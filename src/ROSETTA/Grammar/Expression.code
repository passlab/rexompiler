// #########################################################    -*- C++ -*-
// #########################################################
//                      HEADER CODE
// #########################################################
// #########################################################

HEADER_START

//! This class represents the base class of all the expressions within this grammar.
/*! It contains all the base functionality for the construction, manipulation, and unparsing support.
 */
     public:
       // $CLASSNAME();
       // $CLASSNAME(Sg_File_Info* info);

      //! Function to get user defined attributes (as I recall)
      //  SgAttributePtrList& get_uattributes();

      //! Replace an expression child of this node with another one.
          virtual int replace_expression(SgExpression *oldChild,SgExpression *newChild);

      //! unparsing support for pragmas
      //  void output_pragma(ostream& os);

       // Set pragmas associated with this expression
       // note: pragmas are typically associated with statements not expressions
       // void set_pragma() ROSE_DEPRECATED_FUNCTION;

      //! get the type associated with this expression
          virtual SgType* get_type() const;

       // set the type \attention{why does this not take a parameter?}
       // DQ (1/14/2006): Because the type is computed internally (often from operands stored internally).
       // virtual void set_type();

      //! return precedence (scale of 0-10, as I recall)
          virtual int precedence() const ;

       // DQ (8/21/2004): Support for pragmas (this is the old Sage II support for pragmas)
       // It is largely redundant to the newer statement based pragma support.  However, this
       // is support for pragmas on a expression level.  I'm not clear if this is important
       // to support.
       // void add_pragma(int cnt, SgPragma** plist);
       // SgPragma* add_pragma(char *nm);
       // SgPragma* get_pragma(char *nm) const;
       // int remove_pragma(char *nm);

       // get attribute
       // SgAttribute* get_user_attribute(char *nm) const;
       // SgAttribute* add_user_attribute(char *nm, SgAttribute* attr);
       // int remove_user_attribute(char *nm);

     public:

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
    // Overriding SgNode versions of these
          virtual unsigned int cfgIndexForEnd() const $ROSE_OVERRIDE;
          virtual bool cfgIsIndexInteresting(unsigned int index) const $ROSE_OVERRIDE;
          virtual unsigned int cfgFindChildIndex(SgNode* n) $ROSE_OVERRIDE;
          virtual unsigned int cfgFindNextChildIndex(SgNode* n) $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) $ROSE_OVERRIDE;
#endif

       // get lvalue
          virtual bool isDefinable() const;
          virtual bool isUsedAsDefinable() const;
          virtual bool isLValue() const;
          virtual bool isUsedAsLValue() const; // Calls parent.isChildUsedAsLValue(this)
          virtual bool isChildUsedAsLValue(const SgExpression* child) const; // INTERNAL Recursively call up the chain to answer the child

       // DQ (11/6/2006): use this to return the operatorPosition
       // (instead of the startOfConstruct as it is used for SgStatement objects)
          virtual Sg_File_Info* get_file_info(void) const $ROSE_OVERRIDE;
          virtual void set_file_info(Sg_File_Info* X) $ROSE_OVERRIDE;

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const $ROSE_OVERRIDE;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const $ROSE_OVERRIDE;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const $ROSE_OVERRIDE;
#else
       // DQ (11/1/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

       // DQ (5/29/2011): Added to support for new qualified name generation
      //! This function generates the qualified name prefix to be used with the type referenced by this expression.
          SgName get_qualified_name_prefix() const;

       // DQ (6/2/2011): Added to support for new qualified name generation
      //! This function generates the qualified name prefix to be used with the type referenced by this expression.
          SgName get_qualified_name_prefix_for_referenced_type() const;

       // DQ (6/2/2011): Added virtual functions so that we can define specialized versions at specific IR nodes.
          virtual int  get_name_qualification_length () const;
          virtual void set_name_qualification_length ( int name_qualification_length );
          virtual bool get_type_elaboration_required () const;
          virtual void set_type_elaboration_required ( bool type_elaboration_required );
          virtual bool get_global_qualification_required () const;
          virtual void set_global_qualification_required ( bool global_qualification_required );

       // DQ (4/16/2019): Added virtual functions so that we can define specialized versions at specific IR nodes.
          virtual int  get_name_qualification_for_pointer_to_member_class_length () const;
          virtual void set_name_qualification_for_pointer_to_member_class_length ( int name_qualification_length );
          virtual bool get_type_elaboration_for_pointer_to_member_class_required () const;
          virtual void set_type_elaboration_for_pointer_to_member_class_required ( bool type_elaboration_required );
          virtual bool get_global_qualification_for_pointer_to_member_class_required () const;
          virtual void set_global_qualification_for_pointer_to_member_class_required ( bool global_qualification_required );

       // DQ (9/23/2011): Use the vitual function version so that we can test within ROSE (part of incremental testing of new original expression tree support).
       // DQ (9/19/2011): Put back the original code (non-virtual functions) so that we can test against previously passing tests.
       // DQ (9/16/2011): Modified to make this a virtual function and added set_originalExpressionTree().
       // DQ (6/21/2011): Get the original expression if this is an IR node where it is defined and it is a valid pointer.
#if 1
          virtual SgExpression* get_originalExpressionTree() const;
#else
          SgExpression* get_originalExpressionTree() const;
#endif
#if 1
       // DQ (9/19/2011): Modify this to be virtual as a single step for testing ROSE.
          virtual void set_originalExpressionTree(SgExpression* X);
#else
       // DQ (9/19/2011): Added non-virtual set_originalExpressionTree() function so that code in fixupConstantFoldedValues.C would compile.
          void set_originalExpressionTree(SgExpression* X);
#endif

      /*! \brief Some expressions store internal SgType pointers explicitly while others compute them from other expressions.  This function is true if it has a data member that is a type (pointer, array, etc.).

          Result is true if it stores a type explicitly as a data member, else false.

          \internal True only if this is either a SgTemplateParameterVal, SgComplexVal, SgSizeOfOp, SgAlignOfOp, 
                    SgTypeIdOp, SgVarArgStartOp, SgVarArgStartOneOperandOp, 
                    SgVarArgOp, SgVarArgEndOp, SgVarArgCopyOp, SgNewExp, SgRefExp, SgAggregateInitializer, SgCompoundInitializer,
                    SgConstructorInitializer, SgAssignInitializer, SgPseudoDestructorRefExp.
       */
          bool hasExplicitType();

      /*! \brief Some expressions store internal SgType pointers explicitly, this allows these IR nodes to be reset with new types (used in the snippet support).
       */
          void set_explicitly_stored_type( SgType* type );

HEADER_END


HEADER_X_EXPRESSION_START
       // void post_construction_initialization();
HEADER_X_EXPRESSION_END


HEADER_NON_X_EXPRESSION_START
       // void post_construction_initialization();
HEADER_NON_X_EXPRESSION_END


HEADER_FUNCTIONS_START
HEADER_FUNCTIONS_END

HEADER_GET_TYPE_START
          SgType* get_type() const $ROSE_OVERRIDE;
HEADER_GET_TYPE_END


HEADER_SET_TYPE_START

#error "Error: set_type() is being removed"

       // DQ (1/14/2006): set_type is removed
       // void set_type();

HEADER_SET_TYPE_END


HEADER_POST_CONSTRUCTION_INITIALIZATION_START
          void post_construction_initialization() $ROSE_OVERRIDE;
HEADER_POST_CONSTRUCTION_INITIALIZATION_END


HEADER_PRECEDENCE_START
          int precedence() const $ROSE_OVERRIDE { return PRECEDENCE_VALUE; }
HEADER_PRECEDENCE_END


HEADER_GET_NEXT_EXPRESSION_START
          SgExpression *get_next( int& n) const ROSE_DEPRECATED_FUNCTION;
          int replace_expression( SgExpression *, SgExpression *) $ROSE_OVERRIDE ROSE_DEPRECATED_FUNCTION;
HEADER_GET_NEXT_EXPRESSION_END


HEADER_EXTRA_FUNCTIONS_START
          int length() const ROSE_DEPRECATED_FUNCTION;
          bool empty() const ROSE_DEPRECATED_FUNCTION;
       // void operator_unparse( const char *, Unparse_Info &, ostream & );
HEADER_EXTRA_FUNCTIONS_END

HEADER_LIST_FUNCTIONS_START
          void append_LIST_NAME(SgExpression* what);
       // void insert_LIST_NAME(const SgExpression::iterator & where, SgExpression* what);
       // void insert_LIST_NAME(const SgExpressionPtrList::iterator & where, SgExpression* what);
HEADER_LIST_FUNCTIONS_END

HEADER_UNARY_EXPRESSION_START

          SgExpression* get_operand() const;
          void set_operand (SgExpression * exp);
          SgType* get_type() const $ROSE_OVERRIDE;

       // Enums are not properly scoped in the class declaration and are assigned
       // to a global scope so we have to change the name to make it unique across
       // different grammars
      /*! \brief Enum value defines operators as prefix or postfix, as appropriate, e.g. operator++().

          This enum type provides support for specification of prefix/postfix operators such
          as operator++() using a simpler mechanism thatn that provided by C++.  See C++
          standard for details of specification of prefix and postfix operators.

          \internal There should be an additional value added to support unknown setting (with value 0)
       */
          enum Sgop_mode
             {
               prefix=0 /*! Prefix Operator Specifier */,
               postfix  /*! Postfix Operator Specifier */
             };

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) $ROSE_OVERRIDE;
#endif

HEADER_UNARY_EXPRESSION_END

HEADER_BINARY_EXPRESSION_START
          SgExpression* get_lhs_operand() const;
          void set_lhs_operand(SgExpression * exp);
          SgExpression* get_rhs_operand() const;
          void set_rhs_operand(SgExpression * exp);
          SgType* get_type() const $ROSE_OVERRIDE;

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) $ROSE_OVERRIDE;
#endif

HEADER_BINARY_EXPRESSION_END


HEADER_EXPRESSION_ROOT_EXPRESSION_START
       // QY: 9/30/2004: removed stmt pointer inside exprRoot. Use parent pointer instead.
       // void initialize_root (SgExpression* exp, SgStatement* stmt);

       // DQ (12/17/2006): Removed to clean up code (not used, I think).
       // void set_statement( SgStatement* stmt );
       // SgStatement* get_statement() const;

HEADER_EXPRESSION_ROOT_EXPRESSION_END


HEADER_EXPRESSION_LIST_EXPRESSION_START

          SgExpressionPtrList& get_expressions();
          const SgExpressionPtrList& get_expressions() const;
          void set_expressions(SgExpressionPtrList e_list);

HEADER_LIST_DECLARATIONS

          void prepend_expression(SgExpression *what);

          bool empty() const ROSE_DEPRECATED_FUNCTION;

          //SgExpression* get_first() const ROSE_DEPRECATED_FUNCTION;
          //SgExpression* get_end() const ROSE_DEPRECATED_FUNCTION;
          //int get_index(SgExpression*) const ROSE_DEPRECATED_FUNCTION;

        // void insert_expression(const SgExpressionPtrList::iterator &, SgExpression*);
        // void insert_expression( SgExpression*, SgExpression*, int);

          int replace_expression(SgExpression *o, SgExpression *n) $ROSE_OVERRIDE ROSE_DEPRECATED_FUNCTION;

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) $ROSE_OVERRIDE;
#endif

       // get lvalue
          virtual bool isChildUsedAsLValue(const SgExpression* child) const $ROSE_OVERRIDE; // INTERNAL Recursively call up the chain to answer the child
HEADER_EXPRESSION_LIST_EXPRESSION_END


HEADER_MATRIX_EXP_START
HEADER_MATRIX_EXP_END

HEADER_RANGE_EXP_START
//Append an expression to the range
SgRangeExp* append(SgExpression *exp);
HEADER_RANGE_EXP_END

HEADER_VAR_REF_EXPRESSION_START
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) $ROSE_OVERRIDE;
#endif

       // DQ (11/7/2007): I think this is not used any more.
       // DQ (10/5/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
       // virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;

       // get lvalue
          virtual bool isDefinable() const $ROSE_OVERRIDE;
          virtual bool isLValue() const $ROSE_OVERRIDE;
          virtual bool isChildUsedAsLValue(const SgExpression* child) const $ROSE_OVERRIDE; // INTERNAL Recursively call up the chain to answer the child

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          int get_name_qualification_length() const $ROSE_OVERRIDE;
          void set_name_qualification_length(int name_qualification_length) $ROSE_OVERRIDE;

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_type_elaboration_required() const $ROSE_OVERRIDE;
          void set_type_elaboration_required(bool type_elaboration_required) $ROSE_OVERRIDE;

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_global_qualification_required() const $ROSE_OVERRIDE;
          void set_global_qualification_required(bool global_qualification_required) $ROSE_OVERRIDE;

HEADER_VAR_REF_EXPRESSION_END

HEADER_NONREAL_REF_EXPRESSION_START
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) $ROSE_OVERRIDE;
#endif

          int get_name_qualification_length() const $ROSE_OVERRIDE;
          void set_name_qualification_length(int name_qualification_length) $ROSE_OVERRIDE;

          bool get_type_elaboration_required() const $ROSE_OVERRIDE;
          void set_type_elaboration_required(bool type_elaboration_required) $ROSE_OVERRIDE;

          bool get_global_qualification_required() const $ROSE_OVERRIDE;
          void set_global_qualification_required(bool global_qualification_required) $ROSE_OVERRIDE;
HEADER_NONREAL_REF_EXPRESSION_END

HEADER_COMPOUND_LITERAL_EXPRESSION_START
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) $ROSE_OVERRIDE;
#endif

       // get lvalue
          virtual bool isDefinable() const $ROSE_OVERRIDE;
          virtual bool isLValue() const $ROSE_OVERRIDE;
          virtual bool isChildUsedAsLValue(const SgExpression* child) const $ROSE_OVERRIDE; // INTERNAL Recursively call up the chain to answer the child
HEADER_COMPOUND_LITERAL_EXPRESSION_END


HEADER_LABEL_REF_EXPRESSION_START

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) $ROSE_OVERRIDE;
#endif

          SgName get_name() const;
       // const SgName & get_name() const;

          int get_numeric_label_value() const;

       // DQ (12/30/2007): I don't think there is any control flow through this sorts of variables, but this
       // should be discussed (might apply to assigned goto).
       // virtual unsigned int cfgIndexForEnd() const;
       // virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index);
       // virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index);

       // DQ (2/2/2011): This is support for Fortran alternative return type arguments.
      //! Support for recognition of Fortran alternative return type arguments.
          bool isFunctionCallArgumentForAlternativeReturnType() const;

HEADER_LABEL_REF_EXPRESSION_END


HEADER_LAMBDA_EXPRESSION_START
HEADER_LAMBDA_EXPRESSION_END


HEADER_CLASS_NAME_REF_EXPRESSION_START
HEADER_CLASS_NAME_REF_EXPRESSION_END


HEADER_FUNCTION_REF_EXPRESSION_START
          SgFunctionSymbol* get_symbol() const;
          void set_symbol(SgFunctionSymbol * symbol);

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) $ROSE_OVERRIDE;
#endif

      /** Returns the associated function declaration, if it can be resolved statically. In some cases,
      * such as function pointers and virtual functions, the function called cannot be resolved statically;
      * for those cases this function returns NULL. The actual function expression is available through
      * get_function(). */
          SgFunctionDeclaration* getAssociatedFunctionDeclaration() const;

//       // get lvalue
//          virtual bool isLValue() const;
//          virtual bool isChildUsedAsLValue(const SgExpression* child) const; // INTERNAL Recursively call up the chain to answer the child

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          int get_name_qualification_length() const $ROSE_OVERRIDE;
          void set_name_qualification_length(int name_qualification_length) $ROSE_OVERRIDE;

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_type_elaboration_required() const $ROSE_OVERRIDE;
          void set_type_elaboration_required(bool type_elaboration_required) $ROSE_OVERRIDE;

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_global_qualification_required() const $ROSE_OVERRIDE;
          void set_global_qualification_required(bool global_qualification_required) $ROSE_OVERRIDE;

HEADER_FUNCTION_REF_EXPRESSION_END


HEADER_MEMBER_FUNCTION_REF_EXPRESSION_START
          SgMemberFunctionSymbol* get_symbol() const;
          void set_symbol(SgMemberFunctionSymbol * symbol);

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) $ROSE_OVERRIDE;
#endif

          //! This is helpful in chasing down the associated declaration to this member function reference.
      //! Note: This function can return NULL - for example when the function call occurs through a function
      //! pointer.
          SgMemberFunctionDeclaration* getAssociatedMemberFunctionDeclaration() const;

       // get lvalue
          virtual bool isLValue() const $ROSE_OVERRIDE;
          virtual bool isChildUsedAsLValue(const SgExpression* child) const $ROSE_OVERRIDE; // INTERNAL Recursively call up the chain to answer the child

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          int get_name_qualification_length() const $ROSE_OVERRIDE;
          void set_name_qualification_length(int name_qualification_length) $ROSE_OVERRIDE;

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_type_elaboration_required() const $ROSE_OVERRIDE;
          void set_type_elaboration_required(bool type_elaboration_required) $ROSE_OVERRIDE;

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_global_qualification_required() const $ROSE_OVERRIDE;
          void set_global_qualification_required(bool global_qualification_required) $ROSE_OVERRIDE;

HEADER_MEMBER_FUNCTION_REF_EXPRESSION_END


HEADER_TEMPLATE_FUNCTION_REF_EXPRESSION_START
       // SgTemplateSymbol* get_symbol() const;
       // void set_symbol(SgTemplateSymbol * symbol);
          SgTemplateFunctionSymbol* get_symbol() const;
          void set_symbol(SgTemplateFunctionSymbol * symbol);

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) $ROSE_OVERRIDE;
#endif

      /** Returns the associated function declaration, if it can be resolved statically. In some cases,
      * such as function pointers and virtual functions, the function called cannot be resolved statically;
      * for those cases this function returns NULL. The actual function expression is available through
      * get_function(). */
          SgTemplateFunctionDeclaration* getAssociatedFunctionDeclaration() const;

//       // get lvalue
//          virtual bool isLValue() const;
//          virtual bool isChildUsedAsLValue(const SgExpression* child) const; // INTERNAL Recursively call up the chain to answer the child

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          int get_name_qualification_length() const $ROSE_OVERRIDE;
          void set_name_qualification_length(int name_qualification_length) $ROSE_OVERRIDE;

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_type_elaboration_required() const $ROSE_OVERRIDE;
          void set_type_elaboration_required(bool type_elaboration_required) $ROSE_OVERRIDE;

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_global_qualification_required() const $ROSE_OVERRIDE;
          void set_global_qualification_required(bool global_qualification_required) $ROSE_OVERRIDE;

HEADER_TEMPLATE_FUNCTION_REF_EXPRESSION_END


HEADER_TEMPLATE_MEMBER_FUNCTION_REF_EXPRESSION_START
       // SgTemplateSymbol* get_symbol() const;
       // void set_symbol(SgTemplateSymbol * symbol);
          SgTemplateMemberFunctionSymbol* get_symbol() const;
          void set_symbol(SgTemplateMemberFunctionSymbol * symbol);

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) $ROSE_OVERRIDE;
#endif

        //! This is helpful in chasing down the associated declaration to this member function reference.
      //! Note: This function can return NULL - for example when the function call occurs through a function
      //! pointer.
          SgTemplateMemberFunctionDeclaration* getAssociatedMemberFunctionDeclaration() const;

       // DQ (12/15/2011): We might require this...
       // get lvalue
       // virtual bool isLValue() const;
       // virtual bool isChildUsedAsLValue(const SgExpression* child) const; // INTERNAL Recursively call up the chain to answer the child

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          int  get_name_qualification_length() const $ROSE_OVERRIDE;
          void set_name_qualification_length(int name_qualification_length) $ROSE_OVERRIDE;

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_type_elaboration_required() const $ROSE_OVERRIDE;
          void set_type_elaboration_required(bool type_elaboration_required) $ROSE_OVERRIDE;

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_global_qualification_required() const $ROSE_OVERRIDE;
          void set_global_qualification_required(bool global_qualification_required) $ROSE_OVERRIDE;

HEADER_TEMPLATE_MEMBER_FUNCTION_REF_EXPRESSION_END


HEADER_VALUE_EXPRESSION_START
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) $ROSE_OVERRIDE;
#endif

       // DQ (2/12/2011): Added const so that this could be called in get_mangled() (and more generally).
       // DQ (8/18/2009): Added support to get the constant folded value as a string instead of the expression tree.
       // std::string get_constant_folded_value_as_string();
          std::string get_constant_folded_value_as_string() const;

HEADER_VALUE_EXPRESSION_END


HEADER_BOOLEAN_VALUE_EXPRESSION_START
HEADER_BOOLEAN_VALUE_EXPRESSION_END


HEADER_NULLPTR_VALUE_EXPRESSION_START
HEADER_NULLPTR_VALUE_EXPRESSION_END


HEADER_VOID_VALUE_EXPRESSION_START
HEADER_VOID_VALUE_EXPRESSION_END


HEADER_STRING_VALUE_EXPRESSION_START
      // DQ (3/25/2006): This is not generated by ROSETTA automatically (using C++ style string type)
      // $CLASSNAME( Sg_File_Info* file_info = NULL, char* value = NULL );
      // ~$CLASSNAME();

       // get lvalue
          virtual bool isLValue() const $ROSE_OVERRIDE;
          virtual bool isChildUsedAsLValue(const SgExpression* child) const $ROSE_OVERRIDE; // INTERNAL Recursively call up the chain to answer the child

       // PP (4/25/21) implement usesSingleQuote and usesDoubleQuote based on
       //              stringDelimiter for backward compatibility.
          bool get_usesSingleQuotes() const    { return get_stringDelimiter() == '\''; }
          bool get_usesDoubleQuotes() const    { return get_stringDelimiter() == '"'; }

          void set_usesSingleQuotes(bool usesSingleQuotes);
          void set_usesDoubleQuotes(bool usesDoubleQuotes);
HEADER_STRING_VALUE_EXPRESSION_END


HEADER_SHORT_VALUE_EXPRESSION_START
HEADER_SHORT_VALUE_EXPRESSION_END


HEADER_CHAR_VALUE_EXPRESSION_START
HEADER_CHAR_VALUE_EXPRESSION_END


HEADER_UNSIGNED_CHAR_VALUE_EXPRESSION_START
HEADER_UNSIGNED_CHAR_VALUE_EXPRESSION_END


HEADER_WCHAR_VALUE_EXPRESSION_START
          wchar_t get_value() const;
          void set_value(wchar_t new_val);

HEADER_WCHAR_VALUE_EXPRESSION_END


HEADER_CHAR16_VALUE_EXPRESSION_START
       // DQ (2/16/2018): ROSE needs to be able to be compiled on non C++11 systems where char_32_t is not defiled.
       // char16_t get_value() const;
       // void set_value(char16_t new_val);
          unsigned short get_value() const;
          void set_value(unsigned short new_val);

HEADER_CHAR16_VALUE_EXPRESSION_END


HEADER_CHAR32_VALUE_EXPRESSION_START
       // DQ (2/16/2018): ROSE needs to be able to be compiled on non C++11 systems where char_32_t is not defiled.
       // char32_t get_value() const;
       // void set_value(char32_t new_val);
          unsigned int get_value() const;
          void set_value(unsigned int new_val);

HEADER_CHAR32_VALUE_EXPRESSION_END


HEADER_UNSIGNED_SHORT_VALUE_EXPRESSION_START
HEADER_UNSIGNED_SHORT_VALUE_EXPRESSION_END


HEADER_INT_VALUE_EXPRESSION_START
HEADER_INT_VALUE_EXPRESSION_END


HEADER_ENUM_VALUE_EXPRESSION_START

       // DQ (2/5/2020): Addedin custom get_type() function so that we can pass the associated SgEnumDeclaration.
       // This code is already generated by ROSETTA, so we don't need to specify this here.
       // SgType* get_type() const $ROSE_OVERRIDE;

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          int get_name_qualification_length() const $ROSE_OVERRIDE;
          void set_name_qualification_length(int name_qualification_length) $ROSE_OVERRIDE;

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_type_elaboration_required() const $ROSE_OVERRIDE;
          void set_type_elaboration_required(bool type_elaboration_required) $ROSE_OVERRIDE;

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_global_qualification_required() const $ROSE_OVERRIDE;
          void set_global_qualification_required(bool global_qualification_required) $ROSE_OVERRIDE;

HEADER_ENUM_VALUE_EXPRESSION_END


HEADER_UNSIGNED_INT_VALUE_EXPRESSION_START
HEADER_UNSIGNED_INT_VALUE_EXPRESSION_END


HEADER_LONG_INT_VALUE_EXPRESSION_START
HEADER_LONG_INT_VALUE_EXPRESSION_END


HEADER_LONG_LONG_VALUE_EXPRESSION_START
HEADER_LONG_LONG_VALUE_EXPRESSION_END


HEADER_UNSIGNED_LONG_LONG_VALUE_EXPRESSION_START
HEADER_UNSIGNED_LONG_LONG_VALUE_EXPRESSION_END


HEADER_UNSIGNED_LONG_VALUE_EXPRESSION_START
HEADER_UNSIGNED_LONG_VALUE_EXPRESSION_END


HEADER_FLOAT_VALUE_EXPRESSION_START
HEADER_FLOAT_VALUE_EXPRESSION_END


HEADER_DOUBLE_VALUE_EXPRESSION_START
HEADER_DOUBLE_VALUE_EXPRESSION_END


HEADER_LONG_DOUBLE_VALUE_EXPRESSION_START
HEADER_LONG_DOUBLE_VALUE_EXPRESSION_END

HEADER_FLOAT_80_VALUE_EXPRESSION_START
HEADER_FLOAT_80_VALUE_EXPRESSION_END

HEADER_FLOAT_128_VALUE_EXPRESSION_START
HEADER_FLOAT_128_VALUE_EXPRESSION_END

HEADER_TEMPLATE_PARAMETER_VALUE_EXPRESSION_START

       // DQ (11/28/2011): Added to support template declarations in the AST.
          SgName get_template_parameter_name() const;

          SgType* get_type() const $ROSE_OVERRIDE;

HEADER_TEMPLATE_PARAMETER_VALUE_EXPRESSION_END


HEADER_COMPLEX_VALUE_EXPRESSION_START
HEADER_COMPLEX_VALUE_EXPRESSION_END

// HEADER_LABEL_ADDRESS_VALUE_EXPRESSION_START
// HEADER_LABEL_ADDRESS_VALUE_EXPRESSION_END

HEADER_UPC_THREADS_EXPRESSION_START
HEADER_UPC_THREADS_EXPRESSION_END

HEADER_UPC_MYTHREAD_EXPRESSION_START
HEADER_UPC_MYTHREAD_EXPRESSION_END

HEADER_YIELD_EXPRESSION_START
HEADER_YIELD_EXPRESSION_END

// DQ (7/25/2020): Adding C++17 language features (required for C++20 support).
HEADER_AWAIT_EXPRESSION_START
HEADER_AWAIT_EXPRESSION_END

// DQ (7/25/2020): Adding C++17 language features (required for C++20 support).
HEADER_FOLD_EXPRESSION_START
HEADER_FOLD_EXPRESSION_END

// DQ (7/25/2020): Adding C++17 language features (required for C++20 support).
HEADER_CHOOSE_EXPRESSION_START
HEADER_CHOOSE_EXPRESSION_END

// DQ (7/25/2020): Adding C++20 language features.
HEADER_SPACESHIP_OPERATOR_START
HEADER_SPACESHIP_OPERATOR_END


HEADER_CALL_EXPRESSION_START
HEADER_LIST_DECLARATIONS
HEADER_CALL_EXPRESSION_END

HEADER_FUNCTION_CALL_EXPRESSION_START

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) $ROSE_OVERRIDE;
#endif

      /** Returns the associated function declaration, if it can be resolved statically. In some cases,
      * such as function pointers and virtual functions, the function called cannot be resolved statically;
      * for those cases this function returns NULL. The actual function expression is available through
      * get_function(). */
          SgFunctionDeclaration* getAssociatedFunctionDeclaration() const;

      /** Returns the associated function symbol, if it can be resolved statically. In some cases,
      * such as function pointers and virtual functions, the function called cannot be resolved statically;
      * for those cases this function returns NULL. The actual function expression is available through
      * get_function(). */
          SgFunctionSymbol* getAssociatedFunctionSymbol() const;

       // get lvalue
          virtual bool isLValue() const $ROSE_OVERRIDE;
          virtual bool isChildUsedAsLValue(const SgExpression* child) const $ROSE_OVERRIDE; // INTERNAL Recursively call up the chain to answer the child

HEADER_FUNCTION_CALL_EXPRESSION_END

HEADER_TYPE_TRAIT_BUILTIN_OPERATOR_START

       // DQ (7/13/2013): I have verified that we need implementations of these functions for the CFG support.
       // DQ (7/12/2013): Not clear if we need these functions since the buildin functions are all pure and lack definitions.
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) $ROSE_OVERRIDE;
#endif

       // DQ (7/12/2013): Not clear if we need these functions since the buildin functions are all pure.
       // get lvalue
       // virtual bool isLValue() const;
       // virtual bool isChildUsedAsLValue(const SgExpression* child) const; // INTERNAL Recursively call up the chain to answer the child

HEADER_TYPE_TRAIT_BUILTIN_OPERATOR_END

HEADER_ARROW_EXPRESSION_START
          SgType* get_type() const $ROSE_OVERRIDE;

       // get lvalue
          virtual bool isLValue() const $ROSE_OVERRIDE;
          virtual bool isChildUsedAsLValue(const SgExpression* child) const $ROSE_OVERRIDE; // INTERNAL Recursively call up the chain to answer the child

       // DQ (7/16/2014): Shared types from expressions in UPC have some expected symantics that are not a matter of returning the result of get_type().
       // This function supports the get_type() function.
          SgType* checkForSharedTypeAndReturnSharedType( SgType* possibleReturnType ) const;

HEADER_ARROW_EXPRESSION_END


HEADER_DOT_EXPRESSION_START
          SgType* get_type() const $ROSE_OVERRIDE;

       // get lvalue
          virtual bool isLValue() const $ROSE_OVERRIDE;
          virtual bool isChildUsedAsLValue(const SgExpression* child) const $ROSE_OVERRIDE; // INTERNAL Recursively call up the chain to answer the child

HEADER_DOT_EXPRESSION_END


HEADER_DOT_STAR_OPERATOR_START
          SgType* get_type() const $ROSE_OVERRIDE;

       // get lvalue
          virtual bool isLValue() const $ROSE_OVERRIDE;
          virtual bool isChildUsedAsLValue(const SgExpression* child) const $ROSE_OVERRIDE; // INTERNAL Recursively call up the chain to answer the child

HEADER_DOT_STAR_OPERATOR_END


HEADER_ARROW_STAR_OPERATOR_START
          SgType* get_type() const $ROSE_OVERRIDE;

       // get lvalue
          virtual bool isLValue() const $ROSE_OVERRIDE;
          virtual bool isChildUsedAsLValue(const SgExpression* child) const $ROSE_OVERRIDE; // INTERNAL Recursively call up the chain to answer the child

HEADER_ARROW_STAR_OPERATOR_END


HEADER_BOOLEAN_GET_TYPE_START
       // DQ (3/23/2017): This is used as ROSE_OVERRIDE instead of $ROSE_OVERRIDE since the order of the editing to build the generated code appears to be important.
       // DQ (6/20/2006): Used for all relational operators
          virtual SgType* get_type() const ROSE_OVERRIDE;
HEADER_BOOLEAN_GET_TYPE_END

HEADER_EQUALITY_OPERATOR_START
HEADER_BOOLEAN_GET_TYPE_MEMBER_FUNCTION
HEADER_EQUALITY_OPERATOR_END

HEADER_LESS_THAN_OPERATOR_START
HEADER_BOOLEAN_GET_TYPE_MEMBER_FUNCTION
HEADER_LESS_THAN_OPERATOR_END

HEADER_GREATER_THAN_OPERATOR_START
HEADER_BOOLEAN_GET_TYPE_MEMBER_FUNCTION
HEADER_GREATER_THAN_OPERATOR_END

HEADER_NOT_EQUAL_OPERATOR_START
HEADER_BOOLEAN_GET_TYPE_MEMBER_FUNCTION
HEADER_NOT_EQUAL_OPERATOR_END

HEADER_LESS_OR_EQUAL_OPERATOR_START
HEADER_BOOLEAN_GET_TYPE_MEMBER_FUNCTION
HEADER_LESS_OR_EQUAL_OPERATOR_END

HEADER_GREATER_OR_EQUAL_OPERATOR_START
HEADER_BOOLEAN_GET_TYPE_MEMBER_FUNCTION
HEADER_GREATER_OR_EQUAL_OPERATOR_END


HEADER_ADD_OPERATOR_START
HEADER_ADD_OPERATOR_END

HEADER_SUBTRACT_OPERATOR_START
HEADER_SUBTRACT_OPERATOR_END


HEADER_MULTIPLY_OPERATOR_START
HEADER_MULTIPLY_OPERATOR_END


HEADER_DIVIDE_OPERATOR_START
HEADER_DIVIDE_OPERATOR_END


HEADER_INTEGER_DIVIDE_OPERATOR_START
HEADER_INTEGER_DIVIDE_OPERATOR_END


HEADER_MOD_OPERATOR_START
HEADER_MOD_OPERATOR_END

HEADER_MEMBERSHIP_OP_START
HEADER_BOOLEAN_GET_TYPE_MEMBER_FUNCTION
HEADER_MEMBERSHIP_OP_END

HEADER_NON_MEMBERSHIP_OP_START
HEADER_BOOLEAN_GET_TYPE_MEMBER_FUNCTION
HEADER_NON_MEMBERSHIP_OP_END

HEADER_IS_OP_START
HEADER_BOOLEAN_GET_TYPE_MEMBER_FUNCTION
HEADER_IS_OP_END

HEADER_IS_NOT_OP_START
HEADER_BOOLEAN_GET_TYPE_MEMBER_FUNCTION
HEADER_IS_NOT_OP_END

HEADER_NARY_OP_START

    SgExpressionPtrList& get_operands();
    const SgExpressionPtrList& get_operands() const;

    VariantTList& get_operators();
    const VariantTList& get_operators() const;

    virtual void append_operation(VariantT sg_operator, SgExpression* operand);

HEADER_NARY_OP_END

HEADER_NARY_COMPARISON_OP_START
    virtual SgType* get_type() const $ROSE_OVERRIDE;
HEADER_NARY_COMPARISON_OP_END

HEADER_NARY_BOOLEAN_OP_START
    virtual SgType* get_type() const $ROSE_OVERRIDE;
HEADER_NARY_BOOLEAN_OP_END


HEADER_AND_OPERATOR_START
          SgType* get_type() const $ROSE_OVERRIDE;

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual bool cfgIsIndexInteresting(unsigned int) const $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) $ROSE_OVERRIDE;
#endif

HEADER_AND_OPERATOR_END


HEADER_OR_OPERATOR_START
          SgType* get_type() const $ROSE_OVERRIDE;

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual bool cfgIsIndexInteresting(unsigned int) const $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) $ROSE_OVERRIDE;
#endif

HEADER_OR_OPERATOR_END


HEADER_BIT_XOR_OPERATOR_START
HEADER_BIT_XOR_OPERATOR_END

HEADER_BIT_AND_OPERATOR_START
HEADER_BIT_AND_OPERATOR_END

HEADER_BIT_OR_OPERATOR_START
HEADER_BIT_OR_OPERATOR_END

// CR (4/28/2020): Added SgBitEqvOp to support the Jovial bitwise operator.
HEADER_BIT_EQV_OPERATOR_START
HEADER_BIT_EQV_OPERATOR_END


HEADER_COMMA_OPERATOR_EXPRESSION_START

       // get the type associated with this expression (using the rhs)
          virtual SgType* get_type() const $ROSE_OVERRIDE;

       // get lvalue
          virtual bool isLValue() const $ROSE_OVERRIDE;
          virtual bool isChildUsedAsLValue(const SgExpression* child) const $ROSE_OVERRIDE; // INTERNAL Recursively call up the chain to answer the child

HEADER_COMMA_OPERATOR_EXPRESSION_END


HEADER_LEFT_SHIFT_OPERATOR_START
HEADER_LEFT_SHIFT_OPERATOR_END


HEADER_RIGHT_SHIFT_OPERATOR_START
HEADER_RIGHT_SHIFT_OPERATOR_END

HEADER_MINUS_OPERATOR_START
HEADER_MINUS_OPERATOR_END

HEADER_MATRIX_TRANSPOSE_OPERATOR_START
HEADER_MATRIX_TRANSPOSE_OPERATOR_END

HEADER_UNARY_ADD_OPERATOR_START
HEADER_UNARY_ADD_OPERATOR_END


HEADER_SIZEOF_OPERATOR_START
 // Liao, 11/17/2009
          int replace_expression(SgExpression*, SgExpression*) $ROSE_OVERRIDE ROSE_DEPRECATED_FUNCTION;

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) $ROSE_OVERRIDE;
#endif

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          int get_name_qualification_length() const $ROSE_OVERRIDE;
          void set_name_qualification_length(int name_qualification_length) $ROSE_OVERRIDE;

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_type_elaboration_required() const $ROSE_OVERRIDE;
          void set_type_elaboration_required(bool type_elaboration_required) $ROSE_OVERRIDE;

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_global_qualification_required() const $ROSE_OVERRIDE;
          void set_global_qualification_required(bool global_qualification_required) $ROSE_OVERRIDE;

       // DQ (4/15/2019): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          int get_name_qualification_for_pointer_to_member_class_length() const $ROSE_OVERRIDE;
          void set_name_qualification_for_pointer_to_member_class_length(int name_qualification_length) $ROSE_OVERRIDE;

       // DQ (4/15/2019): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_type_elaboration_for_pointer_to_member_class_required() const $ROSE_OVERRIDE;
          void set_type_elaboration_for_pointer_to_member_class_required(bool type_elaboration_required) $ROSE_OVERRIDE;

       // DQ (4/15/2019): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_global_qualification_for_pointer_to_member_class_required() const $ROSE_OVERRIDE;
          void set_global_qualification_for_pointer_to_member_class_required(bool global_qualification_required) $ROSE_OVERRIDE;

HEADER_SIZEOF_OPERATOR_END


HEADER_ALIGNOF_OPERATOR_START
          int replace_expression(SgExpression*, SgExpression*) $ROSE_OVERRIDE ROSE_DEPRECATED_FUNCTION;

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) $ROSE_OVERRIDE;
#endif

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          int  get_name_qualification_length() const $ROSE_OVERRIDE;
          void set_name_qualification_length(int name_qualification_length) $ROSE_OVERRIDE;

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_type_elaboration_required() const $ROSE_OVERRIDE;
          void set_type_elaboration_required(bool type_elaboration_required) $ROSE_OVERRIDE;

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_global_qualification_required() const $ROSE_OVERRIDE;
          void set_global_qualification_required(bool global_qualification_required) $ROSE_OVERRIDE;

HEADER_ALIGNOF_OPERATOR_END


HEADER_NOEXCEPT_OPERATOR_START
       // DQ (2/4/2015): Let's not build this if we don't need it.
       // int replace_expression(SgExpression*, SgExpression*) ROSE_DEPRECATED_FUNCTION;

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) $ROSE_OVERRIDE;
#endif

HEADER_NOEXCEPT_OPERATOR_END


HEADER_TYPE_ID_OPERATOR_START
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) $ROSE_OVERRIDE;
#endif

       // get lvalue
          virtual bool isLValue() const $ROSE_OVERRIDE;
          virtual bool isChildUsedAsLValue(const SgExpression* child) const $ROSE_OVERRIDE; // INTERNAL Recursively call up the chain to answer the child

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          int get_name_qualification_length() const $ROSE_OVERRIDE;
          void set_name_qualification_length(int name_qualification_length) $ROSE_OVERRIDE;

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_type_elaboration_required() const $ROSE_OVERRIDE;
          void set_type_elaboration_required(bool type_elaboration_required) $ROSE_OVERRIDE;

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_global_qualification_required() const $ROSE_OVERRIDE;
          void set_global_qualification_required(bool global_qualification_required) $ROSE_OVERRIDE;

       // DQ (4/15/2019): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          int get_name_qualification_for_pointer_to_member_class_length() const $ROSE_OVERRIDE;
          void set_name_qualification_for_pointer_to_member_class_length(int name_qualification_length) $ROSE_OVERRIDE;

       // DQ (4/15/2019): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_type_elaboration_for_pointer_to_member_class_required() const $ROSE_OVERRIDE;
          void set_type_elaboration_for_pointer_to_member_class_required(bool type_elaboration_required) $ROSE_OVERRIDE;

       // DQ (4/15/2019): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_global_qualification_for_pointer_to_member_class_required() const $ROSE_OVERRIDE;
          void set_global_qualification_for_pointer_to_member_class_required(bool global_qualification_required) $ROSE_OVERRIDE;

HEADER_TYPE_ID_OPERATOR_END

HEADER_VARARG_START_OPERATOR_START
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) $ROSE_OVERRIDE;
#endif

HEADER_VARARG_START_OPERATOR_END

HEADER_VARARG_OPERATOR_START

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) $ROSE_OVERRIDE;
#endif

          int replace_expression(SgExpression*, SgExpression*) $ROSE_OVERRIDE ROSE_DEPRECATED_FUNCTION;
       // void set_type( SgType* type );

HEADER_VARARG_OPERATOR_END

HEADER_VARARG_END_OPERATOR_START
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) $ROSE_OVERRIDE;
#endif

          int replace_expression(SgExpression*, SgExpression*) $ROSE_OVERRIDE ROSE_DEPRECATED_FUNCTION;

HEADER_VARARG_END_OPERATOR_END

HEADER_NOT_OPERATOR_START
          SgType* get_type() const $ROSE_OVERRIDE;

HEADER_NOT_OPERATOR_END


HEADER_POINTER_DEREF_EXPRESSION_START
          SgType* get_type() const $ROSE_OVERRIDE;

       // get lvalue
          virtual bool isLValue() const $ROSE_OVERRIDE;
          virtual bool isChildUsedAsLValue(const SgExpression* child) const $ROSE_OVERRIDE; // INTERNAL Recursively call up the chain to answer the child

HEADER_POINTER_DEREF_EXPRESSION_END


HEADER_ADDRESS_OF_OPERATOR_START
          SgType* get_type() const $ROSE_OVERRIDE;

       // get lvalue
          virtual bool isLValue() const $ROSE_OVERRIDE;
          virtual bool isChildUsedAsLValue(const SgExpression* child) const $ROSE_OVERRIDE; // INTERNAL Recursively call up the chain to answer the child

       // DQ (7/16/2014): Shared types from expressions in UPC have some expected symantics that are not a matter of returning the result of get_type().
       // This function supports the get_type() function.
          SgType* checkForSharedTypeAndReturnSharedType( SgType* possibleReturnType ) const;

HEADER_ADDRESS_OF_OPERATOR_END


HEADER_MINUS_MINUS_OPERATOR_START
          $CLASSNAME ( Sg_File_Info* file_info, SgExpression* operand_i, Sgop_mode a_mode );
          $CLASSNAME ( SgExpression* operand_i, Sgop_mode a_mode );

       // get lvalue
          virtual bool isLValue() const $ROSE_OVERRIDE;
          virtual bool isChildUsedAsLValue(const SgExpression* child) const $ROSE_OVERRIDE; // INTERNAL Recursively call up the chain to answer the child

HEADER_MINUS_MINUS_OPERATOR_END


HEADER_PLUS_PLUS_OPERATOR_START
          $CLASSNAME ( Sg_File_Info* file_info, SgExpression* operand_i, Sgop_mode a_mode );
          $CLASSNAME ( SgExpression* operand_i, Sgop_mode a_mode );

       // get lvalue
          virtual bool isLValue() const $ROSE_OVERRIDE;
          virtual bool isChildUsedAsLValue(const SgExpression* child) const $ROSE_OVERRIDE; // INTERNAL Recursively call up the chain to answer the child

HEADER_PLUS_PLUS_OPERATOR_END


HEADER_BIT_COMPLEMENT_OPERATOR_START
HEADER_BIT_COMPLEMENT_OPERATOR_END


HEADER_REAL_PART_OPERATOR_START
HEADER_REAL_PART_OPERATOR_END


HEADER_IMAG_PART_OPERATOR_START
HEADER_IMAG_PART_OPERATOR_END


HEADER_CONJUGATE_OPERATOR_START
HEADER_CONJUGATE_OPERATOR_END

HEADER_CONDITIONAL_EXPRESSION_START
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const $ROSE_OVERRIDE;
          virtual bool cfgIsIndexInteresting(unsigned int) const $ROSE_OVERRIDE;
          virtual unsigned int cfgFindChildIndex(SgNode* n) $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) $ROSE_OVERRIDE;
#endif

       // get lvalue
          virtual bool isLValue() const $ROSE_OVERRIDE;
          virtual bool isChildUsedAsLValue(const SgExpression* child) const $ROSE_OVERRIDE; // INTERNAL Recursively call up the chain to answer the child

HEADER_CONDITIONAL_EXPRESSION_END


HEADER_CAST_EXPRESSION_START
       // DQ (6/14/2005): Modified to make enum name consistant with elsewhere in ROSE (Sage III)
       // enum Sg_e_cast_type
      /*! \brief Classification of Casts

          Must be either C style cast or C++ style const_cast<>, static_cast<>,
          dynamic_cast<>, or reinterpret_cast<>.

          \internal Only a single value is permited.
       */
          enum cast_type_enum
             {
               e_unknown               = 0, /*!< Unknown value (error value) */
               e_default               = 1, /*!< Default value (default) */
               e_C_style_cast          = 2, /*!< C style cast */
               e_const_cast            = 3, /*!< C++ const cast */
               e_static_cast           = 4, /*!< C++ static cast */
               e_dynamic_cast          = 5, /*!< C++ dynamic cast */
               e_reinterpret_cast      = 6,  /*!< C++ reinterpret cast */
            // DQ (8/22/2016): Adding more comprehensive setting of cast semantics (as part of improved C++ cast support).
            // Not clear if these really need to be present.
            // e_reference_cast        = 7, /*!< C++ reference cast (base class cast) */
            // e_rvalue_reference_cast = 8,  /*!< C++ rvalue reference cast (base class cast to rvalue) */
               e_safe_cast             = 8, /*!< C++ MSVC specific safe cast */
               e_last_cast  /*!< Last entry in enum of cast types */
             };

       // Sg_e_cast_type cast_type();
          cast_type_enum cast_type() const;

       // DQ (1/16/2006): Added to support special version of get_type which uses the p_expression_type
       // (one of the few places where we have to store the expression type explicitly).
          SgType* get_type() const $ROSE_OVERRIDE;

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgFindChildIndex(SgNode* n) $ROSE_OVERRIDE; // CFG children do not match traversalSuccessorContainer
#endif

       // DQ (1/17/2008): Added to permit the type to be set.
          void set_type (SgType* type);

       // get lvalue
          virtual bool isLValue() const $ROSE_OVERRIDE;
          virtual bool isChildUsedAsLValue(const SgExpression* child) const $ROSE_OVERRIDE; // INTERNAL Recursively call up the chain to answer the child

       // DQ (10/24/2014): Added support to determine when cast should be allowable.
       // This is used in the SageInterace support for evaluation of constant expressions.
          bool cast_looses_precision();

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          int get_name_qualification_length() const $ROSE_OVERRIDE;
          void set_name_qualification_length(int name_qualification_length) $ROSE_OVERRIDE;

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_type_elaboration_required() const $ROSE_OVERRIDE;
          void set_type_elaboration_required(bool type_elaboration_required) $ROSE_OVERRIDE;

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_global_qualification_required() const $ROSE_OVERRIDE;
          void set_global_qualification_required(bool global_qualification_required) $ROSE_OVERRIDE;

          static std::string cast_type_to_string ( enum cast_type_enum );

       // DQ (4/15/2019): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          int get_name_qualification_for_pointer_to_member_class_length() const $ROSE_OVERRIDE;
          void set_name_qualification_for_pointer_to_member_class_length(int name_qualification_length) $ROSE_OVERRIDE;

       // DQ (4/15/2019): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_type_elaboration_for_pointer_to_member_class_required() const $ROSE_OVERRIDE;
          void set_type_elaboration_for_pointer_to_member_class_required(bool type_elaboration_required) $ROSE_OVERRIDE;

       // DQ (4/15/2019): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_global_qualification_for_pointer_to_member_class_required() const $ROSE_OVERRIDE;
          void set_global_qualification_for_pointer_to_member_class_required(bool global_qualification_required) $ROSE_OVERRIDE;

HEADER_CAST_EXPRESSION_END


HEADER_POINTER_ARRAY_REFERENCE_EXPRESSION_START
       // DQ (1/16/2006): Added to support special version of get_type.
       // returns get_lhs_operand()->get_type()  (maybe we should call get_base_type() ???)
          SgType* get_type() const $ROSE_OVERRIDE;

       // get lvalue
          virtual bool isLValue() const $ROSE_OVERRIDE;
          virtual bool isChildUsedAsLValue(const SgExpression* child) const $ROSE_OVERRIDE; // INTERNAL Recursively call up the chain to answer the child

HEADER_POINTER_ARRAY_REFERENCE_EXPRESSION_END


HEADER_NEW_OPERATOR_EXPRESSION_START
       // DQ (1/16/2006): Added to support special version of get_type.
       // returns SgPointerType::createType(p_expression_type)
       // SgType* get_type() const;

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const $ROSE_OVERRIDE;
          virtual unsigned int cfgFindChildIndex(SgNode* n) $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) $ROSE_OVERRIDE;
#endif

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          int get_name_qualification_length() const $ROSE_OVERRIDE;
          void set_name_qualification_length(int name_qualification_length) $ROSE_OVERRIDE;

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_type_elaboration_required() const $ROSE_OVERRIDE;
          void set_type_elaboration_required(bool type_elaboration_required) $ROSE_OVERRIDE;

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_global_qualification_required() const $ROSE_OVERRIDE;
          void set_global_qualification_required(bool global_qualification_required) $ROSE_OVERRIDE;

       // DQ (4/15/2019): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          int get_name_qualification_for_pointer_to_member_class_length() const $ROSE_OVERRIDE;
          void set_name_qualification_for_pointer_to_member_class_length(int name_qualification_length) $ROSE_OVERRIDE;

       // DQ (4/15/2019): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_type_elaboration_for_pointer_to_member_class_required() const $ROSE_OVERRIDE;
          void set_type_elaboration_for_pointer_to_member_class_required(bool type_elaboration_required) $ROSE_OVERRIDE;

       // DQ (4/15/2019): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_global_qualification_for_pointer_to_member_class_required() const $ROSE_OVERRIDE;
          void set_global_qualification_for_pointer_to_member_class_required(bool global_qualification_required) $ROSE_OVERRIDE;

HEADER_NEW_OPERATOR_EXPRESSION_END


HEADER_DELETE_OPERATOR_EXPRESSION_START
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) $ROSE_OVERRIDE;
#endif

HEADER_DELETE_OPERATOR_EXPRESSION_END

HEADER_THIS_EXPRESSION_START
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) $ROSE_OVERRIDE;
#endif

HEADER_THIS_EXPRESSION_END

HEADER_SUPER_EXPRESSION_START
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) $ROSE_OVERRIDE;
#endif

HEADER_SUPER_EXPRESSION_END

HEADER_CLASS_EXPRESSION_START
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) $ROSE_OVERRIDE;
#endif

HEADER_CLASS_EXPRESSION_END

HEADER_TUPLE_EXP_START
HEADER_TUPLE_EXP_END

HEADER_LIST_EXP_START
HEADER_LIST_EXP_END

HEADER_COMPREHENSION_START
HEADER_COMPREHENSION_END

HEADER_LIST_COMPREHENSION_START
HEADER_LIST_COMPREHENSION_END

HEADER_SET_COMPREHENSION_START
HEADER_SET_COMPREHENSION_END

HEADER_DICTIONARY_COMPREHENSION_START
HEADER_DICTIONARY_COMPREHENSION_END

HEADER_DICTIONARY_EXP_START
SgKeyDatumPairPtrList& get_key_datum_pairs();
const SgKeyDatumPairPtrList& get_key_datum_pairs() const;
void append_pair(SgKeyDatumPair *what);
HEADER_DICTIONARY_EXP_END

HEADER_KEY_DATUM_PAIR_START
HEADER_KEY_DATUM_PAIR_END

HEADER_STRING_CONVERSION_START
HEADER_STRING_CONVERSION_END

HEADER_SCOPE_OPERATOR_START
       // get lvalue
          virtual bool isLValue() const $ROSE_OVERRIDE;
          virtual bool isChildUsedAsLValue(const SgExpression* child) const $ROSE_OVERRIDE; // INTERNAL Recursively call up the chain to answer the child
HEADER_SCOPE_OPERATOR_END


HEADER_ASSIGNMENT_OPERATOR_START

       // get lvalue
          virtual bool isLValue() const $ROSE_OVERRIDE;
          virtual bool isChildUsedAsLValue(const SgExpression* child) const $ROSE_OVERRIDE; // INTERNAL Recursively call up the chain to answer the child

HEADER_ASSIGNMENT_OPERATOR_END


HEADER_COMPOUND_ASSIGNMENT_OPERATOR_START

       // get lvalue
          virtual bool isLValue() const $ROSE_OVERRIDE;
          virtual bool isChildUsedAsLValue(const SgExpression* child) const $ROSE_OVERRIDE; // INTERNAL Recursively call up the chain to answer the child

HEADER_COMPOUND_ASSIGNMENT_OPERATOR_END


HEADER_ELEMENT_WISE_OP_START


          // virtual bool isLValue() const;
          // virtual bool isChildUsedAsLValue(const SgExpression* child) const; // INTERNAL Recursively call up the chain to answer the child

HEADER_ELEMENT_WISE_OP_END



HEADER_POINTER_ASSIGNMENT_OPERATOR_START

       // get lvalue
          virtual bool isDefinable() const $ROSE_OVERRIDE;

HEADER_POINTER_ASSIGNMENT_OPERATOR_END

HEADER_INTEGER_DIVIDE_ASSIGN_OP_START
HEADER_INTEGER_DIVIDE_ASSIGN_OP_END

HEADER_EXPONENTIATION_ASSIGN_OP_START
HEADER_EXPONENTIATION_ASSIGN_OP_END

HEADER_REFERENCE_EXPRESSION_START
HEADER_REFERENCE_EXPRESSION_END


HEADER_THROW_OPERATOR_START

      //! Throw IR node can be used in three different ways.
          enum e_throw_kind
             {
               unknown_throw = 0             /*! error value */,
               throw_expression              /*! throw expression (takes an expression) */,
               // throw_exception_specification /*! takes a list of types */, JJW (8/6/2008) -- SgThrowOp is not used for exception specifications
               rethrow                       /*! rethow expression (as in \"rethrow;\") */
             };

       // DQ (1/16/2006): Added to support special version of get_type()
          SgType* get_type() const $ROSE_OVERRIDE;

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          unsigned int cfgIndexForEnd() const $ROSE_OVERRIDE;
          std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) $ROSE_OVERRIDE;
          std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) $ROSE_OVERRIDE;
#endif

HEADER_THROW_OPERATOR_END


HEADER_CONCATENATION_OPERATOR_START
HEADER_CONCATENATION_OPERATOR_END

HEADER_REM_OPERATOR_START
HEADER_REM_OPERATOR_END

HEADER_ABS_OPERATOR_START
HEADER_ABS_OPERATOR_END

HEADER_INITIALIZER_EXPRESSION_START
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const $ROSE_OVERRIDE;
#endif

HEADER_INITIALIZER_EXPRESSION_END


HEADER_AGGREGATE_INITIALIZER_EXPRESSION_START
HEADER_LIST_DECLARATIONS
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) $ROSE_OVERRIDE;
#endif

#if 1
       // DQ (6/11/2015): Added support for non ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_requiresGlobalNameQualificationOnType() const;
          void set_requiresGlobalNameQualificationOnType(bool requiresGlobalNameQualificationOnType);

       // DQ (6/11/2015): Added support for non ROSETTA generated access functions to avoid isModified flag setting semantics.
          int get_name_qualification_length_for_type() const;
          void set_name_qualification_length_for_type(int name_qualification_length_for_type);

       // DQ (6/11/2015): Added support for non ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_type_elaboration_required_for_type() const;
          void set_type_elaboration_required_for_type(bool type_elaboration_required_for_type);

       // DQ (6/11/2015): Added support for non ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_global_qualification_required_for_type() const;
          void set_global_qualification_required_for_type(bool global_qualification_required_for_type);
#else
       // DQ (3/22/2018): The names of the data members have been renamed to support the name qualification support
       // using the same support as for the SgConstructor initializer.  The name qualification that is supported for
       // an aggregate initializer is just that for the C++11 specific type specifier that is sometime required
       // (for an example of this see Cxx11_tests/test2018_47.C).  Since it is the type name that is qualified
       // it does make sens to use the original names (e.g. name_qualification_length_for_type), but it would be
       // inconsistant with the constructor initializer support, and eliminate the opportunity to reuse that
       // supporting name qualification code.

       // DQ (6/11/2015): Added support for non ROSETTA generated access functions to avoid isModified flag setting semantics.
          int get_name_qualification_length() const;
          void set_name_qualification_length(int name_qualification_length);

       // DQ (6/11/2015): Added support for non ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_type_elaboration_required() const;
          void set_type_elaboration_required(bool type_elaboration_required);

       // DQ (6/11/2015): Added support for non ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_global_qualification_required() const;
          void set_global_qualification_required(bool global_qualification_required);
#endif

HEADER_AGGREGATE_INITIALIZER_EXPRESSION_END

HEADER_COMPOUND_INITIALIZER_EXPRESSION_START
HEADER_LIST_DECLARATIONS
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) $ROSE_OVERRIDE;
#endif

HEADER_COMPOUND_INITIALIZER_EXPRESSION_END

HEADER_CONSTRUCTOR_INITIALIZER_EXPRESSION_START
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) $ROSE_OVERRIDE;
          virtual unsigned int cfgIndexForEnd() const $ROSE_OVERRIDE;
#endif

      /*! \brief Get the SgClassDeclaration associated with this constructor call.

          Note that in rare cases where the constructor is associated with a primative type
          this function will return a NULL pointer.  In which case p_expression_type is a
          pointer to a SgType which is not a SgClassType, but is a valid pointer to a
          primative type.

          \internal if p_declaration is NULL then p_associated_class_unknown is true.
       */
          SgClassDeclaration* get_class_decl () const;

       // DQ (6/11/2015): Added support for non ROSETTA generated access functions to avoid isModified flag setting semantics.
          int get_name_qualification_length() const $ROSE_OVERRIDE;
          void set_name_qualification_length(int name_qualification_length) $ROSE_OVERRIDE;

       // DQ (6/11/2015): Added support for non ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_type_elaboration_required() const $ROSE_OVERRIDE;
          void set_type_elaboration_required(bool type_elaboration_required) $ROSE_OVERRIDE;

       // DQ (6/11/2015): Added support for non ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_global_qualification_required() const $ROSE_OVERRIDE;
          void set_global_qualification_required(bool global_qualification_required) $ROSE_OVERRIDE;

HEADER_CONSTRUCTOR_INITIALIZER_EXPRESSION_END


HEADER_ASSIGNMENT_INITIALIZER_EXPRESSION_START
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) $ROSE_OVERRIDE;
#endif

          SgExpression * get_operand() const;
          void set_operand(SgExpression * exp);

       // get lvalue
          virtual bool isLValue() const $ROSE_OVERRIDE;
          virtual bool isChildUsedAsLValue(const SgExpression* child) const $ROSE_OVERRIDE; // INTERNAL Recursively call up the chain to answer the child

HEADER_ASSIGNMENT_INITIALIZER_EXPRESSION_END

HEADER_BRACED_INITIALIZER_EXPRESSION_START
HEADER_LIST_DECLARATIONS
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) $ROSE_OVERRIDE;
#endif

#if 0
       // DQ (11/15/2016): I don' think that name qualification maes sense for a braced initializer.

       // DQ (6/11/2015): Added support for non ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_requiresGlobalNameQualificationOnType() const;
          void set_requiresGlobalNameQualificationOnType(bool requiresGlobalNameQualificationOnType);

       // DQ (6/11/2015): Added support for non ROSETTA generated access functions to avoid isModified flag setting semantics.
          int get_name_qualification_length_for_type() const $ROSE_OVERRIDE;
          void set_name_qualification_length_for_type(int name_qualification_length_for_type) $ROSE_OVERRIDE;

       // DQ (6/11/2015): Added support for non ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_type_elaboration_required_for_type() const $ROSE_OVERRIDE;
          void set_type_elaboration_required_for_type(bool type_elaboration_required_for_type) $ROSE_OVERRIDE;

       // DQ (6/11/2015): Added support for non ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_global_qualification_required_for_type() const $ROSE_OVERRIDE;
          void set_global_qualification_required_for_type(bool global_qualification_required_for_type) $ROSE_OVERRIDE;
#endif

HEADER_BRACED_INITIALIZER_EXPRESSION_END


HEADER_REPLACE_EXPRESSION_START
          int replace_expression(SgExpression*, SgExpression*) $ROSE_OVERRIDE ROSE_DEPRECATED_FUNCTION;
HEADER_REPLACE_EXPRESSION_END

HEADER_NULL_EXPRESSION_START
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) $ROSE_OVERRIDE;
#endif

HEADER_NULL_EXPRESSION_END


HEADER_VARIANT_EXPRESSION_START
HEADER_VARIANT_EXPRESSION_END

HEADER_STATEMENT_EXPRESSION_START
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) $ROSE_OVERRIDE;
#endif

HEADER_STATEMENT_EXPRESSION_END

HEADER_ASM_OP_START

       // DQ (7/22/2006): Added support for asm operands and their modifiers
      /*! \brief ASM Operand modifiers (multiple values can be specified)

          \internal Multiple values can be specified
       */
           enum asm_operand_modifier_enum
             {
               e_unknown           = 0x00, /*!< error */
               e_input             = 0x01, /*!< no mod: input operand */
               e_output            = 0x02, /*!< =: output operand */
               e_modify            = 0x03, /*!< +: read-mod-write operand */
               e_earlyclobber      = 0x04, /*!< &: modified early, cannot overlap inputs */
               e_commutative       = 0x08, /*!< %: commutative with next operand */
               e_ignore_next       = 0x10, /*!< *: ignore next letter as a register pref */
               e_ignore_till_comma = 0x20, /*!< #: ignore up to comma as a register pref */
               e_poor_choice       = 0x40, /*!< ?: avoid choosing this */
               e_bad_choice        = 0x80  /*!< !: really avoid choosing this */
             };

       // DQ (7/22/2006): Added support for asm operands and their constraints
      /*! \brief ASM operand constraints (multiple values can be specified)

          \internal Only one value can be specified
       */
          enum asm_operand_constraint_enum
             {
               e_invalid = 0,
               e_any,              /*!< X: unconstrained */
               e_general,          /*!< g: r or i or m */
               e_match_0, aoc_match_1, aoc_match_2, aoc_match_3, aoc_match_4,
               e_match_5, aoc_match_6, aoc_match_7, aoc_match_8, aoc_match_9, /*!< 0-9: same as a previous operand */
            /* registers constraints */
               e_reg_integer,      /*!< r: any integer register */
               e_reg_float,        /*!< f: any float register */
            /* memory constraints */
               e_mem_any,          /*!< m: any memory location */
               e_mem_offset,       /*!< o: memory location, if (val + sizeof(object))
                                           is also acceptable in this context */
               e_mem_nonoffset,    /*!< V: m but not o */
               e_mem_autoinc,      /*!< >: mem, ptr incremented before or after op */
               e_mem_autodec,      /*!< <: mem, ptr decremented before or after op */
            /* immediate constraints */
               e_imm_int,          /*!< i: any integer (including symbolic references) */
               e_imm_number,       /*!< n: any number known to the compiler (no symbols) */
               e_imm_symbol,       /*!< s: any symbolic reference */
               e_imm_float,        /*!< E, F: any floating point constant */

            // DQ (7/22/2006): Let's assume we want to include these (controled by EDG's setting of GNU_X86_ASM_EXTENSIONS_ALLOWED start)
            /* register constraints */
               e_reg_a,            /*!< a: ax */
               e_reg_b,            /*!< b: bx */
               e_reg_c,            /*!< c: cx */
               e_reg_d,            /*!< d: dx */
               e_reg_si,           /*!< s: si */
               e_reg_di,           /*!< d: di */
               e_reg_legacy,       /*!< R: ax bx cx dx si di bp sp (avail. on non-x86-64) */
               e_reg_q,            /*!< Q: ax bx cx dx (non-x86-64), same as 'r' (x86-64) */
               e_reg_ad,           /*!< A: ax dx */
               e_reg_float_tos,    /*!< t: %st(0) */
               e_reg_float_second, /*!< u: %st(1) */
               e_reg_sse,          /*!< x: any SSE register */
               e_reg_sse2,         /*!< Y: any SSE2 register */
               e_reg_mmx,          /*!< y: any MMX register */
            /* immediate constraints */
               e_imm_short_shift,  /*!< I: [0, 32) */
               e_imm_long_shift,   /*!< J: [0, 64) */
               e_imm_lea_shift,    /*!< M: [0, 4) */
               e_imm_signed8,      /*!< K: [-128, 127] */
               e_imm_unsigned8,    /*!< N: [0, 255] */
               e_imm_and_zext,     /*!< L: {0xFF, 0xFFFF} */
               e_imm_80387,        /*!< G: any 80387 standard constant */
               e_imm_sse,          /*!< H: any SSE standard constant */
               e_imm_sext32,       /*!< e: any 32-bit quantity sign extended to 64 bits */
               e_imm_zext32,       /*!< Z: any 32-bit quantity zero extended to 64 bits */
            // DQ (7/22/2006): Let's assume we want to include these (controled by EDG's setting of GNU_X86_ASM_EXTENSIONS_ALLOWED end)
               e_last
             };

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) $ROSE_OVERRIDE;
#endif

HEADER_ASM_OP_END


// HEADER_INTRINSICFN_EXPRESSION_START
//         void append_arg($GRAMMAR_PREFIX_Expression*);
// HEADER_INTRINSICFN_EXPRESSION_END

HEADER_SUBSCRIPT_EXPR_EXPRESSION_START
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) $ROSE_OVERRIDE;
#endif

HEADER_SUBSCRIPT_EXPR_EXPRESSION_END

// HEADER_SUBSCRIPT_COLON_EXPRESSION_START
// HEADER_SUBSCRIPT_COLON_EXPRESSION_END

HEADER_COLON_SHAPE_EXPRESSION_START
HEADER_COLON_SHAPE_EXPRESSION_END

// HEADER_SUBSCRIPT_ASTERISK_EXPRESSION_START
// HEADER_SUBSCRIPT_ASTERISK_EXPRESSION_END

HEADER_ASTERISK_SHAPE_EXPRESSION_START
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) $ROSE_OVERRIDE;
#endif

HEADER_ASTERISK_SHAPE_EXPRESSION_END

HEADER_USE_ONLY_EXPR_START
HEADER_USE_ONLY_EXPR_END

HEADER_USE_RENAME_EXPR_START
HEADER_USE_RENAME_EXPR_END

HEADER_IO_ITEM_EXPR_START
HEADER_IO_ITEM_EXPR_END

HEADER_IMPLIED_DO_START
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) $ROSE_OVERRIDE;
#endif

HEADER_IMPLIED_DO_END

HEADER_UNKNOWN_ARRAY_OR_FUNCTION_REFERENCE_START
HEADER_UNKNOWN_ARRAY_OR_FUNCTION_REFERENCE_END

HEADER_ACTUAL_ARGUMENT_EXPRESSION_START
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) $ROSE_OVERRIDE;
#endif

HEADER_ACTUAL_ARGUMENT_EXPRESSION_END

HEADER_DESIGNATED_INITIALIZER_START
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) $ROSE_OVERRIDE;
          virtual unsigned int cfgFindChildIndex(SgNode* n) $ROSE_OVERRIDE;
#endif

HEADER_DESIGNATED_INITIALIZER_END

HEADER_UPC_LOCAL_SIZEOF_EXPRESSION_START
//        virtual unsigned int cfgIndexForEnd() const;
//        virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index);
//        virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index);
HEADER_UPC_LOCAL_SIZEOF_EXPRESSION_END

HEADER_UPC_BLOCK_SIZEOF_EXPRESSION_START
//        virtual unsigned int cfgIndexForEnd() const;
//        virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index);
//        virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index);
HEADER_UPC_BLOCK_SIZEOF_EXPRESSION_END

HEADER_UPC_ELEM_SIZEOF_EXPRESSION_START
//        virtual unsigned int cfgIndexForEnd() const;
//        virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index);
//        virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index);
HEADER_UPC_ELEM_SIZEOF_EXPRESSION_END

HEADER_USER_DEFINED_UNARY_EXPRESSION_START
          SgType* get_type() const $ROSE_OVERRIDE;
HEADER_USER_DEFINED_UNARY_EXPRESSION_END

HEADER_USER_DEFINED_BINARY_EXPRESSION_START
          SgType* get_type() const $ROSE_OVERRIDE;
HEADER_USER_DEFINED_BINARY_EXPRESSION_END

HEADER_PSEUDO_DESTRUCTOR_REF_START

       // DQ (1/18/2020): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          int get_name_qualification_length() const $ROSE_OVERRIDE;
          void set_name_qualification_length(int name_qualification_length) $ROSE_OVERRIDE;

       // DQ (1/18/2020): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_type_elaboration_required() const $ROSE_OVERRIDE;
          void set_type_elaboration_required(bool type_elaboration_required) $ROSE_OVERRIDE;

       // DQ (1/18/2020): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_global_qualification_required() const $ROSE_OVERRIDE;
          void set_global_qualification_required(bool global_qualification_required) $ROSE_OVERRIDE;

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) $ROSE_OVERRIDE;
#endif

HEADER_PSEUDO_DESTRUCTOR_REF_END

// FMZ (2/5/2009) Added for CAFCoExpression
HEADER_CO_EXPRESSION_START

HEADER_CO_EXPRESSION_END

HEADER_LAMBDA_REF_EXP_START

    SgFunctionParameterList* get_parameterList();
    SgStatement* get_body();

HEADER_LAMBDA_REF_EXP_END

HEADER_CUDA_KERNEL_EXEC_CONFIG_START
HEADER_CUDA_KERNEL_EXEC_CONFIG_END

HEADER_CUDA_KERNEL_CALL_EXPRESSION_START
HEADER_CUDA_KERNEL_CALL_EXPRESSION_END

HEADER_TYPE_EXPRESSION_START
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) $ROSE_OVERRIDE;
#endif

HEADER_TYPE_EXPRESSION_END


HEADER_FUNCTION_PARAMETER_REFERENCE_EXPRESSION_START

       // DQ (8/11/2014): Added support for C++11 decltype used in new function return syntax.
#if 0
          virtual unsigned int cfgIndexForEnd() const $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) $ROSE_OVERRIDE;
#endif
       // SgType* get_type() const;

HEADER_FUNCTION_PARAMETER_REFERENCE_EXPRESSION_END


// #########################################################
// #########################################################
//                      SOURCE CODE
// #########################################################
// #########################################################

NOTES: SgAggregateInitializer, SgConstructorInitializer, and
       SgAssignInitializer all have different set_type functions
       (is this a bug?).

       set_type in SgPlusAssignOp is different from every other SgxxxAssignOp

       SgBitComplementOp set_type function is different from all other Bit operators

// #########################################################
// #########################################################


SOURCE_BASECLASS_EXPRESSION_START

Sg_File_Info*
SgExpression::get_file_info() const
   {
  // DQ (11/8/2006): Note that the EDG/SageIII translation only
  // uses set_startOfConstruct() and set_endOfConstruct().

  // This redefines get_file_info() as it is implemented for a SgLocatedNode
  // to use the "get_operatorPosition()" instead of the get_startOfConstruct()"
  // Most if not all operator positions will associated with syntax for the operator.
  // return get_operatorPosition();
     Sg_File_Info* returnFileInfo = get_operatorPosition();
     if (returnFileInfo == NULL)
          returnFileInfo = get_startOfConstruct();
     return returnFileInfo;
   }

void
SgExpression::set_file_info(Sg_File_Info* fileInfo)
   {
  // DQ (11/8/2006): Note that the EDG/SageIII translation only
  // uses set_startOfConstruct() and set_endOfConstruct().

  // This redefines get_file_info() as it is implemented for a SgLocatedNode
  // to use the "get_operatorPosition()" instead of the get_startOfConstruct()"
  // Most if not all operator positions will associated with syntax for the operator.
     return set_operatorPosition(fileInfo);
   }

#define DEBUG_SGEXPRESSION_GET_QUALIFIED_NAME_PREFIX 0

SgName
SgExpression::get_qualified_name_prefix() const
   {
  // DQ (5/29/2011): Added to support for new qualified name generation.
  // This only applies to specific SgSupport IR nodes:
  //    SgVarRefExp
  //    SgFunctionRefExp
  //    SgMemberFunctionRefExp

#if DEBUG_SGEXPRESSION_GET_QUALIFIED_NAME_PREFIX
     printf ("In get_qualified_name_prefix(): search globalQualifiedNameMapForNames: this = %p = %s \n",this,this->class_name().c_str());
#endif

  // DQ (5/28/2011): We have to handle the name qualification directly since types can be qualified
  // different and so it depends upon where the type is referenced.  Thus the qualified name is
  // stored in a map to the IR node that references the type.
     SgName nameQualifier;
     std::map<SgNode*,std::string>::iterator i = SgNode::get_globalQualifiedNameMapForNames().find(const_cast<SgExpression*>(this));
  // ROSE_ASSERT(i != SgNode::get_globalQualifiedNameMapForNames().end());

     if (i != SgNode::get_globalQualifiedNameMapForNames().end())
        {
          nameQualifier = i->second;
#if DEBUG_SGEXPRESSION_GET_QUALIFIED_NAME_PREFIX
          printf ("In SgExpression::get_qualified_name_prefix(): Found a valid name qualification: nameQualifier = %s \n",nameQualifier.str());
#endif
        }
       else
        {
#if DEBUG_SGEXPRESSION_GET_QUALIFIED_NAME_PREFIX
          printf ("In SgExpression::get_qualified_name_prefix(): Could NOT find a valid name qualification: nameQualifier = %s \n",nameQualifier.str());
#endif
        }

#if DEBUG_SGEXPRESSION_GET_QUALIFIED_NAME_PREFIX
     printf ("nameQualifier for SgExpression = %p = %p = %s = %s \n",this,const_cast<SgExpression*>(this),class_name().c_str(),nameQualifier.str());
#endif

#if 0
  // DQ (8/19/2013): Error checking on the globalTypeNameMap...check if there is an entry here that we might have wanted to use instead.
     std::map<SgNode*,std::string>::iterator j = SgNode::get_globalTypeNameMap().find(const_cast<SgExpression*>(this));
     if (j != SgNode::get_globalTypeNameMap().end())
        {
          SgName debug_nameQualifier = j->second;
          printf ("In SgExpression::get_qualified_name_prefix(): Found a valid name qualification in the globalTypeNameMap: debug_nameQualifier = %s \n",debug_nameQualifier.str());
        }
#endif

     return nameQualifier;
   }


SgName
SgExpression::get_qualified_name_prefix_for_referenced_type() const
   {
  // DQ (6/2/2011): Added to support for new qualified name generation.

#if 0
     printf ("In get_qualified_name_prefix_for_referenced_type(): search globalQualifiedNameMapForNames: this = %p = %s \n",this,this->class_name().c_str());
#endif

  // DQ (5/28/2011): We have to handle the name qualification directly since types can be qualified
  // different and so it depends upon where the type is referenced.  Thus the qualified name is
  // stored in a map to the IR node that references the type.
     SgName nameQualifier;
     std::map<SgNode*,std::string>::iterator i = SgNode::get_globalQualifiedNameMapForTypes().find(const_cast<SgExpression*>(this));

     if (i != SgNode::get_globalQualifiedNameMapForTypes().end())
        {
          nameQualifier = i->second;
#if 0
          printf ("In SgExpression::get_qualified_name_prefix_for_referenced_type(): Found a valid name qualification: nameQualifier = %s \n",nameQualifier.str());
#endif
        }
       else
        {
#if 0
          printf ("In SgExpression::get_qualified_name_prefix_for_referenced_type(): Could NOT find a valid name qualification: nameQualifier = %s \n",nameQualifier.str());
#endif
        }

  // printf ("nameQualifier for SgExpression referenced type = %s = %s \n",class_name().c_str(),nameQualifier.str());

#if 0
  // DQ (8/19/2013): Error checking on the globalTypeNameMap...check if there is an entry here that we might have wanted to use instead.
     std::map<SgNode*,std::string>::iterator j = SgNode::get_globalTypeNameMap().find(const_cast<SgExpression*>(this));
     if (j != SgNode::get_globalTypeNameMap().end())
        {
          SgName debug_nameQualifier = j->second;
          printf ("In SgExpression::get_qualified_name_prefix_for_referenced_type(): Found a valid name qualification in the globalTypeNameMap: debug_nameQualifier = %s \n",debug_nameQualifier.str());
        }
#endif

     return nameQualifier;
   }


void
SgExpression::post_construction_initialization()
   {
   }

int
SgExpression::replace_expression(SgExpression *,SgExpression *)
   {
     printf ("Error: base class  SgExpression::replace_expression called, likely a mistake! \n");
     ROSE_ASSERT(false);
     return 0;
   }

#if 0
// DQ (1/14/2006): set_type is removed
void
SgExpression::set_type()
   {
    /*
     * this is a quick hack to allow me to rely on being to create a non
     * abstract object.  For some expression classes this had not been
     * overridden
     */

     cerr << "Call to undefined set_type(): aborting" << endl;
     exit(1);
   }
#endif

SgType*
SgExpression::get_type() const
   {
  // DQ: With this function defined we can be sure that we don't call it by accident.
  // This catches any IR nodes where the fucntion should have been overwritten and was not.

     cerr << "Call to undefined $CLASSNAME::get_type(): aborting" << endl;
     cerr << "dynamic type: " << this->class_name() << endl;
     ROSE_ASSERT(false);

     return 0;
   }

#if 0
// DQ (8/18/2004): removing this older pragma mechanism
void
SgExpression::output_pragma(ostream& os)
   {
     ::print_pragma( p_uattributes, os);
   }
#endif

int
SgExpression::precedence() const
   {
     return 0;
   }

#if 0
int
SgExpression::length() const
   {
     return 0;
   }
#endif

#if 0
bool
SgExpression::empty() const
   {
     return 1;
   }
#endif

#if 0
SgExpression*
SgExpression::get_first() const
   {
     int p = 0;
     return get_next(p);
   }
#endif

#if 0
SgExpression*
SgExpression::get_next(int&) const
   {
     printf ("Error: baseClass called! \n");
     abort();

     return NULL;
   }
#endif

#if 0
SgExpression*
SgExpression::get_end() const
   {
     printf ("Error: baseClass called! \n");
     abort();

     return NULL;
   }
#endif

#if 0
void
SgExpression::insert_next(int,SgExpression *)
   {
   }
#endif

#if 0
SgExpressionPtrList::iterator
SgExpression::begin()
   { return get_first(); }

SgExpressionPtrList::iterator
SgExpression::end()
   { return get_end(); }
#endif

#if 0
// DQ (8/18/2004): Removed since it is not used!
void
SgExpression::set_lvalue()
   {
#if 0
     printf ("ERROR: not yet implemented in SAGE3! \n");
     abort();
#else
     set_system_bitflag(p_uattributes,e_lvalue);
#endif
   }

int
SgExpression::get_is_lvalue() const
   { return is_system_bitflag(p_uattributes,e_lvalue); }
#endif


#if 0
void
SgExpression::unset_lvalue()
   { unset_system_bitflag(p_uattributes,e_lvalue); }

void
SgExpression::add_pragma(int cnt, SgPragma** plist)
   {
     for(int i=0; i<cnt; i++)
        {
          ::add_pragma(p_uattributes, plist[i]);
          plist[i]=0;
        }
   }

SgPragma*
SgExpression::add_pragma(char *nm)
   { return ::add_pragma(p_uattributes, nm); }

SgPragma*
SgExpression::get_pragma(char *nm) const
   { return ::get_pragma(p_uattributes, nm); }

int
SgExpression::remove_pragma(char *nm)
   { return ::remove_pragma(p_uattributes,nm); }

// get attribute,
SgAttribute*
SgExpression::get_user_attribute(char *nm) const
   { return ::Sgget_user_attribute(p_uattributes,nm); }

SgAttribute*
SgExpression::add_user_attribute(char *nm, SgAttribute* attr)
   { return ::Sgadd_user_attribute(p_uattributes,nm,attr); }

int
SgExpression::remove_user_attribute(char *nm)
   { return ::remove_user_attribute(p_uattributes,nm); }
#endif

#if 0
// DQ (8/18/2004): Removed since it uses the old attribute mechanism
// Some global functions that are used by expressions
SgAttribute*
get_system_bitflag(const SgAttributePtrList & pattr)
   {
     SgAttributePtrList::const_iterator p = pattr.begin();
     if(p == pattr.end())
          return NULL;
       else
        {
          assert((*p) != NULL);
          return (SgAttribute *)(*p); // first one
        }
   }

/* always the first SgAttributePtr in the list */
void
set_system_bitflag(SgAttributePtrList & pattr, unsigned long int bit)
   {
     SgAttributePtrList::iterator p = pattr.begin();
     if(p==pattr.end())
        {
          SgBitAttribute* newAttribute = new SgBitAttribute("SYS_BITFLAG");
          assert(newAttribute != NULL);
          p = pattr.insert(p, newAttribute);
      //  p = pattr.insert(p,(SgAttribute *) new SgBitAttribute("SYS_BITFLAG"));
        }

     SgBitAttribute *bp = (SgBitAttribute *)(*p);
     assert(bp != NULL);
     bp->setAttribute(bit);
   }

void
unset_system_bitflag(SgAttributePtrList& pattr, unsigned long int bit)
   {
     SgAttributePtrList::iterator p=pattr.begin();
     if(p==pattr.end())
        {
          SgBitAttribute* newAttribute = new SgBitAttribute("SYS_BITFLAG");
          assert(newAttribute != NULL);
          p=pattr.insert(p,(SgAttribute *) newAttribute);
       // p=pattr.insert(p,(SgAttribute *) new SgBitAttribute("SYS_BITFLAG"));
        }

     SgBitAttribute* bp = (SgBitAttribute *)(*p);
     assert(bp != NULL);
     bp->unsetAttribute(bit);
   }

int
is_system_bitflag(const SgAttributePtrList& pattr, unsigned long int bit)
   {
     SgAttributePtrList::const_iterator p=pattr.begin();
     if(p==pattr.end())
          return 0;

     SgBitAttribute *bp = (SgBitAttribute *)(*p);
     assert(bp != NULL);
     return bp->isAttributeSet(bit);
   }

SgAttribute*
Sgadd_user_attribute(SgAttributePtrList& pattr, char *attr_name, SgAttribute* attr)
   {
     SgAttributePtrList::iterator p=pattr.begin();
     if(p==pattr.end())
        {
          SgBitAttribute* newAttribute = new SgBitAttribute("SYS_BITFLAG");
          assert(newAttribute != NULL);
          pattr.insert(p,newAttribute);
       // pattr.insert(p,(SgAttribute *)new SgBitAttribute("SYS_BITFLAG"));
        }
     p++;

  // I think it would not make much sense to insert a NULL pointer
     assert(attr != NULL);
     pattr.insert(pattr.end(), attr);
     p++;

  // DQ: Not sure we can assert that the return value is a valid pointer
     assert((*p) != NULL);
     return (SgAttribute *)(*p);
   }

// get user attribute,
SgAttribute*
Sgget_user_attribute(const SgAttributePtrList& pattr, char *attr_name)
   {
     assert(attr_name != NULL);
     SgAttributePtrList::const_iterator p = pattr.begin();
     if(p == pattr.end())
          return 0;
       else
          p++; // skip the system attribute

     while( p != pattr.end())
        {
          assert((*p) != NULL);
          if( !(*p)->isPragma() && (*p)->isSame(attr_name) )
             {
               assert((*p) != NULL);
               return (SgAttribute *)(*p);
             }
          p++;
        }

     return NULL;
   }

int
remove_user_attribute(SgAttributePtrList& pattr, char *attr_name)
   {
     assert(attr_name != NULL);
     SgAttributePtrList::iterator p = pattr.begin();
     if(p==pattr.end())
          return 0;
       else
          p++; // skip the system one

     while( p!=pattr.end())
        {
          assert((*p) != NULL);
          if( !(*p)->isPragma() && (*p)->isSame(attr_name) )
             {
               pattr.remove((*p));
               return 1;
             }
          p++;
        }

     return 0;
   }
#endif


int
SgExpression::get_name_qualification_length () const
   {
     ROSE_ASSERT (this != NULL);

     printf ("Error: base class virtual function called by mistake on node = %p = %s \n",this,this->class_name().c_str());
     ROSE_ASSERT(false);

     return 0; // p_name_qualification_length;
   }

void
SgExpression::set_name_qualification_length ( int name_qualification_length )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     printf ("Error: base class virtual function called by mistake on node = %p = %s \n",this,this->class_name().c_str());
     ROSE_ASSERT(false);

  // p_name_qualification_length = name_qualification_length;
   }


bool
SgExpression::get_type_elaboration_required () const
   {
     ROSE_ASSERT (this != NULL);

     printf ("Error: base class virtual function called by mistake on node = %p = %s \n",this,this->class_name().c_str());
     ROSE_ASSERT(false);

     return false; // p_type_elaboration_required;
   }

void
SgExpression::set_type_elaboration_required ( bool type_elaboration_required )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     printf ("Error: base class virtual function called by mistake on node = %p = %s \n",this,this->class_name().c_str());
     ROSE_ASSERT(false);

  // p_type_elaboration_required = type_elaboration_required;
   }

bool
SgExpression::get_global_qualification_required () const
   {
     ROSE_ASSERT (this != NULL);

     printf ("Error: base class virtual function called by mistake on node = %p = %s \n",this,this->class_name().c_str());
     ROSE_ASSERT(false);

     return false; // p_global_qualification_required;
   }

void
SgExpression::set_global_qualification_required ( bool global_qualification_required )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     printf ("Error: base class virtual function called by mistake on node = %p = %s \n",this,this->class_name().c_str());
     ROSE_ASSERT(false);

  // p_global_qualification_required = global_qualification_required;
   }


int
SgExpression::get_name_qualification_for_pointer_to_member_class_length () const
   {
     ROSE_ASSERT (this != NULL);

     printf ("Error: base class virtual function called by mistake on node = %p = %s \n",this,this->class_name().c_str());
     ROSE_ASSERT(false);

     return 0; // p_name_qualification_length;
   }

void
SgExpression::set_name_qualification_for_pointer_to_member_class_length ( int name_qualification_length )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     printf ("Error: base class virtual function called by mistake on node = %p = %s \n",this,this->class_name().c_str());
     ROSE_ASSERT(false);

  // p_name_qualification_length = name_qualification_length;
   }


bool
SgExpression::get_type_elaboration_for_pointer_to_member_class_required () const
   {
     ROSE_ASSERT (this != NULL);

     printf ("Error: base class virtual function called by mistake on node = %p = %s \n",this,this->class_name().c_str());
     ROSE_ASSERT(false);

     return false; // p_type_elaboration_required;
   }

void
SgExpression::set_type_elaboration_for_pointer_to_member_class_required ( bool type_elaboration_required )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     printf ("Error: base class virtual function called by mistake on node = %p = %s \n",this,this->class_name().c_str());
     ROSE_ASSERT(false);

  // p_type_elaboration_required = type_elaboration_required;
   }

bool
SgExpression::get_global_qualification_for_pointer_to_member_class_required () const
   {
     ROSE_ASSERT (this != NULL);

     printf ("Error: base class virtual function called by mistake on node = %p = %s \n",this,this->class_name().c_str());
     ROSE_ASSERT(false);

     return false; // p_global_qualification_required;
   }

void
SgExpression::set_global_qualification_for_pointer_to_member_class_required ( bool global_qualification_required )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     printf ("Error: base class virtual function called by mistake on node = %p = %s \n",this,this->class_name().c_str());
     ROSE_ASSERT(false);

  // p_global_qualification_required = global_qualification_required;
   }


// DQ (9/23/2011): Use the vitual function version so that we can test within ROSE (part of incremental testing of new original expression tree support).
// DQ (9/19/2011): Put back the original code (non-virtual functions) so that we can test against previously passing tests.
SgExpression*
SgExpression::get_originalExpressionTree() const
   {
     SgExpression* originalExpressionTree = NULL;

#if 0
  // DQ (9/17/2011): It is OK to call this function, where it is not supported by a function in the derived class it should return NULL.
     printf ("WARNING: base function SgExpression::get_originalExpressionTree() called for %p = %s (returning NULL) \n",this,this->class_name().c_str());
  // ROSE_ASSERT(false);
#endif

     return originalExpressionTree;
   }

// DQ (9/19/2011): Put back the original code (non-virtual functions) so that we can test against previously passing tests.
void
SgExpression::set_originalExpressionTree(SgExpression* X)
   {
     printf ("ERROR: base function SgExpression::set_originalExpressionTree() called for %p = %s \n",this,this->class_name().c_str());
     ROSE_ASSERT(false);
   }

bool
SgExpression::hasExplicitType()
   {
  // DQ (3/7/2014):  This could be implemented as a virtual function but would require 11 functions to be
  // implemented. I have thus instead implemented it as a single function on the SgType instead. We
  // can review this if it is important.

  // This function returns true only if this is either a SgTemplateParameterVal, SgComplexVal, SgSizeOfOp, SgAlignOfOp, 
  // SgTypeIdOp, SgVarArgStartOp, SgVarArgStartOneOperandOp, 
  // SgVarArgOp, SgVarArgEndOp, SgVarArgCopyOp, SgNewExp, SgRefExp, SgAggregateInitializer, SgCompoundInitializer,
  // SgConstructorInitializer, SgAssignInitializer, SgPseudoDestructorRefExp.

     bool returnValue = false;

  // Need to add: SgUpcLocalsizeofExpression, SgUpcBlocksizeofExpression, SgUpcElemsizeofExpression.

  // DQ (11/10/2014): Added support for SgFunctionParameterRefExp node to store the type explicitly.

     if ( isSgTemplateParameterVal(this) != NULL     || isSgComplexVal(this)    != NULL            || isSgSizeOfOp(this) != NULL                 || 
          isSgAlignOfOp(this) != NULL                || isSgTypeIdOp(this)  != NULL                ||
          isSgVarArgStartOp(this) != NULL            || isSgVarArgStartOneOperandOp(this) != NULL  || isSgVarArgOp(this)  != NULL                ||
          isSgVarArgEndOp(this) != NULL              || isSgVarArgCopyOp(this) != NULL             || isSgNewExp(this)  != NULL                  ||
          isSgRefExp(this) != NULL                   || isSgAggregateInitializer(this) != NULL     || isSgCompoundInitializer(this)  != NULL     ||
          isSgUpcLocalsizeofExpression(this) != NULL || isSgUpcBlocksizeofExpression(this) != NULL || isSgUpcElemsizeofExpression(this)  != NULL ||
       // isSgConstructorInitializer(this) != NULL   || isSgAssignInitializer(this) != NULL        || isSgPseudoDestructorRefExp(this)  != NULL  ||
          isSgConstructorInitializer(this) != NULL   || isSgPseudoDestructorRefExp(this)  != NULL  || isSgFunctionParameterRefExp(this) != NULL )
        {
          returnValue = true;
        }

     return returnValue;
   }

void
SgExpression::set_explicitly_stored_type( SgType* type )
   {
  // DQ (3/7/2014): Some expressions store internal SgType pointers explicitly, this allows these IR nodes to be reset with new types (used in the snippet support).

     switch (this->variantT())
        {
           case V_SgNewExp:
             {
               SgNewExp* exp = isSgNewExp(this);
               ROSE_ASSERT(exp != NULL);
               exp->set_specified_type(type);
               break;
             }

          case V_SgConstructorInitializer:
             {
               SgConstructorInitializer* exp = isSgConstructorInitializer(this);
               ROSE_ASSERT(exp != NULL);
               exp->set_expression_type(type);
               break;
             }

          case V_SgTemplateParameterVal:
             {
               SgTemplateParameterVal* exp = isSgTemplateParameterVal(this);
               ROSE_ASSERT(exp != NULL);
               exp->set_valueType(type);
               break;
             }

          case V_SgComplexVal:
             {
               SgComplexVal* exp = isSgComplexVal(this);
               ROSE_ASSERT(exp != NULL);
               exp->set_precisionType(type);
               break;
             }

          case V_SgSizeOfOp:
             {
               SgSizeOfOp* exp = isSgSizeOfOp(this);
               ROSE_ASSERT(exp != NULL);
               exp->set_operand_type(type);
               break;
             }

          case V_SgAlignOfOp:
             {
               SgAlignOfOp* exp = isSgAlignOfOp(this);
               ROSE_ASSERT(exp != NULL);
               exp->set_operand_type(type);
               break;
             }

          case V_SgTypeIdOp:
             {
               SgTypeIdOp* exp = isSgTypeIdOp(this);
               ROSE_ASSERT(exp != NULL);
               exp->set_operand_type(type);
               break;
             }

          case V_SgVarArgStartOp:
             {
               SgVarArgStartOp* exp = isSgVarArgStartOp(this);
               ROSE_ASSERT(exp != NULL);
               exp->set_expression_type(type);
               break;
             }

          case V_SgVarArgStartOneOperandOp:
             {
               SgVarArgStartOneOperandOp* exp = isSgVarArgStartOneOperandOp(this);
               ROSE_ASSERT(exp != NULL);
               exp->set_expression_type(type);
               break;
             }

          case V_SgVarArgOp:
             {
               SgVarArgOp* exp = isSgVarArgOp(this);
               ROSE_ASSERT(exp != NULL);
               exp->set_expression_type(type);
               break;
             }

          case V_SgVarArgEndOp:
             {
               SgVarArgEndOp* exp = isSgVarArgEndOp(this);
               ROSE_ASSERT(exp != NULL);
               exp->set_expression_type(type);
               break;
             }

          case V_SgVarArgCopyOp:
             {
               SgVarArgCopyOp* exp = isSgVarArgCopyOp(this);
               ROSE_ASSERT(exp != NULL);
               exp->set_expression_type(type);
               break;
             }

          case V_SgRefExp:
             {
               SgRefExp* exp = isSgRefExp(this);
               ROSE_ASSERT(exp != NULL);
               exp->set_type_name(type);
               break;
             }

          case V_SgAggregateInitializer:
             {
               SgAggregateInitializer* exp = isSgAggregateInitializer(this);
               ROSE_ASSERT(exp != NULL);
               exp->set_expression_type(type);
               break;
             }

          case V_SgCompoundInitializer:
             {
               SgCompoundInitializer* exp = isSgCompoundInitializer(this);
               ROSE_ASSERT(exp != NULL);
               exp->set_expression_type(type);
               break;
             }

          case V_SgPseudoDestructorRefExp:
             {
               SgPseudoDestructorRefExp* exp = isSgPseudoDestructorRefExp(this);
               ROSE_ASSERT(exp != NULL);
               exp->set_object_type(type);
               break;
             }

           case V_SgUpcLocalsizeofExpression:
             {
               SgUpcLocalsizeofExpression* exp = isSgUpcLocalsizeofExpression(this);
               ROSE_ASSERT(exp != NULL);
               exp->set_operand_type(type);
               break;
             }

           case V_SgUpcBlocksizeofExpression:
             {
               SgUpcBlocksizeofExpression* exp = isSgUpcBlocksizeofExpression(this);
               ROSE_ASSERT(exp != NULL);
               exp->set_operand_type(type);
               break;
             }

           case V_SgUpcElemsizeofExpression:
             {
               SgUpcElemsizeofExpression* exp = isSgUpcElemsizeofExpression(this);
               ROSE_ASSERT(exp != NULL);
               exp->set_operand_type(type);
               break;
             }

#if 0
             {
               printf ("Error: case not handled: expression = %p = %s \n",this,this->class_name().c_str());
               ROSE_ASSERT(false);
               break;
             }
#endif
          default:
             {
               printf ("Error: SgExpression::set_explicit_type(): default reached: expression = %p = %s \n",this,this->class_name().c_str());
               ROSE_ASSERT(false);
             }
        }
   }

SOURCE_BASECLASS_EXPRESSION_END


SOURCE_X_EXPRESSION_START

#error "Error code included from SOURCE_X_EXPRESSION"

void
$CLASSNAME::post_construction_initialization()
   {
   }

SOURCE_X_EXPRESSION_END


SOURCE_X_EXPRESSION_UNKNOWN_START

// This is not a terminal that we really need, so I'm
// not sure it should be a part of the X grammar.

#error "Error code included from SOURCE_X_EXPRESSION_UNKNOWN"

SOURCE_X_EXPRESSION_UNKNOWN_END


SOURCE_NON_X_EXPRESSION_START

#error "Error code included from SOURCE_NON_X_EXPRESSION"

SOURCE_NON_X_EXPRESSION_END


SOURCE_UNARY_EXPRESSION_START

void
SgUnaryOp::post_construction_initialization()
   {
// #ifndef REMOVE_SET_PARENT_FUNCTION
     if (get_operand())
          get_operand()->set_parent(this);
// #endif
     p_mode = SgUnaryOp::prefix;
   }

SgExpression*
SgUnaryOp::get_operand() const
   { return get_operand_i(); }

void
SgUnaryOp::set_operand(SgExpression * exp)
   {
     set_operand_i(exp);
// #ifndef REMOVE_SET_PARENT_FUNCTION
     if (exp)
          exp->set_parent(this);
// #endif

  // DQ (1/14/2006): set_type is removed
  // set_type();
   }

SgType*
SgUnaryOp::get_type() const
   {
  // DQ (1/14/2006): Get the type from the operand
  // return get_expression_type();

#if 0
     printf ("$CLASSNAME::get_type(): getting type from operand \n");
#endif

     ROSE_ASSERT(get_operand() != NULL);

     SgType* returnType = get_operand()->get_type();

     return returnType;
   }

int
SgUnaryOp::length() const
   { return 1;}

bool
SgUnaryOp::empty() const
   { return 0; }

// void $CLASSNAME::operator_unparse(const char * op, Unparse_Info & info, ostream & os);

#if 0
// This should be automatically generated!
int
SgUnaryOp::get_mode()
   { return p_mode; }

void
SgUnaryOp::set_mode(Sgop_mode m)
   { p_mode=m; }
#endif

SgExpression*
SgUnaryOp::get_next (int &n) const
   {
     if(n)
        {
          return NULL;
        }
       else
        {
          n++;
          return get_operand();
        }
   }

int
SgUnaryOp::replace_expression (SgExpression *o, SgExpression *n)
   {
  // DQ (12/17/2006): This function should have the semantics that it will represent a
  // structural change to the AST, thus it is free to set the parent of the new expression.

     ROSE_ASSERT(o != NULL);
     ROSE_ASSERT(n != NULL);

     if (get_operand() == o)
        {
          set_operand(n);
          return 1;
        }
       else
        {
          printf ("Warning: inside of SgUnaryOp::replace_expression original SgExpression unidentified \n");
          return 0;
        }
   }

SOURCE_UNARY_EXPRESSION_END


SOURCE_BINARY_EXPRESSION_START
void
SgBinaryOp::post_construction_initialization()
   {
// #ifndef REMOVE_SET_PARENT_FUNCTION
     if (get_lhs_operand())
          get_lhs_operand()->set_parent(this);
     if (get_rhs_operand())
          get_rhs_operand()->set_parent(this);
// #endif
   }

SgExpression*
SgBinaryOp::get_lhs_operand() const
   { return get_lhs_operand_i(); }

void
SgBinaryOp::set_lhs_operand(SgExpression * exp)
   {
     set_lhs_operand_i(exp);
// #ifndef REMOVE_SET_PARENT_FUNCTION
     if (exp)
        exp->set_parent(this);
// #endif

  // DQ (1/14/2006): set_type is removed
  // set_type();
   }

int
SgBinaryOp::length() const
   {
     return 2;
   }

// I don't think this is used (so exclude it until we clearly need it)!
bool
SgBinaryOp::empty() const
   {
     return false;  // return 0;
   }

SgExpression*
SgBinaryOp::get_rhs_operand() const
   { return get_rhs_operand_i(); }

void
SgBinaryOp::set_rhs_operand(SgExpression * exp)
   {
     set_rhs_operand_i(exp);
// #ifndef REMOVE_SET_PARENT_FUNCTION
     if (exp)
          exp->set_parent(this);
// #endif

  // DQ (1/14/2006): set_type is removed
  // set_type();
   }

SgType*
SgBinaryOp::get_type() const
   {
  // We have to select one, so for now chose the lhs, it might be that
  // we have to explicitly store the return type of binary operators.

     ROSE_ASSERT(get_lhs_operand() != NULL);
     ROSE_ASSERT(get_rhs_operand() != NULL);

#if 0
     printf ("In SgBinaryOp::get_type(): this->class_name() = %s \n",this->class_name().c_str());
#endif

     SgType* lhsType = get_lhs_operand()->get_type();
     ROSE_ASSERT(lhsType != NULL);

     SgType* rhsType = get_rhs_operand()->get_type();
     ROSE_ASSERT(rhsType != NULL);

  // DQ (9/27/2006): Ideally, this should not be set, though sometimes it is.
  // ROSE_ASSERT(p_expression_type != NULL);
     string expression_type_name = "NULL";
     if (p_expression_type != NULL)
        {
          expression_type_name = p_expression_type->class_name();
          printf ("Found an case where $CLASSNAME::p_expression_type != NULL on %s expression_type_name = %s \n",
               this->class_name().c_str(),expression_type_name.c_str());
        }

     if (variantT() == V_SgAddOp || variantT() == V_SgSubtractOp)
        {
       // PC (10/9/2009): Pointer arithmetic is a special case
          SgType *lhsBase = SageInterface::getElementType(lhsType),
                 *rhsBase = SageInterface::getElementType(rhsType);

       /* Note that we return an SgPointerType regardless of whether the original
        * type was an SgPointerType or SgArrayType.  This is because the latter
        * undergoes implicit array-to-pointer conversion. */
          if (lhsBase != NULL && rhsBase == NULL)
             {
               return SgPointerType::createType(lhsBase);
             }
          else if (lhsBase == NULL && rhsBase != NULL)
             {
               return SgPointerType::createType(rhsBase);
             }
          else if (lhsBase != NULL && rhsBase != NULL && variantT() == V_SgSubtractOp)
             {
            // TODO: return ptrdiff_t
               return lhsType;
             }
        }

     return lhsType;
   }

SgExpression*
SgBinaryOp::get_next(int& n) const
   {
     if(n==0)
        {
          n++;
          return get_lhs_operand();
        }
       else
        {
          if (n==1)
             {
               n++;
               return get_rhs_operand();
             }
        }

     return 0;
   }

int
SgBinaryOp::replace_expression(SgExpression *o, SgExpression *n)
   {
  // DQ (12/17/2006): This function should have the semantics that it will represent a
  // structural change to the AST, thus it is free to set the parent of the new expression.

     ROSE_ASSERT(o != NULL);
     ROSE_ASSERT(n != NULL);

     if (get_lhs_operand() == o)
        {
          set_lhs_operand(n);
          return 1;
        }
       else
          if (get_rhs_operand() == o)
             {
               set_rhs_operand(n);
               return 1;
             }
            else
             {
               printf ("Warning: inside of SgBinaryOp::replace_expression original SgExpression unidentified \n");
               return 0;
             }
   }

SOURCE_BINARY_EXPRESSION_END


SOURCE_EXPRESSION_ROOT_START
//QY:9/30/2004: removed stmt pointer inside exprRoot. Use parent pointer instead.
#if 0
void
SgExpressionRoot::initialize_root ( SgExpression* exp, SgStatement* stmt )
   {
  // The root of an expression should be an expression.
  // If the expression's parent is a statement then the
  // statement should contain an expression root object.

  // stmt should always be initialized to calling object's this pointer
     ROSE_ASSERT(stmt != NULL);

  // set the parent of this expression to the calling statement
  // (this might be better off set to NULL or some other value!)
  // set_parent(stmt);
  // Let the parent of the expression root be NULL (since it really should be an expression type)
  // Access the parent through the p_statement pointer!
  // set_parent(NULL);
  // We can't call the set_parent function because it can't take a NULL pointer

  // We don't want to call set_statement since this will attempt to
  // initialize the parent of stmt (which would be backwards)
  // set_statement(stmt);
  // p_statement = stmt;
  // call the modified set_statement function
     set_statement(stmt);

  // We use the SgExpressionRoot as the parent of the exp
  // (this is the purpose of the SgExpressionRoot object)
// #ifndef REMOVE_SET_PARENT_FUNCTION
     if (exp)
          exp->set_parent(this);
// #endif
     set_operand(exp);
   }
#endif

#if 0
// DQ (1/14/2006): set_type is removed
void
SgExpressionRoot::set_type()
   {
     if (get_operand())
          set_expression_type(get_operand()->get_type());
       else
          set_expression_type(SgTypeDefault::createType());
   }
#endif

#if 0
// DQ (12/17/2006): Removed to clean up code (not used, I think).
//QY:9/30/2004: removed stmt pointer inside exprRoot. Use parent pointer instead.
void
SgExpressionRoot::set_statement( SgStatement* stmt )
   {
     set_parent(stmt);
   }

//QY:9/30/2004: removed stmt pointer inside exprRoot. Use parent pointer instead.
SgStatement*
SgExpressionRoot::get_statement() const
   {
     if (get_parent() == 0)
        return 0;
     SgStatement* res= isSgStatement( get_parent());
     assert(res != 0);
     return res;
   }
#endif

SOURCE_EXPRESSION_ROOT_END


SOURCE_EXPRESSION_LIST_EXPRESSION_START
bool
SgExprListExp::empty() const
   {
     if (p_expressions.empty())
          return 1;
       else
          return 0;
   }

SgExpressionPtrList&
SgExprListExp::get_expressions()
   { return p_expressions; }

const SgExpressionPtrList&
SgExprListExp::get_expressions() const
   { return p_expressions; }

void SgExprListExp::set_expressions(SgExpressionPtrList e_list) 
   { p_expressions= e_list; }

void
SgExprListExp::append_expression(SgExpression *what)
   { what->set_parent(this); p_expressions.push_back(what); }

void
SgExprListExp::prepend_expression(SgExpression *what)
   { what->set_parent(this); p_expressions.insert(p_expressions.begin(), what); }

#if 0
void
SgExprListExp::insert_expression(const SgExpressionPtrList::iterator &where, SgExpression *what)
   {
// #ifndef REMOVE_SET_PARENT_FUNCTION
     what->set_parent(this);
// #endif
     p_expressions.insert(where,what);
   }
#endif

#if 0
SgExpression*
SgExprListExp::get_first() const
   {
     if(get_expressions().empty())
          return 0;
     SgExpressionPtrList::const_iterator p=get_expressions().begin();
     ROSE_ASSERT( (*p) != NULL );
     return (*p);
   }
#endif

#if 0
SgExpression*
SgExprListExp::get_end() const
   {
     return NULL;
   }
#endif

#if 0
int
SgExprListExp::get_index(SgExpression *e) const
   {
     if(get_expressions().empty()) return -1;
     SgExpressionPtrList::const_iterator p=get_expressions().begin();
     int i=0;
     while(p!=p_expressions.end())
        {
#if 0
          if( (*p).irep()== e )
             return i;
#else
          printf ("ERROR: not yet implemented in SAGE3 \n");
          abort();
#endif
          i++;
          p++;
        }
     return -1;
   }
#endif

#if 1
int
SgExprListExp::replace_expression(SgExpression *o, SgExpression *n)
   {
  // DQ (10/5/2007): This is a new version of this function (from Jeremiah) which observes STL vector iterator semantics.

  // DQ (12/17/2006): This function should have the semantics that it will represent a
  // structural change to the AST, thus it is free to set the parent of the new expression.

     ROSE_ASSERT(o != NULL);
     ROSE_ASSERT(n != NULL);

     for (SgExpressionPtrList::iterator i=p_expressions.begin();
          i != p_expressions.end(); ++i)
        {
          if( (*i) == o)
             {
               *i = n;
               return 1;
             }
        }
     return 0;
   }
#else
int
SgExprListExp::replace_expression(SgExpression *o, SgExpression *n)
   {
  // DQ (12/17/2006): This function should have the semantics that it will represent a
  // structural change to the AST, thus it is free to set the parent of the new expression.

     ROSE_ASSERT(o != NULL);
     ROSE_ASSERT(n != NULL);

     SgExpressionPtrList::iterator i=p_expressions.begin();
     while (i != p_expressions.end())
        {
          if( (*i) == o)
             {
               insert_expression(i, n);
               p_expressions.erase(i);
               return 1;
             }
/*
          printf ("ERROR: not yet implemented in SAGE3 \n");
          abort();
*/
          i++;
        }
     return 0;
   }
#endif

#if 0
void
SgExprListExp::insert_expression(SgExpression *o, SgExpression *n, int inFront)
   {
     SgExpressionPtrList::iterator i=p_expressions.begin();
     while(i!=p_expressions.end())
        {
#if 0
          if((*i).irep() == o)
             {
               if(!inFront) i++;
#ifndef REMOVE_SET_PARENT_FUNCTION
               n->set_parent(this);
#endif
               insert_expression(i,n);
             }
#else
          printf ("ERROR: not yet implemented in SAGE3 \n");
          abort();
#endif
        }
   }
#endif

SOURCE_EXPRESSION_LIST_EXPRESSION_END


SOURCE_VARIABLE_REFERENCE_EXPRESSION_START
#if 0
// DQ (11/7/2007): I think this is not used any more.
void
SgVarRefExp::fixupCopy(SgNode* copy, SgCopyHelp & help) const
   {
  // This is the empty default inplementation, not a problem if it is called!
     printf ("Inside of SgVarRefExp::fixupCopy() \n");

     SgVarRefExp* variableRefExpression_copy = isSgVarRefExp(copy);

  // We could first check if the declarations are the same, but that would not imply that they had to be reset!

     ROSE_ASSERT(variableRefExpression_copy->get_symbol() != NULL);
     SgNode* declaration_key = variableRefExpression_copy->get_symbol()->get_declaration();
     ROSE_ASSERT(declaration_key != NULL);

  // If this is a reference to a declaration that was copied, then we have a new symbol that should be referencec by the reference.
  // The declaration is saved into a map held as state in the SgCopyHelp object.
     SgCopyHelp::copiedNodeMapTypeIterator i = help.get_copiedNodeMap().find(declaration_key);
     if (i != help.get_copiedNodeMap().end())
        {
       // Found the key (a declaration SgDeclarationStatement or a SgInitializedName) so get the symbol and reset the symbol in the referencec to the value's associated symbol!
          SgNode* declaration_value = i->second;
          SgInitializedName* initializedName_copy = isSgInitializedName(declaration_value);
          ROSE_ASSERT(initializedName_copy != NULL);
          SgSymbol* symbol_copy = initializedName_copy->get_symbol_from_symbol_table();

       // DQ (10/8/2007): It might be too early to expect this to work!
       // ROSE_ASSERT(symbol_copy != NULL);
          printf ("Inside of SgVarRefExp::fixupCopy(): symbol_copy = %p \n",symbol_copy);
          if (symbol_copy != NULL)
             {
               SgVariableSymbol* variableSymbol_copy = isSgVariableSymbol(symbol_copy);
               ROSE_ASSERT(variableSymbol_copy != NULL);
               variableRefExpression_copy->set_symbol(variableSymbol_copy);
             }
        }
   }
#endif

// DQ (6/11/2015): Moved these six access functions, they should not be generated by ROSETTA
// so that we could avoid them setting the isModified flag which is a problem in the
// name qualification support for C++ (interfering with the token-based unparsing).
int
SgVarRefExp::get_name_qualification_length () const
   {
     ROSE_ASSERT (this != NULL);
     return p_name_qualification_length;
   }

void
SgVarRefExp::set_name_qualification_length ( int name_qualification_length )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_name_qualification_length = name_qualification_length;
   }

bool
SgVarRefExp::get_type_elaboration_required () const
   {
     ROSE_ASSERT (this != NULL);
     return p_type_elaboration_required;
   }

void
SgVarRefExp::set_type_elaboration_required ( bool type_elaboration_required )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_type_elaboration_required = type_elaboration_required;
   }

bool
SgVarRefExp::get_global_qualification_required () const
   {
     ROSE_ASSERT (this != NULL);
     return p_global_qualification_required;
   }

void
SgVarRefExp::set_global_qualification_required ( bool global_qualification_required )
   {
     ROSE_ASSERT (this != NULL);

  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_global_qualification_required = global_qualification_required;
   }

SOURCE_VARIABLE_REFERENCE_EXPRESSION_END

SOURCE_NONREAL_REF_EXPRESSION_START
int
SgNonrealRefExp::get_name_qualification_length () const
   {
     ROSE_ASSERT (this != NULL);
     return p_name_qualification_length;
   }

void
SgNonrealRefExp::set_name_qualification_length ( int name_qualification_length )
   {
     ROSE_ASSERT (this != NULL);
     p_name_qualification_length = name_qualification_length;
   }

bool
SgNonrealRefExp::get_type_elaboration_required () const
   {
     ROSE_ASSERT (this != NULL);
     return p_type_elaboration_required;
   }

void
SgNonrealRefExp::set_type_elaboration_required ( bool type_elaboration_required )
   {
     ROSE_ASSERT (this != NULL);
     p_type_elaboration_required = type_elaboration_required;
   }

bool
SgNonrealRefExp::get_global_qualification_required () const
   {
     ROSE_ASSERT (this != NULL);
     return p_global_qualification_required;
   }

void
SgNonrealRefExp::set_global_qualification_required ( bool global_qualification_required )
   {
     ROSE_ASSERT (this != NULL);

     p_global_qualification_required = global_qualification_required;
   }
SOURCE_NONREAL_REF_EXPRESSION_END

SOURCE_COMPOUND_LITERAL_EXPRESSION_START
SOURCE_COMPOUND_LITERAL_EXPRESSION_END


SOURCE_LABEL_REFERENCE_EXPRESSION_START

SgName
SgLabelRefExp::get_name() const
   {
     ROSE_ASSERT(p_symbol != NULL);
     return p_symbol->get_name();
   }

int
SgLabelRefExp::get_numeric_label_value() const
   {
     ROSE_ASSERT(p_symbol != NULL);
     return p_symbol->get_numeric_label_value();
   }

bool
SgLabelRefExp::isFunctionCallArgumentForAlternativeReturnType() const
   {
  // We might want to make sure that this is for a Fortran AST.

  // This is relevant more for type checking than for the unparing since a SgLabel expression will always be output using "*" syntax.

  // However initial results from this test is showing that the function type arguments list is at least sometime empty when it should not be.

     bool returnValue = false;

#if 0
  // SgFunctionCallExp* enclosingFunctionCall = SageInterface::getEnclosingNode<SgFunctionCallExp>(this);
     SgNode* tmp_enclosingFunctionCall = SageInterface::getEnclosingNode<SgFunctionCallExp>(this);
     ROSE_ASSERT(tmp_enclosingFunctionCall != NULL);

     SgNode* tmp_exprListExp = SageInterface::getEnclosingNode<SgExprListExp>(this);
     ROSE_ASSERT(tmp_exprListExp != NULL);

  // Compute the index position of the current element (finish later)...
     size_t positionInList = 1;

     SgFunctionCallExp* enclosingFunctionCall = isSgFunctionCallExp(tmp_enclosingFunctionCall);
     ROSE_ASSERT(enclosingFunctionCall != NULL);

     SgExpression* tmp_functionRefExp = enclosingFunctionCall->get_function();
     ROSE_ASSERT(tmp_functionRefExp != NULL);

  // Could this alternatively be a Fortran procedure pointer?
     SgFunctionRefExp* functionRefExp = isSgFunctionRefExp(tmp_functionRefExp);
     ROSE_ASSERT(functionRefExp != NULL);

     SgType* tmp_functionType = functionRefExp->get_type();
     ROSE_ASSERT(tmp_functionRefExp != NULL);
     SgFunctionType* functionType = isSgFunctionType(tmp_functionType);
     ROSE_ASSERT(functionType != NULL);

     SgFunctionParameterTypeList* functionParameterTypeList = functionType->get_argument_list();
     ROSE_ASSERT(functionParameterTypeList != NULL);

     SgTypePtrList & functionTypeArguments = functionParameterTypeList->get_arguments();

     printf ("functionTypeArguments.size() = %" PRIuPTR " \n",functionTypeArguments.size());
     ROSE_ASSERT(positionInList < functionTypeArguments.size());

     SgType* tmp_thisParametersType = functionTypeArguments[positionInList];
     ROSE_ASSERT(tmp_thisParametersType != NULL);

     SgTypeLabel* labelType = isSgTypeLabel(tmp_thisParametersType);

     returnValue = (labelType != NULL);

     printf ("In SgLabelRefExp::isFunctionCallArgumentForAlternativeReturnType(): returnValue = %s \n",returnValue ? "true" : "false");
#endif

     return returnValue;
   }

#if 0
const SgName &
SgLabelRefExp::get_name() const
   {
     ROSE_ASSERT(p_symbol != NULL);
     return p_symbol->get_name();
   }
#endif

SOURCE_LABEL_REFERENCE_EXPRESSION_END


SOURCE_CLASS_NAME_REFERENCE_EXPRESSION_START
SOURCE_CLASS_NAME_REFERENCE_EXPRESSION_END


SOURCE_LAMBDA_EXPRESSION_START

SgType*
SgLambdaExp::get_type() const
   {
  // DQ (9/2/2014): I think we want this to be the return type of the function (deduced or not).

#if 0
     printf ("In SgLambdaExp::get_type() \n");
#endif

     return SageBuilder::buildVoidType(); // TODO this is wrong
   }

SOURCE_LAMBDA_EXPRESSION_END


SOURCE_FUNCTION_REFERENCE_EXPRESSION_START

#if 0
// DQ (11/7/2007): I think this is not used any more.
void
SgFunctionRefExp::fixupCopy(SgNode* copy, SgCopyHelp & help) const
   {
  // This is the empty default inplementation, not a problem if it is called!
     printf ("Inside of SgFunctionRefExp::fixupCopy() \n");

     SgFunctionRefExp* functionRefExpression_copy = isSgFunctionRefExp(copy);

  // We could first check if the declarations are the same, but that would not imply that they had to be reset!

     ROSE_ASSERT(functionRefExpression_copy->get_symbol() != NULL);
     SgNode* declaration_key = functionRefExpression_copy->get_symbol()->get_declaration();
     ROSE_ASSERT(declaration_key != NULL);

  // If this is a reference to a declaration that was copied, then we have a new symbol that should be referencec by the reference.
  // The declaration is saved into a map held as state in the SgCopyHelp object.
     SgCopyHelp::copiedNodeMapTypeIterator i = help.get_copiedNodeMap().find(declaration_key);
     if (i != help.get_copiedNodeMap().end())
        {
       // Found the key (a declaration SgDeclarationStatement or a SgInitializedName) so get the symbol and reset the symbol in the referencec to the value's associated symbol!
          SgNode* declaration_value = i->second;
          SgFunctionDeclaration* functionDeclaration_copy = isSgFunctionDeclaration(declaration_value);
          ROSE_ASSERT(functionDeclaration_copy != NULL);
          SgSymbol* symbol_copy = functionDeclaration_copy->get_symbol_from_symbol_table();
       // ROSE_ASSERT(symbol_copy != NULL);
          if (symbol_copy != NULL)
             {
               SgFunctionSymbol* functionSymbol_copy = isSgFunctionSymbol(symbol_copy);
               ROSE_ASSERT(functionSymbol_copy != NULL);
               functionRefExpression_copy->set_symbol(functionSymbol_copy);
             }
        }
   }
#endif

void
SgFunctionRefExp::post_construction_initialization()
   {
  // DQ (1/14/2006): set_type is removed
  // if (! get_function_type())
  //      set_type();
   }

SgFunctionSymbol*
SgFunctionRefExp::get_symbol() const
   { return get_symbol_i(); }

void
SgFunctionRefExp::set_symbol(SgFunctionSymbol * symbol)
   {
     set_symbol_i(symbol);

  // DQ (1/14/2006): set_type is removed
  // set_type();
   }


SgFunctionDeclaration*
SgFunctionRefExp::getAssociatedFunctionDeclaration() const
   {
  // This is helpful in chasing down the associated declaration to this function reference.
     SgFunctionDeclaration* returnFunctionDeclaration = NULL;
     SgFunctionSymbol* functionSymbol = this->get_symbol();

  // DQ (2/8/2009): Can we assert this! What about pointers to functions?
     ROSE_ASSERT(functionSymbol != NULL);

  // It might be that a pointer to a function would not have a symbol.
     if (functionSymbol != NULL)
          returnFunctionDeclaration = functionSymbol->get_declaration();

     return returnFunctionDeclaration;
   }

// DQ (6/11/2015): Moved these six access functions, they should not be generated by ROSETTA
// so that we could avoid them setting the isModified flag which is a problem in the
// name qualification support for C++ (interfering with the token-based unparsing).
int
SgFunctionRefExp::get_name_qualification_length () const
   {
     ROSE_ASSERT (this != NULL);
     return p_name_qualification_length;
   }

void
SgFunctionRefExp::set_name_qualification_length ( int name_qualification_length )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_name_qualification_length = name_qualification_length;
   }

bool
SgFunctionRefExp::get_type_elaboration_required () const
   {
     ROSE_ASSERT (this != NULL);
     return p_type_elaboration_required;
   }

void
SgFunctionRefExp::set_type_elaboration_required ( bool type_elaboration_required )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_type_elaboration_required = type_elaboration_required;
   }

bool
SgFunctionRefExp::get_global_qualification_required () const
   {
     ROSE_ASSERT (this != NULL);
     return p_global_qualification_required;
   }

void
SgFunctionRefExp::set_global_qualification_required ( bool global_qualification_required )
   {
     ROSE_ASSERT (this != NULL);

  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_global_qualification_required = global_qualification_required;
   }

SOURCE_FUNCTION_REFERENCE_EXPRESSION_END


SOURCE_MEMBER_FUNCTION_REFERENCE_EXPRESSION_START

void
SgMemberFunctionRefExp::post_construction_initialization()
   {
   }

SgMemberFunctionSymbol*
SgMemberFunctionRefExp::get_symbol() const
   { return get_symbol_i(); }

void
SgMemberFunctionRefExp::set_symbol(SgMemberFunctionSymbol * symbol)
   {
     set_symbol_i(symbol);

  // DQ (1/14/2006): set_type is removed
  // set_type();
   }

#if 0
void
SgMemberFunctionRefExp::set_type()
   {
     SgMemberFunctionSymbol *mfsym = get_symbol();
     ROSE_ASSERT(mfsym != NULL);
     p_function_type = (SgFunctionType *)(mfsym->get_type());
     if ( p_function_type == NULL )
        {
          cout << "bad" << mfsym->get_name().str() << endl;

       // DQ (9/12/2004): Made this an error (I think it should be and it is in the case of a function pointer)
          ROSE_ASSERT(false);
        }
   }
#endif

// DQ (2/8/2009): I always wanted to have this function!
SgMemberFunctionDeclaration*
SgMemberFunctionRefExp::getAssociatedMemberFunctionDeclaration() const
   {
  // This is helpful in chasing down the associated declaration to this member function reference.
     SgMemberFunctionDeclaration* returnMemberFunctionDeclaration = NULL;
     SgMemberFunctionSymbol* memberFunctionSymbol = this->get_symbol();

  // DQ (2/8/2009): Can we assert this! What about pointers to functions?
     ROSE_ASSERT(memberFunctionSymbol != NULL);

  // It might be that a pointer to a function would not have a symbol.
     if (memberFunctionSymbol != NULL)
          returnMemberFunctionDeclaration = memberFunctionSymbol->get_declaration();

     return returnMemberFunctionDeclaration;
   }

// DQ (6/11/2015): Moved these six access functions, they should not be generated by ROSETTA
// so that we could avoid them setting the isModified flag which is a problem in the
// name qualification support for C++ (interfering with the token-based unparsing).
int
SgMemberFunctionRefExp::get_name_qualification_length () const
   {
     ROSE_ASSERT (this != NULL);
     return p_name_qualification_length;
   }

void
SgMemberFunctionRefExp::set_name_qualification_length ( int name_qualification_length )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_name_qualification_length = name_qualification_length;
   }

bool
SgMemberFunctionRefExp::get_type_elaboration_required () const
   {
     ROSE_ASSERT (this != NULL);
     return p_type_elaboration_required;
   }

void
SgMemberFunctionRefExp::set_type_elaboration_required ( bool type_elaboration_required )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_type_elaboration_required = type_elaboration_required;
   }

bool
SgMemberFunctionRefExp::get_global_qualification_required () const
   {
     ROSE_ASSERT (this != NULL);
     return p_global_qualification_required;
   }

void
SgMemberFunctionRefExp::set_global_qualification_required ( bool global_qualification_required )
   {
     ROSE_ASSERT (this != NULL);

  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_global_qualification_required = global_qualification_required;
   }

SOURCE_MEMBER_FUNCTION_REFERENCE_EXPRESSION_END


SOURCE_TEMPLATE_FUNCTION_REFERENCE_EXPRESSION_START

void
SgTemplateFunctionRefExp::post_construction_initialization()
   {
   }

SgTemplateFunctionSymbol*
SgTemplateFunctionRefExp::get_symbol() const
   {
  // return isSgTemplateFunctionSymbol(get_symbol_i());
     return get_symbol_i();
   }

void
SgTemplateFunctionRefExp::set_symbol(SgTemplateFunctionSymbol * symbol)
   {
     set_symbol_i(symbol);
   }

SgTemplateFunctionDeclaration*
SgTemplateFunctionRefExp::getAssociatedFunctionDeclaration() const
   {
  // This is helpful in chasing down the associated declaration to this function reference.
     SgTemplateFunctionDeclaration* returnFunctionDeclaration = NULL;
     SgTemplateFunctionSymbol*      functionSymbol            = this->get_symbol();

     ROSE_ASSERT(functionSymbol != NULL);

     if (functionSymbol != NULL)
          returnFunctionDeclaration = isSgTemplateFunctionDeclaration(functionSymbol->get_declaration());

     return returnFunctionDeclaration;
   }

// DQ (6/11/2015): Moved these six access functions, they should not be generated by ROSETTA
// so that we could avoid them setting the isModified flag which is a problem in the
// name qualification support for C++ (interfering with the token-based unparsing).
int
SgTemplateFunctionRefExp::get_name_qualification_length () const
   {
     ROSE_ASSERT (this != NULL);
     return p_name_qualification_length;
   }

void
SgTemplateFunctionRefExp::set_name_qualification_length ( int name_qualification_length )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_name_qualification_length = name_qualification_length;
   }

bool
SgTemplateFunctionRefExp::get_type_elaboration_required () const
   {
     ROSE_ASSERT (this != NULL);
     return p_type_elaboration_required;
   }

void
SgTemplateFunctionRefExp::set_type_elaboration_required ( bool type_elaboration_required )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_type_elaboration_required = type_elaboration_required;
   }

bool
SgTemplateFunctionRefExp::get_global_qualification_required () const
   {
     ROSE_ASSERT (this != NULL);
     return p_global_qualification_required;
   }

void
SgTemplateFunctionRefExp::set_global_qualification_required ( bool global_qualification_required )
   {
     ROSE_ASSERT (this != NULL);

  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_global_qualification_required = global_qualification_required;
   }

SOURCE_TEMPLATE_FUNCTION_REFERENCE_EXPRESSION_END


SOURCE_TEMPLATE_MEMBER_FUNCTION_REFERENCE_EXPRESSION_START

void
SgTemplateMemberFunctionRefExp::post_construction_initialization()
   {
   }

SgTemplateMemberFunctionSymbol*
SgTemplateMemberFunctionRefExp::get_symbol() const
   {
  // return isSgTemplateMemberFunctionSymbol(get_symbol_i());
     return get_symbol_i();
   }

void
SgTemplateMemberFunctionRefExp::set_symbol(SgTemplateMemberFunctionSymbol * symbol)
   {
     set_symbol_i(symbol);
   }

// DQ (2/8/2009): I always wanted to have this function!
SgTemplateMemberFunctionDeclaration*
SgTemplateMemberFunctionRefExp::getAssociatedMemberFunctionDeclaration() const
   {
  // This is helpful in chasing down the associated declaration to this member function reference.
     SgTemplateMemberFunctionDeclaration* returnMemberFunctionDeclaration = NULL;
     SgTemplateMemberFunctionSymbol*      memberFunctionSymbol            = this->get_symbol();

     ROSE_ASSERT(memberFunctionSymbol != NULL);

     if (memberFunctionSymbol != NULL)
          returnMemberFunctionDeclaration = isSgTemplateMemberFunctionDeclaration(memberFunctionSymbol->get_declaration());

     return returnMemberFunctionDeclaration;
   }

// DQ (6/11/2015): Moved these six access functions, they should not be generated by ROSETTA
// so that we could avoid them setting the isModified flag which is a problem in the
// name qualification support for C++ (interfering with the token-based unparsing).
int
SgTemplateMemberFunctionRefExp::get_name_qualification_length () const
   {
     ROSE_ASSERT (this != NULL);
     return p_name_qualification_length;
   }

void
SgTemplateMemberFunctionRefExp::set_name_qualification_length ( int name_qualification_length )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_name_qualification_length = name_qualification_length;
   }

bool
SgTemplateMemberFunctionRefExp::get_type_elaboration_required () const
   {
     ROSE_ASSERT (this != NULL);
     return p_type_elaboration_required;
   }

void
SgTemplateMemberFunctionRefExp::set_type_elaboration_required ( bool type_elaboration_required )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_type_elaboration_required = type_elaboration_required;
   }

bool
SgTemplateMemberFunctionRefExp::get_global_qualification_required () const
   {
     ROSE_ASSERT (this != NULL);
     return p_global_qualification_required;
   }

void
SgTemplateMemberFunctionRefExp::set_global_qualification_required ( bool global_qualification_required )
   {
     ROSE_ASSERT (this != NULL);

  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_global_qualification_required = global_qualification_required;
   }

SOURCE_TEMPLATE_MEMBER_FUNCTION_REFERENCE_EXPRESSION_END

SOURCE_VALUE_EXPRESSION_START

SOURCE_VALUE_EXPRESSION_END


SOURCE_BOOLEAN_VALUE_EXPRESSION_START
SOURCE_BOOLEAN_VALUE_EXPRESSION_END


SOURCE_NULLPTR_VALUE_EXPRESSION_START
SOURCE_NULLPTR_VALUE_EXPRESSION_END


SOURCE_VOID_VALUE_EXPRESSION_START
SOURCE_VOID_VALUE_EXPRESSION_END


SOURCE_STRING_VALUE_EXPRESSION_START

void
$CLASSNAME::post_construction_initialization()
   {
  // We can't initialize this to NULL since it might have just been set!
  // p_value = (char*)0L;
   }

#if 0
$CLASSNAME::$CLASSNAME ( Sg_File_Info* file_info, string value )
   : $BASECLASS(file_info)
   {
  // Build a custom constructor since we have to make a
  // copy (using strdup(char*)) of the input string (value)

  // Copy the string (else it is lost and not represented in the unparsed output code)
  // p_value = (value == 0)? 0 : strdup(value);
     p_value = value;

  // Test the variant virtual function
     assert(STRING_VAL == variant());
     post_construction_initialization();

  // Test the isSgStringVal() function since it has been problematic
     assert(isSgStringVal(this) != NULL);
   }
#endif

#if 0
$CLASSNAME::~$CLASSNAME()
   {
  // Delete the array of char (so use "delete []")
     delete [] p_value;
     p_value = NULL;
   }
#endif

void $CLASSNAME::set_usesSingleQuotes(bool usesSingleQuotes)
{
  if (usesSingleQuotes)
  {
    set_stringDelimiter('\'');
  }
  else if (get_usesSingleQuotes())
  {
    // unset only if the current delimiter uses single quotes
    set_stringDelimiter(0);
  }
}

void $CLASSNAME::set_usesDoubleQuotes(bool usesDoubleQuotes)
{
  if (usesDoubleQuotes)
  {
    set_stringDelimiter('"');
  }
  else if (get_usesDoubleQuotes())
  {
    // unset only if the current delimiter uses double quotes
    set_stringDelimiter(0);
  }
}

SOURCE_STRING_VALUE_EXPRESSION_END


SOURCE_SHORT_VALUE_EXPRESSION_START
SOURCE_SHORT_VALUE_EXPRESSION_END


SOURCE_CHAR_VALUE_EXPRESSION_START
SOURCE_CHAR_VALUE_EXPRESSION_END


SOURCE_UNSIGNED_CHAR_VALUE_EXPRESSION_START
SOURCE_UNSIGNED_CHAR_VALUE_EXPRESSION_END


SOURCE_WCHAR_VALUE_EXPRESSION_START
void
$CLASSNAME::post_construction_initialization()
   {
  // We can't initialize this to NULL since it might have just been set!
  // p_valueUL = 0L;
   }

wchar_t
$CLASSNAME::get_value() const
   {
     return p_valueUL;
   }

void
$CLASSNAME::set_value(wchar_t new_val)
   {
     p_valueUL = new_val;
   }

SOURCE_WCHAR_VALUE_EXPRESSION_END


SOURCE_CHAR16_VALUE_EXPRESSION_START
void
$CLASSNAME::post_construction_initialization()
   {
  // We can't initialize this to NULL since it might have just been set!
  // p_valueUL = 0L;
   }

// DQ (2/16/2018): ROSE needs to be able to be compiled on non C++11 systems where char_32_t is not defiled.
// char16_t
unsigned short
$CLASSNAME::get_value() const
   {
     return p_valueUL;
   }

// void $CLASSNAME::set_value(char16_t new_val)
void
$CLASSNAME::set_value(unsigned short new_val)
   {
     p_valueUL = new_val;
   }

SOURCE_CHAR16_VALUE_EXPRESSION_END


SOURCE_CHAR32_VALUE_EXPRESSION_START
void
$CLASSNAME::post_construction_initialization()
   {
  // We can't initialize this to NULL since it might have just been set!
  // p_valueUL = 0L;
   }

// DQ (2/16/2018): ROSE needs to be able to be compiled on non C++11 systems where char_32_t is not defiled.
// char32_t
unsigned int
$CLASSNAME::get_value() const
   {
     return p_valueUL;
   }

// void $CLASSNAME::set_value(char32_t new_val)
void
$CLASSNAME::set_value(unsigned int new_val)
   {
     p_valueUL = new_val;
   }

SOURCE_CHAR32_VALUE_EXPRESSION_END


SOURCE_UNSIGNED_SHORT_VALUE_EXPRESSION_START
SOURCE_UNSIGNED_SHORT_VALUE_EXPRESSION_END


SOURCE_INTEGER_VALUE_EXPRESSION_START
SOURCE_INTEGER_VALUE_EXPRESSION_END


SOURCE_ENUM_VALUE_EXPRESSION_START

// DQ (2/5/2020): Addedin custom get_type() function so that we can pass the associated SgEnumDeclaration.
SgType* SgEnumVal::get_type() const
   {
#if 0
     printf ("In SgEnumVal::get_type() \n");
#endif

     SgEnumDeclaration* enumDeclaration = this->get_declaration();
     ROSE_ASSERT(enumDeclaration != NULL);

     return SgEnumType::createType(enumDeclaration);
   }

// DQ (6/11/2015): Moved these six access functions, they should not be generated by ROSETTA
// so that we could avoid them setting the isModified flag which is a problem in the
// name qualification support for C++ (interfering with the token-based unparsing).
int
SgEnumVal::get_name_qualification_length () const
   {
     ROSE_ASSERT (this != NULL);
     return p_name_qualification_length;
   }

void
SgEnumVal::set_name_qualification_length ( int name_qualification_length )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_name_qualification_length = name_qualification_length;
   }

bool
SgEnumVal::get_type_elaboration_required () const
   {
     ROSE_ASSERT (this != NULL);
     return p_type_elaboration_required;
   }

void
SgEnumVal::set_type_elaboration_required ( bool type_elaboration_required )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_type_elaboration_required = type_elaboration_required;
   }

bool
SgEnumVal::get_global_qualification_required () const
   {
     ROSE_ASSERT (this != NULL);
     return p_global_qualification_required;
   }

void
SgEnumVal::set_global_qualification_required ( bool global_qualification_required )
   {
     ROSE_ASSERT (this != NULL);

  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_global_qualification_required = global_qualification_required;
   }

SOURCE_ENUM_VALUE_EXPRESSION_END


SOURCE_UNSIGNED_INTEGER_VALUE_EXPRESSION_START
SOURCE_UNSIGNED_INTEGER_VALUE_EXPRESSION_END


SOURCE_LONG_INTEGER_VALUE_EXPRESSION_START
SOURCE_LONG_INTEGER_VALUE_EXPRESSION_END


SOURCE_LONG_LONG_INTEGER_VALUE_EXPRESSION_START
SOURCE_LONG_LONG_INTEGER_VALUE_EXPRESSION_END


SOURCE_UNSIGNED_LONG_LONG_INTEGER_VALUE_EXPRESSION_START
SOURCE_UNSIGNED_LONG_LONG_INTEGER_VALUE_EXPRESSION_END


SOURCE_UNSIGNED_LONG_VALUE_EXPRESSION_START
SOURCE_UNSIGNED_LONG_VALUE_EXPRESSION_END


SOURCE_FLOAT_VALUE_EXPRESSION_START
SOURCE_FLOAT_VALUE_EXPRESSION_END


SOURCE_DOUBLE_VALUE_EXPRESSION_START
SOURCE_DOUBLE_VALUE_EXPRESSION_END


SOURCE_LONG_DOUBLE_VALUE_EXPRESSION_START
SOURCE_LONG_DOUBLE_VALUE_EXPRESSION_END

SOURCE_FLOAT_80_VALUE_EXPRESSION_START
SOURCE_FLOAT_80_VALUE_EXPRESSION_END

SOURCE_FLOAT_128_VALUE_EXPRESSION_START
SOURCE_FLOAT_128_VALUE_EXPRESSION_END


SOURCE_TEMPLATE_PARAMETER_VALUE_EXPRESSION_START

SgName
SgTemplateParameterVal::get_template_parameter_name() const
   {
  // DQ (11/28/2011): Added to support template declarations in the AST.

  // Note that we have to store the index position into the template parameter list
  // so that this template parameter can be identified and its name used.  It
  // can be different from the template parameter name of the template class declaration
  // (which is the name referenced in EDG), so we have to find the enclosing template
  // declaration and use the index position into its template parameter list (which
  // can of course use different names).

  // DQ (7/24/2012): Added test.
     ROSE_ASSERT(this != NULL);

     ROSE_ASSERT(get_parent() != NULL);

  // DQ (7/24/2012): For the new EDG support (4.x) and new template handling, we don't use
  // a generic SgTemplateDeclaration; instead we have specific kinds of template declarations.
  // So templateDeclaration will always be NULL now.

     int template_parameter_position = get_template_parameter_position();

#if 0
     SgTemplateDeclaration* templateDeclaration = TransformationSupport::getTemplateDeclaration(this);
     if (templateDeclaration == NULL)
        {
          printf ("Error: In SgTemplateParameterVal::get_template_parameter_name(): templateDeclaration == NULL: this = %p = %s \n",this,this->class_name().c_str());
        }

#error "DEAD CODE!"

     ROSE_ASSERT(templateDeclaration != NULL);

     SgTemplateParameterPtrList & templateParameters = templateDeclaration->get_templateParameters();
#else
  // DQ (7/25/2012): This reflects the new design of how templates are supported in ROSE.
     SgDeclarationStatement* templateDeclaration = TransformationSupport::getTemplateDeclaration(this);
     if (templateDeclaration == NULL)
        {
          printf ("Error: In SgTemplateParameterVal::get_template_parameter_name(): templateDeclaration == NULL: this = %p = %s \n",this,this->class_name().c_str());

       // DQ (6/6/2013): If the template parameter is used as a template argument, then we just return a simple name.
       // Nowever, maybe the constant should have been shared so that it would be correctly associated with a template declaration.
          SgName name = "__template_parameter_used_as_template_argument__";
#if 0
          printf ("In SgTemplateParameterVal::get_template_parameter_name(): template_parameter_position = %d I think this is the case of a template parameter used as an argument to another template (see test2013_198.C) \n",template_parameter_position);
#endif
          return name;
        }
     ROSE_ASSERT(templateDeclaration != NULL);

     SgTemplateParameterPtrList* templateParameters = NULL;
     switch(templateDeclaration->variantT())
        {
          case V_SgTemplateDeclaration:               templateParameters = &(isSgTemplateDeclaration(templateDeclaration)->get_templateParameters());               break;
          case V_SgTemplateClassDeclaration:          templateParameters = &(isSgTemplateClassDeclaration(templateDeclaration)->get_templateParameters());          break;

       // DQ (2/1/2019): Bug fix, likely copy-paste error, casting to wrong type.
       // case V_SgTemplateFunctionDeclaration:       templateParameters = &(isSgTemplateMemberFunctionDeclaration(templateDeclaration)->get_templateParameters()); break;
          case V_SgTemplateFunctionDeclaration:       templateParameters = &(isSgTemplateFunctionDeclaration(templateDeclaration)->get_templateParameters());       break;

          case V_SgTemplateMemberFunctionDeclaration: templateParameters = &(isSgTemplateMemberFunctionDeclaration(templateDeclaration)->get_templateParameters()); break;
          case V_SgTemplateVariableDeclaration:       templateParameters = &(isSgTemplateVariableDeclaration(templateDeclaration)->get_templateParameters());       break;

          default:
             {
               printf ("Error: default reached in SgTemplateParameterVal::get_template_parameter_name(): templateDeclaration = %p = %s \n",templateDeclaration,templateDeclaration->class_name().c_str());
               ROSE_ASSERT(false);
             }
        }

     ROSE_ASSERT(templateParameters != NULL);
#endif

     long int numberOfTemplateParameters = (long int) templateParameters->size();

  // DQ (12/13/2011): this is a problem demonstrated by test2011_186.C, so we have to disable the template parameter position error checking.
     bool getParameterNameFromTemplateParameterList = true;
  // if (template_parameter_position >= (long int) templateParameters.size())
     if (template_parameter_position >= numberOfTemplateParameters)
        {
#if 0
          printf ("This is a reference to a template parameter in an outer scope (e.g. we are a part of a member function with out explicit templates within a templated class declaration) \n");
#endif
          getParameterNameFromTemplateParameterList = false;
        }

  // printf ("In SgTemplateParameterVal::get_template_parameter_name(): template_parameter_position = %d \n",template_parameter_position);
  // printf ("In SgTemplateParameterVal::get_template_parameter_name(): templateParameters.size()   = %" PRIuPTR " \n",templateParameters.size());

#if 0
  // if (template_parameter_position >= (long int)(templateParameters.size()))
     if (template_parameter_position >= numberOfTemplateParameters)
        {
          printf ("In SgTemplateParameterVal::get_template_parameter_name(): template_parameter_position = %d \n",template_parameter_position);
       // printf ("In SgTemplateParameterVal::get_template_parameter_name(): templateParameters.size()   = %" PRIuPTR " \n",templateParameters.size());
          printf ("In SgTemplateParameterVal::get_template_parameter_name(): numberOfTemplateParameters  = %" PRIuPTR " \n",numberOfTemplateParameters);
        }

     printf ("In SgTemplateParameterVal::get_template_parameter_name(): getParameterNameFromTemplateParameterList = %s \n",getParameterNameFromTemplateParameterList ? "true" : "false");
#endif

     SgName name;
     if (getParameterNameFromTemplateParameterList == true)
        {
          ROSE_ASSERT(template_parameter_position >= 0);
       // ROSE_ASSERT(template_parameter_position < (long int)(templateParameters.size()));
          ROSE_ASSERT(template_parameter_position < numberOfTemplateParameters);

       // SgTemplateParameter* templateParameter = templateParameters[position];

          name = "__template_parameter_name__error__";

          SgTemplateParameter* templateParameter = NULL;
          if (template_parameter_position >= 0)
             {
            // templateParameter = templateParameters[template_parameter_position];
               templateParameter = (*templateParameters)[template_parameter_position];
               ROSE_ASSERT(templateParameter != NULL);

            // printf ("In SgTemplateParameterVal::get_template_parameter_name(): templateParameter->get_parameterType() = %d \n",templateParameter->get_parameterType());

               ROSE_ASSERT(templateParameter->get_parameterType() == SgTemplateParameter::nontype_parameter);
            // ROSE_ASSERT(templateParameter->get_parameterType() == SgTemplateParameter::template_parameter);

               SgInitializedName* initializedName = templateParameter->get_initializedName();
               ROSE_ASSERT(initializedName != NULL);

            // name = "__template_parameter_name__";
               name = initializedName->get_name();

            // printf ("In SgTemplateParameterVal::get_template_parameter_name(): name of template parameter used = %s \n",name.str());
             }
        }
       else
        {
       // This is not the favored case since i think it can be problematic to use template parameter names.
          name = get_valueString();
#if 0
          printf ("In SgTemplateParameterVal::get_template_parameter_name(): Using the string in the template parameter value = %s \n",name.str());
#endif
        }

#if 0
     printf ("In SgTemplateParameterVal::get_template_parameter_name(): Using the string in the template parameteer value = %s \n",name.str());
#endif

     return name;
   }

SgType*
SgTemplateParameterVal::get_type() const
   {
  // DQ (8/6/2013): The correct type is now saved explicitly so that it can be used to disambiguate
  // template functions overloaded on template parameters. See test2013_303.C for an example.
     ROSE_ASSERT(this->get_valueType() != NULL);

#if 0
     printf ("In SgTemplateParameterVal::get_type() \n");
#endif

     return this->get_valueType();
   }


SOURCE_TEMPLATE_PARAMETER_VALUE_EXPRESSION_END


SOURCE_COMPLEX_VALUE_EXPRESSION_START
SOURCE_COMPLEX_VALUE_EXPRESSION_END

// SOURCE_LABEL_ADDRESS_VALUE_EXPRESSION_START
// SOURCE_LABEL_ADDRESS_VALUE_EXPRESSION_END

SOURCE_UPC_THREADS_EXPRESSION_START
SOURCE_UPC_THREADS_EXPRESSION_END


SOURCE_UPC_MYTHREAD_EXPRESSION_START
SOURCE_UPC_MYTHREAD_EXPRESSION_END


SOURCE_YIELD_EXPRESSION_START
SOURCE_YIELD_EXPRESSION_END


// DQ (7/25/2020): Adding C++17 language features (required for C++20 support).
SOURCE_AWAIT_EXPRESSION_START
SOURCE_AWAIT_EXPRESSION_END


// DQ (7/25/2020): Adding C++17 language features (required for C++20 support).
SOURCE_FOLD_EXPRESSION_START
SOURCE_FOLD_EXPRESSION_END


// DQ (7/25/2020): Adding C++17 language features (required for C++20 support).
SOURCE_CHOOSE_EXPRESSION_START
SOURCE_CHOOSE_EXPRESSION_END


// DQ (7/25/2020): Adding C++20 language features.
SOURCE_SPACESHIP_OPERATOR_START
SOURCE_SPACESHIP_OPERATOR_END


SOURCE_CALL_EXPRESSION_START

void
SgCallExpression::post_construction_initialization()
   {
     if (p_function != NULL)
          p_function->set_parent(this);
   }


SgExpression*
SgCallExpression::get_next(int& n) const
   {
     if(n==0)
        {
          n++;
          return get_function();
        }
       else
          if(p_args && n==1)
             {
               n++;
               return get_args();
             }

     return 0;
   }

#if 1
// DQ: trying to remove the nested iterator class
void
SgCallExpression::append_arg(SgExpression* what)
   {
     assert(this != NULL);

  // DQ (11/15/2006): avoid setting newArgs this late in the process.
     ROSE_ASSERT(p_args != NULL);
     if (p_args == NULL)
        {
       // set_args(new SgExprListExp(this->get_file_info()));
          SgExprListExp* newArgs = new SgExprListExp ( this->get_file_info() );
          assert(newArgs != NULL);
          newArgs->set_endOfConstruct( this->get_file_info() );
          set_args(newArgs);
        }

    // insert_arg(p_args->end(),what);
       p_args->append_expression(what);
   }
#endif

#if 0
// DQ: trying to remove the nested iterator class
// $CLASSNAME::insert_arg(const SgExpression::iterator& where, SgExpression* what)
void
SgCallExpression::insert_arg(const SgExpressionPtrList::iterator& where, SgExpression* what)
   {
     p_args->insert_expression(where,what);
   }
#endif


int
SgCallExpression::replace_expression(SgExpression *o, SgExpression *n)
   {
  // DQ (12/17/2006): This function should have the semantics that it will represent a
  // structural change to the AST, thus it is free to set the parent of the new expression.

     ROSE_ASSERT(o != NULL);
     ROSE_ASSERT(n != NULL);

     if (get_function() == o)
        {
          set_function(n);
          n->set_parent(this);

          return 1;
        }
       else
        {
          if (p_args == o)
             {
            // DQ (12/17/2006): Make this code safer (avoid passing NULL pointers to functions that we call!
            // set_args(isSgExprListExp(n));
               SgExprListExp* expressionList = isSgExprListExp(n);
               ROSE_ASSERT(expressionList != NULL);
               set_args(expressionList);
               n->set_parent(this);
               return 1;
             }
        }

     return 0;
   }

SgType*
SgCallExpression::get_type() const
   {
#if 0
     printf ("In SgCallExpression::get_type() \n");
#endif

     return SageBuilder::buildVoidType(); //TODO this is wrong
   }

SOURCE_CALL_EXPRESSION_END

SOURCE_FUNCTION_CALL_EXPRESSION_START

void
SgFunctionCallExp::post_construction_initialization()
   {
       SgCallExpression::post_construction_initialization();
   }


SgType*
SgFunctionCallExp::get_type() const
   {
  // DQ (1/14/2006): p_expression_type has been removed, we have to compute the appropriate type (IR specific code)

  // printf ("$CLASSNAME::get_type(): p_expression_type has been removed, we have to compute the appropriate type \n");

#if 0
     printf ("In SgFunctionCallExp::get_type() \n");
#endif

  // DQ (7/20/2006): Peter's patch now allows this function to be simplified to the following (suggested by Jeremiah).
     SgType* returnType = NULL;

     ROSE_ASSERT(p_function != NULL);
  // printf ("In SgFunctionCallExp::get_type(): calling get_type() on p_function = %p = %s \n",p_function,p_function->class_name().c_str());
     SgType* likelyFunctionType = p_function->get_type();
     ROSE_ASSERT(likelyFunctionType != NULL);
     while (likelyFunctionType && isSgTypedefType(likelyFunctionType))
        {
          likelyFunctionType = isSgTypedefType(likelyFunctionType)->get_base_type();
          ROSE_ASSERT(likelyFunctionType != NULL);
        }

     SgFunctionType* functionType = isSgFunctionType(likelyFunctionType);
     if (functionType == NULL)
        {
#if 1
       // DQ (8/26/2012): Decrease the volume of warnings from this part of the code.
#ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION
          static int count = 0;
          if (count++ % 100 == 0)
             {
               printf ("Warning: unexpected type found for likelyFunctionType = %p = %s \n",likelyFunctionType,likelyFunctionType->class_name().c_str());
             }
#endif
#else
          printf ("Warning: unexpected type found for likelyFunctionType = %p = %s \n",likelyFunctionType,likelyFunctionType->class_name().c_str());
#endif
       // get_file_info()->display("Location of call to SgFunctionCallExp::get_type(): debug");

       // DQ (7/15/2007): Handle case of typedef of function type
       // Milind Chabbi, after discussing with DQ (7/29/2013), we need to strip all. See test: CompileTests/Cxx_tests/test2013_milind_01.C
          likelyFunctionType = likelyFunctionType->stripType(SgType::STRIP_MODIFIER_TYPE |
                                                             SgType::STRIP_REFERENCE_TYPE |
                                                             SgType::STRIP_RVALUE_REFERENCE_TYPE |
                                                             SgType::STRIP_POINTER_TYPE |
                                                             SgType::STRIP_ARRAY_TYPE |
                                                             SgType::STRIP_TYPEDEF_TYPE);

       // printf ("After calling stripType(SgType::STRIP_TYPEDEF_TYPE): likelyFunctionType = %p = %s \n",likelyFunctionType,likelyFunctionType->class_name().c_str());
          functionType = isSgFunctionType(likelyFunctionType);

       // if functionType is NULL (e.g SgTemplateType or SgClassType) we have no idea what the return type is, so we will return SgTypeUnknown
          if (functionType == NULL) {
              //printf ("Warning: Unable to infer the return type of %s in SgFunctionCallExp\n", likelyFunctionType->class_name().c_str());
              return SgTypeUnknown::createType();
          }
        }
     ROSE_ASSERT(functionType);
     returnType = functionType->get_return_type();
     ROSE_ASSERT(returnType != NULL);
     return returnType;
   }

SOURCE_FUNCTION_CALL_EXPRESSION_END

// DQ (7/12/2013): Added support for type trait specific builtin functions.
SOURCE_TYPE_TRAIT_BUILTIN_OPERATOR_START

void
SgTypeTraitBuiltinOperator::post_construction_initialization()
   {
  // SgCallExpression::post_construction_initialization();
   }

SgType*
SgTypeTraitBuiltinOperator::get_type() const
   {
  // DQ (7/12/2013): These functions will almost always return a boolean type, but not always.

     SgType* returnType = NULL;

#if 0
     printf ("In SgTypeTraitBuiltinOperator::get_type() \n");
#endif

     if (get_name() == "__underlying_type")
        {
       // This returns an actual type and it is not clear now to handle this.
          returnType = SgTypeDefault::createType();
        }
       else
        {
       // return boolean type.
          returnType = SgTypeBool::createType();
        }

     ROSE_ASSERT(returnType != NULL);
     return returnType;
   }

SOURCE_TYPE_TRAIT_BUILTIN_OPERATOR_END


SOURCE_ARROW_EXPRESSION_START

SgType*
SgArrowExp::get_type() const
   {
  // DQ (1/14/2006): p_expression_type has been removed, we have to compute the appropriate type (IR specific code)

  // For the SgArrowExp, the type is the type of the rhs operand (e.g. "Aptr->x" where "x" is the data member of the pointer to class "A").

  // printf ("$CLASSNAME::get_type(): p_expression_type has been removed, we have to compute the appropriate type \n");

     ROSE_ASSERT(get_lhs_operand() != NULL);
     ROSE_ASSERT(get_rhs_operand() != NULL);

#if 0
     printf ("In SgArrowExp::get_type() \n");
#endif

     SgType* returnType = get_rhs_operand()->get_type();

     ROSE_ASSERT(returnType != NULL);

#if 0
     printf ("SgArrowExp::get_type(): get the type of the rhs operand returnType = %p = %s \n",returnType,returnType->class_name().c_str());
#endif

  // DQ (7/16/2014): In the case of UPC shared type for the lhs_operand, we need to return a type that is marked as
  // shared (even if the type on the rhs_operand is non-shared) (see UPC_tests/test2014_56.c for an example).
     returnType = checkForSharedTypeAndReturnSharedType(returnType);

#if 0
     printf ("Leaving SgArrowExp::get_type(): returnType->get_mangled() = %s \n",returnType->get_mangled().str());
#endif

     return returnType;
   }


SgType*
SgArrowExp::checkForSharedTypeAndReturnSharedType( SgType* possibleReturnType ) const
   {
  // DQ (7/16/2014): In the case of UPC shared type for the lhs_operand, we need to return a type that is marked as
  // shared (even if the type on the rhs_operand is non-shared) (see UPC_tests/test2014_56.c for an example).

     SgType* returnType = possibleReturnType;

     ROSE_ASSERT(get_lhs_operand()->get_type() != NULL);
     SgModifierType* mod_type = isSgModifierType(get_lhs_operand()->get_type());
     if (mod_type != NULL)
        {
#if 0
          printf ("In SgArrowExp::checkForSharedTypeAndReturnSharedType(): (mod_type != NULL): get_lhs_operand()->get_type() = %p = %s \n",get_lhs_operand()->get_type(),get_lhs_operand()->get_type()->class_name().c_str());
#endif
          if (mod_type->get_typeModifier().get_upcModifier().get_isShared() == true)
             {
#if 0
               printf ("In SgArrowExp::checkForSharedTypeAndReturnSharedType(): Detected a UPC shared lhs type in the evaluation of the type for SgArrowExp expression (need to return a type same as rhs type, but marked as shared) \n");
#endif
               returnType = SageBuilder::buildUpcSharedType(returnType);
             }
        }
       else
        {
#if 0
          printf ("In SgArrowExp::checkForSharedTypeAndReturnSharedType(): (mod_type == NULL): get_lhs_operand()->get_type() = %p = %s \n",get_lhs_operand()->get_type(),get_lhs_operand()->get_type()->class_name().c_str());
#endif
          SgPointerType* pointerType = isSgPointerType(get_lhs_operand()->get_type());
          if (pointerType != NULL)
             {
#if 0
               printf ("In SgArrowExp::checkForSharedTypeAndReturnSharedType(): Detected pointer type: pointerType = %p \n",pointerType);
#endif
               SgType* base_type = pointerType->get_base_type();
               SgModifierType* modifier_type = isSgModifierType(base_type);
               while (modifier_type != NULL && modifier_type->get_typeModifier().get_upcModifier().get_isShared() == false)
                  {
#if 0
                    printf ("In SgArrowExp::checkForSharedTypeAndReturnSharedType(): SgPointerType: SgModifierType type: (loop): Detected a SgModifierType \n");
#endif
                    modifier_type = isSgModifierType(modifier_type->get_base_type());
                  }
               if (modifier_type != NULL && modifier_type->get_typeModifier().get_upcModifier().get_isShared() == true)
                  {
#if 0
                    printf ("In SgArrowExp::checkForSharedTypeAndReturnSharedType(): SgPointerType: SgModifierType type: Detected a UPC shared lhs type in the evaluation of the type for SgArrowExp expression (need to return a type same as rhs type, but marked as shared) \n");
#endif
                    returnType = SageBuilder::buildUpcSharedType(returnType);
                  }
             }
        }

     return returnType;
   }



SOURCE_ARROW_EXPRESSION_END


SOURCE_DOT_EXPRESSION_START

SgType*
  // $CLASSNAME::get_type() const
SgDotExp::get_type() const
   {
  // DQ (1/14/2006): p_expression_type has been removed, we have to compute the appropriate type (IR specific code)

  // For the SgDotExp, the type is the type of the rhs operand (e.g. "A.x" where "x" is the data member of the class "A").

  // printf ("$CLASSNAME::get_type(): p_expression_type has been removed, we have to compute the appropriate type \n");

     ROSE_ASSERT(get_lhs_operand() != NULL);
     ROSE_ASSERT(get_rhs_operand() != NULL);

#if 0
     printf ("In SgDotExp::get_type() \n");
#endif

     SgType* returnType = get_rhs_operand()->get_type();

     ROSE_ASSERT(returnType != NULL);

  // printf ("$CLASSNAME::get_type(): get the type of the rhs operand returnType = %s \n",returnType->class_name().c_str());

     return returnType;
   }

SOURCE_DOT_EXPRESSION_END


SOURCE_DOT_STAR_OPERATOR_EXPRESSION_START

SgType*
SgDotStarOp::get_type() const
   {
  // DQ (1/14/2006): p_expression_type has been removed, we have to compute the appropriate type (IR specific code)

  // For the SgDotStarOp, the type is the type of the rhs operand (e.g. "A.*x" where "x" is a member function pointer of the class "A").

  // Comment from Jeremiah (7/20/2006)
  // In SOURCE_DOT_STAR_OPERATOR_EXPRESSION's get_type() method, the expression type is computed as the type of the RHS operand.
  // This is most likely a pointer to member type, though, not the type of the underlying member (assuming the types of
  // pointer-to-member expressions are set correctly).  The same issue applies to SOURCE_ARROW_STAR_OPERATOR_EXPRESSION.

  // printf ("SgDotStarOp::get_type(): p_expression_type has been removed, we have to compute the appropriate type from rhs = %s \n",get_rhs_operand()->class_name().c_str());

     ROSE_ASSERT(get_lhs_operand() != NULL);
     ROSE_ASSERT(get_rhs_operand() != NULL);

#if 0
     printf ("In SgDotStarExp::get_type() \n");
#endif

     SgType* someType = get_rhs_operand()->get_type();

     SgType* returnType = NULL;
     keepStripping:

  // printf ("$CLASSNAME::get_type(): someType = %s \n",someType->class_name().c_str());

     ROSE_ASSERT (someType != NULL);
     switch(someType->variantT())
        {
       // These cases all have base types and the pointer dereferencing returns the base type
       // But since p_base_type is placed at each of the different SgType IR nodes we have
       // to handle each case separately.
          case V_SgPointerType:
             {
               SgPointerType* pointerType = isSgPointerType(someType);
               returnType = pointerType->get_base_type();
               break;
             }
       // DQ (7/31/2006): Added a new case so now this code is no longer a clone of what is used in SgPointerDerefExp and SgPntrArrRefExp.
          case V_SgPointerMemberType:
             {
               SgPointerMemberType* pointerMemberType = isSgPointerMemberType(someType);
               returnType = pointerMemberType->get_base_type();
               break;
             }
          case V_SgArrayType:
             {
               SgArrayType* arrayType = isSgArrayType(someType);
               returnType = arrayType->get_base_type();
               break;
             }
          case V_SgTypedefType:
             {
               SgTypedefType* typedefType = isSgTypedefType(someType);
               someType = typedefType->get_base_type();
               goto keepStripping;
             }
          case V_SgReferenceType:
             {
               SgReferenceType* referenceType = isSgReferenceType(someType);
               someType = referenceType->get_base_type();
               goto keepStripping;
             }
          case V_SgModifierType:
             {
               SgModifierType* modifierType = isSgModifierType(someType);
               someType = modifierType->get_base_type();
               goto keepStripping;
             }
          default:
             {
               returnType = someType;
             }
        }

     ROSE_ASSERT(returnType != NULL);

  // printf ("$CLASSNAME::get_type(): get the type of the rhs operand returnType = %s \n",returnType->class_name().c_str());

     return returnType;
   }

SOURCE_DOT_STAR_OPERATOR_EXPRESSION_END


SOURCE_ARROW_STAR_OPERATOR_EXPRESSION_START

SgType*
SgArrowStarOp::get_type() const
   {
  // DQ (1/14/2006): p_expression_type has been removed, we have to compute the appropriate type (IR specific code)

  // For the SgArrowStarOp, the type is the type of the rhs operand (e.g. "A->*x" where "x" is a member function pointer of the pointer to the class "A").

  // printf ("SgArrowStarOp::get_type(): p_expression_type has been removed, we have to compute the appropriate type from rhs = %s \n",get_rhs_operand()->class_name().c_str());

     ROSE_ASSERT(get_lhs_operand() != NULL);
     ROSE_ASSERT(get_rhs_operand() != NULL);

#if 0
     printf ("In SgArrowStarExp::get_type() \n");
#endif

     SgType* someType = get_rhs_operand()->get_type();

     SgType* returnType = NULL;
     keepStripping:
     ROSE_ASSERT (someType != NULL);
     switch(someType->variantT())
        {
       // These cases all have base types and the pointer dereferencing returns the base type
       // But since p_base_type is placed at each of the different SgType IR nodes we have
       // to handle each case separately.
          case V_SgPointerType:
             {
               SgPointerType* pointerType = isSgPointerType(someType);
               returnType = pointerType->get_base_type();
               break;
             }
       // DQ (7/31/2006): Added a new case so now this code is no longer a clone of what is used in SgPointerDerefExp and SgPntrArrRefExp.
          case V_SgPointerMemberType:
             {
               SgPointerMemberType* pointerMemberType = isSgPointerMemberType(someType);
               returnType = pointerMemberType->get_base_type();
               break;
             }
          case V_SgArrayType:
             {
               SgArrayType* arrayType = isSgArrayType(someType);
               returnType = arrayType->get_base_type();
               break;
             }
          case V_SgTypedefType:
             {
               SgTypedefType* typedefType = isSgTypedefType(someType);
               someType = typedefType->get_base_type();
               goto keepStripping;
             }
          case V_SgReferenceType:
             {
               SgReferenceType* referenceType = isSgReferenceType(someType);
               someType = referenceType->get_base_type();
               goto keepStripping;
             }
          case V_SgModifierType:
             {
               SgModifierType* modifierType = isSgModifierType(someType);
               someType = modifierType->get_base_type();
               goto keepStripping;
             }
#if 0
       // DQ (1/19/2017): Added support for SgTemplateType.  However we might want to handle this similarly to SgDotStarExp::get_type() (above)
          case V_SgTemplateType:
             {
#if 1
               printf ("In SgArrowStarOp::get_type(): Found SgTemplateType \n");
#endif
               SgTemplateType* templateType = isSgTemplateType(someType);
               someType = templateType->get_base_type();
               goto keepStripping;
             }
#endif

          default:
             {
#if defined(ROSE_USE_EDG_VERSION_4) || defined(ROSE_USE_CLANG_FRONTEND)
            // DQ (1/19/2017): I think we want to fix this similarly to the case of SgDotStarExp::get_type() (above)
            // printf ("Using default case in SgArrowStarOp::get_type() differently with EDG version 4.x someType = %s \n",someType->class_name().c_str());
               returnType = someType;
#else
               printf ("Error: default reached in In SgArrowStarOp::get_type() someType = %s \n",someType->class_name().c_str());
               ROSE_ASSERT(false);
#endif
             }
        }

     ROSE_ASSERT(returnType != NULL);

  // printf ("SgArrowStarOp::get_type(): get the type of the rhs operand returnType = %s \n",returnType->class_name().c_str());

     return returnType;
   }

SOURCE_ARROW_STAR_OPERATOR_EXPRESSION_END


SOURCE_BOOLEAN_GET_TYPE_START

// DQ (6/20/2006): Used for all relational operators: ==, !=, <, >, <=, >=, !
SgType*
$CLASSNAME::get_type() const
   {
#if 0
     printf ("In $CLASSNAME::get_type() \n");
#endif

  // DQ (8/27/2006): We can get this result more quickly without searching the AST backward to the root and
  // if we do so it will be more consistant with what we have to do for the SgTypeBool which similarly must
  // be unparsed differently for C99 and C++ (gnu gcc also accepts "_Bool" as a type).
     SgType* returnType = (SageInterface::is_C_language() == true) ?
                               static_cast<SgType*>(SgTypeInt::createType()) :
                               static_cast<SgType*>(SgTypeBool::createType());
     ROSE_ASSERT(returnType != NULL);
     return returnType;
   }
SOURCE_BOOLEAN_GET_TYPE_END

SOURCE_EQUALITY_OPERATOR_EXPRESSION_START
SOURCE_BOOLEAN_GET_TYPE_MEMBER_FUNCTION
SOURCE_EQUALITY_OPERATOR_EXPRESSION_END

SOURCE_LESS_THAN_OPERATOR_EXPRESSION_START
SOURCE_BOOLEAN_GET_TYPE_MEMBER_FUNCTION
SOURCE_LESS_THAN_OPERATOR_EXPRESSION_END


SOURCE_GREATER_THAN_OPERATOR_EXPRESSION_START
SOURCE_BOOLEAN_GET_TYPE_MEMBER_FUNCTION
SOURCE_GREATER_THAN_OPERATOR_EXPRESSION_END


SOURCE_NOT_EQUAL_OPERATOR_EXPRESSION_START
SOURCE_BOOLEAN_GET_TYPE_MEMBER_FUNCTION
SOURCE_NOT_EQUAL_OPERATOR_EXPRESSION_END


SOURCE_LESS_OR_EQUAL_OPERATOR_EXPRESSION_START
SOURCE_BOOLEAN_GET_TYPE_MEMBER_FUNCTION
SOURCE_LESS_OR_EQUAL_OPERATOR_EXPRESSION_END


SOURCE_GREATER_OR_EQUAL_OPERATOR_EXPRESSION_START
SOURCE_BOOLEAN_GET_TYPE_MEMBER_FUNCTION
SOURCE_GREATER_OR_EQUAL_OPERATOR_EXPRESSION_END

SOURCE_NOT_OPERATOR_EXPRESSION_START
SOURCE_BOOLEAN_GET_TYPE_MEMBER_FUNCTION
SOURCE_NOT_OPERATOR_EXPRESSION_END


SOURCE_ADD_OPERATOR_EXPRESSION_START
SOURCE_ADD_OPERATOR_EXPRESSION_END

SOURCE_SUBTRACT_OPERATOR_EXPRESSION_START
SOURCE_SUBTRACT_OPERATOR_EXPRESSION_END


SOURCE_MULTIPLY_OPERATOR_EXPRESSION_START
SOURCE_MULTIPLY_OPERATOR_EXPRESSION_END


SOURCE_DIVIDE_OPERATOR_EXPRESSION_START
SOURCE_DIVIDE_OPERATOR_EXPRESSION_END


SOURCE_INTEGER_DIVIDE_OPERATOR_EXPRESSION_START
SOURCE_INTEGER_DIVIDE_OPERATOR_EXPRESSION_END


SOURCE_MOD_OPERATOR_EXPRESSION_START
SOURCE_MOD_OPERATOR_EXPRESSION_END

SOURCE_MEMBERSHIP_OP_START
SOURCE_BOOLEAN_GET_TYPE_MEMBER_FUNCTION
SOURCE_MEMBERSHIP_OP_END

SOURCE_NON_MEMBERSHIP_OP_START
SOURCE_BOOLEAN_GET_TYPE_MEMBER_FUNCTION
SOURCE_NON_MEMBERSHIP_OP_END

SOURCE_IS_OP_START
SOURCE_BOOLEAN_GET_TYPE_MEMBER_FUNCTION
SOURCE_IS_OP_END

SOURCE_IS_NOT_OP_START
SOURCE_BOOLEAN_GET_TYPE_MEMBER_FUNCTION
SOURCE_IS_NOT_OP_END

SOURCE_NARY_OP_START

SgExpressionPtrList&
SgNaryOp::get_operands()
   { return p_operands; }

const SgExpressionPtrList&
SgNaryOp::get_operands() const
   { return p_operands; }

VariantTList&
SgNaryOp::get_operators()
   { return p_operators; }

const VariantTList&
SgNaryOp::get_operators() const
   { return p_operators; }

void
SgNaryOp::append_operation(VariantT sg_operator, SgExpression* operand) {
    ROSE_ASSERT(operand != NULL);
    get_operands().push_back(operand);
    get_operators().push_back(sg_operator);
    operand->set_parent(this);
}

int
SgNaryOp::replace_expression(SgExpression *o, SgExpression *n) {
    SgExpressionPtrList::iterator i;
    for (i = get_operands().begin(); i != get_operands().end(); ++i) {
        if( (*i) == o) {
            *i = n;
            return 1;
        }
    }
    return 0;
}

int
SgNaryOp::length() const {
     return get_operands().size();
}

SgExpression*
SgNaryOp::get_next(int& i) const {
    return get_operands()[i++];
}

bool
SgNaryOp::empty() const {
    return get_operands().empty();
}

SOURCE_NARY_OP_END

SOURCE_NARY_COMPARISON_OP_START
SgType*
SgNaryComparisonOp::get_type() const
   {
#if 1
     printf ("In SgNaryComparisonOp::get_type() \n");
#endif

     return SageBuilder::buildBoolType();
   }
SOURCE_NARY_COMPARISON_OP_END

SOURCE_NARY_BOOLEAN_OP_START
SgType*
SgNaryBooleanOp::get_type() const
   {
     return SageBuilder::buildVoidType();
   }
SOURCE_NARY_BOOLEAN_OP_END

SOURCE_AND_OPERATOR_EXPRESSION_START

SgType*
$CLASSNAME::get_type() const
   {
  // This function returns an integer representing the logical type

#if 0
     printf ("In $CLASSNAME::get_type() \n");
#endif

  // DQ (1/14/2006): p_expression_type has been removed, we have to compute the appropriate type (IR specific code)
  // DQ (7/20/2006): Modified to remove redundant SgTypeInt qualifier.
  // SgType* returnType = SgTypeInt::SgTypeInt::createType();
     SgType* returnType = SgTypeInt::createType();

     ROSE_ASSERT(returnType != NULL);
     return returnType;
   }

SOURCE_AND_OPERATOR_EXPRESSION_END


SOURCE_OR_OPERATOR_EXPRESSION_START

SgType*
$CLASSNAME::get_type() const
   {
  // This function returns an integer representing the logical type

#if 0
     printf ("In $CLASSNAME::get_type() \n");
#endif

  // DQ (1/14/2006): p_expression_type has been removed, we have to compute the appropriate type (IR specific code)
  // DQ (7/20/2006): Modified to remove redundant SgTypeInt qualifier.
     SgType* returnType = SgTypeInt::createType();

     ROSE_ASSERT(returnType != NULL);
     return returnType;
   }

SOURCE_OR_OPERATOR_EXPRESSION_END


SOURCE_BIT_XOR_OPERATOR_EXPRESSION_START
SOURCE_BIT_XOR_OPERATOR_EXPRESSION_END

SOURCE_BIT_AND_OPERATOR_EXPRESSION_START
SOURCE_BIT_AND_OPERATOR_EXPRESSION_END

SOURCE_BIT_OR_OPERATOR_EXPRESSION_START
SOURCE_BIT_OR_OPERATOR_EXPRESSION_END

// CR (4/28/2020): Added SgBitEqvOp to support the Jovial bitwise operator.
SOURCE_BIT_EQV_OPERATOR_EXPRESSION_START
SOURCE_BIT_EQV_OPERATOR_EXPRESSION_END


SOURCE_COMMA_OPERATOR_EXPRESSION_START

SgType*
$CLASSNAME::get_type() const
   {
  // DQ (10/2/2006): Comma operator's get_type function didn't previously exist, but it should
  // because its semantics is different from the default SgBinaryOp::get_type() which returns
  // the type associated with the lhs.  This returns the type of the rhs.
     ROSE_ASSERT(get_lhs_operand() != NULL);
     ROSE_ASSERT(get_rhs_operand() != NULL);

#if 0
     printf ("In $CLASSNAME::get_type() \n");
#endif

     SgType* returnType = get_rhs_operand()->get_type();
     ROSE_ASSERT(returnType != NULL);

  // printf ("$CLASSNAME::get_type(): get the type of the rhs operand returnType = %s \n",returnType->class_name().c_str());

     return returnType;
   }

SOURCE_COMMA_OPERATOR_EXPRESSION_END

SOURCE_LEFT_SHIFT_OPERATOR_EXPRESSION_START
SOURCE_LEFT_SHIFT_OPERATOR_EXPRESSION_END

SOURCE_RIGHT_SHIFT_OPERATOR_EXPRESSION_START
SOURCE_RIGHT_SHIFT_OPERATOR_EXPRESSION_END

SOURCE_MINUS_OPERATOR_EXPRESSION_START
SOURCE_MINUS_OPERATOR_EXPRESSION_END

SOURCE_UNARY_ADD_OPERATOR_EXPRESSION_START
SOURCE_UNARY_ADD_OPERATOR_EXPRESSION_END

SOURCE_SIZE_OF_OPERATOR_EXPRESSION_START

SgType*
$CLASSNAME::get_type() const
   {
  // This function returns an unsigned integer representing the size of type
  // (the unsigned int should match size_t, which may or may not be defined).

     ROSE_ASSERT(p_operand_expr != NULL || p_operand_type != NULL);

#if 0
     printf ("In $CLASSNAME::get_type() \n");
#endif

     SgType* returnType = SgTypeUnsignedInt::createType();

     ROSE_ASSERT(returnType != NULL);
     return returnType;
   }

// Liao, 11/17/2009
int
SgSizeOfOp::replace_expression (SgExpression *o, SgExpression *n)
   {
  // DQ (12/17/2006): This function should have the semantics that it will represent a
  // structural change to the AST, thus it is free to set the parent of the new expression.

     ROSE_ASSERT(o != NULL);
     ROSE_ASSERT(n != NULL);

     if (get_operand_expr() == o)
        {
          set_operand_expr(n);
          return 1;
        }
       else
        {
          printf ("Warning: inside of SgSizeOfOp::replace_expression original SgExpression unidentified \n");
          return 0;
        }
   }

// DQ (6/11/2015): Moved these six access functions, they should not be generated by ROSETTA
// so that we could avoid them setting the isModified flag which is a problem in the
// name qualification support for C++ (interfering with the token-based unparsing).
int
SgSizeOfOp::get_name_qualification_length () const
   {
     ROSE_ASSERT (this != NULL);
     return p_name_qualification_length;
   }

void
SgSizeOfOp::set_name_qualification_length ( int name_qualification_length )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_name_qualification_length = name_qualification_length;
   }

bool
SgSizeOfOp::get_type_elaboration_required () const
   {
     ROSE_ASSERT (this != NULL);
     return p_type_elaboration_required;
   }

void
SgSizeOfOp::set_type_elaboration_required ( bool type_elaboration_required )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_type_elaboration_required = type_elaboration_required;
   }

bool
SgSizeOfOp::get_global_qualification_required () const
   {
     ROSE_ASSERT (this != NULL);
     return p_global_qualification_required;
   }

void
SgSizeOfOp::set_global_qualification_required ( bool global_qualification_required )
   {
     ROSE_ASSERT (this != NULL);

  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_global_qualification_required = global_qualification_required;
   }

// DQ (4/15/2019): These six access functions should not be generated by ROSETTA
// so that we could avoid them setting the isModified flag which is a problem in the
// name qualification support for C++ (interfering with the token-based unparsing).
int
SgSizeOfOp::get_name_qualification_for_pointer_to_member_class_length () const
   {
     ROSE_ASSERT (this != NULL);
     return p_name_qualification_for_pointer_to_member_class_length;
   }

void
SgSizeOfOp::set_name_qualification_for_pointer_to_member_class_length ( int name_qualification_length )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_name_qualification_for_pointer_to_member_class_length = name_qualification_length;
   }

bool
SgSizeOfOp::get_type_elaboration_for_pointer_to_member_class_required () const
   {
     ROSE_ASSERT (this != NULL);
     return p_type_elaboration_for_pointer_to_member_class_required;
   }

void
SgSizeOfOp::set_type_elaboration_for_pointer_to_member_class_required ( bool type_elaboration_required )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_type_elaboration_for_pointer_to_member_class_required = type_elaboration_required;
   }

bool
SgSizeOfOp::get_global_qualification_for_pointer_to_member_class_required () const
   {
     ROSE_ASSERT (this != NULL);
     return p_global_qualification_for_pointer_to_member_class_required;
   }

void
SgSizeOfOp::set_global_qualification_for_pointer_to_member_class_required ( bool global_qualification_required )
   {
     ROSE_ASSERT (this != NULL);

  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_global_qualification_for_pointer_to_member_class_required = global_qualification_required;
   }




SOURCE_SIZE_OF_OPERATOR_EXPRESSION_END


SOURCE_ALIGN_OF_OPERATOR_EXPRESSION_START

SgType*
$CLASSNAME::get_type() const
   {
  // This function returns an unsigned integer representing the size of type
  // (the unsigned int should match size_t, which may or may not be defined).

     ROSE_ASSERT(p_operand_expr != NULL || p_operand_type != NULL);

#if 0
     printf ("In $CLASSNAME::get_type() \n");
#endif

     SgType* returnType = SgTypeUnsignedInt::createType();

     ROSE_ASSERT(returnType != NULL);
     return returnType;
   }

// DQ (6/20/2013): Added alignment operator.
int
SgAlignOfOp::replace_expression (SgExpression *o, SgExpression *n)
   {
  // DQ (12/17/2006): This function should have the semantics that it will represent a
  // structural change to the AST, thus it is free to set the parent of the new expression.

     ROSE_ASSERT(o != NULL);
     ROSE_ASSERT(n != NULL);

     if (get_operand_expr() == o)
        {
          set_operand_expr(n);
          return 1;
        }
       else
        {
          printf ("Warning: inside of SgAlignOfOp::replace_expression original SgExpression unidentified \n");
          return 0;
        }
   }

// DQ (6/11/2015): Moved these six access functions, they should not be generated by ROSETTA
// so that we could avoid them setting the isModified flag which is a problem in the
// name qualification support for C++ (interfering with the token-based unparsing).
int
SgAlignOfOp::get_name_qualification_length () const
   {
     ROSE_ASSERT (this != NULL);
     return p_name_qualification_length;
   }

void
SgAlignOfOp::set_name_qualification_length ( int name_qualification_length )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_name_qualification_length = name_qualification_length;
   }

bool
SgAlignOfOp::get_type_elaboration_required () const
   {
     ROSE_ASSERT (this != NULL);
     return p_type_elaboration_required;
   }

void
SgAlignOfOp::set_type_elaboration_required ( bool type_elaboration_required )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_type_elaboration_required = type_elaboration_required;
   }

bool
SgAlignOfOp::get_global_qualification_required () const
   {
     ROSE_ASSERT (this != NULL);
     return p_global_qualification_required;
   }

void
SgAlignOfOp::set_global_qualification_required ( bool global_qualification_required )
   {
     ROSE_ASSERT (this != NULL);

  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_global_qualification_required = global_qualification_required;
   }

SOURCE_ALIGN_OF_OPERATOR_EXPRESSION_END


SOURCE_NOEXCEPT_OPERATOR_EXPRESSION_START

// DQ (2/4/2015): Added noexcept operator as part of C++11 support.
SgType*
SgNoexceptOp::get_type() const
   {
  // DQ (2/4/2015): This function returns a bool type (evaluating if exceptions are to be supported).

     ROSE_ASSERT(p_operand_expr != NULL);

#if 0
     printf ("In $CLASSNAME::get_type() \n");
#endif

     SgType* returnType = SgTypeBool::createType();

     ROSE_ASSERT(returnType != NULL);
     return returnType;
   }

#if 0
// DQ (2/4/2015): This function was required for the SgAlignOfOp, but I don't know if it is required for the SgNoexceptOp node.
int
SgNoexceptOp::replace_expression (SgExpression *o, SgExpression *n)
   {
  // DQ (12/17/2006): This function should have the semantics that it will represent a
  // structural change to the AST, thus it is free to set the parent of the new expression.

     ROSE_ASSERT(o != NULL);
     ROSE_ASSERT(n != NULL);

     if (get_operand_expr() == o)
        {
          set_operand_expr(n);
          return 1;
        }
       else
        {
          printf ("Warning: inside of SgAlignOfOp::replace_expression original SgExpression unidentified \n");
          return 0;
        }
   }
#endif

SOURCE_NOEXCEPT_OPERATOR_EXPRESSION_END

SOURCE_TYPE_ID_OPERATOR_EXPRESSION_START

#if 0
// DQ (1/17/2008): There is already an operand_type with get and set functions generated by ROSETTA.
// DQ (1/17/2008): Added set_type function since this is one of three IR nodes that require
// the type to be held explicitly, for all other IR nodes the type is computed dynamicly.
void
SgTypeIdOp::set_type( SgType* type )
   {
     p_expression_type = type;
   }
#endif

SgType*
SgTypeIdOp::get_type() const
   {
#if 0
     printf ("In $CLASSNAME::get_type() \n");
#endif

#if 0
  // DQ (7/20/2006): The typeid operator returns an lvalue of type const std::type_info that represents the
  // type of expression expr. You must include the standard template library header <typeinfo> to use the
  // typeid operator (obtained from IBM C++ web page).  So it seems that the correct return type is a
  // SgClassType with reference to the class declaration that should have been seen or we can perhaps assume to be
  // simply: "std::type_info"

  // DQ (1/26/2013): Since the operand can be either an expression or a type, the return type has to be either from the expression, or from the operand.
  // DQ (8/8/2006): The C++ standard requires that this return a "std::type_info" classType
  // SgType* returnType = p_expression_type;
     SgType* returnType = NULL;
     if (p_operand_expr != NULL)
        {
       // Could we alternatively just call get_type on the expression directly?
       // Note that EDG provised us with the type on the expression explicitly so
       // this has influenced the design here with saves the expression type explicitly.
          returnType = p_expression_type;
          ROSE_ASSERT(returnType != NULL);
        }
       else
        {
          returnType = p_operand_type;
          ROSE_ASSERT(returnType != NULL);
        }

     ROSE_ASSERT(returnType != NULL);

     return returnType;
#else
    // get_type on SgTypeIdOp must always retuen a const referene to "std::type_info"

     SgType* returnType = NULL;
     // If we call get_type() on a node that is not fully build then this will break.
     SgGlobal* globalScope = SageInterface::getGlobalScope(this);
     ROSE_ASSERT(globalScope && "globalScope is NULL");

     SgNamespaceSymbol* stdNamespaceSymbol = globalScope->lookup_namespace_symbol(SgName("std"));
     ROSE_ASSERT(stdNamespaceSymbol && "lookup_namespace_symbol did not found std symbol");

     SgNamespaceDeclarationStatement *  namespaceDeclarationStatement   = stdNamespaceSymbol->get_declaration ();
     SgNamespaceDefinitionStatement * namespaceDefinitionStatement = namespaceDeclarationStatement->get_definition();
     ROSE_ASSERT(namespaceDefinitionStatement && "get_definition() retured NULL");

     SgClassSymbol * typeInfoClassSymbol = namespaceDefinitionStatement->lookup_class_symbol(SgName("type_info"));
     ROSE_ASSERT(typeInfoClassSymbol && "lookup_class_symbol did not found type_info symbol");

     //returnType = SageInterface::deepCopy(typeInfoClassSymbol->get_type());
     returnType = typeInfoClassSymbol->get_type();
     ROSE_ASSERT(isSgClassType(returnType));


     SgModifierType* constType =  SageBuilder::buildConstType(returnType);
     ROSE_ASSERT (constType);
     SgReferenceType * constRefType = SageBuilder::buildReferenceType(constType);
     return constRefType;
#endif
   }

// DQ (6/11/2015): Moved these six access functions, they should not be generated by ROSETTA
// so that we could avoid them setting the isModified flag which is a problem in the
// name qualification support for C++ (interfering with the token-based unparsing).
int
SgTypeIdOp::get_name_qualification_length () const
   {
     ROSE_ASSERT (this != NULL);
     return p_name_qualification_length;
   }

void
SgTypeIdOp::set_name_qualification_length ( int name_qualification_length )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_name_qualification_length = name_qualification_length;
   }

bool
SgTypeIdOp::get_type_elaboration_required () const
   {
     ROSE_ASSERT (this != NULL);
     return p_type_elaboration_required;
   }

void
SgTypeIdOp::set_type_elaboration_required ( bool type_elaboration_required )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_type_elaboration_required = type_elaboration_required;
   }

bool
SgTypeIdOp::get_global_qualification_required () const
   {
     ROSE_ASSERT (this != NULL);
     return p_global_qualification_required;
   }

void
SgTypeIdOp::set_global_qualification_required ( bool global_qualification_required )
   {
     ROSE_ASSERT (this != NULL);

  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_global_qualification_required = global_qualification_required;
   }

// DQ (4/15/2019): These six access functions should not be generated by ROSETTA
// so that we could avoid them setting the isModified flag which is a problem in the
// name qualification support for C++ (interfering with the token-based unparsing).
int
SgTypeIdOp::get_name_qualification_for_pointer_to_member_class_length () const
   {
     ROSE_ASSERT (this != NULL);
     return p_name_qualification_for_pointer_to_member_class_length;
   }

void
SgTypeIdOp::set_name_qualification_for_pointer_to_member_class_length ( int name_qualification_length )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_name_qualification_for_pointer_to_member_class_length = name_qualification_length;
   }

bool
SgTypeIdOp::get_type_elaboration_for_pointer_to_member_class_required () const
   {
     ROSE_ASSERT (this != NULL);
     return p_type_elaboration_for_pointer_to_member_class_required;
   }

void
SgTypeIdOp::set_type_elaboration_for_pointer_to_member_class_required ( bool type_elaboration_required )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_type_elaboration_for_pointer_to_member_class_required = type_elaboration_required;
   }

bool
SgTypeIdOp::get_global_qualification_for_pointer_to_member_class_required () const
   {
     ROSE_ASSERT (this != NULL);
     return p_global_qualification_for_pointer_to_member_class_required;
   }

void
SgTypeIdOp::set_global_qualification_for_pointer_to_member_class_required ( bool global_qualification_required )
   {
     ROSE_ASSERT (this != NULL);

  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_global_qualification_for_pointer_to_member_class_required = global_qualification_required;
   }

SOURCE_TYPE_ID_OPERATOR_EXPRESSION_END


SOURCE_VARARG_START_OPERATOR_START
SOURCE_VARARG_START_OPERATOR_END


SOURCE_VARARG_OPERATOR_START

#if 0
// There is a set_expression_type function alread, soe we don't need this.
// DQ (1/17/2008): Added set_type function since this is one of a few IR nodes that require
// the type to be held explicitly, for all other IR nodes the type is computed dynamicly.
void
$CLASSNAME::set_type( SgType* type )
   {
     p_expression_type = type;
   }
#endif

// This function helps to provide a uniform interface even though the type is help in a field called p_expression_type.
SgType*
$CLASSNAME::get_type() const
   {
  // This function returns an explicitly stored type

     SgType* returnType = p_expression_type;

#if 0
     printf ("In $CLASSNAME::get_type() \n");
#endif

     ROSE_ASSERT(returnType != NULL);
     return returnType;
   }


int
SgVarArgOp::replace_expression(SgExpression *o, SgExpression *n)
{

  ROSE_ASSERT(o != NULL);
  ROSE_ASSERT(n != NULL);

  if (get_operand_expr() == o)
  {
    set_operand_expr(n);
    return 1;
  }
  else
  {
    printf ("Warning: inside of SgVarArgOp::replace_expression original SgExpression unidentified \n");
    return 0;
  }
}

SOURCE_VARARG_OPERATOR_END


SOURCE_VARARG_END_OPERATOR_START
int
SgVarArgEndOp::replace_expression(SgExpression *o, SgExpression *n)
{

  ROSE_ASSERT(o != NULL);
  ROSE_ASSERT(n != NULL);

  if (get_operand_expr() == o)
  {
    set_operand_expr(n);
    return 1;
  }
  else
  {
    printf ("Warning: inside of SgVarArgEndOp::replace_expression original SgExpression unidentified \n");
    return 0;
  }
}

SOURCE_VARARG_END_OPERATOR_END

SOURCE_POINTER_DEREFERENCE_EXPRESSION_START

// SgType* SgPointerDerefExp::get_type() const
SgType*
SgPointerDerefExp::get_type() const
   {
  // DQ (1/14/2006): p_expression_type has been removed, we have to compute the appropriate type (IR specific code)

  // DQ (7/28/2006): This code can't be used for both the SgPointerDerefExp and the SgPntrArrRefExp IR nodes because
  // it is a bit different (one node is a unary operator and the other is a binary operator).

  // This function returns the base type of the type returned from get_operand()->get_type() (which should be a SgPointerType).

     ROSE_ASSERT(get_operand() != NULL);

  // printf ("In $CLASSNAME::get_type(): get_operand() = %p = %s \n",get_operand(),get_operand()->class_name().c_str());

#if 0
     printf ("In SgPointerDerefExp::get_type() \n");
#endif

     SgType* someType = get_operand()->get_type();
     ROSE_ASSERT(someType != NULL);
#if 0
     printf ("In $CLASSNAME::get_type(): %s->get_type() = %p = %s \n",
          get_operand()->class_name().c_str(),get_operand()->get_type(),
          get_operand()->get_type()->class_name().c_str());
#endif
     if (p_expression_type != NULL)
        {
          printf ("In $CLASSNAME::get_type(): p_expression_type = %s \n",p_expression_type->class_name().c_str());
        }

  // This code should be shared between the SgPntrArrRefExp and the SgPointerDerefExp IR nodes
  // A better idea would be to have a function that strips off types based on a set of flags
  // that would control stripping of pointer references, array references, C++ references,
  // modifiers, and typedefs.

     SgType* returnType = NULL;
     keepStripping:
     ROSE_ASSERT (someType);
     switch(someType->variantT())
        {
       // These cases all have base types and the pointer dereferencing returns the base type
       // But since p_base_type is placed at each of the different SgType IR nodes we have
       // to handle each case separately.
          case V_SgPointerType:
             {
               SgPointerType* pointerType = isSgPointerType(someType);
               returnType = pointerType->get_base_type();
#if 0
               printf ("In SgPointerDerefExp::get_type(): SgPointerType: BEFORE stripType(): returnType = %p = %s \n",returnType,returnType->class_name().c_str());
#endif
            // DQ (6/11/2014): We also need to take any associated SgModifierType node chains used to modity the SgPointerType (e.g. defining const or UPC shared type attributes).
               returnType = returnType->stripType (SgType::STRIP_MODIFIER_TYPE);
#if 0
               printf ("In SgPointerDerefExp::get_type(): SgPointerType: AFTER stripType(): returnType = %p = %s \n",returnType,returnType->class_name().c_str());
#endif
               break;
             }
          case V_SgArrayType:
             {
               SgArrayType* arrayType = isSgArrayType(someType);
               returnType = arrayType->get_base_type();
               break;
             }
          case V_SgTypedefType:
             {
               SgTypedefType* typedefType = isSgTypedefType(someType);
               someType = typedefType->get_base_type();
               goto keepStripping;
             }
          case V_SgReferenceType:
             {
               SgReferenceType* referenceType = isSgReferenceType(someType);
               someType = referenceType->get_base_type();
               goto keepStripping;
             }
          case V_SgModifierType:
             {
               SgModifierType* modifierType = isSgModifierType(someType);
               someType = modifierType->get_base_type();
               goto keepStripping;
             }

       // DQ (5/10/2016): Added this for the case of the C++11 support.
          case V_SgRvalueReferenceType:
             {
               SgRvalueReferenceType* rvalueReferenceType = isSgRvalueReferenceType(someType);
            // returnType = rvalueReferenceType;
               someType = rvalueReferenceType->get_base_type();
               goto keepStripping;
             }

       // DQ (9/27/2012): Added case to avoid falling through the default case (more template support).
          case V_SgTemplateType:
             {
            // DQ (9/27/2012): I think that this is the correct handling of the return value generation.
               returnType = someType;
               break;
             }

       // DQ (9/27/2012): The dereference of a function type is a function call so the type is it's return type (I think)
          case V_SgMemberFunctionType:
             {
               SgMemberFunctionType* memberFunctionType = isSgMemberFunctionType(someType);
            // returnType = functionType->get_return_type();
               returnType = memberFunctionType;
               break;
             }

       // DQ (5/25/2013): Added this for the case of the new EDG interface.
       // DQ (6/18/2007): The dereference of a function type is a function call so the type is it's return type (I think)
          case V_SgFunctionType:
             {
               SgFunctionType* functionType = isSgFunctionType(someType);
            // returnType = functionType->get_return_type();
               returnType = functionType;
               break;
             }

       // DQ (5/25/2013): Added this for the case of the new EDG interface.
          case V_SgClassType:
             {
               SgClassType* classType = isSgClassType(someType);
               returnType = classType;
               break;
             }

       // DQ (7/13/2013): Added this for the case of the new EDG interface.
          case V_SgTypeVoid:
             {
               SgTypeVoid* voidType = isSgTypeVoid(someType);
               returnType = voidType;
               break;
             }

#if 0
       // DQ (10/3/2006): I think this is no longer required, since we fixed the case of sizeof taking an
       // expression (not required to be an lvalue)!
       // DQ (9/30/2006): This case appears where the expression of sizeof is a literal (in this case a char*).
       // This can be a SgTypeChar for "sizeof('\x1234567890123456789012345678901234567890')",
       // it is not clear how to handle this case, at present we just return the SgTypeChar type.
          case V_SgTypeChar:
             {
               returnType = someType;
               break;
             }
#endif
       // DQ (2/16/2014): Added this for the case of the new EDG interface (sometimes this case is required).
          case V_SgTypeUnknown:
             {
               returnType = someType;
               break;
             }

          default:
             {
            // DQ (10/23/2016): Commented out message to avoid output spew.
            // DQ (12/31/2008): This is the new behavior for EDG version 4.x.
            // printf ("Warning: default reached in In SgPointerDerefExp::get_type() someType = %s \n",someType->class_name().c_str());
               returnType = someType;
             }
        }

     ROSE_ASSERT(returnType != NULL);
     return returnType;
   }

SOURCE_POINTER_DEREFERENCE_EXPRESSION_END


SOURCE_ADDRESS_OF_OPERATOR_EXPRESSION_START

SgType*
SgAddressOfOp::get_type() const
   {
  // DQ (1/14/2006): p_expression_type has been removed, we have to compute the appropriate type (IR specific code)

  // This function returns a pointer to the type return from get_operand()->get_type().

#if 0
     printf ("In SgAddressOfOp::get_type() \n");
#endif

     ROSE_ASSERT(get_operand() != NULL);
     SgType* baseType = get_operand()->get_type();
     ROSE_ASSERT(baseType != NULL);

  // DQ (7/31/2006): Suggested change by Jeremiah.
  // SgType* returnType = SgPointerType::createType(baseType);
     SgClassDefinition* classDefinition = NULL;

  // DQ (7/31/2006): check if this is a data member of a class
  // (and save the class for the SgPointerMemberType::createType() function!)
     SgVarRefExp* varRefExp = isSgVarRefExp(get_operand());
     if (varRefExp != NULL)
        {
          ROSE_ASSERT(varRefExp->get_symbol() != NULL);
          ROSE_ASSERT(varRefExp->get_symbol()->get_declaration() != NULL);
          SgInitializedName* variable = varRefExp->get_symbol()->get_declaration();
          ROSE_ASSERT(variable != NULL);
          SgScopeStatement* scope = variable->get_scope();
          ROSE_ASSERT(scope != NULL);

          classDefinition = isSgClassDefinition(scope);
        }

  // printf ("In SgAddressOfOp::get_type(): classDefinition is valid = %s \n",(classDefinition != NULL) ? "true" : "false");

     SgType* returnType = NULL;
     if (classDefinition != NULL)
        {
          SgClassType* classType = classDefinition->get_declaration()->get_type();
          returnType = SgPointerMemberType::createType(baseType,classType);
#if 0
       // DQ (7/16/2014): Make this a warning for the moment.
          printf ("Warning: In SgAddressOfOp::get_type(): checkForSharedTypeAndReturnSharedType() not supported for generation of SgPointerMemberType \n");
#endif
        }
       else
        {
       // Milind Chabbi (8/1/2013) We must strip the reference else we will get pointer to a reference.
       // See CompileTests/Cxx_tests/test2004_157.C run under extractFunctionArgumentsNormalization
       // TODO: should we strip STRIP_TYPEDEF_TYPE? Not sure, need to talk to Dan.
       // DQ (7/16/2014): Dan says no. Don't strip the typedef or we could generate references to types
       // in the AST that might be private or inaccessible when we compile the unparsed the source code).
       // TV (11/13/2018): Added r-value reference handling
          returnType = SgPointerType::createType(baseType->stripType(SgType::STRIP_REFERENCE_TYPE|SgType::STRIP_RVALUE_REFERENCE_TYPE));

       // DQ (7/16/2014): In the case of UPC shared type for the lhs_operand, we need to return a type that is marked as
       // shared (even if the type on the rhs_operand is non-shared) (see UPC_tests/test2014_56.c for an example).
          returnType = checkForSharedTypeAndReturnSharedType(returnType);
        }

   //  ROSE_ASSERT(returnType != NULL);
     return returnType;
   }


// DQ (7/16/2014): Shared types from expressions in UPC have some expected symantics that are not a matter of returning the result of get_type().
// This function supports the get_type() function.
SgType*
SgAddressOfOp::checkForSharedTypeAndReturnSharedType( SgType* possibleReturnType ) const
   {
  // DQ (7/16/2014): In the case of UPC shared type for the lhs_operand, we need to return a type that is marked as
  // shared (even if the type on the rhs_operand is non-shared) (see UPC_tests/test2014_56.c for an example).

     SgType* returnType = possibleReturnType;

     ROSE_ASSERT(get_operand()->get_type() != NULL);
     SgModifierType* mod_type = isSgModifierType(get_operand()->get_type());
     if (mod_type != NULL)
        {
#if 0
          printf ("In SgAddressOfOp::checkForSharedTypeAndReturnSharedType(): (mod_type != NULL): get_operand()->get_type() = %p = %s \n",get_operand()->get_type(),get_operand()->get_type()->class_name().c_str());
#endif
          if (mod_type->get_typeModifier().get_upcModifier().get_isShared() == true)
             {
#if 0
               printf ("In SgAddressOfOp::checkForSharedTypeAndReturnSharedType(): Detected a UPC shared lhs type in the evaluation of the type for SgAddressOf expression (need to return a type same as rhs type, but marked as shared) \n");
#endif
               returnType = SageBuilder::buildUpcSharedType(possibleReturnType);
             }
        }
       else
        {
#if 0
          printf ("In SgAddressOfOp::checkForSharedTypeAndReturnSharedType(): (mod_type == NULL): get_operand()->get_type() = %p = %s \n",get_operand()->get_type(),get_operand()->get_type()->class_name().c_str());
#endif
          SgPointerType* pointerType = isSgPointerType(get_operand()->get_type());
          if (pointerType != NULL)
             {
#if 0
               printf ("In SgAddressOfOp::checkForSharedTypeAndReturnSharedType(): Detected pointer type: pointerType = %p \n",pointerType);
#endif
               SgType* base_type = pointerType->get_base_type();
               SgModifierType* modifier_type = isSgModifierType(base_type);
               while (modifier_type != NULL && modifier_type->get_typeModifier().get_upcModifier().get_isShared() == false)
                  {
#if 0
                    printf ("In SgAddressOfOp::checkForSharedTypeAndReturnSharedType(): SgPointerType: SgModifierType type: (loop): Detected a SgModifierType \n");
#endif
                    modifier_type = isSgModifierType(modifier_type->get_base_type());
                  }
               if (modifier_type != NULL && modifier_type->get_typeModifier().get_upcModifier().get_isShared() == true)
                  {
#if 0
                    printf ("In SgAddressOfOp::checkForSharedTypeAndReturnSharedType(): SgPointerType: SgModifierType type: Detected a UPC shared lhs type in the evaluation of the type for SgAddressOf expression (need to return a type same as rhs type, but marked as shared) \n");
#endif
                    returnType = SageBuilder::buildUpcSharedType(possibleReturnType);
                  }
             }
        }

     return returnType;
   }



SOURCE_ADDRESS_OF_OPERATOR_EXPRESSION_END


SOURCE_MINUS_MINUS_OPERATOR_EXPRESSION_START
$CLASSNAME::$CLASSNAME(Sg_File_Info * fi, SgExpression * exp, Sgop_mode a_mode)
   : $BASECLASS(fi, exp, NULL)
   {
     set_mode(a_mode);
     if (exp)
          exp->set_parent(this);
   }

$CLASSNAME::$CLASSNAME(SgExpression * exp, Sgop_mode a_mode)
   : $BASECLASS(exp, NULL)
   {
     set_mode(a_mode);
     if (exp)
          exp->set_parent(this);
   }

void
$CLASSNAME::post_construction_initialization()
   {
     set_mode(SgUnaryOp::prefix);
   }

SOURCE_MINUS_MINUS_OPERATOR_EXPRESSION_END


SOURCE_PLUS_PLUS_OPERATOR_EXPRESSION_START
$CLASSNAME::$CLASSNAME(Sg_File_Info * fi, SgExpression * exp, Sgop_mode a_mode)
   : $BASECLASS(fi, exp, NULL)
   {
     set_mode(a_mode);
     if (exp)
          exp->set_parent(this);
   }

$CLASSNAME::$CLASSNAME( SgExpression * exp, Sgop_mode a_mode)
   : $BASECLASS(exp, NULL)
   {
     set_mode(a_mode);
     if (exp)
          exp->set_parent(this);
   }

void
$CLASSNAME::post_construction_initialization()
   {
     set_mode(SgUnaryOp::prefix);
   }

SOURCE_PLUS_PLUS_OPERATOR_EXPRESSION_END


SOURCE_BIT_COMPLEMENT_OPERATOR_EXPRESSION_START

void
SgBitComplementOp::post_construction_initialization()
   {
  // DQ (1/20/2019): This function must be defined here so that we can properly mark this operator as a prefix operator (see test2019_10.C).
     set_mode(SgUnaryOp::prefix);

#if 0
     printf ("SgBitComplementOp::post_construction_initialization(): this->get_mode() == SgUnaryOp::prefix is  %s \n",(this->get_mode() == SgUnaryOp::prefix)  ? "true" : "false");
#endif
   }

SOURCE_BIT_COMPLEMENT_OPERATOR_EXPRESSION_END


SOURCE_REAL_PART_OPERATOR_EXPRESSION_START
SOURCE_REAL_PART_OPERATOR_EXPRESSION_END


SOURCE_IMAG_PART_OPERATOR_EXPRESSION_START
SOURCE_IMAG_PART_OPERATOR_EXPRESSION_END


SOURCE_CONJUGATE_OPERATOR_EXPRESSION_START
SOURCE_CONJUGATE_OPERATOR_EXPRESSION_END

SOURCE_CONDITIONAL_EXPRESSION_START
void
$CLASSNAME::post_construction_initialization()
   {
// #ifndef REMOVE_SET_PARENT_FUNCTION
     if (p_conditional_exp != NULL)
          p_conditional_exp->set_parent(this);
     if (p_true_exp != NULL)
          p_true_exp->set_parent(this);
     if (p_false_exp != NULL)
          p_false_exp->set_parent(this);
// #endif

  // DQ (1/14/2006): set_type is removed
  // set_type();
   }

SgType*
$CLASSNAME::get_type() const
   {
  // In this function we want to return the type of the true of false option but it only makes sense for them to be the same type.

  // DQ (1/14/2006): p_expression_type has been removed, we have to compute the appropriate type (IR specific code)
  // printf ("$CLASSNAME::get_type(): p_expression_type has been removed, we have to compute the appropriate type \n");

  // Jeremiah (7/20/2006): Despite the comments, SOURCE_CONDITIONAL_EXPRESSION refers to a p_expression_type member,
  // but then ignores it.  I think you may want to store the type explicitly for this operator, as computing it is
  // difficult (requires handling user-defined conversions and such).  The return type can be either the true or false
  // types, and they can be different.

     ROSE_ASSERT(p_true_exp  != NULL);
     ROSE_ASSERT(p_false_exp != NULL);

#if 0
     printf ("In $CLASSNAME::get_type() \n");
#endif

     SgType* trueType   = p_true_exp->get_type();
     ROSE_ASSERT(trueType != NULL);

     SgType* falseType  = p_false_exp->get_type();
     ROSE_ASSERT(falseType != NULL);

#if PRINT_DEVELOPER_WARNINGS
     string expression_type_name = "NULL";
     if (p_expression_type != NULL)
          expression_type_name = p_expression_type->class_name();

  // ROSE_ASSERT(trueType == falseType);
     if (trueType != falseType)
        {
          printf ("Warning: In SgConditionalExp::get_type(): trueType = %s != falseType = %s  (p_expression_type = %s) \n",
               trueType->class_name().c_str(),falseType->class_name().c_str(),expression_type_name.c_str());
       // get_file_info()->display("Warning: In SgConditionalExp::get_type(): trueType != falseType");
        }
#endif

  // This was the previous choice for how p_expression_type was set,
  // so to be consistant we will select the same branch.
     SgType* returnType = trueType;

  // PC (10/12/2009): If returnType is in fact an SgArrayType it will undergo array-to-pointer conversion
     SgType *retElemType = SageInterface::getElementType(returnType);
     if (retElemType != NULL)
        {
          returnType = SgPointerType::createType(retElemType);
        }

     ROSE_ASSERT(returnType != NULL);
     return returnType;
   }

SgExpression*
$CLASSNAME::get_next(int& n) const
   {
     SgExpression *tmp = NULL;
     switch (n)
        {
          case 0: tmp = get_conditional_exp(); n++; break;
          case 1: tmp = get_true_exp(); n++; break;
          case 2: tmp = get_false_exp(); n++; break;
        }

     return tmp;
   }

int
$CLASSNAME::replace_expression(SgExpression *o, SgExpression *n)
   {
  // DQ (12/17/2006): This function should have the semantics that it will represent a
  // structural change to the AST, thus it is free to set the parent of the new expression.

     ROSE_ASSERT(o != NULL);
     ROSE_ASSERT(n != NULL);

     if (get_conditional_exp() == o)
        {
          set_conditional_exp(n);
          n->set_parent(this);
          return 1;
        }
       else
        {
          if (get_true_exp() == o)
             {
               set_true_exp(n);
               n->set_parent(this);
               return 1;
             }
            else
             {
               if (get_false_exp() == o)
                  {
                    set_false_exp(n);
                    n->set_parent(this);
                    return 1;
                  }
                 else
                  {
                    return 0;
                  }
             }
        }
   }

SOURCE_CONDITIONAL_EXPRESSION_END


SOURCE_CAST_EXPRESSION_START

void
SgCastExp::post_construction_initialization()
   {
   }

// DQ (6/14/2005): Modified to make enum name consistant with elsewhere in ROSE (Sage III)
// $CLASSNAME::Sg_e_cast_type
SgCastExp::cast_type_enum
SgCastExp::cast_type() const
   {
     return p_cast_type;
   }

// DQ (1/17/2008): Added set_type function since this is one of a few IR nodes that require
// the type to be held explicitly, for all other IR nodes the type is computed dynamicly.
void
SgCastExp::set_type( SgType* type )
   {
     p_expression_type = type;
   }

SgType*
SgCastExp::get_type() const
   {
  // DQ (1/16/2006): In this function we want to return the stored p_expression_type.
  // This IR node has to store the type explicitly since there is no other way to
  // recover what the cast is TO (since the operand stored what the cast in FROM).

  // DQ (1/14/2006): p_expression_type has been removed, we have to compute the appropriate type (IR specific code)

  // printf ("SgCastOp::get_type(): p_expression_type has been removed from many IR nodes but is required for SgCastOp \n");

#if 0
     printf ("In SgCastExp::get_type() \n");
#endif

     ROSE_ASSERT(p_expression_type != NULL);
     return p_expression_type;
   }

bool
SgCastExp::cast_looses_precision()
   {
  // DQ (10/24/2014): Added support to determine when cast should be allowable.
  // This is used in the SageInterace support for evaluation of constant expressions.

     bool result = false;
     if (isSgTypeDouble(p_expression_type) != NULL && isSgTypeFloat(p_expression_type) != NULL)
        {
          SgExpression* operand = this->get_operand();
          ROSE_ASSERT(operand != NULL);

          SgType* operantType = operand->get_type();
          ROSE_ASSERT(operantType != NULL);

          if (isSgTypeInt(operantType) != NULL         || isSgTypeLong(operantType) != NULL         || isSgTypeShort(operantType) != NULL         || isSgTypeChar(operantType) != NULL ||
              isSgTypeUnsignedInt(operantType) != NULL || isSgTypeUnsignedLong(operantType) != NULL || isSgTypeUnsignedShort(operantType) != NULL || isSgTypeUnsignedChar(operantType) != NULL ||
              isSgTypeSignedInt(operantType) != NULL   || isSgTypeSignedLong(operantType) != NULL   || isSgTypeSignedShort(operantType) != NULL   || isSgTypeSignedChar(operantType) != NULL)
             {
               result = true;
             }
        }

     return result;
   }

// DQ (6/11/2015): Moved these six access functions, they should not be generated by ROSETTA
// so that we could avoid them setting the isModified flag which is a problem in the
// name qualification support for C++ (interfering with the token-based unparsing).
int
SgCastExp::get_name_qualification_length () const
   {
     ROSE_ASSERT (this != NULL);
     return p_name_qualification_length;
   }

void
SgCastExp::set_name_qualification_length ( int name_qualification_length )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_name_qualification_length = name_qualification_length;
   }

bool
SgCastExp::get_type_elaboration_required () const
   {
     ROSE_ASSERT (this != NULL);
     return p_type_elaboration_required;
   }

void
SgCastExp::set_type_elaboration_required ( bool type_elaboration_required )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_type_elaboration_required = type_elaboration_required;
   }

bool
SgCastExp::get_global_qualification_required () const
   {
     ROSE_ASSERT (this != NULL);
     return p_global_qualification_required;
   }

void
SgCastExp::set_global_qualification_required ( bool global_qualification_required )
   {
     ROSE_ASSERT (this != NULL);

  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_global_qualification_required = global_qualification_required;
   }

std::string
SgCastExp::cast_type_to_string ( enum cast_type_enum cast_type )
   {
     string s;

     switch (cast_type)
       {
         case e_unknown: s = "e_unknown"; break;
         case e_default: s = "e_default"; break;
         case e_C_style_cast: s = "e_C_style_cast"; break;
         case e_const_cast: s = "e_const_cast"; break;
         case e_static_cast: s = "e_static_cast"; break;
         case e_dynamic_cast: s = "e_dynamic_cast"; break;
         case e_reinterpret_cast: s = "e_reinterpret_cast"; break;
         case e_safe_cast: s = "e_safe_cast"; break;
         case e_last_cast: s = "e_last_cast"; break;

         default:
              printf ("ERROR: default reached in switch: cast_type = %d \n",cast_type);
       }

     return s;
   }

// DQ (4/15/2019): These six access functions should not be generated by ROSETTA
// so that we could avoid them setting the isModified flag which is a problem in the
// name qualification support for C++ (interfering with the token-based unparsing).
int
SgCastExp::get_name_qualification_for_pointer_to_member_class_length () const
   {
     ROSE_ASSERT (this != NULL);
     return p_name_qualification_for_pointer_to_member_class_length;
   }

void
SgCastExp::set_name_qualification_for_pointer_to_member_class_length ( int name_qualification_length )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_name_qualification_for_pointer_to_member_class_length = name_qualification_length;
   }

bool
SgCastExp::get_type_elaboration_for_pointer_to_member_class_required () const
   {
     ROSE_ASSERT (this != NULL);
     return p_type_elaboration_for_pointer_to_member_class_required;
   }

void
SgCastExp::set_type_elaboration_for_pointer_to_member_class_required ( bool type_elaboration_required )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_type_elaboration_for_pointer_to_member_class_required = type_elaboration_required;
   }

bool
SgCastExp::get_global_qualification_for_pointer_to_member_class_required () const
   {
     ROSE_ASSERT (this != NULL);
     return p_global_qualification_for_pointer_to_member_class_required;
   }

void
SgCastExp::set_global_qualification_for_pointer_to_member_class_required ( bool global_qualification_required )
   {
     ROSE_ASSERT (this != NULL);

  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_global_qualification_for_pointer_to_member_class_required = global_qualification_required;
   }



SOURCE_CAST_EXPRESSION_END


SOURCE_POINTER_ARRAY_REFERENCE_EXPRESSION_START

SgType*
SgPntrArrRefExp::get_type() const
   {
  // DQ (1/16/2006): In this function we want to return the base type of the array being referenced (lhs->get_type()).

  // DQ (1/14/2006): p_expression_type has been removed, we have to compute the appropriate type (IR specific code)

  // printf ("SgPntrArrRefExp::get_type(): p_expression_type has been removed from many IR nodes \n");

#if 0
     printf ("In SgPntrArrRefExp::get_type() \n");
#endif

  // ROSE_ASSERT(p_expression_type != NULL);
     if (p_expression_type != NULL)
        {
          printf ("In SgPntrArrRefExp::get_type(): p_expression_type = %s \n",p_expression_type->class_name().c_str());
        }

     ROSE_ASSERT(get_lhs_operand() != NULL);
     ROSE_ASSERT(get_rhs_operand() != NULL);

#if 0
     printf ("In SgPntrArrRefExp::get_type(): this = %p \n",this);
#endif

  // SgType* returnType = get_lhs_operand()->get_type();
     SgType* someType = get_lhs_operand()->get_type();
     ROSE_ASSERT(someType != NULL);

  // This code should be shared between the SgPntrArrRefExp and the SgPointerDerefExp IR nodes
  // A better idea would be to have a function that strips off types based on a set of flags
  // that would control stripping of pointer references, array references, C++ references,
  // modifiers, and typedefs.

     SgType* returnType = NULL;
     keepStripping:
     ROSE_ASSERT (someType);

#if 0
     printf ("In SgPntrArrRefExp::get_type(): someType = %p = %s \n",someType,someType->class_name().c_str());
#endif

     switch(someType->variantT())
        {
       // These cases all have base types and the pointer dereferencing returns the base type
       // But since p_base_type is placed at each of the different SgType IR nodes we have
       // to handle each case separately.
          case V_SgPointerType:
             {
               SgPointerType* pointerType = isSgPointerType(someType);
               returnType = pointerType->get_base_type();
#if 0
               printf ("In SgPntrArrRefExp::get_type(): SgPointerType: BEFORE stripType(): returnType = %p = %s \n",returnType,returnType->class_name().c_str());
#endif
            // DQ (6/11/2014): We also need to take any associated SgModifierType node chains used to modity the SgPointerType (e.g. defining const or UPC shared type attributes).
               returnType = returnType->stripType (SgType::STRIP_MODIFIER_TYPE);
#if 0
               printf ("In SgPntrArrRefExp::get_type(): SgPointerType: AFTER stripType(): returnType = %p = %s \n",returnType,returnType->class_name().c_str());
#endif
               break;
             }
          case V_SgArrayType:
             {
               SgArrayType* arrayType = isSgArrayType(someType);
               returnType = arrayType->get_base_type();
               break;
             }
          case V_SgTypedefType:
             {
               SgTypedefType* typedefType = isSgTypedefType(someType);
               someType = typedefType->get_base_type();
               goto keepStripping;
             }
          case V_SgReferenceType:
             {
               SgReferenceType* referenceType = isSgReferenceType(someType);
               someType = referenceType->get_base_type();
               goto keepStripping;
             }
          case V_SgModifierType:
             {
               SgModifierType* modifierType = isSgModifierType(someType);
               someType = modifierType->get_base_type();
               goto keepStripping;
             }

       // DQ (9/12/2010): Added SgTypeFloat support to handle Fortran support (in file LANL_POP/grid.F90).
          case V_SgTypeFloat:
             {
            // DQ (8/17/2010): I think that this is the correct handling of the return value generation.
               returnType = someType;
               break;
             }

       // DQ (10/3/2006): Added case of array reference of string type (assume it returns a char).
       // Once we have a wcharString type then we have to add that case to this list as well!
          case V_SgTypeString:
             {
            // SgTypeString* stringType = isSgTypeString(someType);
            // someType = stringType->get_base_type();
               returnType = SgTypeChar::createType();
               break;
             }
       // DQ (12/31/2008): This is a better fit for the new EDG/ROSE translation interface.
          default:
             {
#if 0
               printf ("In SgPntrArrRefExp::get_type(): default case: someType = %p = %s \n",someType,someType->class_name().c_str());
#endif
               returnType = someType;
             }
        }

     ROSE_ASSERT(returnType != NULL);

#if 0
     printf ("In SgPntrArrRefExp::get_type(): returnType = %p = %s \n",returnType,returnType->class_name().c_str());
#endif

     return returnType;
   }

SOURCE_POINTER_ARRAY_REFERENCE_EXPRESSION_END


SOURCE_NEW_OPERATOR_EXPRESSION_START

void
$CLASSNAME::post_construction_initialization()
   {
     if(p_constructor_args)
        {
// #ifndef REMOVE_SET_PARENT_FUNCTION
          p_constructor_args->set_parent(this);
// #endif
          p_constructor_args->set_need_paren(true);
        }

// #ifndef REMOVE_SET_PARENT_FUNCTION
     if(p_builtin_args)
        {
          p_builtin_args->set_parent(this);
        }

     if(p_placement_args)
          p_placement_args->set_parent(this);
// #endif
   }


SgExpression*
$CLASSNAME::get_next(int& n) const
   {
  // SgExpression *tmp = NULL;
     if(n==0)
        {
          n++;
          if(get_placement_args()) return get_placement_args();
            else
             {
               n++;
               if(get_constructor_args())
                    return get_constructor_args();
                 else
                    return get_builtin_args();
             }
        }
       else
          if(n==1)
             {
               n++;
               if(get_constructor_args())
                    return get_constructor_args();
                 else
                    return get_builtin_args();
             }

     return NULL;
   }

int
$CLASSNAME::replace_expression(SgExpression *o, SgExpression *n)
   {
  // DQ (12/17/2006): This function should have the semantics that it will represent a
  // structural change to the AST, thus it is free to set the parent of the new expression.

     ROSE_ASSERT(o != NULL);
     ROSE_ASSERT(n != NULL);

     if(get_placement_args()==o)
        {
          set_placement_args(isSgExprListExp(n));
          n->set_parent(this);
          return 1;
        }
       else
        {
          if(get_constructor_args()==o)
             {
               set_constructor_args(isSgConstructorInitializer(n));
               n->set_parent(this);
               return 1;
             }
            else
             {
               if(get_builtin_args()==o)
                  {
                    set_builtin_args(n);
                    n->set_parent(this);
                    return 1;
                  }
                 else
                  {
                    return 0;
                  }
             }
        }
   }

SgType*
$CLASSNAME::get_type() const
   {
  // DQ (1/14/2006): p_expression_type has been removed, we have to compute the appropriate type (IR specific code)

  // printf ("$CLASSNAME::get_type(): p_expression_type has been removed, we have to compute the appropriate type \n");

  // The p_constructor_args really just identifies the constructor being called,
  // from which we can get the type to be returned from the new operator!
  // If there is no constructor then this might be a primative type or perhaps
  // a class or struct without an explicit constructor.
     // ROSE_ASSERT(p_constructor_args != NULL); -- JJW hack

#if 0
     printf ("In $CLASSNAME::get_type() \n");
#endif

  // Since where the p_constructor_args->get_declaration() == NULL (often for primative types)
  // we need the explicitly stored p_expression_type pointer anyway so we can just make it the
  // return type for all cases.
  // SgType* returnType = p_expression_type;
  // SgType* returnType = SgPointerType::createType(p_expression_type);
     ROSE_ASSERT(p_specified_type != NULL);
     SgType* returnType = SgPointerType::createType(p_specified_type);

     ROSE_ASSERT(returnType != NULL);
  // printf ("$CLASSNAME::get_type(): We might have to return a pointer to this type! returnType = %s \n",returnType->class_name().c_str());

     return returnType;
   }

// DQ (6/11/2015): Moved these six access functions, they should not be generated by ROSETTA
// so that we could avoid them setting the isModified flag which is a problem in the
// name qualification support for C++ (interfering with the token-based unparsing).
int
SgNewExp::get_name_qualification_length () const
   {
     ROSE_ASSERT (this != NULL);
     return p_name_qualification_length;
   }

void
SgNewExp::set_name_qualification_length ( int name_qualification_length )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_name_qualification_length = name_qualification_length;
   }

bool
SgNewExp::get_type_elaboration_required () const
   {
     ROSE_ASSERT (this != NULL);
     return p_type_elaboration_required;
   }

void
SgNewExp::set_type_elaboration_required ( bool type_elaboration_required )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_type_elaboration_required = type_elaboration_required;
   }

bool
SgNewExp::get_global_qualification_required () const
   {
     ROSE_ASSERT (this != NULL);
     return p_global_qualification_required;
   }

void
SgNewExp::set_global_qualification_required ( bool global_qualification_required )
   {
     ROSE_ASSERT (this != NULL);

  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_global_qualification_required = global_qualification_required;
   }


// DQ (4/15/2019): These six access functions should not be generated by ROSETTA
// so that we could avoid them setting the isModified flag which is a problem in the
// name qualification support for C++ (interfering with the token-based unparsing).
int
SgNewExp::get_name_qualification_for_pointer_to_member_class_length () const
   {
     ROSE_ASSERT (this != NULL);
     return p_name_qualification_for_pointer_to_member_class_length;
   }

void
SgNewExp::set_name_qualification_for_pointer_to_member_class_length ( int name_qualification_length )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_name_qualification_for_pointer_to_member_class_length = name_qualification_length;
   }

bool
SgNewExp::get_type_elaboration_for_pointer_to_member_class_required () const
   {
     ROSE_ASSERT (this != NULL);
     return p_type_elaboration_for_pointer_to_member_class_required;
   }

void
SgNewExp::set_type_elaboration_for_pointer_to_member_class_required ( bool type_elaboration_required )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_type_elaboration_for_pointer_to_member_class_required = type_elaboration_required;
   }

bool
SgNewExp::get_global_qualification_for_pointer_to_member_class_required () const
   {
     ROSE_ASSERT (this != NULL);
     return p_global_qualification_for_pointer_to_member_class_required;
   }

void
SgNewExp::set_global_qualification_for_pointer_to_member_class_required ( bool global_qualification_required )
   {
     ROSE_ASSERT (this != NULL);

  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_global_qualification_for_pointer_to_member_class_required = global_qualification_required;
   }




SOURCE_NEW_OPERATOR_EXPRESSION_END


SOURCE_DELETE_OPERATOR_EXPRESSION_START

#if 0
// This should be generated automatically
SgDeleteExp::SgDeleteExp(Sg_File_Info* info , SgExpression* variable, short is_array, short need_global_specifier)
   : $BASECLASS(info)
   {
     p_variable = variable;
     p_is_array = is_array;
     p_need_global_specifier = need_global_specifier;
  /* now a call to the user defined intialization function */
     post_construction_initialization();
   }
#endif

void
SgDeleteExp::post_construction_initialization()
   {
// #ifndef REMOVE_SET_PARENT_FUNCTION
     if(p_variable)
          p_variable->set_parent(this);
// #endif
   }

SgType*
SgDeleteExp::get_type() const
   {
  // The delete operator always returns "void" as a type.  This used to return SgDefaultType (but that didn't seem quite right)

  // DQ (1/14/2006): p_expression_type has been removed, we have to compute the appropriate type (IR specific code)

  // printf ("$CLASSNAME::get_type(): p_expression_type has been removed, we now return SgTypeVoid \n");

#if 0
     printf ("In SgDeleteExp::get_type() \n");
#endif

     SgType* returnType = SgTypeVoid::createType();

     ROSE_ASSERT(returnType != NULL);
     return returnType;
   }

SgExpression*
SgDeleteExp::get_next(int& n) const
   {
     if(n==0)
        {
          n++;
          return get_variable();
        }
       else
        {
          return 0;
        }
   }

int
SgDeleteExp::replace_expression(SgExpression *o, SgExpression *n)
   {
  // DQ (12/17/2006): This function should have the semantics that it will represent a
  // structural change to the AST, thus it is free to set the parent of the new expression.

     ROSE_ASSERT(o != NULL);
     ROSE_ASSERT(n != NULL);

     if (get_variable() == o)
        {
          set_variable(n);
          n->set_parent(this);
          return 1;
        }
       else
        {
          return 0;
        }
   }

SOURCE_DELETE_OPERATOR_EXPRESSION_END

SOURCE_THIS_EXPRESSION_START
SOURCE_THIS_EXPRESSION_END

SOURCE_SUPER_EXPRESSION_START
SOURCE_SUPER_EXPRESSION_END

SOURCE_CLASS_EXPRESSION_START
SOURCE_CLASS_EXPRESSION_END

SOURCE_TUPLE_EXP_START
SOURCE_TUPLE_EXP_END

SOURCE_LIST_EXP_START
SOURCE_LIST_EXP_END


SOURCE_MATRIX_EXP_START

SgType*
SgMatrixExp::get_type() const
   {
#if 0
     printf ("In SgMatrixExp::get_type() \n");
#endif
     return SageBuilder::buildMatrixType();
   }

SOURCE_MATRIX_EXP_END

SOURCE_RANGE_EXP_START

SgRangeExp* SgRangeExp::append(SgExpression *exp)
{
  //start:end
  //or start:increment:end

  ROSE_ASSERT(exp != NULL);

  if(p_start == NULL)
    {
      p_start = exp;
    }
  else
    {
      if(p_end == NULL)
  {
    p_end = exp;
  }
      else
  {
    if(p_stride == NULL)
      {
        //Swap stride with end. 1:2 then 1:2:3 comes, 2 was end. now 2 becomes stride
        p_stride = p_end;
        p_end = exp;
      }
    else
      {
        //cannot do more appends. Max 3 items allowed. Raise an error
        return NULL;
      }
  }
    }

  exp->set_parent(this);
  return this;
}

SOURCE_RANGE_EXP_END

SOURCE_COMPREHENSION_START
SOURCE_COMPREHENSION_END

SOURCE_LIST_COMPREHENSION_START
SOURCE_LIST_COMPREHENSION_END

SOURCE_SET_COMPREHENSION_START
SOURCE_SET_COMPREHENSION_END

SOURCE_DICTIONARY_COMPREHENSION_START
SOURCE_DICTIONARY_COMPREHENSION_END

SOURCE_DICTIONARY_EXP_START

SgKeyDatumPairPtrList&
SgDictionaryExp::get_key_datum_pairs()
   { return p_key_datum_pairs; }

const SgKeyDatumPairPtrList&
SgDictionaryExp::get_key_datum_pairs() const
   { return p_key_datum_pairs; }

void
SgDictionaryExp::append_pair(SgKeyDatumPair *what)
   { what->set_parent(this); p_key_datum_pairs.push_back(what); }

SOURCE_DICTIONARY_EXP_END

SOURCE_KEY_DATUM_PAIR_START
SOURCE_KEY_DATUM_PAIR_END

SOURCE_STRING_CONVERSION_START
SOURCE_STRING_CONVERSION_END

SOURCE_SCOPE_OPERATOR_EXPRESSION_START
SOURCE_SCOPE_OPERATOR_EXPRESSION_END


SOURCE_ASSIGN_OPERATOR_EXPRESSION_START
SOURCE_ASSIGN_OPERATOR_EXPRESSION_END


SOURCE_POINTER_ASSIGN_OPERATOR_EXPRESSION_START
SOURCE_POINTER_ASSIGN_OPERATOR_EXPRESSION_END

SOURCE_INTEGER_DIVIDE_ASSIGN_OP_START
SOURCE_INTEGER_DIVIDE_ASSIGN_OP_END

SOURCE_EXPONENTIATION_ASSIGN_OP_START
SOURCE_EXPONENTIATION_ASSIGN_OP_END

SOURCE_REFERENCE_EXPRESSION_START
SOURCE_REFERENCE_EXPRESSION_END


SOURCE_THROW_OPERATOR_EXPRESSION_START

SgType*
$CLASSNAME::get_type() const
   {
  // DQ (1/14/2006): p_expression_type has been removed, we have to compute the appropriate type (IR specific code)

#if 0
     printf ("In $CLASSNAME::get_type() \n");
#endif

  // DQ (1/14/2006): For a list of types held internally it is not clear what to return.
  // So return a SgDefaultType as in Sage II previously.  Might be better to research
  // this in more details later.
     SgType* returnType = SgTypeDefault::createType();

     ROSE_ASSERT(returnType != NULL);
     return returnType;
   }

SOURCE_THROW_OPERATOR_EXPRESSION_END


SOURCE_CONCATENATION_OPERATOR_EXPRESSION_START
SOURCE_CONCATENATION_OPERATOR_EXPRESSION_END

SOURCE_REM_OPERATOR_EXPRESSION_START
SOURCE_REM_OPERATOR_EXPRESSION_END

SOURCE_ABS_OPERATOR_EXPRESSION_START
SOURCE_ABS_OPERATOR_EXPRESSION_END

SOURCE_INITIALIZER_EXPRESSION_START
SOURCE_INITIALIZER_EXPRESSION_END


SOURCE_AGGREGATE_INITIALIZER_EXPRESSION_START

void
SgAggregateInitializer::post_construction_initialization()
   {
     if (get_initializers())
          get_initializers()->set_parent(this);
   }

// DQ: trying to remove the nested iterator class
void
SgAggregateInitializer::append_initializer(SgExpression* what)
   {
     assert(this != NULL);

  // DQ (11/15/2006): avoid setting newArgs this late in the process.
     ROSE_ASSERT(p_initializers != NULL);
     if(!p_initializers)
        {
       // set_initializers(new SgExprListExp(this->get_file_info()));
          SgExprListExp* newArgs = new SgExprListExp ( this->get_file_info() );
          assert(newArgs != NULL);
          newArgs->set_endOfConstruct( this->get_file_info() );
          set_initializers(newArgs);
        }

  // insert_initializer(p_initializers->end(),what);
     p_initializers->append_expression(what);
   }

SgExpression*
SgAggregateInitializer::get_next(int& n) const
   {
     if(n==0)
        {
          n++;
          return get_initializers();
        }
       else
          return 0;
   }

int
SgAggregateInitializer::replace_expression(SgExpression* o, SgExpression* n)
   {
  // DQ (12/17/2006): This function should have the semantics that it will represent a
  // structural change to the AST, thus it is free to set the parent of the new expression.

     ROSE_ASSERT(o != NULL);
     ROSE_ASSERT(n != NULL);

     if (get_initializers() == o)
        {
          set_initializers(isSgExprListExp(n));
          n->set_parent(this);
          return 1;
        }
       else
        {
          return 0;
        }
   }

SgType*
SgAggregateInitializer::get_type() const
   {
#if 0
     printf ("In SgAggregateInitializer::get_type() \n");
#endif

#if 0
     printf ("In SgAggregateInitializer::get_type(): p_expression_type = %p \n",p_expression_type);
#endif
     if (p_expression_type != NULL)
        {
#if 0
          printf ("SgAggregateInitializer::get_type(): p_expression_type != NULL: return p_expression_type = %p = %s \n",p_expression_type,p_expression_type->class_name().c_str());
#endif
          return p_expression_type;
        }
       else
        {
#if 0
          printf ("SgAggregateInitializer::get_type(): default case: return SgTypeDefault::createType()\n");
#endif
          return SgTypeDefault::createType();
        }
   }

// DQ (6/11/2015): Moved these eight access functions, they should not be generated by ROSETTA
// so that we could avoid them setting the isModified flag which is a problem in the
// name qualification support for C++ (interfering with the token-based unparsing).
#if 1
bool
SgAggregateInitializer::get_requiresGlobalNameQualificationOnType () const
   {
     ROSE_ASSERT (this != NULL);
     return p_requiresGlobalNameQualificationOnType;
   }

void
SgAggregateInitializer::set_requiresGlobalNameQualificationOnType ( bool requiresGlobalNameQualificationOnType )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_requiresGlobalNameQualificationOnType = requiresGlobalNameQualificationOnType;
   }

int
SgAggregateInitializer::get_name_qualification_length_for_type () const
   {
     ROSE_ASSERT (this != NULL);
     return p_name_qualification_length_for_type;
   }

void
SgAggregateInitializer::set_name_qualification_length_for_type ( int name_qualification_length_for_type )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_name_qualification_length_for_type = name_qualification_length_for_type;
   }

bool
SgAggregateInitializer::get_type_elaboration_required_for_type () const
   {
     ROSE_ASSERT (this != NULL);
     return p_type_elaboration_required_for_type;
   }

void
SgAggregateInitializer::set_type_elaboration_required_for_type ( bool type_elaboration_required_for_type )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_type_elaboration_required_for_type = type_elaboration_required_for_type;
   }

bool
SgAggregateInitializer::get_global_qualification_required_for_type () const
   {
     ROSE_ASSERT (this != NULL);
     return p_global_qualification_required_for_type;
   }

void
SgAggregateInitializer::set_global_qualification_required_for_type ( bool global_qualification_required_for_type )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_global_qualification_required_for_type = global_qualification_required_for_type;
   }
#else
// DQ (3/22/2018): The names of the data members have been renamed to support the name qualification support
// using the same support as for the SgConstructor initializer.  The name qualification that is supported for
// an aggregate initializer is just that for the C++11 specific type specifier that is sometime required
// (for an example of this see Cxx11_tests/test2018_47.C).  Since it is the type name that is qualified
// it does make sens to use the original names (e.g. name_qualification_length_for_type), but it would be
// inconsistant with the constructor initializer support, and eliminate the opportunity to reuse that
// supporting name qualification code.
int
SgAggregateInitializer::get_name_qualification_length () const
   {
     ROSE_ASSERT (this != NULL);
     return p_name_qualification_length;
   }

void
SgAggregateInitializer::set_name_qualification_length ( int name_qualification_length )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_name_qualification_length = name_qualification_length;
   }

bool
SgAggregateInitializer::get_type_elaboration_required () const
   {
     ROSE_ASSERT (this != NULL);
     return p_type_elaboration_required;
   }

void
SgAggregateInitializer::set_type_elaboration_required ( bool type_elaboration_required )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_type_elaboration_required = type_elaboration_required;
   }

bool
SgAggregateInitializer::get_global_qualification_required () const
   {
     ROSE_ASSERT (this != NULL);
     return p_global_qualification_required;
   }

void
SgAggregateInitializer::set_global_qualification_required ( bool global_qualification_required )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_global_qualification_required = global_qualification_required;
   }
#endif

SOURCE_AGGREGATE_INITIALIZER_EXPRESSION_END


SOURCE_COMPOUND_INITIALIZER_EXPRESSION_START

void
SgCompoundInitializer::post_construction_initialization()
   {
     if (get_initializers())
          get_initializers()->set_parent(this);
   }

// DQ: trying to remove the nested iterator class
void
SgCompoundInitializer::append_initializer(SgExpression* what)
   {
     assert(this != NULL);

  // DQ (11/15/2006): avoid setting newArgs this late in the process.
     ROSE_ASSERT(p_initializers != NULL);
     if(!p_initializers)
        {
       // set_initializers(new SgExprListExp(this->get_file_info()));
          SgExprListExp* newArgs = new SgExprListExp ( this->get_file_info() );
          assert(newArgs != NULL);
          newArgs->set_endOfConstruct( this->get_file_info() );
          set_initializers(newArgs);
        }

  // insert_initializer(p_initializers->end(),what);
     p_initializers->append_expression(what);
   }

SgExpression*
SgCompoundInitializer::get_next(int& n) const
   {
     if(n==0)
        {
          n++;
          return get_initializers();
        }
       else
          return 0;
   }

int
SgCompoundInitializer::replace_expression(SgExpression* o, SgExpression* n)
   {
  // DQ (12/17/2006): This function should have the semantics that it will represent a
  // structural change to the AST, thus it is free to set the parent of the new expression.

     ROSE_ASSERT(o != NULL);
     ROSE_ASSERT(n != NULL);

     if (get_initializers() == o)
        {
          set_initializers(isSgExprListExp(n));
          n->set_parent(this);
          return 1;
        }
       else
        {
          return 0;
        }
   }

SgType*
SgCompoundInitializer::get_type() const
   {
#if 0
     printf ("In SgCompoundInitializer::get_type() \n");
#endif

     if (p_expression_type != NULL)
        {
          return p_expression_type;
        }
       else
        {
       // printf ("SgAggregateInitializer::get_type(): default case\n");
          return SgTypeDefault::createType();
        }
   }

SOURCE_COMPOUND_INITIALIZER_EXPRESSION_END

SOURCE_CONSTRUCTOR_INITIALIZER_EXPRESSION_START

/** Obtain the class declaration for a constructor initializer if possible.
 *
 * If this is a constructor initializer for a class type then the first non-defining declaration of the constructor's class is
 * returned; the null pointer is returned for constructor initializers of primitive types.
 *
 * The SgConstructorInitializer::p_declaration points to a SgMemberFunctionDeclaration when the constructor is declared, but is
 * the null pointer when the constructor is not declared or when the constructor is for a non-class type.
 *
 * When the p_declaration is the null pointer then the SgConstructorInitializer::p_expression_type can be used to determine
 * whether the constructor initializer is for a class type without a declared constructor, or for a non-class type.  In the
 * former case, the p_expression_type points to a SgClassType.  In the latter case it points to either a SgFunctionType (EDG4)
 * or null (EDG3). */
SgClassDeclaration*
SgConstructorInitializer::get_class_decl () const
{
    SgClassDeclaration *class_decl = NULL;

    if (SgMemberFunctionDeclaration *fdecl = get_declaration()) {
        // The constructor is declared (and is a member of a class type)
#if 1
     // DQ (11/11/2014): Modified version of code to address the fact that Fortran is organized a bit differently.
     // That it is different from C++ might be something to revisit later in the Fortran support.
        ROSE_ASSERT(get_declaration() != NULL);
     // printf ("In SgConstructorInitializer::get_class_decl(): get_declaration() = %p = %s \n",get_declaration(),get_declaration()->class_name().c_str());
        ROSE_ASSERT(fdecl->get_scope() != NULL);
     // printf ("In SgConstructorInitializer::get_class_decl(): fdecl->get_scope() = %p = %s \n",fdecl->get_scope(),fdecl->get_scope()->class_name().c_str());

        SgClassDefinition *cdef = isSgClassDefinition(fdecl->get_scope());
        if (cdef != NULL)
           {
             assert(cdef!=NULL);
             class_decl = isSgClassDeclaration(cdef->get_parent());
             assert(class_decl!=NULL);
           }
#else
     // DQ (11/11/2014): Original code which does not work for Fortran (the fortran_constructor_function for a data type is not in the same scope as the data type).
     // This might be something that we want to visit at some point.  But this is caught as an error because the C++11 support caused more
     // debug information to be placed into the generated AST graphs and so this function is now called for Fortran code where it had not
     // previously been called for Fortran code.
        SgClassDefinition *cdef = isSgClassDefinition(fdecl->get_scope());
        assert(cdef!=NULL);
        class_decl = isSgClassDeclaration(cdef->get_parent());
        assert(class_decl!=NULL);
#endif
    } else if (SgClassType *expr_type = isSgClassType(get_expression_type())) {
        // Constructor initializer is for a class type with a non-declared default constructor.  We can follow the
        // p_expression_type's declaration.
        class_decl = isSgClassDeclaration(expr_type->get_declaration());
        assert(class_decl!=NULL);
    } else {
        // Constructor is for a primitive type.  There is no class declaration to return.
    }

    if (class_decl) {
        class_decl = isSgClassDeclaration(class_decl->get_firstNondefiningDeclaration());
        assert(class_decl!=NULL);
    }
    return class_decl;
}

void
SgConstructorInitializer::post_construction_initialization()
   {
     ROSE_ASSERT(p_expression_type != NULL);
     if (p_declaration == NULL)
        {
       // DQ (1/19/2019): This is failing in the copyAST tests for test2005_24.C
          if ( !((isSgTypedefType(p_expression_type) || isSgClassType(p_expression_type) != NULL) || (p_associated_class_unknown == true)) )
             {
               printf ("In SgConstructorInitializer::post_construction_initialization(): What is this failing case?  p_expression_type = %p \n",p_expression_type);
               if (p_expression_type != NULL)
                  {
                    printf ("   --- What is this failing case?  p_expression_type = %p = %s \n",p_expression_type,p_expression_type->class_name().c_str());
                  }
             }

          ROSE_ASSERT( (isSgTypedefType(p_expression_type) || isSgClassType(p_expression_type) != NULL) || (p_associated_class_unknown == true) );
        }

  // DQ (11/15/2006): avoid setting newArgs this late in the process.
  // ROSE_ASSERT(p_args != NULL);
     if (p_args == NULL)
        {
       // Build an empty argument list

       // DQ (11/16/2006): Need to handle use in new constructors that don't have fileInfo parameters.
       // p_args = new SgExprListExp(New_File_Info(this));
          if (get_startOfConstruct() != NULL)
             {
               p_args = new SgExprListExp(New_File_Info(this));
               p_args->set_endOfConstruct(New_File_Info(this));
             }
            else
             {
               p_args = new SgExprListExp();
             }
          ROSE_ASSERT(p_args != NULL);
        }

  // if (get_args() != NULL)
  //      get_args()->set_parent(this);
     get_args()->set_parent(this);

     ROSE_ASSERT(p_args != NULL);
   }

#if 0
SgClassDeclaration*
SgConstructorInitializer::get_class_decl () const
   {
     assert (this != NULL);

  // Look this up from the SgType that we now store explicitly instead of the SgClassDeclaration
  // return p_class_decl;

     SgClassDeclaration* classDeclaration = NULL;
     ROSE_ASSERT(this->get_type() != NULL);

     return classDeclaration;
   }
#endif

#if 0
// Need a feature in the grammar code generator to permit
// user specification of the set_DATA member function
void
SgConstructorInitializer::set_declaration(SgMemberFunctionDeclaration* new_val)
   {
     p_declaration = new_val;
#ifndef REMOVE_SET_PARENT_FUNCTION
     if(p_declaration)p_declaration->set_parent(this);
#endif
   }

void
SgConstructorInitializer::set_args(SgExprListExp* new_val)
   {
     p_args = new_val;
#ifndef REMOVE_SET_PARENT_FUNCTION
     if(p_args)p_args->set_parent(this);
#endif
   }

void
SgConstructorInitializer::set_class_decl(SgClassDeclaration* new_val)
   {
     p_class_decl = new_val;
#ifndef REMOVE_SET_PARENT_FUNCTION
     if(p_class_decl)p_class_decl->set_parent(this);
#endif
   }
#endif

//#if 0
SgExpression*
SgConstructorInitializer::get_next(int& n) const
   {
     if(n==0)
        {
          n++;
          return get_args();
        }
     return 0;
   }
//#endif

int
SgConstructorInitializer::replace_expression(SgExpression *o, SgExpression *n)
   {
  // DQ (12/17/2006): This function should have the semantics that it will represent a
  // structural change to the AST, thus it is free to set the parent of the new expression.

     ROSE_ASSERT(o != NULL);
     ROSE_ASSERT(n != NULL);

     if(get_args() == o)
        {
          set_args(isSgExprListExp(n));
          n->set_parent(this);
          return 1;
        }
       else
          return 0;
   }

// DQ (6/11/2015): Moved these six access functions, they should not be generated by ROSETTA
// so that we could avoid them setting the isModified flag which is a problem in the
// name qualification support for C++ (interfering with the token-based unparsing).
int
SgConstructorInitializer::get_name_qualification_length () const
   {
     ROSE_ASSERT (this != NULL);
     return p_name_qualification_length;
   }

void
SgConstructorInitializer::set_name_qualification_length ( int name_qualification_length )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_name_qualification_length = name_qualification_length;
   }

bool
SgConstructorInitializer::get_type_elaboration_required () const
   {
     ROSE_ASSERT (this != NULL);

     return p_type_elaboration_required;
   }

void
SgConstructorInitializer::set_type_elaboration_required ( bool type_elaboration_required )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_type_elaboration_required = type_elaboration_required;
   }

bool
SgConstructorInitializer::get_global_qualification_required () const
   {
     ROSE_ASSERT (this != NULL);
     return p_global_qualification_required;
   }

void
SgConstructorInitializer::set_global_qualification_required ( bool global_qualification_required )
   {
     ROSE_ASSERT (this != NULL);

  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_global_qualification_required = global_qualification_required;
   }

SOURCE_CONSTRUCTOR_INITIALIZER_EXPRESSION_END

SOURCE_ASSIGNMENT_INITIALIZER_EXPRESSION_START

SgExpression*
$CLASSNAME::get_operand() const
   { return get_operand_i(); }

void
$CLASSNAME::post_construction_initialization()
   {
// #ifndef REMOVE_SET_PARENT_FUNCTION
     if (get_operand() != NULL)
          get_operand()->set_parent(this);
// #endif

  // DQ (1/14/2006): set_type is removed
  // set_type();
   }

SgType*
$CLASSNAME::get_type() const
   {
  // DQ (1/14/2006): p_expression_type has been removed, we have to compute the appropriate type (IR specific code)

  // printf ("$CLASSNAME::get_type(): p_expression_type has been removed, getting the return type from the stored internal operand \n");

     ROSE_ASSERT(get_operand() != NULL);

#if 0
     printf ("In $CLASSNAME::get_type() \n");
#endif

     SgType* returnType = p_expression_type ? p_expression_type : get_operand()->get_type();

     ROSE_ASSERT(returnType != NULL);

     if (!p_expression_type && get_operand()->variantT() != V_SgStringVal)
        {
          SgType* retElemType = SageInterface::getElementType(returnType);
          if (retElemType != NULL)
             {
               returnType = SgPointerType::createType(retElemType);
             }
        }

     ROSE_ASSERT(returnType != NULL);
     return returnType;
   }

void
$CLASSNAME::set_operand(SgExpression * exp)
   {
     set_operand_i(exp);
// #ifndef REMOVE_SET_PARENT_FUNCTION
     if (exp)
          exp->set_parent(this);
// #endif

  // DQ (1/14/2006): set_type is removed
  // set_type();
   }

SgExpression*
$CLASSNAME::get_next(int& n) const
   {
     if(n==0)
        {
          n++;
          return get_operand();
        }
       else
          return 0;
   }

int
$CLASSNAME::replace_expression(SgExpression *o, SgExpression *n)
   {
  // DQ (12/17/2006): This function should have the semantics that it will represent a
  // structural change to the AST, thus it is free to set the parent of the new expression.

     ROSE_ASSERT(o != NULL);
     ROSE_ASSERT(n != NULL);

     if(get_operand()==o)
        {
          set_operand(n);
          n->set_parent(this);
          return 1;
        }
       else
          return 0;
   }

SOURCE_ASSIGNMENT_INITIALIZER_EXPRESSION_END


SOURCE_BRACED_INITIALIZER_EXPRESSION_START

void
SgBracedInitializer::post_construction_initialization()
   {
     if (get_initializers())
          get_initializers()->set_parent(this);
   }

// DQ: trying to remove the nested iterator class
void
SgBracedInitializer::append_initializer(SgExpression* what)
   {
     assert(this != NULL);

  // DQ (11/15/2006): avoid setting newArgs this late in the process.
     ROSE_ASSERT(p_initializers != NULL);
     if(!p_initializers)
        {
       // set_initializers(new SgExprListExp(this->get_file_info()));
          SgExprListExp* newArgs = new SgExprListExp ( this->get_file_info() );
          assert(newArgs != NULL);
          newArgs->set_endOfConstruct( this->get_file_info() );
          set_initializers(newArgs);
        }

  // insert_initializer(p_initializers->end(),what);
     p_initializers->append_expression(what);
   }

SgExpression*
SgBracedInitializer::get_next(int& n) const
   {
     if(n==0)
        {
          n++;
          return get_initializers();
        }
       else
          return 0;
   }

int
SgBracedInitializer::replace_expression(SgExpression* o, SgExpression* n)
   {
  // DQ (12/17/2006): This function should have the semantics that it will represent a
  // structural change to the AST, thus it is free to set the parent of the new expression.

     ROSE_ASSERT(o != NULL);
     ROSE_ASSERT(n != NULL);

     if (get_initializers() == o)
        {
          set_initializers(isSgExprListExp(n));
          n->set_parent(this);
          return 1;
        }
       else
        {
          return 0;
        }
   }

SgType*
SgBracedInitializer::get_type() const
   {
#if 0
     printf ("In SgAggregateInitializer::get_type() \n");
#endif

#if 0
     printf ("In SgAggregateInitializer::get_type(): p_expression_type = %p \n",p_expression_type);
#endif
     if (p_expression_type != NULL)
        {
#if 0
          printf ("SgAggregateInitializer::get_type(): p_expression_type != NULL: return p_expression_type = %p = %s \n",p_expression_type,p_expression_type->class_name().c_str());
#endif
          return p_expression_type;
        }
       else
        {
#if 0
          printf ("SgAggregateInitializer::get_type(): default case: return SgTypeDefault::createType()\n");
#endif
          return SgTypeDefault::createType();
        }
   }

#if 0
// DQ (11/15/2016): I don' think that name qualification maes sense for a braced initializer.

// DQ (6/11/2015): Moved these six access functions, they should not be generated by ROSETTA
// so that we could avoid them setting the isModified flag which is a problem in the
// name qualification support for C++ (interfering with the token-based unparsing).
bool
SgBracedInitializer::get_requiresGlobalNameQualificationOnType () const
   {
     ROSE_ASSERT (this != NULL);
     return p_requiresGlobalNameQualificationOnType;
   }

void
SgBracedInitializer::set_requiresGlobalNameQualificationOnType ( bool requiresGlobalNameQualificationOnType )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_requiresGlobalNameQualificationOnType = requiresGlobalNameQualificationOnType;
   }

int
SgBracedInitializer::get_name_qualification_length_for_type () const
   {
     ROSE_ASSERT (this != NULL);
     return p_name_qualification_length_for_type;
   }

void
SgBracedInitializer::set_name_qualification_length_for_type ( int name_qualification_length_for_type )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_name_qualification_length_for_type = name_qualification_length_for_type;
   }

bool
SgBracedInitializer::get_type_elaboration_required_for_type () const
   {
     ROSE_ASSERT (this != NULL);
     return p_type_elaboration_required_for_type;
   }

void
SgBracedInitializer::set_type_elaboration_required_for_type ( bool type_elaboration_required_for_type )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_type_elaboration_required_for_type = type_elaboration_required_for_type;
   }

bool
SgBracedInitializer::get_global_qualification_required_for_type () const
   {
     ROSE_ASSERT (this != NULL);
     return p_global_qualification_required_for_type;
   }

void
SgBracedInitializer::set_global_qualification_required_for_type ( bool global_qualification_required_for_type )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_global_qualification_required_for_type = global_qualification_required_for_type;
   }
#endif

SOURCE_BRACED_INITIALIZER_EXPRESSION_END


// ######################################################
// ######################################################
// ######################################################
// ######################################################
// ######################################################
// ######################################################

// ******************************************************
// $CLASSNAME::post_construction_initialization() function
// ******************************************************

SOURCE_EMPTY_POST_CONSTRUCTION_INITIALIZATION_START
void
$CLASSNAME::post_construction_initialization()
   {
   }

SOURCE_EMPTY_POST_CONSTRUCTION_INITIALIZATION_END


SOURCE_POST_CONSTRUCTION_INITIALIZATION_USING_SET_TYPE_START

#error "This code from SOURCE_POST_CONSTRUCTION_INITIALIZATION_USING_SET_TYPE should not be used"

void
$CLASSNAME::post_construction_initialization()
   {
     set_type();
   }
SOURCE_POST_CONSTRUCTION_INITIALIZATION_USING_SET_TYPE_END


// *******************************************
//       $CLASSNAME::set_Type() function
// *******************************************

// SgExprListExp
// SgVarRefExp
// SgClassNameRefExp
// SgValueExp
// SgNewExp
// SgDeleteExp
// SgThisExp
// SgAggregateInitializer
SOURCE_EMPTY_SET_TYPE_FUNCTION_START

#error "This code from SOURCE_EMPTY_SET_TYPE_FUNCTION should not be used"

// DQ (1/14/2006): set_type is removed
void
$CLASSNAME::set_type()
   {
   }

SOURCE_EMPTY_SET_TYPE_FUNCTION_END


// SgEqualityOp
// SgLessThanOp
// SgGreaterThanOp
// SgNotEqualOp
// SgLessOrEqualOp
// SgGreaterOrEqualOp
SOURCE_SET_TYPE_BOOLEAN_OPERATOR_EXPRESSION_START

#error "This code from SOURCE_SET_TYPE_BOOLEAN_OPERATOR_EXPRESSION should not be used"

// DQ (1/14/2006): set_type is removed
void
$CLASSNAME::set_type()
   {
     set_expression_type(SgTypeBool::createType());
   }

SOURCE_SET_TYPE_BOOLEAN_OPERATOR_EXPRESSION_END


// SgAddOp
// SgSubtractOp
// SgMultiplyOp
// SgDivideOp
// SgIntegerDivideOp
// SgModOp
SOURCE_ARITHMETIC_OPERATOR_EXPRESSION_START

#if 0
#error "This code from SOURCE_ARITHMETIC_OPERATOR_EXPRESSION should not be used"

// DQ (1/14/2006): set_type is removed
void
$CLASSNAME::set_type()
   {
     assert(get_lhs_operand() != NULL);
     assert(get_rhs_operand() != NULL);
     SgType * op_type = SgType::arithmetic_conversions(get_lhs_operand()->get_type(), get_rhs_operand()->get_type());
     set_expression_type(op_type);
   }
#endif

SOURCE_ARITHMETIC_OPERATOR_EXPRESSION_END


// SgAndOp
// SgOrOp
// SgNotOp
SOURCE_INTEGER_OPERATOR_EXPRESSION_START

#if 0
#error "This code from SOURCE_INTEGER_OPERATOR_EXPRESSION should not be used"

// DQ (1/14/2006): set_type is removed
void
$CLASSNAME::set_type()
   {
     set_expression_type(SgTypeInt::createType());
   }
#endif

SOURCE_INTEGER_OPERATOR_EXPRESSION_END


// SgBitXorOp
// SgBitAndOp
// SgBitOrOp
// SgBitEqvOp
SOURCE_BIT_OPERATOR_EXPRESSION_START

#if 0
#error "This code from SOURCE_BIT_OPERATOR_EXPRESSION should not be used"

// DQ (1/14/2006): set_type is removed
void
$CLASSNAME::set_type()
   {
     assert(get_lhs_operand() != NULL);
     assert(get_rhs_operand() != NULL);
     SgType * int_type = SgType::integer_promotion(get_lhs_operand()->get_type(), get_rhs_operand()->get_type());
     assert(int_type != NULL);
     set_expression_type(int_type);
   }
#endif

SOURCE_BIT_OPERATOR_EXPRESSION_END


// SgFunctionCallExp
// SgFunctionRefExp
SOURCE_GET_FUNCTION_SET_TYPE_FUNCTION_EXPRESSION_START
SOURCE_GET_FUNCTION_SET_TYPE_FUNCTION_EXPRESSION_END

// SgArrowExp
// SgDotExp
// SgScopeOp
SOURCE_GET_RHS_OPERAND_FUNCTION_EXPRESSION_START
SOURCE_GET_RHS_OPERAND_FUNCTION_EXPRESSION_END


// SgLshiftOp
// SgRshiftOp
// SgAssignOp
// SgPlusAssignOp (not used currently, suspected bug?)
// SgMinusAssignOp
// SgAndAssignOp
// SgIorAssignOp
// SgMinusAssignOp
// SgMultAssignOp
// SgDivAssignOp
// SgModAssignOp
// SgXorAssignOp
// SgLshiftAssignOp
// SgRshiftAssignOp
SOURCE_SET_TYPE_SHIFT_OPERATOR_EXPRESSION_START

#error "This code from SOURCE_SET_TYPE_SHIFT_OPERATOR_EXPRESSION should not be used"

// DQ (1/14/2006): set_type is removed
void
$CLASSNAME::set_type()
   {
     assert(get_lhs_operand() != NULL);
     set_expression_type(get_lhs_operand()->get_type());
   }

SOURCE_SET_TYPE_SHIFT_OPERATOR_EXPRESSION_END


// SgMinusOp
// SgUnaryAddOp
// SgMinusMinusOp
// SgPlusPlusOp
// SgBitComplementOp  // Why is this not like the other Bit operators?
// SgAssignInitializer
SOURCE_SET_TYPE_UNARY_OPERATOR_EXPRESSION_START

#error "This code from SOURCE_SET_TYPE_UNARY_OPERATOR_EXPRESSION should not be used"

// DQ (1/14/2006): set_type is removed
void
$CLASSNAME::set_type()
   {
     assert(get_operand() != NULL);
     set_expression_type(get_operand()->get_type());
   }

SOURCE_SET_TYPE_UNARY_OPERATOR_EXPRESSION_END


// SgSizeOfOp
// SgTypeIdOp
SOURCE_SET_TYPE_SIZEOF_TYPEID_OPERATOR_EXPRESSION_START

#error "This code from SOURCE_SET_TYPE_SIZEOF_TYPEID_OPERATOR_EXPRESSION should not be used"

// DQ (1/14/2006): set_type is removed
void
$CLASSNAME::set_type()
   {
     if(get_operand_expr() != NULL)
          set_expression_type(get_operand_expr()->get_type());
       else
          set_expression_type(get_operand_type());
   }

SOURCE_SET_TYPE_SIZEOF_TYPEID_OPERATOR_EXPRESSION_END


// SgThrowOp
SOURCE_SET_TYPE_DEFAULT_TYPE_EXPRESSION_START

#error "This code from SOURCE_SET_TYPE_DEFAULT_TYPE_EXPRESSION should not be used"

// DQ (1/14/2006): set_type is removed
void
$CLASSNAME::set_type()
   {
     set_expression_type(SgTypeDefault::createType());
   }

SOURCE_SET_TYPE_DEFAULT_TYPE_EXPRESSION_END


// *******************************************
//       CLASSNAME::get_Type() function
// *******************************************


// SgExprListExp
SOURCE_DEFAULT_GET_TYPE_START
SgType*

$CLASSNAME::get_type() const
   {
     ROSE_ASSERT(this != NULL);

#if 0
     printf ("In $CLASSNAME::get_type() (default_get_type) calling SgTypeDefault::createType() \n");
#endif

  // DQ (10/31/2016): Debugging...
  // return SgTypeDefault::createType();
     SgType* returnType = SgTypeDefault::createType();

#if 0
     printf ("Leaving $CLASSNAME::get_type() (default_get_type) returnType = %p \n",returnType);
#endif

     return returnType;
   }

SOURCE_DEFAULT_GET_TYPE_END


SOURCE_GET_TYPE_FROM_SYMBOL_START

SgType*
$CLASSNAME::get_type() const
   {
     ROSE_ASSERT(this != NULL);

#if 0
     printf ("In $CLASSNAME::get_type() \n");
#endif

     SgSymbol* symbol = this->get_symbol();
     if (symbol == NULL)
        {
          printf ("Error: In $CLASSNAME::get_type(): symbol == NULL this = %p = %s \n",this,this->class_name().c_str());
        }
     ROSE_ASSERT(symbol != NULL);

  // DQ (9/27/2006): Added assertion
  // ROSE_ASSERT(get_symbol()->get_type() != NULL);

  // printf ("In $CLASSNAME::get_type(): symbol = %p = %s \n",symbol,symbol->class_name().c_str());
     SgType* type = symbol->get_type();
     if (type == NULL)
        {
          printf ("Error: In $CLASSNAME::get_type(): type == NULL symbol = %p = %s \n",symbol,symbol->class_name().c_str());
        }
     ROSE_ASSERT(type != NULL);

  // return get_symbol()->get_type();
     return type;
   }

SOURCE_GET_TYPE_FROM_SYMBOL_END

// SgFunctionRefExp
// SgMemberFunctionRefExp
SOURCE_GET_TYPE_FUNCTION_REFERENCE_EXPRESSION_START

SgType*
$CLASSNAME::get_type() const
   {
  // DQ (1/14/2006): explicit type is now computed instead of being stored.
  // assert(p_function_type != NULL);

  // DQ (7/30/2004): The type of a SgFunctionRefExp should be a SgFunctionType,
  // not the return type of the function associated with the SgFunctionRefExp.
  // return p_function_type->get_return_type();
  // return get_function_type();

     printf ("$CLASSNAME::get_type() for FUNCTION_REFERENCE_EXPRESSION not implemented (p_function_type removed) \n");
     ROSE_ASSERT(false);

     return NULL;
   }

SOURCE_GET_TYPE_FUNCTION_REFERENCE_EXPRESSION_END

// DQ (8/17/2010): Removed SgStringVal from the list of types using the generic form of get_type()
// SgBoolValExp
// SgShortVal
// SgCharVal
// SgUnsignedCharVal
// SgWcharVal
// SgUnsignedShortVal
// SgIntVal
// SgEnumVal
// SgUnsignedIntVal
// SgLongIntVal
// SgLongLongIntVal
// SgUnsignedLongLongIntVal
// SgUnsignedLongVal
// SgFloatVal
// SgDoubleVal
// SgLongDoubleVal
// SgDeleteExp
SOURCE_GET_TYPE_GENERIC_START

SgType*
$CLASSNAME::get_type(void) const
   {
#if 0
     printf ("In $CLASSNAME::get_type() \n");
#endif

     return GENERIC_TYPE::createType();
   }

SOURCE_GET_TYPE_GENERIC_END

// SgStringVal
SOURCE_GET_TYPE_STRING_START

SgType*
SgStringVal::get_type(void) const
   {
#if 0
     printf ("In SgStringVal::get_type() \n");
#endif

  // Since this is a literal, it must have a defined size (even if it is length zero).
     size_t stringSize = get_value().size();

#if 0
  // Debugging...
     if (stringSize == 0)
        {
          printf ("SgStringVal::get_type(): string generated an empty string type -- get_value() = %s \n",get_value().c_str());
        }
#endif

  // DQ (10/5/2010): Modified to used new API (only lengthExpression is supported).
  // Use the literal size and assume that there is no associated expression.
  // return SgTypeString::createType(NULL,stringSize);
     Sg_File_Info* fileInfo = Sg_File_Info::generateDefaultFileInfoForCompilerGeneratedNode();
     SgIntVal* lengthExpression = new SgIntVal(fileInfo,(int)stringSize,"");
     ROSE_ASSERT(lengthExpression != NULL);
     return SgTypeString::createType(lengthExpression);
   }

SOURCE_GET_TYPE_STRING_END

SOURCE_GET_TYPE_COMPLEX_START

SgType*
$CLASSNAME::get_type(void) const
   {
  // Use the stored SgType to return the correct SgTypeComplex using the correct precision.
     ROSE_ASSERT(p_precisionType != NULL);

#if 0
     printf ("In $CLASSNAME::get_type() \n");
#endif

  // returns a shared SgTypeComplex type
     return SgTypeComplex::createType(p_precisionType);
   }

SOURCE_GET_TYPE_COMPLEX_END

// SgConstructorInitializer (DQ (8/1/2006): This code fragment is no longer used!)
SOURCE_GET_TYPE_CLASS_DECL_START

// DQ (7/19/2006): Function suggested by Jeremiah Willcock and fixed up for general use by DQ
// A better fix (later) will allow us to save the SgType and not use a SgDefaultType for the
// special case below.
SgType*
$CLASSNAME::get_type(void) const
   {
     ROSE_ASSERT(this != NULL);

#if 0
     printf ("In $CLASSNAME::get_type() \n");
#endif

  // DQ (8/5/2006): Now that we store the expression type explicitly this is a simpler function.
     SgType* returnType = p_expression_type;

     ROSE_ASSERT(returnType != NULL);
     return returnType;
   }

SOURCE_GET_TYPE_CLASS_DECL_END

// SgFunctionCallExp
// SgSizeOfOp
// SgTypeIdOp
// SgConditionalExp
// SgAssignInitializer
SOURCE_GET_TYPE_CALLING_GET_EXPRESSION_TYPE_EXPRESSION_START

#error "This is not IR node dependent since we compute the type"

SgType*
$CLASSNAME::get_type() const
   {
  // DQ (1/14/2006): p_expression_type has been removed, we have to compute the appropriate type (not implemented)
  // return get_expression_type();

     printf ("$CLASSNAME::get_type(): p_expression_type has been removed, we have to compute the appropriate type (not implemented) \n");
     ROSE_ASSERT(false);

     return NULL;
   }

SOURCE_GET_TYPE_CALLING_GET_EXPRESSION_TYPE_EXPRESSION_END

SOURCE_GET_TYPE_THIS_EXPRESSION_START

SgType*
$CLASSNAME::get_type() const
   {
     SgType * type = NULL;
     if (get_class_symbol() != NULL) {
       type = get_class_symbol()->get_type();
     }
     if (get_nonreal_symbol() != NULL) {
       type = get_nonreal_symbol()->get_type();
     }

#if 0
     printf ("In $CLASSNAME::get_type() \n");
#endif
     ROSE_ASSERT(type != NULL);

     return SgPointerType::createType(type);
   }

SOURCE_GET_TYPE_THIS_EXPRESSION_END

SOURCE_GET_TYPE_SUPER_EXPRESSION_START

SgType*
$CLASSNAME::get_type() const
   {
     ROSE_ASSERT(get_class_symbol() != NULL);
     ROSE_ASSERT(get_class_symbol()->get_type() != NULL);

#if 0
     printf ("In $CLASSNAME::get_type() \n");
#endif

     return SgPointerType::createType(get_class_symbol()->get_type());
   }

SOURCE_GET_TYPE_SUPER_EXPRESSION_END

SOURCE_GET_TYPE_CLASS_EXPRESSION_START

SgType*
$CLASSNAME::get_type() const
   {
     ROSE_ASSERT(get_class_symbol() != NULL);
     ROSE_ASSERT(get_class_symbol()->get_type() != NULL);

#if 0
     printf ("In $CLASSNAME::get_type() \n");
#endif

     return get_class_symbol() -> get_type();
   }

SOURCE_GET_TYPE_CLASS_EXPRESSION_END

SOURCE_NULL_EXPRESSION_START
SOURCE_NULL_EXPRESSION_END

SOURCE_VARIANT_EXPRESSION_START
SOURCE_VARIANT_EXPRESSION_END

SOURCE_STATEMENT_EXPRESSION_START
SgType*
$CLASSNAME::get_type() const
   {
     SgType* returnType = NULL;

     ROSE_ASSERT(p_statement != NULL);

  // DQ (7/21/2006): For now we implement this partially and fix it up later.
  // We might want to store the type explicitly since it might be difficult
  // to compute for complex sequences of statements.  It appears that the
  // type is just the type of the expression in the last statement of the block,
  // but it is not clear if it can be more complex than this!

  // The rules are: The last thing in the compound statement should be an expression
  // followed by a semicolon; the value of this subexpression serves as the value of
  // the entire construct. (If you use some other kind of statement last within the
  // braces, the construct has type void, and thus effectively no value.).

  // printf ("$CLASSNAME::get_type() for GNU Statement Expression extension not implemented p_statement = %p = %s \n",p_statement,p_statement->class_name().c_str());
  // ROSE_ASSERT(false);

  // This is the default case (we can look at the last statement of the block later)
  // returnType = SgTypeVoid::createType();

#if 0
     printf ("In $CLASSNAME::get_type() \n");
#endif

  // DQ (8/6/2006): The rules for the type of a statement expression are that it is the
  // type of the last expression in the statement list or void if the last statement is
  // not an expression (expression statement, SgExpressionStatement).
     SgBasicBlock* block = isSgBasicBlock(p_statement);
     ROSE_ASSERT(block != NULL);

     SgStatementPtrList & statementList = block->getStatementList();

  // DQ (4/8/2015): Empty statement expressions have to be allowed.
  // ROSE_ASSERT(statementList.empty() == false);
     if (statementList.empty() == true)
        {
       // DQ (4/8/2015): After discusion, this might be better setup as a SgTypeUnknown instead of SgTypeVoid.
          returnType = SgTypeVoid::createType();
        }
       else
        {
          SgStatement* lastStatement = *(statementList.rbegin());
          SgExprStatement* expressionStatement = isSgExprStatement(lastStatement);
          if (expressionStatement != NULL)
             {
            // The type of the statement expression is the
            // SgExpression* expression = expressionStatement->get_the_expr();
               SgExpression* expression = expressionStatement->get_expression();
               ROSE_ASSERT(expression != NULL);
               returnType = expression->get_type();
             }
            else
             {
            // This is the default type if last statement in block is not an expression statement (C++ standard)
               returnType = SgTypeVoid::createType();
             }
        }

     ROSE_ASSERT(returnType != NULL);

  // printf ("$CLASSNAME::get_type() for GNU Statement Expression extension returnType = %s \n",returnType->class_name().c_str());

     return returnType;
   }

SOURCE_STATEMENT_EXPRESSION_END

SOURCE_ASM_OP_START
SgType*
$CLASSNAME::get_type() const
   {
     SgType* returnType = NULL;

     ROSE_ASSERT(p_expression != NULL);

  // printf ("$CLASSNAME::get_type() for asm operand not implemented p_expression = %p = %s \n",p_expression,p_expression->class_name().c_str());
  // ROSE_ASSERT(false);

#if 0
     printf ("In $CLASSNAME::get_type() \n");
#endif

  // This is the default case (we can look at the last statement of the block later)
     returnType = p_expression->get_type();
     ROSE_ASSERT(returnType != NULL);

     return returnType;
   }

SOURCE_ASM_OP_END



SOURCE_EXPONENTIATION_EXPRESSION_START

void
$CLASSNAME::post_construction_initialization()
   {
   }

#if 0
SgType*
$CLASSNAME::get_type() const
   {
     return NULL;
   }
#endif

SOURCE_EXPONENTIATION_EXPRESSION_END



SOURCE_INTRINSICFN_EXPRESSION_START

#error "DEAD CODE!"

void
SgIntrinsicFn::post_construction_initialization()
   { }

#error "DEAD CODE!"

SgType*
SgIntrinsicFn::get_type() const
   {
     printf ("In SgIntrinsicFn::get_type(): Not clear what this type should be. \n");
     ROSE_ASSERT(false);
     return NULL;
   }

#error "DEAD CODE!"

void
SgIntrinsicFn::append_arg($GRAMMAR_PREFIX_Expression* what)
   {
     assert(this != NULL);
     if (p_args == NULL)
        {
       // set_args(new $GRAMMAR_PREFIX_ExprListExp(this->get_file_info()));
          $GRAMMAR_PREFIX_ExprListExp* newArgs = new $GRAMMAR_PREFIX_ExprListExp ( this->get_file_info() );
          assert(newArgs != NULL);
          set_args(newArgs);
        }

    // insert_arg(p_args->end(),what);
       p_args->append_expression(what);
   }

#error "DEAD CODE!"

#if 0
// DQ (3/20/2007): This is an older function now depricated.
int
SgIntrinsicFn::replace_expression($GRAMMAR_PREFIX_Expression *,$GRAMMAR_PREFIX_Expression *)
   { return 0; }
#endif

#error "DEAD CODE!"

SOURCE_INTRINSICFN_EXPRESSION_END


SOURCE_SUBSCRIPT_EXPR_EXPRESSION_START

void
SgSubscriptExpression::post_construction_initialization()
   { }

SgType*
SgSubscriptExpression::get_type() const
   {
  // printf ("Not clear what the type should be for a SgSubscriptExpression: returning type of lower bound,upper bound, and string; or SgIntType if none are available. \n");
  // ROSE_ASSERT(false);

     SgType* returnType = NULL;

#if 0
     printf ("In SgSubscriptExpression::get_type() \n");
#endif

     bool isLowerBoundNullExpression = (isSgNullExpression(get_lowerBound()) != NULL);
     bool isUpperBoundNullExpression = (isSgNullExpression(get_upperBound()) != NULL);
     bool isStrideNullExpression     = (isSgNullExpression(get_stride()) != NULL);

  // Even if the stride was not specified it should default to unit stride (value == 1).
     ROSE_ASSERT(isStrideNullExpression == false);

     if (isLowerBoundNullExpression == true)
        {
       // There was no lower bound specified
          if (isUpperBoundNullExpression == true)
             {
            // There was no upper bound specified, so we have to assume SgIntType is OK!
               returnType = SgTypeInt::createType();
             }
            else
             {
               returnType = get_upperBound()->get_type();
             }
        }
       else
        {
          returnType = get_lowerBound()->get_type();
          if (isUpperBoundNullExpression == true)
             {
            // Not a problem since the lower bound was specified
             }
            else
             {
            // Just make sure that they are the same type, not clear how important this is!
               SgType* upperBoundType = get_upperBound()->get_type();
            // ROSE_ASSERT(upperBoundType->variantT() == returnType->variantT());
               if (upperBoundType->variantT() != returnType->variantT())
                  {
                 // These are a different type..., I wonder why
                    printf ("In SgSubscriptExpression::get_type(): Note that lowerBound = %s and upperBound = %s are different types \n",returnType->class_name().c_str(),upperBoundType->class_name().c_str());
                    this->get_startOfConstruct()->display("In SgSubscriptExpression::get_type(): lowerBound and upperBound are different types");
                  }
             }
        }

     return returnType;
   }

#if 0
// DQ (3/20/2007): This is an older function now depricated.
int
SgSubscriptExpression::replace_expression($GRAMMAR_PREFIX_Expression *o, $GRAMMAR_PREFIX_Expression *n)
   {
     if(get_lowerBound()==o)
        {
          set_lowerBound(n);
          return 1;
        }
       else
          if(get_upperBound()==o)
             {
               set_upperBound(n);
               return 1;
             }
          else
             if(get_stride()==o)
                {
                  set_stride(n);
                  return 1;
                }
                else
                  return 0;
   }
#endif

SOURCE_SUBSCRIPT_EXPR_EXPRESSION_END


SOURCE_SUBSCRIPT_COLON_EXPRESSION_START

#error "DEAD CODE!"

void
SgSubscriptColon::post_construction_initialization()
   { }


#error "DEAD CODE!"

SgType*
SgSubscriptColon::get_type() const
   {
     printf ("In SgSubscriptColon::get_type(): Not clear what this type should be. \n");
     ROSE_ASSERT(false);
     return NULL;
   }

#error "DEAD CODE!"

#if 0
// DQ (3/20/2007): This is an older function now depricated.
int
SgSubscriptColon::replace_expression($GRAMMAR_PREFIX_Expression *o, $GRAMMAR_PREFIX_Expression *n)
   {
     if(get_lowerBound()==o)
        {
          set_lowerBound(n);
          return 1;
        }
       else
          if(get_stride()==o)
             {
               set_stride(n);
               return 1;
             }
             else
               return 0;
   }
#endif

#error "DEAD CODE!"

SOURCE_SUBSCRIPT_COLON_EXPRESSION_END


SOURCE_COLON_SHAPE_EXPRESSION_START

void
SgColonShapeExp::post_construction_initialization()
   { }


SgType*
SgColonShapeExp::get_type() const
   {
  // printf ("In SgColonShapeExp::get_type(): Not clear what this type should be. \n");
  // ROSE_ASSERT(false);

#if 0
     printf ("In SgColonShapeExp::get_type() \n");
#endif

     return SgTypeDefault::createType();
   }

#if 0
// DQ (3/20/2007): This is an older function now depricated.
int
SgColonShapeExp::replace_expression($GRAMMAR_PREFIX_Expression *o, $GRAMMAR_PREFIX_Expression *n)
   {
     if(get_lowerBound()==o)
        {
          set_lowerBound(n);
          return 1;
        }
       else
          if(get_stride()==o)
             {
               set_stride(n);
               return 1;
             }
             else
               return 0;
   }
#endif

SOURCE_COLON_SHAPE_EXPRESSION_END


SOURCE_ASTERISK_SHAPE_EXPRESSION_START

void
SgAsteriskShapeExp::post_construction_initialization()
   { }

SgType*
SgAsteriskShapeExp::get_type() const
   {
  // printf ("In SgAsteriskShapeExp::get_type(): Not clear what this type should be. \n");
  // ROSE_ASSERT(false);

#if 0
     printf ("In SgAsteriskShapeExp::get_type() \n");
#endif

     return SgTypeDefault::createType();
   }

#if 0
// DQ (3/20/2007): This is an older function now depricated.
int
SgAsteriskShapeExp::replace_expression($GRAMMAR_PREFIX_Expression *o, $GRAMMAR_PREFIX_Expression *n)
   {
     if(get_lowerBound()==o)
        {
          set_lowerBound(n);
          return 1;
        }
       else
          if(get_stride()==o)
             {
               set_stride(n);
               return 1;
             }
             else
               return 0;
   }
#endif

SOURCE_ASTERISK_SHAPE_EXPRESSION_END


SOURCE_USE_ONLY_EXPR_START

void
SgUseOnlyExpression::post_construction_initialization()
   { }

SgType*
SgUseOnlyExpression::get_type() const
   {
     printf ("In SgUseOnlyExpression::get_type(): Not clear what this type should be. \n");
     ROSE_ASSERT(false);

     return NULL;
   }

#if 0
// DQ (3/20/2007): This is an older function now depricated.
int
UseOnlyExpression::replace_expression($GRAMMAR_PREFIX_Expression* o, $GRAMMAR_PREFIX_Expression* n)
   {
     if(get_access_list()==o)
        {
          set_access_list(is$GRAMMAR_PREFIX_ExprListExp(n));
          return 1;
        }
       else
          return 0;
   }
#endif

SOURCE_USE_ONLY_EXPR_END


SOURCE_USE_RENAME_EXPR_START

void
SgUseRenameExpression::post_construction_initialization()
   { }

SgType*
SgUseRenameExpression::get_type() const
   {
     printf ("In SgUseRenameExpression::get_type(): Not clear what this type should be. \n");
     ROSE_ASSERT(false);

     return NULL;
   }

#if 0
// DQ (3/20/2007): This is an older function now depricated.
int
SgUseRenameExpression::replace_expression($GRAMMAR_PREFIX_Expression *o, $GRAMMAR_PREFIX_Expression *n)
   {
     if(get_newname()==o)
        {
          set_newname(n);
          return 1;
        }
       else
          if(get_oldname()==o)
             {
               set_oldname(n);
               return 1;
             }
            else
               return 0;
   }
#endif

SOURCE_USE_RENAME_EXPR_END


SOURCE_IO_ITEM_EXPR_START

void
SgIOItemExpression::post_construction_initialization()
   { }

SgType*
SgIOItemExpression::get_type() const
   {
     printf ("In SgIOItemExpression::get_type(): Not clear what this type should be. \n");
     ROSE_ASSERT(false);

     return NULL;
   }

#if 0
// DQ (3/20/2007): This is an older function now depricated.
int
SgIOItemExpression::replace_expression($GRAMMAR_PREFIX_Expression* o, $GRAMMAR_PREFIX_Expression* n)
   {
     if(get_io_item()==o)
        {
          set_io_item(n);
          return 1;
        }
       else
          return 0;
   }
#endif

SOURCE_IO_ITEM_EXPR_END


SOURCE_IMPLIED_DO_START

void
SgImpliedDo::post_construction_initialization()
   { }

SgType*
SgImpliedDo::get_type() const
   {
  // printf ("In SgImpliedDo::get_type(): Not clear what this type should be (returning SgTypeDefault). \n");
  // ROSE_ASSERT(false);
  // return NULL;

#if 1
     printf ("In SgImpliedDo::get_type() \n");
#endif

     return SgTypeDefault::createType();
   }

#if 0
// DQ (3/20/2007): This is an older function now depricated.
int
SgImpliedDo::replace_expression($GRAMMAR_PREFIX_Expression* o, $GRAMMAR_PREFIX_Expression* n)
   {
     if(get_object_list()==o)
        {
          set_object_list(is$GRAMMAR_PREFIX_ExprListExp(n));
          return 1;
        }
       else
          return 0;
   }
#endif

SOURCE_IMPLIED_DO_END


SOURCE_UNKNOWN_ARRAY_OR_FUNCTION_REFERENCE_START

void
SgUnknownArrayOrFunctionReference::post_construction_initialization()
   { }

SgType*
SgUnknownArrayOrFunctionReference::get_type() const
   {
     printf ("In SgUnknownArrayOrFunctionReference::get_type(): Not clear what this type should be (returning SgTypeDefault). \n");
  // ROSE_ASSERT(false);
  // return NULL;
     return SgTypeDefault::createType();
   }

SOURCE_UNKNOWN_ARRAY_OR_FUNCTION_REFERENCE_END


SOURCE_ACTUAL_ARGUMENT_EXPRESSION_START

void
SgActualArgumentExpression::post_construction_initialization()
   {
     ROSE_ASSERT(p_expression != NULL);
     p_expression->set_parent(this);
   }

SgType*
SgActualArgumentExpression::get_type() const
   {
     ROSE_ASSERT(p_expression != NULL);

#if 0
     printf ("In SgActualArgumentExpression::get_type() \n");
#endif

     return p_expression->get_type();
   }

SOURCE_ACTUAL_ARGUMENT_EXPRESSION_END

SOURCE_DESIGNATED_INITIALIZER_START

void
SgDesignatedInitializer::post_construction_initialization()
   {
  // This should be a list of designators to handle the case of multi-deminsional array references.
     ROSE_ASSERT(p_designatorList != NULL);
     p_designatorList->set_parent(this);
  // ROSE_ASSERT(p_designator != NULL);
  // p_designator->set_parent(this);

     if (p_memberInit != NULL) // We want to support NULL p_memberInit when building this node
        {
          p_memberInit->set_parent(this);
        }
   }

SgType*
SgDesignatedInitializer::get_type() const
   {
     ROSE_ASSERT(p_memberInit != NULL);

#if 0
     printf ("In SgDesignatedInitializer::get_type() \n");
#endif

     return p_memberInit->get_type();
   }

int
SgDesignatedInitializer::replace_expression(SgExpression *o, SgExpression *n)
   {
  // DQ (12/17/2006): This function should have the semantics that it will represent a
  // structural change to the AST, thus it is free to set the parent of the new expression.

     ROSE_ASSERT(o != NULL);
     ROSE_ASSERT(n != NULL);

     if (get_memberInit() == o)
        {
          ROSE_ASSERT (isSgInitializer(n));
          set_memberInit(isSgInitializer(n));
          n->set_parent(this);

       // Return 1 to indicate sucess.
          return 1;
        }
       else if (get_designatorList() == o)
        {
          ROSE_ASSERT (isSgExprListExp(n));
          set_designatorList(isSgExprListExp(n));
       // set_designator(n);
          n->set_parent(this);

       // Return 1 to indicate sucess.
          return 1;
        }
       else
        {
       // Return 0 to indicate failure to match original expression ("o").
          return 0;
        }
   }

SgExpression*
SgDesignatedInitializer::get_next(int& n) const
   {
  // DQ (7/21/2013): This function should not be called and should be removed at some point.

     printf ("This function should not be called and should be removed at some point \n");
     ROSE_ASSERT(false);

  // tps (12/9/2009) : MSC requires a return value
     return NULL;
   }

SOURCE_DESIGNATED_INITIALIZER_END


SOURCE_UPC_LOCAL_SIZEOF_EXPRESSION_START
void
SgUpcLocalsizeofExpression::post_construction_initialization()
   {
   }

// DQ (2/12/2011): Copied this version from SgSizeOfOp::get_type().
SgType*
$CLASSNAME::get_type() const
   {
  // This function returns an unsigned integer representing the size of type
  // (the unsigned int should match size_t, which may or may not be defined).

     ROSE_ASSERT(p_expression != NULL || p_operand_type != NULL);

#if 0
     printf ("In $CLASSNAME::get_type() \n");
#endif

     SgType* returnType = SgTypeUnsignedInt::createType();

     ROSE_ASSERT(returnType != NULL);
     return returnType;
   }

#if 0
SgType*
$CLASSNAME::get_type() const
   {
     SgType* returnType = get_expression()->get_type();
     ROSE_ASSERT(returnType != NULL);
     return returnType;
   }
#endif

SOURCE_UPC_LOCAL_SIZEOF_EXPRESSION_END


SOURCE_UPC_BLOCK_SIZEOF_EXPRESSION_START
void
SgUpcBlocksizeofExpression::post_construction_initialization()
   {
   }

// DQ (2/12/2011): Copied this version from SgSizeOfOp::get_type().
SgType*
$CLASSNAME::get_type() const
   {
  // This function returns an unsigned integer representing the size of type
  // (the unsigned int should match size_t, which may or may not be defined).

     ROSE_ASSERT(p_expression != NULL || p_operand_type != NULL);

#if 0
     printf ("In $CLASSNAME::get_type() \n");
#endif

     SgType* returnType = SgTypeUnsignedInt::createType();

     ROSE_ASSERT(returnType != NULL);
     return returnType;
   }

#if 0
SgType*
$CLASSNAME::get_type() const
   {
     SgType* returnType = get_expression()->get_type();
     ROSE_ASSERT(returnType != NULL);
     return returnType;
   }
#endif

SOURCE_UPC_BLOCK_SIZEOF_EXPRESSION_END

SOURCE_UPC_ELEM_SIZEOF_EXPRESSION_START
void
SgUpcElemsizeofExpression::post_construction_initialization()
   {
   }

// DQ (2/12/2011): Copied this version from SgSizeOfOp::get_type().
SgType*
$CLASSNAME::get_type() const
   {
  // This function returns an unsigned integer representing the size of type
  // (the unsigned int should match size_t, which may or may not be defined).

     ROSE_ASSERT(p_expression != NULL || p_operand_type != NULL);

#if 0
     printf ("In $CLASSNAME::get_type() \n");
#endif

     SgType* returnType = SgTypeUnsignedInt::createType();

     ROSE_ASSERT(returnType != NULL);
     return returnType;
   }

#if 0
SgType*
$CLASSNAME::get_type() const
   {
     SgType* returnType = get_expression()->get_type();
     ROSE_ASSERT(returnType != NULL);
     return returnType;
   }
#endif

SOURCE_UPC_ELEM_SIZEOF_EXPRESSION_END


SOURCE_USER_DEFINED_UNARY_EXPRESSION_START
SgType*
SgUserDefinedUnaryOp::get_type() const
   {
  // DQ (10/8/2008): Unclear how this should be implemented right now!
     ROSE_ASSERT(get_symbol() != NULL);

#if 1
     printf ("In SgUserDefinedUnaryOp::get_type() \n");
#endif

     SgType* returnType = get_symbol()->get_type();
     ROSE_ASSERT(returnType != NULL);
     return returnType;
   }

SOURCE_USER_DEFINED_UNARY_EXPRESSION_END

SOURCE_USER_DEFINED_BINARY_EXPRESSION_START
SgType*
SgUserDefinedBinaryOp::get_type() const
   {
  // DQ (10/8/2008): Unclear how this should be implemented right now!
     ROSE_ASSERT(get_symbol() != NULL);

#if 1
     printf ("In SgUserDefinedBinaryOp::get_type() \n");
#endif

     SgType* returnType = get_symbol()->get_type();
     ROSE_ASSERT(returnType != NULL);
     return returnType;
   }

SOURCE_USER_DEFINED_BINARY_EXPRESSION_END


// FMZ (2/5/200) Added for CAFCoExpression
SOURCE_CO_EXPRESSION_START

SgType*
SgCAFCoExpression::get_type() const
   {
     SgType* returnType = get_referData()->get_type();

#if 0
     printf ("In SgCAFCoExpression::get_type() \n");
#endif

     ROSE_ASSERT(returnType != NULL);
     return returnType;
   }

SOURCE_CO_EXPRESSION_END

SOURCE_PSEUDO_DESTRUCTOR_REF_START
void
SgPseudoDestructorRefExp::post_construction_initialization()
   {
     SgMemberFunctionType *memFnType = new SgMemberFunctionType(SgTypeVoid::createType(), false, p_object_type);
     set_expression_type(memFnType);
   }


// DQ (1/18/2020): Adding name qualification support to SgPseudoDestructorRefExp.
int
SgPseudoDestructorRefExp::get_name_qualification_length () const
   {
     ROSE_ASSERT (this != NULL);
     return p_name_qualification_length;
   }

// DQ (1/18/2020): Adding name qualification support to SgPseudoDestructorRefExp.
void
SgPseudoDestructorRefExp::set_name_qualification_length ( int name_qualification_length )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_name_qualification_length = name_qualification_length;
   }

// DQ (1/18/2020): Adding name qualification support to SgPseudoDestructorRefExp.
bool
SgPseudoDestructorRefExp::get_type_elaboration_required () const
   {
     ROSE_ASSERT (this != NULL);
     return p_type_elaboration_required;
   }

// DQ (1/18/2020): Adding name qualification support to SgPseudoDestructorRefExp.
void
SgPseudoDestructorRefExp::set_type_elaboration_required ( bool type_elaboration_required )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_type_elaboration_required = type_elaboration_required;
   }

// DQ (1/18/2020): Adding name qualification support to SgPseudoDestructorRefExp.
bool
SgPseudoDestructorRefExp::get_global_qualification_required () const
   {
     ROSE_ASSERT (this != NULL);
     return p_global_qualification_required;
   }

// DQ (1/18/2020): Adding name qualification support to SgPseudoDestructorRefExp.
void
SgPseudoDestructorRefExp::set_global_qualification_required ( bool global_qualification_required )
   {
     ROSE_ASSERT (this != NULL);

  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_global_qualification_required = global_qualification_required;
   }

SOURCE_PSEUDO_DESTRUCTOR_REF_END


SOURCE_LAMBDA_REF_EXP_START

SgType* SgLambdaRefExp::get_type() const
   {
#if 0
     printf ("In SgLambdaRefExp::get_type() \n");
#endif

     return SageBuilder::buildVoidType();
   }

void
SgLambdaRefExp::post_construction_initialization()
   {
   }

SgFunctionParameterList*
SgLambdaRefExp::get_parameterList()
   {
     ROSE_ASSERT(this != NULL);

     SgFunctionDeclaration* func_decl = this->get_functionDeclaration();
     ROSE_ASSERT(func_decl != NULL);

     return func_decl->get_parameterList();
   }

SgStatement*
SgLambdaRefExp::get_body() {
    ROSE_ASSERT(this != NULL);

    SgFunctionDeclaration* func_decl =
        this->get_functionDeclaration();
    ROSE_ASSERT(func_decl != NULL);

    SgFunctionDefinition* func_def =
        func_decl->get_definition();
    ROSE_ASSERT(func_def != NULL);

    return func_def->get_body();
}

SOURCE_LAMBDA_REF_EXP_END

SOURCE_CUDA_KERNEL_EXEC_CONFIG_START
SOURCE_CUDA_KERNEL_EXEC_CONFIG_END

SOURCE_CUDA_KERNEL_CALL_EXPRESSION_START

void
SgCudaKernelCallExp::post_construction_initialization()
   {
     if (p_function != NULL)
          p_function->set_parent(this);

     // TODO : exec_config
   }

SgType*
SgCudaKernelCallExp::get_type() const
   {
#if 0
     printf ("In SgCudaKernelCallExp::get_type() \n");
#endif

     return SgFunctionCallExp::get_type();
   }

SOURCE_CUDA_KERNEL_CALL_EXPRESSION_END


SOURCE_TYPE_EXPRESSION_START
SOURCE_TYPE_EXPRESSION_END

SOURCE_FUNCTION_PARAMETER_REFERENCE_EXPRESSION_START

SgType*
SgFunctionParameterRefExp::get_type() const
   {
  // DQ (8/11/2014): Added support for C++11 decltype used in new function return syntax.

     ROSE_ASSERT(this != NULL);

     SgType* returnType = NULL;

#if 0
     printf ("In SgFunctionParameterRefExp::get_type() \n");
#endif

  // ROSE_ASSERT(p_parameter_expression != NULL);
     if (p_parameter_expression != NULL)
        {
          ROSE_ASSERT(p_parameter_type == NULL);
          returnType = p_parameter_expression->get_type();
          ROSE_ASSERT(returnType != NULL);
        }
       else
        {
          returnType = p_parameter_type;
          ROSE_ASSERT(returnType != NULL);
        }

     ROSE_ASSERT(returnType != NULL);
     return returnType;
   }

SOURCE_FUNCTION_PARAMETER_REFERENCE_EXPRESSION_END

// SIMD Operations
HEADER_SIMD_BINARY_OP_START
HEADER_SIMD_BINARY_OP_END

SOURCE_SIMD_BINARY_OP_START
void SgSIMDBinaryOp::post_construction_initialization() {}
SOURCE_SIMD_BINARY_OP_END


HEADER_SIMD_ADD_OP_START
HEADER_SIMD_ADD_OP_END


HEADER_SIMD_SUB_OP_START
HEADER_SIMD_SUB_OP_END


HEADER_SIMD_MUL_OP_START
HEADER_SIMD_MUL_OP_END


HEADER_SIMD_DIV_OP_START
HEADER_SIMD_DIV_OP_END


HEADER_SIMD_FMA_OP_START
HEADER_SIMD_FMA_OP_END


HEADER_SIMD_LOAD_START
HEADER_SIMD_LOAD_END

SOURCE_SIMD_LOAD_START
void SgSIMDLoad::post_construction_initialization() {}
SOURCE_SIMD_LOAD_END


HEADER_SIMD_BROADCAST_START
HEADER_SIMD_BROADCAST_END

SOURCE_SIMD_BROADCAST_START
void SgSIMDBroadcast::post_construction_initialization() {}
SOURCE_SIMD_BROADCAST_END


HEADER_SIMD_STORE_START
HEADER_SIMD_STORE_END

SOURCE_SIMD_STORE_START
void SgSIMDStore::post_construction_initialization() {}
SOURCE_SIMD_STORE_END


HEADER_SIMD_PARTIAL_STORE_START
HEADER_SIMD_PARTIAL_STORE_END

SOURCE_SIMD_PARTIAL_STORE_START
void SgSIMDPartialStore::post_construction_initialization() {}
SOURCE_SIMD_PARTIAL_STORE_END


HEADER_SIMD_SCALAR_STORE_START
HEADER_SIMD_SCALAR_STORE_END

SOURCE_SIMD_SCALAR_STORE_START
void SgSIMDScalarStore::post_construction_initialization() {}
SOURCE_SIMD_SCALAR_STORE_END


HEADER_SIMD_SVADDV_START
HEADER_SIMD_SVADDV_END

SOURCE_SIMD_SVADDV_START
void SgSIMDSVAddV::post_construction_initialization() {}
SOURCE_SIMD_SVADDV_END


HEADER_SIMD_GATHER_START
HEADER_SIMD_GATHER_END

SOURCE_SIMD_GATHER_START
void SgSIMDGather::post_construction_initialization() {}
SOURCE_SIMD_GATHER_END


HEADER_SIMD_SCATTER_START
HEADER_SIMD_SCATTER_END

SOURCE_SIMD_SCATTER_START
void SgSIMDScatter::post_construction_initialization() {}
SOURCE_SIMD_SCATTER_END

