#include <boost/algorithm/string/predicate.hpp>
#include <boost/lexical_cast.hpp>
#include <string>
#include <vector>

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseSupport/utility_functions.C line 770
namespace stringify {
    const char* language_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_none";
            case 1L: return "e_c";
            case 2L: return "e_cxx";
            case 3L: return "e_fortran";
            case 4L: return "e_last_language";
            default: return "";
        }
    }

    std::string language_enum(int64_t i, const std::string &strip) {
        std::string s = language_enum(i);
        if (s.empty())
            s = "(language_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& language_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringify_language_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::language_enum(i);
        if (retval.empty()) {
            retval = "(language_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "language_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_language_enum() {
        return stringify::language_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseSupport/transformationSupport.h line 37
namespace stringify { namespace TransformationSupport {
    const char* operatorCodeType(int64_t i) {
        switch (i) {
            case 0L: return "FUNCTION_CALL_OPERATOR_CODE";
            case 1L: return "ADD_OPERATOR_CODE";
            case 2L: return "SUBT_OPERATOR_CODE";
            case 3L: return "MULT_OPERATOR_CODE";
            case 4L: return "DIV_OPERATOR_CODE";
            case 5L: return "INTEGER_DIV_OPERATOR_CODE";
            case 6L: return "MOD_OPERATOR_CODE";
            case 7L: return "AND_OPERATOR_CODE";
            case 8L: return "OR_OPERATOR_CODE";
            case 9L: return "BITXOR_OPERATOR_CODE";
            case 10L: return "BITAND_OPERATOR_CODE";
            case 11L: return "BITOR_OPERATOR_CODE";
            case 12L: return "EQ_OPERATOR_CODE";
            case 13L: return "LT_OPERATOR_CODE";
            case 14L: return "GT_OPERATOR_CODE";
            case 15L: return "NE_OPERATOR_CODE";
            case 16L: return "LE_OPERATOR_CODE";
            case 17L: return "GE_OPERATOR_CODE";
            case 18L: return "ASSIGN_OPERATOR_CODE";
            case 19L: return "PLUS_ASSIGN_OPERATOR_CODE";
            case 20L: return "MINUS_ASSIGN_OPERATOR_CODE";
            case 21L: return "AND_ASSIGN_OPERATOR_CODE";
            case 22L: return "IOR_ASSIGN_OPERATOR_CODE";
            case 23L: return "MULT_ASSIGN_OPERATOR_CODE";
            case 24L: return "DIV_ASSIGN_OPERATOR_CODE";
            case 25L: return "MOD_ASSIGN_OPERATOR_CODE";
            case 26L: return "XOR_ASSIGN_OPERATOR_CODE";
            case 27L: return "PARENTHESIS_OPERATOR_CODE";
            case 28L: return "BRACKET_OPERATOR_CODE";
            case 29L: return "NOT_OPERATOR_CODE";
            case 30L: return "DEREFERENCE_OPERATOR_CODE";
            case 31L: return "ADDRESS_OPERATOR_CODE";
            case 32L: return "LSHIFT_OPERATOR_CODE";
            case 33L: return "RSHIFT_OPERATOR_CODE";
            case 34L: return "LSHIFT_ASSIGN_OPERATOR_CODE";
            case 35L: return "RSHIFT_ASSIGN_OPERATOR_CODE";
            case 36L: return "PREFIX_PLUSPLUS_OPERATOR_CODE";
            case 37L: return "POSTFIX_PLUSPLUS_OPERATOR_CODE";
            case 38L: return "PREFIX_MINUSMINUS_OPERATOR_CODE";
            case 39L: return "POSTFIX_MINUSMINUS_OPERATOR_CODE";
            case 99L: return "OPERATOR_CODE_LAST_TAG";
            default: return "";
        }
    }

    std::string operatorCodeType(int64_t i, const std::string &strip) {
        std::string s = operatorCodeType(i);
        if (s.empty())
            s = "(TransformationSupport::operatorCodeType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& operatorCodeType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            99L
        };
        static const std::vector<int64_t> retval(values, values + 41);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyTransformationSupport_operatorCodeType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::TransformationSupport::operatorCodeType(i);
        if (retval.empty()) {
            retval = "(TransformationSupport::operatorCodeType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "TransformationSupport::operatorCodeType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyTransformationSupport_operatorCodeType() {
        return stringify::TransformationSupport::operatorCodeType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseSupport/SqlDatabase.h line 121
namespace stringify { namespace SqlDatabase {
    const char* Driver(int64_t i) {
        switch (i) {
            case 0L: return "NO_DRIVER";
            case 1L: return "SQLITE3";
            case 2L: return "POSTGRESQL";
            default: return "";
        }
    }

    std::string Driver(int64_t i, const std::string &strip) {
        std::string s = Driver(i);
        if (s.empty())
            s = "(SqlDatabase::Driver)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Driver() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySqlDatabaseDriver(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SqlDatabase::Driver(i);
        if (retval.empty()) {
            retval = "(SqlDatabase::Driver)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SqlDatabase::Driver::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySqlDatabaseDriver() {
        return stringify::SqlDatabase::Driver();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseSupport/callbacks.h line 14
namespace stringify { namespace Rose { namespace Callbacks {
    const char* Direction(int64_t i) {
        switch (i) {
            case 0L: return "FORWARD";
            case 1L: return "BACKWARD";
            default: return "";
        }
    }

    std::string Direction(int64_t i, const std::string &strip) {
        std::string s = Direction(i);
        if (s.empty())
            s = "(Rose::Callbacks::Direction)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Direction() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyCallbacksDirection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::Callbacks::Direction(i);
        if (retval.empty()) {
            retval = "(Rose::Callbacks::Direction)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::Callbacks::Direction::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyCallbacksDirection() {
        return stringify::Rose::Callbacks::Direction();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseSupport/CommandLine.C line 17
namespace stringify { namespace Rose { namespace CommandLine { namespace FailedAssertionBehaviorAdjuster {
    const char* Behavior(int64_t i) {
        switch (i) {
            case 0L: return "ABORT_ON_FAILURE";
            case 1L: return "EXIT_ON_FAILURE";
            case 2L: return "THROW_ON_FAILURE";
            default: return "";
        }
    }

    std::string Behavior(int64_t i, const std::string &strip) {
        std::string s = Behavior(i);
        if (s.empty())
            s = "(Rose::CommandLine::FailedAssertionBehaviorAdjuster::Behavior)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Behavior() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyCommandLineFailedAssertionBehaviorAdjusterBehavior(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::CommandLine::FailedAssertionBehaviorAdjuster::Behavior(i);
        if (retval.empty()) {
            retval = "(Rose::CommandLine::FailedAssertionBehaviorAdjuster::Behavior)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::CommandLine::FailedAssertionBehaviorAdjuster::Behavior::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyCommandLineFailedAssertionBehaviorAdjusterBehavior() {
        return stringify::Rose::CommandLine::FailedAssertionBehaviorAdjuster::Behavior();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/edgRose/debugging.C line 266
namespace stringify {
    const char* an_init_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "initk_none";
            case 1L: return "initk_static";
            case 2L: return "initk_dynamic";
            case 3L: return "initk_zero";
            case 4L: return "initk_function_local";
            default: return "";
        }
    }

    std::string an_init_kind_tag(int64_t i, const std::string &strip) {
        std::string s = an_init_kind_tag(i);
        if (s.empty())
            s = "(an_init_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_init_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_init_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_init_kind_tag(i);
        if (retval.empty()) {
            retval = "(an_init_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_init_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_init_kind_tag() {
        return stringify::an_init_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/edgRose/debugging.C line 1182
namespace stringify {
    const char* a_decl_modifier_tag(int64_t i) {
        switch (i) {
            case 0L: return "dmt_dllimport";
            case 1L: return "dmt_dllexport";
            case 2L: return "dmt_thread";
            case 3L: return "dmt_microsoft_inline";
            case 4L: return "dmt_forceinline";
            case 5L: return "dmt_selectany";
            case 6L: return "dmt_novtable";
            case 7L: return "dmt_noalias";
            case 8L: return "dmt_restrict";
            case 9L: return "dmt_safebuffers";
            case 10L: return "dmt_global_link_scope";
            case 11L: return "dmt_symbolic_link_scope";
            case 12L: return "dmt_hidden_link_scope";
            case 13L: return "dmt_host";
            case 14L: return "dmt_global";
            case 15L: return "dmt_device";
            case 16L: return "dmt_shared";
            case 17L: return "dmt_local";
            case 18L: return "dmt_constant";
            case 19L: return "dmt_last";
            default: return "";
        }
    }

    std::string a_decl_modifier_tag(int64_t i, const std::string &strip) {
        std::string s = a_decl_modifier_tag(i);
        if (s.empty())
            s = "(a_decl_modifier_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_decl_modifier_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L
        };
        static const std::vector<int64_t> retval(values, values + 20);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_decl_modifier_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_decl_modifier_tag(i);
        if (retval.empty()) {
            retval = "(a_decl_modifier_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_decl_modifier_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_decl_modifier_tag() {
        return stringify::a_decl_modifier_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/edgRose/debugging.C line 7715
namespace stringify {
    const char* a_local_expr_node_ref_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "lerk_none";
            case 1L: return "lerk_typeof";
            case 2L: return "lerk_generic_sizeof";
            case 3L: return "lerk_array_bound";
            case 4L: return "lerk_dep_array_bound";
            case 5L: return "lerk_decltype";
            default: return "";
        }
    }

    std::string a_local_expr_node_ref_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_local_expr_node_ref_kind_tag(i);
        if (s.empty())
            s = "(a_local_expr_node_ref_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_local_expr_node_ref_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_local_expr_node_ref_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_local_expr_node_ref_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_local_expr_node_ref_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_local_expr_node_ref_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_local_expr_node_ref_kind_tag() {
        return stringify::a_local_expr_node_ref_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/edgRose/debugging.C line 10918
namespace stringify {
    const char* an_operand_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "ok_error";
            case 1L: return "ok_expression";
            case 2L: return "ok_constant";
            case 3L: return "ok_indefinite_function";
            case 4L: return "ok_sym_for_member";
            case 5L: return "ok_property_ref";
            case 6L: return "ok_undefined_symbol";
            default: return "";
        }
    }

    std::string an_operand_kind_tag(int64_t i, const std::string &strip) {
        std::string s = an_operand_kind_tag(i);
        if (s.empty())
            s = "(an_operand_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_operand_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_operand_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_operand_kind_tag(i);
        if (retval.empty()) {
            retval = "(an_operand_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_operand_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_operand_kind_tag() {
        return stringify::an_operand_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/edgRose/debugging.C line 12861
namespace stringify {
    const char* a_pragma_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "pk_none";
            case 1L: return "pk_printf_args";
            case 2L: return "pk_scanf_args";
            case 3L: return "pk_lint_argsused";
            case 4L: return "pk_lint_varargs_count";
            case 5L: return "pk_lint_notreached";
            case 6L: return "pk_instantiate";
            case 7L: return "pk_do_not_instantiate";
            case 8L: return "pk_can_instantiate";
            case 9L: return "pk_inline_template";
            case 10L: return "pk_pack";
            case 11L: return "pk_ident";
            case 12L: return "pk_weak";
            case 13L: return "pk_once";
            case 14L: return "pk_hdrstop";
            case 15L: return "pk_no_pch";
            case 16L: return "pk_define_type_info";
            case 17L: return "pk_stdc";
            case 18L: return "pk_upc";
            case 19L: return "pk_redefine_extname";
            case 20L: return "pk_enable_ldscope";
            case 21L: return "pk_disable_ldscope";
            case 22L: return "pk_gcc";
            case 23L: return "pk_diag_suppress";
            case 24L: return "pk_diag_remark";
            case 25L: return "pk_diag_warning";
            case 26L: return "pk_diag_error";
            case 27L: return "pk_diag_once";
            case 28L: return "pk_diag_default";
            case 29L: return "pk_test_next_statement";
            case 30L: return "pk_test_next_decl";
            case 31L: return "pk_test_immediate";
            case 32L: return "pk_test_immediate_text";
            case 33L: return "pk_test_immediate_pp_text";
            case 34L: return "pk_test_other";
            case 35L: return "pk_test_bind_next_pass";
            case 36L: return "pk_checking_pragma";
            case 37L: return "pk_db_opt";
            case 38L: return "pk_db_name";
            case 39L: return "pk_if_exists";
            case 40L: return "pk_push_macro";
            case 41L: return "pk_pop_macro";
            case 42L: return "pk_start_map_region";
            case 43L: return "pk_stop_map_region";
            case 44L: return "pk_setlocale";
            case 45L: return "pk_comment";
            case 46L: return "pk_conform";
            case 47L: return "pk_include_alias";
            case 48L: return "pk_unrecognized";
            case 49L: return "pk_last";
            default: return "";
        }
    }

    std::string a_pragma_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_pragma_kind_tag(i);
        if (s.empty())
            s = "(a_pragma_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_pragma_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L
        };
        static const std::vector<int64_t> retval(values, values + 50);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_pragma_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_pragma_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_pragma_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_pragma_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_pragma_kind_tag() {
        return stringify::a_pragma_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/edgRose/debugging.C line 13903
namespace stringify {
    const char* a_name_linkage_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "nlk_none";
            case 1L: return "nlk_internal";
            case 2L: return "nlk_cplusplus_external";
            case 3L: return "nlk_last_standard";
            default: return "";
        }
    }

    std::string a_name_linkage_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_name_linkage_kind_tag(i);
        if (s.empty())
            s = "(a_name_linkage_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_name_linkage_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_name_linkage_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_name_linkage_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_name_linkage_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_name_linkage_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_name_linkage_kind_tag() {
        return stringify::a_name_linkage_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/edgRose/edgRose.C line 6372
namespace stringify {
    const char* kinds_of_type_references(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown_type_reference";
            case 1L: return "e_modifier_type_reference";
            case 2L: return "e_typeof_type_reference";
            case 3L: return "e_decltype_type_reference";
            case 4L: return "e_template_alias_type_reference";
            case 5L: return "e_last_type_reference";
            default: return "";
        }
    }

    std::string kinds_of_type_references(int64_t i, const std::string &strip) {
        std::string s = kinds_of_type_references(i);
        if (s.empty())
            s = "(kinds_of_type_references)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& kinds_of_type_references() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}

namespace Rose {
    std::string stringify_kinds_of_type_references(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::kinds_of_type_references(i);
        if (retval.empty()) {
            retval = "(kinds_of_type_references)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "kinds_of_type_references::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_kinds_of_type_references() {
        return stringify::kinds_of_type_references();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/edgRose/edgRose.C line 46795
namespace stringify {
    const char* a_special_function_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "sfk_none";
            case 1L: return "sfk_constructor";
            case 2L: return "sfk_destructor";
            case 3L: return "sfk_conversion";
            case 4L: return "sfk_udl_operator";
            case 5L: return "sfk_operator";
            case 6L: return "sfk_lambda_entry_point";
            case 7L: return "sfk_static_constructor";
            case 8L: return "sfk_finalizer";
            case 9L: return "sfk_idisposable_dispose";
            case 10L: return "sfk_dispose_bool";
            case 11L: return "sfk_object_finalize";
            case 12L: return "sfk_property_get";
            case 13L: return "sfk_property_set";
            case 14L: return "sfk_event_add";
            case 15L: return "sfk_event_remove";
            case 16L: return "sfk_last_accessor";
            case 17L: return "sfk_gnu_sync_concrete_function";
            case 18L: return "sfk_gnu_atomic_nongeneric_function";
            case 19L: return "sfk_last";
            default: return "";
        }
    }

    std::string a_special_function_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_special_function_kind_tag(i);
        if (s.empty())
            s = "(a_special_function_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_special_function_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L
        };
        static const std::vector<int64_t> retval(values, values + 20);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_special_function_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_special_function_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_special_function_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_special_function_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_special_function_kind_tag() {
        return stringify::a_special_function_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/lib_src/rtti.c line 120
namespace stringify {
    const char* a_result_virtuality(int64_t i) {
        switch (i) {
            case 0L: return "rv_unknown";
            case 1L: return "rv_nonvirtual";
            case 2L: return "rv_directvirtual";
            default: return "";
        }
    }

    std::string a_result_virtuality(int64_t i, const std::string &strip) {
        std::string s = a_result_virtuality(i);
        if (s.empty())
            s = "(a_result_virtuality)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_result_virtuality() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_result_virtuality(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_result_virtuality(i);
        if (retval.empty()) {
            retval = "(a_result_virtuality)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_result_virtuality::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_result_virtuality() {
        return stringify::a_result_virtuality();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/lib_src/eh.h line 348
namespace stringify {
    const char* an_eh_stack_entry_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "ehsek_old_try_block";
            case 1L: return "ehsek_function";
            case 2L: return "ehsek_throw_spec";
            case 3L: return "ehsek_throw_processing_marker";
            case 4L: return "ehsek_vec_new_or_delete";
            case 5L: return "ehsek_try_block";
            case 6L: return "ehsek_noexcept";
            default: return "";
        }
    }

    std::string an_eh_stack_entry_kind_tag(int64_t i, const std::string &strip) {
        std::string s = an_eh_stack_entry_kind_tag(i);
        if (s.empty())
            s = "(an_eh_stack_entry_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_eh_stack_entry_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_eh_stack_entry_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_eh_stack_entry_kind_tag(i);
        if (retval.empty()) {
            retval = "(an_eh_stack_entry_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_eh_stack_entry_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_eh_stack_entry_kind_tag() {
        return stringify::an_eh_stack_entry_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/pragma.h line 52
namespace stringify {
    const char* a_pragma_binding_kind(int64_t i) {
        switch (i) {
            case 0L: return "pbk_none";
            case 1L: return "pbk_next_construct";
            case 2L: return "pbk_next_token";
            case 3L: return "pbk_immediate";
            case 4L: return "pbk_other";
            case 5L: return "pbk_preproc_immediate";
            case 6L: return "pbk_last";
            default: return "";
        }
    }

    std::string a_pragma_binding_kind(int64_t i, const std::string &strip) {
        std::string s = a_pragma_binding_kind(i);
        if (s.empty())
            s = "(a_pragma_binding_kind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_pragma_binding_kind() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_pragma_binding_kind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_pragma_binding_kind(i);
        if (retval.empty()) {
            retval = "(a_pragma_binding_kind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_pragma_binding_kind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_pragma_binding_kind() {
        return stringify::a_pragma_binding_kind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/lower_il.h line 424
namespace stringify {
    const char* an_insert_location_kind(int64_t i) {
        switch (i) {
            case 0L: return "ilk_after_statement";
            case 1L: return "ilk_block_start";
            case 2L: return "ilk_statement_creation";
            case 3L: return "ilk_before_expr";
            case 4L: return "ilk_after_expr";
            case 5L: return "ilk_expr_creation";
            default: return "";
        }
    }

    std::string an_insert_location_kind(int64_t i, const std::string &strip) {
        std::string s = an_insert_location_kind(i);
        if (s.empty())
            s = "(an_insert_location_kind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_insert_location_kind() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_insert_location_kind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_insert_location_kind(i);
        if (retval.empty()) {
            retval = "(an_insert_location_kind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_insert_location_kind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_insert_location_kind() {
        return stringify::an_insert_location_kind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/ms_metadata.cpp line 1032
namespace stringify { namespace a_type_wrapper {
    const char* a_kind(int64_t i) {
        switch (i) {
            case 0L: return "twk_invalid";
            case 1L: return "twk_void";
            case 2L: return "twk_cxx_udt_return";
            case 3L: return "twk_copy_ctor";
            case 4L: return "twk_bool";
            case 5L: return "twk_char";
            case 6L: return "twk_signed_char";
            case 7L: return "twk_unsigned_char";
            case 8L: return "twk_short";
            case 9L: return "twk_unsigned_short";
            case 10L: return "twk_wchar_t";
            case 11L: return "twk_int";
            case 12L: return "twk_unsigned_int";
            case 13L: return "twk_long";
            case 14L: return "twk_unsigned_long";
            case 15L: return "twk_long_long";
            case 16L: return "twk_unsigned_long_long";
            case 17L: return "twk_float";
            case 18L: return "twk_double";
            case 19L: return "twk_long_double";
            case 20L: return "twk_class";
            case 21L: return "twk_array";
            case 22L: return "twk_indirection";
            case 23L: return "twk_function";
            default: return "";
        }
    }

    std::string a_kind(int64_t i, const std::string &strip) {
        std::string s = a_kind(i);
        if (s.empty())
            s = "(a_type_wrapper::a_kind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_kind() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L
        };
        static const std::vector<int64_t> retval(values, values + 24);
        return retval;
    }

}}

namespace Rose {
    std::string stringify_a_type_wrapper_a_kind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_type_wrapper::a_kind(i);
        if (retval.empty()) {
            retval = "(a_type_wrapper::a_kind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_type_wrapper::a_kind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_type_wrapper_a_kind() {
        return stringify::a_type_wrapper::a_kind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/ms_metadata.cpp line 1293
namespace stringify { namespace a_class_type_wrapper {
    const char* a_class_kind(int64_t i) {
        switch (i) {
            case 0L: return "ck_invalid";
            case 1L: return "ck_unresolved";
            case 2L: return "ck_class";
            case 3L: return "ck_generic_parameter";
            default: return "";
        }
    }

    std::string a_class_kind(int64_t i, const std::string &strip) {
        std::string s = a_class_kind(i);
        if (s.empty())
            s = "(a_class_type_wrapper::a_class_kind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_class_kind() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringify_a_class_type_wrapper_a_class_kind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_class_type_wrapper::a_class_kind(i);
        if (retval.empty()) {
            retval = "(a_class_type_wrapper::a_class_kind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_class_type_wrapper::a_class_kind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_class_type_wrapper_a_class_kind() {
        return stringify::a_class_type_wrapper::a_class_kind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/ms_metadata.cpp line 1414
namespace stringify { namespace a_type_indirection {
    const char* an_indirection_kind(int64_t i) {
        switch (i) {
            case 0L: return "tik_invalid";
            case 1L: return "tik_pointer";
            case 2L: return "tik_interior_pointer";
            case 3L: return "tik_handle";
            case 4L: return "tik_reference";
            case 5L: return "tik_rvalue_reference";
            case 6L: return "tik_tracking_reference";
            case 7L: return "tik_tentative_byref";
            default: return "";
        }
    }

    std::string an_indirection_kind(int64_t i, const std::string &strip) {
        std::string s = an_indirection_kind(i);
        if (s.empty())
            s = "(a_type_indirection::an_indirection_kind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_indirection_kind() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}}

namespace Rose {
    std::string stringify_a_type_indirection_an_indirection_kind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_type_indirection::an_indirection_kind(i);
        if (retval.empty()) {
            retval = "(a_type_indirection::an_indirection_kind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_type_indirection::an_indirection_kind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_type_indirection_an_indirection_kind() {
        return stringify::a_type_indirection::an_indirection_kind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/ms_metadata.cpp line 1566
namespace stringify { namespace an_array_type_wrapper {
    const char* an_array_kind(int64_t i) {
        switch (i) {
            case 0L: return "ak_invalid";
            case 1L: return "ak_array";
            case 2L: return "ak_param_array";
            case 3L: return "ak_write_only_array";
            default: return "";
        }
    }

    std::string an_array_kind(int64_t i, const std::string &strip) {
        std::string s = an_array_kind(i);
        if (s.empty())
            s = "(an_array_type_wrapper::an_array_kind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_array_kind() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringify_an_array_type_wrapper_an_array_kind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_array_type_wrapper::an_array_kind(i);
        if (retval.empty()) {
            retval = "(an_array_type_wrapper::an_array_kind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_array_type_wrapper::an_array_kind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_array_type_wrapper_an_array_kind() {
        return stringify::an_array_type_wrapper::an_array_kind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/ms_metadata.cpp line 3807
namespace stringify { namespace an_accessibility {
    const char* access_kind(int64_t i) {
        switch (i) {
            case 0L: return "access_unknown";
            case 1L: return "access_none";
            case 2L: return "access_private";
            case 3L: return "access_imported_private";
            case 4L: return "access_private_as_friend";
            case 5L: return "access_family_and_assembly";
            case 6L: return "access_imported_family_and_assembly";
            case 7L: return "access_family_and_assembly_as_friend";
            case 8L: return "access_assembly";
            case 9L: return "access_imported_assembly";
            case 10L: return "access_assembly_as_friend";
            case 11L: return "access_family";
            case 12L: return "access_family_or_assembly";
            case 13L: return "access_family_or_assembly_as_friend";
            case 14L: return "access_public";
            default: return "";
        }
    }

    std::string access_kind(int64_t i, const std::string &strip) {
        std::string s = access_kind(i);
        if (s.empty())
            s = "(an_accessibility::access_kind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& access_kind() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L
        };
        static const std::vector<int64_t> retval(values, values + 15);
        return retval;
    }

}}

namespace Rose {
    std::string stringify_an_accessibility_access_kind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_accessibility::access_kind(i);
        if (retval.empty()) {
            retval = "(an_accessibility::access_kind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_accessibility::access_kind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_accessibility_access_kind() {
        return stringify::an_accessibility::access_kind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/ms_metadata.cpp line 3846
namespace stringify { namespace a_type_definition {
    const char* a_type_definition_kind(int64_t i) {
        switch (i) {
            case 0L: return "tdk_unknown";
            case 1L: return "tdk_ref_class";
            case 2L: return "tdk_interface_class";
            case 3L: return "tdk_value_class";
            case 4L: return "tdk_enum_class";
            case 5L: return "tdk_delegate";
            case 6L: return "tdk_native_class";
            case 7L: return "tdk_native_enum";
            default: return "";
        }
    }

    std::string a_type_definition_kind(int64_t i, const std::string &strip) {
        std::string s = a_type_definition_kind(i);
        if (s.empty())
            s = "(a_type_definition::a_type_definition_kind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_type_definition_kind() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}}

namespace Rose {
    std::string stringify_a_type_definition_a_type_definition_kind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_type_definition::a_type_definition_kind(i);
        if (retval.empty()) {
            retval = "(a_type_definition::a_type_definition_kind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_type_definition::a_type_definition_kind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_type_definition_a_type_definition_kind() {
        return stringify::a_type_definition::a_type_definition_kind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/ms_metadata.h line 22
namespace stringify {
    const char* a_cpp_cli_import_flag_tag(int64_t i) {
        switch (i) {
            case 0L: return "cpp_cli_none";
            case 1L: return "cpp_cli_as_friend_assembly";
            case 2L: return "cpp_cli_declspec_assembly_info";
            case 4L: return "cpp_cli_declspec_member_info";
            case 8L: return "cpp_cli_define_all_types";
            case 16L: return "cpp_cli_wchar_t_is_keyword";
            case 32L: return "cpp_cli_ide_custom_attributes";
            case 64L: return "cpp_cli_all_custom_attributes";
            default: return "";
        }
    }

    std::string a_cpp_cli_import_flag_tag(int64_t i, const std::string &strip) {
        std::string s = a_cpp_cli_import_flag_tag(i);
        if (s.empty())
            s = "(a_cpp_cli_import_flag_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_cpp_cli_import_flag_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            4L,
            8L,
            16L,
            32L,
            64L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_cpp_cli_import_flag_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_cpp_cli_import_flag_tag(i);
        if (retval.empty()) {
            retval = "(a_cpp_cli_import_flag_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_cpp_cli_import_flag_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_cpp_cli_import_flag_tag() {
        return stringify::a_cpp_cli_import_flag_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/expr.h line 93
namespace stringify {
    const char* an_init_component_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "ick_expression";
            case 1L: return "ick_braced";
            case 2L: return "ick_designator";
            case 3L: return "ick_continued";
            default: return "";
        }
    }

    std::string an_init_component_kind_tag(int64_t i, const std::string &strip) {
        std::string s = an_init_component_kind_tag(i);
        if (s.empty())
            s = "(an_init_component_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_init_component_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_init_component_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_init_component_kind_tag(i);
        if (retval.empty()) {
            retval = "(an_init_component_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_init_component_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_init_component_kind_tag() {
        return stringify::an_init_component_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/interpret.h line 59
namespace stringify {
    const char* a_constexpr_intrinsic_tag(int64_t i) {
        switch (i) {
            case 0L: return "cit_error";
            case 1L: return "cit_std_is_constant_evaluated";
            case 2L: return "cit_std_allocator_allocate";
            case 3L: return "cit_std_allocator_deallocate";
            case 4L: return "cit_std_construct_at";
            case 5L: return "cit_std_destroy_at";
            case 6L: return "cit_std_report_constexpr_value";
            case 7L: return "cit_last";
            default: return "";
        }
    }

    std::string a_constexpr_intrinsic_tag(int64_t i, const std::string &strip) {
        std::string s = a_constexpr_intrinsic_tag(i);
        if (s.empty())
            s = "(a_constexpr_intrinsic_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_constexpr_intrinsic_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_constexpr_intrinsic_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_constexpr_intrinsic_tag(i);
        if (retval.empty()) {
            retval = "(a_constexpr_intrinsic_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_constexpr_intrinsic_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_constexpr_intrinsic_tag() {
        return stringify::a_constexpr_intrinsic_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/statements.h line 56
namespace stringify {
    const char* a_control_flow_descr_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "cfdk_block";
            case 1L: return "cfdk_init";
            case 2L: return "cfdk_goto";
            case 3L: return "cfdk_label";
            case 4L: return "cfdk_case_label";
            case 5L: return "cfdk_end_of_block";
            default: return "";
        }
    }

    std::string a_control_flow_descr_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_control_flow_descr_kind_tag(i);
        if (s.empty())
            s = "(a_control_flow_descr_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_control_flow_descr_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_control_flow_descr_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_control_flow_descr_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_control_flow_descr_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_control_flow_descr_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_control_flow_descr_kind_tag() {
        return stringify::a_control_flow_descr_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/exprutil.h line 106
namespace stringify {
    const char* an_expression_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "ek_pp";
            case 1L: return "ek_integral_constant";
            case 2L: return "ek_template_arg";
            case 3L: return "ek_init_constant";
            case 4L: return "ek_normal";
            case 5L: return "ek_sizeof";
            default: return "";
        }
    }

    std::string an_expression_kind_tag(int64_t i, const std::string &strip) {
        std::string s = an_expression_kind_tag(i);
        if (s.empty())
            s = "(an_expression_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_expression_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_expression_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_expression_kind_tag(i);
        if (retval.empty()) {
            retval = "(an_expression_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_expression_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_expression_kind_tag() {
        return stringify::an_expression_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/exprutil.h line 143
namespace stringify {
    const char* a_cast_source_form(int64_t i) {
        switch (i) {
            case 0L: return "csf_none";
            case 1L: return "csf_old_style";
            case 2L: return "csf_functional";
            case 3L: return "csf_static_cast";
            case 4L: return "csf_const_cast";
            case 5L: return "csf_reinterpret_cast";
            case 6L: return "csf_safe_cast";
            case 7L: return "csf_dynamic_cast";
            default: return "";
        }
    }

    std::string a_cast_source_form(int64_t i, const std::string &strip) {
        std::string s = a_cast_source_form(i);
        if (s.empty())
            s = "(a_cast_source_form)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_cast_source_form() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_cast_source_form(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_cast_source_form(i);
        if (retval.empty()) {
            retval = "(a_cast_source_form)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_cast_source_form::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_cast_source_form() {
        return stringify::a_cast_source_form();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/exprutil.h line 162
namespace stringify {
    const char* an_overload_context(int64_t i) {
        switch (i) {
            case 0L: return "oc_default";
            case 1L: return "oc_constructor";
            case 2L: return "oc_new_expression";
            case 3L: return "oc_range_based_for_bounds";
            case 4L: return "oc_for_each_bounds";
            case 5L: return "oc_cppcx_for_each_bounds";
            case 6L: return "oc_property_access";
            case 7L: return "oc_event_access";
            case 8L: return "oc_synthesized_member_call";
            case 9L: return "oc_ctad";
            case 10L: return "oc_tuple_like_binding";
            case 11L: return "oc_reversed_cmp_candidate";
            case 12L: return "oc_last";
            default: return "";
        }
    }

    std::string an_overload_context(int64_t i, const std::string &strip) {
        std::string s = an_overload_context(i);
        if (s.empty())
            s = "(an_overload_context)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_overload_context() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L
        };
        static const std::vector<int64_t> retval(values, values + 13);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_overload_context(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_overload_context(i);
        if (retval.empty()) {
            retval = "(an_overload_context)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_overload_context::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_overload_context() {
        return stringify::an_overload_context();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/exprutil.h line 195
namespace stringify {
    const char* a_type_class_kind(int64_t i) {
        switch (i) {
            case -1L: return "tck_none";
            case 0L: return "tck_void";
            case 1L: return "tck_integer";
            case 2L: return "tck_char";
            case 3L: return "tck_enum";
            case 4L: return "tck_bool";
            case 5L: return "tck_pointer";
            case 6L: return "tck_reference";
            case 7L: return "tck_offset";
            case 8L: return "tck_float";
            case 9L: return "tck_complex";
            case 10L: return "tck_routine";
            case 11L: return "tck_method";
            case 12L: return "tck_struct";
            case 13L: return "tck_union";
            case 14L: return "tck_array";
            case 15L: return "tck_string";
            default: return "";
        }
    }

    std::string a_type_class_kind(int64_t i, const std::string &strip) {
        std::string s = a_type_class_kind(i);
        if (s.empty())
            s = "(a_type_class_kind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_type_class_kind() {
        static const int64_t values[] = {
            -1L,
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L
        };
        static const std::vector<int64_t> retval(values, values + 17);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_type_class_kind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_type_class_kind(i);
        if (retval.empty()) {
            retval = "(a_type_class_kind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_type_class_kind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_type_class_kind() {
        return stringify::a_type_class_kind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/exprutil.h line 323
namespace stringify {
    const char* an_operand_state_tag(int64_t i) {
        switch (i) {
            case 0L: return "os_none";
            case 1L: return "os_glvalue";
            case 2L: return "os_prvalue";
            case 3L: return "os_function_designator";
            default: return "";
        }
    }

    std::string an_operand_state_tag(int64_t i, const std::string &strip) {
        std::string s = an_operand_state_tag(i);
        if (s.empty())
            s = "(an_operand_state_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_operand_state_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_operand_state_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_operand_state_tag(i);
        if (retval.empty()) {
            retval = "(an_operand_state_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_operand_state_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_operand_state_tag() {
        return stringify::an_operand_state_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/host_envir.h line 2382
namespace stringify {
    const char* a_unicode_source_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "usk_none";
            case 1L: return "usk_utf8";
            case 2L: return "usk_utf16LE";
            case 3L: return "usk_utf16BE";
            default: return "";
        }
    }

    std::string a_unicode_source_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_unicode_source_kind_tag(i);
        if (s.empty())
            s = "(a_unicode_source_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_unicode_source_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_unicode_source_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_unicode_source_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_unicode_source_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_unicode_source_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_unicode_source_kind_tag() {
        return stringify::a_unicode_source_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/host_envir.h line 3758
namespace stringify {
    const char* a_predef_macro_mode(int64_t i) {
        switch (i) {
            case 0L: return "pmm_none";
            case 1L: return "pmm_gnu";
            case 2L: return "pmm_gcc";
            case 3L: return "pmm_gpp";
            case 4L: return "pmm_clang";
            case 5L: return "pmm_clang_c";
            case 6L: return "pmm_clang_cpp";
            case 7L: return "pmm_gnu_or_clang";
            case 8L: return "pmm_microsoft";
            case 9L: return "pmm_strict";
            case 10L: return "pmm_cpp";
            case 11L: return "pmm_all";
            case 12L: return "pmm_last";
            default: return "";
        }
    }

    std::string a_predef_macro_mode(int64_t i, const std::string &strip) {
        std::string s = a_predef_macro_mode(i);
        if (s.empty())
            s = "(a_predef_macro_mode)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_predef_macro_mode() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L
        };
        static const std::vector<int64_t> retval(values, values + 13);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_predef_macro_mode(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_predef_macro_mode(i);
        if (retval.empty()) {
            retval = "(a_predef_macro_mode)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_predef_macro_mode::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_predef_macro_mode() {
        return stringify::a_predef_macro_mode();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/floating.h line 416
namespace stringify {
    const char* an_fp_type(int64_t i) {
        switch (i) {
            case 0L: return "fpt_invalid";
            case 1L: return "fpt_approx";
            case 2L: return "fpt_number";
            case 3L: return "fpt_nan";
            case 4L: return "fpt_infinity";
            case 5L: return "fpt_overflow";
            case 6L: return "fpt_zero";
            case 7L: return "fpt_underflow";
            default: return "";
        }
    }

    std::string an_fp_type(int64_t i, const std::string &strip) {
        std::string s = an_fp_type(i);
        if (s.empty())
            s = "(an_fp_type)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_fp_type() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_fp_type(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_fp_type(i);
        if (retval.empty()) {
            retval = "(an_fp_type)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_fp_type::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_fp_type() {
        return stringify::an_fp_type();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/floating.h line 515
namespace stringify {
    const char* an_fp_return_type(int64_t i) {
        switch (i) {
            case -3L: return "fp_ret_invalid";
            case -2L: return "fp_ret_too_small";
            case -1L: return "fp_ret_not_formatted";
            case 0L: return "fp_ret_valid";
            case 1L: return "fp_ret_nan";
            case 2L: return "fp_ret_pos_infinity";
            case 3L: return "fp_ret_neg_infinity";
            case 4L: return "fp_ret_overflow";
            case 5L: return "fp_ret_underflow";
            default: return "";
        }
    }

    std::string an_fp_return_type(int64_t i, const std::string &strip) {
        std::string s = an_fp_return_type(i);
        if (s.empty())
            s = "(an_fp_return_type)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_fp_return_type() {
        static const int64_t values[] = {
            -3L,
            -2L,
            -1L,
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 9);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_fp_return_type(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_fp_return_type(i);
        if (retval.empty()) {
            retval = "(an_fp_return_type)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_fp_return_type::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_fp_return_type() {
        return stringify::an_fp_return_type();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/lexical.h line 1973
namespace stringify {
    const char* a_token_extra_info_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "teik_none";
            case 1L: return "teik_identifier";
            case 2L: return "teik_constant";
            case 3L: return "teik_pragma";
            case 4L: return "teik_pp_token";
            case 5L: return "teik_extracted_body";
            case 6L: return "teik_asm_string";
            case 7L: return "teik_insert_string";
            case 8L: return "teik_ud_lit";
            default: return "";
        }
    }

    std::string a_token_extra_info_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_token_extra_info_kind_tag(i);
        if (s.empty())
            s = "(a_token_extra_info_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_token_extra_info_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L
        };
        static const std::vector<int64_t> retval(values, values + 9);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_token_extra_info_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_token_extra_info_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_token_extra_info_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_token_extra_info_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_token_extra_info_kind_tag() {
        return stringify::a_token_extra_info_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/mem_manage.h line 421
namespace stringify {
    const char* a_function_number_tag(int64_t i) {
        switch (i) {
            case 0L: return "fn_null";
            case 1L: return "fn_hash_attribute_kind";
            case 2L: return "fn_compare_for_attr_corresp_checking_map";
            case 3L: return "fn_hash_source_string";
            case 4L: return "fn_compare_for_attr_name_map";
            case 5L: return "fn_compare_for_asm_name_map";
            case 6L: return "fn_hash_include_search_result";
            case 7L: return "fn_compare_include_search_result";
            case 8L: return "fn_hash_include_file_history";
            case 9L: return "fn_compare_include_file_history";
            case 10L: return "fn_hash_unique_file_id_for_table";
            case 11L: return "fn_compare_unique_file_id";
            case 12L: return "fn_hash_include_alias";
            case 13L: return "fn_compare_include_alias";
            case 14L: return "fn_hash_instantiation";
            case 15L: return "fn_compare_instantiation";
            case 16L: return "fn_hash_prop_or_event_accessor_header_lookup";
            case 17L: return "fn_compare_prop_or_event_accessor_header_lookup";
            case 18L: return "fn_hash_symbol_header_lookup_entry";
            case 19L: return "fn_compare_symbol_header_lookup_entry";
            case 20L: return "fn_record_arg_pragma";
            case 21L: return "fn_instantiation_pragma";
            case 22L: return "fn_pack_pragma";
            case 23L: return "fn_ident_pragma";
            case 24L: return "fn_ident_directive";
            case 25L: return "fn_once_pragma";
            case 26L: return "fn_hdrstop_or_no_pch_pragma";
            case 27L: return "fn_define_type_info_pragma";
            case 28L: return "fn_stdc_pragma";
            case 29L: return "fn_upc_pragma";
            case 30L: return "fn_redefine_extname_pragma";
            case 31L: return "fn_ldscope_pragma";
            case 32L: return "fn_gcc_pragma";
            case 33L: return "fn_diag_pragma";
            case 34L: return "fn_test_immediate_pragma";
            case 35L: return "fn_test_next_construct_pragma";
            case 36L: return "fn_db_opt_pragma";
            case 37L: return "fn_db_name_pragma";
            case 38L: return "fn_if_exists_pragma";
            case 39L: return "fn_push_macro_pragma";
            case 40L: return "fn_pop_macro_pragma";
            case 41L: return "fn_microsoft_start_map_region_pragma";
            case 42L: return "fn_microsoft_stop_map_region_pragma";
            case 43L: return "fn_setlocale_pragma";
            case 44L: return "fn_microsoft_comment_pragma";
            case 45L: return "fn_microsoft_conform_pragma";
            case 46L: return "fn_microsoft_include_alias_pragma";
            case 47L: return "fn_hash_unresolved_type_map_key";
            case 48L: return "fn_compare_for_unresolved_type_map";
            case 49L: return "fn_hash_void_pointer";
            case 50L: return "fn_compare_for_pointer_pair_map";
            case 51L: return "fn_compare_substituted_type_list_entry";
            case 52L: return "fn_hash_token_sequence_xref";
            case 53L: return "fn_compare_token_sequence_xref";
            case 54L: return "fn_last";
            default: return "";
        }
    }

    std::string a_function_number_tag(int64_t i, const std::string &strip) {
        std::string s = a_function_number_tag(i);
        if (s.empty())
            s = "(a_function_number_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_function_number_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L
        };
        static const std::vector<int64_t> retval(values, values + 55);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_function_number_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_function_number_tag(i);
        if (retval.empty()) {
            retval = "(a_function_number_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_function_number_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_function_number_tag() {
        return stringify::a_function_number_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/sys_predef.h line 220
namespace stringify {
    const char* a_builtin_user_function_kind_tag(int64_t i) {
        switch (i) {
            default: return "";
        }
    }

    std::string a_builtin_user_function_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_builtin_user_function_kind_tag(i);
        if (s.empty())
            s = "(a_builtin_user_function_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_builtin_user_function_kind_tag() {
        static const std::vector<int64_t> retval;
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_builtin_user_function_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_builtin_user_function_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_builtin_user_function_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_builtin_user_function_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_builtin_user_function_kind_tag() {
        return stringify::a_builtin_user_function_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/sys_predef.h line 453
namespace stringify {
    const char* a_multiversion_arch_kind_tag(int64_t i) {
        switch (i) {
            case -1L: return "mvak_invalid";
            case 0L: return "mvak_unknown";
            case 1L: return "mvak_lowest_cpu";
            case 2L: return "mvak_cpu_bdver2";
            case 3L: return "mvak_cpu_corei7";
            case 4L: return "mvak_cpu_amdfam10h";
            case 5L: return "mvak_cpu_core2";
            case 6L: return "mvak_highest_cpu";
            case 7L: return "mvak_default_target";
            case 8L: return "mvak_lowest_isa";
            case 9L: return "mvak_isa_sse";
            case 10L: return "mvak_isa_sse2";
            case 11L: return "mvak_isa_sse3";
            case 12L: return "mvak_isa_ssse3";
            case 13L: return "mvak_isa_sse4";
            case 14L: return "mvak_isa_sse4a";
            case 15L: return "mvak_isa_sse4_1";
            case 16L: return "mvak_isa_sse4_2";
            case 17L: return "mvak_isa_popcnt";
            case 18L: return "mvak_isa_aes";
            case 19L: return "mvak_isa_pclmul";
            case 20L: return "mvak_isa_avx";
            case 21L: return "mvak_isa_bmi";
            case 22L: return "mvak_isa_fma4";
            case 23L: return "mvak_isa_xop";
            case 24L: return "mvak_isa_fma";
            case 25L: return "mvak_isa_bmi2";
            case 26L: return "mvak_isa_avx2";
            case 27L: return "mvak_isa_avx512f";
            case 28L: return "mvak_last";
            default: return "";
        }
    }

    std::string a_multiversion_arch_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_multiversion_arch_kind_tag(i);
        if (s.empty())
            s = "(a_multiversion_arch_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_multiversion_arch_kind_tag() {
        static const int64_t values[] = {
            -1L,
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L
        };
        static const std::vector<int64_t> retval(values, values + 30);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_multiversion_arch_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_multiversion_arch_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_multiversion_arch_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_multiversion_arch_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_multiversion_arch_kind_tag() {
        return stringify::a_multiversion_arch_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/il_def.h line 387
namespace stringify {
    const char* an_access_specifier_tag(int64_t i) {
        switch (i) {
            case 0L: return "as_public";
            case 1L: return "as_protected";
            case 2L: return "as_private";
            case 3L: return "as_inaccessible";
            default: return "";
        }
    }

    std::string an_access_specifier_tag(int64_t i, const std::string &strip) {
        std::string s = an_access_specifier_tag(i);
        if (s.empty())
            s = "(an_access_specifier_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_access_specifier_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_access_specifier_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_access_specifier_tag(i);
        if (retval.empty()) {
            retval = "(an_access_specifier_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_access_specifier_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_access_specifier_tag() {
        return stringify::an_access_specifier_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/il_def.h line 407
namespace stringify {
    const char* an_assembly_visibility_tag(int64_t i) {
        switch (i) {
            case 0L: return "av_none";
            case 1L: return "av_public";
            case 2L: return "av_private";
            default: return "";
        }
    }

    std::string an_assembly_visibility_tag(int64_t i, const std::string &strip) {
        std::string s = an_assembly_visibility_tag(i);
        if (s.empty())
            s = "(an_assembly_visibility_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_assembly_visibility_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_assembly_visibility_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_assembly_visibility_tag(i);
        if (retval.empty()) {
            retval = "(an_assembly_visibility_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_assembly_visibility_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_assembly_visibility_tag() {
        return stringify::an_assembly_visibility_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/il_def.h line 1570
namespace stringify {
    const char* an_element_position_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "epk_error";
            case 1L: return "epk_specialization_header";
            case 2L: return "epk_noreturn";
            case 3L: return "epk_last";
            default: return "";
        }
    }

    std::string an_element_position_kind_tag(int64_t i, const std::string &strip) {
        std::string s = an_element_position_kind_tag(i);
        if (s.empty())
            s = "(an_element_position_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_element_position_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_element_position_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_element_position_kind_tag(i);
        if (retval.empty()) {
            retval = "(an_element_position_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_element_position_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_element_position_kind_tag() {
        return stringify::an_element_position_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/il_def.h line 1680
namespace stringify {
    const char* an_ELF_visibility_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "evk_unspecified";
            case 1L: return "evk_hidden";
            case 2L: return "evk_protected";
            case 3L: return "evk_internal";
            case 4L: return "evk_default";
            default: return "";
        }
    }

    std::string an_ELF_visibility_kind_tag(int64_t i, const std::string &strip) {
        std::string s = an_ELF_visibility_kind_tag(i);
        if (s.empty())
            s = "(an_ELF_visibility_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_ELF_visibility_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_ELF_visibility_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_ELF_visibility_kind_tag(i);
        if (retval.empty()) {
            retval = "(an_ELF_visibility_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_ELF_visibility_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_ELF_visibility_kind_tag() {
        return stringify::an_ELF_visibility_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/il_def.h line 2398
namespace stringify {
    const char* an_attribute_arg_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "aak_empty";
            case 1L: return "aak_raw_token";
            case 2L: return "aak_token";
            case 3L: return "aak_constant";
            case 4L: return "aak_type";
            case 5L: return "aak_expression";
            case 6L: return "aak_last";
            default: return "";
        }
    }

    std::string an_attribute_arg_kind_tag(int64_t i, const std::string &strip) {
        std::string s = an_attribute_arg_kind_tag(i);
        if (s.empty())
            s = "(an_attribute_arg_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_attribute_arg_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_attribute_arg_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_attribute_arg_kind_tag(i);
        if (retval.empty()) {
            retval = "(an_attribute_arg_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_attribute_arg_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_attribute_arg_kind_tag() {
        return stringify::an_attribute_arg_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/il_def.h line 2474
namespace stringify {
    const char* an_attribute_family_tag(int64_t i) {
        switch (i) {
            case 0L: return "af_internal";
            case 1L: return "af_std";
            case 2L: return "af_gnu";
            case 3L: return "af_ms_declspec";
            case 4L: return "af_alignas";
            case 5L: return "af_last";
            default: return "";
        }
    }

    std::string an_attribute_family_tag(int64_t i, const std::string &strip) {
        std::string s = an_attribute_family_tag(i);
        if (s.empty())
            s = "(an_attribute_family_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_attribute_family_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_attribute_family_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_attribute_family_tag(i);
        if (retval.empty()) {
            retval = "(an_attribute_family_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_attribute_family_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_attribute_family_tag() {
        return stringify::an_attribute_family_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/il_def.h line 2499
namespace stringify {
    const char* an_attribute_location_tag(int64_t i) {
        switch (i) {
            case 0L: return "al_implicit";
            case 1L: return "al_prefix";
            case 2L: return "al_tag_name";
            case 3L: return "al_post_tag_definition";
            case 4L: return "al_base_specifier";
            case 5L: return "al_specifier";
            case 6L: return "al_declarator_id";
            case 7L: return "al_post_ptr_or_ref";
            case 8L: return "al_post_array";
            case 9L: return "al_post_func";
            case 10L: return "al_postfix";
            case 11L: return "al_predeclarator";
            case 12L: return "al_id_equivalent";
            case 13L: return "al_trailing_return";
            case 14L: return "al_post_initializer";
            case 15L: return "al_namespace";
            case 16L: return "al_gnu_namespace";
            case 17L: return "al_label";
            case 18L: return "al_explicit";
            case 19L: return "al_enumerator";
            case 20L: return "al_id_equivalent_as_postfix";
            case 21L: return "al_last";
            default: return "";
        }
    }

    std::string an_attribute_location_tag(int64_t i, const std::string &strip) {
        std::string s = an_attribute_location_tag(i);
        if (s.empty())
            s = "(an_attribute_location_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_attribute_location_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L
        };
        static const std::vector<int64_t> retval(values, values + 22);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_attribute_location_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_attribute_location_tag(i);
        if (retval.empty()) {
            retval = "(an_attribute_location_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_attribute_location_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_attribute_location_tag() {
        return stringify::an_attribute_location_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/il_def.h line 2568
namespace stringify {
    const char* an_attribute_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "ak_unrecognized";
            case 1L: return "ak_empty_attr";
            case 2L: return "ak_attr_using_prefix";
            case 3L: return "ak_align";
            case 4L: return "ak_base_check";
            case 5L: return "ak_carries_dependency";
            case 6L: return "ak_deprecated";
            case 7L: return "ak_final";
            case 8L: return "ak_hiding";
            case 9L: return "ak_noreturn";
            case 10L: return "ak_override";
            case 11L: return "ak_nodiscard";
            case 12L: return "ak_maybe_unused";
            case 13L: return "ak_fallthrough";
            case 14L: return "ak_likely";
            case 15L: return "ak_unlikely";
            case 16L: return "ak_no_unique_address";
            case 17L: return "ak_enable_if";
            case 18L: return "ak_overloadable";
            case 19L: return "ak_naked";
            case 20L: return "ak_noinline";
            case 21L: return "ak_nothrow";
            case 22L: return "ak_pure";
            case 23L: return "ak_section";
            case 24L: return "ak_alias";
            case 25L: return "ak_alloc_size";
            case 26L: return "ak_always_inline";
            case 27L: return "ak_artificial";
            case 28L: return "ak_cdecl";
            case 29L: return "ak_cleanup";
            case 30L: return "ak_cold";
            case 31L: return "ak_common";
            case 32L: return "ak_const";
            case 33L: return "ak_constructor";
            case 34L: return "ak_destructor";
            case 35L: return "ak_error";
            case 36L: return "ak_ext_vector_type";
            case 37L: return "ak_externally_visible";
            case 38L: return "ak_fastcall";
            case 39L: return "ak_flatten";
            case 40L: return "ak_format";
            case 41L: return "ak_format_arg";
            case 42L: return "ak_gnu_inline";
            case 43L: return "ak_hot";
            case 44L: return "ak_ifunc";
            case 45L: return "ak_init_priority";
            case 46L: return "ak_internal_linkage";
            case 47L: return "ak_malloc";
            case 48L: return "ak_may_alias";
            case 49L: return "ak_mode";
            case 50L: return "ak_no_instrument_function";
            case 51L: return "ak_no_check_memory_usage";
            case 52L: return "ak_nocommon";
            case 53L: return "ak_nonnull";
            case 54L: return "ak_noplt";
            case 55L: return "ak_packed";
            case 56L: return "ak_sentinel";
            case 57L: return "ak_stdcall";
            case 58L: return "ak_strong";
            case 59L: return "ak_target";
            case 60L: return "ak_tls_model";
            case 61L: return "ak_transparent_union";
            case 62L: return "ak_unused";
            case 63L: return "ak_used";
            case 64L: return "ak_vector_size";
            case 65L: return "ak_visibility";
            case 66L: return "ak_warn_unused_result";
            case 67L: return "ak_warning";
            case 68L: return "ak_weak";
            case 69L: return "ak_weakref";
            case 70L: return "ak_abi_tag";
            case 71L: return "ak_appdomain";
            case 72L: return "ak_assembly_info";
            case 73L: return "ak_dllexport";
            case 74L: return "ak_dllimport";
            case 75L: return "ak_edg_interior_ptr_alias";
            case 76L: return "ak_edg_pin_ptr_alias";
            case 77L: return "ak_empty_bases";
            case 78L: return "ak_hybrid_patchable";
            case 79L: return "ak_implementation_key";
            case 80L: return "ak_intrin_type";
            case 81L: return "ak_jitintrinsic";
            case 82L: return "ak_no_init_all";
            case 83L: return "ak_noalias";
            case 84L: return "ak_non_user_code";
            case 85L: return "ak_novtable";
            case 86L: return "ak_process";
            case 87L: return "ak_property";
            case 88L: return "ak_restrict";
            case 89L: return "ak_safebuffers";
            case 90L: return "ak_selectany";
            case 91L: return "ak_spectre";
            case 92L: return "ak_thread";
            case 93L: return "ak_uuid";
            case 94L: return "ak_layout_as_external";
            case 95L: return "ak_no_empty_identity_interface";
            case 96L: return "ak_no_ftm";
            case 97L: return "ak_no_refcount";
            case 98L: return "ak_no_release_return";
            case 99L: return "ak_no_weakreferencesource";
            case 100L: return "ak_one_phase_constructed";
            case 101L: return "ak_allocator";
            case 102L: return "ak_host";
            case 103L: return "ak_global";
            case 104L: return "ak_device";
            case 105L: return "ak_shared";
            case 106L: return "ak_local";
            case 107L: return "ak_constant";
            case 108L: return "ak_edg_e1";
            case 109L: return "ak_edg_n1";
            case 110L: return "ak_availability";
            case 111L: return "ak_conditional_explicit";
            case 112L: return "ak_pragma_pack_state";
            case 113L: return "ak_last";
            default: return "";
        }
    }

    std::string an_attribute_kind_tag(int64_t i, const std::string &strip) {
        std::string s = an_attribute_kind_tag(i);
        if (s.empty())
            s = "(an_attribute_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_attribute_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L,
            58L,
            59L,
            60L,
            61L,
            62L,
            63L,
            64L,
            65L,
            66L,
            67L,
            68L,
            69L,
            70L,
            71L,
            72L,
            73L,
            74L,
            75L,
            76L,
            77L,
            78L,
            79L,
            80L,
            81L,
            82L,
            83L,
            84L,
            85L,
            86L,
            87L,
            88L,
            89L,
            90L,
            91L,
            92L,
            93L,
            94L,
            95L,
            96L,
            97L,
            98L,
            99L,
            100L,
            101L,
            102L,
            103L,
            104L,
            105L,
            106L,
            107L,
            108L,
            109L,
            110L,
            111L,
            112L,
            113L
        };
        static const std::vector<int64_t> retval(values, values + 114);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_attribute_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_attribute_kind_tag(i);
        if (retval.empty()) {
            retval = "(an_attribute_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_attribute_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_attribute_kind_tag() {
        return stringify::an_attribute_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/il_def.h line 3206
namespace stringify {
    const char* a_constant_repr_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "ck_error";
            case 1L: return "ck_integer";
            case 2L: return "ck_fixed_point";
            case 3L: return "ck_string";
            case 4L: return "ck_float";
            case 5L: return "ck_complex";
            case 6L: return "ck_imaginary";
            case 7L: return "ck_address";
            case 8L: return "ck_ptr_to_member";
            case 9L: return "ck_label_difference";
            case 10L: return "ck_stack_offset";
            case 11L: return "ck_dynamic_init";
            case 12L: return "ck_aggregate";
            case 13L: return "ck_init_repeat";
            case 14L: return "ck_template_param";
            case 15L: return "ck_designator";
            case 16L: return "ck_upc_threads";
            case 17L: return "ck_upc_mythread";
            case 18L: return "ck_void";
            case 19L: return "ck_last";
            default: return "";
        }
    }

    std::string a_constant_repr_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_constant_repr_kind_tag(i);
        if (s.empty())
            s = "(a_constant_repr_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_constant_repr_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L
        };
        static const std::vector<int64_t> retval(values, values + 20);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_constant_repr_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_constant_repr_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_constant_repr_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_constant_repr_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_constant_repr_kind_tag() {
        return stringify::a_constant_repr_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/il_def.h line 3258
namespace stringify {
    const char* an_address_base_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "abk_routine";
            case 1L: return "abk_variable";
            case 2L: return "abk_constant";
            case 3L: return "abk_temporary";
            case 4L: return "abk_uuidof";
            case 5L: return "abk_typeid";
            case 6L: return "abk_cli_typeid";
            case 7L: return "abk_cli_array";
            case 8L: return "abk_label";
            case 9L: return "abk_last";
            default: return "";
        }
    }

    std::string an_address_base_kind_tag(int64_t i, const std::string &strip) {
        std::string s = an_address_base_kind_tag(i);
        if (s.empty())
            s = "(an_address_base_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_address_base_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L
        };
        static const std::vector<int64_t> retval(values, values + 10);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_address_base_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_address_base_kind_tag(i);
        if (retval.empty()) {
            retval = "(an_address_base_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_address_base_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_address_base_kind_tag() {
        return stringify::an_address_base_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/il_def.h line 3519
namespace stringify {
    const char* a_dynamic_init_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "dik_none";
            case 1L: return "dik_zero";
            case 2L: return "dik_constant";
            case 3L: return "dik_expression";
            case 4L: return "dik_class_result_via_ctor";
            case 5L: return "dik_constructor";
            case 6L: return "dik_nonconstant_aggregate";
            case 7L: return "dik_bitwise_copy";
            case 8L: return "dik_lambda";
            default: return "";
        }
    }

    std::string a_dynamic_init_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_dynamic_init_kind_tag(i);
        if (s.empty())
            s = "(a_dynamic_init_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_dynamic_init_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L
        };
        static const std::vector<int64_t> retval(values, values + 9);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_dynamic_init_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_dynamic_init_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_dynamic_init_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_dynamic_init_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_dynamic_init_kind_tag() {
        return stringify::a_dynamic_init_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/il_def.h line 3953
namespace stringify {
    const char* a_template_param_constant_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "tpck_param";
            case 1L: return "tpck_expression";
            case 2L: return "tpck_member";
            case 3L: return "tpck_unknown_function";
            case 4L: return "tpck_address";
            case 5L: return "tpck_sizeof";
            case 6L: return "tpck_alignof";
            case 7L: return "tpck_uuidof";
            case 8L: return "tpck_typeid";
            case 9L: return "tpck_noexcept";
            case 10L: return "tpck_template_ref";
            case 11L: return "tpck_integer_pack";
            case 12L: return "tpck_destructor";
            default: return "";
        }
    }

    std::string a_template_param_constant_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_template_param_constant_kind_tag(i);
        if (s.empty())
            s = "(a_template_param_constant_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_template_param_constant_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L
        };
        static const std::vector<int64_t> retval(values, values + 13);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_template_param_constant_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_template_param_constant_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_template_param_constant_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_template_param_constant_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_template_param_constant_kind_tag() {
        return stringify::a_template_param_constant_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/il_def.h line 4087
namespace stringify {
    const char* a_character_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "chk_default";
            case 1L: return "chk_wchar_t";
            case 2L: return "chk_char8_t";
            case 3L: return "chk_char16_t";
            case 4L: return "chk_char32_t";
            case 5L: return "chk_last";
            default: return "";
        }
    }

    std::string a_character_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_character_kind_tag(i);
        if (s.empty())
            s = "(a_character_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_character_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_character_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_character_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_character_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_character_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_character_kind_tag() {
        return stringify::a_character_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/il_def.h line 4909
namespace stringify {
    const char* a_type_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "tk_error";
            case 1L: return "tk_void";
            case 2L: return "tk_integer";
            case 3L: return "tk_fixed_point";
            case 4L: return "tk_float";
            case 5L: return "tk_imaginary";
            case 6L: return "tk_complex";
            case 7L: return "tk_pointer";
            case 8L: return "tk_routine";
            case 9L: return "tk_array";
            case 10L: return "tk_class";
            case 11L: return "tk_struct";
            case 12L: return "tk_union";
            case 13L: return "tk_typeref";
            case 14L: return "tk_ptr_to_member";
            case 15L: return "tk_template_param";
            case 16L: return "tk_vector";
            case 17L: return "tk_nullptr";
            case 18L: return "tk_unknown";
            default: return "";
        }
    }

    std::string a_type_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_type_kind_tag(i);
        if (s.empty())
            s = "(a_type_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_type_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L
        };
        static const std::vector<int64_t> retval(values, values + 19);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_type_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_type_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_type_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_type_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_type_kind_tag() {
        return stringify::a_type_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/il_def.h line 4957
namespace stringify {
    const char* an_integer_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "ik_char";
            case 1L: return "ik_signed_char";
            case 2L: return "ik_unsigned_char";
            case 3L: return "ik_short";
            case 4L: return "ik_unsigned_short";
            case 5L: return "ik_int";
            case 6L: return "ik_unsigned_int";
            case 7L: return "ik_long";
            case 8L: return "ik_unsigned_long";
            case 9L: return "ik_long_long";
            case 10L: return "ik_unsigned_long_long";
            case 11L: return "ik_int128";
            case 12L: return "ik_unsigned_int128";
            case 13L: return "ik_none";
            default: return "";
        }
    }

    std::string an_integer_kind_tag(int64_t i, const std::string &strip) {
        std::string s = an_integer_kind_tag(i);
        if (s.empty())
            s = "(an_integer_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_integer_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L
        };
        static const std::vector<int64_t> retval(values, values + 14);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_integer_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_integer_kind_tag(i);
        if (retval.empty()) {
            retval = "(an_integer_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_integer_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_integer_kind_tag() {
        return stringify::an_integer_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/il_def.h line 5047
namespace stringify {
    const char* a_fixed_point_precision_tag(int64_t i) {
        switch (i) {
            case 0L: return "fpp_short";
            case 1L: return "fpp_default";
            case 2L: return "fpp_long";
            case 3L: return "fpp_last";
            default: return "";
        }
    }

    std::string a_fixed_point_precision_tag(int64_t i, const std::string &strip) {
        std::string s = a_fixed_point_precision_tag(i);
        if (s.empty())
            s = "(a_fixed_point_precision_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_fixed_point_precision_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_fixed_point_precision_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_fixed_point_precision_tag(i);
        if (retval.empty()) {
            retval = "(a_fixed_point_precision_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_fixed_point_precision_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_fixed_point_precision_tag() {
        return stringify::a_fixed_point_precision_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/il_def.h line 5079
namespace stringify {
    const char* a_float_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "fk_float";
            case 1L: return "fk_double";
            case 2L: return "fk_long_double";
            case 3L: return "fk_float80";
            case 4L: return "fk_float128";
            case 5L: return "fk_last";
            default: return "";
        }
    }

    std::string a_float_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_float_kind_tag(i);
        if (s.empty())
            s = "(a_float_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_float_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_float_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_float_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_float_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_float_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_float_kind_tag() {
        return stringify::a_float_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/il_def.h line 5105
namespace stringify {
    const char* a_type_mode_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "tmk_error";
            case 1L: return "tmk_first";
            case 2L: return "tmk_HI";
            case 3L: return "tmk_SI";
            case 4L: return "tmk_DI";
            case 5L: return "tmk_TI";
            case 6L: return "tmk_SF";
            case 7L: return "tmk_DF";
            case 8L: return "tmk_XF";
            case 9L: return "tmk_TF";
            case 10L: return "tmk_SC";
            case 11L: return "tmk_DC";
            case 12L: return "tmk_XC";
            case 13L: return "tmk_TC";
            case 14L: return "tmk_none";
            default: return "";
        }
    }

    std::string a_type_mode_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_type_mode_kind_tag(i);
        if (s.empty())
            s = "(a_type_mode_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_type_mode_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L
        };
        static const std::vector<int64_t> retval(values, values + 15);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_type_mode_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_type_mode_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_type_mode_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_type_mode_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_type_mode_kind_tag() {
        return stringify::a_type_mode_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/il_def.h line 5161
namespace stringify {
    const char* an_asm_operand_constraint_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "aoc_invalid";
            case 1L: return "aoc_end_of_constraint";
            case 2L: return "aoc_mod_earlyclobber";
            case 3L: return "aoc_mod_commutative_ops";
            case 4L: return "aoc_mod_ignore";
            case 5L: return "aoc_mod_ignore_char";
            case 6L: return "aoc_mod_disparage_slightly";
            case 7L: return "aoc_mod_disparage_severely";
            case 8L: return "aoc_any";
            case 9L: return "aoc_general";
            case 10L: return "aoc_match_0";
            case 11L: return "aoc_match_1";
            case 12L: return "aoc_match_2";
            case 13L: return "aoc_match_3";
            case 14L: return "aoc_match_4";
            case 15L: return "aoc_match_5";
            case 16L: return "aoc_match_6";
            case 17L: return "aoc_match_7";
            case 18L: return "aoc_match_8";
            case 19L: return "aoc_match_9";
            case 20L: return "aoc_reg_integer";
            case 21L: return "aoc_reg_float";
            case 22L: return "aoc_mem_any";
            case 23L: return "aoc_mem_load";
            case 24L: return "aoc_mem_offset";
            case 25L: return "aoc_mem_nonoffset";
            case 26L: return "aoc_mem_autoinc";
            case 27L: return "aoc_mem_autodec";
            case 28L: return "aoc_imm_int";
            case 29L: return "aoc_imm_number";
            case 30L: return "aoc_imm_symbol";
            case 31L: return "aoc_imm_float";
            case 32L: return "aoc_reg_a";
            case 33L: return "aoc_reg_b";
            case 34L: return "aoc_reg_c";
            case 35L: return "aoc_reg_d";
            case 36L: return "aoc_reg_si";
            case 37L: return "aoc_reg_di";
            case 38L: return "aoc_reg_legacy";
            case 39L: return "aoc_reg_q";
            case 40L: return "aoc_reg_Q";
            case 41L: return "aoc_reg_ad";
            case 42L: return "aoc_reg_float_tos";
            case 43L: return "aoc_reg_float_second";
            case 44L: return "aoc_reg_sse";
            case 45L: return "aoc_reg_sse2";
            case 46L: return "aoc_reg_mmx";
            case 47L: return "aoc_imm_short_shift";
            case 48L: return "aoc_imm_long_shift";
            case 49L: return "aoc_imm_lea_shift";
            case 50L: return "aoc_imm_signed8";
            case 51L: return "aoc_imm_unsigned8";
            case 52L: return "aoc_imm_and_zext";
            case 53L: return "aoc_imm_80387";
            case 54L: return "aoc_imm_sse";
            case 55L: return "aoc_imm_sext32";
            case 56L: return "aoc_imm_zext32";
            case 57L: return "aoc_last";
            default: return "";
        }
    }

    std::string an_asm_operand_constraint_kind_tag(int64_t i, const std::string &strip) {
        std::string s = an_asm_operand_constraint_kind_tag(i);
        if (s.empty())
            s = "(an_asm_operand_constraint_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_asm_operand_constraint_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L
        };
        static const std::vector<int64_t> retval(values, values + 58);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_asm_operand_constraint_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_asm_operand_constraint_kind_tag(i);
        if (retval.empty()) {
            retval = "(an_asm_operand_constraint_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_asm_operand_constraint_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_asm_operand_constraint_kind_tag() {
        return stringify::an_asm_operand_constraint_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/il_def.h line 5326
namespace stringify {
    const char* an_asm_operand_modifier_tag(int64_t i) {
        switch (i) {
            case 0L: return "aom_invalid";
            case 1L: return "aom_input";
            case 2L: return "aom_output";
            case 3L: return "aom_modify";
            default: return "";
        }
    }

    std::string an_asm_operand_modifier_tag(int64_t i, const std::string &strip) {
        std::string s = an_asm_operand_modifier_tag(i);
        if (s.empty())
            s = "(an_asm_operand_modifier_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_asm_operand_modifier_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_asm_operand_modifier_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_asm_operand_modifier_tag(i);
        if (retval.empty()) {
            retval = "(an_asm_operand_modifier_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_asm_operand_modifier_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_asm_operand_modifier_tag() {
        return stringify::an_asm_operand_modifier_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/il_def.h line 5337
namespace stringify {
    const char* a_named_register_tag(int64_t i) {
        switch (i) {
            case 0L: return "anr_invalid";
            case 1L: return "anr_memory";
            case 2L: return "anr_a";
            case 3L: return "anr_b";
            case 4L: return "anr_c";
            case 5L: return "anr_d";
            case 6L: return "anr_si";
            case 7L: return "anr_di";
            case 8L: return "anr_bp";
            case 9L: return "anr_sp";
            case 10L: return "anr_r8";
            case 11L: return "anr_r9";
            case 12L: return "anr_r10";
            case 13L: return "anr_r11";
            case 14L: return "anr_r12";
            case 15L: return "anr_r13";
            case 16L: return "anr_r14";
            case 17L: return "anr_r15";
            case 18L: return "anr_st";
            case 19L: return "anr_st1";
            case 20L: return "anr_st2";
            case 21L: return "anr_st3";
            case 22L: return "anr_st4";
            case 23L: return "anr_st5";
            case 24L: return "anr_st6";
            case 25L: return "anr_st7";
            case 26L: return "anr_mm0";
            case 27L: return "anr_mm1";
            case 28L: return "anr_mm2";
            case 29L: return "anr_mm3";
            case 30L: return "anr_mm4";
            case 31L: return "anr_mm5";
            case 32L: return "anr_mm6";
            case 33L: return "anr_mm7";
            case 34L: return "anr_f0";
            case 35L: return "anr_f1";
            case 36L: return "anr_f2";
            case 37L: return "anr_f3";
            case 38L: return "anr_f4";
            case 39L: return "anr_f5";
            case 40L: return "anr_f6";
            case 41L: return "anr_f7";
            case 42L: return "anr_f8";
            case 43L: return "anr_f9";
            case 44L: return "anr_f10";
            case 45L: return "anr_f11";
            case 46L: return "anr_f12";
            case 47L: return "anr_f13";
            case 48L: return "anr_f14";
            case 49L: return "anr_f15";
            case 50L: return "anr_flags";
            case 51L: return "anr_fpsr";
            case 52L: return "anr_dirflag";
            case 53L: return "anr_16";
            case 54L: return "anr_17";
            case 55L: return "anr_18";
            case 56L: return "anr_19";
            case 57L: return "anr_20";
            case 58L: return "anr_unrecognized";
            case 59L: return "anr_last";
            default: return "";
        }
    }

    std::string a_named_register_tag(int64_t i, const std::string &strip) {
        std::string s = a_named_register_tag(i);
        if (s.empty())
            s = "(a_named_register_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_named_register_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L,
            58L,
            59L
        };
        static const std::vector<int64_t> retval(values, values + 60);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_named_register_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_named_register_tag(i);
        if (retval.empty()) {
            retval = "(a_named_register_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_named_register_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_named_register_tag() {
        return stringify::a_named_register_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/il_def.h line 5512
namespace stringify {
    const char* a_type_qualifier_tag(int64_t i) {
        switch (i) {
            case 0L: return "tqt_const";
            case 1L: return "tqt_volatile";
            case 2L: return "tqt_restrict";
            case 3L: return "tqt_c11_atomic";
            case 4L: return "tqt_nullable";
            case 5L: return "tqt_nonnull";
            case 6L: return "tqt_null_unspecified";
            case 7L: return "tqt_unaligned";
            case 8L: return "tqt_near";
            case 9L: return "tqt_far";
            case 10L: return "tqt_upc_shared";
            case 11L: return "tqt_upc_strict";
            case 12L: return "tqt_upc_relaxed";
            case 13L: return "tqt_lsb_named_address_space";
            default: return "";
        }
    }

    std::string a_type_qualifier_tag(int64_t i, const std::string &strip) {
        std::string s = a_type_qualifier_tag(i);
        if (s.empty())
            s = "(a_type_qualifier_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_type_qualifier_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L
        };
        static const std::vector<int64_t> retval(values, values + 14);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_type_qualifier_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_type_qualifier_tag(i);
        if (retval.empty()) {
            retval = "(a_type_qualifier_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_type_qualifier_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_type_qualifier_tag() {
        return stringify::a_type_qualifier_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/il_def.h line 5614
namespace stringify {
    const char* a_upc_pragma_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "upc_pk_access";
            case 1L: return "upc_pk_coherence";
            default: return "";
        }
    }

    std::string a_upc_pragma_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_upc_pragma_kind_tag(i);
        if (s.empty())
            s = "(a_upc_pragma_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_upc_pragma_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_upc_pragma_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_upc_pragma_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_upc_pragma_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_upc_pragma_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_upc_pragma_kind_tag() {
        return stringify::a_upc_pragma_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/il_def.h line 5624
namespace stringify {
    const char* a_upc_access_method_tag(int64_t i) {
        switch (i) {
            case 0L: return "upc_access_unspecified";
            case 1L: return "upc_access_strict";
            case 2L: return "upc_access_relaxed";
            default: return "";
        }
    }

    std::string a_upc_access_method_tag(int64_t i, const std::string &strip) {
        std::string s = a_upc_access_method_tag(i);
        if (s.empty())
            s = "(a_upc_access_method_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_upc_access_method_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_upc_access_method_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_upc_access_method_tag(i);
        if (retval.empty()) {
            retval = "(a_upc_access_method_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_upc_access_method_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_upc_access_method_tag() {
        return stringify::a_upc_access_method_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/il_def.h line 5635
namespace stringify {
    const char* a_upc_coherence_stack_operation_tag(int64_t i) {
        switch (i) {
            case 0L: return "upc_coherence_stack_noop";
            case 1L: return "upc_coherence_stack_save";
            case 2L: return "upc_coherence_stack_restore";
            default: return "";
        }
    }

    std::string a_upc_coherence_stack_operation_tag(int64_t i, const std::string &strip) {
        std::string s = a_upc_coherence_stack_operation_tag(i);
        if (s.empty())
            s = "(a_upc_coherence_stack_operation_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_upc_coherence_stack_operation_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_upc_coherence_stack_operation_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_upc_coherence_stack_operation_tag(i);
        if (retval.empty()) {
            retval = "(a_upc_coherence_stack_operation_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_upc_coherence_stack_operation_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_upc_coherence_stack_operation_tag() {
        return stringify::a_upc_coherence_stack_operation_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/il_def.h line 5816
namespace stringify {
    const char* a_stdc_pragma_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "stdc_pk_none";
            case 1L: return "stdc_pk_fp_contract";
            case 2L: return "stdc_pk_fenv_access";
            case 3L: return "stdc_pk_cx_limited_range";
            case 4L: return "stdc_pk_fx_full_precision";
            case 5L: return "stdc_pk_fx_fract_overflow";
            case 6L: return "stdc_pk_fx_accum_overflow";
            case 7L: return "stdc_pk_last";
            default: return "";
        }
    }

    std::string a_stdc_pragma_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_stdc_pragma_kind_tag(i);
        if (s.empty())
            s = "(a_stdc_pragma_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_stdc_pragma_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_stdc_pragma_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_stdc_pragma_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_stdc_pragma_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_stdc_pragma_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_stdc_pragma_kind_tag() {
        return stringify::a_stdc_pragma_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/il_def.h line 5842
namespace stringify {
    const char* a_stdc_pragma_value_tag(int64_t i) {
        switch (i) {
            case 0L: return "stdc_pv_none";
            case 1L: return "stdc_pv_off";
            case 2L: return "stdc_pv_on";
            case 3L: return "stdc_pv_sat";
            case 4L: return "stdc_pv_default";
            default: return "";
        }
    }

    std::string a_stdc_pragma_value_tag(int64_t i, const std::string &strip) {
        std::string s = a_stdc_pragma_value_tag(i);
        if (s.empty())
            s = "(a_stdc_pragma_value_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_stdc_pragma_value_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_stdc_pragma_value_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_stdc_pragma_value_tag(i);
        if (retval.empty()) {
            retval = "(a_stdc_pragma_value_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_stdc_pragma_value_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_stdc_pragma_value_tag() {
        return stringify::a_stdc_pragma_value_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/il_def.h line 5863
namespace stringify {
    const char* a_gcc_pragma_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "gcc_pk_none";
            case 1L: return "gcc_pk_system_header";
            case 2L: return "gcc_pk_visibility_push";
            case 3L: return "gcc_pk_visibility_pop";
            case 4L: return "gcc_pk_target";
            case 5L: return "gcc_pk_push_options";
            case 6L: return "gcc_pk_pop_options";
            case 7L: return "gcc_pk_reset_options";
            case 8L: return "gcc_pk_last";
            default: return "";
        }
    }

    std::string a_gcc_pragma_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_gcc_pragma_kind_tag(i);
        if (s.empty())
            s = "(a_gcc_pragma_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_gcc_pragma_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L
        };
        static const std::vector<int64_t> retval(values, values + 9);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_gcc_pragma_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_gcc_pragma_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_gcc_pragma_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_gcc_pragma_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_gcc_pragma_kind_tag() {
        return stringify::a_gcc_pragma_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/il_def.h line 6133
namespace stringify {
    const char* a_microsoft_pragma_comment_type_tag(int64_t i) {
        switch (i) {
            case 0L: return "mpct_compiler";
            case 1L: return "mpct_exestr";
            case 2L: return "mpct_lib";
            case 3L: return "mpct_linker";
            case 4L: return "mpct_user";
            case 5L: return "mpct_last";
            default: return "";
        }
    }

    std::string a_microsoft_pragma_comment_type_tag(int64_t i, const std::string &strip) {
        std::string s = a_microsoft_pragma_comment_type_tag(i);
        if (s.empty())
            s = "(a_microsoft_pragma_comment_type_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_microsoft_pragma_comment_type_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_microsoft_pragma_comment_type_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_microsoft_pragma_comment_type_tag(i);
        if (retval.empty()) {
            retval = "(a_microsoft_pragma_comment_type_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_microsoft_pragma_comment_type_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_microsoft_pragma_comment_type_tag() {
        return stringify::a_microsoft_pragma_comment_type_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/il_def.h line 6147
namespace stringify {
    const char* a_microsoft_pragma_conform_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "mpck_forScope";
            default: return "";
        }
    }

    std::string a_microsoft_pragma_conform_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_microsoft_pragma_conform_kind_tag(i);
        if (s.empty())
            s = "(a_microsoft_pragma_conform_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_microsoft_pragma_conform_kind_tag() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_microsoft_pragma_conform_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_microsoft_pragma_conform_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_microsoft_pragma_conform_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_microsoft_pragma_conform_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_microsoft_pragma_conform_kind_tag() {
        return stringify::a_microsoft_pragma_conform_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/il_def.h line 6454
namespace stringify {
    const char* a_calling_convention_tag(int64_t i) {
        switch (i) {
            case 0L: return "cc_default";
            case 1L: return "cc_cdecl";
            case 2L: return "cc_fastcall";
            case 3L: return "cc_stdcall";
            case 4L: return "cc_thiscall";
            case 5L: return "cc_vectorcall";
            case 6L: return "cc_clrcall";
            case 7L: return "cc_last";
            default: return "";
        }
    }

    std::string a_calling_convention_tag(int64_t i, const std::string &strip) {
        std::string s = a_calling_convention_tag(i);
        if (s.empty())
            s = "(a_calling_convention_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_calling_convention_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_calling_convention_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_calling_convention_tag(i);
        if (retval.empty()) {
            retval = "(a_calling_convention_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_calling_convention_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_calling_convention_tag() {
        return stringify::a_calling_convention_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/il_def.h line 6642
namespace stringify {
    const char* a_ref_qualifier_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "rqk_default";
            case 1L: return "rqk_lvalue";
            case 2L: return "rqk_rvalue";
            default: return "";
        }
    }

    std::string a_ref_qualifier_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_ref_qualifier_kind_tag(i);
        if (s.empty())
            s = "(a_ref_qualifier_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_ref_qualifier_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_ref_qualifier_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_ref_qualifier_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_ref_qualifier_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_ref_qualifier_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_ref_qualifier_kind_tag() {
        return stringify::a_ref_qualifier_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/il_def.h line 6924
namespace stringify {
    const char* a_templ_arg_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "tak_type";
            case 1L: return "tak_nontype";
            case 2L: return "tak_template";
            case 3L: return "tak_start_of_pack_expansion";
            default: return "";
        }
    }

    std::string a_templ_arg_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_templ_arg_kind_tag(i);
        if (s.empty())
            s = "(a_templ_arg_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_templ_arg_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_templ_arg_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_templ_arg_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_templ_arg_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_templ_arg_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_templ_arg_kind_tag() {
        return stringify::a_templ_arg_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/il_def.h line 7554
namespace stringify {
    const char* an_anonymous_union_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "auk_none";
            case 1L: return "auk_variable";
            case 2L: return "auk_field";
            default: return "";
        }
    }

    std::string an_anonymous_union_kind_tag(int64_t i, const std::string &strip) {
        std::string s = an_anonymous_union_kind_tag(i);
        if (s.empty())
            s = "(an_anonymous_union_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_anonymous_union_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_anonymous_union_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_anonymous_union_kind_tag(i);
        if (retval.empty()) {
            retval = "(an_anonymous_union_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_anonymous_union_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_anonymous_union_kind_tag() {
        return stringify::an_anonymous_union_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/il_def.h line 7569
namespace stringify {
    const char* an_inheritance_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "ihk_none";
            case 1L: return "ihk_single";
            case 2L: return "ihk_multiple";
            case 3L: return "ihk_virtual";
            default: return "";
        }
    }

    std::string an_inheritance_kind_tag(int64_t i, const std::string &strip) {
        std::string s = an_inheritance_kind_tag(i);
        if (s.empty())
            s = "(an_inheritance_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_inheritance_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_inheritance_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_inheritance_kind_tag(i);
        if (retval.empty()) {
            retval = "(an_inheritance_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_inheritance_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_inheritance_kind_tag() {
        return stringify::an_inheritance_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/il_def.h line 7603
namespace stringify {
    const char* a_cli_class_type_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "cctk_standard";
            case 1L: return "cctk_value";
            case 2L: return "cctk_ref";
            case 3L: return "cctk_interface";
            case 4L: return "cctk_unresolved";
            default: return "";
        }
    }

    std::string a_cli_class_type_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_cli_class_type_kind_tag(i);
        if (s.empty())
            s = "(a_cli_class_type_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_cli_class_type_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_cli_class_type_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_cli_class_type_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_cli_class_type_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_cli_class_type_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_cli_class_type_kind_tag() {
        return stringify::a_cli_class_type_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/il_def.h line 7636
namespace stringify {
    const char* a_property_or_event_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "pek_declspec_property";
            case 1L: return "pek_cli_property";
            case 2L: return "pek_cli_event";
            default: return "";
        }
    }

    std::string a_property_or_event_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_property_or_event_kind_tag(i);
        if (s.empty())
            s = "(a_property_or_event_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_property_or_event_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_property_or_event_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_property_or_event_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_property_or_event_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_property_or_event_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_property_or_event_kind_tag() {
        return stringify::a_property_or_event_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/il_def.h line 7769
namespace stringify {
    const char* a_rewritten_property_reference_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "rprk_none";
            case 1L: return "rprk_compound_assignment";
            case 2L: return "rprk_pre_incr_decr";
            case 3L: return "rprk_post_incr_decr";
            case 4L: return "rprk_comma_discard_first";
            case 5L: return "rprk_comma_discard_second";
            default: return "";
        }
    }

    std::string a_rewritten_property_reference_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_rewritten_property_reference_kind_tag(i);
        if (s.empty())
            s = "(a_rewritten_property_reference_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_rewritten_property_reference_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_rewritten_property_reference_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_rewritten_property_reference_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_rewritten_property_reference_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_rewritten_property_reference_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_rewritten_property_reference_kind_tag() {
        return stringify::a_rewritten_property_reference_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/il_def.h line 8436
namespace stringify {
    const char* a_template_param_type_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "tptk_param";
            case 1L: return "tptk_member";
            case 2L: return "tptk_unknown";
            default: return "";
        }
    }

    std::string a_template_param_type_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_template_param_type_kind_tag(i);
        if (s.empty())
            s = "(a_template_param_type_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_template_param_type_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_template_param_type_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_template_param_type_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_template_param_type_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_template_param_type_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_template_param_type_kind_tag() {
        return stringify::a_template_param_type_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/il_def.h line 8702
namespace stringify {
    const char* a_based_type_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "btk_qualified";
            case 1L: return "btk_rvalue_reference";
            case 2L: return "btk_reference";
            case 3L: return "btk_ptr_to_member";
            case 4L: return "btk_unqualified_array_type";
            case 5L: return "btk_handle";
            case 6L: return "btk_tracking_ref";
            case 7L: return "btk_interior_ptr";
            case 8L: return "btk_pin_ptr";
            case 9L: return "btk_cppcx_box";
            case 10L: return "btk_pointer";
            case 11L: return "btk_no_noexcept_exception_spec";
            default: return "";
        }
    }

    std::string a_based_type_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_based_type_kind_tag(i);
        if (s.empty())
            s = "(a_based_type_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_based_type_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L
        };
        static const std::vector<int64_t> retval(values, values + 12);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_based_type_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_based_type_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_based_type_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_based_type_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_based_type_kind_tag() {
        return stringify::a_based_type_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/il_def.h line 8763
namespace stringify {
    const char* a_pointer_modifier_tag(int64_t i) {
        switch (i) {
            case 0L: return "pmt_ptr32";
            case 1L: return "pmt_ptr64";
            case 2L: return "pmt_sptr";
            case 3L: return "pmt_uptr";
            case 4L: return "pmt_last";
            default: return "";
        }
    }

    std::string a_pointer_modifier_tag(int64_t i, const std::string &strip) {
        std::string s = a_pointer_modifier_tag(i);
        if (s.empty())
            s = "(a_pointer_modifier_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_pointer_modifier_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_pointer_modifier_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_pointer_modifier_tag(i);
        if (retval.empty()) {
            retval = "(a_pointer_modifier_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_pointer_modifier_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_pointer_modifier_tag() {
        return stringify::a_pointer_modifier_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/il_def.h line 9944
namespace stringify {
    const char* a_storage_class_tag(int64_t i) {
        switch (i) {
            case 0L: return "sc_unspecified";
            case 1L: return "sc_extern";
            case 2L: return "sc_static";
            case 3L: return "sc_auto";
            case 4L: return "sc_typedef";
            case 5L: return "sc_register";
            case 6L: return "sc_asm";
            case 7L: return "sc_last";
            default: return "";
        }
    }

    std::string a_storage_class_tag(int64_t i, const std::string &strip) {
        std::string s = a_storage_class_tag(i);
        if (s.empty())
            s = "(a_storage_class_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_storage_class_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_storage_class_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_storage_class_tag(i);
        if (retval.empty()) {
            retval = "(a_storage_class_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_storage_class_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_storage_class_tag() {
        return stringify::a_storage_class_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/il_def.h line 11066
namespace stringify {
    const char* an_opname_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "onk_none";
            case 1L: return "onk_new";
            case 2L: return "onk_delete";
            case 3L: return "onk_array_new";
            case 4L: return "onk_array_delete";
            case 5L: return "onk_plus";
            case 6L: return "onk_minus";
            case 7L: return "onk_star";
            case 8L: return "onk_divide";
            case 9L: return "onk_remainder";
            case 10L: return "onk_excl_or";
            case 11L: return "onk_ampersand";
            case 12L: return "onk_or";
            case 13L: return "onk_compl";
            case 14L: return "onk_not";
            case 15L: return "onk_assign";
            case 16L: return "onk_lt";
            case 17L: return "onk_gt";
            case 18L: return "onk_plus_assign";
            case 19L: return "onk_minus_assign";
            case 20L: return "onk_times_assign";
            case 21L: return "onk_divide_assign";
            case 22L: return "onk_remainder_assign";
            case 23L: return "onk_excl_or_assign";
            case 24L: return "onk_and_assign";
            case 25L: return "onk_or_assign";
            case 26L: return "onk_shift_left";
            case 27L: return "onk_shift_right";
            case 28L: return "onk_shift_right_assign";
            case 29L: return "onk_shift_left_assign";
            case 30L: return "onk_eq";
            case 31L: return "onk_ne";
            case 32L: return "onk_le";
            case 33L: return "onk_ge";
            case 34L: return "onk_spaceship";
            case 35L: return "onk_and_and";
            case 36L: return "onk_or_or";
            case 37L: return "onk_plus_plus";
            case 38L: return "onk_minus_minus";
            case 39L: return "onk_comma";
            case 40L: return "onk_arrow_star";
            case 41L: return "onk_arrow";
            case 42L: return "onk_function_call";
            case 43L: return "onk_subscript";
            case 44L: return "onk_question";
            case 45L: return "onk_gnu_min";
            case 46L: return "onk_gnu_max";
            case 47L: return "onk_await";
            case 48L: return "onk_last";
            default: return "";
        }
    }

    std::string an_opname_kind_tag(int64_t i, const std::string &strip) {
        std::string s = an_opname_kind_tag(i);
        if (s.empty())
            s = "(an_opname_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_opname_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L
        };
        static const std::vector<int64_t> retval(values, values + 49);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_opname_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_opname_kind_tag(i);
        if (retval.empty()) {
            retval = "(an_opname_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_opname_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_opname_kind_tag() {
        return stringify::an_opname_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/il_def.h line 11121
namespace stringify {
    const char* a_ctor_or_dtor_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "cdk_none";
            case 1L: return "cdk_complete";
            case 2L: return "cdk_subobject";
            case 3L: return "cdk_deleting";
            case 4L: return "cdk_delegation";
            case 5L: return "cdk_last";
            default: return "";
        }
    }

    std::string a_ctor_or_dtor_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_ctor_or_dtor_kind_tag(i);
        if (s.empty())
            s = "(a_ctor_or_dtor_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_ctor_or_dtor_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_ctor_or_dtor_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_ctor_or_dtor_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_ctor_or_dtor_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_ctor_or_dtor_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_ctor_or_dtor_kind_tag() {
        return stringify::a_ctor_or_dtor_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/il_def.h line 12399
namespace stringify {
    const char* an_expr_node_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "enk_error";
            case 1L: return "enk_operation";
            case 2L: return "enk_constant";
            case 3L: return "enk_variable";
            case 4L: return "enk_field";
            case 5L: return "enk_temp_init";
            case 6L: return "enk_lambda";
            case 7L: return "enk_new_delete";
            case 8L: return "enk_gcnew";
            case 9L: return "enk_throw";
            case 10L: return "enk_condition";
            case 11L: return "enk_object_lifetime";
            case 12L: return "enk_typeid";
            case 13L: return "enk_sizeof";
            case 14L: return "enk_sizeof_pack";
            case 15L: return "enk_alignof";
            case 16L: return "enk_address_of_ellipsis";
            case 17L: return "enk_statement";
            case 18L: return "enk_reuse_value";
            case 19L: return "enk_lowered_eh_construct";
            case 20L: return "enk_result_of_overriding_function";
            case 21L: return "enk_routine";
            case 22L: return "enk_vla_dealloc";
            case 23L: return "enk_type_operand";
            case 24L: return "enk_builtin_operation";
            case 25L: return "enk_param_ref";
            case 26L: return "enk_braced_init_list";
            case 27L: return "enk_c11_generic";
            case 28L: return "enk_builtin_choose_expr";
            case 29L: return "enk_yield";
            case 30L: return "enk_await";
            case 31L: return "enk_fold";
            case 32L: return "enk_initializer";
            case 33L: return "enk_last";
            default: return "";
        }
    }

    std::string an_expr_node_kind_tag(int64_t i, const std::string &strip) {
        std::string s = an_expr_node_kind_tag(i);
        if (s.empty())
            s = "(an_expr_node_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_expr_node_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L
        };
        static const std::vector<int64_t> retval(values, values + 34);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_expr_node_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_expr_node_kind_tag(i);
        if (retval.empty()) {
            retval = "(an_expr_node_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_expr_node_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_expr_node_kind_tag() {
        return stringify::an_expr_node_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/il_def.h line 12524
namespace stringify {
    const char* a_lowered_eh_construct_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "leck_caught_object_address";
            case 1L: return "leck_thrown_object_address";
            case 2L: return "leck_cleanup_state";
            case 3L: return "leck_unreachable_cleanup_state";
            case 4L: return "leck_function_prologue";
            case 5L: return "leck_function_epilogue";
            case 6L: return "leck_catch_epilogue";
            case 7L: return "leck_try_epilogue";
            case 8L: return "leck_exception_caught";
            case 9L: return "leck_exception_started";
            case 10L: return "leck_initialization_completed";
            case 11L: return "leck_internal_try";
            default: return "";
        }
    }

    std::string a_lowered_eh_construct_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_lowered_eh_construct_kind_tag(i);
        if (s.empty())
            s = "(a_lowered_eh_construct_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_lowered_eh_construct_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L
        };
        static const std::vector<int64_t> retval(values, values + 12);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_lowered_eh_construct_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_lowered_eh_construct_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_lowered_eh_construct_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_lowered_eh_construct_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_lowered_eh_construct_kind_tag() {
        return stringify::a_lowered_eh_construct_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/il_def.h line 12566
namespace stringify {
    const char* an_expr_operator_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "eok_address_of";
            case 1L: return "eok_reference_to";
            case 2L: return "eok_handle_to";
            case 3L: return "eok_indirect";
            case 4L: return "eok_ref_indirect";
            case 5L: return "eok_cast";
            case 6L: return "eok_lvalue_cast";
            case 7L: return "eok_ref_cast";
            case 8L: return "eok_lvalue_adjust";
            case 9L: return "eok_class_rvalue_adjust";
            case 10L: return "eok_box";
            case 11L: return "eok_handle_to_box";
            case 12L: return "eok_unbox";
            case 13L: return "eok_unbox_lvalue";
            case 14L: return "eok_base_class_cast";
            case 15L: return "eok_derived_class_cast";
            case 16L: return "eok_pm_base_class_cast";
            case 17L: return "eok_pm_derived_class_cast";
            case 18L: return "eok_dynamic_cast";
            case 19L: return "eok_ref_dynamic_cast";
            case 20L: return "eok_bool_cast";
            case 21L: return "eok_array_to_pointer";
            case 22L: return "eok_dot_vacuous_destructor_call";
            case 23L: return "eok_points_to_vacuous_destructor_call";
            case 24L: return "eok_assume";
            case 25L: return "eok_noexcept";
            case 26L: return "eok_parens";
            case 27L: return "eok_negate";
            case 28L: return "eok_unary_plus";
            case 29L: return "eok_complement";
            case 30L: return "eok_not";
            case 31L: return "eok_vector_not";
            case 32L: return "eok_vector_fill";
            case 33L: return "eok_xconj";
            case 34L: return "eok_real_part";
            case 35L: return "eok_imag_part";
            case 36L: return "eok_post_incr";
            case 37L: return "eok_post_decr";
            case 38L: return "eok_pre_incr";
            case 39L: return "eok_pre_decr";
            case 40L: return "eok_add";
            case 41L: return "eok_subtract";
            case 42L: return "eok_multiply";
            case 43L: return "eok_divide";
            case 44L: return "eok_remainder";
            case 45L: return "eok_jmultiply";
            case 46L: return "eok_jdivide";
            case 47L: return "eok_fjadd";
            case 48L: return "eok_jfadd";
            case 49L: return "eok_fjsubtract";
            case 50L: return "eok_jfsubtract";
            case 51L: return "eok_padd";
            case 52L: return "eok_psubtract";
            case 53L: return "eok_pdiff";
            case 54L: return "eok_shiftl";
            case 55L: return "eok_shiftr";
            case 56L: return "eok_and";
            case 57L: return "eok_or";
            case 58L: return "eok_xor";
            case 59L: return "eok_eq";
            case 60L: return "eok_ne";
            case 61L: return "eok_gt";
            case 62L: return "eok_lt";
            case 63L: return "eok_ge";
            case 64L: return "eok_le";
            case 65L: return "eok_spaceship";
            case 66L: return "eok_vector_eq";
            case 67L: return "eok_vector_ne";
            case 68L: return "eok_vector_gt";
            case 69L: return "eok_vector_lt";
            case 70L: return "eok_vector_ge";
            case 71L: return "eok_vector_le";
            case 72L: return "eok_gnu_min";
            case 73L: return "eok_gnu_max";
            case 74L: return "eok_assign";
            case 75L: return "eok_add_assign";
            case 76L: return "eok_subtract_assign";
            case 77L: return "eok_multiply_assign";
            case 78L: return "eok_divide_assign";
            case 79L: return "eok_remainder_assign";
            case 80L: return "eok_shiftl_assign";
            case 81L: return "eok_shiftr_assign";
            case 82L: return "eok_and_assign";
            case 83L: return "eok_or_assign";
            case 84L: return "eok_xor_assign";
            case 85L: return "eok_padd_assign";
            case 86L: return "eok_psubtract_assign";
            case 87L: return "eok_bassign";
            case 88L: return "eok_land";
            case 89L: return "eok_lor";
            case 90L: return "eok_vector_land";
            case 91L: return "eok_vector_lor";
            case 92L: return "eok_comma";
            case 93L: return "eok_subscript";
            case 94L: return "eok_vector_subscript";
            case 95L: return "eok_dot_field";
            case 96L: return "eok_points_to_field";
            case 97L: return "eok_pm_field";
            case 98L: return "eok_pm_points_to_field";
            case 99L: return "eok_dot_pm_func_ptr";
            case 100L: return "eok_points_to_pm_func_ptr";
            case 101L: return "eok_dot_static";
            case 102L: return "eok_points_to_static";
            case 103L: return "eok_virtual_function_ptr";
            case 104L: return "eok_question";
            case 105L: return "eok_vector_question";
            case 106L: return "eok_call";
            case 107L: return "eok_dot_member_call";
            case 108L: return "eok_points_to_member_call";
            case 109L: return "eok_dot_pm_call";
            case 110L: return "eok_points_to_pm_call";
            case 111L: return "eok_cli_subscript";
            case 112L: return "eok_va_start";
            case 113L: return "eok_va_arg";
            case 114L: return "eok_va_end";
            case 115L: return "eok_va_copy";
            case 116L: return "eok_va_start_single_operand";
            case 117L: return "eok_lvalue";
            case 118L: return "eok_await";
            case 119L: return "eok_yield";
            case 120L: return "eok_error";
            case 121L: return "eok_last";
            default: return "";
        }
    }

    std::string an_expr_operator_kind_tag(int64_t i, const std::string &strip) {
        std::string s = an_expr_operator_kind_tag(i);
        if (s.empty())
            s = "(an_expr_operator_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_expr_operator_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L,
            58L,
            59L,
            60L,
            61L,
            62L,
            63L,
            64L,
            65L,
            66L,
            67L,
            68L,
            69L,
            70L,
            71L,
            72L,
            73L,
            74L,
            75L,
            76L,
            77L,
            78L,
            79L,
            80L,
            81L,
            82L,
            83L,
            84L,
            85L,
            86L,
            87L,
            88L,
            89L,
            90L,
            91L,
            92L,
            93L,
            94L,
            95L,
            96L,
            97L,
            98L,
            99L,
            100L,
            101L,
            102L,
            103L,
            104L,
            105L,
            106L,
            107L,
            108L,
            109L,
            110L,
            111L,
            112L,
            113L,
            114L,
            115L,
            116L,
            117L,
            118L,
            119L,
            120L,
            121L
        };
        static const std::vector<int64_t> retval(values, values + 122);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_expr_operator_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_expr_operator_kind_tag(i);
        if (retval.empty()) {
            retval = "(an_expr_operator_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_expr_operator_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_expr_operator_kind_tag() {
        return stringify::an_expr_operator_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/il_def.h line 13090
namespace stringify {
    const char* a_builtin_operation_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "bok_offsetof";
            case 1L: return "bok_has_assign";
            case 2L: return "bok_has_copy";
            case 3L: return "bok_has_nothrow_assign";
            case 4L: return "bok_has_nothrow_constructor";
            case 5L: return "bok_has_nothrow_copy";
            case 6L: return "bok_has_trivial_assign";
            case 7L: return "bok_has_trivial_constructor";
            case 8L: return "bok_has_trivial_copy";
            case 9L: return "bok_has_trivial_destructor";
            case 10L: return "bok_has_user_destructor";
            case 11L: return "bok_has_virtual_destructor";
            case 12L: return "bok_is_abstract";
            case 13L: return "bok_is_base_of";
            case 14L: return "bok_is_class";
            case 15L: return "bok_is_convertible_to";
            case 16L: return "bok_is_empty";
            case 17L: return "bok_is_enum";
            case 18L: return "bok_is_pod";
            case 19L: return "bok_is_polymorphic";
            case 20L: return "bok_is_union";
            case 21L: return "bok_types_compatible";
            case 22L: return "bok_intaddr";
            case 23L: return "bok_is_trivial";
            case 24L: return "bok_is_standard_layout";
            case 25L: return "bok_is_trivially_copyable";
            case 26L: return "bok_is_literal_type";
            case 27L: return "bok_has_trivial_move_constructor";
            case 28L: return "bok_has_trivial_move_assign";
            case 29L: return "bok_has_nothrow_move_assign";
            case 30L: return "bok_is_constructible";
            case 31L: return "bok_is_nothrow_constructible";
            case 32L: return "bok_has_finalizer";
            case 33L: return "bok_is_delegate";
            case 34L: return "bok_is_interface_class";
            case 35L: return "bok_is_ref_array";
            case 36L: return "bok_is_ref_class";
            case 37L: return "bok_is_sealed";
            case 38L: return "bok_is_simple_value_class";
            case 39L: return "bok_is_value_class";
            case 40L: return "bok_is_final";
            case 41L: return "bok_is_trivially_constructible";
            case 42L: return "bok_is_destructible";
            case 43L: return "bok_is_nothrow_destructible";
            case 44L: return "bok_is_trivially_destructible";
            case 45L: return "bok_is_nothrow_assignable";
            case 46L: return "bok_is_trivially_assignable";
            case 47L: return "bok_builtin_shuffle";
            case 48L: return "bok_builtin_complex";
            case 49L: return "bok_is_valid_winrt_type";
            case 50L: return "bok_is_win_class";
            case 51L: return "bok_is_win_interface";
            case 52L: return "bok_builtin_shufflevector";
            case 53L: return "bok_builtin_convertvector";
            case 54L: return "bok_is_assignable";
            case 55L: return "bok_is_assignable_no_precondition_check";
            case 56L: return "bok_is_trivially_copy_assignable";
            case 57L: return "bok_builtin_addressof";
            case 58L: return "bok_has_unique_object_representations";
            case 59L: return "bok_is_aggregate";
            case 60L: return "bok_reference_binds_to_temporary";
            case 61L: return "bok_is_same";
            case 62L: return "bok_is_same_as";
            case 63L: return "bok_is_function";
            case 64L: return "bok_last";
            default: return "";
        }
    }

    std::string a_builtin_operation_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_builtin_operation_kind_tag(i);
        if (s.empty())
            s = "(a_builtin_operation_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_builtin_operation_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L,
            58L,
            59L,
            60L,
            61L,
            62L,
            63L,
            64L
        };
        static const std::vector<int64_t> retval(values, values + 65);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_builtin_operation_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_builtin_operation_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_builtin_operation_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_builtin_operation_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_builtin_operation_kind_tag() {
        return stringify::a_builtin_operation_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/il_def.h line 14313
namespace stringify {
    const char* a_statement_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "stmk_expr";
            case 1L: return "stmk_if";
            case 2L: return "stmk_constexpr_if";
            case 3L: return "stmk_while";
            case 4L: return "stmk_goto";
            case 5L: return "stmk_label";
            case 6L: return "stmk_return";
            case 7L: return "stmk_coroutine";
            case 8L: return "stmk_coroutine_return";
            case 9L: return "stmk_block";
            case 10L: return "stmk_end_test_while";
            case 11L: return "stmk_for";
            case 12L: return "stmk_range_based_for";
            case 13L: return "stmk_for_each";
            case 14L: return "stmk_switch_case";
            case 15L: return "stmk_switch";
            case 16L: return "stmk_init";
            case 17L: return "stmk_asm";
            case 18L: return "stmk_asm_func_body";
            case 19L: return "stmk_try_block";
            case 20L: return "stmk_microsoft_try";
            case 21L: return "stmk_decl";
            case 22L: return "stmk_set_vla_size";
            case 23L: return "stmk_vla_decl";
            case 24L: return "stmk_upc_notify";
            case 25L: return "stmk_upc_wait";
            case 26L: return "stmk_upc_barrier";
            case 27L: return "stmk_upc_fence";
            case 28L: return "stmk_upc_forall";
            case 29L: return "stmk_assigned_goto";
            case 30L: return "stmk_empty";
            case 31L: return "stmk_stmt_expr_result";
            case 32L: return "stmk_last";
            default: return "";
        }
    }

    std::string a_statement_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_statement_kind_tag(i);
        if (s.empty())
            s = "(a_statement_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_statement_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L
        };
        static const std::vector<int64_t> retval(values, values + 33);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_statement_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_statement_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_statement_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_statement_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_statement_kind_tag() {
        return stringify::a_statement_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/il_def.h line 14542
namespace stringify {
    const char* a_for_each_pattern_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "sfepk_none";
            case 1L: return "sfepk_stl_pattern";
            case 2L: return "sfepk_cli_pattern";
            case 3L: return "sfepk_cli_array_pattern";
            case 4L: return "sfepk_array_pattern";
            default: return "";
        }
    }

    std::string a_for_each_pattern_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_for_each_pattern_kind_tag(i);
        if (s.empty())
            s = "(a_for_each_pattern_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_for_each_pattern_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_for_each_pattern_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_for_each_pattern_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_for_each_pattern_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_for_each_pattern_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_for_each_pattern_kind_tag() {
        return stringify::a_for_each_pattern_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/il_def.h line 15361
namespace stringify {
    const char* a_constructor_init_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "cik_virtual_base_class";
            case 1L: return "cik_direct_base_class";
            case 2L: return "cik_field";
            case 3L: return "cik_delegation";
            default: return "";
        }
    }

    std::string a_constructor_init_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_constructor_init_kind_tag(i);
        if (s.empty())
            s = "(a_constructor_init_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_constructor_init_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_constructor_init_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_constructor_init_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_constructor_init_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_constructor_init_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_constructor_init_kind_tag() {
        return stringify::a_constructor_init_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/il_def.h line 15587
namespace stringify {
    const char* a_generic_constraint_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "gck_none";
            case 1L: return "gck_type";
            case 2L: return "gck_naked_type_param";
            case 3L: return "gck_ref_class";
            case 4L: return "gck_value_class";
            case 5L: return "gck_gcnew";
            case 6L: return "gck_fail";
            default: return "";
        }
    }

    std::string a_generic_constraint_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_generic_constraint_kind_tag(i);
        if (s.empty())
            s = "(a_generic_constraint_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_generic_constraint_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_generic_constraint_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_generic_constraint_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_generic_constraint_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_generic_constraint_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_generic_constraint_kind_tag() {
        return stringify::a_generic_constraint_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/il_def.h line 15675
namespace stringify {
    const char* a_template_parameter_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "tpk_error";
            case 1L: return "tpk_type";
            case 2L: return "tpk_nontype";
            case 3L: return "tpk_template";
            default: return "";
        }
    }

    std::string a_template_parameter_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_template_parameter_kind_tag(i);
        if (s.empty())
            s = "(a_template_parameter_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_template_parameter_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_template_parameter_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_template_parameter_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_template_parameter_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_template_parameter_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_template_parameter_kind_tag() {
        return stringify::a_template_parameter_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/il_def.h line 15779
namespace stringify {
    const char* a_template_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "templk_none";
            case 1L: return "templk_class";
            case 2L: return "templk_function";
            case 3L: return "templk_variable";
            case 4L: return "templk_member_function";
            case 5L: return "templk_static_data_member";
            case 6L: return "templk_member_class";
            case 7L: return "templk_member_enum";
            case 8L: return "templk_template_template_param";
            default: return "";
        }
    }

    std::string a_template_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_template_kind_tag(i);
        if (s.empty())
            s = "(a_template_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_template_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L
        };
        static const std::vector<int64_t> retval(values, values + 9);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_template_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_template_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_template_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_template_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_template_kind_tag() {
        return stringify::a_template_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/il_def.h line 16125
namespace stringify {
    const char* an_object_lifetime_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "olk_global_static";
            case 1L: return "olk_block";
            case 2L: return "olk_block_after_label";
            case 3L: return "olk_function_static";
            case 4L: return "olk_expr_temporary";
            case 5L: return "olk_try_block";
            default: return "";
        }
    }

    std::string an_object_lifetime_kind_tag(int64_t i, const std::string &strip) {
        std::string s = an_object_lifetime_kind_tag(i);
        if (s.empty())
            s = "(an_object_lifetime_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_object_lifetime_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_object_lifetime_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_object_lifetime_kind_tag(i);
        if (retval.empty()) {
            retval = "(an_object_lifetime_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_object_lifetime_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_object_lifetime_kind_tag() {
        return stringify::an_object_lifetime_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/il_def.h line 16268
namespace stringify {
    const char* an_ms_attribute_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "msak_none";
            case 1L: return "msak_unrecognized";
            case 2L: return "msak_misc";
            case 3L: return "msak_uuid";
            case 4L: return "msak_custom";
            case 5L: return "msak_edg_test";
            case 6L: return "msak_coclass";
            case 7L: return "msak_no_injected_text";
            case 8L: return "msak_last";
            default: return "";
        }
    }

    std::string an_ms_attribute_kind_tag(int64_t i, const std::string &strip) {
        std::string s = an_ms_attribute_kind_tag(i);
        if (s.empty())
            s = "(an_ms_attribute_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_ms_attribute_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L
        };
        static const std::vector<int64_t> retval(values, values + 9);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_ms_attribute_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_ms_attribute_kind_tag(i);
        if (retval.empty()) {
            retval = "(an_ms_attribute_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_ms_attribute_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_ms_attribute_kind_tag() {
        return stringify::an_ms_attribute_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/il_def.h line 16290
namespace stringify {
    const char* an_ms_attribute_arg_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "msaak_none";
            case 1L: return "msaak_integer";
            case 2L: return "msaak_boolean";
            case 3L: return "msaak_string";
            case 4L: return "msaak_uuid";
            case 5L: return "msaak_enumeration";
            case 6L: return "msaak_other";
            default: return "";
        }
    }

    std::string an_ms_attribute_arg_kind_tag(int64_t i, const std::string &strip) {
        std::string s = an_ms_attribute_arg_kind_tag(i);
        if (s.empty())
            s = "(an_ms_attribute_arg_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_ms_attribute_arg_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_ms_attribute_arg_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_ms_attribute_arg_kind_tag(i);
        if (retval.empty()) {
            retval = "(an_ms_attribute_arg_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_ms_attribute_arg_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_ms_attribute_arg_kind_tag() {
        return stringify::an_ms_attribute_arg_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/il_def.h line 16680
namespace stringify {
    const char* a_scope_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "sck_file";
            case 1L: return "sck_func_prototype";
            case 2L: return "sck_block";
            case 3L: return "sck_namespace";
            case 4L: return "sck_namespace_extension";
            case 5L: return "sck_namespace_reactivation";
            case 6L: return "sck_class_struct_union";
            case 7L: return "sck_class_reactivation";
            case 8L: return "sck_template_declaration";
            case 9L: return "sck_template_instantiation";
            case 10L: return "sck_instantiation_context";
            case 11L: return "sck_pragma";
            case 12L: return "sck_function_access";
            case 13L: return "sck_condition";
            case 14L: return "sck_enum";
            case 15L: return "sck_function";
            case 16L: return "sck_none";
            default: return "";
        }
    }

    std::string a_scope_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_scope_kind_tag(i);
        if (s.empty())
            s = "(a_scope_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_scope_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L
        };
        static const std::vector<int64_t> retval(values, values + 17);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_scope_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_scope_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_scope_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_scope_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_scope_kind_tag() {
        return stringify::a_scope_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/builtin_defs.h line 25
namespace stringify {
    const char* a_builtin_function_type_index(int64_t i) {
        switch (i) {
            case 0L: return "bfti_000db6619e";
            case 1L: return "bfti_001e209a45";
            case 2L: return "bfti_003d6de10d";
            case 3L: return "bfti_003fa00724";
            case 4L: return "bfti_004086891a";
            case 5L: return "bfti_0056490ab6";
            case 6L: return "bfti_0063dc7557";
            case 7L: return "bfti_00a69d8b4b";
            case 8L: return "bfti_00bfd9928a";
            case 9L: return "bfti_00cce8bfc5";
            case 10L: return "bfti_00d9b248c7";
            case 11L: return "bfti_00f5fef98c";
            case 12L: return "bfti_0125fc19ed";
            case 13L: return "bfti_013bed6256";
            case 14L: return "bfti_015b244f65";
            case 15L: return "bfti_01678b0e31";
            case 16L: return "bfti_018e095f15";
            case 17L: return "bfti_019980e3fc";
            case 18L: return "bfti_01a390af99";
            case 19L: return "bfti_01ad6f2ea7";
            case 20L: return "bfti_01b5072cbd";
            case 21L: return "bfti_01ed60f438";
            case 22L: return "bfti_02075a7818";
            case 23L: return "bfti_021feda6a2";
            case 24L: return "bfti_0261491605";
            case 25L: return "bfti_02a7d41178";
            case 26L: return "bfti_02b5a15283";
            case 27L: return "bfti_02e6f23732";
            case 28L: return "bfti_030dd242f7";
            case 29L: return "bfti_0360cd1add";
            case 30L: return "bfti_03aa168638";
            case 31L: return "bfti_03c7ae9ece";
            case 32L: return "bfti_03d5cb95bf";
            case 33L: return "bfti_03e0a9391a";
            case 34L: return "bfti_03ea8a6e53";
            case 35L: return "bfti_04022dca7a";
            case 36L: return "bfti_041f722932";
            case 37L: return "bfti_04228dccc6";
            case 38L: return "bfti_0438d503e1";
            case 39L: return "bfti_043f0f6bdd";
            case 40L: return "bfti_043f1742a6";
            case 41L: return "bfti_049f994f52";
            case 42L: return "bfti_04a02a19bd";
            case 43L: return "bfti_04b6378005";
            case 44L: return "bfti_04c4ebcda3";
            case 45L: return "bfti_0506407bd3";
            case 46L: return "bfti_050f43759e";
            case 47L: return "bfti_053aad4f6b";
            case 48L: return "bfti_054ab132f8";
            case 49L: return "bfti_0553518b14";
            case 50L: return "bfti_05d1694fef";
            case 51L: return "bfti_05db792456";
            case 52L: return "bfti_05f0e64002";
            case 53L: return "bfti_05f212d199";
            case 54L: return "bfti_05f2b70bad";
            case 55L: return "bfti_0635a955f7";
            case 56L: return "bfti_06786e9f2b";
            case 57L: return "bfti_067adc41e3";
            case 58L: return "bfti_069e99e161";
            case 59L: return "bfti_06c519c321";
            case 60L: return "bfti_06ee14db2f";
            case 61L: return "bfti_06f1e4b6db";
            case 62L: return "bfti_072a41f47f";
            case 63L: return "bfti_073f5e849d";
            case 64L: return "bfti_076d9dc90a";
            case 65L: return "bfti_076e140dd7";
            case 66L: return "bfti_07734d6839";
            case 67L: return "bfti_078c102556";
            case 68L: return "bfti_079010e56c";
            case 69L: return "bfti_0792fee631";
            case 70L: return "bfti_079f4de5a6";
            case 71L: return "bfti_07c96ecc2b";
            case 72L: return "bfti_07cec8b399";
            case 73L: return "bfti_08224e710e";
            case 74L: return "bfti_0827f0a803";
            case 75L: return "bfti_0829edf422";
            case 76L: return "bfti_083d2d8dcd";
            case 77L: return "bfti_08550e996a";
            case 78L: return "bfti_085bb00c77";
            case 79L: return "bfti_0878a3dbd1";
            case 80L: return "bfti_087b01bf81";
            case 81L: return "bfti_087be52f11";
            case 82L: return "bfti_088bc89552";
            case 83L: return "bfti_08aba71b16";
            case 84L: return "bfti_08d2223f23";
            case 85L: return "bfti_08d56cfd51";
            case 86L: return "bfti_08f83fcc74";
            case 87L: return "bfti_090d29b6c6";
            case 88L: return "bfti_094a4a928e";
            case 89L: return "bfti_09629c2306";
            case 90L: return "bfti_09671bacac";
            case 91L: return "bfti_096a3b13bd";
            case 92L: return "bfti_0973c161e2";
            case 93L: return "bfti_097d49d2c4";
            case 94L: return "bfti_0990c2bd50";
            case 95L: return "bfti_0997187e9a";
            case 96L: return "bfti_09a3fdab76";
            case 97L: return "bfti_09cc70d50c";
            case 98L: return "bfti_09dc3854c8";
            case 99L: return "bfti_09fbe2b5e1";
            case 100L: return "bfti_0a0ae45507";
            case 101L: return "bfti_0a19a2d5c0";
            case 102L: return "bfti_0a1fae4344";
            case 103L: return "bfti_0a2e9f10a4";
            case 104L: return "bfti_0a4a1950d1";
            case 105L: return "bfti_0a4a8dc832";
            case 106L: return "bfti_0ab459d8f9";
            case 107L: return "bfti_0ad0083bce";
            case 108L: return "bfti_0ad5e8efd6";
            case 109L: return "bfti_0ae7c3c252";
            case 110L: return "bfti_0b144dbb6d";
            case 111L: return "bfti_0b1a7c543d";
            case 112L: return "bfti_0b3e1a0d9c";
            case 113L: return "bfti_0b493e41c9";
            case 114L: return "bfti_0b4db9a264";
            case 115L: return "bfti_0b646cddc6";
            case 116L: return "bfti_0b667519de";
            case 117L: return "bfti_0b875308d0";
            case 118L: return "bfti_0bb7f15d41";
            case 119L: return "bfti_0bcb8b17b5";
            case 120L: return "bfti_0bce84f3ab";
            case 121L: return "bfti_0bd530539f";
            case 122L: return "bfti_0bdff635b8";
            case 123L: return "bfti_0c0e8645bc";
            case 124L: return "bfti_0c12f9b9d2";
            case 125L: return "bfti_0c1ce1dbd8";
            case 126L: return "bfti_0c1d031183";
            case 127L: return "bfti_0c48dcecd8";
            case 128L: return "bfti_0cd91d57ab";
            case 129L: return "bfti_0ceb38c49d";
            case 130L: return "bfti_0d2af5ce76";
            case 131L: return "bfti_0d44f81ccc";
            case 132L: return "bfti_0d584dbeaa";
            case 133L: return "bfti_0d6f1fdfcb";
            case 134L: return "bfti_0d7ec2a155";
            case 135L: return "bfti_0d9a31fcc7";
            case 136L: return "bfti_0da2b2ac63";
            case 137L: return "bfti_0da3b4892e";
            case 138L: return "bfti_0dac31fc8d";
            case 139L: return "bfti_0ddee3dcb1";
            case 140L: return "bfti_0dfa3c8404";
            case 141L: return "bfti_0e11e9b7d8";
            case 142L: return "bfti_0e15c9775d";
            case 143L: return "bfti_0e21d503a9";
            case 144L: return "bfti_0e3fefe412";
            case 145L: return "bfti_0e4fd898c7";
            case 146L: return "bfti_0e5906147f";
            case 147L: return "bfti_0e6a4e2beb";
            case 148L: return "bfti_0e6eb99a03";
            case 149L: return "bfti_0e7894567a";
            case 150L: return "bfti_0e89e8268b";
            case 151L: return "bfti_0e9b9d2319";
            case 152L: return "bfti_0eadfe1dba";
            case 153L: return "bfti_0ec7628210";
            case 154L: return "bfti_0ee8659d68";
            case 155L: return "bfti_0ee9cb5436";
            case 156L: return "bfti_0f050f2633";
            case 157L: return "bfti_0f097d6f7e";
            case 158L: return "bfti_0f2fd6445b";
            case 159L: return "bfti_0f33396cec";
            case 160L: return "bfti_0f3903a67e";
            case 161L: return "bfti_0f54e1c803";
            case 162L: return "bfti_0f61c53ab9";
            case 163L: return "bfti_0f9efae8ce";
            case 164L: return "bfti_0fa4f4bf2b";
            case 165L: return "bfti_0fb2ceae5f";
            case 166L: return "bfti_0fc006bdcc";
            case 167L: return "bfti_0fe17cad73";
            case 168L: return "bfti_0fedb54ba6";
            case 169L: return "bfti_10154e817b";
            case 170L: return "bfti_10275706e1";
            case 171L: return "bfti_1041c6a791";
            case 172L: return "bfti_105a2c6d64";
            case 173L: return "bfti_106f9cad20";
            case 174L: return "bfti_10ac05c17e";
            case 175L: return "bfti_10deec183f";
            case 176L: return "bfti_10e2a64785";
            case 177L: return "bfti_110084a10b";
            case 178L: return "bfti_115865b8c5";
            case 179L: return "bfti_117b024bdc";
            case 180L: return "bfti_11a957515b";
            case 181L: return "bfti_11ab1a3a1f";
            case 182L: return "bfti_11bf806960";
            case 183L: return "bfti_11ef997505";
            case 184L: return "bfti_11f28b741a";
            case 185L: return "bfti_122fefe0ac";
            case 186L: return "bfti_123ef40d00";
            case 187L: return "bfti_12489ae6ff";
            case 188L: return "bfti_12a19d76dc";
            case 189L: return "bfti_12cd2a04b6";
            case 190L: return "bfti_12e249d08f";
            case 191L: return "bfti_12fd3e8468";
            case 192L: return "bfti_133b9a35bb";
            case 193L: return "bfti_1345213053";
            case 194L: return "bfti_135c501a56";
            case 195L: return "bfti_1363dd796e";
            case 196L: return "bfti_138d138eb0";
            case 197L: return "bfti_13b7be6f37";
            case 198L: return "bfti_13cacdc41f";
            case 199L: return "bfti_13d1000887";
            case 200L: return "bfti_13d9a0dfac";
            case 201L: return "bfti_13f171890a";
            case 202L: return "bfti_1429007ea9";
            case 203L: return "bfti_144f9138f1";
            case 204L: return "bfti_1451b004cc";
            case 205L: return "bfti_147b004c22";
            case 206L: return "bfti_14854d240b";
            case 207L: return "bfti_14970992c6";
            case 208L: return "bfti_14a0812d09";
            case 209L: return "bfti_14edb45f9a";
            case 210L: return "bfti_14f74930d4";
            case 211L: return "bfti_152e047e40";
            case 212L: return "bfti_155380c999";
            case 213L: return "bfti_157092cbcc";
            case 214L: return "bfti_1579595730";
            case 215L: return "bfti_1594b1776b";
            case 216L: return "bfti_15b201edad";
            case 217L: return "bfti_15b3d0e346";
            case 218L: return "bfti_15c82d0793";
            case 219L: return "bfti_15d5e0e930";
            case 220L: return "bfti_15fe1865b6";
            case 221L: return "bfti_16083eecf1";
            case 222L: return "bfti_16232d7f39";
            case 223L: return "bfti_1623a621a8";
            case 224L: return "bfti_164b9005d6";
            case 225L: return "bfti_164fee816a";
            case 226L: return "bfti_165c3107a6";
            case 227L: return "bfti_165e80e4d0";
            case 228L: return "bfti_166ba9bb06";
            case 229L: return "bfti_16771fd934";
            case 230L: return "bfti_16835c8cb2";
            case 231L: return "bfti_16844cfcaa";
            case 232L: return "bfti_1693e41d99";
            case 233L: return "bfti_16c5c386dd";
            case 234L: return "bfti_16c5d1ee97";
            case 235L: return "bfti_16d2dd0c23";
            case 236L: return "bfti_16d896f164";
            case 237L: return "bfti_16e6ce0874";
            case 238L: return "bfti_170a15172f";
            case 239L: return "bfti_172d4ded1c";
            case 240L: return "bfti_1746cd3964";
            case 241L: return "bfti_17655780d3";
            case 242L: return "bfti_176c6e5d8c";
            case 243L: return "bfti_177cb42b60";
            case 244L: return "bfti_17abda1ad3";
            case 245L: return "bfti_17fbb9aabb";
            case 246L: return "bfti_17fe3e6ec9";
            case 247L: return "bfti_17ff20a35b";
            case 248L: return "bfti_1804314289";
            case 249L: return "bfti_180cd5420b";
            case 250L: return "bfti_181ccc9767";
            case 251L: return "bfti_183bb9fd6f";
            case 252L: return "bfti_183cc632bc";
            case 253L: return "bfti_18533dbc3a";
            case 254L: return "bfti_1855e653cb";
            case 255L: return "bfti_1861131fba";
            case 256L: return "bfti_188a8e0cf3";
            case 257L: return "bfti_18b345b24e";
            case 258L: return "bfti_18ba52f8d5";
            case 259L: return "bfti_18d42eabcb";
            case 260L: return "bfti_18e2a741d3";
            case 261L: return "bfti_18e72fe806";
            case 262L: return "bfti_1902b04093";
            case 263L: return "bfti_191e459932";
            case 264L: return "bfti_19243598d1";
            case 265L: return "bfti_1928deaae4";
            case 266L: return "bfti_19372dee47";
            case 267L: return "bfti_194afe8ee8";
            case 268L: return "bfti_19856b98b2";
            case 269L: return "bfti_19ac9c70e8";
            case 270L: return "bfti_1a03221fa2";
            case 271L: return "bfti_1a1ed1aeb3";
            case 272L: return "bfti_1a53f11758";
            case 273L: return "bfti_1a7f5cdd07";
            case 274L: return "bfti_1a82453c56";
            case 275L: return "bfti_1aa81332d2";
            case 276L: return "bfti_1aa8f02153";
            case 277L: return "bfti_1aad43899a";
            case 278L: return "bfti_1af3646a6f";
            case 279L: return "bfti_1afd5d7557";
            case 280L: return "bfti_1b09479a2c";
            case 281L: return "bfti_1b36b7dd5d";
            case 282L: return "bfti_1b3c2c2d9b";
            case 283L: return "bfti_1b4c3772a3";
            case 284L: return "bfti_1b649b8436";
            case 285L: return "bfti_1b8490292a";
            case 286L: return "bfti_1b8b4142f0";
            case 287L: return "bfti_1bd10470e2";
            case 288L: return "bfti_1bd7c59031";
            case 289L: return "bfti_1c5d3c4cd6";
            case 290L: return "bfti_1c6b8b4074";
            case 291L: return "bfti_1c989dc11b";
            case 292L: return "bfti_1ca2328b73";
            case 293L: return "bfti_1ca724dbdf";
            case 294L: return "bfti_1ccf5477ea";
            case 295L: return "bfti_1cd9d945ec";
            case 296L: return "bfti_1cdcc627f2";
            case 297L: return "bfti_1cf7409a55";
            case 298L: return "bfti_1d1d7d60fb";
            case 299L: return "bfti_1d4e5c82bc";
            case 300L: return "bfti_1d6e6627e3";
            case 301L: return "bfti_1d9c36e5de";
            case 302L: return "bfti_1dafa7d608";
            case 303L: return "bfti_1db66d695f";
            case 304L: return "bfti_1dc718c508";
            case 305L: return "bfti_1e0b76f123";
            case 306L: return "bfti_1e17a03d28";
            case 307L: return "bfti_1e1aad424d";
            case 308L: return "bfti_1e1b3b7da0";
            case 309L: return "bfti_1e1daf59c4";
            case 310L: return "bfti_1e5188cc74";
            case 311L: return "bfti_1e6e568d5c";
            case 312L: return "bfti_1e72c68fe4";
            case 313L: return "bfti_1e7863e94a";
            case 314L: return "bfti_1e7ee3d778";
            case 315L: return "bfti_1e805f0fe7";
            case 316L: return "bfti_1e91885a56";
            case 317L: return "bfti_1e951e261f";
            case 318L: return "bfti_1e9c717db7";
            case 319L: return "bfti_1ea1135519";
            case 320L: return "bfti_1ecbaf9c15";
            case 321L: return "bfti_1ecc530d17";
            case 322L: return "bfti_1ed0d6a678";
            case 323L: return "bfti_1ed174492c";
            case 324L: return "bfti_1f02a1e4b8";
            case 325L: return "bfti_1f119532c8";
            case 326L: return "bfti_1f31d40504";
            case 327L: return "bfti_1f545dde45";
            case 328L: return "bfti_1f5e04cb20";
            case 329L: return "bfti_1f5fbc696e";
            case 330L: return "bfti_1f6f079742";
            case 331L: return "bfti_1f70583313";
            case 332L: return "bfti_1f7be337fc";
            case 333L: return "bfti_1fe349f6d3";
            case 334L: return "bfti_1ffd4e60d6";
            case 335L: return "bfti_202b5991f4";
            case 336L: return "bfti_2041624b53";
            case 337L: return "bfti_204ca5bac5";
            case 338L: return "bfti_2071e2464d";
            case 339L: return "bfti_20a5af4621";
            case 340L: return "bfti_20c87514ce";
            case 341L: return "bfti_20d4922265";
            case 342L: return "bfti_20db90a2f5";
            case 343L: return "bfti_21184779dc";
            case 344L: return "bfti_212b0b9eab";
            case 345L: return "bfti_212c142e9e";
            case 346L: return "bfti_212fc8185d";
            case 347L: return "bfti_2161a8acff";
            case 348L: return "bfti_217015e55d";
            case 349L: return "bfti_21793971f6";
            case 350L: return "bfti_218f04023e";
            case 351L: return "bfti_21aa5fec2d";
            case 352L: return "bfti_21aa7c5185";
            case 353L: return "bfti_21b6466dcf";
            case 354L: return "bfti_21c3169413";
            case 355L: return "bfti_21e71befc5";
            case 356L: return "bfti_220cfa4d95";
            case 357L: return "bfti_22228caa6f";
            case 358L: return "bfti_222b95de68";
            case 359L: return "bfti_2238731621";
            case 360L: return "bfti_224444a7fd";
            case 361L: return "bfti_224d69c947";
            case 362L: return "bfti_2260d709bc";
            case 363L: return "bfti_22697324e3";
            case 364L: return "bfti_226ae106f4";
            case 365L: return "bfti_227a57d7d6";
            case 366L: return "bfti_22b228fcd9";
            case 367L: return "bfti_22bb934c05";
            case 368L: return "bfti_22fd32d531";
            case 369L: return "bfti_22fdc9ba40";
            case 370L: return "bfti_2309315d4d";
            case 371L: return "bfti_230c54c0f6";
            case 372L: return "bfti_231195c162";
            case 373L: return "bfti_233ee2cc6b";
            case 374L: return "bfti_2342d8ed5d";
            case 375L: return "bfti_234978f903";
            case 376L: return "bfti_235ac0fe86";
            case 377L: return "bfti_235d6c3e2c";
            case 378L: return "bfti_23c0dca960";
            case 379L: return "bfti_23d48c14f7";
            case 380L: return "bfti_23ee1d49bd";
            case 381L: return "bfti_23f8b1cc1d";
            case 382L: return "bfti_240db23826";
            case 383L: return "bfti_24124c69a5";
            case 384L: return "bfti_2417476ffe";
            case 385L: return "bfti_241f446680";
            case 386L: return "bfti_2421c7878b";
            case 387L: return "bfti_242803315b";
            case 388L: return "bfti_244ed5fe2c";
            case 389L: return "bfti_24620a103e";
            case 390L: return "bfti_2478fe37ff";
            case 391L: return "bfti_247f8d5dee";
            case 392L: return "bfti_249257dea6";
            case 393L: return "bfti_2498af02d8";
            case 394L: return "bfti_24a17495d6";
            case 395L: return "bfti_24b66da9c1";
            case 396L: return "bfti_24df04c7e0";
            case 397L: return "bfti_24e889906c";
            case 398L: return "bfti_24f4753ab4";
            case 399L: return "bfti_2526a73369";
            case 400L: return "bfti_25272939f9";
            case 401L: return "bfti_25431b5719";
            case 402L: return "bfti_2566557da0";
            case 403L: return "bfti_259a571579";
            case 404L: return "bfti_25b669ecaa";
            case 405L: return "bfti_25d14c1b7c";
            case 406L: return "bfti_25d43151c6";
            case 407L: return "bfti_25d623a33d";
            case 408L: return "bfti_25e8ab162e";
            case 409L: return "bfti_25f6da5aa0";
            case 410L: return "bfti_260558396a";
            case 411L: return "bfti_2608d45b84";
            case 412L: return "bfti_263945ad49";
            case 413L: return "bfti_266990a8bb";
            case 414L: return "bfti_26cab0e481";
            case 415L: return "bfti_26cbc3eb59";
            case 416L: return "bfti_26d251ab8e";
            case 417L: return "bfti_26d710ec0f";
            case 418L: return "bfti_26fcc50d0f";
            case 419L: return "bfti_2714b3ad29";
            case 420L: return "bfti_272295074f";
            case 421L: return "bfti_273c13de41";
            case 422L: return "bfti_273edd8f10";
            case 423L: return "bfti_27409c86f3";
            case 424L: return "bfti_2761d18f84";
            case 425L: return "bfti_276a020309";
            case 426L: return "bfti_277b297420";
            case 427L: return "bfti_27802a1e54";
            case 428L: return "bfti_278282b6d8";
            case 429L: return "bfti_27b4d59c87";
            case 430L: return "bfti_2817fc3990";
            case 431L: return "bfti_281e73f96d";
            case 432L: return "bfti_2820c907ec";
            case 433L: return "bfti_282b8bb919";
            case 434L: return "bfti_2832191c17";
            case 435L: return "bfti_2838f64533";
            case 436L: return "bfti_2845c42e98";
            case 437L: return "bfti_285267d41c";
            case 438L: return "bfti_2880c3fb37";
            case 439L: return "bfti_28ac9e657f";
            case 440L: return "bfti_28afb5604b";
            case 441L: return "bfti_28e5df3f2d";
            case 442L: return "bfti_28f2bae353";
            case 443L: return "bfti_28f33d91de";
            case 444L: return "bfti_28f9dc7344";
            case 445L: return "bfti_290357eb1d";
            case 446L: return "bfti_292e78f164";
            case 447L: return "bfti_293d8500ad";
            case 448L: return "bfti_293da61e8d";
            case 449L: return "bfti_297367ee56";
            case 450L: return "bfti_297ac95dc2";
            case 451L: return "bfti_29df303b2a";
            case 452L: return "bfti_29f1d32960";
            case 453L: return "bfti_2a0912a53b";
            case 454L: return "bfti_2a0b6e540b";
            case 455L: return "bfti_2a1787a280";
            case 456L: return "bfti_2a6bab061c";
            case 457L: return "bfti_2a73b66867";
            case 458L: return "bfti_2a7d61e66a";
            case 459L: return "bfti_2ab6fad262";
            case 460L: return "bfti_2abc22675d";
            case 461L: return "bfti_2abc32c8df";
            case 462L: return "bfti_2ad4106e0d";
            case 463L: return "bfti_2b087e7d18";
            case 464L: return "bfti_2b09870e84";
            case 465L: return "bfti_2b2a43cb09";
            case 466L: return "bfti_2b3f6c3302";
            case 467L: return "bfti_2b60a06226";
            case 468L: return "bfti_2b6c384072";
            case 469L: return "bfti_2b8f4eb0ca";
            case 470L: return "bfti_2bb3743966";
            case 471L: return "bfti_2bc7f2ffa8";
            case 472L: return "bfti_2bcc8a204b";
            case 473L: return "bfti_2bd9265718";
            case 474L: return "bfti_2c1300f922";
            case 475L: return "bfti_2c20414721";
            case 476L: return "bfti_2c5fc38c7b";
            case 477L: return "bfti_2c904955e6";
            case 478L: return "bfti_2c99316882";
            case 479L: return "bfti_2c9b734dbf";
            case 480L: return "bfti_2c9e0ab48f";
            case 481L: return "bfti_2ca344f3b8";
            case 482L: return "bfti_2cc508f1f7";
            case 483L: return "bfti_2cca3f2760";
            case 484L: return "bfti_2cce874428";
            case 485L: return "bfti_2cd13b956a";
            case 486L: return "bfti_2ce28c271b";
            case 487L: return "bfti_2ce9808990";
            case 488L: return "bfti_2cfc52d1ad";
            case 489L: return "bfti_2d0e87f00a";
            case 490L: return "bfti_2d4097d376";
            case 491L: return "bfti_2d493c24d7";
            case 492L: return "bfti_2d6ffd7c91";
            case 493L: return "bfti_2d7eb42a37";
            case 494L: return "bfti_2d8a4b62f4";
            case 495L: return "bfti_2da1a95297";
            case 496L: return "bfti_2dbdc9ab22";
            case 497L: return "bfti_2ddbc4ef5c";
            case 498L: return "bfti_2de4fa95b7";
            case 499L: return "bfti_2e0abffd7b";
            case 500L: return "bfti_2e160ce4fc";
            case 501L: return "bfti_2e2cf8ce97";
            case 502L: return "bfti_2e54f51f17";
            case 503L: return "bfti_2e7326905b";
            case 504L: return "bfti_2e77b0dad8";
            case 505L: return "bfti_2eb68153fb";
            case 506L: return "bfti_2ee41c62cf";
            case 507L: return "bfti_2efcf7acce";
            case 508L: return "bfti_2f25d8b1b4";
            case 509L: return "bfti_2f26d8ab17";
            case 510L: return "bfti_2f2c340741";
            case 511L: return "bfti_2f3af666a6";
            case 512L: return "bfti_2f3b2b2e38";
            case 513L: return "bfti_2f4ae67303";
            case 514L: return "bfti_2f7e50467a";
            case 515L: return "bfti_2f80c5a85b";
            case 516L: return "bfti_2f815c605e";
            case 517L: return "bfti_2f8f306fb1";
            case 518L: return "bfti_2fb59735b3";
            case 519L: return "bfti_2fc9b972de";
            case 520L: return "bfti_2fe793f356";
            case 521L: return "bfti_2ff7822286";
            case 522L: return "bfti_3065534615";
            case 523L: return "bfti_3068b59990";
            case 524L: return "bfti_3077ebe9e0";
            case 525L: return "bfti_3095af88ee";
            case 526L: return "bfti_30afc18be7";
            case 527L: return "bfti_30d166a274";
            case 528L: return "bfti_30f8b7f7a5";
            case 529L: return "bfti_315ecf6dc3";
            case 530L: return "bfti_31644d2fb2";
            case 531L: return "bfti_3164afa260";
            case 532L: return "bfti_318bf74fc3";
            case 533L: return "bfti_318f92063d";
            case 534L: return "bfti_319eafd31d";
            case 535L: return "bfti_31d077a664";
            case 536L: return "bfti_32088d8163";
            case 537L: return "bfti_32136ef373";
            case 538L: return "bfti_32267eb497";
            case 539L: return "bfti_322956ccf0";
            case 540L: return "bfti_3247052e7b";
            case 541L: return "bfti_3248e36e71";
            case 542L: return "bfti_3285875503";
            case 543L: return "bfti_3297c9cf8d";
            case 544L: return "bfti_32ab7102de";
            case 545L: return "bfti_32ac6dbdad";
            case 546L: return "bfti_32c3a3055f";
            case 547L: return "bfti_32c70784fc";
            case 548L: return "bfti_32f1e3b7da";
            case 549L: return "bfti_32f35d75ce";
            case 550L: return "bfti_32fd940ac7";
            case 551L: return "bfti_3329d4c20c";
            case 552L: return "bfti_33b09ff8e8";
            case 553L: return "bfti_33c7f0cd4c";
            case 554L: return "bfti_33cb510d37";
            case 555L: return "bfti_33f43e6d23";
            case 556L: return "bfti_33f4552478";
            case 557L: return "bfti_33f643305a";
            case 558L: return "bfti_341be6a056";
            case 559L: return "bfti_34327292b3";
            case 560L: return "bfti_344272427c";
            case 561L: return "bfti_3442f023a1";
            case 562L: return "bfti_34492eaf8c";
            case 563L: return "bfti_34679d528f";
            case 564L: return "bfti_3468fb73ca";
            case 565L: return "bfti_3472aee82a";
            case 566L: return "bfti_3477445486";
            case 567L: return "bfti_34814e8652";
            case 568L: return "bfti_34a545e62d";
            case 569L: return "bfti_34a63c7ea4";
            case 570L: return "bfti_350b112c28";
            case 571L: return "bfti_35311cafb8";
            case 572L: return "bfti_3585c2985e";
            case 573L: return "bfti_359ab02841";
            case 574L: return "bfti_35b3447b04";
            case 575L: return "bfti_35c69b7855";
            case 576L: return "bfti_35d4f7e96f";
            case 577L: return "bfti_35f2899b52";
            case 578L: return "bfti_35ff8de1a8";
            case 579L: return "bfti_361617e5d8";
            case 580L: return "bfti_3629449bd9";
            case 581L: return "bfti_363dec7adf";
            case 582L: return "bfti_3657405da2";
            case 583L: return "bfti_36610ed3e3";
            case 584L: return "bfti_366b60a9ae";
            case 585L: return "bfti_36702b92bb";
            case 586L: return "bfti_3675b7642c";
            case 587L: return "bfti_36bd36f49e";
            case 588L: return "bfti_36c479a82b";
            case 589L: return "bfti_36dd12046d";
            case 590L: return "bfti_36fc5336c4";
            case 591L: return "bfti_374a046371";
            case 592L: return "bfti_37501c21c3";
            case 593L: return "bfti_3771c33244";
            case 594L: return "bfti_377eab1137";
            case 595L: return "bfti_3798b2fc0c";
            case 596L: return "bfti_37a2b8453b";
            case 597L: return "bfti_37b2dee55d";
            case 598L: return "bfti_37b61f5386";
            case 599L: return "bfti_37d8ed8ff2";
            case 600L: return "bfti_37f3160927";
            case 601L: return "bfti_3823efa837";
            case 602L: return "bfti_387cc159a8";
            case 603L: return "bfti_388523c7c7";
            case 604L: return "bfti_388c1c59ae";
            case 605L: return "bfti_388c979dc2";
            case 606L: return "bfti_38f0e7ad6f";
            case 607L: return "bfti_3900d90676";
            case 608L: return "bfti_39316066a6";
            case 609L: return "bfti_39516bd715";
            case 610L: return "bfti_395554f443";
            case 611L: return "bfti_3981d04884";
            case 612L: return "bfti_398d10a7b2";
            case 613L: return "bfti_3991fc513c";
            case 614L: return "bfti_39a479a8b9";
            case 615L: return "bfti_39b13e8b07";
            case 616L: return "bfti_39d283f70e";
            case 617L: return "bfti_39de673ebd";
            case 618L: return "bfti_39e4ecdfd9";
            case 619L: return "bfti_3a09309298";
            case 620L: return "bfti_3a36ec7a93";
            case 621L: return "bfti_3a4518ce54";
            case 622L: return "bfti_3a5388b465";
            case 623L: return "bfti_3aa20e919e";
            case 624L: return "bfti_3aac1a6863";
            case 625L: return "bfti_3abb0346ea";
            case 626L: return "bfti_3acb137cf2";
            case 627L: return "bfti_3ae136b830";
            case 628L: return "bfti_3b25b06d5d";
            case 629L: return "bfti_3b98ccca7f";
            case 630L: return "bfti_3baf7d31d6";
            case 631L: return "bfti_3bb2299456";
            case 632L: return "bfti_3bddf33085";
            case 633L: return "bfti_3c1345f125";
            case 634L: return "bfti_3c147d7954";
            case 635L: return "bfti_3c3cba7786";
            case 636L: return "bfti_3c4777897f";
            case 637L: return "bfti_3c643bfab6";
            case 638L: return "bfti_3c73745a2e";
            case 639L: return "bfti_3c95dd4ddf";
            case 640L: return "bfti_3c9e99e75c";
            case 641L: return "bfti_3ca5ad7d5f";
            case 642L: return "bfti_3cc6c80751";
            case 643L: return "bfti_3ceee99c80";
            case 644L: return "bfti_3d1f71a790";
            case 645L: return "bfti_3d27d748e8";
            case 646L: return "bfti_3d2c4ee27d";
            case 647L: return "bfti_3d6b046bc9";
            case 648L: return "bfti_3d72e67a9e";
            case 649L: return "bfti_3d75148905";
            case 650L: return "bfti_3d94720c77";
            case 651L: return "bfti_3dcf5021c2";
            case 652L: return "bfti_3ddbc292a4";
            case 653L: return "bfti_3df37a15b3";
            case 654L: return "bfti_3e29362db1";
            case 655L: return "bfti_3e474d7770";
            case 656L: return "bfti_3e4e552e80";
            case 657L: return "bfti_3e4eecbe66";
            case 658L: return "bfti_3e5cc7cedf";
            case 659L: return "bfti_3e67bcdeb4";
            case 660L: return "bfti_3e71f41b7a";
            case 661L: return "bfti_3e8a243bf6";
            case 662L: return "bfti_3e8cd1e1d9";
            case 663L: return "bfti_3e8e103c62";
            case 664L: return "bfti_3e922cf548";
            case 665L: return "bfti_3e9282df2c";
            case 666L: return "bfti_3ea2f12fd2";
            case 667L: return "bfti_3eba34f35e";
            case 668L: return "bfti_3ec11acbdf";
            case 669L: return "bfti_3ed06857c3";
            case 670L: return "bfti_3eeb86a455";
            case 671L: return "bfti_3f072b1c89";
            case 672L: return "bfti_3f324d93cd";
            case 673L: return "bfti_3f3402878e";
            case 674L: return "bfti_3f3db6ce76";
            case 675L: return "bfti_3f6b32d7bf";
            case 676L: return "bfti_3f8bcd7340";
            case 677L: return "bfti_3fc94965ed";
            case 678L: return "bfti_3febe103ee";
            case 679L: return "bfti_3fed034f7c";
            case 680L: return "bfti_3ff25f2d91";
            case 681L: return "bfti_3ff34ff33d";
            case 682L: return "bfti_3ffbfacfc3";
            case 683L: return "bfti_403582992a";
            case 684L: return "bfti_403da3b35d";
            case 685L: return "bfti_4040f84db6";
            case 686L: return "bfti_404e40353f";
            case 687L: return "bfti_40673eee8c";
            case 688L: return "bfti_406c4ea7b8";
            case 689L: return "bfti_408b5724d8";
            case 690L: return "bfti_40b7bd1bcb";
            case 691L: return "bfti_40bcc1f7d1";
            case 692L: return "bfti_40d6a07eb4";
            case 693L: return "bfti_40daf2c28c";
            case 694L: return "bfti_40f3baab83";
            case 695L: return "bfti_41081d5062";
            case 696L: return "bfti_412f071fcd";
            case 697L: return "bfti_41600a9f86";
            case 698L: return "bfti_41637b73d6";
            case 699L: return "bfti_417031a38a";
            case 700L: return "bfti_4170d01296";
            case 701L: return "bfti_417549c2e6";
            case 702L: return "bfti_417bedfde4";
            case 703L: return "bfti_41869691ac";
            case 704L: return "bfti_41b96e589f";
            case 705L: return "bfti_41c9a48555";
            case 706L: return "bfti_41d628ef36";
            case 707L: return "bfti_421fdb32b1";
            case 708L: return "bfti_422bb9b600";
            case 709L: return "bfti_422ef8d863";
            case 710L: return "bfti_423721d757";
            case 711L: return "bfti_426ef947ad";
            case 712L: return "bfti_427b820ade";
            case 713L: return "bfti_4284ce7dcf";
            case 714L: return "bfti_428e410b8a";
            case 715L: return "bfti_4295aa69ff";
            case 716L: return "bfti_42a2c403b7";
            case 717L: return "bfti_42bd796283";
            case 718L: return "bfti_42c834f38b";
            case 719L: return "bfti_42ebb46e51";
            case 720L: return "bfti_4307049193";
            case 721L: return "bfti_4352a2daf7";
            case 722L: return "bfti_4364615e0d";
            case 723L: return "bfti_436880ca74";
            case 724L: return "bfti_4373ab6d1b";
            case 725L: return "bfti_4373d64d40";
            case 726L: return "bfti_4378888800";
            case 727L: return "bfti_437ce74e1e";
            case 728L: return "bfti_43a0acf2a4";
            case 729L: return "bfti_43a1c4ddc8";
            case 730L: return "bfti_43d3b793d2";
            case 731L: return "bfti_43eb91e2d3";
            case 732L: return "bfti_43faf6d454";
            case 733L: return "bfti_4403f83dae";
            case 734L: return "bfti_44110a9e5d";
            case 735L: return "bfti_441d47c3d3";
            case 736L: return "bfti_4424efedb8";
            case 737L: return "bfti_442cf100a3";
            case 738L: return "bfti_444abf4183";
            case 739L: return "bfti_44596024fc";
            case 740L: return "bfti_44a2a2ae3b";
            case 741L: return "bfti_44dffe79e7";
            case 742L: return "bfti_44edf9602f";
            case 743L: return "bfti_450182a55c";
            case 744L: return "bfti_45400bfcdc";
            case 745L: return "bfti_455973f3f6";
            case 746L: return "bfti_45638abfb1";
            case 747L: return "bfti_456f951988";
            case 748L: return "bfti_457426a792";
            case 749L: return "bfti_4586e4f8c9";
            case 750L: return "bfti_458a3f0142";
            case 751L: return "bfti_45908ace6e";
            case 752L: return "bfti_45e1492dcb";
            case 753L: return "bfti_4602dc1244";
            case 754L: return "bfti_46102dcf72";
            case 755L: return "bfti_463c502e30";
            case 756L: return "bfti_4645fe6737";
            case 757L: return "bfti_46659d9534";
            case 758L: return "bfti_4682e1f02d";
            case 759L: return "bfti_46a5c99211";
            case 760L: return "bfti_46ae6ba4d6";
            case 761L: return "bfti_46d26eb3a8";
            case 762L: return "bfti_46d4fe894d";
            case 763L: return "bfti_470302a3c0";
            case 764L: return "bfti_470932a5ac";
            case 765L: return "bfti_474dc5fc8a";
            case 766L: return "bfti_4757a12fb1";
            case 767L: return "bfti_475fcf2c4e";
            case 768L: return "bfti_477d8c1396";
            case 769L: return "bfti_4785656737";
            case 770L: return "bfti_4799211e97";
            case 771L: return "bfti_47a8b5f3fd";
            case 772L: return "bfti_47b4b98ed7";
            case 773L: return "bfti_47b82ed471";
            case 774L: return "bfti_47bae7dc53";
            case 775L: return "bfti_47cb13d7a9";
            case 776L: return "bfti_47d1984159";
            case 777L: return "bfti_47d8bd8d7a";
            case 778L: return "bfti_4817eeff3a";
            case 779L: return "bfti_481ddf023c";
            case 780L: return "bfti_483b401f1f";
            case 781L: return "bfti_4876daa300";
            case 782L: return "bfti_4884d3475a";
            case 783L: return "bfti_48bd2a9674";
            case 784L: return "bfti_48c356215b";
            case 785L: return "bfti_48c3c00d6a";
            case 786L: return "bfti_48d4e9296d";
            case 787L: return "bfti_48d603f662";
            case 788L: return "bfti_48e2c1ddfe";
            case 789L: return "bfti_49000971f7";
            case 790L: return "bfti_4939bab4fa";
            case 791L: return "bfti_49660415ac";
            case 792L: return "bfti_4979c21dc3";
            case 793L: return "bfti_4984a6814f";
            case 794L: return "bfti_49b36b6014";
            case 795L: return "bfti_49c75cbafe";
            case 796L: return "bfti_49ccee4c1e";
            case 797L: return "bfti_49e90027eb";
            case 798L: return "bfti_49eb4a1432";
            case 799L: return "bfti_4a090a46a0";
            case 800L: return "bfti_4a6c6687cf";
            case 801L: return "bfti_4a78974318";
            case 802L: return "bfti_4a8732c1ae";
            case 803L: return "bfti_4aa69f6d86";
            case 804L: return "bfti_4ac6f38309";
            case 805L: return "bfti_4ae3ac6470";
            case 806L: return "bfti_4af1ab3e8e";
            case 807L: return "bfti_4af6814e0f";
            case 808L: return "bfti_4afcabad8a";
            case 809L: return "bfti_4b04fb1d35";
            case 810L: return "bfti_4b4582c555";
            case 811L: return "bfti_4b633d9cbc";
            case 812L: return "bfti_4b6b1c29aa";
            case 813L: return "bfti_4b85220956";
            case 814L: return "bfti_4b8db75463";
            case 815L: return "bfti_4ba076afbb";
            case 816L: return "bfti_4bb5fd52bc";
            case 817L: return "bfti_4be58825fa";
            case 818L: return "bfti_4be9e502b0";
            case 819L: return "bfti_4bedc3b05c";
            case 820L: return "bfti_4bee96831e";
            case 821L: return "bfti_4c169845e4";
            case 822L: return "bfti_4c2151908d";
            case 823L: return "bfti_4c4cdcfa31";
            case 824L: return "bfti_4c5a390a21";
            case 825L: return "bfti_4c7a626b08";
            case 826L: return "bfti_4c9b8adf5c";
            case 827L: return "bfti_4ca51e68d1";
            case 828L: return "bfti_4cbe9cb39d";
            case 829L: return "bfti_4cdf7ff37f";
            case 830L: return "bfti_4d08dfc9ca";
            case 831L: return "bfti_4d1a3308cb";
            case 832L: return "bfti_4d23fb85a5";
            case 833L: return "bfti_4d35cc6e38";
            case 834L: return "bfti_4d6b0cf554";
            case 835L: return "bfti_4d7ec1b5b6";
            case 836L: return "bfti_4d84c521c9";
            case 837L: return "bfti_4d91193f49";
            case 838L: return "bfti_4da1bcf6df";
            case 839L: return "bfti_4dc7faec00";
            case 840L: return "bfti_4dce24c368";
            case 841L: return "bfti_4de463a752";
            case 842L: return "bfti_4df3447d7c";
            case 843L: return "bfti_4dfdcdd55d";
            case 844L: return "bfti_4e01e0dcb2";
            case 845L: return "bfti_4e2222416a";
            case 846L: return "bfti_4e253a0dca";
            case 847L: return "bfti_4e2738c91d";
            case 848L: return "bfti_4e2ba1cf4e";
            case 849L: return "bfti_4e2d025300";
            case 850L: return "bfti_4e30ed76e3";
            case 851L: return "bfti_4e514e8fcc";
            case 852L: return "bfti_4e53ff546b";
            case 853L: return "bfti_4e68df38f0";
            case 854L: return "bfti_4e77af121b";
            case 855L: return "bfti_4e81f85206";
            case 856L: return "bfti_4e8eddc10b";
            case 857L: return "bfti_4e98ee60b8";
            case 858L: return "bfti_4ebf1b6a81";
            case 859L: return "bfti_4ec12718cf";
            case 860L: return "bfti_4ee11c6a8b";
            case 861L: return "bfti_4ee908688c";
            case 862L: return "bfti_4ef071cab2";
            case 863L: return "bfti_4f06b662b7";
            case 864L: return "bfti_4f0dc3b304";
            case 865L: return "bfti_4f264094c7";
            case 866L: return "bfti_4f2b7708dc";
            case 867L: return "bfti_4f5ed5c11a";
            case 868L: return "bfti_4f6a73628d";
            case 869L: return "bfti_4f71abd9b9";
            case 870L: return "bfti_4f9da4f4e5";
            case 871L: return "bfti_4fa4e71e8a";
            case 872L: return "bfti_4faf560655";
            case 873L: return "bfti_4fc336fff2";
            case 874L: return "bfti_4fc9499d5e";
            case 875L: return "bfti_4ff92dc33a";
            case 876L: return "bfti_4ffa10350c";
            case 877L: return "bfti_5036c0f447";
            case 878L: return "bfti_5048e2c4b3";
            case 879L: return "bfti_507160dbeb";
            case 880L: return "bfti_507badf080";
            case 881L: return "bfti_5094540cbb";
            case 882L: return "bfti_50b00b97fa";
            case 883L: return "bfti_50bae3ce44";
            case 884L: return "bfti_50d43e3dd0";
            case 885L: return "bfti_50f7f6fb2a";
            case 886L: return "bfti_510b93e19a";
            case 887L: return "bfti_51473f9c3c";
            case 888L: return "bfti_5148cd2787";
            case 889L: return "bfti_5165552c19";
            case 890L: return "bfti_5188944c45";
            case 891L: return "bfti_51bd8e1f07";
            case 892L: return "bfti_51e5b050fa";
            case 893L: return "bfti_51e9c544e3";
            case 894L: return "bfti_51ea5a07b3";
            case 895L: return "bfti_520ed58b15";
            case 896L: return "bfti_522fd4b577";
            case 897L: return "bfti_5235b0a01d";
            case 898L: return "bfti_5236609f1c";
            case 899L: return "bfti_527044a525";
            case 900L: return "bfti_52ac882da1";
            case 901L: return "bfti_52ac889299";
            case 902L: return "bfti_52b23b5ded";
            case 903L: return "bfti_52b50b66c6";
            case 904L: return "bfti_52f04be5ae";
            case 905L: return "bfti_53209be2ab";
            case 906L: return "bfti_53464fcd8a";
            case 907L: return "bfti_5374aff85c";
            case 908L: return "bfti_53b024cffe";
            case 909L: return "bfti_53b033cc6e";
            case 910L: return "bfti_53b2719dff";
            case 911L: return "bfti_53c0e4f12e";
            case 912L: return "bfti_53e3eef58b";
            case 913L: return "bfti_54072d8762";
            case 914L: return "bfti_5412963e41";
            case 915L: return "bfti_54422d3191";
            case 916L: return "bfti_548c8f97c1";
            case 917L: return "bfti_5495a81987";
            case 918L: return "bfti_549c8f7452";
            case 919L: return "bfti_54ad3d7405";
            case 920L: return "bfti_54b0342cb8";
            case 921L: return "bfti_54b5e110d9";
            case 922L: return "bfti_54d55504de";
            case 923L: return "bfti_54d639c341";
            case 924L: return "bfti_54d7c0492d";
            case 925L: return "bfti_54ea68ef33";
            case 926L: return "bfti_54f008bbbd";
            case 927L: return "bfti_54fb04ae11";
            case 928L: return "bfti_5510dd39df";
            case 929L: return "bfti_5532f26055";
            case 930L: return "bfti_554d2db086";
            case 931L: return "bfti_555ee3ec16";
            case 932L: return "bfti_556b745490";
            case 933L: return "bfti_557f40c247";
            case 934L: return "bfti_55b9e35a19";
            case 935L: return "bfti_55d6ad988c";
            case 936L: return "bfti_55dc777bbe";
            case 937L: return "bfti_55dc7a75b6";
            case 938L: return "bfti_55e1d85c26";
            case 939L: return "bfti_55fa978734";
            case 940L: return "bfti_55ffe4d76e";
            case 941L: return "bfti_5600b89fd5";
            case 942L: return "bfti_563408a166";
            case 943L: return "bfti_56490b90b8";
            case 944L: return "bfti_5650a84842";
            case 945L: return "bfti_566717f9aa";
            case 946L: return "bfti_566eb6f210";
            case 947L: return "bfti_5672c56d58";
            case 948L: return "bfti_56744b8225";
            case 949L: return "bfti_568ba34659";
            case 950L: return "bfti_568d43212b";
            case 951L: return "bfti_569d8ea359";
            case 952L: return "bfti_56d7dbf543";
            case 953L: return "bfti_56dd756e86";
            case 954L: return "bfti_56e399212c";
            case 955L: return "bfti_56e56a7f2e";
            case 956L: return "bfti_56f84e68bd";
            case 957L: return "bfti_56ff68c99c";
            case 958L: return "bfti_57107191e6";
            case 959L: return "bfti_5717ed9692";
            case 960L: return "bfti_5752d33fef";
            case 961L: return "bfti_5756ce5be7";
            case 962L: return "bfti_576d87228e";
            case 963L: return "bfti_57bafbbe87";
            case 964L: return "bfti_57bd7a3571";
            case 965L: return "bfti_57d21eda0d";
            case 966L: return "bfti_57d7d6afe6";
            case 967L: return "bfti_57df6de23d";
            case 968L: return "bfti_57e5f58e89";
            case 969L: return "bfti_57f14f0812";
            case 970L: return "bfti_57f3db37f0";
            case 971L: return "bfti_5829a92b79";
            case 972L: return "bfti_5842e842ea";
            case 973L: return "bfti_585274d3be";
            case 974L: return "bfti_586ccf83d1";
            case 975L: return "bfti_58851e798f";
            case 976L: return "bfti_58b118f542";
            case 977L: return "bfti_58bccfb62e";
            case 978L: return "bfti_58be3ee29e";
            case 979L: return "bfti_58c88381cb";
            case 980L: return "bfti_58f5ed42b3";
            case 981L: return "bfti_58fb50007d";
            case 982L: return "bfti_5917650572";
            case 983L: return "bfti_5922d2768b";
            case 984L: return "bfti_59848f7f99";
            case 985L: return "bfti_59a0cbfcfc";
            case 986L: return "bfti_59b0c6b3dc";
            case 987L: return "bfti_59bf9475d1";
            case 988L: return "bfti_59eef96f39";
            case 989L: return "bfti_5a00c77bb3";
            case 990L: return "bfti_5a09702542";
            case 991L: return "bfti_5a1ee53b7e";
            case 992L: return "bfti_5a2c468a36";
            case 993L: return "bfti_5a367c62dd";
            case 994L: return "bfti_5a663ff1fe";
            case 995L: return "bfti_5a66a83110";
            case 996L: return "bfti_5a8d417e14";
            case 997L: return "bfti_5aa1785ada";
            case 998L: return "bfti_5aaef128f8";
            case 999L: return "bfti_5ab407de35";
            case 1000L: return "bfti_5ab415eb94";
            case 1001L: return "bfti_5ad8b960b0";
            case 1002L: return "bfti_5ae746feef";
            case 1003L: return "bfti_5b0aa6e33f";
            case 1004L: return "bfti_5b272ac382";
            case 1005L: return "bfti_5b43ee1d9f";
            case 1006L: return "bfti_5b54cb7b58";
            case 1007L: return "bfti_5b64f01311";
            case 1008L: return "bfti_5b6a01accc";
            case 1009L: return "bfti_5bc5c3a22c";
            case 1010L: return "bfti_5bd162420f";
            case 1011L: return "bfti_5beab249b9";
            case 1012L: return "bfti_5bf1df01df";
            case 1013L: return "bfti_5bf4274a7e";
            case 1014L: return "bfti_5bfe209403";
            case 1015L: return "bfti_5c01e14cab";
            case 1016L: return "bfti_5c0ef2135b";
            case 1017L: return "bfti_5c1040cee4";
            case 1018L: return "bfti_5c33ef6594";
            case 1019L: return "bfti_5c3da66fbd";
            case 1020L: return "bfti_5c6c72ff3e";
            case 1021L: return "bfti_5ca9edbf8b";
            case 1022L: return "bfti_5cca26ddbf";
            case 1023L: return "bfti_5cef6f8de9";
            case 1024L: return "bfti_5cf86be1b2";
            case 1025L: return "bfti_5cfc3b5b4c";
            case 1026L: return "bfti_5d0ffbe003";
            case 1027L: return "bfti_5d56089899";
            case 1028L: return "bfti_5d65fd793c";
            case 1029L: return "bfti_5d701bf554";
            case 1030L: return "bfti_5d776c52eb";
            case 1031L: return "bfti_5daf90f8fb";
            case 1032L: return "bfti_5dd2bf0fec";
            case 1033L: return "bfti_5de4bb3dcb";
            case 1034L: return "bfti_5dffeb6de1";
            case 1035L: return "bfti_5e1bd120c8";
            case 1036L: return "bfti_5e2d8648dc";
            case 1037L: return "bfti_5e32022ca0";
            case 1038L: return "bfti_5e4296a4bb";
            case 1039L: return "bfti_5e45be2598";
            case 1040L: return "bfti_5e935510ab";
            case 1041L: return "bfti_5ead6621d0";
            case 1042L: return "bfti_5ed293acf4";
            case 1043L: return "bfti_5ee8e11dc8";
            case 1044L: return "bfti_5efb6d310c";
            case 1045L: return "bfti_5f09e99a9b";
            case 1046L: return "bfti_5f28546ef8";
            case 1047L: return "bfti_5f2c578696";
            case 1048L: return "bfti_5f33e1ee3f";
            case 1049L: return "bfti_5f36a958b6";
            case 1050L: return "bfti_5f8e9bc1c7";
            case 1051L: return "bfti_6001b0602b";
            case 1052L: return "bfti_6004795e19";
            case 1053L: return "bfti_602d8b495f";
            case 1054L: return "bfti_60308b2432";
            case 1055L: return "bfti_608d22ceb1";
            case 1056L: return "bfti_60b6d6e300";
            case 1057L: return "bfti_60de612447";
            case 1058L: return "bfti_60e8754fa5";
            case 1059L: return "bfti_611000e820";
            case 1060L: return "bfti_6154b35a15";
            case 1061L: return "bfti_6156ef68e2";
            case 1062L: return "bfti_6174c38813";
            case 1063L: return "bfti_617a569928";
            case 1064L: return "bfti_6185d55604";
            case 1065L: return "bfti_61a3861bfb";
            case 1066L: return "bfti_61b0bb3150";
            case 1067L: return "bfti_61b7287efc";
            case 1068L: return "bfti_61cfa1935a";
            case 1069L: return "bfti_61fc71ca74";
            case 1070L: return "bfti_6220654784";
            case 1071L: return "bfti_6225c8441a";
            case 1072L: return "bfti_626589aa1e";
            case 1073L: return "bfti_62726d0377";
            case 1074L: return "bfti_62863fdc37";
            case 1075L: return "bfti_62895f6452";
            case 1076L: return "bfti_628aa1bb7b";
            case 1077L: return "bfti_62afdd195f";
            case 1078L: return "bfti_62bde0e3b2";
            case 1079L: return "bfti_62d06fcc44";
            case 1080L: return "bfti_62e6248dfb";
            case 1081L: return "bfti_62fbff47e9";
            case 1082L: return "bfti_6307f35cf6";
            case 1083L: return "bfti_630a94c7fc";
            case 1084L: return "bfti_6325990ecb";
            case 1085L: return "bfti_632ae2754f";
            case 1086L: return "bfti_63353c311d";
            case 1087L: return "bfti_634d3e2463";
            case 1088L: return "bfti_63bc224f4d";
            case 1089L: return "bfti_63f94d0014";
            case 1090L: return "bfti_63fa16e110";
            case 1091L: return "bfti_6400341218";
            case 1092L: return "bfti_6412de3a55";
            case 1093L: return "bfti_641e6931d5";
            case 1094L: return "bfti_642df1468c";
            case 1095L: return "bfti_64338b297c";
            case 1096L: return "bfti_643c64b54f";
            case 1097L: return "bfti_646f236585";
            case 1098L: return "bfti_647e07d40b";
            case 1099L: return "bfti_648bd8e36d";
            case 1100L: return "bfti_64e10c4b08";
            case 1101L: return "bfti_64eb464466";
            case 1102L: return "bfti_64f861b7ea";
            case 1103L: return "bfti_64f86da40e";
            case 1104L: return "bfti_65341e1028";
            case 1105L: return "bfti_65363641c1";
            case 1106L: return "bfti_65455c44b5";
            case 1107L: return "bfti_6585c33912";
            case 1108L: return "bfti_658ed20145";
            case 1109L: return "bfti_6596ba3751";
            case 1110L: return "bfti_659920f694";
            case 1111L: return "bfti_65b0f41f99";
            case 1112L: return "bfti_65cfa4cf9d";
            case 1113L: return "bfti_65d50e9b22";
            case 1114L: return "bfti_65dd9e9278";
            case 1115L: return "bfti_65e7364f54";
            case 1116L: return "bfti_664fdbbc45";
            case 1117L: return "bfti_66613df1fb";
            case 1118L: return "bfti_666d2df0db";
            case 1119L: return "bfti_666ecb44ba";
            case 1120L: return "bfti_667454597b";
            case 1121L: return "bfti_66b65cb961";
            case 1122L: return "bfti_66c1bdd41a";
            case 1123L: return "bfti_66f75a06f7";
            case 1124L: return "bfti_670425f0a4";
            case 1125L: return "bfti_6711b35bde";
            case 1126L: return "bfti_671d9e8d01";
            case 1127L: return "bfti_6727816bea";
            case 1128L: return "bfti_672ad8cf38";
            case 1129L: return "bfti_673d711aa8";
            case 1130L: return "bfti_6751434510";
            case 1131L: return "bfti_676fa16616";
            case 1132L: return "bfti_678269df04";
            case 1133L: return "bfti_678499d39c";
            case 1134L: return "bfti_6788710305";
            case 1135L: return "bfti_6791cb787e";
            case 1136L: return "bfti_67b1e10145";
            case 1137L: return "bfti_67e57c88d9";
            case 1138L: return "bfti_67ffe7d88a";
            case 1139L: return "bfti_681676f263";
            case 1140L: return "bfti_6847aef2d0";
            case 1141L: return "bfti_684ca27f5e";
            case 1142L: return "bfti_6853828c1e";
            case 1143L: return "bfti_6882d463f1";
            case 1144L: return "bfti_68aa34da03";
            case 1145L: return "bfti_68b900647a";
            case 1146L: return "bfti_68bb1d6b9c";
            case 1147L: return "bfti_68c7ff3363";
            case 1148L: return "bfti_68dc77b428";
            case 1149L: return "bfti_68dcc8b04f";
            case 1150L: return "bfti_692bd1692d";
            case 1151L: return "bfti_695d50b9d9";
            case 1152L: return "bfti_696dfad892";
            case 1153L: return "bfti_698a84e6e3";
            case 1154L: return "bfti_6993792391";
            case 1155L: return "bfti_69cfccc059";
            case 1156L: return "bfti_69f1dc9a05";
            case 1157L: return "bfti_6a3273b3c5";
            case 1158L: return "bfti_6a5c596d54";
            case 1159L: return "bfti_6a5eb80f2e";
            case 1160L: return "bfti_6a6a898c31";
            case 1161L: return "bfti_6a7366d080";
            case 1162L: return "bfti_6a74f732b1";
            case 1163L: return "bfti_6a7c077641";
            case 1164L: return "bfti_6a8e1c26c8";
            case 1165L: return "bfti_6aa5608d1a";
            case 1166L: return "bfti_6ab0803ece";
            case 1167L: return "bfti_6ac6754936";
            case 1168L: return "bfti_6accf35747";
            case 1169L: return "bfti_6afe975f02";
            case 1170L: return "bfti_6b227023a4";
            case 1171L: return "bfti_6b294172ca";
            case 1172L: return "bfti_6b334bd7c4";
            case 1173L: return "bfti_6b3be7d373";
            case 1174L: return "bfti_6b411082d4";
            case 1175L: return "bfti_6b4412ad13";
            case 1176L: return "bfti_6b5a1ef617";
            case 1177L: return "bfti_6b6d3d4711";
            case 1178L: return "bfti_6b71de1a33";
            case 1179L: return "bfti_6b74b5863c";
            case 1180L: return "bfti_6b89e81494";
            case 1181L: return "bfti_6b93ac8b16";
            case 1182L: return "bfti_6bae6594b0";
            case 1183L: return "bfti_6bb0fe7a87";
            case 1184L: return "bfti_6bb3b86a9e";
            case 1185L: return "bfti_6bc51f00e4";
            case 1186L: return "bfti_6bc86b6d7f";
            case 1187L: return "bfti_6be124b729";
            case 1188L: return "bfti_6be1585ac8";
            case 1189L: return "bfti_6bfbdcf5df";
            case 1190L: return "bfti_6bfd735dc1";
            case 1191L: return "bfti_6c13141f62";
            case 1192L: return "bfti_6c1a352e13";
            case 1193L: return "bfti_6c4f7d12ab";
            case 1194L: return "bfti_6c5afbbc39";
            case 1195L: return "bfti_6c5bef80bd";
            case 1196L: return "bfti_6c6bfbb57b";
            case 1197L: return "bfti_6c6cd604ff";
            case 1198L: return "bfti_6c7c6ab40b";
            case 1199L: return "bfti_6c82d4260f";
            case 1200L: return "bfti_6c841bbabc";
            case 1201L: return "bfti_6c8af6322c";
            case 1202L: return "bfti_6ca238a1e9";
            case 1203L: return "bfti_6cd43f7c21";
            case 1204L: return "bfti_6cfbd87d48";
            case 1205L: return "bfti_6d4fd0355b";
            case 1206L: return "bfti_6d61ba0933";
            case 1207L: return "bfti_6d75f3ee99";
            case 1208L: return "bfti_6db9a8442d";
            case 1209L: return "bfti_6dbb58adf2";
            case 1210L: return "bfti_6e08b3c5a7";
            case 1211L: return "bfti_6e0bcf23e9";
            case 1212L: return "bfti_6e10f1bcd7";
            case 1213L: return "bfti_6e17abbfa0";
            case 1214L: return "bfti_6e1bcd41da";
            case 1215L: return "bfti_6e3fa6b510";
            case 1216L: return "bfti_6e48ee4c63";
            case 1217L: return "bfti_6e5d48e096";
            case 1218L: return "bfti_6e646ba9d4";
            case 1219L: return "bfti_6e680051dd";
            case 1220L: return "bfti_6e988b32e4";
            case 1221L: return "bfti_6e99696f59";
            case 1222L: return "bfti_6e9e02c373";
            case 1223L: return "bfti_6edf78bf06";
            case 1224L: return "bfti_6ef714b581";
            case 1225L: return "bfti_6ef7356bd2";
            case 1226L: return "bfti_6f1d85b9e5";
            case 1227L: return "bfti_6f31963edd";
            case 1228L: return "bfti_6f3e0dfa3d";
            case 1229L: return "bfti_6f49a728e3";
            case 1230L: return "bfti_6f5a002bb2";
            case 1231L: return "bfti_6f6855a2cb";
            case 1232L: return "bfti_6f99823a66";
            case 1233L: return "bfti_6fd2dd172c";
            case 1234L: return "bfti_6fd7c1cd44";
            case 1235L: return "bfti_6ffe6b7c8f";
            case 1236L: return "bfti_7023b8e0ec";
            case 1237L: return "bfti_702597fbdd";
            case 1238L: return "bfti_702d78eb89";
            case 1239L: return "bfti_7072b04016";
            case 1240L: return "bfti_707f245cdc";
            case 1241L: return "bfti_7089767499";
            case 1242L: return "bfti_7090ed7c7c";
            case 1243L: return "bfti_70920f81b3";
            case 1244L: return "bfti_70a70c9e90";
            case 1245L: return "bfti_70afc720aa";
            case 1246L: return "bfti_70b79f07b2";
            case 1247L: return "bfti_70dfa4e2e5";
            case 1248L: return "bfti_70e1c53177";
            case 1249L: return "bfti_70e3bbe604";
            case 1250L: return "bfti_70f8d53332";
            case 1251L: return "bfti_715714a07c";
            case 1252L: return "bfti_717a714881";
            case 1253L: return "bfti_717c9d662e";
            case 1254L: return "bfti_7181266eeb";
            case 1255L: return "bfti_71a5a931e6";
            case 1256L: return "bfti_71a5e60126";
            case 1257L: return "bfti_71f1d7aaba";
            case 1258L: return "bfti_71fbe24941";
            case 1259L: return "bfti_721164f9da";
            case 1260L: return "bfti_7230e03d5c";
            case 1261L: return "bfti_7236860958";
            case 1262L: return "bfti_7245bc68e3";
            case 1263L: return "bfti_725a9a695a";
            case 1264L: return "bfti_7266fdc43b";
            case 1265L: return "bfti_728b46bce7";
            case 1266L: return "bfti_729206740d";
            case 1267L: return "bfti_72bdc4b521";
            case 1268L: return "bfti_72ca2bee94";
            case 1269L: return "bfti_72d204903a";
            case 1270L: return "bfti_72d3fcf28b";
            case 1271L: return "bfti_73062210d5";
            case 1272L: return "bfti_732c687617";
            case 1273L: return "bfti_735b9bce52";
            case 1274L: return "bfti_7372bd6505";
            case 1275L: return "bfti_73c071bc40";
            case 1276L: return "bfti_73e4f09d59";
            case 1277L: return "bfti_73e645533e";
            case 1278L: return "bfti_73eece56e8";
            case 1279L: return "bfti_73f984a044";
            case 1280L: return "bfti_73fb713f69";
            case 1281L: return "bfti_7411e2da0d";
            case 1282L: return "bfti_741946d37b";
            case 1283L: return "bfti_7422c7d7b7";
            case 1284L: return "bfti_743606e7f3";
            case 1285L: return "bfti_7439f6e74d";
            case 1286L: return "bfti_743ba986ab";
            case 1287L: return "bfti_74512b55a3";
            case 1288L: return "bfti_747ab28a91";
            case 1289L: return "bfti_747b19d04f";
            case 1290L: return "bfti_748a0901f7";
            case 1291L: return "bfti_748ea550d6";
            case 1292L: return "bfti_74adcc9c7a";
            case 1293L: return "bfti_74c6ba983f";
            case 1294L: return "bfti_74d45d7226";
            case 1295L: return "bfti_75032dae16";
            case 1296L: return "bfti_7527a7241e";
            case 1297L: return "bfti_753183cb90";
            case 1298L: return "bfti_75321455a2";
            case 1299L: return "bfti_75506a9fbd";
            case 1300L: return "bfti_7551897a7a";
            case 1301L: return "bfti_756b26544d";
            case 1302L: return "bfti_75714d6b13";
            case 1303L: return "bfti_757b6a50ea";
            case 1304L: return "bfti_758c664d2f";
            case 1305L: return "bfti_7596fe3896";
            case 1306L: return "bfti_759fc3ac3f";
            case 1307L: return "bfti_75a90d6bb2";
            case 1308L: return "bfti_75c7ddd248";
            case 1309L: return "bfti_75cbe8aace";
            case 1310L: return "bfti_761a592f26";
            case 1311L: return "bfti_762b03f892";
            case 1312L: return "bfti_765808e277";
            case 1313L: return "bfti_767a6c232a";
            case 1314L: return "bfti_767b523732";
            case 1315L: return "bfti_767df0e69f";
            case 1316L: return "bfti_768a23be16";
            case 1317L: return "bfti_76953745d1";
            case 1318L: return "bfti_76a574762b";
            case 1319L: return "bfti_76b90ffb57";
            case 1320L: return "bfti_76fb86b28b";
            case 1321L: return "bfti_7716adb227";
            case 1322L: return "bfti_772d8be62a";
            case 1323L: return "bfti_7734c25e8d";
            case 1324L: return "bfti_773ad86447";
            case 1325L: return "bfti_7749d2b0f0";
            case 1326L: return "bfti_77821d8ecb";
            case 1327L: return "bfti_77978735fe";
            case 1328L: return "bfti_779f1ece73";
            case 1329L: return "bfti_77cbe5a02b";
            case 1330L: return "bfti_77e2032769";
            case 1331L: return "bfti_780217fc81";
            case 1332L: return "bfti_780aab42df";
            case 1333L: return "bfti_78415e51a4";
            case 1334L: return "bfti_78496e62ca";
            case 1335L: return "bfti_785186aee1";
            case 1336L: return "bfti_7869d6ad75";
            case 1337L: return "bfti_78885ab579";
            case 1338L: return "bfti_78947e7514";
            case 1339L: return "bfti_78a3349585";
            case 1340L: return "bfti_78c654566e";
            case 1341L: return "bfti_78d26dde9d";
            case 1342L: return "bfti_78dc022076";
            case 1343L: return "bfti_78eb0dec70";
            case 1344L: return "bfti_78f4bf7828";
            case 1345L: return "bfti_78faf1b713";
            case 1346L: return "bfti_790af77de7";
            case 1347L: return "bfti_791263ccb3";
            case 1348L: return "bfti_791c6b1993";
            case 1349L: return "bfti_792fc3e2af";
            case 1350L: return "bfti_79461406af";
            case 1351L: return "bfti_7957ac3dc7";
            case 1352L: return "bfti_796ae22273";
            case 1353L: return "bfti_799483b0b3";
            case 1354L: return "bfti_79b4878404";
            case 1355L: return "bfti_79bbf2c981";
            case 1356L: return "bfti_79bc89269f";
            case 1357L: return "bfti_79c80226a2";
            case 1358L: return "bfti_79c8f35835";
            case 1359L: return "bfti_79f56ee6aa";
            case 1360L: return "bfti_7a135cd2e3";
            case 1361L: return "bfti_7a4875e18d";
            case 1362L: return "bfti_7a5bb6640d";
            case 1363L: return "bfti_7a5d479dc9";
            case 1364L: return "bfti_7a9a4016d3";
            case 1365L: return "bfti_7abcc47105";
            case 1366L: return "bfti_7adc19a344";
            case 1367L: return "bfti_7ae711cde9";
            case 1368L: return "bfti_7b077cb8e2";
            case 1369L: return "bfti_7b1302731d";
            case 1370L: return "bfti_7b1f73d02f";
            case 1371L: return "bfti_7b4593557f";
            case 1372L: return "bfti_7b7348433e";
            case 1373L: return "bfti_7b939ac3d7";
            case 1374L: return "bfti_7b9c6ee492";
            case 1375L: return "bfti_7bb7cbcbc4";
            case 1376L: return "bfti_7bcaaf9cdd";
            case 1377L: return "bfti_7c052fcc47";
            case 1378L: return "bfti_7c106b0ea5";
            case 1379L: return "bfti_7c12c4cc47";
            case 1380L: return "bfti_7c46a5e875";
            case 1381L: return "bfti_7c4b744606";
            case 1382L: return "bfti_7c54706b23";
            case 1383L: return "bfti_7c6a60942e";
            case 1384L: return "bfti_7c6c8d8ea8";
            case 1385L: return "bfti_7c7104a0ca";
            case 1386L: return "bfti_7c7aad3878";
            case 1387L: return "bfti_7c8fa948d7";
            case 1388L: return "bfti_7c970c1edf";
            case 1389L: return "bfti_7c9879911c";
            case 1390L: return "bfti_7ca53d1ebb";
            case 1391L: return "bfti_7cb6f8c99c";
            case 1392L: return "bfti_7cbec3735a";
            case 1393L: return "bfti_7cc8f91f16";
            case 1394L: return "bfti_7cd22b5acf";
            case 1395L: return "bfti_7ceaa3f156";
            case 1396L: return "bfti_7cf621f125";
            case 1397L: return "bfti_7d0aeab0d6";
            case 1398L: return "bfti_7d36b925a3";
            case 1399L: return "bfti_7d545a5ae9";
            case 1400L: return "bfti_7d6b5a3746";
            case 1401L: return "bfti_7d6ee203f1";
            case 1402L: return "bfti_7d8ab33925";
            case 1403L: return "bfti_7d953cd087";
            case 1404L: return "bfti_7dac1befb2";
            case 1405L: return "bfti_7dc2e5bc01";
            case 1406L: return "bfti_7de06301e8";
            case 1407L: return "bfti_7e0f00dc21";
            case 1408L: return "bfti_7e1cd19b4c";
            case 1409L: return "bfti_7e1d5d238c";
            case 1410L: return "bfti_7e3d1faa0c";
            case 1411L: return "bfti_7e41646a22";
            case 1412L: return "bfti_7e4cb54b4f";
            case 1413L: return "bfti_7e4d9d1016";
            case 1414L: return "bfti_7e4f601f20";
            case 1415L: return "bfti_7e6f5df02c";
            case 1416L: return "bfti_7e75c36d49";
            case 1417L: return "bfti_7e8c304830";
            case 1418L: return "bfti_7e8df83414";
            case 1419L: return "bfti_7ea365444c";
            case 1420L: return "bfti_7eb2a471ca";
            case 1421L: return "bfti_7ec86b1335";
            case 1422L: return "bfti_7ecebe0382";
            case 1423L: return "bfti_7edd8a020f";
            case 1424L: return "bfti_7ee31bbb80";
            case 1425L: return "bfti_7eefa0c57d";
            case 1426L: return "bfti_7ef2fcf593";
            case 1427L: return "bfti_7f0094cd11";
            case 1428L: return "bfti_7f16bee6b9";
            case 1429L: return "bfti_7f1eff7f58";
            case 1430L: return "bfti_7f35854a1a";
            case 1431L: return "bfti_7f4b55dad1";
            case 1432L: return "bfti_7f603a621e";
            case 1433L: return "bfti_7f815df06a";
            case 1434L: return "bfti_7f99260594";
            case 1435L: return "bfti_7f9a0d779d";
            case 1436L: return "bfti_7fa56021a9";
            case 1437L: return "bfti_7fb63dbc16";
            case 1438L: return "bfti_7fc1d03eb9";
            case 1439L: return "bfti_7fcaa7083d";
            case 1440L: return "bfti_7fcc43d717";
            case 1441L: return "bfti_7fceb30d1f";
            case 1442L: return "bfti_7fdd38def1";
            case 1443L: return "bfti_7ff203e31d";
            case 1444L: return "bfti_7ffbec0d8d";
            case 1445L: return "bfti_80023cfe4a";
            case 1446L: return "bfti_800ec5a23b";
            case 1447L: return "bfti_802b38c238";
            case 1448L: return "bfti_802b59ea3f";
            case 1449L: return "bfti_802c9619fe";
            case 1450L: return "bfti_8090747d6d";
            case 1451L: return "bfti_80b3863bbe";
            case 1452L: return "bfti_814ef3bf53";
            case 1453L: return "bfti_8154db458a";
            case 1454L: return "bfti_8169f75e7c";
            case 1455L: return "bfti_817c32e01e";
            case 1456L: return "bfti_818b38abd3";
            case 1457L: return "bfti_818f007437";
            case 1458L: return "bfti_81acf5a82c";
            case 1459L: return "bfti_81f589ce33";
            case 1460L: return "bfti_81f67702c9";
            case 1461L: return "bfti_81faad84e6";
            case 1462L: return "bfti_8246563c0c";
            case 1463L: return "bfti_8257e0c20e";
            case 1464L: return "bfti_826de42190";
            case 1465L: return "bfti_8275570935";
            case 1466L: return "bfti_828c59ce75";
            case 1467L: return "bfti_829821141a";
            case 1468L: return "bfti_829f612161";
            case 1469L: return "bfti_82a6170b6e";
            case 1470L: return "bfti_83050ac835";
            case 1471L: return "bfti_830e60ab0f";
            case 1472L: return "bfti_832ad8fb99";
            case 1473L: return "bfti_8355bb71a3";
            case 1474L: return "bfti_8377428c99";
            case 1475L: return "bfti_838dd5feee";
            case 1476L: return "bfti_83a0321e57";
            case 1477L: return "bfti_83b8be0c44";
            case 1478L: return "bfti_83c835413e";
            case 1479L: return "bfti_83e28d4e33";
            case 1480L: return "bfti_83eb0a5d0b";
            case 1481L: return "bfti_83ee670f7d";
            case 1482L: return "bfti_83f8880f1a";
            case 1483L: return "bfti_83f948b132";
            case 1484L: return "bfti_84115dc2ba";
            case 1485L: return "bfti_84240b8163";
            case 1486L: return "bfti_842b316134";
            case 1487L: return "bfti_843090a24e";
            case 1488L: return "bfti_8440dda2ba";
            case 1489L: return "bfti_8442d8ed74";
            case 1490L: return "bfti_8449b8116e";
            case 1491L: return "bfti_844c407da5";
            case 1492L: return "bfti_846a362da5";
            case 1493L: return "bfti_8471ce24ab";
            case 1494L: return "bfti_84746f3a70";
            case 1495L: return "bfti_84852bb2c8";
            case 1496L: return "bfti_849d95b902";
            case 1497L: return "bfti_84a4681591";
            case 1498L: return "bfti_84dfe4b1d9";
            case 1499L: return "bfti_84fedfd13f";
            case 1500L: return "bfti_850e191f84";
            case 1501L: return "bfti_851d974afd";
            case 1502L: return "bfti_853d7986ec";
            case 1503L: return "bfti_85790e53b6";
            case 1504L: return "bfti_859bbb8cb6";
            case 1505L: return "bfti_85c244bcaf";
            case 1506L: return "bfti_85d37f9103";
            case 1507L: return "bfti_85d4bc1b19";
            case 1508L: return "bfti_85ff3417dc";
            case 1509L: return "bfti_8646e1151d";
            case 1510L: return "bfti_865a40b8c9";
            case 1511L: return "bfti_8665dae4ba";
            case 1512L: return "bfti_8672bb54e3";
            case 1513L: return "bfti_8676f92db7";
            case 1514L: return "bfti_867f565c91";
            case 1515L: return "bfti_8697257f79";
            case 1516L: return "bfti_86c357ebda";
            case 1517L: return "bfti_86cef64642";
            case 1518L: return "bfti_8707a39e7b";
            case 1519L: return "bfti_870c26909d";
            case 1520L: return "bfti_871f558281";
            case 1521L: return "bfti_87345842ab";
            case 1522L: return "bfti_878ed2ae74";
            case 1523L: return "bfti_879534b906";
            case 1524L: return "bfti_87980cec03";
            case 1525L: return "bfti_87b8f10e09";
            case 1526L: return "bfti_87c2ca69e1";
            case 1527L: return "bfti_8802fe90eb";
            case 1528L: return "bfti_88065e0aa0";
            case 1529L: return "bfti_881e4c6c23";
            case 1530L: return "bfti_88293189c5";
            case 1531L: return "bfti_883242dce2";
            case 1532L: return "bfti_883f6adc56";
            case 1533L: return "bfti_88551720eb";
            case 1534L: return "bfti_8859e75d90";
            case 1535L: return "bfti_885fb44f96";
            case 1536L: return "bfti_8860dc6b8d";
            case 1537L: return "bfti_887704a522";
            case 1538L: return "bfti_888b2e1e88";
            case 1539L: return "bfti_888cefc610";
            case 1540L: return "bfti_888d66db7e";
            case 1541L: return "bfti_888d6a9e35";
            case 1542L: return "bfti_88b4a9e6de";
            case 1543L: return "bfti_88bbdd7354";
            case 1544L: return "bfti_8901e37e2d";
            case 1545L: return "bfti_8901e92b1e";
            case 1546L: return "bfti_893acb134f";
            case 1547L: return "bfti_8944855e7c";
            case 1548L: return "bfti_89555fb5aa";
            case 1549L: return "bfti_8962467c9c";
            case 1550L: return "bfti_89c63bd3e2";
            case 1551L: return "bfti_89cfe5ff4e";
            case 1552L: return "bfti_89dbfcdba9";
            case 1553L: return "bfti_89ebf08bd5";
            case 1554L: return "bfti_89f038cf77";
            case 1555L: return "bfti_8a0031cf7d";
            case 1556L: return "bfti_8a175f291c";
            case 1557L: return "bfti_8a1f027f51";
            case 1558L: return "bfti_8a263e5df0";
            case 1559L: return "bfti_8a2e144d0d";
            case 1560L: return "bfti_8a46514417";
            case 1561L: return "bfti_8a5ae09fc8";
            case 1562L: return "bfti_8a63515b1f";
            case 1563L: return "bfti_8a6bcb14b1";
            case 1564L: return "bfti_8a823f3f44";
            case 1565L: return "bfti_8a825b073d";
            case 1566L: return "bfti_8a8b91c6a3";
            case 1567L: return "bfti_8ab153fae0";
            case 1568L: return "bfti_8ab42c4d0a";
            case 1569L: return "bfti_8ac5e843d9";
            case 1570L: return "bfti_8ac61f4909";
            case 1571L: return "bfti_8ad0cfdc75";
            case 1572L: return "bfti_8afdebfd34";
            case 1573L: return "bfti_8b22e205f9";
            case 1574L: return "bfti_8b2a3f8317";
            case 1575L: return "bfti_8b448fc92d";
            case 1576L: return "bfti_8b58045a11";
            case 1577L: return "bfti_8b5d19d4e6";
            case 1578L: return "bfti_8b7a5eac03";
            case 1579L: return "bfti_8b9abc1b83";
            case 1580L: return "bfti_8babb34e2d";
            case 1581L: return "bfti_8bba56991b";
            case 1582L: return "bfti_8bbe7c0b61";
            case 1583L: return "bfti_8c1316c7e1";
            case 1584L: return "bfti_8c200dfdab";
            case 1585L: return "bfti_8c3fccadfc";
            case 1586L: return "bfti_8c4e63baad";
            case 1587L: return "bfti_8c556d4310";
            case 1588L: return "bfti_8c75d580ec";
            case 1589L: return "bfti_8c814367d5";
            case 1590L: return "bfti_8c9cdd3ba6";
            case 1591L: return "bfti_8ca80b6f2c";
            case 1592L: return "bfti_8cacc881d1";
            case 1593L: return "bfti_8cc15f077a";
            case 1594L: return "bfti_8ce6b32c00";
            case 1595L: return "bfti_8ce82669a9";
            case 1596L: return "bfti_8cf03fbb56";
            case 1597L: return "bfti_8cfa5fc13f";
            case 1598L: return "bfti_8d2425844c";
            case 1599L: return "bfti_8d2996e4ff";
            case 1600L: return "bfti_8d3ea03ea6";
            case 1601L: return "bfti_8d58be22c0";
            case 1602L: return "bfti_8d74f225aa";
            case 1603L: return "bfti_8d7f261b94";
            case 1604L: return "bfti_8d8570ffbe";
            case 1605L: return "bfti_8d93cc8539";
            case 1606L: return "bfti_8db8e8846a";
            case 1607L: return "bfti_8dd523172d";
            case 1608L: return "bfti_8dd54a3602";
            case 1609L: return "bfti_8dd7a724c2";
            case 1610L: return "bfti_8dddf37754";
            case 1611L: return "bfti_8dfa7492c2";
            case 1612L: return "bfti_8e6ff73718";
            case 1613L: return "bfti_8e761642d3";
            case 1614L: return "bfti_8e78caf0b8";
            case 1615L: return "bfti_8e85aa8c80";
            case 1616L: return "bfti_8e88135b65";
            case 1617L: return "bfti_8ea56efd1c";
            case 1618L: return "bfti_8eb2a5206b";
            case 1619L: return "bfti_8eccfdc9c5";
            case 1620L: return "bfti_8ed19acb4e";
            case 1621L: return "bfti_8ef094cc09";
            case 1622L: return "bfti_8ef399e737";
            case 1623L: return "bfti_8f049409cf";
            case 1624L: return "bfti_8f0948a99c";
            case 1625L: return "bfti_8f3119796d";
            case 1626L: return "bfti_8f91001cfe";
            case 1627L: return "bfti_8f93358894";
            case 1628L: return "bfti_8f98b359fc";
            case 1629L: return "bfti_8fa819c5e0";
            case 1630L: return "bfti_8fb2adc19f";
            case 1631L: return "bfti_8fb7b71f78";
            case 1632L: return "bfti_8fbd684992";
            case 1633L: return "bfti_8fc07089c1";
            case 1634L: return "bfti_8fca868f46";
            case 1635L: return "bfti_8fcd162684";
            case 1636L: return "bfti_8fd81c449b";
            case 1637L: return "bfti_8fedea9993";
            case 1638L: return "bfti_90287907ae";
            case 1639L: return "bfti_903f2e8e42";
            case 1640L: return "bfti_9082235c8a";
            case 1641L: return "bfti_908cc1b2c2";
            case 1642L: return "bfti_90a1b28862";
            case 1643L: return "bfti_90a77ae83b";
            case 1644L: return "bfti_90b4c59578";
            case 1645L: return "bfti_90b8b3556a";
            case 1646L: return "bfti_90c8fe242e";
            case 1647L: return "bfti_90cb165f50";
            case 1648L: return "bfti_90cd025cac";
            case 1649L: return "bfti_90e0db847d";
            case 1650L: return "bfti_90e0eed036";
            case 1651L: return "bfti_90e396f8f1";
            case 1652L: return "bfti_910bd70433";
            case 1653L: return "bfti_91472e1e75";
            case 1654L: return "bfti_914777912e";
            case 1655L: return "bfti_914f5877d3";
            case 1656L: return "bfti_9186a98e0e";
            case 1657L: return "bfti_918c5ae284";
            case 1658L: return "bfti_9191735c60";
            case 1659L: return "bfti_91f4c61dec";
            case 1660L: return "bfti_91fecf7a97";
            case 1661L: return "bfti_9212e386a9";
            case 1662L: return "bfti_9213386b58";
            case 1663L: return "bfti_9215b2afdc";
            case 1664L: return "bfti_922365f3e9";
            case 1665L: return "bfti_923cd52cf0";
            case 1666L: return "bfti_9268346067";
            case 1667L: return "bfti_92697c92f0";
            case 1668L: return "bfti_9276a479f5";
            case 1669L: return "bfti_928f76d224";
            case 1670L: return "bfti_9292dd5902";
            case 1671L: return "bfti_929367f132";
            case 1672L: return "bfti_929420f50d";
            case 1673L: return "bfti_92a8506d94";
            case 1674L: return "bfti_92b544b032";
            case 1675L: return "bfti_92e29c4ec3";
            case 1676L: return "bfti_92e8fb5cdf";
            case 1677L: return "bfti_92fac32ce7";
            case 1678L: return "bfti_92fca0e078";
            case 1679L: return "bfti_9317465577";
            case 1680L: return "bfti_931d32cf99";
            case 1681L: return "bfti_932db00782";
            case 1682L: return "bfti_9335f317c0";
            case 1683L: return "bfti_934d603d27";
            case 1684L: return "bfti_9351bf8db3";
            case 1685L: return "bfti_93546e9764";
            case 1686L: return "bfti_93629b2c9a";
            case 1687L: return "bfti_936774a04e";
            case 1688L: return "bfti_936b43cd84";
            case 1689L: return "bfti_9372915e3b";
            case 1690L: return "bfti_937a6ee62b";
            case 1691L: return "bfti_937a8aa664";
            case 1692L: return "bfti_937d8cf101";
            case 1693L: return "bfti_93a94e7a42";
            case 1694L: return "bfti_93b45aaff5";
            case 1695L: return "bfti_93f79ea781";
            case 1696L: return "bfti_93f7b61038";
            case 1697L: return "bfti_9428db02d4";
            case 1698L: return "bfti_942d3ce4c1";
            case 1699L: return "bfti_9459b060b0";
            case 1700L: return "bfti_9463e91674";
            case 1701L: return "bfti_94736eba2b";
            case 1702L: return "bfti_947a975f94";
            case 1703L: return "bfti_94db325a8d";
            case 1704L: return "bfti_94e8231f3e";
            case 1705L: return "bfti_94f3b7f0c2";
            case 1706L: return "bfti_94fa74057d";
            case 1707L: return "bfti_94fb1315c4";
            case 1708L: return "bfti_94ff17b124";
            case 1709L: return "bfti_9506a185f5";
            case 1710L: return "bfti_95155f3818";
            case 1711L: return "bfti_951f637c83";
            case 1712L: return "bfti_951f89baa0";
            case 1713L: return "bfti_9524df024a";
            case 1714L: return "bfti_9527cc2b95";
            case 1715L: return "bfti_95509ca9f7";
            case 1716L: return "bfti_9553f2dee7";
            case 1717L: return "bfti_95625e988a";
            case 1718L: return "bfti_957e064fee";
            case 1719L: return "bfti_95841a910a";
            case 1720L: return "bfti_958d7936a2";
            case 1721L: return "bfti_95d7ebddb5";
            case 1722L: return "bfti_95dc1d54bc";
            case 1723L: return "bfti_95e007dd65";
            case 1724L: return "bfti_95f84f5bc4";
            case 1725L: return "bfti_95fd0159c9";
            case 1726L: return "bfti_9643dd1241";
            case 1727L: return "bfti_9645f5f25e";
            case 1728L: return "bfti_9646648c78";
            case 1729L: return "bfti_966e5ea019";
            case 1730L: return "bfti_9670cc57a6";
            case 1731L: return "bfti_96786b1422";
            case 1732L: return "bfti_969e915b3e";
            case 1733L: return "bfti_96a23b3f1c";
            case 1734L: return "bfti_96d278b868";
            case 1735L: return "bfti_96d86a9418";
            case 1736L: return "bfti_96e46b2a48";
            case 1737L: return "bfti_96e814a136";
            case 1738L: return "bfti_97157e1a99";
            case 1739L: return "bfti_9719c90f1e";
            case 1740L: return "bfti_97223697d6";
            case 1741L: return "bfti_9750598bf2";
            case 1742L: return "bfti_975e62d841";
            case 1743L: return "bfti_9771186bad";
            case 1744L: return "bfti_97782deb09";
            case 1745L: return "bfti_977f627e4e";
            case 1746L: return "bfti_9780112df8";
            case 1747L: return "bfti_978f35adff";
            case 1748L: return "bfti_979dce71ed";
            case 1749L: return "bfti_97a228aaf7";
            case 1750L: return "bfti_97a272029b";
            case 1751L: return "bfti_97a77dc9dc";
            case 1752L: return "bfti_97ac70d21f";
            case 1753L: return "bfti_97c6334ab2";
            case 1754L: return "bfti_97d060587d";
            case 1755L: return "bfti_97d092c547";
            case 1756L: return "bfti_97d423b41b";
            case 1757L: return "bfti_9817260056";
            case 1758L: return "bfti_98190337db";
            case 1759L: return "bfti_9822fb0c67";
            case 1760L: return "bfti_98232855aa";
            case 1761L: return "bfti_9826748757";
            case 1762L: return "bfti_9845602035";
            case 1763L: return "bfti_985122aa14";
            case 1764L: return "bfti_9858c0595e";
            case 1765L: return "bfti_98697cd677";
            case 1766L: return "bfti_989a717567";
            case 1767L: return "bfti_98af3a9f55";
            case 1768L: return "bfti_98b2a2d1c7";
            case 1769L: return "bfti_98b7ebccb3";
            case 1770L: return "bfti_994c7236f2";
            case 1771L: return "bfti_995ea30375";
            case 1772L: return "bfti_996e402141";
            case 1773L: return "bfti_9997ef5e05";
            case 1774L: return "bfti_999a34e85a";
            case 1775L: return "bfti_999c842d08";
            case 1776L: return "bfti_99cb856a25";
            case 1777L: return "bfti_99d45a72e5";
            case 1778L: return "bfti_99d83c3201";
            case 1779L: return "bfti_99e529b269";
            case 1780L: return "bfti_9a14ae649e";
            case 1781L: return "bfti_9a25299429";
            case 1782L: return "bfti_9a2c6b0ab5";
            case 1783L: return "bfti_9a35c52eb0";
            case 1784L: return "bfti_9a3665e8ec";
            case 1785L: return "bfti_9a725a31bb";
            case 1786L: return "bfti_9ac2950c02";
            case 1787L: return "bfti_9ae1438f06";
            case 1788L: return "bfti_9b027c8388";
            case 1789L: return "bfti_9b0ea52974";
            case 1790L: return "bfti_9b0fd11ad7";
            case 1791L: return "bfti_9b476090e0";
            case 1792L: return "bfti_9b554b353e";
            case 1793L: return "bfti_9b5b3864d7";
            case 1794L: return "bfti_9b5c8f0dd4";
            case 1795L: return "bfti_9b6c293511";
            case 1796L: return "bfti_9b6c9961ca";
            case 1797L: return "bfti_9ba01e673a";
            case 1798L: return "bfti_9ba69135a2";
            case 1799L: return "bfti_9bace442ee";
            case 1800L: return "bfti_9bb741341e";
            case 1801L: return "bfti_9bc66e54c6";
            case 1802L: return "bfti_9be1126281";
            case 1803L: return "bfti_9beaeb9f69";
            case 1804L: return "bfti_9c05874aa1";
            case 1805L: return "bfti_9c24c014fc";
            case 1806L: return "bfti_9c27f920d2";
            case 1807L: return "bfti_9c3dc1cb99";
            case 1808L: return "bfti_9c44510568";
            case 1809L: return "bfti_9c6a8df921";
            case 1810L: return "bfti_9c8a784289";
            case 1811L: return "bfti_9c982f2035";
            case 1812L: return "bfti_9ca365f3f3";
            case 1813L: return "bfti_9ca6fdd901";
            case 1814L: return "bfti_9cb2fdb668";
            case 1815L: return "bfti_9cc87fba14";
            case 1816L: return "bfti_9cdb773d13";
            case 1817L: return "bfti_9ceab2593a";
            case 1818L: return "bfti_9d097d2653";
            case 1819L: return "bfti_9d09a2749e";
            case 1820L: return "bfti_9d172ca88f";
            case 1821L: return "bfti_9d4a25fd11";
            case 1822L: return "bfti_9d4f5d2000";
            case 1823L: return "bfti_9d5be4102b";
            case 1824L: return "bfti_9d5d8c7bd5";
            case 1825L: return "bfti_9d88dad950";
            case 1826L: return "bfti_9d9dfaa7e7";
            case 1827L: return "bfti_9db2980d40";
            case 1828L: return "bfti_9dcaca3832";
            case 1829L: return "bfti_9dd85b86b4";
            case 1830L: return "bfti_9de588181a";
            case 1831L: return "bfti_9de5f3219a";
            case 1832L: return "bfti_9e506ef4ce";
            case 1833L: return "bfti_9e68a45d49";
            case 1834L: return "bfti_9e8d557493";
            case 1835L: return "bfti_9ed912b678";
            case 1836L: return "bfti_9ed9764c12";
            case 1837L: return "bfti_9ee6bec364";
            case 1838L: return "bfti_9f066b0fd4";
            case 1839L: return "bfti_9f1be8ddbe";
            case 1840L: return "bfti_9f3b620db0";
            case 1841L: return "bfti_9f58365915";
            case 1842L: return "bfti_9f5e73aa28";
            case 1843L: return "bfti_9f781f2e39";
            case 1844L: return "bfti_9fa982c787";
            case 1845L: return "bfti_9fc29ba203";
            case 1846L: return "bfti_9fe0a505bd";
            case 1847L: return "bfti_a06bf9107c";
            case 1848L: return "bfti_a087fe322e";
            case 1849L: return "bfti_a095ba66eb";
            case 1850L: return "bfti_a09b0703e5";
            case 1851L: return "bfti_a0ec6a4837";
            case 1852L: return "bfti_a114e3f6fd";
            case 1853L: return "bfti_a13b30e4f8";
            case 1854L: return "bfti_a18a45dfc7";
            case 1855L: return "bfti_a1b13a90e9";
            case 1856L: return "bfti_a1ce9b0d12";
            case 1857L: return "bfti_a22e651be8";
            case 1858L: return "bfti_a2340c9b69";
            case 1859L: return "bfti_a23caced50";
            case 1860L: return "bfti_a24109854b";
            case 1861L: return "bfti_a249b963d9";
            case 1862L: return "bfti_a25a9ce7b0";
            case 1863L: return "bfti_a2a588eb56";
            case 1864L: return "bfti_a2af9dda47";
            case 1865L: return "bfti_a2db2f77d6";
            case 1866L: return "bfti_a2dee1851d";
            case 1867L: return "bfti_a2dfb3b7f2";
            case 1868L: return "bfti_a301630ae9";
            case 1869L: return "bfti_a303677d17";
            case 1870L: return "bfti_a31a0bfab6";
            case 1871L: return "bfti_a320b5ba15";
            case 1872L: return "bfti_a3326a87e2";
            case 1873L: return "bfti_a349db3324";
            case 1874L: return "bfti_a36c7a0074";
            case 1875L: return "bfti_a391348047";
            case 1876L: return "bfti_a421c3755c";
            case 1877L: return "bfti_a4cc855666";
            case 1878L: return "bfti_a4d8f4fbce";
            case 1879L: return "bfti_a4e2625b44";
            case 1880L: return "bfti_a4e443f89a";
            case 1881L: return "bfti_a5027bba35";
            case 1882L: return "bfti_a50500fb68";
            case 1883L: return "bfti_a50c6981f1";
            case 1884L: return "bfti_a513da5d94";
            case 1885L: return "bfti_a523e1b056";
            case 1886L: return "bfti_a5614a5e34";
            case 1887L: return "bfti_a564a35e91";
            case 1888L: return "bfti_a570067b11";
            case 1889L: return "bfti_a576213dc5";
            case 1890L: return "bfti_a57cf152e5";
            case 1891L: return "bfti_a5e563f273";
            case 1892L: return "bfti_a60dd6abfc";
            case 1893L: return "bfti_a61495ffc3";
            case 1894L: return "bfti_a622b194a8";
            case 1895L: return "bfti_a6350825e4";
            case 1896L: return "bfti_a67d6a64e5";
            case 1897L: return "bfti_a68bee1010";
            case 1898L: return "bfti_a6a2e8bebd";
            case 1899L: return "bfti_a6bb7fd805";
            case 1900L: return "bfti_a6bc69ffdd";
            case 1901L: return "bfti_a6c9489aa5";
            case 1902L: return "bfti_a6d666c02a";
            case 1903L: return "bfti_a6dc9edac5";
            case 1904L: return "bfti_a6e9f1d2e8";
            case 1905L: return "bfti_a6f4a33394";
            case 1906L: return "bfti_a7000984b7";
            case 1907L: return "bfti_a713a6426f";
            case 1908L: return "bfti_a72b5b08af";
            case 1909L: return "bfti_a73910d0f1";
            case 1910L: return "bfti_a74c7064c4";
            case 1911L: return "bfti_a76c74de6f";
            case 1912L: return "bfti_a77f6f6a8d";
            case 1913L: return "bfti_a7b4b49d20";
            case 1914L: return "bfti_a7b9a561a6";
            case 1915L: return "bfti_a7e1873b50";
            case 1916L: return "bfti_a7e1f8822b";
            case 1917L: return "bfti_a7e6c7f882";
            case 1918L: return "bfti_a80d60191c";
            case 1919L: return "bfti_a831c26b99";
            case 1920L: return "bfti_a832f7f2ab";
            case 1921L: return "bfti_a8839e3e10";
            case 1922L: return "bfti_a8bf2e34cf";
            case 1923L: return "bfti_a8dbd2813a";
            case 1924L: return "bfti_a8dca33c0e";
            case 1925L: return "bfti_a916af4bf3";
            case 1926L: return "bfti_a931c261ce";
            case 1927L: return "bfti_a94a4521ff";
            case 1928L: return "bfti_a964a28eaf";
            case 1929L: return "bfti_a973125eab";
            case 1930L: return "bfti_a97df6728c";
            case 1931L: return "bfti_a98b196786";
            case 1932L: return "bfti_a99c03f5e2";
            case 1933L: return "bfti_a9ac3d2f90";
            case 1934L: return "bfti_a9ac565719";
            case 1935L: return "bfti_a9bbdd2f2a";
            case 1936L: return "bfti_a9dc9f480f";
            case 1937L: return "bfti_aa0ecd0181";
            case 1938L: return "bfti_aa1551ff72";
            case 1939L: return "bfti_aa250a4d86";
            case 1940L: return "bfti_aa4fe955ad";
            case 1941L: return "bfti_aa5c57371b";
            case 1942L: return "bfti_aa71e26b43";
            case 1943L: return "bfti_aa8f324063";
            case 1944L: return "bfti_aa9b69b48f";
            case 1945L: return "bfti_aa9c8f3492";
            case 1946L: return "bfti_aabc219878";
            case 1947L: return "bfti_aae661aa9e";
            case 1948L: return "bfti_aaf10250c1";
            case 1949L: return "bfti_ab0e69c6fe";
            case 1950L: return "bfti_ab2b023c48";
            case 1951L: return "bfti_ab83421b46";
            case 1952L: return "bfti_ab8f77493f";
            case 1953L: return "bfti_ababf8a4d4";
            case 1954L: return "bfti_abcb9a4eba";
            case 1955L: return "bfti_abd707cfe7";
            case 1956L: return "bfti_abe3ec3b0e";
            case 1957L: return "bfti_abf8a281a5";
            case 1958L: return "bfti_ac32ae5925";
            case 1959L: return "bfti_ac5a891877";
            case 1960L: return "bfti_ac611a7665";
            case 1961L: return "bfti_ac65215cf6";
            case 1962L: return "bfti_ac8458a5b9";
            case 1963L: return "bfti_ac8621d692";
            case 1964L: return "bfti_ac9ee299f0";
            case 1965L: return "bfti_acb4ad318c";
            case 1966L: return "bfti_acbad091a4";
            case 1967L: return "bfti_ad14f6e8d1";
            case 1968L: return "bfti_ad225dea50";
            case 1969L: return "bfti_ad7c16d446";
            case 1970L: return "bfti_ad7cb7d315";
            case 1971L: return "bfti_ad91e997c5";
            case 1972L: return "bfti_ada3f8b024";
            case 1973L: return "bfti_ada8ed44d5";
            case 1974L: return "bfti_adb78c3c8c";
            case 1975L: return "bfti_add6c40a2d";
            case 1976L: return "bfti_ae43d05fec";
            case 1977L: return "bfti_ae50b85cee";
            case 1978L: return "bfti_ae756ed007";
            case 1979L: return "bfti_ae81de53d6";
            case 1980L: return "bfti_ae979e7184";
            case 1981L: return "bfti_aea98fb72f";
            case 1982L: return "bfti_aeb6b2560f";
            case 1983L: return "bfti_aeefc643d4";
            case 1984L: return "bfti_aef717b197";
            case 1985L: return "bfti_af1960020c";
            case 1986L: return "bfti_af37b6bc8e";
            case 1987L: return "bfti_af6827f9a7";
            case 1988L: return "bfti_af8c728dea";
            case 1989L: return "bfti_af8f05590f";
            case 1990L: return "bfti_afb77f928f";
            case 1991L: return "bfti_afb846b145";
            case 1992L: return "bfti_afbfbd170c";
            case 1993L: return "bfti_b01314301e";
            case 1994L: return "bfti_b03b6e32d8";
            case 1995L: return "bfti_b03da5d6ea";
            case 1996L: return "bfti_b05181a71b";
            case 1997L: return "bfti_b052bf6f17";
            case 1998L: return "bfti_b05d3152a5";
            case 1999L: return "bfti_b0a32ea7f6";
            case 2000L: return "bfti_b0a5707e4b";
            case 2001L: return "bfti_b100a3b395";
            case 2002L: return "bfti_b10c2a0cf8";
            case 2003L: return "bfti_b121cb5651";
            case 2004L: return "bfti_b12b724257";
            case 2005L: return "bfti_b13ad3fc7f";
            case 2006L: return "bfti_b13ea8f07b";
            case 2007L: return "bfti_b147103a23";
            case 2008L: return "bfti_b16b545bf5";
            case 2009L: return "bfti_b172b9cdb7";
            case 2010L: return "bfti_b179c28184";
            case 2011L: return "bfti_b17ed5dcbb";
            case 2012L: return "bfti_b17f3f93d0";
            case 2013L: return "bfti_b18b6a8af7";
            case 2014L: return "bfti_b1a3240aac";
            case 2015L: return "bfti_b1a5f6b398";
            case 2016L: return "bfti_b1a8992f50";
            case 2017L: return "bfti_b1b2447001";
            case 2018L: return "bfti_b1b9be06e6";
            case 2019L: return "bfti_b1c1f02ee1";
            case 2020L: return "bfti_b1c8b657df";
            case 2021L: return "bfti_b1d92c4a5c";
            case 2022L: return "bfti_b23bd24559";
            case 2023L: return "bfti_b23c5f0658";
            case 2024L: return "bfti_b245f78b5a";
            case 2025L: return "bfti_b255bff837";
            case 2026L: return "bfti_b26f2b317e";
            case 2027L: return "bfti_b29f52b932";
            case 2028L: return "bfti_b2ba7aab3c";
            case 2029L: return "bfti_b2c6c7a8c0";
            case 2030L: return "bfti_b2ca075328";
            case 2031L: return "bfti_b2f5c19545";
            case 2032L: return "bfti_b318412877";
            case 2033L: return "bfti_b32020f057";
            case 2034L: return "bfti_b320aba05b";
            case 2035L: return "bfti_b356bc9028";
            case 2036L: return "bfti_b37707aa3f";
            case 2037L: return "bfti_b3c1c9347a";
            case 2038L: return "bfti_b4112262cc";
            case 2039L: return "bfti_b412716bc2";
            case 2040L: return "bfti_b4315995ad";
            case 2041L: return "bfti_b47257c93f";
            case 2042L: return "bfti_b48192f5d3";
            case 2043L: return "bfti_b4984ec0ef";
            case 2044L: return "bfti_b4a1d31f2e";
            case 2045L: return "bfti_b4a3100cbc";
            case 2046L: return "bfti_b4a3e2be21";
            case 2047L: return "bfti_b4ac1fafe1";
            case 2048L: return "bfti_b4c5441a31";
            case 2049L: return "bfti_b4e586f7fc";
            case 2050L: return "bfti_b4ee5ccba2";
            case 2051L: return "bfti_b4f69ec6b7";
            case 2052L: return "bfti_b50de25c37";
            case 2053L: return "bfti_b54abe79c8";
            case 2054L: return "bfti_b554c02ce2";
            case 2055L: return "bfti_b56bc815e5";
            case 2056L: return "bfti_b56f335e55";
            case 2057L: return "bfti_b591649efe";
            case 2058L: return "bfti_b5a2ee518b";
            case 2059L: return "bfti_b5a7112f46";
            case 2060L: return "bfti_b5af0d529f";
            case 2061L: return "bfti_b5c501764b";
            case 2062L: return "bfti_b5c8c0bbda";
            case 2063L: return "bfti_b5d02b5eb7";
            case 2064L: return "bfti_b5e7283042";
            case 2065L: return "bfti_b5ee15bd1a";
            case 2066L: return "bfti_b6245f4003";
            case 2067L: return "bfti_b63bbd445a";
            case 2068L: return "bfti_b64704e414";
            case 2069L: return "bfti_b6634d205c";
            case 2070L: return "bfti_b6a2cf437b";
            case 2071L: return "bfti_b6e5c02d17";
            case 2072L: return "bfti_b6f5a0d7c1";
            case 2073L: return "bfti_b714be47eb";
            case 2074L: return "bfti_b76ab8c883";
            case 2075L: return "bfti_b78658f4e1";
            case 2076L: return "bfti_b79cb61f2e";
            case 2077L: return "bfti_b7aad2b6c5";
            case 2078L: return "bfti_b7bba6847c";
            case 2079L: return "bfti_b7df1437c7";
            case 2080L: return "bfti_b7e0638101";
            case 2081L: return "bfti_b7e40fe912";
            case 2082L: return "bfti_b7f83bff13";
            case 2083L: return "bfti_b7fa8d58f9";
            case 2084L: return "bfti_b809e5f64e";
            case 2085L: return "bfti_b819cd2277";
            case 2086L: return "bfti_b81ae9d571";
            case 2087L: return "bfti_b82389717b";
            case 2088L: return "bfti_b835f85e76";
            case 2089L: return "bfti_b83c52ca18";
            case 2090L: return "bfti_b8546d8341";
            case 2091L: return "bfti_b860bd6059";
            case 2092L: return "bfti_b861cd456c";
            case 2093L: return "bfti_b86b8ed237";
            case 2094L: return "bfti_b87a129aa0";
            case 2095L: return "bfti_b882e72e69";
            case 2096L: return "bfti_b8b65349d2";
            case 2097L: return "bfti_b8dec5f274";
            case 2098L: return "bfti_b8fb3c39ef";
            case 2099L: return "bfti_b90e8a9365";
            case 2100L: return "bfti_b91a7e7347";
            case 2101L: return "bfti_b921391022";
            case 2102L: return "bfti_b950d05de8";
            case 2103L: return "bfti_b9beb23acb";
            case 2104L: return "bfti_b9f528dee4";
            case 2105L: return "bfti_b9fe771df3";
            case 2106L: return "bfti_ba3e5d93bd";
            case 2107L: return "bfti_ba477bbdc0";
            case 2108L: return "bfti_ba4f0f6d28";
            case 2109L: return "bfti_baa2656971";
            case 2110L: return "bfti_baab380765";
            case 2111L: return "bfti_baed55dfbb";
            case 2112L: return "bfti_baf28ede80";
            case 2113L: return "bfti_baf3b2dfcf";
            case 2114L: return "bfti_baf82fd146";
            case 2115L: return "bfti_bb16e940b2";
            case 2116L: return "bfti_bb29e28c23";
            case 2117L: return "bfti_bb2e076aa5";
            case 2118L: return "bfti_bb315dbb21";
            case 2119L: return "bfti_bb351775e5";
            case 2120L: return "bfti_bb44225be0";
            case 2121L: return "bfti_bb487b2a53";
            case 2122L: return "bfti_bb523499cd";
            case 2123L: return "bfti_bb574affa7";
            case 2124L: return "bfti_bb5997c548";
            case 2125L: return "bfti_bb6ed2ce2e";
            case 2126L: return "bfti_bb7829c5b9";
            case 2127L: return "bfti_bbb987c096";
            case 2128L: return "bfti_bbc25e0dc2";
            case 2129L: return "bfti_bbc5d4c040";
            case 2130L: return "bfti_bbd4d841c4";
            case 2131L: return "bfti_bbe5e95ac5";
            case 2132L: return "bfti_bbf2ffcd1c";
            case 2133L: return "bfti_bbfb1332fc";
            case 2134L: return "bfti_bc0b7b8489";
            case 2135L: return "bfti_bc51497c04";
            case 2136L: return "bfti_bc5aa605e4";
            case 2137L: return "bfti_bc6274496d";
            case 2138L: return "bfti_bc8d46fb1a";
            case 2139L: return "bfti_bca2424fdb";
            case 2140L: return "bfti_bca4101e33";
            case 2141L: return "bfti_bcab3ce0f1";
            case 2142L: return "bfti_bcb2ad201a";
            case 2143L: return "bfti_bcb322c85e";
            case 2144L: return "bfti_bcb92d7395";
            case 2145L: return "bfti_bcd62b5e65";
            case 2146L: return "bfti_bcdc397f47";
            case 2147L: return "bfti_bcde0dedc5";
            case 2148L: return "bfti_bce767038d";
            case 2149L: return "bfti_bcfb9b3225";
            case 2150L: return "bfti_bd1558b62f";
            case 2151L: return "bfti_bd1d3d9c37";
            case 2152L: return "bfti_bd2356546c";
            case 2153L: return "bfti_bd2ab5c502";
            case 2154L: return "bfti_bd32056632";
            case 2155L: return "bfti_bd4ceb4932";
            case 2156L: return "bfti_bd621682b6";
            case 2157L: return "bfti_bd8c77ba6b";
            case 2158L: return "bfti_bd9819dc18";
            case 2159L: return "bfti_bdc1956832";
            case 2160L: return "bfti_bdcd8083e4";
            case 2161L: return "bfti_bdd2b92448";
            case 2162L: return "bfti_bdd81c65f2";
            case 2163L: return "bfti_bde022c46a";
            case 2164L: return "bfti_bdebe478f1";
            case 2165L: return "bfti_bdec379159";
            case 2166L: return "bfti_be596be481";
            case 2167L: return "bfti_be5b4fa6c2";
            case 2168L: return "bfti_be861bb9a5";
            case 2169L: return "bfti_be9f8a325d";
            case 2170L: return "bfti_bef0d3b28d";
            case 2171L: return "bfti_bf0d377f9d";
            case 2172L: return "bfti_bf1aa577a0";
            case 2173L: return "bfti_bf1ce0b344";
            case 2174L: return "bfti_bf4fd453ea";
            case 2175L: return "bfti_bf7138da88";
            case 2176L: return "bfti_bf925784db";
            case 2177L: return "bfti_bf93e91c21";
            case 2178L: return "bfti_bfa8b8f089";
            case 2179L: return "bfti_bfd0306c9b";
            case 2180L: return "bfti_bfef6b4679";
            case 2181L: return "bfti_bffe5089a8";
            case 2182L: return "bfti_c00738ccbc";
            case 2183L: return "bfti_c046c3de04";
            case 2184L: return "bfti_c06a217627";
            case 2185L: return "bfti_c07b55824b";
            case 2186L: return "bfti_c090b4da80";
            case 2187L: return "bfti_c0ad293ee9";
            case 2188L: return "bfti_c0b9a64723";
            case 2189L: return "bfti_c0bf68e2cd";
            case 2190L: return "bfti_c0ced6310a";
            case 2191L: return "bfti_c1462f7be1";
            case 2192L: return "bfti_c1a8628bd2";
            case 2193L: return "bfti_c1ad3876b0";
            case 2194L: return "bfti_c1bff6ca19";
            case 2195L: return "bfti_c1c10f6aa6";
            case 2196L: return "bfti_c1d6e8432a";
            case 2197L: return "bfti_c1efdbc200";
            case 2198L: return "bfti_c2009fd9ab";
            case 2199L: return "bfti_c223500f6d";
            case 2200L: return "bfti_c2340d1d37";
            case 2201L: return "bfti_c24e344492";
            case 2202L: return "bfti_c29041c36e";
            case 2203L: return "bfti_c2b80612d6";
            case 2204L: return "bfti_c2c14da164";
            case 2205L: return "bfti_c2e3d90748";
            case 2206L: return "bfti_c2e53f9658";
            case 2207L: return "bfti_c32fc88bd0";
            case 2208L: return "bfti_c33009e127";
            case 2209L: return "bfti_c338109c5f";
            case 2210L: return "bfti_c3392e25ed";
            case 2211L: return "bfti_c346bd1fcf";
            case 2212L: return "bfti_c374f16abb";
            case 2213L: return "bfti_c37512cb13";
            case 2214L: return "bfti_c38303da51";
            case 2215L: return "bfti_c39b9d298e";
            case 2216L: return "bfti_c3b5a8412b";
            case 2217L: return "bfti_c3b6b58f93";
            case 2218L: return "bfti_c3be8f26bf";
            case 2219L: return "bfti_c3d4ef9433";
            case 2220L: return "bfti_c3f0bd713a";
            case 2221L: return "bfti_c3f9222f82";
            case 2222L: return "bfti_c40c7a3275";
            case 2223L: return "bfti_c4268824f4";
            case 2224L: return "bfti_c4297fc795";
            case 2225L: return "bfti_c4405dc80c";
            case 2226L: return "bfti_c4504ef4c4";
            case 2227L: return "bfti_c4529931c7";
            case 2228L: return "bfti_c453e83cd1";
            case 2229L: return "bfti_c4683b629f";
            case 2230L: return "bfti_c486763381";
            case 2231L: return "bfti_c48aa2cb1f";
            case 2232L: return "bfti_c490eece28";
            case 2233L: return "bfti_c494c62ea0";
            case 2234L: return "bfti_c496889b3a";
            case 2235L: return "bfti_c49f1724b4";
            case 2236L: return "bfti_c4b6487e95";
            case 2237L: return "bfti_c4b9ba9800";
            case 2238L: return "bfti_c4de4e68f2";
            case 2239L: return "bfti_c4ebf1ddc4";
            case 2240L: return "bfti_c4f5fad99a";
            case 2241L: return "bfti_c4f7dcaba1";
            case 2242L: return "bfti_c532468eae";
            case 2243L: return "bfti_c54d9bc801";
            case 2244L: return "bfti_c55ce00b27";
            case 2245L: return "bfti_c56e0926eb";
            case 2246L: return "bfti_c58134e999";
            case 2247L: return "bfti_c5a45828bd";
            case 2248L: return "bfti_c5e144957a";
            case 2249L: return "bfti_c5e2c98b4b";
            case 2250L: return "bfti_c5e386daca";
            case 2251L: return "bfti_c5ed5c3921";
            case 2252L: return "bfti_c5f0e385df";
            case 2253L: return "bfti_c608d1e9fe";
            case 2254L: return "bfti_c63833fcf7";
            case 2255L: return "bfti_c640f31d68";
            case 2256L: return "bfti_c659e7568e";
            case 2257L: return "bfti_c689a0ffc4";
            case 2258L: return "bfti_c697583e6b";
            case 2259L: return "bfti_c6b60f984e";
            case 2260L: return "bfti_c6dd9b460c";
            case 2261L: return "bfti_c6ff840450";
            case 2262L: return "bfti_c707207fe7";
            case 2263L: return "bfti_c738da4d9e";
            case 2264L: return "bfti_c75b1f89e7";
            case 2265L: return "bfti_c764c56728";
            case 2266L: return "bfti_c76a3e75e0";
            case 2267L: return "bfti_c777c8fad5";
            case 2268L: return "bfti_c7792ddeb7";
            case 2269L: return "bfti_c7989b2e00";
            case 2270L: return "bfti_c7ab251502";
            case 2271L: return "bfti_c7b0779a73";
            case 2272L: return "bfti_c7b517a1b1";
            case 2273L: return "bfti_c7b9951cea";
            case 2274L: return "bfti_c7c395da0f";
            case 2275L: return "bfti_c7df608793";
            case 2276L: return "bfti_c7fda86b96";
            case 2277L: return "bfti_c8136316b5";
            case 2278L: return "bfti_c8327ef2dd";
            case 2279L: return "bfti_c833811d37";
            case 2280L: return "bfti_c83455426e";
            case 2281L: return "bfti_c86aa80f14";
            case 2282L: return "bfti_c87589206d";
            case 2283L: return "bfti_c8846b59d3";
            case 2284L: return "bfti_c8a2ddf896";
            case 2285L: return "bfti_c8cfe57591";
            case 2286L: return "bfti_c8d8accf5f";
            case 2287L: return "bfti_c8ebf7c9dd";
            case 2288L: return "bfti_c8ecfe09e8";
            case 2289L: return "bfti_c9079f5330";
            case 2290L: return "bfti_c910cf5051";
            case 2291L: return "bfti_c922566151";
            case 2292L: return "bfti_c92453a0a7";
            case 2293L: return "bfti_c9630d09dc";
            case 2294L: return "bfti_c96c630c47";
            case 2295L: return "bfti_c96e076b7e";
            case 2296L: return "bfti_c97258b9ee";
            case 2297L: return "bfti_c979e19b7f";
            case 2298L: return "bfti_c98236df38";
            case 2299L: return "bfti_c9aac098a5";
            case 2300L: return "bfti_c9b1d07410";
            case 2301L: return "bfti_c9b4b2d405";
            case 2302L: return "bfti_c9d8d1fc87";
            case 2303L: return "bfti_ca1c9559d7";
            case 2304L: return "bfti_ca58a2a76f";
            case 2305L: return "bfti_ca6f7b483a";
            case 2306L: return "bfti_ca82943ec4";
            case 2307L: return "bfti_cae4f0d655";
            case 2308L: return "bfti_cb08d9acdd";
            case 2309L: return "bfti_cb2e3c0d19";
            case 2310L: return "bfti_cb51215561";
            case 2311L: return "bfti_cb615dfef4";
            case 2312L: return "bfti_cb82911f50";
            case 2313L: return "bfti_cb9f72e7da";
            case 2314L: return "bfti_cba2107c00";
            case 2315L: return "bfti_cbc277c523";
            case 2316L: return "bfti_cbd3e996ec";
            case 2317L: return "bfti_cbd9894a96";
            case 2318L: return "bfti_cbe3c97219";
            case 2319L: return "bfti_cc0b0f1337";
            case 2320L: return "bfti_cc39c5e2ac";
            case 2321L: return "bfti_cc4c54e835";
            case 2322L: return "bfti_cc5fb7ed79";
            case 2323L: return "bfti_cc6260b2e9";
            case 2324L: return "bfti_cc6bc683af";
            case 2325L: return "bfti_cc98505991";
            case 2326L: return "bfti_ccaaf9af09";
            case 2327L: return "bfti_ccb370f3b2";
            case 2328L: return "bfti_ccc273dcf6";
            case 2329L: return "bfti_cce576adeb";
            case 2330L: return "bfti_ccf31a1797";
            case 2331L: return "bfti_cd430465f5";
            case 2332L: return "bfti_cd67dcc966";
            case 2333L: return "bfti_cd68c004c9";
            case 2334L: return "bfti_cd9d6e69ac";
            case 2335L: return "bfti_cdb3ae5237";
            case 2336L: return "bfti_cdb44d631c";
            case 2337L: return "bfti_cdb64f8594";
            case 2338L: return "bfti_cdc173fd55";
            case 2339L: return "bfti_cdd2355e00";
            case 2340L: return "bfti_cdfe41ac24";
            case 2341L: return "bfti_ce0804814a";
            case 2342L: return "bfti_ce1514baf2";
            case 2343L: return "bfti_ce27cb807f";
            case 2344L: return "bfti_ce30e7e6f6";
            case 2345L: return "bfti_ce64a83900";
            case 2346L: return "bfti_ceab1b8cd5";
            case 2347L: return "bfti_ceba7bd7ee";
            case 2348L: return "bfti_cec05a888a";
            case 2349L: return "bfti_cec652711f";
            case 2350L: return "bfti_cec909ed39";
            case 2351L: return "bfti_ced0dc715b";
            case 2352L: return "bfti_cedc14d25c";
            case 2353L: return "bfti_cf1272f225";
            case 2354L: return "bfti_cf22057832";
            case 2355L: return "bfti_cf467abd62";
            case 2356L: return "bfti_cf5ff952f2";
            case 2357L: return "bfti_cf61138d5c";
            case 2358L: return "bfti_cf7938e882";
            case 2359L: return "bfti_cfa9d49722";
            case 2360L: return "bfti_cfd0be8b3c";
            case 2361L: return "bfti_cfd4683658";
            case 2362L: return "bfti_cfee8e1f3a";
            case 2363L: return "bfti_d01b2ed9f0";
            case 2364L: return "bfti_d03f5672de";
            case 2365L: return "bfti_d073fda265";
            case 2366L: return "bfti_d09216e200";
            case 2367L: return "bfti_d09a1e33d9";
            case 2368L: return "bfti_d09e01a8e5";
            case 2369L: return "bfti_d09e62a95e";
            case 2370L: return "bfti_d0f14e168d";
            case 2371L: return "bfti_d0fa8fe4ce";
            case 2372L: return "bfti_d0fdbdb40d";
            case 2373L: return "bfti_d0ff042992";
            case 2374L: return "bfti_d10aafd5a3";
            case 2375L: return "bfti_d10e6d91c1";
            case 2376L: return "bfti_d1539785fc";
            case 2377L: return "bfti_d155030d64";
            case 2378L: return "bfti_d156b6898a";
            case 2379L: return "bfti_d18b29ea35";
            case 2380L: return "bfti_d18f0cc527";
            case 2381L: return "bfti_d195fa1e38";
            case 2382L: return "bfti_d19686246a";
            case 2383L: return "bfti_d1bf93f85a";
            case 2384L: return "bfti_d206537496";
            case 2385L: return "bfti_d215731d67";
            case 2386L: return "bfti_d23b2a69b6";
            case 2387L: return "bfti_d2469ffa77";
            case 2388L: return "bfti_d25b677b38";
            case 2389L: return "bfti_d275e5d4e6";
            case 2390L: return "bfti_d28bcd8da9";
            case 2391L: return "bfti_d29eca8d67";
            case 2392L: return "bfti_d2b73518d2";
            case 2393L: return "bfti_d2b7e74eda";
            case 2394L: return "bfti_d2e074961c";
            case 2395L: return "bfti_d2e97c17cc";
            case 2396L: return "bfti_d2f9401152";
            case 2397L: return "bfti_d30110d3fb";
            case 2398L: return "bfti_d31456abaa";
            case 2399L: return "bfti_d35d7b8e13";
            case 2400L: return "bfti_d36b9a2182";
            case 2401L: return "bfti_d39659f2ab";
            case 2402L: return "bfti_d3c0217805";
            case 2403L: return "bfti_d3d6136347";
            case 2404L: return "bfti_d3e3c773d9";
            case 2405L: return "bfti_d3ea2c77cd";
            case 2406L: return "bfti_d3f623646c";
            case 2407L: return "bfti_d3ff668cbf";
            case 2408L: return "bfti_d408b1ef2e";
            case 2409L: return "bfti_d410ba086b";
            case 2410L: return "bfti_d41d549174";
            case 2411L: return "bfti_d45473f6de";
            case 2412L: return "bfti_d45eea814d";
            case 2413L: return "bfti_d494954117";
            case 2414L: return "bfti_d4a2038c67";
            case 2415L: return "bfti_d4a876c514";
            case 2416L: return "bfti_d4c9ce383a";
            case 2417L: return "bfti_d4dbbf6949";
            case 2418L: return "bfti_d4e8d2026f";
            case 2419L: return "bfti_d4ef95ae10";
            case 2420L: return "bfti_d4f6569585";
            case 2421L: return "bfti_d518665079";
            case 2422L: return "bfti_d51bcf4fe6";
            case 2423L: return "bfti_d5317f6a19";
            case 2424L: return "bfti_d54836d3d4";
            case 2425L: return "bfti_d573552715";
            case 2426L: return "bfti_d58e2de4dc";
            case 2427L: return "bfti_d58ee2f5ff";
            case 2428L: return "bfti_d59475e5a6";
            case 2429L: return "bfti_d5954c2bbd";
            case 2430L: return "bfti_d59de47a45";
            case 2431L: return "bfti_d5acd53784";
            case 2432L: return "bfti_d5e0afcb65";
            case 2433L: return "bfti_d5e4a911fd";
            case 2434L: return "bfti_d5e96f9474";
            case 2435L: return "bfti_d60608391d";
            case 2436L: return "bfti_d617cfd87c";
            case 2437L: return "bfti_d66dbb3d53";
            case 2438L: return "bfti_d688d49c70";
            case 2439L: return "bfti_d6cf059146";
            case 2440L: return "bfti_d6e5a130af";
            case 2441L: return "bfti_d6eaa3bded";
            case 2442L: return "bfti_d71edc2775";
            case 2443L: return "bfti_d764410123";
            case 2444L: return "bfti_d769be6c4b";
            case 2445L: return "bfti_d76a199920";
            case 2446L: return "bfti_d771daa69d";
            case 2447L: return "bfti_d7885d2b11";
            case 2448L: return "bfti_d7bc6f4522";
            case 2449L: return "bfti_d7f5582c63";
            case 2450L: return "bfti_d7f86f4474";
            case 2451L: return "bfti_d81d222b15";
            case 2452L: return "bfti_d83fa8462e";
            case 2453L: return "bfti_d85b84eee8";
            case 2454L: return "bfti_d86859bfe2";
            case 2455L: return "bfti_d88f511064";
            case 2456L: return "bfti_d91239a169";
            case 2457L: return "bfti_d91cbf36fa";
            case 2458L: return "bfti_d9629cde9c";
            case 2459L: return "bfti_d981a6fe0b";
            case 2460L: return "bfti_d98fac9738";
            case 2461L: return "bfti_d98fda487c";
            case 2462L: return "bfti_d9a22ef3b7";
            case 2463L: return "bfti_d9af0bc253";
            case 2464L: return "bfti_da0c05bdea";
            case 2465L: return "bfti_da1b23ce08";
            case 2466L: return "bfti_da23cbda82";
            case 2467L: return "bfti_da2ae06c81";
            case 2468L: return "bfti_da479757b6";
            case 2469L: return "bfti_da509d69d8";
            case 2470L: return "bfti_da51c943f2";
            case 2471L: return "bfti_da6f63fa25";
            case 2472L: return "bfti_da7aeece0f";
            case 2473L: return "bfti_daa9a51b8f";
            case 2474L: return "bfti_dac269456c";
            case 2475L: return "bfti_dafb9f78bc";
            case 2476L: return "bfti_db13c0f900";
            case 2477L: return "bfti_db1484c146";
            case 2478L: return "bfti_db1e578566";
            case 2479L: return "bfti_db27305150";
            case 2480L: return "bfti_db3e8bcf93";
            case 2481L: return "bfti_db4a4eba52";
            case 2482L: return "bfti_db523ae1e7";
            case 2483L: return "bfti_db6fa28728";
            case 2484L: return "bfti_db7b4183db";
            case 2485L: return "bfti_db81816ecd";
            case 2486L: return "bfti_db932471d7";
            case 2487L: return "bfti_dbac1e5ee4";
            case 2488L: return "bfti_dc01001a53";
            case 2489L: return "bfti_dc41587246";
            case 2490L: return "bfti_dc55d8e45c";
            case 2491L: return "bfti_dc59fded37";
            case 2492L: return "bfti_dcbf0c9924";
            case 2493L: return "bfti_dcda675c5e";
            case 2494L: return "bfti_dd0544598a";
            case 2495L: return "bfti_dd0edf0911";
            case 2496L: return "bfti_dd1dccfad5";
            case 2497L: return "bfti_dd28ae7c26";
            case 2498L: return "bfti_dd5c34f83a";
            case 2499L: return "bfti_dd925c690b";
            case 2500L: return "bfti_dda79210d5";
            case 2501L: return "bfti_ddaef1085b";
            case 2502L: return "bfti_ddbaa69943";
            case 2503L: return "bfti_dde2d2df2e";
            case 2504L: return "bfti_dde9c31aab";
            case 2505L: return "bfti_ddeaddad2a";
            case 2506L: return "bfti_ddeefbc544";
            case 2507L: return "bfti_de11980b8e";
            case 2508L: return "bfti_de121de5f9";
            case 2509L: return "bfti_de39384a90";
            case 2510L: return "bfti_de4ada85b6";
            case 2511L: return "bfti_de4bc29402";
            case 2512L: return "bfti_de7ba1a682";
            case 2513L: return "bfti_de826caa72";
            case 2514L: return "bfti_de8ba52df3";
            case 2515L: return "bfti_deb4a5042b";
            case 2516L: return "bfti_debe442f2e";
            case 2517L: return "bfti_dec1ea95c7";
            case 2518L: return "bfti_decc8423bf";
            case 2519L: return "bfti_decd0bd8c4";
            case 2520L: return "bfti_ded1e53cc0";
            case 2521L: return "bfti_dee8d7ed9e";
            case 2522L: return "bfti_def576084b";
            case 2523L: return "bfti_defb063cfb";
            case 2524L: return "bfti_df03cea8d8";
            case 2525L: return "bfti_df04730baf";
            case 2526L: return "bfti_df047ee4cb";
            case 2527L: return "bfti_df120f4412";
            case 2528L: return "bfti_df4d8f86e5";
            case 2529L: return "bfti_df502df456";
            case 2530L: return "bfti_df68fabc68";
            case 2531L: return "bfti_df6a583863";
            case 2532L: return "bfti_df7afde2a6";
            case 2533L: return "bfti_dfb5b095d4";
            case 2534L: return "bfti_dfba09f926";
            case 2535L: return "bfti_dfd5970a83";
            case 2536L: return "bfti_dfe7984531";
            case 2537L: return "bfti_dfffb43f8a";
            case 2538L: return "bfti_e0036e3da2";
            case 2539L: return "bfti_e02d34d7fe";
            case 2540L: return "bfti_e0376efc04";
            case 2541L: return "bfti_e04dbe1ed1";
            case 2542L: return "bfti_e0724b2ea7";
            case 2543L: return "bfti_e094af64d6";
            case 2544L: return "bfti_e0d03ab848";
            case 2545L: return "bfti_e0db2a4a53";
            case 2546L: return "bfti_e0e377c1bd";
            case 2547L: return "bfti_e0f016d195";
            case 2548L: return "bfti_e10177b3df";
            case 2549L: return "bfti_e1066b5ec4";
            case 2550L: return "bfti_e11fbc319c";
            case 2551L: return "bfti_e150a4d6a7";
            case 2552L: return "bfti_e173c3bdad";
            case 2553L: return "bfti_e1b9eda92e";
            case 2554L: return "bfti_e1be22c277";
            case 2555L: return "bfti_e1c0492848";
            case 2556L: return "bfti_e1d2731998";
            case 2557L: return "bfti_e1e58145da";
            case 2558L: return "bfti_e1f0e8999f";
            case 2559L: return "bfti_e1fb5e1fe8";
            case 2560L: return "bfti_e21b2ece9e";
            case 2561L: return "bfti_e23bf60b57";
            case 2562L: return "bfti_e25287f555";
            case 2563L: return "bfti_e256fbb843";
            case 2564L: return "bfti_e263f16f9e";
            case 2565L: return "bfti_e27df2d830";
            case 2566L: return "bfti_e29e8c76f5";
            case 2567L: return "bfti_e2b1e35e94";
            case 2568L: return "bfti_e2b8528272";
            case 2569L: return "bfti_e2ba2f25f2";
            case 2570L: return "bfti_e2bf034f20";
            case 2571L: return "bfti_e2dcbe343e";
            case 2572L: return "bfti_e2dd9e2e56";
            case 2573L: return "bfti_e2e4d7865c";
            case 2574L: return "bfti_e307270b1f";
            case 2575L: return "bfti_e3075b9388";
            case 2576L: return "bfti_e326673aec";
            case 2577L: return "bfti_e330738694";
            case 2578L: return "bfti_e3394256ac";
            case 2579L: return "bfti_e3a2e4983e";
            case 2580L: return "bfti_e3ae10b090";
            case 2581L: return "bfti_e402efe3af";
            case 2582L: return "bfti_e41b3d135d";
            case 2583L: return "bfti_e42963e8e2";
            case 2584L: return "bfti_e44bf2bd1c";
            case 2585L: return "bfti_e46136fb52";
            case 2586L: return "bfti_e467e41671";
            case 2587L: return "bfti_e4c2962623";
            case 2588L: return "bfti_e4e20f172b";
            case 2589L: return "bfti_e4fc7a1cc8";
            case 2590L: return "bfti_e51a9102f6";
            case 2591L: return "bfti_e51e3a2fcb";
            case 2592L: return "bfti_e522dade13";
            case 2593L: return "bfti_e53440bad4";
            case 2594L: return "bfti_e53c9ad5af";
            case 2595L: return "bfti_e5d921181f";
            case 2596L: return "bfti_e6103617cb";
            case 2597L: return "bfti_e62982b650";
            case 2598L: return "bfti_e6470ea292";
            case 2599L: return "bfti_e658c32910";
            case 2600L: return "bfti_e66eedb580";
            case 2601L: return "bfti_e67424b084";
            case 2602L: return "bfti_e68a5c2caf";
            case 2603L: return "bfti_e69d6edd95";
            case 2604L: return "bfti_e6c6ba8e25";
            case 2605L: return "bfti_e6dae0b968";
            case 2606L: return "bfti_e6df4483d3";
            case 2607L: return "bfti_e6df7e3040";
            case 2608L: return "bfti_e7110292a4";
            case 2609L: return "bfti_e7223491ae";
            case 2610L: return "bfti_e72b870587";
            case 2611L: return "bfti_e72d0bc0dd";
            case 2612L: return "bfti_e7498b0c2a";
            case 2613L: return "bfti_e784cbea37";
            case 2614L: return "bfti_e791e571c0";
            case 2615L: return "bfti_e7a095423e";
            case 2616L: return "bfti_e7bf8df06e";
            case 2617L: return "bfti_e7ea306c2e";
            case 2618L: return "bfti_e80fc1d2a3";
            case 2619L: return "bfti_e81ba5a612";
            case 2620L: return "bfti_e81f140e1a";
            case 2621L: return "bfti_e82e20a540";
            case 2622L: return "bfti_e8320ce01e";
            case 2623L: return "bfti_e8341b76ec";
            case 2624L: return "bfti_e8378314e4";
            case 2625L: return "bfti_e8395d327b";
            case 2626L: return "bfti_e8531a1bd8";
            case 2627L: return "bfti_e86032bd75";
            case 2628L: return "bfti_e86f5fc5bc";
            case 2629L: return "bfti_e888b40562";
            case 2630L: return "bfti_e89a02e09f";
            case 2631L: return "bfti_e8abb52925";
            case 2632L: return "bfti_e8d8539733";
            case 2633L: return "bfti_e91a9eefe2";
            case 2634L: return "bfti_e92ecd5d63";
            case 2635L: return "bfti_e944e016ac";
            case 2636L: return "bfti_e94efe43f7";
            case 2637L: return "bfti_e95ca7a9ed";
            case 2638L: return "bfti_e9787a51d7";
            case 2639L: return "bfti_e9940d4b68";
            case 2640L: return "bfti_e996f47390";
            case 2641L: return "bfti_e9db9c5af0";
            case 2642L: return "bfti_e9fdf9e610";
            case 2643L: return "bfti_ea186403d9";
            case 2644L: return "bfti_ea18a9682b";
            case 2645L: return "bfti_ea3d7c0b91";
            case 2646L: return "bfti_ea44be3ef1";
            case 2647L: return "bfti_ea531035ce";
            case 2648L: return "bfti_eab9d74080";
            case 2649L: return "bfti_eac41a89c8";
            case 2650L: return "bfti_ead9a4aae5";
            case 2651L: return "bfti_eade1f14ce";
            case 2652L: return "bfti_eaeabc9957";
            case 2653L: return "bfti_eaf552bbd5";
            case 2654L: return "bfti_eb0f764104";
            case 2655L: return "bfti_eb249ec982";
            case 2656L: return "bfti_eb53e38271";
            case 2657L: return "bfti_eb712f0bdb";
            case 2658L: return "bfti_eb774769c9";
            case 2659L: return "bfti_eb800a3ed7";
            case 2660L: return "bfti_eb991ad3f8";
            case 2661L: return "bfti_eba6079ecb";
            case 2662L: return "bfti_eba8fe603d";
            case 2663L: return "bfti_ebb47ef126";
            case 2664L: return "bfti_ebca67decf";
            case 2665L: return "bfti_ebcb25d721";
            case 2666L: return "bfti_ebe12987ea";
            case 2667L: return "bfti_ebf31d7e78";
            case 2668L: return "bfti_ec1c4fc343";
            case 2669L: return "bfti_ec3991cdb3";
            case 2670L: return "bfti_ec4e93048b";
            case 2671L: return "bfti_ec510b378a";
            case 2672L: return "bfti_ec8294af72";
            case 2673L: return "bfti_ec9eaa6cc9";
            case 2674L: return "bfti_eca5dcd6fd";
            case 2675L: return "bfti_ecbf7c3952";
            case 2676L: return "bfti_ecc1777e00";
            case 2677L: return "bfti_ecd989c159";
            case 2678L: return "bfti_ece9cd73a7";
            case 2679L: return "bfti_ed1bd06043";
            case 2680L: return "bfti_ed1f9fee39";
            case 2681L: return "bfti_ed2a28af9f";
            case 2682L: return "bfti_ed3c271523";
            case 2683L: return "bfti_ed6b7fc650";
            case 2684L: return "bfti_ed83f24fc9";
            case 2685L: return "bfti_edb0d22177";
            case 2686L: return "bfti_edbc91ac4f";
            case 2687L: return "bfti_ee07931288";
            case 2688L: return "bfti_ee0e12d5d8";
            case 2689L: return "bfti_ee1399701a";
            case 2690L: return "bfti_ee27c81565";
            case 2691L: return "bfti_ee4e80e92e";
            case 2692L: return "bfti_ee781628c3";
            case 2693L: return "bfti_ee7dbfc59b";
            case 2694L: return "bfti_ee9498a725";
            case 2695L: return "bfti_eebb362371";
            case 2696L: return "bfti_ef0879a007";
            case 2697L: return "bfti_ef45e5427a";
            case 2698L: return "bfti_ef69064538";
            case 2699L: return "bfti_ef6b16135c";
            case 2700L: return "bfti_ef9c2a2588";
            case 2701L: return "bfti_efa0ef3f8b";
            case 2702L: return "bfti_efa15b104e";
            case 2703L: return "bfti_efc83f14da";
            case 2704L: return "bfti_efdfb5ab89";
            case 2705L: return "bfti_efe666961d";
            case 2706L: return "bfti_efefccb61e";
            case 2707L: return "bfti_f00037c220";
            case 2708L: return "bfti_f0005979bc";
            case 2709L: return "bfti_f004038852";
            case 2710L: return "bfti_f04bca1267";
            case 2711L: return "bfti_f07f86a340";
            case 2712L: return "bfti_f098fd319a";
            case 2713L: return "bfti_f0cc077772";
            case 2714L: return "bfti_f0e48fbf1d";
            case 2715L: return "bfti_f0e7a08dc6";
            case 2716L: return "bfti_f1061ac2ec";
            case 2717L: return "bfti_f11709c0ca";
            case 2718L: return "bfti_f138ac7f54";
            case 2719L: return "bfti_f14d5f0e55";
            case 2720L: return "bfti_f14f60a211";
            case 2721L: return "bfti_f161ef81d6";
            case 2722L: return "bfti_f16def1781";
            case 2723L: return "bfti_f175fa97ba";
            case 2724L: return "bfti_f17bd906f1";
            case 2725L: return "bfti_f1ae98068c";
            case 2726L: return "bfti_f1ec082751";
            case 2727L: return "bfti_f23cd7545e";
            case 2728L: return "bfti_f28ea9078f";
            case 2729L: return "bfti_f2e82fe7eb";
            case 2730L: return "bfti_f2f30c1868";
            case 2731L: return "bfti_f2f537231c";
            case 2732L: return "bfti_f303144c3a";
            case 2733L: return "bfti_f31078c017";
            case 2734L: return "bfti_f31fa9d57d";
            case 2735L: return "bfti_f328af8e55";
            case 2736L: return "bfti_f349b86ad0";
            case 2737L: return "bfti_f3625a753e";
            case 2738L: return "bfti_f3631a7563";
            case 2739L: return "bfti_f36a819e53";
            case 2740L: return "bfti_f388485362";
            case 2741L: return "bfti_f3a9c0ffa8";
            case 2742L: return "bfti_f3abd7f47f";
            case 2743L: return "bfti_f3b7558a14";
            case 2744L: return "bfti_f3c4691d8b";
            case 2745L: return "bfti_f3c8d4357c";
            case 2746L: return "bfti_f3cad457a7";
            case 2747L: return "bfti_f3dc909b34";
            case 2748L: return "bfti_f3fe702729";
            case 2749L: return "bfti_f40211b778";
            case 2750L: return "bfti_f41a7e5346";
            case 2751L: return "bfti_f42ad892e3";
            case 2752L: return "bfti_f45819239a";
            case 2753L: return "bfti_f47907394b";
            case 2754L: return "bfti_f48de439d2";
            case 2755L: return "bfti_f48e738432";
            case 2756L: return "bfti_f4ab981150";
            case 2757L: return "bfti_f4b8e269fd";
            case 2758L: return "bfti_f4cf58d722";
            case 2759L: return "bfti_f4d5595ade";
            case 2760L: return "bfti_f4efa1f3e0";
            case 2761L: return "bfti_f522976c00";
            case 2762L: return "bfti_f53fc97195";
            case 2763L: return "bfti_f546d4cc7d";
            case 2764L: return "bfti_f5a37604a0";
            case 2765L: return "bfti_f5af8f0f9d";
            case 2766L: return "bfti_f5cfb4b36d";
            case 2767L: return "bfti_f6139a5b1c";
            case 2768L: return "bfti_f619988375";
            case 2769L: return "bfti_f667f7472c";
            case 2770L: return "bfti_f66a6e2446";
            case 2771L: return "bfti_f675857266";
            case 2772L: return "bfti_f68345ce77";
            case 2773L: return "bfti_f68f94e898";
            case 2774L: return "bfti_f6b167f49c";
            case 2775L: return "bfti_f6e13c6253";
            case 2776L: return "bfti_f6f6715eae";
            case 2777L: return "bfti_f701d29bf6";
            case 2778L: return "bfti_f7096e66b8";
            case 2779L: return "bfti_f7469c46ee";
            case 2780L: return "bfti_f7541e2606";
            case 2781L: return "bfti_f7a9dd4858";
            case 2782L: return "bfti_f7b5c01d95";
            case 2783L: return "bfti_f7bce644c8";
            case 2784L: return "bfti_f7dd90f22c";
            case 2785L: return "bfti_f7e06f26f2";
            case 2786L: return "bfti_f7e85347c6";
            case 2787L: return "bfti_f7fa335e50";
            case 2788L: return "bfti_f80defb21e";
            case 2789L: return "bfti_f81185710d";
            case 2790L: return "bfti_f825c51446";
            case 2791L: return "bfti_f827dc336c";
            case 2792L: return "bfti_f84b461ec8";
            case 2793L: return "bfti_f8b96e2714";
            case 2794L: return "bfti_f8bcc4fb0c";
            case 2795L: return "bfti_f8e01da3da";
            case 2796L: return "bfti_f8e4c00692";
            case 2797L: return "bfti_f8e6203699";
            case 2798L: return "bfti_f8ed161325";
            case 2799L: return "bfti_f8fcfa7f69";
            case 2800L: return "bfti_f906837692";
            case 2801L: return "bfti_f90ca5d33f";
            case 2802L: return "bfti_f9520da84b";
            case 2803L: return "bfti_f970022bc4";
            case 2804L: return "bfti_f9837438ff";
            case 2805L: return "bfti_f986b2d5ce";
            case 2806L: return "bfti_f98fef8652";
            case 2807L: return "bfti_f99710fc1d";
            case 2808L: return "bfti_f99e661969";
            case 2809L: return "bfti_f9af11a632";
            case 2810L: return "bfti_f9b0b4e9b6";
            case 2811L: return "bfti_f9c3a519e6";
            case 2812L: return "bfti_f9cc71ca3b";
            case 2813L: return "bfti_f9e54aadd6";
            case 2814L: return "bfti_f9f39af3ae";
            case 2815L: return "bfti_f9f6259885";
            case 2816L: return "bfti_f9f6640629";
            case 2817L: return "bfti_fa286ce8af";
            case 2818L: return "bfti_fa64ad19f0";
            case 2819L: return "bfti_fa6659b90b";
            case 2820L: return "bfti_fa6e4f625e";
            case 2821L: return "bfti_fab6ab5d90";
            case 2822L: return "bfti_fabc3d4a4f";
            case 2823L: return "bfti_fac1365817";
            case 2824L: return "bfti_fad8f8ea4d";
            case 2825L: return "bfti_fafc65e875";
            case 2826L: return "bfti_fb39ee2ab0";
            case 2827L: return "bfti_fb3b241720";
            case 2828L: return "bfti_fb4e42ae06";
            case 2829L: return "bfti_fb54521f24";
            case 2830L: return "bfti_fb5ad52db3";
            case 2831L: return "bfti_fb602dd132";
            case 2832L: return "bfti_fb60ac0bc9";
            case 2833L: return "bfti_fb85c61cbb";
            case 2834L: return "bfti_fbc6154444";
            case 2835L: return "bfti_fbf1af9eea";
            case 2836L: return "bfti_fbf79674c5";
            case 2837L: return "bfti_fc0bd128f4";
            case 2838L: return "bfti_fc17e96675";
            case 2839L: return "bfti_fc24ed5436";
            case 2840L: return "bfti_fc2a05412b";
            case 2841L: return "bfti_fc2c65657f";
            case 2842L: return "bfti_fc3c52a0fb";
            case 2843L: return "bfti_fc4bb5e11c";
            case 2844L: return "bfti_fc75304bbc";
            case 2845L: return "bfti_fc839f5c89";
            case 2846L: return "bfti_fc86f4b82a";
            case 2847L: return "bfti_fcbd8758e7";
            case 2848L: return "bfti_fcc97b2911";
            case 2849L: return "bfti_fd0eba518d";
            case 2850L: return "bfti_fd10cb23ff";
            case 2851L: return "bfti_fd30bc8201";
            case 2852L: return "bfti_fd44bab025";
            case 2853L: return "bfti_fd5562a3ff";
            case 2854L: return "bfti_fd5aaa6f87";
            case 2855L: return "bfti_fdb89a20cb";
            case 2856L: return "bfti_fdc8662281";
            case 2857L: return "bfti_fdd6928843";
            case 2858L: return "bfti_fdd7a5e331";
            case 2859L: return "bfti_fdd7f1e60f";
            case 2860L: return "bfti_fde1636073";
            case 2861L: return "bfti_fdeb8449f8";
            case 2862L: return "bfti_fdec4e1bd1";
            case 2863L: return "bfti_fe18d6e969";
            case 2864L: return "bfti_fe1db9286a";
            case 2865L: return "bfti_fe21681a75";
            case 2866L: return "bfti_fe95eb849c";
            case 2867L: return "bfti_fea59671c2";
            case 2868L: return "bfti_feb8bcf217";
            case 2869L: return "bfti_fec957fd30";
            case 2870L: return "bfti_fece9e70ec";
            case 2871L: return "bfti_fedc099f48";
            case 2872L: return "bfti_fee91dd795";
            case 2873L: return "bfti_feeac38fe4";
            case 2874L: return "bfti_fef2f6fe56";
            case 2875L: return "bfti_ff12d56947";
            case 2876L: return "bfti_ff3d9cb127";
            case 2877L: return "bfti_ff661598c1";
            case 2878L: return "bfti_ff744f940f";
            case 2879L: return "bfti_ff7e5ae566";
            case 2880L: return "bfti_ff8d0d91d9";
            case 2881L: return "bfti_ff9d63b71f";
            case 2882L: return "bfti_ff9d993979";
            case 2883L: return "bfti_ff9dfa626a";
            case 2884L: return "bfti_ffc841e027";
            case 2885L: return "bfti_ffe16e5df8";
            case 2886L: return "bfti_ffe4addc6d";
            case 2887L: return "bfti_last";
            default: return "";
        }
    }

    std::string a_builtin_function_type_index(int64_t i, const std::string &strip) {
        std::string s = a_builtin_function_type_index(i);
        if (s.empty())
            s = "(a_builtin_function_type_index)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_builtin_function_type_index() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L,
            58L,
            59L,
            60L,
            61L,
            62L,
            63L,
            64L,
            65L,
            66L,
            67L,
            68L,
            69L,
            70L,
            71L,
            72L,
            73L,
            74L,
            75L,
            76L,
            77L,
            78L,
            79L,
            80L,
            81L,
            82L,
            83L,
            84L,
            85L,
            86L,
            87L,
            88L,
            89L,
            90L,
            91L,
            92L,
            93L,
            94L,
            95L,
            96L,
            97L,
            98L,
            99L,
            100L,
            101L,
            102L,
            103L,
            104L,
            105L,
            106L,
            107L,
            108L,
            109L,
            110L,
            111L,
            112L,
            113L,
            114L,
            115L,
            116L,
            117L,
            118L,
            119L,
            120L,
            121L,
            122L,
            123L,
            124L,
            125L,
            126L,
            127L,
            128L,
            129L,
            130L,
            131L,
            132L,
            133L,
            134L,
            135L,
            136L,
            137L,
            138L,
            139L,
            140L,
            141L,
            142L,
            143L,
            144L,
            145L,
            146L,
            147L,
            148L,
            149L,
            150L,
            151L,
            152L,
            153L,
            154L,
            155L,
            156L,
            157L,
            158L,
            159L,
            160L,
            161L,
            162L,
            163L,
            164L,
            165L,
            166L,
            167L,
            168L,
            169L,
            170L,
            171L,
            172L,
            173L,
            174L,
            175L,
            176L,
            177L,
            178L,
            179L,
            180L,
            181L,
            182L,
            183L,
            184L,
            185L,
            186L,
            187L,
            188L,
            189L,
            190L,
            191L,
            192L,
            193L,
            194L,
            195L,
            196L,
            197L,
            198L,
            199L,
            200L,
            201L,
            202L,
            203L,
            204L,
            205L,
            206L,
            207L,
            208L,
            209L,
            210L,
            211L,
            212L,
            213L,
            214L,
            215L,
            216L,
            217L,
            218L,
            219L,
            220L,
            221L,
            222L,
            223L,
            224L,
            225L,
            226L,
            227L,
            228L,
            229L,
            230L,
            231L,
            232L,
            233L,
            234L,
            235L,
            236L,
            237L,
            238L,
            239L,
            240L,
            241L,
            242L,
            243L,
            244L,
            245L,
            246L,
            247L,
            248L,
            249L,
            250L,
            251L,
            252L,
            253L,
            254L,
            255L,
            256L,
            257L,
            258L,
            259L,
            260L,
            261L,
            262L,
            263L,
            264L,
            265L,
            266L,
            267L,
            268L,
            269L,
            270L,
            271L,
            272L,
            273L,
            274L,
            275L,
            276L,
            277L,
            278L,
            279L,
            280L,
            281L,
            282L,
            283L,
            284L,
            285L,
            286L,
            287L,
            288L,
            289L,
            290L,
            291L,
            292L,
            293L,
            294L,
            295L,
            296L,
            297L,
            298L,
            299L,
            300L,
            301L,
            302L,
            303L,
            304L,
            305L,
            306L,
            307L,
            308L,
            309L,
            310L,
            311L,
            312L,
            313L,
            314L,
            315L,
            316L,
            317L,
            318L,
            319L,
            320L,
            321L,
            322L,
            323L,
            324L,
            325L,
            326L,
            327L,
            328L,
            329L,
            330L,
            331L,
            332L,
            333L,
            334L,
            335L,
            336L,
            337L,
            338L,
            339L,
            340L,
            341L,
            342L,
            343L,
            344L,
            345L,
            346L,
            347L,
            348L,
            349L,
            350L,
            351L,
            352L,
            353L,
            354L,
            355L,
            356L,
            357L,
            358L,
            359L,
            360L,
            361L,
            362L,
            363L,
            364L,
            365L,
            366L,
            367L,
            368L,
            369L,
            370L,
            371L,
            372L,
            373L,
            374L,
            375L,
            376L,
            377L,
            378L,
            379L,
            380L,
            381L,
            382L,
            383L,
            384L,
            385L,
            386L,
            387L,
            388L,
            389L,
            390L,
            391L,
            392L,
            393L,
            394L,
            395L,
            396L,
            397L,
            398L,
            399L,
            400L,
            401L,
            402L,
            403L,
            404L,
            405L,
            406L,
            407L,
            408L,
            409L,
            410L,
            411L,
            412L,
            413L,
            414L,
            415L,
            416L,
            417L,
            418L,
            419L,
            420L,
            421L,
            422L,
            423L,
            424L,
            425L,
            426L,
            427L,
            428L,
            429L,
            430L,
            431L,
            432L,
            433L,
            434L,
            435L,
            436L,
            437L,
            438L,
            439L,
            440L,
            441L,
            442L,
            443L,
            444L,
            445L,
            446L,
            447L,
            448L,
            449L,
            450L,
            451L,
            452L,
            453L,
            454L,
            455L,
            456L,
            457L,
            458L,
            459L,
            460L,
            461L,
            462L,
            463L,
            464L,
            465L,
            466L,
            467L,
            468L,
            469L,
            470L,
            471L,
            472L,
            473L,
            474L,
            475L,
            476L,
            477L,
            478L,
            479L,
            480L,
            481L,
            482L,
            483L,
            484L,
            485L,
            486L,
            487L,
            488L,
            489L,
            490L,
            491L,
            492L,
            493L,
            494L,
            495L,
            496L,
            497L,
            498L,
            499L,
            500L,
            501L,
            502L,
            503L,
            504L,
            505L,
            506L,
            507L,
            508L,
            509L,
            510L,
            511L,
            512L,
            513L,
            514L,
            515L,
            516L,
            517L,
            518L,
            519L,
            520L,
            521L,
            522L,
            523L,
            524L,
            525L,
            526L,
            527L,
            528L,
            529L,
            530L,
            531L,
            532L,
            533L,
            534L,
            535L,
            536L,
            537L,
            538L,
            539L,
            540L,
            541L,
            542L,
            543L,
            544L,
            545L,
            546L,
            547L,
            548L,
            549L,
            550L,
            551L,
            552L,
            553L,
            554L,
            555L,
            556L,
            557L,
            558L,
            559L,
            560L,
            561L,
            562L,
            563L,
            564L,
            565L,
            566L,
            567L,
            568L,
            569L,
            570L,
            571L,
            572L,
            573L,
            574L,
            575L,
            576L,
            577L,
            578L,
            579L,
            580L,
            581L,
            582L,
            583L,
            584L,
            585L,
            586L,
            587L,
            588L,
            589L,
            590L,
            591L,
            592L,
            593L,
            594L,
            595L,
            596L,
            597L,
            598L,
            599L,
            600L,
            601L,
            602L,
            603L,
            604L,
            605L,
            606L,
            607L,
            608L,
            609L,
            610L,
            611L,
            612L,
            613L,
            614L,
            615L,
            616L,
            617L,
            618L,
            619L,
            620L,
            621L,
            622L,
            623L,
            624L,
            625L,
            626L,
            627L,
            628L,
            629L,
            630L,
            631L,
            632L,
            633L,
            634L,
            635L,
            636L,
            637L,
            638L,
            639L,
            640L,
            641L,
            642L,
            643L,
            644L,
            645L,
            646L,
            647L,
            648L,
            649L,
            650L,
            651L,
            652L,
            653L,
            654L,
            655L,
            656L,
            657L,
            658L,
            659L,
            660L,
            661L,
            662L,
            663L,
            664L,
            665L,
            666L,
            667L,
            668L,
            669L,
            670L,
            671L,
            672L,
            673L,
            674L,
            675L,
            676L,
            677L,
            678L,
            679L,
            680L,
            681L,
            682L,
            683L,
            684L,
            685L,
            686L,
            687L,
            688L,
            689L,
            690L,
            691L,
            692L,
            693L,
            694L,
            695L,
            696L,
            697L,
            698L,
            699L,
            700L,
            701L,
            702L,
            703L,
            704L,
            705L,
            706L,
            707L,
            708L,
            709L,
            710L,
            711L,
            712L,
            713L,
            714L,
            715L,
            716L,
            717L,
            718L,
            719L,
            720L,
            721L,
            722L,
            723L,
            724L,
            725L,
            726L,
            727L,
            728L,
            729L,
            730L,
            731L,
            732L,
            733L,
            734L,
            735L,
            736L,
            737L,
            738L,
            739L,
            740L,
            741L,
            742L,
            743L,
            744L,
            745L,
            746L,
            747L,
            748L,
            749L,
            750L,
            751L,
            752L,
            753L,
            754L,
            755L,
            756L,
            757L,
            758L,
            759L,
            760L,
            761L,
            762L,
            763L,
            764L,
            765L,
            766L,
            767L,
            768L,
            769L,
            770L,
            771L,
            772L,
            773L,
            774L,
            775L,
            776L,
            777L,
            778L,
            779L,
            780L,
            781L,
            782L,
            783L,
            784L,
            785L,
            786L,
            787L,
            788L,
            789L,
            790L,
            791L,
            792L,
            793L,
            794L,
            795L,
            796L,
            797L,
            798L,
            799L,
            800L,
            801L,
            802L,
            803L,
            804L,
            805L,
            806L,
            807L,
            808L,
            809L,
            810L,
            811L,
            812L,
            813L,
            814L,
            815L,
            816L,
            817L,
            818L,
            819L,
            820L,
            821L,
            822L,
            823L,
            824L,
            825L,
            826L,
            827L,
            828L,
            829L,
            830L,
            831L,
            832L,
            833L,
            834L,
            835L,
            836L,
            837L,
            838L,
            839L,
            840L,
            841L,
            842L,
            843L,
            844L,
            845L,
            846L,
            847L,
            848L,
            849L,
            850L,
            851L,
            852L,
            853L,
            854L,
            855L,
            856L,
            857L,
            858L,
            859L,
            860L,
            861L,
            862L,
            863L,
            864L,
            865L,
            866L,
            867L,
            868L,
            869L,
            870L,
            871L,
            872L,
            873L,
            874L,
            875L,
            876L,
            877L,
            878L,
            879L,
            880L,
            881L,
            882L,
            883L,
            884L,
            885L,
            886L,
            887L,
            888L,
            889L,
            890L,
            891L,
            892L,
            893L,
            894L,
            895L,
            896L,
            897L,
            898L,
            899L,
            900L,
            901L,
            902L,
            903L,
            904L,
            905L,
            906L,
            907L,
            908L,
            909L,
            910L,
            911L,
            912L,
            913L,
            914L,
            915L,
            916L,
            917L,
            918L,
            919L,
            920L,
            921L,
            922L,
            923L,
            924L,
            925L,
            926L,
            927L,
            928L,
            929L,
            930L,
            931L,
            932L,
            933L,
            934L,
            935L,
            936L,
            937L,
            938L,
            939L,
            940L,
            941L,
            942L,
            943L,
            944L,
            945L,
            946L,
            947L,
            948L,
            949L,
            950L,
            951L,
            952L,
            953L,
            954L,
            955L,
            956L,
            957L,
            958L,
            959L,
            960L,
            961L,
            962L,
            963L,
            964L,
            965L,
            966L,
            967L,
            968L,
            969L,
            970L,
            971L,
            972L,
            973L,
            974L,
            975L,
            976L,
            977L,
            978L,
            979L,
            980L,
            981L,
            982L,
            983L,
            984L,
            985L,
            986L,
            987L,
            988L,
            989L,
            990L,
            991L,
            992L,
            993L,
            994L,
            995L,
            996L,
            997L,
            998L,
            999L,
            1000L,
            1001L,
            1002L,
            1003L,
            1004L,
            1005L,
            1006L,
            1007L,
            1008L,
            1009L,
            1010L,
            1011L,
            1012L,
            1013L,
            1014L,
            1015L,
            1016L,
            1017L,
            1018L,
            1019L,
            1020L,
            1021L,
            1022L,
            1023L,
            1024L,
            1025L,
            1026L,
            1027L,
            1028L,
            1029L,
            1030L,
            1031L,
            1032L,
            1033L,
            1034L,
            1035L,
            1036L,
            1037L,
            1038L,
            1039L,
            1040L,
            1041L,
            1042L,
            1043L,
            1044L,
            1045L,
            1046L,
            1047L,
            1048L,
            1049L,
            1050L,
            1051L,
            1052L,
            1053L,
            1054L,
            1055L,
            1056L,
            1057L,
            1058L,
            1059L,
            1060L,
            1061L,
            1062L,
            1063L,
            1064L,
            1065L,
            1066L,
            1067L,
            1068L,
            1069L,
            1070L,
            1071L,
            1072L,
            1073L,
            1074L,
            1075L,
            1076L,
            1077L,
            1078L,
            1079L,
            1080L,
            1081L,
            1082L,
            1083L,
            1084L,
            1085L,
            1086L,
            1087L,
            1088L,
            1089L,
            1090L,
            1091L,
            1092L,
            1093L,
            1094L,
            1095L,
            1096L,
            1097L,
            1098L,
            1099L,
            1100L,
            1101L,
            1102L,
            1103L,
            1104L,
            1105L,
            1106L,
            1107L,
            1108L,
            1109L,
            1110L,
            1111L,
            1112L,
            1113L,
            1114L,
            1115L,
            1116L,
            1117L,
            1118L,
            1119L,
            1120L,
            1121L,
            1122L,
            1123L,
            1124L,
            1125L,
            1126L,
            1127L,
            1128L,
            1129L,
            1130L,
            1131L,
            1132L,
            1133L,
            1134L,
            1135L,
            1136L,
            1137L,
            1138L,
            1139L,
            1140L,
            1141L,
            1142L,
            1143L,
            1144L,
            1145L,
            1146L,
            1147L,
            1148L,
            1149L,
            1150L,
            1151L,
            1152L,
            1153L,
            1154L,
            1155L,
            1156L,
            1157L,
            1158L,
            1159L,
            1160L,
            1161L,
            1162L,
            1163L,
            1164L,
            1165L,
            1166L,
            1167L,
            1168L,
            1169L,
            1170L,
            1171L,
            1172L,
            1173L,
            1174L,
            1175L,
            1176L,
            1177L,
            1178L,
            1179L,
            1180L,
            1181L,
            1182L,
            1183L,
            1184L,
            1185L,
            1186L,
            1187L,
            1188L,
            1189L,
            1190L,
            1191L,
            1192L,
            1193L,
            1194L,
            1195L,
            1196L,
            1197L,
            1198L,
            1199L,
            1200L,
            1201L,
            1202L,
            1203L,
            1204L,
            1205L,
            1206L,
            1207L,
            1208L,
            1209L,
            1210L,
            1211L,
            1212L,
            1213L,
            1214L,
            1215L,
            1216L,
            1217L,
            1218L,
            1219L,
            1220L,
            1221L,
            1222L,
            1223L,
            1224L,
            1225L,
            1226L,
            1227L,
            1228L,
            1229L,
            1230L,
            1231L,
            1232L,
            1233L,
            1234L,
            1235L,
            1236L,
            1237L,
            1238L,
            1239L,
            1240L,
            1241L,
            1242L,
            1243L,
            1244L,
            1245L,
            1246L,
            1247L,
            1248L,
            1249L,
            1250L,
            1251L,
            1252L,
            1253L,
            1254L,
            1255L,
            1256L,
            1257L,
            1258L,
            1259L,
            1260L,
            1261L,
            1262L,
            1263L,
            1264L,
            1265L,
            1266L,
            1267L,
            1268L,
            1269L,
            1270L,
            1271L,
            1272L,
            1273L,
            1274L,
            1275L,
            1276L,
            1277L,
            1278L,
            1279L,
            1280L,
            1281L,
            1282L,
            1283L,
            1284L,
            1285L,
            1286L,
            1287L,
            1288L,
            1289L,
            1290L,
            1291L,
            1292L,
            1293L,
            1294L,
            1295L,
            1296L,
            1297L,
            1298L,
            1299L,
            1300L,
            1301L,
            1302L,
            1303L,
            1304L,
            1305L,
            1306L,
            1307L,
            1308L,
            1309L,
            1310L,
            1311L,
            1312L,
            1313L,
            1314L,
            1315L,
            1316L,
            1317L,
            1318L,
            1319L,
            1320L,
            1321L,
            1322L,
            1323L,
            1324L,
            1325L,
            1326L,
            1327L,
            1328L,
            1329L,
            1330L,
            1331L,
            1332L,
            1333L,
            1334L,
            1335L,
            1336L,
            1337L,
            1338L,
            1339L,
            1340L,
            1341L,
            1342L,
            1343L,
            1344L,
            1345L,
            1346L,
            1347L,
            1348L,
            1349L,
            1350L,
            1351L,
            1352L,
            1353L,
            1354L,
            1355L,
            1356L,
            1357L,
            1358L,
            1359L,
            1360L,
            1361L,
            1362L,
            1363L,
            1364L,
            1365L,
            1366L,
            1367L,
            1368L,
            1369L,
            1370L,
            1371L,
            1372L,
            1373L,
            1374L,
            1375L,
            1376L,
            1377L,
            1378L,
            1379L,
            1380L,
            1381L,
            1382L,
            1383L,
            1384L,
            1385L,
            1386L,
            1387L,
            1388L,
            1389L,
            1390L,
            1391L,
            1392L,
            1393L,
            1394L,
            1395L,
            1396L,
            1397L,
            1398L,
            1399L,
            1400L,
            1401L,
            1402L,
            1403L,
            1404L,
            1405L,
            1406L,
            1407L,
            1408L,
            1409L,
            1410L,
            1411L,
            1412L,
            1413L,
            1414L,
            1415L,
            1416L,
            1417L,
            1418L,
            1419L,
            1420L,
            1421L,
            1422L,
            1423L,
            1424L,
            1425L,
            1426L,
            1427L,
            1428L,
            1429L,
            1430L,
            1431L,
            1432L,
            1433L,
            1434L,
            1435L,
            1436L,
            1437L,
            1438L,
            1439L,
            1440L,
            1441L,
            1442L,
            1443L,
            1444L,
            1445L,
            1446L,
            1447L,
            1448L,
            1449L,
            1450L,
            1451L,
            1452L,
            1453L,
            1454L,
            1455L,
            1456L,
            1457L,
            1458L,
            1459L,
            1460L,
            1461L,
            1462L,
            1463L,
            1464L,
            1465L,
            1466L,
            1467L,
            1468L,
            1469L,
            1470L,
            1471L,
            1472L,
            1473L,
            1474L,
            1475L,
            1476L,
            1477L,
            1478L,
            1479L,
            1480L,
            1481L,
            1482L,
            1483L,
            1484L,
            1485L,
            1486L,
            1487L,
            1488L,
            1489L,
            1490L,
            1491L,
            1492L,
            1493L,
            1494L,
            1495L,
            1496L,
            1497L,
            1498L,
            1499L,
            1500L,
            1501L,
            1502L,
            1503L,
            1504L,
            1505L,
            1506L,
            1507L,
            1508L,
            1509L,
            1510L,
            1511L,
            1512L,
            1513L,
            1514L,
            1515L,
            1516L,
            1517L,
            1518L,
            1519L,
            1520L,
            1521L,
            1522L,
            1523L,
            1524L,
            1525L,
            1526L,
            1527L,
            1528L,
            1529L,
            1530L,
            1531L,
            1532L,
            1533L,
            1534L,
            1535L,
            1536L,
            1537L,
            1538L,
            1539L,
            1540L,
            1541L,
            1542L,
            1543L,
            1544L,
            1545L,
            1546L,
            1547L,
            1548L,
            1549L,
            1550L,
            1551L,
            1552L,
            1553L,
            1554L,
            1555L,
            1556L,
            1557L,
            1558L,
            1559L,
            1560L,
            1561L,
            1562L,
            1563L,
            1564L,
            1565L,
            1566L,
            1567L,
            1568L,
            1569L,
            1570L,
            1571L,
            1572L,
            1573L,
            1574L,
            1575L,
            1576L,
            1577L,
            1578L,
            1579L,
            1580L,
            1581L,
            1582L,
            1583L,
            1584L,
            1585L,
            1586L,
            1587L,
            1588L,
            1589L,
            1590L,
            1591L,
            1592L,
            1593L,
            1594L,
            1595L,
            1596L,
            1597L,
            1598L,
            1599L,
            1600L,
            1601L,
            1602L,
            1603L,
            1604L,
            1605L,
            1606L,
            1607L,
            1608L,
            1609L,
            1610L,
            1611L,
            1612L,
            1613L,
            1614L,
            1615L,
            1616L,
            1617L,
            1618L,
            1619L,
            1620L,
            1621L,
            1622L,
            1623L,
            1624L,
            1625L,
            1626L,
            1627L,
            1628L,
            1629L,
            1630L,
            1631L,
            1632L,
            1633L,
            1634L,
            1635L,
            1636L,
            1637L,
            1638L,
            1639L,
            1640L,
            1641L,
            1642L,
            1643L,
            1644L,
            1645L,
            1646L,
            1647L,
            1648L,
            1649L,
            1650L,
            1651L,
            1652L,
            1653L,
            1654L,
            1655L,
            1656L,
            1657L,
            1658L,
            1659L,
            1660L,
            1661L,
            1662L,
            1663L,
            1664L,
            1665L,
            1666L,
            1667L,
            1668L,
            1669L,
            1670L,
            1671L,
            1672L,
            1673L,
            1674L,
            1675L,
            1676L,
            1677L,
            1678L,
            1679L,
            1680L,
            1681L,
            1682L,
            1683L,
            1684L,
            1685L,
            1686L,
            1687L,
            1688L,
            1689L,
            1690L,
            1691L,
            1692L,
            1693L,
            1694L,
            1695L,
            1696L,
            1697L,
            1698L,
            1699L,
            1700L,
            1701L,
            1702L,
            1703L,
            1704L,
            1705L,
            1706L,
            1707L,
            1708L,
            1709L,
            1710L,
            1711L,
            1712L,
            1713L,
            1714L,
            1715L,
            1716L,
            1717L,
            1718L,
            1719L,
            1720L,
            1721L,
            1722L,
            1723L,
            1724L,
            1725L,
            1726L,
            1727L,
            1728L,
            1729L,
            1730L,
            1731L,
            1732L,
            1733L,
            1734L,
            1735L,
            1736L,
            1737L,
            1738L,
            1739L,
            1740L,
            1741L,
            1742L,
            1743L,
            1744L,
            1745L,
            1746L,
            1747L,
            1748L,
            1749L,
            1750L,
            1751L,
            1752L,
            1753L,
            1754L,
            1755L,
            1756L,
            1757L,
            1758L,
            1759L,
            1760L,
            1761L,
            1762L,
            1763L,
            1764L,
            1765L,
            1766L,
            1767L,
            1768L,
            1769L,
            1770L,
            1771L,
            1772L,
            1773L,
            1774L,
            1775L,
            1776L,
            1777L,
            1778L,
            1779L,
            1780L,
            1781L,
            1782L,
            1783L,
            1784L,
            1785L,
            1786L,
            1787L,
            1788L,
            1789L,
            1790L,
            1791L,
            1792L,
            1793L,
            1794L,
            1795L,
            1796L,
            1797L,
            1798L,
            1799L,
            1800L,
            1801L,
            1802L,
            1803L,
            1804L,
            1805L,
            1806L,
            1807L,
            1808L,
            1809L,
            1810L,
            1811L,
            1812L,
            1813L,
            1814L,
            1815L,
            1816L,
            1817L,
            1818L,
            1819L,
            1820L,
            1821L,
            1822L,
            1823L,
            1824L,
            1825L,
            1826L,
            1827L,
            1828L,
            1829L,
            1830L,
            1831L,
            1832L,
            1833L,
            1834L,
            1835L,
            1836L,
            1837L,
            1838L,
            1839L,
            1840L,
            1841L,
            1842L,
            1843L,
            1844L,
            1845L,
            1846L,
            1847L,
            1848L,
            1849L,
            1850L,
            1851L,
            1852L,
            1853L,
            1854L,
            1855L,
            1856L,
            1857L,
            1858L,
            1859L,
            1860L,
            1861L,
            1862L,
            1863L,
            1864L,
            1865L,
            1866L,
            1867L,
            1868L,
            1869L,
            1870L,
            1871L,
            1872L,
            1873L,
            1874L,
            1875L,
            1876L,
            1877L,
            1878L,
            1879L,
            1880L,
            1881L,
            1882L,
            1883L,
            1884L,
            1885L,
            1886L,
            1887L,
            1888L,
            1889L,
            1890L,
            1891L,
            1892L,
            1893L,
            1894L,
            1895L,
            1896L,
            1897L,
            1898L,
            1899L,
            1900L,
            1901L,
            1902L,
            1903L,
            1904L,
            1905L,
            1906L,
            1907L,
            1908L,
            1909L,
            1910L,
            1911L,
            1912L,
            1913L,
            1914L,
            1915L,
            1916L,
            1917L,
            1918L,
            1919L,
            1920L,
            1921L,
            1922L,
            1923L,
            1924L,
            1925L,
            1926L,
            1927L,
            1928L,
            1929L,
            1930L,
            1931L,
            1932L,
            1933L,
            1934L,
            1935L,
            1936L,
            1937L,
            1938L,
            1939L,
            1940L,
            1941L,
            1942L,
            1943L,
            1944L,
            1945L,
            1946L,
            1947L,
            1948L,
            1949L,
            1950L,
            1951L,
            1952L,
            1953L,
            1954L,
            1955L,
            1956L,
            1957L,
            1958L,
            1959L,
            1960L,
            1961L,
            1962L,
            1963L,
            1964L,
            1965L,
            1966L,
            1967L,
            1968L,
            1969L,
            1970L,
            1971L,
            1972L,
            1973L,
            1974L,
            1975L,
            1976L,
            1977L,
            1978L,
            1979L,
            1980L,
            1981L,
            1982L,
            1983L,
            1984L,
            1985L,
            1986L,
            1987L,
            1988L,
            1989L,
            1990L,
            1991L,
            1992L,
            1993L,
            1994L,
            1995L,
            1996L,
            1997L,
            1998L,
            1999L,
            2000L,
            2001L,
            2002L,
            2003L,
            2004L,
            2005L,
            2006L,
            2007L,
            2008L,
            2009L,
            2010L,
            2011L,
            2012L,
            2013L,
            2014L,
            2015L,
            2016L,
            2017L,
            2018L,
            2019L,
            2020L,
            2021L,
            2022L,
            2023L,
            2024L,
            2025L,
            2026L,
            2027L,
            2028L,
            2029L,
            2030L,
            2031L,
            2032L,
            2033L,
            2034L,
            2035L,
            2036L,
            2037L,
            2038L,
            2039L,
            2040L,
            2041L,
            2042L,
            2043L,
            2044L,
            2045L,
            2046L,
            2047L,
            2048L,
            2049L,
            2050L,
            2051L,
            2052L,
            2053L,
            2054L,
            2055L,
            2056L,
            2057L,
            2058L,
            2059L,
            2060L,
            2061L,
            2062L,
            2063L,
            2064L,
            2065L,
            2066L,
            2067L,
            2068L,
            2069L,
            2070L,
            2071L,
            2072L,
            2073L,
            2074L,
            2075L,
            2076L,
            2077L,
            2078L,
            2079L,
            2080L,
            2081L,
            2082L,
            2083L,
            2084L,
            2085L,
            2086L,
            2087L,
            2088L,
            2089L,
            2090L,
            2091L,
            2092L,
            2093L,
            2094L,
            2095L,
            2096L,
            2097L,
            2098L,
            2099L,
            2100L,
            2101L,
            2102L,
            2103L,
            2104L,
            2105L,
            2106L,
            2107L,
            2108L,
            2109L,
            2110L,
            2111L,
            2112L,
            2113L,
            2114L,
            2115L,
            2116L,
            2117L,
            2118L,
            2119L,
            2120L,
            2121L,
            2122L,
            2123L,
            2124L,
            2125L,
            2126L,
            2127L,
            2128L,
            2129L,
            2130L,
            2131L,
            2132L,
            2133L,
            2134L,
            2135L,
            2136L,
            2137L,
            2138L,
            2139L,
            2140L,
            2141L,
            2142L,
            2143L,
            2144L,
            2145L,
            2146L,
            2147L,
            2148L,
            2149L,
            2150L,
            2151L,
            2152L,
            2153L,
            2154L,
            2155L,
            2156L,
            2157L,
            2158L,
            2159L,
            2160L,
            2161L,
            2162L,
            2163L,
            2164L,
            2165L,
            2166L,
            2167L,
            2168L,
            2169L,
            2170L,
            2171L,
            2172L,
            2173L,
            2174L,
            2175L,
            2176L,
            2177L,
            2178L,
            2179L,
            2180L,
            2181L,
            2182L,
            2183L,
            2184L,
            2185L,
            2186L,
            2187L,
            2188L,
            2189L,
            2190L,
            2191L,
            2192L,
            2193L,
            2194L,
            2195L,
            2196L,
            2197L,
            2198L,
            2199L,
            2200L,
            2201L,
            2202L,
            2203L,
            2204L,
            2205L,
            2206L,
            2207L,
            2208L,
            2209L,
            2210L,
            2211L,
            2212L,
            2213L,
            2214L,
            2215L,
            2216L,
            2217L,
            2218L,
            2219L,
            2220L,
            2221L,
            2222L,
            2223L,
            2224L,
            2225L,
            2226L,
            2227L,
            2228L,
            2229L,
            2230L,
            2231L,
            2232L,
            2233L,
            2234L,
            2235L,
            2236L,
            2237L,
            2238L,
            2239L,
            2240L,
            2241L,
            2242L,
            2243L,
            2244L,
            2245L,
            2246L,
            2247L,
            2248L,
            2249L,
            2250L,
            2251L,
            2252L,
            2253L,
            2254L,
            2255L,
            2256L,
            2257L,
            2258L,
            2259L,
            2260L,
            2261L,
            2262L,
            2263L,
            2264L,
            2265L,
            2266L,
            2267L,
            2268L,
            2269L,
            2270L,
            2271L,
            2272L,
            2273L,
            2274L,
            2275L,
            2276L,
            2277L,
            2278L,
            2279L,
            2280L,
            2281L,
            2282L,
            2283L,
            2284L,
            2285L,
            2286L,
            2287L,
            2288L,
            2289L,
            2290L,
            2291L,
            2292L,
            2293L,
            2294L,
            2295L,
            2296L,
            2297L,
            2298L,
            2299L,
            2300L,
            2301L,
            2302L,
            2303L,
            2304L,
            2305L,
            2306L,
            2307L,
            2308L,
            2309L,
            2310L,
            2311L,
            2312L,
            2313L,
            2314L,
            2315L,
            2316L,
            2317L,
            2318L,
            2319L,
            2320L,
            2321L,
            2322L,
            2323L,
            2324L,
            2325L,
            2326L,
            2327L,
            2328L,
            2329L,
            2330L,
            2331L,
            2332L,
            2333L,
            2334L,
            2335L,
            2336L,
            2337L,
            2338L,
            2339L,
            2340L,
            2341L,
            2342L,
            2343L,
            2344L,
            2345L,
            2346L,
            2347L,
            2348L,
            2349L,
            2350L,
            2351L,
            2352L,
            2353L,
            2354L,
            2355L,
            2356L,
            2357L,
            2358L,
            2359L,
            2360L,
            2361L,
            2362L,
            2363L,
            2364L,
            2365L,
            2366L,
            2367L,
            2368L,
            2369L,
            2370L,
            2371L,
            2372L,
            2373L,
            2374L,
            2375L,
            2376L,
            2377L,
            2378L,
            2379L,
            2380L,
            2381L,
            2382L,
            2383L,
            2384L,
            2385L,
            2386L,
            2387L,
            2388L,
            2389L,
            2390L,
            2391L,
            2392L,
            2393L,
            2394L,
            2395L,
            2396L,
            2397L,
            2398L,
            2399L,
            2400L,
            2401L,
            2402L,
            2403L,
            2404L,
            2405L,
            2406L,
            2407L,
            2408L,
            2409L,
            2410L,
            2411L,
            2412L,
            2413L,
            2414L,
            2415L,
            2416L,
            2417L,
            2418L,
            2419L,
            2420L,
            2421L,
            2422L,
            2423L,
            2424L,
            2425L,
            2426L,
            2427L,
            2428L,
            2429L,
            2430L,
            2431L,
            2432L,
            2433L,
            2434L,
            2435L,
            2436L,
            2437L,
            2438L,
            2439L,
            2440L,
            2441L,
            2442L,
            2443L,
            2444L,
            2445L,
            2446L,
            2447L,
            2448L,
            2449L,
            2450L,
            2451L,
            2452L,
            2453L,
            2454L,
            2455L,
            2456L,
            2457L,
            2458L,
            2459L,
            2460L,
            2461L,
            2462L,
            2463L,
            2464L,
            2465L,
            2466L,
            2467L,
            2468L,
            2469L,
            2470L,
            2471L,
            2472L,
            2473L,
            2474L,
            2475L,
            2476L,
            2477L,
            2478L,
            2479L,
            2480L,
            2481L,
            2482L,
            2483L,
            2484L,
            2485L,
            2486L,
            2487L,
            2488L,
            2489L,
            2490L,
            2491L,
            2492L,
            2493L,
            2494L,
            2495L,
            2496L,
            2497L,
            2498L,
            2499L,
            2500L,
            2501L,
            2502L,
            2503L,
            2504L,
            2505L,
            2506L,
            2507L,
            2508L,
            2509L,
            2510L,
            2511L,
            2512L,
            2513L,
            2514L,
            2515L,
            2516L,
            2517L,
            2518L,
            2519L,
            2520L,
            2521L,
            2522L,
            2523L,
            2524L,
            2525L,
            2526L,
            2527L,
            2528L,
            2529L,
            2530L,
            2531L,
            2532L,
            2533L,
            2534L,
            2535L,
            2536L,
            2537L,
            2538L,
            2539L,
            2540L,
            2541L,
            2542L,
            2543L,
            2544L,
            2545L,
            2546L,
            2547L,
            2548L,
            2549L,
            2550L,
            2551L,
            2552L,
            2553L,
            2554L,
            2555L,
            2556L,
            2557L,
            2558L,
            2559L,
            2560L,
            2561L,
            2562L,
            2563L,
            2564L,
            2565L,
            2566L,
            2567L,
            2568L,
            2569L,
            2570L,
            2571L,
            2572L,
            2573L,
            2574L,
            2575L,
            2576L,
            2577L,
            2578L,
            2579L,
            2580L,
            2581L,
            2582L,
            2583L,
            2584L,
            2585L,
            2586L,
            2587L,
            2588L,
            2589L,
            2590L,
            2591L,
            2592L,
            2593L,
            2594L,
            2595L,
            2596L,
            2597L,
            2598L,
            2599L,
            2600L,
            2601L,
            2602L,
            2603L,
            2604L,
            2605L,
            2606L,
            2607L,
            2608L,
            2609L,
            2610L,
            2611L,
            2612L,
            2613L,
            2614L,
            2615L,
            2616L,
            2617L,
            2618L,
            2619L,
            2620L,
            2621L,
            2622L,
            2623L,
            2624L,
            2625L,
            2626L,
            2627L,
            2628L,
            2629L,
            2630L,
            2631L,
            2632L,
            2633L,
            2634L,
            2635L,
            2636L,
            2637L,
            2638L,
            2639L,
            2640L,
            2641L,
            2642L,
            2643L,
            2644L,
            2645L,
            2646L,
            2647L,
            2648L,
            2649L,
            2650L,
            2651L,
            2652L,
            2653L,
            2654L,
            2655L,
            2656L,
            2657L,
            2658L,
            2659L,
            2660L,
            2661L,
            2662L,
            2663L,
            2664L,
            2665L,
            2666L,
            2667L,
            2668L,
            2669L,
            2670L,
            2671L,
            2672L,
            2673L,
            2674L,
            2675L,
            2676L,
            2677L,
            2678L,
            2679L,
            2680L,
            2681L,
            2682L,
            2683L,
            2684L,
            2685L,
            2686L,
            2687L,
            2688L,
            2689L,
            2690L,
            2691L,
            2692L,
            2693L,
            2694L,
            2695L,
            2696L,
            2697L,
            2698L,
            2699L,
            2700L,
            2701L,
            2702L,
            2703L,
            2704L,
            2705L,
            2706L,
            2707L,
            2708L,
            2709L,
            2710L,
            2711L,
            2712L,
            2713L,
            2714L,
            2715L,
            2716L,
            2717L,
            2718L,
            2719L,
            2720L,
            2721L,
            2722L,
            2723L,
            2724L,
            2725L,
            2726L,
            2727L,
            2728L,
            2729L,
            2730L,
            2731L,
            2732L,
            2733L,
            2734L,
            2735L,
            2736L,
            2737L,
            2738L,
            2739L,
            2740L,
            2741L,
            2742L,
            2743L,
            2744L,
            2745L,
            2746L,
            2747L,
            2748L,
            2749L,
            2750L,
            2751L,
            2752L,
            2753L,
            2754L,
            2755L,
            2756L,
            2757L,
            2758L,
            2759L,
            2760L,
            2761L,
            2762L,
            2763L,
            2764L,
            2765L,
            2766L,
            2767L,
            2768L,
            2769L,
            2770L,
            2771L,
            2772L,
            2773L,
            2774L,
            2775L,
            2776L,
            2777L,
            2778L,
            2779L,
            2780L,
            2781L,
            2782L,
            2783L,
            2784L,
            2785L,
            2786L,
            2787L,
            2788L,
            2789L,
            2790L,
            2791L,
            2792L,
            2793L,
            2794L,
            2795L,
            2796L,
            2797L,
            2798L,
            2799L,
            2800L,
            2801L,
            2802L,
            2803L,
            2804L,
            2805L,
            2806L,
            2807L,
            2808L,
            2809L,
            2810L,
            2811L,
            2812L,
            2813L,
            2814L,
            2815L,
            2816L,
            2817L,
            2818L,
            2819L,
            2820L,
            2821L,
            2822L,
            2823L,
            2824L,
            2825L,
            2826L,
            2827L,
            2828L,
            2829L,
            2830L,
            2831L,
            2832L,
            2833L,
            2834L,
            2835L,
            2836L,
            2837L,
            2838L,
            2839L,
            2840L,
            2841L,
            2842L,
            2843L,
            2844L,
            2845L,
            2846L,
            2847L,
            2848L,
            2849L,
            2850L,
            2851L,
            2852L,
            2853L,
            2854L,
            2855L,
            2856L,
            2857L,
            2858L,
            2859L,
            2860L,
            2861L,
            2862L,
            2863L,
            2864L,
            2865L,
            2866L,
            2867L,
            2868L,
            2869L,
            2870L,
            2871L,
            2872L,
            2873L,
            2874L,
            2875L,
            2876L,
            2877L,
            2878L,
            2879L,
            2880L,
            2881L,
            2882L,
            2883L,
            2884L,
            2885L,
            2886L,
            2887L
        };
        static const std::vector<int64_t> retval(values, values + 2888);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_builtin_function_type_index(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_builtin_function_type_index(i);
        if (retval.empty()) {
            retval = "(a_builtin_function_type_index)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_builtin_function_type_index::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_builtin_function_type_index() {
        return stringify::a_builtin_function_type_index();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/builtin_defs.h line 5812
namespace stringify {
    const char* a_builtin_function_condition_index(int64_t i) {
        switch (i) {
            case 0L: return "bfci_00f7898ac1";
            case 1L: return "bfci_023c888429";
            case 2L: return "bfci_02af039f89";
            case 3L: return "bfci_03cc0a7dc4";
            case 4L: return "bfci_05f1854379";
            case 5L: return "bfci_06cc7a5344";
            case 6L: return "bfci_06f5a8045f";
            case 7L: return "bfci_07754772cf";
            case 8L: return "bfci_07fddcd316";
            case 9L: return "bfci_08b3aa4129";
            case 10L: return "bfci_0904b91f4a";
            case 11L: return "bfci_0a94310b00";
            case 12L: return "bfci_0ad6a55c34";
            case 13L: return "bfci_0aefd6143b";
            case 14L: return "bfci_0af8691a7c";
            case 15L: return "bfci_0bb687c5e4";
            case 16L: return "bfci_0d0a9f18c9";
            case 17L: return "bfci_0d10935287";
            case 18L: return "bfci_0dfb27eb98";
            case 19L: return "bfci_0e2c11caa7";
            case 20L: return "bfci_0f0fdd84b4";
            case 21L: return "bfci_0f450964bb";
            case 22L: return "bfci_0fbbca9837";
            case 23L: return "bfci_10aba1335f";
            case 24L: return "bfci_1198a24cac";
            case 25L: return "bfci_122d7c153b";
            case 26L: return "bfci_135553476e";
            case 27L: return "bfci_13c0119692";
            case 28L: return "bfci_13d7c9c82c";
            case 29L: return "bfci_14f926a96f";
            case 30L: return "bfci_1584883a5c";
            case 31L: return "bfci_15ebbdebe4";
            case 32L: return "bfci_160e35243c";
            case 33L: return "bfci_1639e4d87e";
            case 34L: return "bfci_166c46465e";
            case 35L: return "bfci_16e0f137b7";
            case 36L: return "bfci_16f3f18c14";
            case 37L: return "bfci_170d16fb66";
            case 38L: return "bfci_18105219d6";
            case 39L: return "bfci_1885733069";
            case 40L: return "bfci_189110168a";
            case 41L: return "bfci_1b22e07cde";
            case 42L: return "bfci_1cf925f27f";
            case 43L: return "bfci_1fac3ab6f4";
            case 44L: return "bfci_2140592716";
            case 45L: return "bfci_22cb5f6c47";
            case 46L: return "bfci_24c1f47fe6";
            case 47L: return "bfci_24d7b6c650";
            case 48L: return "bfci_251bba9b08";
            case 49L: return "bfci_2571367846";
            case 50L: return "bfci_271bd9e275";
            case 51L: return "bfci_28d016cf40";
            case 52L: return "bfci_2b6a6ccbfd";
            case 53L: return "bfci_2b83d5c086";
            case 54L: return "bfci_2bdc9b7c53";
            case 55L: return "bfci_2db268fef1";
            case 56L: return "bfci_2e3d8a2d64";
            case 57L: return "bfci_2eda4ca466";
            case 58L: return "bfci_2fb7d11850";
            case 59L: return "bfci_2ffc57d066";
            case 60L: return "bfci_30a8f841d0";
            case 61L: return "bfci_31381ad87d";
            case 62L: return "bfci_3184ecb0eb";
            case 63L: return "bfci_32163ae6f8";
            case 64L: return "bfci_3325a27549";
            case 65L: return "bfci_33d2cd07a4";
            case 66L: return "bfci_360945a0aa";
            case 67L: return "bfci_3658d5daaf";
            case 68L: return "bfci_383686b422";
            case 69L: return "bfci_38b3fa5b0c";
            case 70L: return "bfci_3949302733";
            case 71L: return "bfci_396f29aaa8";
            case 72L: return "bfci_39931913b1";
            case 73L: return "bfci_3ad620d37f";
            case 74L: return "bfci_3b106353e2";
            case 75L: return "bfci_3b4d939364";
            case 76L: return "bfci_3b79ad16b9";
            case 77L: return "bfci_3cfb8e7c97";
            case 78L: return "bfci_3d7e578457";
            case 79L: return "bfci_3f173fe05a";
            case 80L: return "bfci_3f4487dc71";
            case 81L: return "bfci_3f8db3aebf";
            case 82L: return "bfci_405b7f8d43";
            case 83L: return "bfci_406d0b7d5c";
            case 84L: return "bfci_408e2de9f7";
            case 85L: return "bfci_430603b963";
            case 86L: return "bfci_43401f0c3e";
            case 87L: return "bfci_45b1e2f4fa";
            case 88L: return "bfci_4749af9536";
            case 89L: return "bfci_47a905f2ba";
            case 90L: return "bfci_49263981c7";
            case 91L: return "bfci_4abb53d66f";
            case 92L: return "bfci_4acd1a4ba9";
            case 93L: return "bfci_4b9fc82931";
            case 94L: return "bfci_4e1252c20f";
            case 95L: return "bfci_4f87c16939";
            case 96L: return "bfci_4f8b9a2b7f";
            case 97L: return "bfci_502ffc9ecc";
            case 98L: return "bfci_508053f403";
            case 99L: return "bfci_513a431293";
            case 100L: return "bfci_520a754f09";
            case 101L: return "bfci_522a7362cf";
            case 102L: return "bfci_5440a29628";
            case 103L: return "bfci_54a29ecd4b";
            case 104L: return "bfci_55c72c9da6";
            case 105L: return "bfci_5774453750";
            case 106L: return "bfci_577b2906b3";
            case 107L: return "bfci_57ae73720e";
            case 108L: return "bfci_57e928b997";
            case 109L: return "bfci_58bcc6410c";
            case 110L: return "bfci_59aa2e490d";
            case 111L: return "bfci_5a36eb321d";
            case 112L: return "bfci_5be90c6b88";
            case 113L: return "bfci_5bf906970b";
            case 114L: return "bfci_5d0cbe9254";
            case 115L: return "bfci_5d201f633a";
            case 116L: return "bfci_5d2530522e";
            case 117L: return "bfci_5df115a66d";
            case 118L: return "bfci_5e4b26a750";
            case 119L: return "bfci_5ebf9a8708";
            case 120L: return "bfci_5f64aa4ac8";
            case 121L: return "bfci_5feba30d04";
            case 122L: return "bfci_60dac71855";
            case 123L: return "bfci_6233187660";
            case 124L: return "bfci_62c10382ca";
            case 125L: return "bfci_634ad11953";
            case 126L: return "bfci_648771df08";
            case 127L: return "bfci_65c40afa78";
            case 128L: return "bfci_6697624632";
            case 129L: return "bfci_670852f41a";
            case 130L: return "bfci_67ee8aac99";
            case 131L: return "bfci_6824786031";
            case 132L: return "bfci_683cfc86f1";
            case 133L: return "bfci_69d4f189e6";
            case 134L: return "bfci_6a4e73b1f7";
            case 135L: return "bfci_6a8022365a";
            case 136L: return "bfci_6a8da69fa1";
            case 137L: return "bfci_6abc4780b6";
            case 138L: return "bfci_6b92f59576";
            case 139L: return "bfci_6c559f46f1";
            case 140L: return "bfci_6ccda99e01";
            case 141L: return "bfci_6cee601ca5";
            case 142L: return "bfci_6e8695f6e1";
            case 143L: return "bfci_6eb90db662";
            case 144L: return "bfci_6edf5a16fc";
            case 145L: return "bfci_6fdde64436";
            case 146L: return "bfci_7014af4af9";
            case 147L: return "bfci_70203bfabd";
            case 148L: return "bfci_715cee0f46";
            case 149L: return "bfci_716f146207";
            case 150L: return "bfci_7223e6309d";
            case 151L: return "bfci_7292666ab4";
            case 152L: return "bfci_72943f5562";
            case 153L: return "bfci_729bcfb28d";
            case 154L: return "bfci_73bf97c902";
            case 155L: return "bfci_745ba8dc3a";
            case 156L: return "bfci_74877ae309";
            case 157L: return "bfci_74973482fa";
            case 158L: return "bfci_752da8b1fe";
            case 159L: return "bfci_75bfa6e611";
            case 160L: return "bfci_779f906272";
            case 161L: return "bfci_77e865c6a2";
            case 162L: return "bfci_79815881ff";
            case 163L: return "bfci_7be4b0dc76";
            case 164L: return "bfci_7de2ca1029";
            case 165L: return "bfci_819b663547";
            case 166L: return "bfci_819dfc40c9";
            case 167L: return "bfci_81c684609e";
            case 168L: return "bfci_81f7ddea30";
            case 169L: return "bfci_822510f655";
            case 170L: return "bfci_828d52a9f4";
            case 171L: return "bfci_829d78317c";
            case 172L: return "bfci_83526e0f46";
            case 173L: return "bfci_835e2d4ab6";
            case 174L: return "bfci_83dcf0b45e";
            case 175L: return "bfci_846ca4ed95";
            case 176L: return "bfci_858b2c1758";
            case 177L: return "bfci_85c0226b73";
            case 178L: return "bfci_85c092f8a8";
            case 179L: return "bfci_863b97bf5d";
            case 180L: return "bfci_87c8ad8477";
            case 181L: return "bfci_88a563dd31";
            case 182L: return "bfci_89f7654db7";
            case 183L: return "bfci_89fcc8ec92";
            case 184L: return "bfci_8ad4effd96";
            case 185L: return "bfci_8bbfd5604c";
            case 186L: return "bfci_8d1a82004d";
            case 187L: return "bfci_8f30ba5abe";
            case 188L: return "bfci_915c9bd439";
            case 189L: return "bfci_91aef79def";
            case 190L: return "bfci_92436a153d";
            case 191L: return "bfci_9264184f34";
            case 192L: return "bfci_92b298e77f";
            case 193L: return "bfci_9377bbcfa7";
            case 194L: return "bfci_94fe8631f9";
            case 195L: return "bfci_9502adfe46";
            case 196L: return "bfci_959812e8be";
            case 197L: return "bfci_95deeaeb59";
            case 198L: return "bfci_95ef0a52d2";
            case 199L: return "bfci_9602b2a587";
            case 200L: return "bfci_9687f85046";
            case 201L: return "bfci_97cd2838f9";
            case 202L: return "bfci_99788cf313";
            case 203L: return "bfci_997f8f376f";
            case 204L: return "bfci_99cfd45cc2";
            case 205L: return "bfci_99d7e22373";
            case 206L: return "bfci_99f247e3d3";
            case 207L: return "bfci_9a6fa67179";
            case 208L: return "bfci_9c3f64c544";
            case 209L: return "bfci_9cb3f2de6d";
            case 210L: return "bfci_9e3f2d008e";
            case 211L: return "bfci_9ed43877aa";
            case 212L: return "bfci_9efa353721";
            case 213L: return "bfci_a11751e8c7";
            case 214L: return "bfci_a1ea1d44f4";
            case 215L: return "bfci_a201931f77";
            case 216L: return "bfci_a275c997e3";
            case 217L: return "bfci_a2cc09eead";
            case 218L: return "bfci_a33b49d4c4";
            case 219L: return "bfci_a3a7437041";
            case 220L: return "bfci_a4537c68bd";
            case 221L: return "bfci_a480f66892";
            case 222L: return "bfci_a4fe5f2994";
            case 223L: return "bfci_a5385dc887";
            case 224L: return "bfci_a53fd2bb41";
            case 225L: return "bfci_a64b37e87e";
            case 226L: return "bfci_a7330460b7";
            case 227L: return "bfci_a781bfe8c7";
            case 228L: return "bfci_a7dd4c94b3";
            case 229L: return "bfci_a7e9ce229c";
            case 230L: return "bfci_a7eff8f1a4";
            case 231L: return "bfci_a82603eeaa";
            case 232L: return "bfci_a86ccbad83";
            case 233L: return "bfci_a90062d397";
            case 234L: return "bfci_a97d66f655";
            case 235L: return "bfci_a9c6b361c8";
            case 236L: return "bfci_aa36cf1d2e";
            case 237L: return "bfci_ab11f6964c";
            case 238L: return "bfci_ab51cb3c48";
            case 239L: return "bfci_ab65adfe0e";
            case 240L: return "bfci_ad36df3502";
            case 241L: return "bfci_ad3825c933";
            case 242L: return "bfci_ad4ee88e3a";
            case 243L: return "bfci_adc63abe75";
            case 244L: return "bfci_adef37cffd";
            case 245L: return "bfci_ae8af20cc2";
            case 246L: return "bfci_af12fea7d2";
            case 247L: return "bfci_af2178e4b7";
            case 248L: return "bfci_af556fac96";
            case 249L: return "bfci_b03ddf20b3";
            case 250L: return "bfci_b10b51ded7";
            case 251L: return "bfci_b114fd9a3e";
            case 252L: return "bfci_b1cec7092e";
            case 253L: return "bfci_b44ceb883d";
            case 254L: return "bfci_b455251d81";
            case 255L: return "bfci_b4aa481bef";
            case 256L: return "bfci_b51a2bbe85";
            case 257L: return "bfci_b539c6f0a8";
            case 258L: return "bfci_b57a37d661";
            case 259L: return "bfci_b686ebed1a";
            case 260L: return "bfci_b73c4f16e5";
            case 261L: return "bfci_b813592eb0";
            case 262L: return "bfci_b90efe4b7e";
            case 263L: return "bfci_bad392549e";
            case 264L: return "bfci_bb902b1b0f";
            case 265L: return "bfci_bd0ab013c9";
            case 266L: return "bfci_bdbd39ad4d";
            case 267L: return "bfci_c05dc7594c";
            case 268L: return "bfci_c0cfdaf944";
            case 269L: return "bfci_c382276e7f";
            case 270L: return "bfci_c3a192d6c1";
            case 271L: return "bfci_c5fa5926f2";
            case 272L: return "bfci_c607fd9992";
            case 273L: return "bfci_c643c030aa";
            case 274L: return "bfci_c69f9a4f8b";
            case 275L: return "bfci_c6feacf333";
            case 276L: return "bfci_c777f677f3";
            case 277L: return "bfci_c786ccfb66";
            case 278L: return "bfci_c798f5e9ea";
            case 279L: return "bfci_c8e6be958a";
            case 280L: return "bfci_c9c7312b28";
            case 281L: return "bfci_c9f1aecdc8";
            case 282L: return "bfci_ca711666f3";
            case 283L: return "bfci_cc0c786b5d";
            case 284L: return "bfci_cc1e0d9edc";
            case 285L: return "bfci_cd45f1821e";
            case 286L: return "bfci_cd9f9d0b56";
            case 287L: return "bfci_ce2a96ed38";
            case 288L: return "bfci_ce961ebf23";
            case 289L: return "bfci_cec983dfe6";
            case 290L: return "bfci_cee21c23e8";
            case 291L: return "bfci_d23485c2ea";
            case 292L: return "bfci_d24f7b9365";
            case 293L: return "bfci_d35abe7739";
            case 294L: return "bfci_d433cc386c";
            case 295L: return "bfci_d4799f266b";
            case 296L: return "bfci_d76d02e310";
            case 297L: return "bfci_da325b342e";
            case 298L: return "bfci_dacb367fda";
            case 299L: return "bfci_db0aa07e4d";
            case 300L: return "bfci_dc3e7aaf4d";
            case 301L: return "bfci_dd24ef61c4";
            case 302L: return "bfci_ddcf876873";
            case 303L: return "bfci_de9d5193d7";
            case 304L: return "bfci_debe17f022";
            case 305L: return "bfci_df46b9ba82";
            case 306L: return "bfci_e153c0eaa5";
            case 307L: return "bfci_e155f0607a";
            case 308L: return "bfci_e2a99c7094";
            case 309L: return "bfci_e374bf567b";
            case 310L: return "bfci_e37c836637";
            case 311L: return "bfci_e55047361b";
            case 312L: return "bfci_e64364acdb";
            case 313L: return "bfci_e6b4e03721";
            case 314L: return "bfci_e73f511266";
            case 315L: return "bfci_e7ab46e012";
            case 316L: return "bfci_e866a09f1e";
            case 317L: return "bfci_e91242a7aa";
            case 318L: return "bfci_e9223a9620";
            case 319L: return "bfci_e97e9b924a";
            case 320L: return "bfci_ea9c300354";
            case 321L: return "bfci_eba83ed205";
            case 322L: return "bfci_ec6b7e9ab8";
            case 323L: return "bfci_ed67fabb51";
            case 324L: return "bfci_ed7b044a3b";
            case 325L: return "bfci_ee6ba5fd86";
            case 326L: return "bfci_ef0582593d";
            case 327L: return "bfci_ef39595129";
            case 328L: return "bfci_f023265b7b";
            case 329L: return "bfci_f0ca9ebb2a";
            case 330L: return "bfci_f1a07309fd";
            case 331L: return "bfci_f1bcd01647";
            case 332L: return "bfci_f328633379";
            case 333L: return "bfci_f38d5e9172";
            case 334L: return "bfci_f3f5ce09c8";
            case 335L: return "bfci_f40ffd293a";
            case 336L: return "bfci_f4471a96d1";
            case 337L: return "bfci_f6c14e39e6";
            case 338L: return "bfci_f7bb06f3b6";
            case 339L: return "bfci_f8fb60295c";
            case 340L: return "bfci_fa0252ddf6";
            case 341L: return "bfci_fb44431c81";
            case 342L: return "bfci_fbeac09b3b";
            case 343L: return "bfci_fc1eb2921c";
            case 344L: return "bfci_fcef52416a";
            case 345L: return "bfci_fcf334be72";
            case 346L: return "bfci_fd1f445e0f";
            case 347L: return "bfci_fd9a903e86";
            case 348L: return "bfci_ff000f0c81";
            case 349L: return "bfci_ff337d6933";
            case 350L: return "bfci_ffd4a0cf4a";
            case 351L: return "bfci_last";
            default: return "";
        }
    }

    std::string a_builtin_function_condition_index(int64_t i, const std::string &strip) {
        std::string s = a_builtin_function_condition_index(i);
        if (s.empty())
            s = "(a_builtin_function_condition_index)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_builtin_function_condition_index() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L,
            58L,
            59L,
            60L,
            61L,
            62L,
            63L,
            64L,
            65L,
            66L,
            67L,
            68L,
            69L,
            70L,
            71L,
            72L,
            73L,
            74L,
            75L,
            76L,
            77L,
            78L,
            79L,
            80L,
            81L,
            82L,
            83L,
            84L,
            85L,
            86L,
            87L,
            88L,
            89L,
            90L,
            91L,
            92L,
            93L,
            94L,
            95L,
            96L,
            97L,
            98L,
            99L,
            100L,
            101L,
            102L,
            103L,
            104L,
            105L,
            106L,
            107L,
            108L,
            109L,
            110L,
            111L,
            112L,
            113L,
            114L,
            115L,
            116L,
            117L,
            118L,
            119L,
            120L,
            121L,
            122L,
            123L,
            124L,
            125L,
            126L,
            127L,
            128L,
            129L,
            130L,
            131L,
            132L,
            133L,
            134L,
            135L,
            136L,
            137L,
            138L,
            139L,
            140L,
            141L,
            142L,
            143L,
            144L,
            145L,
            146L,
            147L,
            148L,
            149L,
            150L,
            151L,
            152L,
            153L,
            154L,
            155L,
            156L,
            157L,
            158L,
            159L,
            160L,
            161L,
            162L,
            163L,
            164L,
            165L,
            166L,
            167L,
            168L,
            169L,
            170L,
            171L,
            172L,
            173L,
            174L,
            175L,
            176L,
            177L,
            178L,
            179L,
            180L,
            181L,
            182L,
            183L,
            184L,
            185L,
            186L,
            187L,
            188L,
            189L,
            190L,
            191L,
            192L,
            193L,
            194L,
            195L,
            196L,
            197L,
            198L,
            199L,
            200L,
            201L,
            202L,
            203L,
            204L,
            205L,
            206L,
            207L,
            208L,
            209L,
            210L,
            211L,
            212L,
            213L,
            214L,
            215L,
            216L,
            217L,
            218L,
            219L,
            220L,
            221L,
            222L,
            223L,
            224L,
            225L,
            226L,
            227L,
            228L,
            229L,
            230L,
            231L,
            232L,
            233L,
            234L,
            235L,
            236L,
            237L,
            238L,
            239L,
            240L,
            241L,
            242L,
            243L,
            244L,
            245L,
            246L,
            247L,
            248L,
            249L,
            250L,
            251L,
            252L,
            253L,
            254L,
            255L,
            256L,
            257L,
            258L,
            259L,
            260L,
            261L,
            262L,
            263L,
            264L,
            265L,
            266L,
            267L,
            268L,
            269L,
            270L,
            271L,
            272L,
            273L,
            274L,
            275L,
            276L,
            277L,
            278L,
            279L,
            280L,
            281L,
            282L,
            283L,
            284L,
            285L,
            286L,
            287L,
            288L,
            289L,
            290L,
            291L,
            292L,
            293L,
            294L,
            295L,
            296L,
            297L,
            298L,
            299L,
            300L,
            301L,
            302L,
            303L,
            304L,
            305L,
            306L,
            307L,
            308L,
            309L,
            310L,
            311L,
            312L,
            313L,
            314L,
            315L,
            316L,
            317L,
            318L,
            319L,
            320L,
            321L,
            322L,
            323L,
            324L,
            325L,
            326L,
            327L,
            328L,
            329L,
            330L,
            331L,
            332L,
            333L,
            334L,
            335L,
            336L,
            337L,
            338L,
            339L,
            340L,
            341L,
            342L,
            343L,
            344L,
            345L,
            346L,
            347L,
            348L,
            349L,
            350L,
            351L
        };
        static const std::vector<int64_t> retval(values, values + 352);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_builtin_function_condition_index(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_builtin_function_condition_index(i);
        if (retval.empty()) {
            retval = "(a_builtin_function_condition_index)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_builtin_function_condition_index::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_builtin_function_condition_index() {
        return stringify::a_builtin_function_condition_index();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/builtin_defs.h line 6527
namespace stringify {
    const char* a_builtin_function_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "bfk_none";
            case 1L: return "bfk_FILE";
            case 2L: return "bfk_FUNCTION";
            case 3L: return "bfk_GOMP_atomic_end";
            case 4L: return "bfk_GOMP_atomic_start";
            case 5L: return "bfk_GOMP_barrier";
            case 6L: return "bfk_GOMP_barrier_cancel";
            case 7L: return "bfk_GOMP_cancel";
            case 8L: return "bfk_GOMP_cancellation_point";
            case 9L: return "bfk_GOMP_critical_end";
            case 10L: return "bfk_GOMP_critical_name_end";
            case 11L: return "bfk_GOMP_critical_name_start";
            case 12L: return "bfk_GOMP_critical_start";
            case 13L: return "bfk_GOMP_loop_dynamic_next";
            case 14L: return "bfk_GOMP_loop_dynamic_start";
            case 15L: return "bfk_GOMP_loop_end";
            case 16L: return "bfk_GOMP_loop_end_cancel";
            case 17L: return "bfk_GOMP_loop_end_nowait";
            case 18L: return "bfk_GOMP_loop_guided_next";
            case 19L: return "bfk_GOMP_loop_guided_start";
            case 20L: return "bfk_GOMP_loop_ordered_dynamic_next";
            case 21L: return "bfk_GOMP_loop_ordered_dynamic_start";
            case 22L: return "bfk_GOMP_loop_ordered_guided_next";
            case 23L: return "bfk_GOMP_loop_ordered_guided_start";
            case 24L: return "bfk_GOMP_loop_ordered_runtime_next";
            case 25L: return "bfk_GOMP_loop_ordered_runtime_start";
            case 26L: return "bfk_GOMP_loop_ordered_static_next";
            case 27L: return "bfk_GOMP_loop_ordered_static_start";
            case 28L: return "bfk_GOMP_loop_runtime_next";
            case 29L: return "bfk_GOMP_loop_runtime_start";
            case 30L: return "bfk_GOMP_loop_static_next";
            case 31L: return "bfk_GOMP_loop_static_start";
            case 32L: return "bfk_GOMP_loop_ull_dynamic_next";
            case 33L: return "bfk_GOMP_loop_ull_dynamic_start";
            case 34L: return "bfk_GOMP_loop_ull_guided_next";
            case 35L: return "bfk_GOMP_loop_ull_guided_start";
            case 36L: return "bfk_GOMP_loop_ull_ordered_dynamic_next";
            case 37L: return "bfk_GOMP_loop_ull_ordered_dynamic_start";
            case 38L: return "bfk_GOMP_loop_ull_ordered_guided_next";
            case 39L: return "bfk_GOMP_loop_ull_ordered_guided_start";
            case 40L: return "bfk_GOMP_loop_ull_ordered_runtime_next";
            case 41L: return "bfk_GOMP_loop_ull_ordered_runtime_start";
            case 42L: return "bfk_GOMP_loop_ull_ordered_static_next";
            case 43L: return "bfk_GOMP_loop_ull_ordered_static_start";
            case 44L: return "bfk_GOMP_loop_ull_runtime_next";
            case 45L: return "bfk_GOMP_loop_ull_runtime_start";
            case 46L: return "bfk_GOMP_loop_ull_static_next";
            case 47L: return "bfk_GOMP_loop_ull_static_start";
            case 48L: return "bfk_GOMP_ordered_end";
            case 49L: return "bfk_GOMP_ordered_start";
            case 50L: return "bfk_GOMP_parallel";
            case 51L: return "bfk_GOMP_parallel_end";
            case 52L: return "bfk_GOMP_parallel_loop_dynamic";
            case 53L: return "bfk_GOMP_parallel_loop_dynamic_start";
            case 54L: return "bfk_GOMP_parallel_loop_guided";
            case 55L: return "bfk_GOMP_parallel_loop_guided_start";
            case 56L: return "bfk_GOMP_parallel_loop_runtime";
            case 57L: return "bfk_GOMP_parallel_loop_runtime_start";
            case 58L: return "bfk_GOMP_parallel_loop_static";
            case 59L: return "bfk_GOMP_parallel_loop_static_start";
            case 60L: return "bfk_GOMP_parallel_sections";
            case 61L: return "bfk_GOMP_parallel_sections_start";
            case 62L: return "bfk_GOMP_parallel_start";
            case 63L: return "bfk_GOMP_sections_end";
            case 64L: return "bfk_GOMP_sections_end_cancel";
            case 65L: return "bfk_GOMP_sections_end_nowait";
            case 66L: return "bfk_GOMP_sections_next";
            case 67L: return "bfk_GOMP_sections_start";
            case 68L: return "bfk_GOMP_single_copy_end";
            case 69L: return "bfk_GOMP_single_copy_start";
            case 70L: return "bfk_GOMP_single_start";
            case 71L: return "bfk_GOMP_target";
            case 72L: return "bfk_GOMP_target_data";
            case 73L: return "bfk_GOMP_target_end_data";
            case 74L: return "bfk_GOMP_target_update";
            case 75L: return "bfk_GOMP_task";
            case 76L: return "bfk_GOMP_taskgroup_end";
            case 77L: return "bfk_GOMP_taskgroup_start";
            case 78L: return "bfk_GOMP_taskwait";
            case 79L: return "bfk_GOMP_taskyield";
            case 80L: return "bfk_GOMP_teams";
            case 81L: return "bfk_LINE";
            case 82L: return "bfk__Block_object_assign";
            case 83L: return "bfk__Block_object_dispose";
            case 84L: return "bfk__Exit";
            case 85L: return "bfk___CFStringMakeConstantString";
            case 86L: return "bfk___NSStringMakeConstantString";
            case 87L: return "bfk___annotation";
            case 88L: return "bfk___bnd_chk_ptr_bounds";
            case 89L: return "bfk___bnd_chk_ptr_lbounds";
            case 90L: return "bfk___bnd_chk_ptr_ubounds";
            case 91L: return "bfk___bnd_copy_ptr_bounds";
            case 92L: return "bfk___bnd_get_ptr_lbound";
            case 93L: return "bfk___bnd_get_ptr_ubound";
            case 94L: return "bfk___bnd_init_ptr_bounds";
            case 95L: return "bfk___bnd_narrow_ptr_bounds";
            case 96L: return "bfk___bnd_null_ptr_bounds";
            case 97L: return "bfk___bnd_set_ptr_bounds";
            case 98L: return "bfk___bnd_store_ptr_bounds";
            case 99L: return "bfk___c11_atomic_compare_exchange_strong";
            case 100L: return "bfk___c11_atomic_compare_exchange_weak";
            case 101L: return "bfk___c11_atomic_exchange";
            case 102L: return "bfk___c11_atomic_fetch_add";
            case 103L: return "bfk___c11_atomic_fetch_and";
            case 104L: return "bfk___c11_atomic_fetch_or";
            case 105L: return "bfk___c11_atomic_fetch_sub";
            case 106L: return "bfk___c11_atomic_fetch_xor";
            case 107L: return "bfk___c11_atomic_init";
            case 108L: return "bfk___c11_atomic_is_lock_free";
            case 109L: return "bfk___c11_atomic_load";
            case 110L: return "bfk___c11_atomic_signal_fence";
            case 111L: return "bfk___c11_atomic_store";
            case 112L: return "bfk___c11_atomic_thread_fence";
            case 113L: return "bfk___chkp_bndldx";
            case 114L: return "bfk___clear_cache";
            case 115L: return "bfk___cospi";
            case 116L: return "bfk___cospif";
            case 117L: return "bfk___cxa_call_unexpected";
            case 118L: return "bfk___cyg_profile_func_enter";
            case 119L: return "bfk___cyg_profile_func_exit";
            case 120L: return "bfk___debugbreak";
            case 121L: return "bfk___divdc3";
            case 122L: return "bfk___divsc3";
            case 123L: return "bfk___divxc3";
            case 124L: return "bfk___exp10";
            case 125L: return "bfk___exp10f";
            case 126L: return "bfk___finite";
            case 127L: return "bfk___finitef";
            case 128L: return "bfk___finitel";
            case 129L: return "bfk___fprintf_chk";
            case 130L: return "bfk___get_unsafe_stack_bottom";
            case 131L: return "bfk___get_unsafe_stack_ptr";
            case 132L: return "bfk___get_unsafe_stack_start";
            case 133L: return "bfk___get_unsafe_stack_top";
            case 134L: return "bfk___memccpy_chk";
            case 135L: return "bfk___memcpy_chk";
            case 136L: return "bfk___memmove_chk";
            case 137L: return "bfk___mempcpy_chk";
            case 138L: return "bfk___memset_chk";
            case 139L: return "bfk___muldc3";
            case 140L: return "bfk___mulsc3";
            case 141L: return "bfk___mulxc3";
            case 142L: return "bfk___opencl_atomic_compare_exchange_strong";
            case 143L: return "bfk___opencl_atomic_compare_exchange_weak";
            case 144L: return "bfk___opencl_atomic_exchange";
            case 145L: return "bfk___opencl_atomic_fetch_add";
            case 146L: return "bfk___opencl_atomic_fetch_and";
            case 147L: return "bfk___opencl_atomic_fetch_max";
            case 148L: return "bfk___opencl_atomic_fetch_min";
            case 149L: return "bfk___opencl_atomic_fetch_or";
            case 150L: return "bfk___opencl_atomic_fetch_sub";
            case 151L: return "bfk___opencl_atomic_fetch_xor";
            case 152L: return "bfk___opencl_atomic_init";
            case 153L: return "bfk___opencl_atomic_load";
            case 154L: return "bfk___opencl_atomic_store";
            case 155L: return "bfk___printf_chk";
            case 156L: return "bfk___rdtsc";
            case 157L: return "bfk___sinpi";
            case 158L: return "bfk___sinpif";
            case 159L: return "bfk___snprintf_chk";
            case 160L: return "bfk___sprintf_chk";
            case 161L: return "bfk___stpcpy_chk";
            case 162L: return "bfk___stpncpy_chk";
            case 163L: return "bfk___strcat_chk";
            case 164L: return "bfk___strcpy_chk";
            case 165L: return "bfk___strlcat_chk";
            case 166L: return "bfk___strlcpy_chk";
            case 167L: return "bfk___strncat_chk";
            case 168L: return "bfk___strncpy_chk";
            case 169L: return "bfk___tanpi";
            case 170L: return "bfk___tanpif";
            case 171L: return "bfk___vfprintf_chk";
            case 172L: return "bfk___vprintf_chk";
            case 173L: return "bfk___vsnprintf_chk";
            case 174L: return "bfk___vsprintf_chk";
            case 175L: return "bfk___xray_customevent";
            case 176L: return "bfk___xray_typedevent";
            case 177L: return "bfk__exit";
            case 178L: return "bfk__mm_clflush";
            case 179L: return "bfk__mm_getcsr";
            case 180L: return "bfk__mm_lfence";
            case 181L: return "bfk__mm_mfence";
            case 182L: return "bfk__mm_pause";
            case 183L: return "bfk__mm_prefetch";
            case 184L: return "bfk__mm_setcsr";
            case 185L: return "bfk__mm_sfence";
            case 186L: return "bfk_abort";
            case 187L: return "bfk_abs";
            case 188L: return "bfk_acc_on_device";
            case 189L: return "bfk_acos";
            case 190L: return "bfk_acosf";
            case 191L: return "bfk_acosh";
            case 192L: return "bfk_acoshf";
            case 193L: return "bfk_acoshl";
            case 194L: return "bfk_acosl";
            case 195L: return "bfk_add_overflow";
            case 196L: return "bfk_add_overflow_p";
            case 197L: return "bfk_addc";
            case 198L: return "bfk_addcb";
            case 199L: return "bfk_addcl";
            case 200L: return "bfk_addcll";
            case 201L: return "bfk_addcs";
            case 202L: return "bfk_addressof";
            case 203L: return "bfk_adjust_descriptor";
            case 204L: return "bfk_adjust_trampoline";
            case 205L: return "bfk_aggregate_incoming_address";
            case 206L: return "bfk_aligned_alloc";
            case 207L: return "bfk_alloca";
            case 208L: return "bfk_alloca_with_align";
            case 209L: return "bfk_alloca_with_align_and_max";
            case 210L: return "bfk_annotation";
            case 211L: return "bfk_apply";
            case 212L: return "bfk_apply_args";
            case 213L: return "bfk_args_info";
            case 214L: return "bfk_asin";
            case 215L: return "bfk_asinf";
            case 216L: return "bfk_asinh";
            case 217L: return "bfk_asinhf";
            case 218L: return "bfk_asinhl";
            case 219L: return "bfk_asinl";
            case 220L: return "bfk_assume";
            case 221L: return "bfk_assume_aligned";
            case 222L: return "bfk_atan";
            case 223L: return "bfk_atan2";
            case 224L: return "bfk_atan2f";
            case 225L: return "bfk_atan2l";
            case 226L: return "bfk_atanf";
            case 227L: return "bfk_atanh";
            case 228L: return "bfk_atanhf";
            case 229L: return "bfk_atanhl";
            case 230L: return "bfk_atanl";
            case 231L: return "bfk_atomic_add_fetch";
            case 232L: return "bfk_atomic_add_fetch_1";
            case 233L: return "bfk_atomic_add_fetch_16";
            case 234L: return "bfk_atomic_add_fetch_2";
            case 235L: return "bfk_atomic_add_fetch_4";
            case 236L: return "bfk_atomic_add_fetch_8";
            case 237L: return "bfk_atomic_always_lock_free";
            case 238L: return "bfk_atomic_and_fetch";
            case 239L: return "bfk_atomic_and_fetch_1";
            case 240L: return "bfk_atomic_and_fetch_16";
            case 241L: return "bfk_atomic_and_fetch_2";
            case 242L: return "bfk_atomic_and_fetch_4";
            case 243L: return "bfk_atomic_and_fetch_8";
            case 244L: return "bfk_atomic_clear";
            case 245L: return "bfk_atomic_compare_exchange";
            case 246L: return "bfk_atomic_compare_exchange_1";
            case 247L: return "bfk_atomic_compare_exchange_16";
            case 248L: return "bfk_atomic_compare_exchange_2";
            case 249L: return "bfk_atomic_compare_exchange_4";
            case 250L: return "bfk_atomic_compare_exchange_8";
            case 251L: return "bfk_atomic_compare_exchange_n";
            case 252L: return "bfk_atomic_exchange";
            case 253L: return "bfk_atomic_exchange_1";
            case 254L: return "bfk_atomic_exchange_16";
            case 255L: return "bfk_atomic_exchange_2";
            case 256L: return "bfk_atomic_exchange_4";
            case 257L: return "bfk_atomic_exchange_8";
            case 258L: return "bfk_atomic_exchange_n";
            case 259L: return "bfk_atomic_feraiseexcept";
            case 260L: return "bfk_atomic_fetch_add";
            case 261L: return "bfk_atomic_fetch_add_1";
            case 262L: return "bfk_atomic_fetch_add_16";
            case 263L: return "bfk_atomic_fetch_add_2";
            case 264L: return "bfk_atomic_fetch_add_4";
            case 265L: return "bfk_atomic_fetch_add_8";
            case 266L: return "bfk_atomic_fetch_and";
            case 267L: return "bfk_atomic_fetch_and_1";
            case 268L: return "bfk_atomic_fetch_and_16";
            case 269L: return "bfk_atomic_fetch_and_2";
            case 270L: return "bfk_atomic_fetch_and_4";
            case 271L: return "bfk_atomic_fetch_and_8";
            case 272L: return "bfk_atomic_fetch_max";
            case 273L: return "bfk_atomic_fetch_min";
            case 274L: return "bfk_atomic_fetch_nand";
            case 275L: return "bfk_atomic_fetch_nand_1";
            case 276L: return "bfk_atomic_fetch_nand_16";
            case 277L: return "bfk_atomic_fetch_nand_2";
            case 278L: return "bfk_atomic_fetch_nand_4";
            case 279L: return "bfk_atomic_fetch_nand_8";
            case 280L: return "bfk_atomic_fetch_or";
            case 281L: return "bfk_atomic_fetch_or_1";
            case 282L: return "bfk_atomic_fetch_or_16";
            case 283L: return "bfk_atomic_fetch_or_2";
            case 284L: return "bfk_atomic_fetch_or_4";
            case 285L: return "bfk_atomic_fetch_or_8";
            case 286L: return "bfk_atomic_fetch_sub";
            case 287L: return "bfk_atomic_fetch_sub_1";
            case 288L: return "bfk_atomic_fetch_sub_16";
            case 289L: return "bfk_atomic_fetch_sub_2";
            case 290L: return "bfk_atomic_fetch_sub_4";
            case 291L: return "bfk_atomic_fetch_sub_8";
            case 292L: return "bfk_atomic_fetch_xor";
            case 293L: return "bfk_atomic_fetch_xor_1";
            case 294L: return "bfk_atomic_fetch_xor_16";
            case 295L: return "bfk_atomic_fetch_xor_2";
            case 296L: return "bfk_atomic_fetch_xor_4";
            case 297L: return "bfk_atomic_fetch_xor_8";
            case 298L: return "bfk_atomic_is_lock_free";
            case 299L: return "bfk_atomic_load";
            case 300L: return "bfk_atomic_load_1";
            case 301L: return "bfk_atomic_load_16";
            case 302L: return "bfk_atomic_load_2";
            case 303L: return "bfk_atomic_load_4";
            case 304L: return "bfk_atomic_load_8";
            case 305L: return "bfk_atomic_load_n";
            case 306L: return "bfk_atomic_nand_fetch";
            case 307L: return "bfk_atomic_nand_fetch_1";
            case 308L: return "bfk_atomic_nand_fetch_16";
            case 309L: return "bfk_atomic_nand_fetch_2";
            case 310L: return "bfk_atomic_nand_fetch_4";
            case 311L: return "bfk_atomic_nand_fetch_8";
            case 312L: return "bfk_atomic_or_fetch";
            case 313L: return "bfk_atomic_or_fetch_1";
            case 314L: return "bfk_atomic_or_fetch_16";
            case 315L: return "bfk_atomic_or_fetch_2";
            case 316L: return "bfk_atomic_or_fetch_4";
            case 317L: return "bfk_atomic_or_fetch_8";
            case 318L: return "bfk_atomic_signal_fence";
            case 319L: return "bfk_atomic_store";
            case 320L: return "bfk_atomic_store_1";
            case 321L: return "bfk_atomic_store_16";
            case 322L: return "bfk_atomic_store_2";
            case 323L: return "bfk_atomic_store_4";
            case 324L: return "bfk_atomic_store_8";
            case 325L: return "bfk_atomic_store_n";
            case 326L: return "bfk_atomic_sub_fetch";
            case 327L: return "bfk_atomic_sub_fetch_1";
            case 328L: return "bfk_atomic_sub_fetch_16";
            case 329L: return "bfk_atomic_sub_fetch_2";
            case 330L: return "bfk_atomic_sub_fetch_4";
            case 331L: return "bfk_atomic_sub_fetch_8";
            case 332L: return "bfk_atomic_test_and_set";
            case 333L: return "bfk_atomic_thread_fence";
            case 334L: return "bfk_atomic_xor_fetch";
            case 335L: return "bfk_atomic_xor_fetch_1";
            case 336L: return "bfk_atomic_xor_fetch_16";
            case 337L: return "bfk_atomic_xor_fetch_2";
            case 338L: return "bfk_atomic_xor_fetch_4";
            case 339L: return "bfk_atomic_xor_fetch_8";
            case 340L: return "bfk_bcmp";
            case 341L: return "bfk_bcopy";
            case 342L: return "bfk_bitreverse16";
            case 343L: return "bfk_bitreverse32";
            case 344L: return "bfk_bitreverse64";
            case 345L: return "bfk_bitreverse8";
            case 346L: return "bfk_bswap16";
            case 347L: return "bfk_bswap32";
            case 348L: return "bfk_bswap64";
            case 349L: return "bfk_bzero";
            case 350L: return "bfk_cabs";
            case 351L: return "bfk_cabsf";
            case 352L: return "bfk_cabsl";
            case 353L: return "bfk_cacos";
            case 354L: return "bfk_cacosf";
            case 355L: return "bfk_cacosh";
            case 356L: return "bfk_cacoshf";
            case 357L: return "bfk_cacoshl";
            case 358L: return "bfk_cacosl";
            case 359L: return "bfk_call_with_static_chain";
            case 360L: return "bfk_calloc";
            case 361L: return "bfk_canonicalize";
            case 362L: return "bfk_canonicalizef";
            case 363L: return "bfk_canonicalizel";
            case 364L: return "bfk_carg";
            case 365L: return "bfk_cargf";
            case 366L: return "bfk_cargl";
            case 367L: return "bfk_casin";
            case 368L: return "bfk_casinf";
            case 369L: return "bfk_casinh";
            case 370L: return "bfk_casinhf";
            case 371L: return "bfk_casinhl";
            case 372L: return "bfk_casinl";
            case 373L: return "bfk_catan";
            case 374L: return "bfk_catanf";
            case 375L: return "bfk_catanh";
            case 376L: return "bfk_catanhf";
            case 377L: return "bfk_catanhl";
            case 378L: return "bfk_catanl";
            case 379L: return "bfk_cbrt";
            case 380L: return "bfk_cbrtf";
            case 381L: return "bfk_cbrtl";
            case 382L: return "bfk_ccos";
            case 383L: return "bfk_ccosf";
            case 384L: return "bfk_ccosh";
            case 385L: return "bfk_ccoshf";
            case 386L: return "bfk_ccoshl";
            case 387L: return "bfk_ccosl";
            case 388L: return "bfk_ceil";
            case 389L: return "bfk_ceilf";
            case 390L: return "bfk_ceilf32";
            case 391L: return "bfk_ceilf32x";
            case 392L: return "bfk_ceilf64";
            case 393L: return "bfk_ceilf64x";
            case 394L: return "bfk_ceill";
            case 395L: return "bfk_cexp";
            case 396L: return "bfk_cexpf";
            case 397L: return "bfk_cexpi";
            case 398L: return "bfk_cexpif";
            case 399L: return "bfk_cexpil";
            case 400L: return "bfk_cexpl";
            case 401L: return "bfk_char_memchr";
            case 402L: return "bfk_chkp_memcpy_nobnd";
            case 403L: return "bfk_chkp_memcpy_nobnd_nochk";
            case 404L: return "bfk_chkp_memcpy_nochk";
            case 405L: return "bfk_chkp_memmove_nobnd";
            case 406L: return "bfk_chkp_memmove_nobnd_nochk";
            case 407L: return "bfk_chkp_memmove_nochk";
            case 408L: return "bfk_chkp_mempcpy_nobnd";
            case 409L: return "bfk_chkp_mempcpy_nobnd_nochk";
            case 410L: return "bfk_chkp_mempcpy_nochk";
            case 411L: return "bfk_chkp_memset_nobnd";
            case 412L: return "bfk_chkp_memset_nobnd_nochk";
            case 413L: return "bfk_chkp_memset_nochk";
            case 414L: return "bfk_cimag";
            case 415L: return "bfk_cimagf";
            case 416L: return "bfk_cimagl";
            case 417L: return "bfk_classify_type";
            case 418L: return "bfk_clog";
            case 419L: return "bfk_clog10";
            case 420L: return "bfk_clog10f";
            case 421L: return "bfk_clog10l";
            case 422L: return "bfk_clogf";
            case 423L: return "bfk_clogl";
            case 424L: return "bfk_clrsb";
            case 425L: return "bfk_clrsbimax";
            case 426L: return "bfk_clrsbl";
            case 427L: return "bfk_clrsbll";
            case 428L: return "bfk_clz";
            case 429L: return "bfk_clzimax";
            case 430L: return "bfk_clzl";
            case 431L: return "bfk_clzll";
            case 432L: return "bfk_clzs";
            case 433L: return "bfk_conj";
            case 434L: return "bfk_conjf";
            case 435L: return "bfk_conjl";
            case 436L: return "bfk_constant_p";
            case 437L: return "bfk_convertvector";
            case 438L: return "bfk_copysign";
            case 439L: return "bfk_copysignf";
            case 440L: return "bfk_copysignf128";
            case 441L: return "bfk_copysignf32";
            case 442L: return "bfk_copysignf32x";
            case 443L: return "bfk_copysignf64";
            case 444L: return "bfk_copysignf64x";
            case 445L: return "bfk_copysignl";
            case 446L: return "bfk_coro_alloc";
            case 447L: return "bfk_coro_begin";
            case 448L: return "bfk_coro_destroy";
            case 449L: return "bfk_coro_done";
            case 450L: return "bfk_coro_end";
            case 451L: return "bfk_coro_frame";
            case 452L: return "bfk_coro_free";
            case 453L: return "bfk_coro_id";
            case 454L: return "bfk_coro_noop";
            case 455L: return "bfk_coro_param";
            case 456L: return "bfk_coro_promise";
            case 457L: return "bfk_coro_resume";
            case 458L: return "bfk_coro_size";
            case 459L: return "bfk_coro_suspend";
            case 460L: return "bfk_cos";
            case 461L: return "bfk_cosf";
            case 462L: return "bfk_cosh";
            case 463L: return "bfk_coshf";
            case 464L: return "bfk_coshl";
            case 465L: return "bfk_cosl";
            case 466L: return "bfk_cpow";
            case 467L: return "bfk_cpowf";
            case 468L: return "bfk_cpowl";
            case 469L: return "bfk_cproj";
            case 470L: return "bfk_cprojf";
            case 471L: return "bfk_cprojl";
            case 472L: return "bfk_cpu_init";
            case 473L: return "bfk_cpu_is";
            case 474L: return "bfk_cpu_supports";
            case 475L: return "bfk_creal";
            case 476L: return "bfk_crealf";
            case 477L: return "bfk_creall";
            case 478L: return "bfk_csin";
            case 479L: return "bfk_csinf";
            case 480L: return "bfk_csinh";
            case 481L: return "bfk_csinhf";
            case 482L: return "bfk_csinhl";
            case 483L: return "bfk_csinl";
            case 484L: return "bfk_csqrt";
            case 485L: return "bfk_csqrtf";
            case 486L: return "bfk_csqrtl";
            case 487L: return "bfk_ctan";
            case 488L: return "bfk_ctanf";
            case 489L: return "bfk_ctanh";
            case 490L: return "bfk_ctanhf";
            case 491L: return "bfk_ctanhl";
            case 492L: return "bfk_ctanl";
            case 493L: return "bfk_ctz";
            case 494L: return "bfk_ctzimax";
            case 495L: return "bfk_ctzl";
            case 496L: return "bfk_ctzll";
            case 497L: return "bfk_ctzs";
            case 498L: return "bfk_dcgettext";
            case 499L: return "bfk_debugtrap";
            case 500L: return "bfk_dgettext";
            case 501L: return "bfk_drem";
            case 502L: return "bfk_dremf";
            case 503L: return "bfk_dreml";
            case 504L: return "bfk_dump_struct";
            case 505L: return "bfk_dwarf_cfa";
            case 506L: return "bfk_dwarf_fp_regnum";
            case 507L: return "bfk_dwarf_sp_column";
            case 508L: return "bfk_dynamic_object_size";
            case 509L: return "bfk_eh_copy_values";
            case 510L: return "bfk_eh_filter";
            case 511L: return "bfk_eh_pointer";
            case 512L: return "bfk_eh_return";
            case 513L: return "bfk_eh_return_data_regno";
            case 514L: return "bfk_erf";
            case 515L: return "bfk_erfc";
            case 516L: return "bfk_erfcf";
            case 517L: return "bfk_erfcl";
            case 518L: return "bfk_erff";
            case 519L: return "bfk_erfl";
            case 520L: return "bfk_execl";
            case 521L: return "bfk_execle";
            case 522L: return "bfk_execlp";
            case 523L: return "bfk_execv";
            case 524L: return "bfk_execve";
            case 525L: return "bfk_execvp";
            case 526L: return "bfk_exit";
            case 527L: return "bfk_exp";
            case 528L: return "bfk_exp10";
            case 529L: return "bfk_exp10f";
            case 530L: return "bfk_exp10l";
            case 531L: return "bfk_exp2";
            case 532L: return "bfk_exp2f";
            case 533L: return "bfk_exp2l";
            case 534L: return "bfk_expect";
            case 535L: return "bfk_expect_with_probability";
            case 536L: return "bfk_expf";
            case 537L: return "bfk_expl";
            case 538L: return "bfk_expm1";
            case 539L: return "bfk_expm1f";
            case 540L: return "bfk_expm1l";
            case 541L: return "bfk_extend_pointer";
            case 542L: return "bfk_extract_return_addr";
            case 543L: return "bfk_fabs";
            case 544L: return "bfk_fabsf";
            case 545L: return "bfk_fabsf128";
            case 546L: return "bfk_fabsf32";
            case 547L: return "bfk_fabsf32x";
            case 548L: return "bfk_fabsf64";
            case 549L: return "bfk_fabsf64x";
            case 550L: return "bfk_fabsl";
            case 551L: return "bfk_fdim";
            case 552L: return "bfk_fdimf";
            case 553L: return "bfk_fdiml";
            case 554L: return "bfk_feclearexcept";
            case 555L: return "bfk_fegetenv";
            case 556L: return "bfk_fegetexceptflag";
            case 557L: return "bfk_fegetround";
            case 558L: return "bfk_feholdexcept";
            case 559L: return "bfk_feraiseexcept";
            case 560L: return "bfk_fesetenv";
            case 561L: return "bfk_fesetexceptflag";
            case 562L: return "bfk_fesetround";
            case 563L: return "bfk_fetestexcept";
            case 564L: return "bfk_feupdateenv";
            case 565L: return "bfk_ffs";
            case 566L: return "bfk_ffsimax";
            case 567L: return "bfk_ffsl";
            case 568L: return "bfk_ffsll";
            case 569L: return "bfk_finite";
            case 570L: return "bfk_finitef";
            case 571L: return "bfk_finitel";
            case 572L: return "bfk_floor";
            case 573L: return "bfk_floorf";
            case 574L: return "bfk_floorf32";
            case 575L: return "bfk_floorf32x";
            case 576L: return "bfk_floorf64";
            case 577L: return "bfk_floorf64x";
            case 578L: return "bfk_floorl";
            case 579L: return "bfk_flt_rounds";
            case 580L: return "bfk_fma";
            case 581L: return "bfk_fmaf";
            case 582L: return "bfk_fmaf32";
            case 583L: return "bfk_fmaf32x";
            case 584L: return "bfk_fmaf64";
            case 585L: return "bfk_fmaf64x";
            case 586L: return "bfk_fmal";
            case 587L: return "bfk_fmax";
            case 588L: return "bfk_fmaxf";
            case 589L: return "bfk_fmaxf32";
            case 590L: return "bfk_fmaxf32x";
            case 591L: return "bfk_fmaxf64";
            case 592L: return "bfk_fmaxf64x";
            case 593L: return "bfk_fmaxl";
            case 594L: return "bfk_fmin";
            case 595L: return "bfk_fminf";
            case 596L: return "bfk_fminf32";
            case 597L: return "bfk_fminf32x";
            case 598L: return "bfk_fminf64";
            case 599L: return "bfk_fminf64x";
            case 600L: return "bfk_fminl";
            case 601L: return "bfk_fmod";
            case 602L: return "bfk_fmodf";
            case 603L: return "bfk_fmodl";
            case 604L: return "bfk_fork";
            case 605L: return "bfk_fpclassify";
            case 606L: return "bfk_fprintf";
            case 607L: return "bfk_fprintf_unlocked";
            case 608L: return "bfk_fputc";
            case 609L: return "bfk_fputc_unlocked";
            case 610L: return "bfk_fputs";
            case 611L: return "bfk_fputs_unlocked";
            case 612L: return "bfk_frame_address";
            case 613L: return "bfk_free";
            case 614L: return "bfk_frexp";
            case 615L: return "bfk_frexpf";
            case 616L: return "bfk_frexpl";
            case 617L: return "bfk_frob_return_addr";
            case 618L: return "bfk_fscanf";
            case 619L: return "bfk_fwrite";
            case 620L: return "bfk_fwrite_unlocked";
            case 621L: return "bfk_gamma";
            case 622L: return "bfk_gamma_r";
            case 623L: return "bfk_gammaf";
            case 624L: return "bfk_gammaf_r";
            case 625L: return "bfk_gammal";
            case 626L: return "bfk_gammal_r";
            case 627L: return "bfk_gettext";
            case 628L: return "bfk_huge_val";
            case 629L: return "bfk_huge_valf";
            case 630L: return "bfk_huge_valf128";
            case 631L: return "bfk_huge_valf32";
            case 632L: return "bfk_huge_valf32x";
            case 633L: return "bfk_huge_valf64";
            case 634L: return "bfk_huge_valf64x";
            case 635L: return "bfk_huge_vall";
            case 636L: return "bfk_hypot";
            case 637L: return "bfk_hypotf";
            case 638L: return "bfk_hypotl";
            case 639L: return "bfk_ia32_4fmaddps";
            case 640L: return "bfk_ia32_4fmaddps_mask";
            case 641L: return "bfk_ia32_4fmaddss";
            case 642L: return "bfk_ia32_4fmaddss_mask";
            case 643L: return "bfk_ia32_4fnmaddps";
            case 644L: return "bfk_ia32_4fnmaddps_mask";
            case 645L: return "bfk_ia32_4fnmaddss";
            case 646L: return "bfk_ia32_4fnmaddss_mask";
            case 647L: return "bfk_ia32_addcarry_u32";
            case 648L: return "bfk_ia32_addcarry_u64";
            case 649L: return "bfk_ia32_addcarryx_u32";
            case 650L: return "bfk_ia32_addcarryx_u64";
            case 651L: return "bfk_ia32_addpd";
            case 652L: return "bfk_ia32_addpd128_mask";
            case 653L: return "bfk_ia32_addpd256";
            case 654L: return "bfk_ia32_addpd256_mask";
            case 655L: return "bfk_ia32_addpd512";
            case 656L: return "bfk_ia32_addpd512_mask";
            case 657L: return "bfk_ia32_addps";
            case 658L: return "bfk_ia32_addps128_mask";
            case 659L: return "bfk_ia32_addps256";
            case 660L: return "bfk_ia32_addps256_mask";
            case 661L: return "bfk_ia32_addps512";
            case 662L: return "bfk_ia32_addps512_mask";
            case 663L: return "bfk_ia32_addsd";
            case 664L: return "bfk_ia32_addsd_mask_round";
            case 665L: return "bfk_ia32_addsd_round";
            case 666L: return "bfk_ia32_addsd_round_mask";
            case 667L: return "bfk_ia32_addss";
            case 668L: return "bfk_ia32_addss_mask_round";
            case 669L: return "bfk_ia32_addss_round";
            case 670L: return "bfk_ia32_addss_round_mask";
            case 671L: return "bfk_ia32_addsubpd";
            case 672L: return "bfk_ia32_addsubpd256";
            case 673L: return "bfk_ia32_addsubps";
            case 674L: return "bfk_ia32_addsubps256";
            case 675L: return "bfk_ia32_aesdec128";
            case 676L: return "bfk_ia32_aesdec256";
            case 677L: return "bfk_ia32_aesdec512";
            case 678L: return "bfk_ia32_aesdeclast128";
            case 679L: return "bfk_ia32_aesdeclast256";
            case 680L: return "bfk_ia32_aesdeclast512";
            case 681L: return "bfk_ia32_aesenc128";
            case 682L: return "bfk_ia32_aesenc256";
            case 683L: return "bfk_ia32_aesenc512";
            case 684L: return "bfk_ia32_aesenclast128";
            case 685L: return "bfk_ia32_aesenclast256";
            case 686L: return "bfk_ia32_aesenclast512";
            case 687L: return "bfk_ia32_aesimc128";
            case 688L: return "bfk_ia32_aeskeygenassist128";
            case 689L: return "bfk_ia32_alignd128";
            case 690L: return "bfk_ia32_alignd128_mask";
            case 691L: return "bfk_ia32_alignd256";
            case 692L: return "bfk_ia32_alignd256_mask";
            case 693L: return "bfk_ia32_alignd512";
            case 694L: return "bfk_ia32_alignd512_mask";
            case 695L: return "bfk_ia32_alignq128";
            case 696L: return "bfk_ia32_alignq128_mask";
            case 697L: return "bfk_ia32_alignq256";
            case 698L: return "bfk_ia32_alignq256_mask";
            case 699L: return "bfk_ia32_alignq512";
            case 700L: return "bfk_ia32_alignq512_mask";
            case 701L: return "bfk_ia32_andnotsi256";
            case 702L: return "bfk_ia32_andnpd";
            case 703L: return "bfk_ia32_andnpd128_mask";
            case 704L: return "bfk_ia32_andnpd256";
            case 705L: return "bfk_ia32_andnpd256_mask";
            case 706L: return "bfk_ia32_andnpd512_mask";
            case 707L: return "bfk_ia32_andnps";
            case 708L: return "bfk_ia32_andnps128_mask";
            case 709L: return "bfk_ia32_andnps256";
            case 710L: return "bfk_ia32_andnps256_mask";
            case 711L: return "bfk_ia32_andnps512_mask";
            case 712L: return "bfk_ia32_andpd";
            case 713L: return "bfk_ia32_andpd128_mask";
            case 714L: return "bfk_ia32_andpd256";
            case 715L: return "bfk_ia32_andpd256_mask";
            case 716L: return "bfk_ia32_andpd512_mask";
            case 717L: return "bfk_ia32_andps";
            case 718L: return "bfk_ia32_andps128_mask";
            case 719L: return "bfk_ia32_andps256";
            case 720L: return "bfk_ia32_andps256_mask";
            case 721L: return "bfk_ia32_andps512_mask";
            case 722L: return "bfk_ia32_andsi256";
            case 723L: return "bfk_ia32_bextr_u32";
            case 724L: return "bfk_ia32_bextr_u64";
            case 725L: return "bfk_ia32_bextri_u32";
            case 726L: return "bfk_ia32_bextri_u64";
            case 727L: return "bfk_ia32_blendmb_128_mask";
            case 728L: return "bfk_ia32_blendmb_256_mask";
            case 729L: return "bfk_ia32_blendmb_512_mask";
            case 730L: return "bfk_ia32_blendmd_128_mask";
            case 731L: return "bfk_ia32_blendmd_256_mask";
            case 732L: return "bfk_ia32_blendmd_512_mask";
            case 733L: return "bfk_ia32_blendmpd_128_mask";
            case 734L: return "bfk_ia32_blendmpd_256_mask";
            case 735L: return "bfk_ia32_blendmpd_512_mask";
            case 736L: return "bfk_ia32_blendmps_128_mask";
            case 737L: return "bfk_ia32_blendmps_256_mask";
            case 738L: return "bfk_ia32_blendmps_512_mask";
            case 739L: return "bfk_ia32_blendmq_128_mask";
            case 740L: return "bfk_ia32_blendmq_256_mask";
            case 741L: return "bfk_ia32_blendmq_512_mask";
            case 742L: return "bfk_ia32_blendmw_128_mask";
            case 743L: return "bfk_ia32_blendmw_256_mask";
            case 744L: return "bfk_ia32_blendmw_512_mask";
            case 745L: return "bfk_ia32_blendpd";
            case 746L: return "bfk_ia32_blendpd256";
            case 747L: return "bfk_ia32_blendps";
            case 748L: return "bfk_ia32_blendps256";
            case 749L: return "bfk_ia32_blendvpd";
            case 750L: return "bfk_ia32_blendvpd256";
            case 751L: return "bfk_ia32_blendvps";
            case 752L: return "bfk_ia32_blendvps256";
            case 753L: return "bfk_ia32_broadcastf32x2_256_mask";
            case 754L: return "bfk_ia32_broadcastf32x2_512_mask";
            case 755L: return "bfk_ia32_broadcastf32x4_256_mask";
            case 756L: return "bfk_ia32_broadcastf32x4_512";
            case 757L: return "bfk_ia32_broadcastf32x8_512_mask";
            case 758L: return "bfk_ia32_broadcastf64x2_256_mask";
            case 759L: return "bfk_ia32_broadcastf64x2_512_mask";
            case 760L: return "bfk_ia32_broadcastf64x4_512";
            case 761L: return "bfk_ia32_broadcasti32x2_128_mask";
            case 762L: return "bfk_ia32_broadcasti32x2_256_mask";
            case 763L: return "bfk_ia32_broadcasti32x2_512_mask";
            case 764L: return "bfk_ia32_broadcasti32x4_256_mask";
            case 765L: return "bfk_ia32_broadcasti32x4_512";
            case 766L: return "bfk_ia32_broadcasti32x8_512_mask";
            case 767L: return "bfk_ia32_broadcasti64x2_256_mask";
            case 768L: return "bfk_ia32_broadcasti64x2_512_mask";
            case 769L: return "bfk_ia32_broadcasti64x4_512";
            case 770L: return "bfk_ia32_broadcastmb128";
            case 771L: return "bfk_ia32_broadcastmb256";
            case 772L: return "bfk_ia32_broadcastmb512";
            case 773L: return "bfk_ia32_broadcastmw128";
            case 774L: return "bfk_ia32_broadcastmw256";
            case 775L: return "bfk_ia32_broadcastmw512";
            case 776L: return "bfk_ia32_broadcastsd256_mask";
            case 777L: return "bfk_ia32_broadcastsd512";
            case 778L: return "bfk_ia32_broadcastss128_mask";
            case 779L: return "bfk_ia32_broadcastss256_mask";
            case 780L: return "bfk_ia32_broadcastss512";
            case 781L: return "bfk_ia32_bsrdi";
            case 782L: return "bfk_ia32_bsrsi";
            case 783L: return "bfk_ia32_bzhi_di";
            case 784L: return "bfk_ia32_bzhi_si";
            case 785L: return "bfk_ia32_ceilpd";
            case 786L: return "bfk_ia32_ceilpd256";
            case 787L: return "bfk_ia32_ceilpd512";
            case 788L: return "bfk_ia32_ceilpd_vec_pack_sfix";
            case 789L: return "bfk_ia32_ceilpd_vec_pack_sfix256";
            case 790L: return "bfk_ia32_ceilpd_vec_pack_sfix512";
            case 791L: return "bfk_ia32_ceilps";
            case 792L: return "bfk_ia32_ceilps256";
            case 793L: return "bfk_ia32_ceilps512";
            case 794L: return "bfk_ia32_ceilps_sfix";
            case 795L: return "bfk_ia32_ceilps_sfix256";
            case 796L: return "bfk_ia32_ceilps_sfix512";
            case 797L: return "bfk_ia32_cldemote";
            case 798L: return "bfk_ia32_clflush";
            case 799L: return "bfk_ia32_clflushopt";
            case 800L: return "bfk_ia32_clrssbsy";
            case 801L: return "bfk_ia32_clwb";
            case 802L: return "bfk_ia32_clzero";
            case 803L: return "bfk_ia32_cmpb128_mask";
            case 804L: return "bfk_ia32_cmpb256_mask";
            case 805L: return "bfk_ia32_cmpb512_mask";
            case 806L: return "bfk_ia32_cmpd128_mask";
            case 807L: return "bfk_ia32_cmpd256_mask";
            case 808L: return "bfk_ia32_cmpd512_mask";
            case 809L: return "bfk_ia32_cmpeqpd";
            case 810L: return "bfk_ia32_cmpeqps";
            case 811L: return "bfk_ia32_cmpeqsd";
            case 812L: return "bfk_ia32_cmpeqss";
            case 813L: return "bfk_ia32_cmpgepd";
            case 814L: return "bfk_ia32_cmpgeps";
            case 815L: return "bfk_ia32_cmpgtpd";
            case 816L: return "bfk_ia32_cmpgtps";
            case 817L: return "bfk_ia32_cmplepd";
            case 818L: return "bfk_ia32_cmpleps";
            case 819L: return "bfk_ia32_cmplesd";
            case 820L: return "bfk_ia32_cmpless";
            case 821L: return "bfk_ia32_cmpltpd";
            case 822L: return "bfk_ia32_cmpltps";
            case 823L: return "bfk_ia32_cmpltsd";
            case 824L: return "bfk_ia32_cmpltss";
            case 825L: return "bfk_ia32_cmpneqpd";
            case 826L: return "bfk_ia32_cmpneqps";
            case 827L: return "bfk_ia32_cmpneqsd";
            case 828L: return "bfk_ia32_cmpneqss";
            case 829L: return "bfk_ia32_cmpngepd";
            case 830L: return "bfk_ia32_cmpngeps";
            case 831L: return "bfk_ia32_cmpngess";
            case 832L: return "bfk_ia32_cmpngtpd";
            case 833L: return "bfk_ia32_cmpngtps";
            case 834L: return "bfk_ia32_cmpngtss";
            case 835L: return "bfk_ia32_cmpnlepd";
            case 836L: return "bfk_ia32_cmpnleps";
            case 837L: return "bfk_ia32_cmpnlesd";
            case 838L: return "bfk_ia32_cmpnless";
            case 839L: return "bfk_ia32_cmpnltpd";
            case 840L: return "bfk_ia32_cmpnltps";
            case 841L: return "bfk_ia32_cmpnltsd";
            case 842L: return "bfk_ia32_cmpnltss";
            case 843L: return "bfk_ia32_cmpordpd";
            case 844L: return "bfk_ia32_cmpordps";
            case 845L: return "bfk_ia32_cmpordsd";
            case 846L: return "bfk_ia32_cmpordss";
            case 847L: return "bfk_ia32_cmppd";
            case 848L: return "bfk_ia32_cmppd128_mask";
            case 849L: return "bfk_ia32_cmppd256";
            case 850L: return "bfk_ia32_cmppd256_mask";
            case 851L: return "bfk_ia32_cmppd512_mask";
            case 852L: return "bfk_ia32_cmpps";
            case 853L: return "bfk_ia32_cmpps128_mask";
            case 854L: return "bfk_ia32_cmpps256";
            case 855L: return "bfk_ia32_cmpps256_mask";
            case 856L: return "bfk_ia32_cmpps512_mask";
            case 857L: return "bfk_ia32_cmpq128_mask";
            case 858L: return "bfk_ia32_cmpq256_mask";
            case 859L: return "bfk_ia32_cmpq512_mask";
            case 860L: return "bfk_ia32_cmpsd";
            case 861L: return "bfk_ia32_cmpsd_mask";
            case 862L: return "bfk_ia32_cmpss";
            case 863L: return "bfk_ia32_cmpss_mask";
            case 864L: return "bfk_ia32_cmpunordpd";
            case 865L: return "bfk_ia32_cmpunordps";
            case 866L: return "bfk_ia32_cmpunordsd";
            case 867L: return "bfk_ia32_cmpunordss";
            case 868L: return "bfk_ia32_cmpw128_mask";
            case 869L: return "bfk_ia32_cmpw256_mask";
            case 870L: return "bfk_ia32_cmpw512_mask";
            case 871L: return "bfk_ia32_comeqpd";
            case 872L: return "bfk_ia32_comeqps";
            case 873L: return "bfk_ia32_comeqsd";
            case 874L: return "bfk_ia32_comeqss";
            case 875L: return "bfk_ia32_comfalsepd";
            case 876L: return "bfk_ia32_comfalseps";
            case 877L: return "bfk_ia32_comfalsesd";
            case 878L: return "bfk_ia32_comfalsess";
            case 879L: return "bfk_ia32_comgepd";
            case 880L: return "bfk_ia32_comgeps";
            case 881L: return "bfk_ia32_comgesd";
            case 882L: return "bfk_ia32_comgess";
            case 883L: return "bfk_ia32_comgtpd";
            case 884L: return "bfk_ia32_comgtps";
            case 885L: return "bfk_ia32_comgtsd";
            case 886L: return "bfk_ia32_comgtss";
            case 887L: return "bfk_ia32_comieq";
            case 888L: return "bfk_ia32_comige";
            case 889L: return "bfk_ia32_comigt";
            case 890L: return "bfk_ia32_comile";
            case 891L: return "bfk_ia32_comilt";
            case 892L: return "bfk_ia32_comineq";
            case 893L: return "bfk_ia32_comisdeq";
            case 894L: return "bfk_ia32_comisdge";
            case 895L: return "bfk_ia32_comisdgt";
            case 896L: return "bfk_ia32_comisdle";
            case 897L: return "bfk_ia32_comisdlt";
            case 898L: return "bfk_ia32_comisdneq";
            case 899L: return "bfk_ia32_comlepd";
            case 900L: return "bfk_ia32_comleps";
            case 901L: return "bfk_ia32_comlesd";
            case 902L: return "bfk_ia32_comless";
            case 903L: return "bfk_ia32_comltpd";
            case 904L: return "bfk_ia32_comltps";
            case 905L: return "bfk_ia32_comltsd";
            case 906L: return "bfk_ia32_comltss";
            case 907L: return "bfk_ia32_comnepd";
            case 908L: return "bfk_ia32_comneps";
            case 909L: return "bfk_ia32_comnesd";
            case 910L: return "bfk_ia32_comness";
            case 911L: return "bfk_ia32_comordpd";
            case 912L: return "bfk_ia32_comordps";
            case 913L: return "bfk_ia32_comordsd";
            case 914L: return "bfk_ia32_comordss";
            case 915L: return "bfk_ia32_compressdf128_mask";
            case 916L: return "bfk_ia32_compressdf256_mask";
            case 917L: return "bfk_ia32_compressdf512_mask";
            case 918L: return "bfk_ia32_compressdi128_mask";
            case 919L: return "bfk_ia32_compressdi256_mask";
            case 920L: return "bfk_ia32_compressdi512_mask";
            case 921L: return "bfk_ia32_compresshi128_mask";
            case 922L: return "bfk_ia32_compresshi256_mask";
            case 923L: return "bfk_ia32_compresshi512_mask";
            case 924L: return "bfk_ia32_compressqi128_mask";
            case 925L: return "bfk_ia32_compressqi256_mask";
            case 926L: return "bfk_ia32_compressqi512_mask";
            case 927L: return "bfk_ia32_compresssf128_mask";
            case 928L: return "bfk_ia32_compresssf256_mask";
            case 929L: return "bfk_ia32_compresssf512_mask";
            case 930L: return "bfk_ia32_compresssi128_mask";
            case 931L: return "bfk_ia32_compresssi256_mask";
            case 932L: return "bfk_ia32_compresssi512_mask";
            case 933L: return "bfk_ia32_compressstoredf128_mask";
            case 934L: return "bfk_ia32_compressstoredf256_mask";
            case 935L: return "bfk_ia32_compressstoredf512_mask";
            case 936L: return "bfk_ia32_compressstoredi128_mask";
            case 937L: return "bfk_ia32_compressstoredi256_mask";
            case 938L: return "bfk_ia32_compressstoredi512_mask";
            case 939L: return "bfk_ia32_compressstorehi128_mask";
            case 940L: return "bfk_ia32_compressstorehi256_mask";
            case 941L: return "bfk_ia32_compressstorehi512_mask";
            case 942L: return "bfk_ia32_compressstoreqi128_mask";
            case 943L: return "bfk_ia32_compressstoreqi256_mask";
            case 944L: return "bfk_ia32_compressstoreqi512_mask";
            case 945L: return "bfk_ia32_compressstoresf128_mask";
            case 946L: return "bfk_ia32_compressstoresf256_mask";
            case 947L: return "bfk_ia32_compressstoresf512_mask";
            case 948L: return "bfk_ia32_compressstoresi128_mask";
            case 949L: return "bfk_ia32_compressstoresi256_mask";
            case 950L: return "bfk_ia32_compressstoresi512_mask";
            case 951L: return "bfk_ia32_compressstoreuhi128_mask";
            case 952L: return "bfk_ia32_compressstoreuhi256_mask";
            case 953L: return "bfk_ia32_compressstoreuhi512_mask";
            case 954L: return "bfk_ia32_compressstoreuqi128_mask";
            case 955L: return "bfk_ia32_compressstoreuqi256_mask";
            case 956L: return "bfk_ia32_compressstoreuqi512_mask";
            case 957L: return "bfk_ia32_comtruepd";
            case 958L: return "bfk_ia32_comtrueps";
            case 959L: return "bfk_ia32_comtruesd";
            case 960L: return "bfk_ia32_comtruess";
            case 961L: return "bfk_ia32_comueqpd";
            case 962L: return "bfk_ia32_comueqps";
            case 963L: return "bfk_ia32_comueqsd";
            case 964L: return "bfk_ia32_comueqss";
            case 965L: return "bfk_ia32_comunepd";
            case 966L: return "bfk_ia32_comuneps";
            case 967L: return "bfk_ia32_comunesd";
            case 968L: return "bfk_ia32_comuness";
            case 969L: return "bfk_ia32_comunordpd";
            case 970L: return "bfk_ia32_comunordps";
            case 971L: return "bfk_ia32_comunordsd";
            case 972L: return "bfk_ia32_comunordss";
            case 973L: return "bfk_ia32_copysignpd";
            case 974L: return "bfk_ia32_copysignpd256";
            case 975L: return "bfk_ia32_copysignpd512";
            case 976L: return "bfk_ia32_copysignps";
            case 977L: return "bfk_ia32_copysignps256";
            case 978L: return "bfk_ia32_copysignps512";
            case 979L: return "bfk_ia32_crc32di";
            case 980L: return "bfk_ia32_crc32hi";
            case 981L: return "bfk_ia32_crc32qi";
            case 982L: return "bfk_ia32_crc32si";
            case 983L: return "bfk_ia32_cvtb2mask128";
            case 984L: return "bfk_ia32_cvtb2mask256";
            case 985L: return "bfk_ia32_cvtb2mask512";
            case 986L: return "bfk_ia32_cvtd2mask128";
            case 987L: return "bfk_ia32_cvtd2mask256";
            case 988L: return "bfk_ia32_cvtd2mask512";
            case 989L: return "bfk_ia32_cvtdq2pd";
            case 990L: return "bfk_ia32_cvtdq2pd128_mask";
            case 991L: return "bfk_ia32_cvtdq2pd256";
            case 992L: return "bfk_ia32_cvtdq2pd256_mask";
            case 993L: return "bfk_ia32_cvtdq2pd512_mask";
            case 994L: return "bfk_ia32_cvtdq2ps";
            case 995L: return "bfk_ia32_cvtdq2ps128_mask";
            case 996L: return "bfk_ia32_cvtdq2ps256";
            case 997L: return "bfk_ia32_cvtdq2ps256_mask";
            case 998L: return "bfk_ia32_cvtdq2ps512_mask";
            case 999L: return "bfk_ia32_cvtmask2b128";
            case 1000L: return "bfk_ia32_cvtmask2b256";
            case 1001L: return "bfk_ia32_cvtmask2b512";
            case 1002L: return "bfk_ia32_cvtmask2d128";
            case 1003L: return "bfk_ia32_cvtmask2d256";
            case 1004L: return "bfk_ia32_cvtmask2d512";
            case 1005L: return "bfk_ia32_cvtmask2q128";
            case 1006L: return "bfk_ia32_cvtmask2q256";
            case 1007L: return "bfk_ia32_cvtmask2q512";
            case 1008L: return "bfk_ia32_cvtmask2w128";
            case 1009L: return "bfk_ia32_cvtmask2w256";
            case 1010L: return "bfk_ia32_cvtmask2w512";
            case 1011L: return "bfk_ia32_cvtne2ps2bf16_128";
            case 1012L: return "bfk_ia32_cvtne2ps2bf16_256";
            case 1013L: return "bfk_ia32_cvtne2ps2bf16_512";
            case 1014L: return "bfk_ia32_cvtneps2bf16_128_mask";
            case 1015L: return "bfk_ia32_cvtneps2bf16_256_mask";
            case 1016L: return "bfk_ia32_cvtneps2bf16_512_mask";
            case 1017L: return "bfk_ia32_cvtpd2dq";
            case 1018L: return "bfk_ia32_cvtpd2dq128_mask";
            case 1019L: return "bfk_ia32_cvtpd2dq256";
            case 1020L: return "bfk_ia32_cvtpd2dq256_mask";
            case 1021L: return "bfk_ia32_cvtpd2dq512_mask";
            case 1022L: return "bfk_ia32_cvtpd2pi";
            case 1023L: return "bfk_ia32_cvtpd2ps";
            case 1024L: return "bfk_ia32_cvtpd2ps256";
            case 1025L: return "bfk_ia32_cvtpd2ps256_mask";
            case 1026L: return "bfk_ia32_cvtpd2ps512_mask";
            case 1027L: return "bfk_ia32_cvtpd2ps_mask";
            case 1028L: return "bfk_ia32_cvtpd2qq128_mask";
            case 1029L: return "bfk_ia32_cvtpd2qq256_mask";
            case 1030L: return "bfk_ia32_cvtpd2qq512_mask";
            case 1031L: return "bfk_ia32_cvtpd2udq128_mask";
            case 1032L: return "bfk_ia32_cvtpd2udq256_mask";
            case 1033L: return "bfk_ia32_cvtpd2udq512_mask";
            case 1034L: return "bfk_ia32_cvtpd2uqq128_mask";
            case 1035L: return "bfk_ia32_cvtpd2uqq256_mask";
            case 1036L: return "bfk_ia32_cvtpd2uqq512_mask";
            case 1037L: return "bfk_ia32_cvtpi2pd";
            case 1038L: return "bfk_ia32_cvtpi2ps";
            case 1039L: return "bfk_ia32_cvtps2dq";
            case 1040L: return "bfk_ia32_cvtps2dq128_mask";
            case 1041L: return "bfk_ia32_cvtps2dq256";
            case 1042L: return "bfk_ia32_cvtps2dq256_mask";
            case 1043L: return "bfk_ia32_cvtps2dq512";
            case 1044L: return "bfk_ia32_cvtps2dq512_mask";
            case 1045L: return "bfk_ia32_cvtps2pd";
            case 1046L: return "bfk_ia32_cvtps2pd128_mask";
            case 1047L: return "bfk_ia32_cvtps2pd256";
            case 1048L: return "bfk_ia32_cvtps2pd256_mask";
            case 1049L: return "bfk_ia32_cvtps2pd512_mask";
            case 1050L: return "bfk_ia32_cvtps2pi";
            case 1051L: return "bfk_ia32_cvtps2qq128_mask";
            case 1052L: return "bfk_ia32_cvtps2qq256_mask";
            case 1053L: return "bfk_ia32_cvtps2qq512_mask";
            case 1054L: return "bfk_ia32_cvtps2udq128_mask";
            case 1055L: return "bfk_ia32_cvtps2udq256_mask";
            case 1056L: return "bfk_ia32_cvtps2udq512_mask";
            case 1057L: return "bfk_ia32_cvtps2uqq128_mask";
            case 1058L: return "bfk_ia32_cvtps2uqq256_mask";
            case 1059L: return "bfk_ia32_cvtps2uqq512_mask";
            case 1060L: return "bfk_ia32_cvtq2mask128";
            case 1061L: return "bfk_ia32_cvtq2mask256";
            case 1062L: return "bfk_ia32_cvtq2mask512";
            case 1063L: return "bfk_ia32_cvtqq2pd128_mask";
            case 1064L: return "bfk_ia32_cvtqq2pd256_mask";
            case 1065L: return "bfk_ia32_cvtqq2pd512_mask";
            case 1066L: return "bfk_ia32_cvtqq2ps128_mask";
            case 1067L: return "bfk_ia32_cvtqq2ps256_mask";
            case 1068L: return "bfk_ia32_cvtqq2ps512_mask";
            case 1069L: return "bfk_ia32_cvtsbf162ss_32";
            case 1070L: return "bfk_ia32_cvtsd2si";
            case 1071L: return "bfk_ia32_cvtsd2si64";
            case 1072L: return "bfk_ia32_cvtsd2ss";
            case 1073L: return "bfk_ia32_cvtsd2ss_round";
            case 1074L: return "bfk_ia32_cvtsd2ss_round_mask";
            case 1075L: return "bfk_ia32_cvtsi2sd";
            case 1076L: return "bfk_ia32_cvtsi2sd64";
            case 1077L: return "bfk_ia32_cvtsi2ss";
            case 1078L: return "bfk_ia32_cvtsi2ss32";
            case 1079L: return "bfk_ia32_cvtsi2ss64";
            case 1080L: return "bfk_ia32_cvtsi642sd";
            case 1081L: return "bfk_ia32_cvtsi642ss";
            case 1082L: return "bfk_ia32_cvtss2sd";
            case 1083L: return "bfk_ia32_cvtss2sd_round";
            case 1084L: return "bfk_ia32_cvtss2sd_round_mask";
            case 1085L: return "bfk_ia32_cvtss2si";
            case 1086L: return "bfk_ia32_cvtss2si64";
            case 1087L: return "bfk_ia32_cvttpd2dq";
            case 1088L: return "bfk_ia32_cvttpd2dq128_mask";
            case 1089L: return "bfk_ia32_cvttpd2dq256";
            case 1090L: return "bfk_ia32_cvttpd2dq256_mask";
            case 1091L: return "bfk_ia32_cvttpd2dq512_mask";
            case 1092L: return "bfk_ia32_cvttpd2pi";
            case 1093L: return "bfk_ia32_cvttpd2qq128_mask";
            case 1094L: return "bfk_ia32_cvttpd2qq256_mask";
            case 1095L: return "bfk_ia32_cvttpd2qq512_mask";
            case 1096L: return "bfk_ia32_cvttpd2udq128_mask";
            case 1097L: return "bfk_ia32_cvttpd2udq256_mask";
            case 1098L: return "bfk_ia32_cvttpd2udq512_mask";
            case 1099L: return "bfk_ia32_cvttpd2uqq128_mask";
            case 1100L: return "bfk_ia32_cvttpd2uqq256_mask";
            case 1101L: return "bfk_ia32_cvttpd2uqq512_mask";
            case 1102L: return "bfk_ia32_cvttps2dq";
            case 1103L: return "bfk_ia32_cvttps2dq128_mask";
            case 1104L: return "bfk_ia32_cvttps2dq256";
            case 1105L: return "bfk_ia32_cvttps2dq256_mask";
            case 1106L: return "bfk_ia32_cvttps2dq512_mask";
            case 1107L: return "bfk_ia32_cvttps2pi";
            case 1108L: return "bfk_ia32_cvttps2qq128_mask";
            case 1109L: return "bfk_ia32_cvttps2qq256_mask";
            case 1110L: return "bfk_ia32_cvttps2qq512_mask";
            case 1111L: return "bfk_ia32_cvttps2udq128_mask";
            case 1112L: return "bfk_ia32_cvttps2udq256_mask";
            case 1113L: return "bfk_ia32_cvttps2udq512_mask";
            case 1114L: return "bfk_ia32_cvttps2uqq128_mask";
            case 1115L: return "bfk_ia32_cvttps2uqq256_mask";
            case 1116L: return "bfk_ia32_cvttps2uqq512_mask";
            case 1117L: return "bfk_ia32_cvttsd2si";
            case 1118L: return "bfk_ia32_cvttsd2si64";
            case 1119L: return "bfk_ia32_cvttss2si";
            case 1120L: return "bfk_ia32_cvttss2si64";
            case 1121L: return "bfk_ia32_cvtudq2pd128_mask";
            case 1122L: return "bfk_ia32_cvtudq2pd256_mask";
            case 1123L: return "bfk_ia32_cvtudq2pd512_mask";
            case 1124L: return "bfk_ia32_cvtudq2ps";
            case 1125L: return "bfk_ia32_cvtudq2ps128_mask";
            case 1126L: return "bfk_ia32_cvtudq2ps256_mask";
            case 1127L: return "bfk_ia32_cvtudq2ps512_mask";
            case 1128L: return "bfk_ia32_cvtuqq2pd128_mask";
            case 1129L: return "bfk_ia32_cvtuqq2pd256_mask";
            case 1130L: return "bfk_ia32_cvtuqq2pd512_mask";
            case 1131L: return "bfk_ia32_cvtuqq2ps128_mask";
            case 1132L: return "bfk_ia32_cvtuqq2ps256_mask";
            case 1133L: return "bfk_ia32_cvtuqq2ps512_mask";
            case 1134L: return "bfk_ia32_cvtusi2sd32";
            case 1135L: return "bfk_ia32_cvtusi2sd64";
            case 1136L: return "bfk_ia32_cvtusi2ss32";
            case 1137L: return "bfk_ia32_cvtusi2ss64";
            case 1138L: return "bfk_ia32_cvtw2mask128";
            case 1139L: return "bfk_ia32_cvtw2mask256";
            case 1140L: return "bfk_ia32_cvtw2mask512";
            case 1141L: return "bfk_ia32_dbpsadbw128";
            case 1142L: return "bfk_ia32_dbpsadbw128_mask";
            case 1143L: return "bfk_ia32_dbpsadbw256";
            case 1144L: return "bfk_ia32_dbpsadbw256_mask";
            case 1145L: return "bfk_ia32_dbpsadbw512";
            case 1146L: return "bfk_ia32_dbpsadbw512_mask";
            case 1147L: return "bfk_ia32_directstore_u32";
            case 1148L: return "bfk_ia32_directstore_u64";
            case 1149L: return "bfk_ia32_directstoreu_u32";
            case 1150L: return "bfk_ia32_directstoreu_u64";
            case 1151L: return "bfk_ia32_divpd";
            case 1152L: return "bfk_ia32_divpd256";
            case 1153L: return "bfk_ia32_divpd256_mask";
            case 1154L: return "bfk_ia32_divpd512";
            case 1155L: return "bfk_ia32_divpd512_mask";
            case 1156L: return "bfk_ia32_divpd_mask";
            case 1157L: return "bfk_ia32_divps";
            case 1158L: return "bfk_ia32_divps256";
            case 1159L: return "bfk_ia32_divps256_mask";
            case 1160L: return "bfk_ia32_divps512";
            case 1161L: return "bfk_ia32_divps512_mask";
            case 1162L: return "bfk_ia32_divps_mask";
            case 1163L: return "bfk_ia32_divsd";
            case 1164L: return "bfk_ia32_divsd_mask_round";
            case 1165L: return "bfk_ia32_divsd_round";
            case 1166L: return "bfk_ia32_divsd_round_mask";
            case 1167L: return "bfk_ia32_divss";
            case 1168L: return "bfk_ia32_divss_mask_round";
            case 1169L: return "bfk_ia32_divss_round";
            case 1170L: return "bfk_ia32_divss_round_mask";
            case 1171L: return "bfk_ia32_dpbf16ps_128";
            case 1172L: return "bfk_ia32_dpbf16ps_256";
            case 1173L: return "bfk_ia32_dpbf16ps_512";
            case 1174L: return "bfk_ia32_dppd";
            case 1175L: return "bfk_ia32_dpps";
            case 1176L: return "bfk_ia32_dpps256";
            case 1177L: return "bfk_ia32_emms";
            case 1178L: return "bfk_ia32_enqcmd";
            case 1179L: return "bfk_ia32_enqcmds";
            case 1180L: return "bfk_ia32_exp2pd_mask";
            case 1181L: return "bfk_ia32_exp2ps";
            case 1182L: return "bfk_ia32_exp2ps_mask";
            case 1183L: return "bfk_ia32_expanddf128_mask";
            case 1184L: return "bfk_ia32_expanddf128_maskz";
            case 1185L: return "bfk_ia32_expanddf256_mask";
            case 1186L: return "bfk_ia32_expanddf256_maskz";
            case 1187L: return "bfk_ia32_expanddf512_mask";
            case 1188L: return "bfk_ia32_expanddf512_maskz";
            case 1189L: return "bfk_ia32_expanddi128_mask";
            case 1190L: return "bfk_ia32_expanddi128_maskz";
            case 1191L: return "bfk_ia32_expanddi256_mask";
            case 1192L: return "bfk_ia32_expanddi256_maskz";
            case 1193L: return "bfk_ia32_expanddi512_mask";
            case 1194L: return "bfk_ia32_expanddi512_maskz";
            case 1195L: return "bfk_ia32_expandhi128_mask";
            case 1196L: return "bfk_ia32_expandhi128_maskz";
            case 1197L: return "bfk_ia32_expandhi256_mask";
            case 1198L: return "bfk_ia32_expandhi256_maskz";
            case 1199L: return "bfk_ia32_expandhi512_mask";
            case 1200L: return "bfk_ia32_expandhi512_maskz";
            case 1201L: return "bfk_ia32_expandloaddf128_mask";
            case 1202L: return "bfk_ia32_expandloaddf128_maskz";
            case 1203L: return "bfk_ia32_expandloaddf256_mask";
            case 1204L: return "bfk_ia32_expandloaddf256_maskz";
            case 1205L: return "bfk_ia32_expandloaddf512_mask";
            case 1206L: return "bfk_ia32_expandloaddf512_maskz";
            case 1207L: return "bfk_ia32_expandloaddi128_mask";
            case 1208L: return "bfk_ia32_expandloaddi128_maskz";
            case 1209L: return "bfk_ia32_expandloaddi256_mask";
            case 1210L: return "bfk_ia32_expandloaddi256_maskz";
            case 1211L: return "bfk_ia32_expandloaddi512_mask";
            case 1212L: return "bfk_ia32_expandloaddi512_maskz";
            case 1213L: return "bfk_ia32_expandloadhi128_mask";
            case 1214L: return "bfk_ia32_expandloadhi128_maskz";
            case 1215L: return "bfk_ia32_expandloadhi256_mask";
            case 1216L: return "bfk_ia32_expandloadhi256_maskz";
            case 1217L: return "bfk_ia32_expandloadhi512_mask";
            case 1218L: return "bfk_ia32_expandloadhi512_maskz";
            case 1219L: return "bfk_ia32_expandloadqi128_mask";
            case 1220L: return "bfk_ia32_expandloadqi128_maskz";
            case 1221L: return "bfk_ia32_expandloadqi256_mask";
            case 1222L: return "bfk_ia32_expandloadqi256_maskz";
            case 1223L: return "bfk_ia32_expandloadqi512_mask";
            case 1224L: return "bfk_ia32_expandloadqi512_maskz";
            case 1225L: return "bfk_ia32_expandloadsf128_mask";
            case 1226L: return "bfk_ia32_expandloadsf128_maskz";
            case 1227L: return "bfk_ia32_expandloadsf256_mask";
            case 1228L: return "bfk_ia32_expandloadsf256_maskz";
            case 1229L: return "bfk_ia32_expandloadsf512_mask";
            case 1230L: return "bfk_ia32_expandloadsf512_maskz";
            case 1231L: return "bfk_ia32_expandloadsi128_mask";
            case 1232L: return "bfk_ia32_expandloadsi128_maskz";
            case 1233L: return "bfk_ia32_expandloadsi256_mask";
            case 1234L: return "bfk_ia32_expandloadsi256_maskz";
            case 1235L: return "bfk_ia32_expandloadsi512_mask";
            case 1236L: return "bfk_ia32_expandloadsi512_maskz";
            case 1237L: return "bfk_ia32_expandqi128_mask";
            case 1238L: return "bfk_ia32_expandqi128_maskz";
            case 1239L: return "bfk_ia32_expandqi256_mask";
            case 1240L: return "bfk_ia32_expandqi256_maskz";
            case 1241L: return "bfk_ia32_expandqi512_mask";
            case 1242L: return "bfk_ia32_expandqi512_maskz";
            case 1243L: return "bfk_ia32_expandsf128_mask";
            case 1244L: return "bfk_ia32_expandsf128_maskz";
            case 1245L: return "bfk_ia32_expandsf256_mask";
            case 1246L: return "bfk_ia32_expandsf256_maskz";
            case 1247L: return "bfk_ia32_expandsf512_mask";
            case 1248L: return "bfk_ia32_expandsf512_maskz";
            case 1249L: return "bfk_ia32_expandsi128_mask";
            case 1250L: return "bfk_ia32_expandsi128_maskz";
            case 1251L: return "bfk_ia32_expandsi256_mask";
            case 1252L: return "bfk_ia32_expandsi256_maskz";
            case 1253L: return "bfk_ia32_expandsi512_mask";
            case 1254L: return "bfk_ia32_expandsi512_maskz";
            case 1255L: return "bfk_ia32_extract128i256";
            case 1256L: return "bfk_ia32_extractf32x4_256_mask";
            case 1257L: return "bfk_ia32_extractf32x4_mask";
            case 1258L: return "bfk_ia32_extractf32x8_mask";
            case 1259L: return "bfk_ia32_extractf64x2_256_mask";
            case 1260L: return "bfk_ia32_extractf64x2_512_mask";
            case 1261L: return "bfk_ia32_extractf64x4_mask";
            case 1262L: return "bfk_ia32_extracti32x4_256_mask";
            case 1263L: return "bfk_ia32_extracti32x4_mask";
            case 1264L: return "bfk_ia32_extracti32x8_mask";
            case 1265L: return "bfk_ia32_extracti64x2_256_mask";
            case 1266L: return "bfk_ia32_extracti64x2_512_mask";
            case 1267L: return "bfk_ia32_extracti64x4_mask";
            case 1268L: return "bfk_ia32_extrq";
            case 1269L: return "bfk_ia32_extrqi";
            case 1270L: return "bfk_ia32_femms";
            case 1271L: return "bfk_ia32_fixupimmpd128_mask";
            case 1272L: return "bfk_ia32_fixupimmpd128_maskz";
            case 1273L: return "bfk_ia32_fixupimmpd256_mask";
            case 1274L: return "bfk_ia32_fixupimmpd256_maskz";
            case 1275L: return "bfk_ia32_fixupimmpd512_mask";
            case 1276L: return "bfk_ia32_fixupimmpd512_maskz";
            case 1277L: return "bfk_ia32_fixupimmps128_mask";
            case 1278L: return "bfk_ia32_fixupimmps128_maskz";
            case 1279L: return "bfk_ia32_fixupimmps256_mask";
            case 1280L: return "bfk_ia32_fixupimmps256_maskz";
            case 1281L: return "bfk_ia32_fixupimmps512_mask";
            case 1282L: return "bfk_ia32_fixupimmps512_maskz";
            case 1283L: return "bfk_ia32_fixupimmsd_mask";
            case 1284L: return "bfk_ia32_fixupimmsd_maskz";
            case 1285L: return "bfk_ia32_fixupimmss_mask";
            case 1286L: return "bfk_ia32_fixupimmss_maskz";
            case 1287L: return "bfk_ia32_fldenv";
            case 1288L: return "bfk_ia32_floorpd";
            case 1289L: return "bfk_ia32_floorpd256";
            case 1290L: return "bfk_ia32_floorpd512";
            case 1291L: return "bfk_ia32_floorpd_vec_pack_sfix";
            case 1292L: return "bfk_ia32_floorpd_vec_pack_sfix256";
            case 1293L: return "bfk_ia32_floorpd_vec_pack_sfix512";
            case 1294L: return "bfk_ia32_floorps";
            case 1295L: return "bfk_ia32_floorps256";
            case 1296L: return "bfk_ia32_floorps512";
            case 1297L: return "bfk_ia32_floorps_sfix";
            case 1298L: return "bfk_ia32_floorps_sfix256";
            case 1299L: return "bfk_ia32_floorps_sfix512";
            case 1300L: return "bfk_ia32_fmaddpd";
            case 1301L: return "bfk_ia32_fmaddps";
            case 1302L: return "bfk_ia32_fmaddsd";
            case 1303L: return "bfk_ia32_fmaddss";
            case 1304L: return "bfk_ia32_fmsubpd";
            case 1305L: return "bfk_ia32_fmsubps";
            case 1306L: return "bfk_ia32_fmsubsd";
            case 1307L: return "bfk_ia32_fmsubss";
            case 1308L: return "bfk_ia32_fnclex";
            case 1309L: return "bfk_ia32_fnmaddpd";
            case 1310L: return "bfk_ia32_fnmaddps";
            case 1311L: return "bfk_ia32_fnmaddsd";
            case 1312L: return "bfk_ia32_fnmaddss";
            case 1313L: return "bfk_ia32_fnmsubpd";
            case 1314L: return "bfk_ia32_fnmsubps";
            case 1315L: return "bfk_ia32_fnmsubsd";
            case 1316L: return "bfk_ia32_fnmsubss";
            case 1317L: return "bfk_ia32_fnstenv";
            case 1318L: return "bfk_ia32_fnstsw";
            case 1319L: return "bfk_ia32_fpclasspd128_mask";
            case 1320L: return "bfk_ia32_fpclasspd256_mask";
            case 1321L: return "bfk_ia32_fpclasspd512_mask";
            case 1322L: return "bfk_ia32_fpclassps128_mask";
            case 1323L: return "bfk_ia32_fpclassps256_mask";
            case 1324L: return "bfk_ia32_fpclassps512_mask";
            case 1325L: return "bfk_ia32_fpclasssd";
            case 1326L: return "bfk_ia32_fpclasssd_mask";
            case 1327L: return "bfk_ia32_fpclassss";
            case 1328L: return "bfk_ia32_fpclassss_mask";
            case 1329L: return "bfk_ia32_frczpd";
            case 1330L: return "bfk_ia32_frczps";
            case 1331L: return "bfk_ia32_frczsd";
            case 1332L: return "bfk_ia32_frczss";
            case 1333L: return "bfk_ia32_fxrstor";
            case 1334L: return "bfk_ia32_fxrstor64";
            case 1335L: return "bfk_ia32_fxsave";
            case 1336L: return "bfk_ia32_fxsave64";
            case 1337L: return "bfk_ia32_gather3altdiv16sf";
            case 1338L: return "bfk_ia32_gather3altdiv16si";
            case 1339L: return "bfk_ia32_gather3altdiv8sf";
            case 1340L: return "bfk_ia32_gather3altdiv8si";
            case 1341L: return "bfk_ia32_gather3altsiv4df";
            case 1342L: return "bfk_ia32_gather3altsiv4di";
            case 1343L: return "bfk_ia32_gather3altsiv8df";
            case 1344L: return "bfk_ia32_gather3altsiv8di";
            case 1345L: return "bfk_ia32_gather3div2df";
            case 1346L: return "bfk_ia32_gather3div2di";
            case 1347L: return "bfk_ia32_gather3div4df";
            case 1348L: return "bfk_ia32_gather3div4di";
            case 1349L: return "bfk_ia32_gather3div4sf";
            case 1350L: return "bfk_ia32_gather3div4si";
            case 1351L: return "bfk_ia32_gather3div8sf";
            case 1352L: return "bfk_ia32_gather3div8si";
            case 1353L: return "bfk_ia32_gather3siv2df";
            case 1354L: return "bfk_ia32_gather3siv2di";
            case 1355L: return "bfk_ia32_gather3siv4df";
            case 1356L: return "bfk_ia32_gather3siv4di";
            case 1357L: return "bfk_ia32_gather3siv4sf";
            case 1358L: return "bfk_ia32_gather3siv4si";
            case 1359L: return "bfk_ia32_gather3siv8sf";
            case 1360L: return "bfk_ia32_gather3siv8si";
            case 1361L: return "bfk_ia32_gatheraltdiv4sf256";
            case 1362L: return "bfk_ia32_gatheraltdiv4si256";
            case 1363L: return "bfk_ia32_gatheraltdiv8sf";
            case 1364L: return "bfk_ia32_gatheraltdiv8si";
            case 1365L: return "bfk_ia32_gatheraltsiv4df";
            case 1366L: return "bfk_ia32_gatheraltsiv4di";
            case 1367L: return "bfk_ia32_gatheraltsiv8df";
            case 1368L: return "bfk_ia32_gatheraltsiv8di";
            case 1369L: return "bfk_ia32_gatherd_d";
            case 1370L: return "bfk_ia32_gatherd_d256";
            case 1371L: return "bfk_ia32_gatherd_pd";
            case 1372L: return "bfk_ia32_gatherd_pd256";
            case 1373L: return "bfk_ia32_gatherd_ps";
            case 1374L: return "bfk_ia32_gatherd_ps256";
            case 1375L: return "bfk_ia32_gatherd_q";
            case 1376L: return "bfk_ia32_gatherd_q256";
            case 1377L: return "bfk_ia32_gatherdiv16sf";
            case 1378L: return "bfk_ia32_gatherdiv16si";
            case 1379L: return "bfk_ia32_gatherdiv2df";
            case 1380L: return "bfk_ia32_gatherdiv2di";
            case 1381L: return "bfk_ia32_gatherdiv4df";
            case 1382L: return "bfk_ia32_gatherdiv4di";
            case 1383L: return "bfk_ia32_gatherdiv4sf";
            case 1384L: return "bfk_ia32_gatherdiv4sf256";
            case 1385L: return "bfk_ia32_gatherdiv4si";
            case 1386L: return "bfk_ia32_gatherdiv4si256";
            case 1387L: return "bfk_ia32_gatherdiv8df";
            case 1388L: return "bfk_ia32_gatherdiv8di";
            case 1389L: return "bfk_ia32_gatherpfdpd";
            case 1390L: return "bfk_ia32_gatherpfdps";
            case 1391L: return "bfk_ia32_gatherpfqpd";
            case 1392L: return "bfk_ia32_gatherpfqps";
            case 1393L: return "bfk_ia32_gatherq_d";
            case 1394L: return "bfk_ia32_gatherq_d256";
            case 1395L: return "bfk_ia32_gatherq_pd";
            case 1396L: return "bfk_ia32_gatherq_pd256";
            case 1397L: return "bfk_ia32_gatherq_ps";
            case 1398L: return "bfk_ia32_gatherq_ps256";
            case 1399L: return "bfk_ia32_gatherq_q";
            case 1400L: return "bfk_ia32_gatherq_q256";
            case 1401L: return "bfk_ia32_gathersiv16sf";
            case 1402L: return "bfk_ia32_gathersiv16si";
            case 1403L: return "bfk_ia32_gathersiv2df";
            case 1404L: return "bfk_ia32_gathersiv2di";
            case 1405L: return "bfk_ia32_gathersiv4df";
            case 1406L: return "bfk_ia32_gathersiv4di";
            case 1407L: return "bfk_ia32_gathersiv4sf";
            case 1408L: return "bfk_ia32_gathersiv4si";
            case 1409L: return "bfk_ia32_gathersiv8df";
            case 1410L: return "bfk_ia32_gathersiv8di";
            case 1411L: return "bfk_ia32_gathersiv8sf";
            case 1412L: return "bfk_ia32_gathersiv8si";
            case 1413L: return "bfk_ia32_getexppd128_mask";
            case 1414L: return "bfk_ia32_getexppd256_mask";
            case 1415L: return "bfk_ia32_getexppd512_mask";
            case 1416L: return "bfk_ia32_getexpps128_mask";
            case 1417L: return "bfk_ia32_getexpps256_mask";
            case 1418L: return "bfk_ia32_getexpps512_mask";
            case 1419L: return "bfk_ia32_getexpsd128_round";
            case 1420L: return "bfk_ia32_getexpsd128_round_mask";
            case 1421L: return "bfk_ia32_getexpsd_mask_round";
            case 1422L: return "bfk_ia32_getexpss128_round";
            case 1423L: return "bfk_ia32_getexpss128_round_mask";
            case 1424L: return "bfk_ia32_getexpss_mask_round";
            case 1425L: return "bfk_ia32_getmantpd128_mask";
            case 1426L: return "bfk_ia32_getmantpd256_mask";
            case 1427L: return "bfk_ia32_getmantpd512_mask";
            case 1428L: return "bfk_ia32_getmantps128_mask";
            case 1429L: return "bfk_ia32_getmantps256_mask";
            case 1430L: return "bfk_ia32_getmantps512_mask";
            case 1431L: return "bfk_ia32_getmantsd_mask_round";
            case 1432L: return "bfk_ia32_getmantsd_round";
            case 1433L: return "bfk_ia32_getmantsd_round_mask";
            case 1434L: return "bfk_ia32_getmantss_mask_round";
            case 1435L: return "bfk_ia32_getmantss_round";
            case 1436L: return "bfk_ia32_getmantss_round_mask";
            case 1437L: return "bfk_ia32_haddpd";
            case 1438L: return "bfk_ia32_haddpd256";
            case 1439L: return "bfk_ia32_haddps";
            case 1440L: return "bfk_ia32_haddps256";
            case 1441L: return "bfk_ia32_hsubpd";
            case 1442L: return "bfk_ia32_hsubpd256";
            case 1443L: return "bfk_ia32_hsubps";
            case 1444L: return "bfk_ia32_hsubps256";
            case 1445L: return "bfk_ia32_incsspd";
            case 1446L: return "bfk_ia32_incsspq";
            case 1447L: return "bfk_ia32_insert128i256";
            case 1448L: return "bfk_ia32_insertf32x4";
            case 1449L: return "bfk_ia32_insertf32x4_256";
            case 1450L: return "bfk_ia32_insertf32x4_256_mask";
            case 1451L: return "bfk_ia32_insertf32x4_mask";
            case 1452L: return "bfk_ia32_insertf32x8";
            case 1453L: return "bfk_ia32_insertf32x8_mask";
            case 1454L: return "bfk_ia32_insertf64x2_256";
            case 1455L: return "bfk_ia32_insertf64x2_256_mask";
            case 1456L: return "bfk_ia32_insertf64x2_512";
            case 1457L: return "bfk_ia32_insertf64x2_512_mask";
            case 1458L: return "bfk_ia32_insertf64x4";
            case 1459L: return "bfk_ia32_insertf64x4_mask";
            case 1460L: return "bfk_ia32_inserti32x4";
            case 1461L: return "bfk_ia32_inserti32x4_256";
            case 1462L: return "bfk_ia32_inserti32x4_256_mask";
            case 1463L: return "bfk_ia32_inserti32x4_mask";
            case 1464L: return "bfk_ia32_inserti32x8";
            case 1465L: return "bfk_ia32_inserti32x8_mask";
            case 1466L: return "bfk_ia32_inserti64x2_256";
            case 1467L: return "bfk_ia32_inserti64x2_256_mask";
            case 1468L: return "bfk_ia32_inserti64x2_512";
            case 1469L: return "bfk_ia32_inserti64x2_512_mask";
            case 1470L: return "bfk_ia32_inserti64x4";
            case 1471L: return "bfk_ia32_inserti64x4_mask";
            case 1472L: return "bfk_ia32_insertps128";
            case 1473L: return "bfk_ia32_insertq";
            case 1474L: return "bfk_ia32_insertqi";
            case 1475L: return "bfk_ia32_invpcid";
            case 1476L: return "bfk_ia32_kadddi";
            case 1477L: return "bfk_ia32_kaddhi";
            case 1478L: return "bfk_ia32_kaddqi";
            case 1479L: return "bfk_ia32_kaddsi";
            case 1480L: return "bfk_ia32_kanddi";
            case 1481L: return "bfk_ia32_kandhi";
            case 1482L: return "bfk_ia32_kandndi";
            case 1483L: return "bfk_ia32_kandnhi";
            case 1484L: return "bfk_ia32_kandnqi";
            case 1485L: return "bfk_ia32_kandnsi";
            case 1486L: return "bfk_ia32_kandqi";
            case 1487L: return "bfk_ia32_kandsi";
            case 1488L: return "bfk_ia32_kmov16";
            case 1489L: return "bfk_ia32_kmovb";
            case 1490L: return "bfk_ia32_kmovd";
            case 1491L: return "bfk_ia32_kmovq";
            case 1492L: return "bfk_ia32_kmovw";
            case 1493L: return "bfk_ia32_knotdi";
            case 1494L: return "bfk_ia32_knothi";
            case 1495L: return "bfk_ia32_knotqi";
            case 1496L: return "bfk_ia32_knotsi";
            case 1497L: return "bfk_ia32_kordi";
            case 1498L: return "bfk_ia32_korhi";
            case 1499L: return "bfk_ia32_korqi";
            case 1500L: return "bfk_ia32_korsi";
            case 1501L: return "bfk_ia32_kortestcdi";
            case 1502L: return "bfk_ia32_kortestchi";
            case 1503L: return "bfk_ia32_kortestcqi";
            case 1504L: return "bfk_ia32_kortestcsi";
            case 1505L: return "bfk_ia32_kortestzdi";
            case 1506L: return "bfk_ia32_kortestzhi";
            case 1507L: return "bfk_ia32_kortestzqi";
            case 1508L: return "bfk_ia32_kortestzsi";
            case 1509L: return "bfk_ia32_kshiftlidi";
            case 1510L: return "bfk_ia32_kshiftlihi";
            case 1511L: return "bfk_ia32_kshiftliqi";
            case 1512L: return "bfk_ia32_kshiftlisi";
            case 1513L: return "bfk_ia32_kshiftridi";
            case 1514L: return "bfk_ia32_kshiftrihi";
            case 1515L: return "bfk_ia32_kshiftriqi";
            case 1516L: return "bfk_ia32_kshiftrisi";
            case 1517L: return "bfk_ia32_ktestcdi";
            case 1518L: return "bfk_ia32_ktestchi";
            case 1519L: return "bfk_ia32_ktestcqi";
            case 1520L: return "bfk_ia32_ktestcsi";
            case 1521L: return "bfk_ia32_ktestzdi";
            case 1522L: return "bfk_ia32_ktestzhi";
            case 1523L: return "bfk_ia32_ktestzqi";
            case 1524L: return "bfk_ia32_ktestzsi";
            case 1525L: return "bfk_ia32_kunpckdi";
            case 1526L: return "bfk_ia32_kunpckhi";
            case 1527L: return "bfk_ia32_kunpcksi";
            case 1528L: return "bfk_ia32_kxnordi";
            case 1529L: return "bfk_ia32_kxnorhi";
            case 1530L: return "bfk_ia32_kxnorqi";
            case 1531L: return "bfk_ia32_kxnorsi";
            case 1532L: return "bfk_ia32_kxordi";
            case 1533L: return "bfk_ia32_kxorhi";
            case 1534L: return "bfk_ia32_kxorqi";
            case 1535L: return "bfk_ia32_kxorsi";
            case 1536L: return "bfk_ia32_lddqu";
            case 1537L: return "bfk_ia32_lddqu256";
            case 1538L: return "bfk_ia32_ldmxcsr";
            case 1539L: return "bfk_ia32_lfence";
            case 1540L: return "bfk_ia32_llwpcb";
            case 1541L: return "bfk_ia32_loadapd128_mask";
            case 1542L: return "bfk_ia32_loadapd256_mask";
            case 1543L: return "bfk_ia32_loadapd512_mask";
            case 1544L: return "bfk_ia32_loadaps";
            case 1545L: return "bfk_ia32_loadaps128_mask";
            case 1546L: return "bfk_ia32_loadaps256_mask";
            case 1547L: return "bfk_ia32_loadaps512_mask";
            case 1548L: return "bfk_ia32_loadddup";
            case 1549L: return "bfk_ia32_loaddqu";
            case 1550L: return "bfk_ia32_loaddqu256";
            case 1551L: return "bfk_ia32_loaddqudi128_mask";
            case 1552L: return "bfk_ia32_loaddqudi256_mask";
            case 1553L: return "bfk_ia32_loaddqudi512_mask";
            case 1554L: return "bfk_ia32_loaddquhi128_mask";
            case 1555L: return "bfk_ia32_loaddquhi256_mask";
            case 1556L: return "bfk_ia32_loaddquhi512_mask";
            case 1557L: return "bfk_ia32_loaddquqi128_mask";
            case 1558L: return "bfk_ia32_loaddquqi256_mask";
            case 1559L: return "bfk_ia32_loaddquqi512_mask";
            case 1560L: return "bfk_ia32_loaddqusi128_mask";
            case 1561L: return "bfk_ia32_loaddqusi256_mask";
            case 1562L: return "bfk_ia32_loaddqusi512_mask";
            case 1563L: return "bfk_ia32_loadhpd";
            case 1564L: return "bfk_ia32_loadhps";
            case 1565L: return "bfk_ia32_loadlpd";
            case 1566L: return "bfk_ia32_loadlps";
            case 1567L: return "bfk_ia32_loadsd128_mask";
            case 1568L: return "bfk_ia32_loadsd_mask";
            case 1569L: return "bfk_ia32_loadss";
            case 1570L: return "bfk_ia32_loadss128_mask";
            case 1571L: return "bfk_ia32_loadss_mask";
            case 1572L: return "bfk_ia32_loadupd";
            case 1573L: return "bfk_ia32_loadupd128_mask";
            case 1574L: return "bfk_ia32_loadupd256";
            case 1575L: return "bfk_ia32_loadupd256_mask";
            case 1576L: return "bfk_ia32_loadupd512_mask";
            case 1577L: return "bfk_ia32_loadups";
            case 1578L: return "bfk_ia32_loadups128_mask";
            case 1579L: return "bfk_ia32_loadups256";
            case 1580L: return "bfk_ia32_loadups256_mask";
            case 1581L: return "bfk_ia32_loadups512_mask";
            case 1582L: return "bfk_ia32_lwpins32";
            case 1583L: return "bfk_ia32_lwpins64";
            case 1584L: return "bfk_ia32_lwpval32";
            case 1585L: return "bfk_ia32_lwpval64";
            case 1586L: return "bfk_ia32_lzcnt_u16";
            case 1587L: return "bfk_ia32_lzcnt_u32";
            case 1588L: return "bfk_ia32_lzcnt_u64";
            case 1589L: return "bfk_ia32_maskloadd";
            case 1590L: return "bfk_ia32_maskloadd256";
            case 1591L: return "bfk_ia32_maskloadpd";
            case 1592L: return "bfk_ia32_maskloadpd256";
            case 1593L: return "bfk_ia32_maskloadps";
            case 1594L: return "bfk_ia32_maskloadps256";
            case 1595L: return "bfk_ia32_maskloadq";
            case 1596L: return "bfk_ia32_maskloadq256";
            case 1597L: return "bfk_ia32_maskmovdqu";
            case 1598L: return "bfk_ia32_maskmovq";
            case 1599L: return "bfk_ia32_maskstored";
            case 1600L: return "bfk_ia32_maskstored256";
            case 1601L: return "bfk_ia32_maskstorepd";
            case 1602L: return "bfk_ia32_maskstorepd256";
            case 1603L: return "bfk_ia32_maskstoreps";
            case 1604L: return "bfk_ia32_maskstoreps256";
            case 1605L: return "bfk_ia32_maskstoreq";
            case 1606L: return "bfk_ia32_maskstoreq256";
            case 1607L: return "bfk_ia32_maxpd";
            case 1608L: return "bfk_ia32_maxpd256";
            case 1609L: return "bfk_ia32_maxpd256_mask";
            case 1610L: return "bfk_ia32_maxpd512";
            case 1611L: return "bfk_ia32_maxpd512_mask";
            case 1612L: return "bfk_ia32_maxpd_mask";
            case 1613L: return "bfk_ia32_maxps";
            case 1614L: return "bfk_ia32_maxps256";
            case 1615L: return "bfk_ia32_maxps256_mask";
            case 1616L: return "bfk_ia32_maxps512";
            case 1617L: return "bfk_ia32_maxps512_mask";
            case 1618L: return "bfk_ia32_maxps_mask";
            case 1619L: return "bfk_ia32_maxsd";
            case 1620L: return "bfk_ia32_maxsd_mask_round";
            case 1621L: return "bfk_ia32_maxsd_round";
            case 1622L: return "bfk_ia32_maxsd_round_mask";
            case 1623L: return "bfk_ia32_maxss";
            case 1624L: return "bfk_ia32_maxss_mask_round";
            case 1625L: return "bfk_ia32_maxss_round";
            case 1626L: return "bfk_ia32_maxss_round_mask";
            case 1627L: return "bfk_ia32_mfence";
            case 1628L: return "bfk_ia32_minpd";
            case 1629L: return "bfk_ia32_minpd256";
            case 1630L: return "bfk_ia32_minpd256_mask";
            case 1631L: return "bfk_ia32_minpd512";
            case 1632L: return "bfk_ia32_minpd512_mask";
            case 1633L: return "bfk_ia32_minpd_mask";
            case 1634L: return "bfk_ia32_minps";
            case 1635L: return "bfk_ia32_minps256";
            case 1636L: return "bfk_ia32_minps256_mask";
            case 1637L: return "bfk_ia32_minps512";
            case 1638L: return "bfk_ia32_minps512_mask";
            case 1639L: return "bfk_ia32_minps_mask";
            case 1640L: return "bfk_ia32_minsd";
            case 1641L: return "bfk_ia32_minsd_mask_round";
            case 1642L: return "bfk_ia32_minsd_round";
            case 1643L: return "bfk_ia32_minsd_round_mask";
            case 1644L: return "bfk_ia32_minss";
            case 1645L: return "bfk_ia32_minss_mask_round";
            case 1646L: return "bfk_ia32_minss_round";
            case 1647L: return "bfk_ia32_minss_round_mask";
            case 1648L: return "bfk_ia32_monitor";
            case 1649L: return "bfk_ia32_monitorx";
            case 1650L: return "bfk_ia32_movapd128_mask";
            case 1651L: return "bfk_ia32_movapd256_mask";
            case 1652L: return "bfk_ia32_movapd512_mask";
            case 1653L: return "bfk_ia32_movaps128_mask";
            case 1654L: return "bfk_ia32_movaps256_mask";
            case 1655L: return "bfk_ia32_movaps512_mask";
            case 1656L: return "bfk_ia32_movddup";
            case 1657L: return "bfk_ia32_movddup128_mask";
            case 1658L: return "bfk_ia32_movddup256";
            case 1659L: return "bfk_ia32_movddup256_mask";
            case 1660L: return "bfk_ia32_movddup512_mask";
            case 1661L: return "bfk_ia32_movdir64b";
            case 1662L: return "bfk_ia32_movdqa32_128_mask";
            case 1663L: return "bfk_ia32_movdqa32_256_mask";
            case 1664L: return "bfk_ia32_movdqa32_512_mask";
            case 1665L: return "bfk_ia32_movdqa32load128_mask";
            case 1666L: return "bfk_ia32_movdqa32load256_mask";
            case 1667L: return "bfk_ia32_movdqa32load512_mask";
            case 1668L: return "bfk_ia32_movdqa32store128_mask";
            case 1669L: return "bfk_ia32_movdqa32store256_mask";
            case 1670L: return "bfk_ia32_movdqa32store512_mask";
            case 1671L: return "bfk_ia32_movdqa64_128_mask";
            case 1672L: return "bfk_ia32_movdqa64_256_mask";
            case 1673L: return "bfk_ia32_movdqa64_512_mask";
            case 1674L: return "bfk_ia32_movdqa64load128_mask";
            case 1675L: return "bfk_ia32_movdqa64load256_mask";
            case 1676L: return "bfk_ia32_movdqa64load512_mask";
            case 1677L: return "bfk_ia32_movdqa64store128_mask";
            case 1678L: return "bfk_ia32_movdqa64store256_mask";
            case 1679L: return "bfk_ia32_movdqa64store512_mask";
            case 1680L: return "bfk_ia32_movdquhi128_mask";
            case 1681L: return "bfk_ia32_movdquhi256_mask";
            case 1682L: return "bfk_ia32_movdquhi512_mask";
            case 1683L: return "bfk_ia32_movdquqi128_mask";
            case 1684L: return "bfk_ia32_movdquqi256_mask";
            case 1685L: return "bfk_ia32_movdquqi512_mask";
            case 1686L: return "bfk_ia32_movesd_mask";
            case 1687L: return "bfk_ia32_movess_mask";
            case 1688L: return "bfk_ia32_movhlps";
            case 1689L: return "bfk_ia32_movlhps";
            case 1690L: return "bfk_ia32_movmskpd";
            case 1691L: return "bfk_ia32_movmskpd256";
            case 1692L: return "bfk_ia32_movmskps";
            case 1693L: return "bfk_ia32_movmskps256";
            case 1694L: return "bfk_ia32_movntdq";
            case 1695L: return "bfk_ia32_movntdq256";
            case 1696L: return "bfk_ia32_movntdq512";
            case 1697L: return "bfk_ia32_movntdqa";
            case 1698L: return "bfk_ia32_movntdqa256";
            case 1699L: return "bfk_ia32_movntdqa512";
            case 1700L: return "bfk_ia32_movnti";
            case 1701L: return "bfk_ia32_movnti64";
            case 1702L: return "bfk_ia32_movntpd";
            case 1703L: return "bfk_ia32_movntpd256";
            case 1704L: return "bfk_ia32_movntpd512";
            case 1705L: return "bfk_ia32_movntps";
            case 1706L: return "bfk_ia32_movntps256";
            case 1707L: return "bfk_ia32_movntps512";
            case 1708L: return "bfk_ia32_movntq";
            case 1709L: return "bfk_ia32_movntsd";
            case 1710L: return "bfk_ia32_movntss";
            case 1711L: return "bfk_ia32_movq128";
            case 1712L: return "bfk_ia32_movsd";
            case 1713L: return "bfk_ia32_movshdup";
            case 1714L: return "bfk_ia32_movshdup128_mask";
            case 1715L: return "bfk_ia32_movshdup256";
            case 1716L: return "bfk_ia32_movshdup256_mask";
            case 1717L: return "bfk_ia32_movshdup512_mask";
            case 1718L: return "bfk_ia32_movsldup";
            case 1719L: return "bfk_ia32_movsldup128_mask";
            case 1720L: return "bfk_ia32_movsldup256";
            case 1721L: return "bfk_ia32_movsldup256_mask";
            case 1722L: return "bfk_ia32_movsldup512_mask";
            case 1723L: return "bfk_ia32_movss";
            case 1724L: return "bfk_ia32_mpsadbw128";
            case 1725L: return "bfk_ia32_mpsadbw256";
            case 1726L: return "bfk_ia32_mulpd";
            case 1727L: return "bfk_ia32_mulpd256";
            case 1728L: return "bfk_ia32_mulpd256_mask";
            case 1729L: return "bfk_ia32_mulpd512";
            case 1730L: return "bfk_ia32_mulpd512_mask";
            case 1731L: return "bfk_ia32_mulpd_mask";
            case 1732L: return "bfk_ia32_mulps";
            case 1733L: return "bfk_ia32_mulps256";
            case 1734L: return "bfk_ia32_mulps256_mask";
            case 1735L: return "bfk_ia32_mulps512";
            case 1736L: return "bfk_ia32_mulps512_mask";
            case 1737L: return "bfk_ia32_mulps_mask";
            case 1738L: return "bfk_ia32_mulsd";
            case 1739L: return "bfk_ia32_mulsd_mask_round";
            case 1740L: return "bfk_ia32_mulsd_round";
            case 1741L: return "bfk_ia32_mulsd_round_mask";
            case 1742L: return "bfk_ia32_mulss";
            case 1743L: return "bfk_ia32_mulss_mask_round";
            case 1744L: return "bfk_ia32_mulss_round";
            case 1745L: return "bfk_ia32_mulss_round_mask";
            case 1746L: return "bfk_ia32_mwait";
            case 1747L: return "bfk_ia32_mwaitx";
            case 1748L: return "bfk_ia32_orpd";
            case 1749L: return "bfk_ia32_orpd128_mask";
            case 1750L: return "bfk_ia32_orpd256";
            case 1751L: return "bfk_ia32_orpd256_mask";
            case 1752L: return "bfk_ia32_orpd512_mask";
            case 1753L: return "bfk_ia32_orps";
            case 1754L: return "bfk_ia32_orps128_mask";
            case 1755L: return "bfk_ia32_orps256";
            case 1756L: return "bfk_ia32_orps256_mask";
            case 1757L: return "bfk_ia32_orps512_mask";
            case 1758L: return "bfk_ia32_pabsb";
            case 1759L: return "bfk_ia32_pabsb128";
            case 1760L: return "bfk_ia32_pabsb128_mask";
            case 1761L: return "bfk_ia32_pabsb256";
            case 1762L: return "bfk_ia32_pabsb256_mask";
            case 1763L: return "bfk_ia32_pabsb512";
            case 1764L: return "bfk_ia32_pabsb512_mask";
            case 1765L: return "bfk_ia32_pabsd";
            case 1766L: return "bfk_ia32_pabsd128";
            case 1767L: return "bfk_ia32_pabsd128_mask";
            case 1768L: return "bfk_ia32_pabsd256";
            case 1769L: return "bfk_ia32_pabsd256_mask";
            case 1770L: return "bfk_ia32_pabsd512";
            case 1771L: return "bfk_ia32_pabsd512_mask";
            case 1772L: return "bfk_ia32_pabsq128";
            case 1773L: return "bfk_ia32_pabsq128_mask";
            case 1774L: return "bfk_ia32_pabsq256";
            case 1775L: return "bfk_ia32_pabsq256_mask";
            case 1776L: return "bfk_ia32_pabsq512";
            case 1777L: return "bfk_ia32_pabsq512_mask";
            case 1778L: return "bfk_ia32_pabsw";
            case 1779L: return "bfk_ia32_pabsw128";
            case 1780L: return "bfk_ia32_pabsw128_mask";
            case 1781L: return "bfk_ia32_pabsw256";
            case 1782L: return "bfk_ia32_pabsw256_mask";
            case 1783L: return "bfk_ia32_pabsw512";
            case 1784L: return "bfk_ia32_pabsw512_mask";
            case 1785L: return "bfk_ia32_packssdw";
            case 1786L: return "bfk_ia32_packssdw128";
            case 1787L: return "bfk_ia32_packssdw128_mask";
            case 1788L: return "bfk_ia32_packssdw256";
            case 1789L: return "bfk_ia32_packssdw256_mask";
            case 1790L: return "bfk_ia32_packssdw512";
            case 1791L: return "bfk_ia32_packssdw512_mask";
            case 1792L: return "bfk_ia32_packsswb";
            case 1793L: return "bfk_ia32_packsswb128";
            case 1794L: return "bfk_ia32_packsswb128_mask";
            case 1795L: return "bfk_ia32_packsswb256";
            case 1796L: return "bfk_ia32_packsswb256_mask";
            case 1797L: return "bfk_ia32_packsswb512";
            case 1798L: return "bfk_ia32_packsswb512_mask";
            case 1799L: return "bfk_ia32_packusdw128";
            case 1800L: return "bfk_ia32_packusdw128_mask";
            case 1801L: return "bfk_ia32_packusdw256";
            case 1802L: return "bfk_ia32_packusdw256_mask";
            case 1803L: return "bfk_ia32_packusdw512";
            case 1804L: return "bfk_ia32_packusdw512_mask";
            case 1805L: return "bfk_ia32_packuswb";
            case 1806L: return "bfk_ia32_packuswb128";
            case 1807L: return "bfk_ia32_packuswb128_mask";
            case 1808L: return "bfk_ia32_packuswb256";
            case 1809L: return "bfk_ia32_packuswb256_mask";
            case 1810L: return "bfk_ia32_packuswb512";
            case 1811L: return "bfk_ia32_packuswb512_mask";
            case 1812L: return "bfk_ia32_paddb";
            case 1813L: return "bfk_ia32_paddb128";
            case 1814L: return "bfk_ia32_paddb128_mask";
            case 1815L: return "bfk_ia32_paddb256";
            case 1816L: return "bfk_ia32_paddb256_mask";
            case 1817L: return "bfk_ia32_paddb512_mask";
            case 1818L: return "bfk_ia32_paddd";
            case 1819L: return "bfk_ia32_paddd128";
            case 1820L: return "bfk_ia32_paddd128_mask";
            case 1821L: return "bfk_ia32_paddd256";
            case 1822L: return "bfk_ia32_paddd256_mask";
            case 1823L: return "bfk_ia32_paddd512_mask";
            case 1824L: return "bfk_ia32_paddq";
            case 1825L: return "bfk_ia32_paddq128";
            case 1826L: return "bfk_ia32_paddq128_mask";
            case 1827L: return "bfk_ia32_paddq256";
            case 1828L: return "bfk_ia32_paddq256_mask";
            case 1829L: return "bfk_ia32_paddq512_mask";
            case 1830L: return "bfk_ia32_paddsb";
            case 1831L: return "bfk_ia32_paddsb128";
            case 1832L: return "bfk_ia32_paddsb128_mask";
            case 1833L: return "bfk_ia32_paddsb256";
            case 1834L: return "bfk_ia32_paddsb256_mask";
            case 1835L: return "bfk_ia32_paddsb512";
            case 1836L: return "bfk_ia32_paddsb512_mask";
            case 1837L: return "bfk_ia32_paddsw";
            case 1838L: return "bfk_ia32_paddsw128";
            case 1839L: return "bfk_ia32_paddsw128_mask";
            case 1840L: return "bfk_ia32_paddsw256";
            case 1841L: return "bfk_ia32_paddsw256_mask";
            case 1842L: return "bfk_ia32_paddsw512";
            case 1843L: return "bfk_ia32_paddsw512_mask";
            case 1844L: return "bfk_ia32_paddusb";
            case 1845L: return "bfk_ia32_paddusb128";
            case 1846L: return "bfk_ia32_paddusb128_mask";
            case 1847L: return "bfk_ia32_paddusb256";
            case 1848L: return "bfk_ia32_paddusb256_mask";
            case 1849L: return "bfk_ia32_paddusb512";
            case 1850L: return "bfk_ia32_paddusb512_mask";
            case 1851L: return "bfk_ia32_paddusw";
            case 1852L: return "bfk_ia32_paddusw128";
            case 1853L: return "bfk_ia32_paddusw128_mask";
            case 1854L: return "bfk_ia32_paddusw256";
            case 1855L: return "bfk_ia32_paddusw256_mask";
            case 1856L: return "bfk_ia32_paddusw512";
            case 1857L: return "bfk_ia32_paddusw512_mask";
            case 1858L: return "bfk_ia32_paddw";
            case 1859L: return "bfk_ia32_paddw128";
            case 1860L: return "bfk_ia32_paddw128_mask";
            case 1861L: return "bfk_ia32_paddw256";
            case 1862L: return "bfk_ia32_paddw256_mask";
            case 1863L: return "bfk_ia32_paddw512_mask";
            case 1864L: return "bfk_ia32_palignr";
            case 1865L: return "bfk_ia32_palignr128";
            case 1866L: return "bfk_ia32_palignr128_mask";
            case 1867L: return "bfk_ia32_palignr256";
            case 1868L: return "bfk_ia32_palignr256_mask";
            case 1869L: return "bfk_ia32_palignr512";
            case 1870L: return "bfk_ia32_palignr512_mask";
            case 1871L: return "bfk_ia32_pand";
            case 1872L: return "bfk_ia32_pand128";
            case 1873L: return "bfk_ia32_pandd128_mask";
            case 1874L: return "bfk_ia32_pandd256_mask";
            case 1875L: return "bfk_ia32_pandd512_mask";
            case 1876L: return "bfk_ia32_pandn";
            case 1877L: return "bfk_ia32_pandn128";
            case 1878L: return "bfk_ia32_pandnd128_mask";
            case 1879L: return "bfk_ia32_pandnd256_mask";
            case 1880L: return "bfk_ia32_pandnd512_mask";
            case 1881L: return "bfk_ia32_pandnq128_mask";
            case 1882L: return "bfk_ia32_pandnq256_mask";
            case 1883L: return "bfk_ia32_pandnq512_mask";
            case 1884L: return "bfk_ia32_pandq128_mask";
            case 1885L: return "bfk_ia32_pandq256_mask";
            case 1886L: return "bfk_ia32_pandq512_mask";
            case 1887L: return "bfk_ia32_pause";
            case 1888L: return "bfk_ia32_pavgb";
            case 1889L: return "bfk_ia32_pavgb128";
            case 1890L: return "bfk_ia32_pavgb128_mask";
            case 1891L: return "bfk_ia32_pavgb256";
            case 1892L: return "bfk_ia32_pavgb256_mask";
            case 1893L: return "bfk_ia32_pavgb512";
            case 1894L: return "bfk_ia32_pavgb512_mask";
            case 1895L: return "bfk_ia32_pavgusb";
            case 1896L: return "bfk_ia32_pavgw";
            case 1897L: return "bfk_ia32_pavgw128";
            case 1898L: return "bfk_ia32_pavgw128_mask";
            case 1899L: return "bfk_ia32_pavgw256";
            case 1900L: return "bfk_ia32_pavgw256_mask";
            case 1901L: return "bfk_ia32_pavgw512";
            case 1902L: return "bfk_ia32_pavgw512_mask";
            case 1903L: return "bfk_ia32_pblendd128";
            case 1904L: return "bfk_ia32_pblendd256";
            case 1905L: return "bfk_ia32_pblendvb128";
            case 1906L: return "bfk_ia32_pblendvb256";
            case 1907L: return "bfk_ia32_pblendw128";
            case 1908L: return "bfk_ia32_pblendw256";
            case 1909L: return "bfk_ia32_pbroadcastb128";
            case 1910L: return "bfk_ia32_pbroadcastb128_gpr_mask";
            case 1911L: return "bfk_ia32_pbroadcastb128_mask";
            case 1912L: return "bfk_ia32_pbroadcastb256";
            case 1913L: return "bfk_ia32_pbroadcastb256_gpr_mask";
            case 1914L: return "bfk_ia32_pbroadcastb256_mask";
            case 1915L: return "bfk_ia32_pbroadcastb512_gpr_mask";
            case 1916L: return "bfk_ia32_pbroadcastb512_mask";
            case 1917L: return "bfk_ia32_pbroadcastd128";
            case 1918L: return "bfk_ia32_pbroadcastd128_gpr_mask";
            case 1919L: return "bfk_ia32_pbroadcastd128_mask";
            case 1920L: return "bfk_ia32_pbroadcastd256";
            case 1921L: return "bfk_ia32_pbroadcastd256_gpr_mask";
            case 1922L: return "bfk_ia32_pbroadcastd256_mask";
            case 1923L: return "bfk_ia32_pbroadcastd512";
            case 1924L: return "bfk_ia32_pbroadcastd512_gpr_mask";
            case 1925L: return "bfk_ia32_pbroadcastq128";
            case 1926L: return "bfk_ia32_pbroadcastq128_gpr_mask";
            case 1927L: return "bfk_ia32_pbroadcastq128_mask";
            case 1928L: return "bfk_ia32_pbroadcastq256";
            case 1929L: return "bfk_ia32_pbroadcastq256_gpr_mask";
            case 1930L: return "bfk_ia32_pbroadcastq256_mask";
            case 1931L: return "bfk_ia32_pbroadcastq512";
            case 1932L: return "bfk_ia32_pbroadcastq512_gpr_mask";
            case 1933L: return "bfk_ia32_pbroadcastq512_mem_mask";
            case 1934L: return "bfk_ia32_pbroadcastw128";
            case 1935L: return "bfk_ia32_pbroadcastw128_gpr_mask";
            case 1936L: return "bfk_ia32_pbroadcastw128_mask";
            case 1937L: return "bfk_ia32_pbroadcastw256";
            case 1938L: return "bfk_ia32_pbroadcastw256_gpr_mask";
            case 1939L: return "bfk_ia32_pbroadcastw256_mask";
            case 1940L: return "bfk_ia32_pbroadcastw512_gpr_mask";
            case 1941L: return "bfk_ia32_pbroadcastw512_mask";
            case 1942L: return "bfk_ia32_pclmulqdq128";
            case 1943L: return "bfk_ia32_pclmulqdq256";
            case 1944L: return "bfk_ia32_pclmulqdq512";
            case 1945L: return "bfk_ia32_pcmov";
            case 1946L: return "bfk_ia32_pcmov_v16qi";
            case 1947L: return "bfk_ia32_pcmov_v2df";
            case 1948L: return "bfk_ia32_pcmov_v2di";
            case 1949L: return "bfk_ia32_pcmov_v4sf";
            case 1950L: return "bfk_ia32_pcmov_v4si";
            case 1951L: return "bfk_ia32_pcmov_v8hi";
            case 1952L: return "bfk_ia32_pcmpeqb";
            case 1953L: return "bfk_ia32_pcmpeqb128";
            case 1954L: return "bfk_ia32_pcmpeqb128_mask";
            case 1955L: return "bfk_ia32_pcmpeqb256";
            case 1956L: return "bfk_ia32_pcmpeqb256_mask";
            case 1957L: return "bfk_ia32_pcmpeqb512_mask";
            case 1958L: return "bfk_ia32_pcmpeqd";
            case 1959L: return "bfk_ia32_pcmpeqd128";
            case 1960L: return "bfk_ia32_pcmpeqd128_mask";
            case 1961L: return "bfk_ia32_pcmpeqd256";
            case 1962L: return "bfk_ia32_pcmpeqd256_mask";
            case 1963L: return "bfk_ia32_pcmpeqd512_mask";
            case 1964L: return "bfk_ia32_pcmpeqq";
            case 1965L: return "bfk_ia32_pcmpeqq128_mask";
            case 1966L: return "bfk_ia32_pcmpeqq256";
            case 1967L: return "bfk_ia32_pcmpeqq256_mask";
            case 1968L: return "bfk_ia32_pcmpeqq512_mask";
            case 1969L: return "bfk_ia32_pcmpeqw";
            case 1970L: return "bfk_ia32_pcmpeqw128";
            case 1971L: return "bfk_ia32_pcmpeqw128_mask";
            case 1972L: return "bfk_ia32_pcmpeqw256";
            case 1973L: return "bfk_ia32_pcmpeqw256_mask";
            case 1974L: return "bfk_ia32_pcmpeqw512_mask";
            case 1975L: return "bfk_ia32_pcmpestri128";
            case 1976L: return "bfk_ia32_pcmpestria128";
            case 1977L: return "bfk_ia32_pcmpestric128";
            case 1978L: return "bfk_ia32_pcmpestrio128";
            case 1979L: return "bfk_ia32_pcmpestris128";
            case 1980L: return "bfk_ia32_pcmpestriz128";
            case 1981L: return "bfk_ia32_pcmpestrm128";
            case 1982L: return "bfk_ia32_pcmpgtb";
            case 1983L: return "bfk_ia32_pcmpgtb128";
            case 1984L: return "bfk_ia32_pcmpgtb128_mask";
            case 1985L: return "bfk_ia32_pcmpgtb256";
            case 1986L: return "bfk_ia32_pcmpgtb256_mask";
            case 1987L: return "bfk_ia32_pcmpgtb512_mask";
            case 1988L: return "bfk_ia32_pcmpgtd";
            case 1989L: return "bfk_ia32_pcmpgtd128";
            case 1990L: return "bfk_ia32_pcmpgtd128_mask";
            case 1991L: return "bfk_ia32_pcmpgtd256";
            case 1992L: return "bfk_ia32_pcmpgtd256_mask";
            case 1993L: return "bfk_ia32_pcmpgtd512_mask";
            case 1994L: return "bfk_ia32_pcmpgtq";
            case 1995L: return "bfk_ia32_pcmpgtq128_mask";
            case 1996L: return "bfk_ia32_pcmpgtq256";
            case 1997L: return "bfk_ia32_pcmpgtq256_mask";
            case 1998L: return "bfk_ia32_pcmpgtq512_mask";
            case 1999L: return "bfk_ia32_pcmpgtw";
            case 2000L: return "bfk_ia32_pcmpgtw128";
            case 2001L: return "bfk_ia32_pcmpgtw128_mask";
            case 2002L: return "bfk_ia32_pcmpgtw256";
            case 2003L: return "bfk_ia32_pcmpgtw256_mask";
            case 2004L: return "bfk_ia32_pcmpgtw512_mask";
            case 2005L: return "bfk_ia32_pcmpistri128";
            case 2006L: return "bfk_ia32_pcmpistria128";
            case 2007L: return "bfk_ia32_pcmpistric128";
            case 2008L: return "bfk_ia32_pcmpistrio128";
            case 2009L: return "bfk_ia32_pcmpistris128";
            case 2010L: return "bfk_ia32_pcmpistriz128";
            case 2011L: return "bfk_ia32_pcmpistrm128";
            case 2012L: return "bfk_ia32_pcomeqb";
            case 2013L: return "bfk_ia32_pcomeqd";
            case 2014L: return "bfk_ia32_pcomeqq";
            case 2015L: return "bfk_ia32_pcomequb";
            case 2016L: return "bfk_ia32_pcomequd";
            case 2017L: return "bfk_ia32_pcomequq";
            case 2018L: return "bfk_ia32_pcomequw";
            case 2019L: return "bfk_ia32_pcomeqw";
            case 2020L: return "bfk_ia32_pcomfalseb";
            case 2021L: return "bfk_ia32_pcomfalsed";
            case 2022L: return "bfk_ia32_pcomfalseq";
            case 2023L: return "bfk_ia32_pcomfalseub";
            case 2024L: return "bfk_ia32_pcomfalseud";
            case 2025L: return "bfk_ia32_pcomfalseuq";
            case 2026L: return "bfk_ia32_pcomfalseuw";
            case 2027L: return "bfk_ia32_pcomfalsew";
            case 2028L: return "bfk_ia32_pcomgeb";
            case 2029L: return "bfk_ia32_pcomged";
            case 2030L: return "bfk_ia32_pcomgeq";
            case 2031L: return "bfk_ia32_pcomgeub";
            case 2032L: return "bfk_ia32_pcomgeud";
            case 2033L: return "bfk_ia32_pcomgeuq";
            case 2034L: return "bfk_ia32_pcomgeuw";
            case 2035L: return "bfk_ia32_pcomgew";
            case 2036L: return "bfk_ia32_pcomgtb";
            case 2037L: return "bfk_ia32_pcomgtd";
            case 2038L: return "bfk_ia32_pcomgtq";
            case 2039L: return "bfk_ia32_pcomgtub";
            case 2040L: return "bfk_ia32_pcomgtud";
            case 2041L: return "bfk_ia32_pcomgtuq";
            case 2042L: return "bfk_ia32_pcomgtuw";
            case 2043L: return "bfk_ia32_pcomgtw";
            case 2044L: return "bfk_ia32_pcomleb";
            case 2045L: return "bfk_ia32_pcomled";
            case 2046L: return "bfk_ia32_pcomleq";
            case 2047L: return "bfk_ia32_pcomleub";
            case 2048L: return "bfk_ia32_pcomleud";
            case 2049L: return "bfk_ia32_pcomleuq";
            case 2050L: return "bfk_ia32_pcomleuw";
            case 2051L: return "bfk_ia32_pcomlew";
            case 2052L: return "bfk_ia32_pcomltb";
            case 2053L: return "bfk_ia32_pcomltd";
            case 2054L: return "bfk_ia32_pcomltq";
            case 2055L: return "bfk_ia32_pcomltub";
            case 2056L: return "bfk_ia32_pcomltud";
            case 2057L: return "bfk_ia32_pcomltuq";
            case 2058L: return "bfk_ia32_pcomltuw";
            case 2059L: return "bfk_ia32_pcomltw";
            case 2060L: return "bfk_ia32_pcommit";
            case 2061L: return "bfk_ia32_pcomneb";
            case 2062L: return "bfk_ia32_pcomned";
            case 2063L: return "bfk_ia32_pcomneq";
            case 2064L: return "bfk_ia32_pcomneub";
            case 2065L: return "bfk_ia32_pcomneud";
            case 2066L: return "bfk_ia32_pcomneuq";
            case 2067L: return "bfk_ia32_pcomneuw";
            case 2068L: return "bfk_ia32_pcomnew";
            case 2069L: return "bfk_ia32_pcomtrueb";
            case 2070L: return "bfk_ia32_pcomtrued";
            case 2071L: return "bfk_ia32_pcomtrueq";
            case 2072L: return "bfk_ia32_pcomtrueub";
            case 2073L: return "bfk_ia32_pcomtrueud";
            case 2074L: return "bfk_ia32_pcomtrueuq";
            case 2075L: return "bfk_ia32_pcomtrueuw";
            case 2076L: return "bfk_ia32_pcomtruew";
            case 2077L: return "bfk_ia32_pd256_pd";
            case 2078L: return "bfk_ia32_pd512_256pd";
            case 2079L: return "bfk_ia32_pd512_pd";
            case 2080L: return "bfk_ia32_pd_pd256";
            case 2081L: return "bfk_ia32_pdep_di";
            case 2082L: return "bfk_ia32_pdep_si";
            case 2083L: return "bfk_ia32_permdf256";
            case 2084L: return "bfk_ia32_permdf256_mask";
            case 2085L: return "bfk_ia32_permdf512";
            case 2086L: return "bfk_ia32_permdf512_mask";
            case 2087L: return "bfk_ia32_permdi256";
            case 2088L: return "bfk_ia32_permdi256_mask";
            case 2089L: return "bfk_ia32_permdi512";
            case 2090L: return "bfk_ia32_permdi512_mask";
            case 2091L: return "bfk_ia32_permpd";
            case 2092L: return "bfk_ia32_permps";
            case 2093L: return "bfk_ia32_permti256";
            case 2094L: return "bfk_ia32_permvardf256";
            case 2095L: return "bfk_ia32_permvardf256_mask";
            case 2096L: return "bfk_ia32_permvardf512";
            case 2097L: return "bfk_ia32_permvardf512_mask";
            case 2098L: return "bfk_ia32_permvardi256";
            case 2099L: return "bfk_ia32_permvardi256_mask";
            case 2100L: return "bfk_ia32_permvardi512";
            case 2101L: return "bfk_ia32_permvardi512_mask";
            case 2102L: return "bfk_ia32_permvarhi128";
            case 2103L: return "bfk_ia32_permvarhi128_mask";
            case 2104L: return "bfk_ia32_permvarhi256";
            case 2105L: return "bfk_ia32_permvarhi256_mask";
            case 2106L: return "bfk_ia32_permvarhi512";
            case 2107L: return "bfk_ia32_permvarhi512_mask";
            case 2108L: return "bfk_ia32_permvarqi128";
            case 2109L: return "bfk_ia32_permvarqi128_mask";
            case 2110L: return "bfk_ia32_permvarqi256";
            case 2111L: return "bfk_ia32_permvarqi256_mask";
            case 2112L: return "bfk_ia32_permvarqi512";
            case 2113L: return "bfk_ia32_permvarqi512_mask";
            case 2114L: return "bfk_ia32_permvarsf256";
            case 2115L: return "bfk_ia32_permvarsf256_mask";
            case 2116L: return "bfk_ia32_permvarsf512";
            case 2117L: return "bfk_ia32_permvarsf512_mask";
            case 2118L: return "bfk_ia32_permvarsi256";
            case 2119L: return "bfk_ia32_permvarsi256_mask";
            case 2120L: return "bfk_ia32_permvarsi512";
            case 2121L: return "bfk_ia32_permvarsi512_mask";
            case 2122L: return "bfk_ia32_pext_di";
            case 2123L: return "bfk_ia32_pext_si";
            case 2124L: return "bfk_ia32_pextrw";
            case 2125L: return "bfk_ia32_pf2id";
            case 2126L: return "bfk_ia32_pf2iw";
            case 2127L: return "bfk_ia32_pfacc";
            case 2128L: return "bfk_ia32_pfadd";
            case 2129L: return "bfk_ia32_pfcmpeq";
            case 2130L: return "bfk_ia32_pfcmpge";
            case 2131L: return "bfk_ia32_pfcmpgt";
            case 2132L: return "bfk_ia32_pfmax";
            case 2133L: return "bfk_ia32_pfmin";
            case 2134L: return "bfk_ia32_pfmul";
            case 2135L: return "bfk_ia32_pfnacc";
            case 2136L: return "bfk_ia32_pfpnacc";
            case 2137L: return "bfk_ia32_pfrcp";
            case 2138L: return "bfk_ia32_pfrcpit1";
            case 2139L: return "bfk_ia32_pfrcpit2";
            case 2140L: return "bfk_ia32_pfrsqit1";
            case 2141L: return "bfk_ia32_pfrsqrt";
            case 2142L: return "bfk_ia32_pfrsqrtit1";
            case 2143L: return "bfk_ia32_pfsub";
            case 2144L: return "bfk_ia32_pfsubr";
            case 2145L: return "bfk_ia32_phaddbd";
            case 2146L: return "bfk_ia32_phaddbq";
            case 2147L: return "bfk_ia32_phaddbw";
            case 2148L: return "bfk_ia32_phaddd";
            case 2149L: return "bfk_ia32_phaddd128";
            case 2150L: return "bfk_ia32_phaddd256";
            case 2151L: return "bfk_ia32_phadddq";
            case 2152L: return "bfk_ia32_phaddsw";
            case 2153L: return "bfk_ia32_phaddsw128";
            case 2154L: return "bfk_ia32_phaddsw256";
            case 2155L: return "bfk_ia32_phaddubd";
            case 2156L: return "bfk_ia32_phaddubq";
            case 2157L: return "bfk_ia32_phaddubw";
            case 2158L: return "bfk_ia32_phaddudq";
            case 2159L: return "bfk_ia32_phadduwd";
            case 2160L: return "bfk_ia32_phadduwq";
            case 2161L: return "bfk_ia32_phaddw";
            case 2162L: return "bfk_ia32_phaddw128";
            case 2163L: return "bfk_ia32_phaddw256";
            case 2164L: return "bfk_ia32_phaddwd";
            case 2165L: return "bfk_ia32_phaddwq";
            case 2166L: return "bfk_ia32_phminposuw128";
            case 2167L: return "bfk_ia32_phsubbw";
            case 2168L: return "bfk_ia32_phsubd";
            case 2169L: return "bfk_ia32_phsubd128";
            case 2170L: return "bfk_ia32_phsubd256";
            case 2171L: return "bfk_ia32_phsubdq";
            case 2172L: return "bfk_ia32_phsubsw";
            case 2173L: return "bfk_ia32_phsubsw128";
            case 2174L: return "bfk_ia32_phsubsw256";
            case 2175L: return "bfk_ia32_phsubw";
            case 2176L: return "bfk_ia32_phsubw128";
            case 2177L: return "bfk_ia32_phsubw256";
            case 2178L: return "bfk_ia32_phsubwd";
            case 2179L: return "bfk_ia32_pi2fd";
            case 2180L: return "bfk_ia32_pi2fw";
            case 2181L: return "bfk_ia32_pinsrw";
            case 2182L: return "bfk_ia32_pmacsdd";
            case 2183L: return "bfk_ia32_pmacsdqh";
            case 2184L: return "bfk_ia32_pmacsdql";
            case 2185L: return "bfk_ia32_pmacssdd";
            case 2186L: return "bfk_ia32_pmacssdqh";
            case 2187L: return "bfk_ia32_pmacssdql";
            case 2188L: return "bfk_ia32_pmacsswd";
            case 2189L: return "bfk_ia32_pmacssww";
            case 2190L: return "bfk_ia32_pmacswd";
            case 2191L: return "bfk_ia32_pmacsww";
            case 2192L: return "bfk_ia32_pmadcsswd";
            case 2193L: return "bfk_ia32_pmadcswd";
            case 2194L: return "bfk_ia32_pmaddubsw";
            case 2195L: return "bfk_ia32_pmaddubsw128";
            case 2196L: return "bfk_ia32_pmaddubsw128_mask";
            case 2197L: return "bfk_ia32_pmaddubsw256";
            case 2198L: return "bfk_ia32_pmaddubsw256_mask";
            case 2199L: return "bfk_ia32_pmaddubsw512";
            case 2200L: return "bfk_ia32_pmaddubsw512_mask";
            case 2201L: return "bfk_ia32_pmaddwd";
            case 2202L: return "bfk_ia32_pmaddwd128";
            case 2203L: return "bfk_ia32_pmaddwd128_mask";
            case 2204L: return "bfk_ia32_pmaddwd256";
            case 2205L: return "bfk_ia32_pmaddwd256_mask";
            case 2206L: return "bfk_ia32_pmaddwd512";
            case 2207L: return "bfk_ia32_pmaddwd512_mask";
            case 2208L: return "bfk_ia32_pmaxsb128";
            case 2209L: return "bfk_ia32_pmaxsb128_mask";
            case 2210L: return "bfk_ia32_pmaxsb256";
            case 2211L: return "bfk_ia32_pmaxsb256_mask";
            case 2212L: return "bfk_ia32_pmaxsb512";
            case 2213L: return "bfk_ia32_pmaxsb512_mask";
            case 2214L: return "bfk_ia32_pmaxsd128";
            case 2215L: return "bfk_ia32_pmaxsd128_mask";
            case 2216L: return "bfk_ia32_pmaxsd256";
            case 2217L: return "bfk_ia32_pmaxsd256_mask";
            case 2218L: return "bfk_ia32_pmaxsd512";
            case 2219L: return "bfk_ia32_pmaxsd512_mask";
            case 2220L: return "bfk_ia32_pmaxsq128";
            case 2221L: return "bfk_ia32_pmaxsq128_mask";
            case 2222L: return "bfk_ia32_pmaxsq256";
            case 2223L: return "bfk_ia32_pmaxsq256_mask";
            case 2224L: return "bfk_ia32_pmaxsq512";
            case 2225L: return "bfk_ia32_pmaxsq512_mask";
            case 2226L: return "bfk_ia32_pmaxsw";
            case 2227L: return "bfk_ia32_pmaxsw128";
            case 2228L: return "bfk_ia32_pmaxsw128_mask";
            case 2229L: return "bfk_ia32_pmaxsw256";
            case 2230L: return "bfk_ia32_pmaxsw256_mask";
            case 2231L: return "bfk_ia32_pmaxsw512";
            case 2232L: return "bfk_ia32_pmaxsw512_mask";
            case 2233L: return "bfk_ia32_pmaxub";
            case 2234L: return "bfk_ia32_pmaxub128";
            case 2235L: return "bfk_ia32_pmaxub128_mask";
            case 2236L: return "bfk_ia32_pmaxub256";
            case 2237L: return "bfk_ia32_pmaxub256_mask";
            case 2238L: return "bfk_ia32_pmaxub512";
            case 2239L: return "bfk_ia32_pmaxub512_mask";
            case 2240L: return "bfk_ia32_pmaxud128";
            case 2241L: return "bfk_ia32_pmaxud128_mask";
            case 2242L: return "bfk_ia32_pmaxud256";
            case 2243L: return "bfk_ia32_pmaxud256_mask";
            case 2244L: return "bfk_ia32_pmaxud512";
            case 2245L: return "bfk_ia32_pmaxud512_mask";
            case 2246L: return "bfk_ia32_pmaxuq128";
            case 2247L: return "bfk_ia32_pmaxuq128_mask";
            case 2248L: return "bfk_ia32_pmaxuq256";
            case 2249L: return "bfk_ia32_pmaxuq256_mask";
            case 2250L: return "bfk_ia32_pmaxuq512";
            case 2251L: return "bfk_ia32_pmaxuq512_mask";
            case 2252L: return "bfk_ia32_pmaxuw128";
            case 2253L: return "bfk_ia32_pmaxuw128_mask";
            case 2254L: return "bfk_ia32_pmaxuw256";
            case 2255L: return "bfk_ia32_pmaxuw256_mask";
            case 2256L: return "bfk_ia32_pmaxuw512";
            case 2257L: return "bfk_ia32_pmaxuw512_mask";
            case 2258L: return "bfk_ia32_pminsb128";
            case 2259L: return "bfk_ia32_pminsb128_mask";
            case 2260L: return "bfk_ia32_pminsb256";
            case 2261L: return "bfk_ia32_pminsb256_mask";
            case 2262L: return "bfk_ia32_pminsb512";
            case 2263L: return "bfk_ia32_pminsb512_mask";
            case 2264L: return "bfk_ia32_pminsd128";
            case 2265L: return "bfk_ia32_pminsd128_mask";
            case 2266L: return "bfk_ia32_pminsd256";
            case 2267L: return "bfk_ia32_pminsd256_mask";
            case 2268L: return "bfk_ia32_pminsd512";
            case 2269L: return "bfk_ia32_pminsd512_mask";
            case 2270L: return "bfk_ia32_pminsq128";
            case 2271L: return "bfk_ia32_pminsq128_mask";
            case 2272L: return "bfk_ia32_pminsq256";
            case 2273L: return "bfk_ia32_pminsq256_mask";
            case 2274L: return "bfk_ia32_pminsq512";
            case 2275L: return "bfk_ia32_pminsq512_mask";
            case 2276L: return "bfk_ia32_pminsw";
            case 2277L: return "bfk_ia32_pminsw128";
            case 2278L: return "bfk_ia32_pminsw128_mask";
            case 2279L: return "bfk_ia32_pminsw256";
            case 2280L: return "bfk_ia32_pminsw256_mask";
            case 2281L: return "bfk_ia32_pminsw512";
            case 2282L: return "bfk_ia32_pminsw512_mask";
            case 2283L: return "bfk_ia32_pminub";
            case 2284L: return "bfk_ia32_pminub128";
            case 2285L: return "bfk_ia32_pminub128_mask";
            case 2286L: return "bfk_ia32_pminub256";
            case 2287L: return "bfk_ia32_pminub256_mask";
            case 2288L: return "bfk_ia32_pminub512";
            case 2289L: return "bfk_ia32_pminub512_mask";
            case 2290L: return "bfk_ia32_pminud128";
            case 2291L: return "bfk_ia32_pminud128_mask";
            case 2292L: return "bfk_ia32_pminud256";
            case 2293L: return "bfk_ia32_pminud256_mask";
            case 2294L: return "bfk_ia32_pminud512";
            case 2295L: return "bfk_ia32_pminud512_mask";
            case 2296L: return "bfk_ia32_pminuq128";
            case 2297L: return "bfk_ia32_pminuq128_mask";
            case 2298L: return "bfk_ia32_pminuq256";
            case 2299L: return "bfk_ia32_pminuq256_mask";
            case 2300L: return "bfk_ia32_pminuq512";
            case 2301L: return "bfk_ia32_pminuq512_mask";
            case 2302L: return "bfk_ia32_pminuw128";
            case 2303L: return "bfk_ia32_pminuw128_mask";
            case 2304L: return "bfk_ia32_pminuw256";
            case 2305L: return "bfk_ia32_pminuw256_mask";
            case 2306L: return "bfk_ia32_pminuw512";
            case 2307L: return "bfk_ia32_pminuw512_mask";
            case 2308L: return "bfk_ia32_pmovdb128_mask";
            case 2309L: return "bfk_ia32_pmovdb128mem_mask";
            case 2310L: return "bfk_ia32_pmovdb256_mask";
            case 2311L: return "bfk_ia32_pmovdb256mem_mask";
            case 2312L: return "bfk_ia32_pmovdb512_mask";
            case 2313L: return "bfk_ia32_pmovdb512mem_mask";
            case 2314L: return "bfk_ia32_pmovdw128_mask";
            case 2315L: return "bfk_ia32_pmovdw128mem_mask";
            case 2316L: return "bfk_ia32_pmovdw256_mask";
            case 2317L: return "bfk_ia32_pmovdw256mem_mask";
            case 2318L: return "bfk_ia32_pmovdw512_mask";
            case 2319L: return "bfk_ia32_pmovdw512mem_mask";
            case 2320L: return "bfk_ia32_pmovmskb";
            case 2321L: return "bfk_ia32_pmovmskb128";
            case 2322L: return "bfk_ia32_pmovmskb256";
            case 2323L: return "bfk_ia32_pmovqb128_mask";
            case 2324L: return "bfk_ia32_pmovqb128mem_mask";
            case 2325L: return "bfk_ia32_pmovqb256_mask";
            case 2326L: return "bfk_ia32_pmovqb256mem_mask";
            case 2327L: return "bfk_ia32_pmovqb512_mask";
            case 2328L: return "bfk_ia32_pmovqb512mem_mask";
            case 2329L: return "bfk_ia32_pmovqd128_mask";
            case 2330L: return "bfk_ia32_pmovqd128mem_mask";
            case 2331L: return "bfk_ia32_pmovqd256_mask";
            case 2332L: return "bfk_ia32_pmovqd256mem_mask";
            case 2333L: return "bfk_ia32_pmovqd512_mask";
            case 2334L: return "bfk_ia32_pmovqd512mem_mask";
            case 2335L: return "bfk_ia32_pmovqw128_mask";
            case 2336L: return "bfk_ia32_pmovqw128mem_mask";
            case 2337L: return "bfk_ia32_pmovqw256_mask";
            case 2338L: return "bfk_ia32_pmovqw256mem_mask";
            case 2339L: return "bfk_ia32_pmovqw512_mask";
            case 2340L: return "bfk_ia32_pmovqw512mem_mask";
            case 2341L: return "bfk_ia32_pmovsdb128_mask";
            case 2342L: return "bfk_ia32_pmovsdb128mem_mask";
            case 2343L: return "bfk_ia32_pmovsdb256_mask";
            case 2344L: return "bfk_ia32_pmovsdb256mem_mask";
            case 2345L: return "bfk_ia32_pmovsdb512_mask";
            case 2346L: return "bfk_ia32_pmovsdb512mem_mask";
            case 2347L: return "bfk_ia32_pmovsdw128_mask";
            case 2348L: return "bfk_ia32_pmovsdw128mem_mask";
            case 2349L: return "bfk_ia32_pmovsdw256_mask";
            case 2350L: return "bfk_ia32_pmovsdw256mem_mask";
            case 2351L: return "bfk_ia32_pmovsdw512_mask";
            case 2352L: return "bfk_ia32_pmovsdw512mem_mask";
            case 2353L: return "bfk_ia32_pmovsqb128_mask";
            case 2354L: return "bfk_ia32_pmovsqb128mem_mask";
            case 2355L: return "bfk_ia32_pmovsqb256_mask";
            case 2356L: return "bfk_ia32_pmovsqb256mem_mask";
            case 2357L: return "bfk_ia32_pmovsqb512_mask";
            case 2358L: return "bfk_ia32_pmovsqb512mem_mask";
            case 2359L: return "bfk_ia32_pmovsqd128_mask";
            case 2360L: return "bfk_ia32_pmovsqd128mem_mask";
            case 2361L: return "bfk_ia32_pmovsqd256_mask";
            case 2362L: return "bfk_ia32_pmovsqd256mem_mask";
            case 2363L: return "bfk_ia32_pmovsqd512_mask";
            case 2364L: return "bfk_ia32_pmovsqd512mem_mask";
            case 2365L: return "bfk_ia32_pmovsqw128_mask";
            case 2366L: return "bfk_ia32_pmovsqw128mem_mask";
            case 2367L: return "bfk_ia32_pmovsqw256_mask";
            case 2368L: return "bfk_ia32_pmovsqw256mem_mask";
            case 2369L: return "bfk_ia32_pmovsqw512_mask";
            case 2370L: return "bfk_ia32_pmovsqw512mem_mask";
            case 2371L: return "bfk_ia32_pmovswb128_mask";
            case 2372L: return "bfk_ia32_pmovswb128mem_mask";
            case 2373L: return "bfk_ia32_pmovswb256_mask";
            case 2374L: return "bfk_ia32_pmovswb256mem_mask";
            case 2375L: return "bfk_ia32_pmovswb512_mask";
            case 2376L: return "bfk_ia32_pmovswb512mem_mask";
            case 2377L: return "bfk_ia32_pmovsxbd128";
            case 2378L: return "bfk_ia32_pmovsxbd128_mask";
            case 2379L: return "bfk_ia32_pmovsxbd256";
            case 2380L: return "bfk_ia32_pmovsxbd256_mask";
            case 2381L: return "bfk_ia32_pmovsxbd512_mask";
            case 2382L: return "bfk_ia32_pmovsxbq128";
            case 2383L: return "bfk_ia32_pmovsxbq128_mask";
            case 2384L: return "bfk_ia32_pmovsxbq256";
            case 2385L: return "bfk_ia32_pmovsxbq256_mask";
            case 2386L: return "bfk_ia32_pmovsxbq512_mask";
            case 2387L: return "bfk_ia32_pmovsxbw128";
            case 2388L: return "bfk_ia32_pmovsxbw128_mask";
            case 2389L: return "bfk_ia32_pmovsxbw256";
            case 2390L: return "bfk_ia32_pmovsxbw256_mask";
            case 2391L: return "bfk_ia32_pmovsxbw512_mask";
            case 2392L: return "bfk_ia32_pmovsxdq128";
            case 2393L: return "bfk_ia32_pmovsxdq128_mask";
            case 2394L: return "bfk_ia32_pmovsxdq256";
            case 2395L: return "bfk_ia32_pmovsxdq256_mask";
            case 2396L: return "bfk_ia32_pmovsxdq512_mask";
            case 2397L: return "bfk_ia32_pmovsxwd128";
            case 2398L: return "bfk_ia32_pmovsxwd128_mask";
            case 2399L: return "bfk_ia32_pmovsxwd256";
            case 2400L: return "bfk_ia32_pmovsxwd256_mask";
            case 2401L: return "bfk_ia32_pmovsxwd512_mask";
            case 2402L: return "bfk_ia32_pmovsxwq128";
            case 2403L: return "bfk_ia32_pmovsxwq128_mask";
            case 2404L: return "bfk_ia32_pmovsxwq256";
            case 2405L: return "bfk_ia32_pmovsxwq256_mask";
            case 2406L: return "bfk_ia32_pmovsxwq512_mask";
            case 2407L: return "bfk_ia32_pmovusdb128_mask";
            case 2408L: return "bfk_ia32_pmovusdb128mem_mask";
            case 2409L: return "bfk_ia32_pmovusdb256_mask";
            case 2410L: return "bfk_ia32_pmovusdb256mem_mask";
            case 2411L: return "bfk_ia32_pmovusdb512_mask";
            case 2412L: return "bfk_ia32_pmovusdb512mem_mask";
            case 2413L: return "bfk_ia32_pmovusdw128_mask";
            case 2414L: return "bfk_ia32_pmovusdw128mem_mask";
            case 2415L: return "bfk_ia32_pmovusdw256_mask";
            case 2416L: return "bfk_ia32_pmovusdw256mem_mask";
            case 2417L: return "bfk_ia32_pmovusdw512_mask";
            case 2418L: return "bfk_ia32_pmovusdw512mem_mask";
            case 2419L: return "bfk_ia32_pmovusqb128_mask";
            case 2420L: return "bfk_ia32_pmovusqb128mem_mask";
            case 2421L: return "bfk_ia32_pmovusqb256_mask";
            case 2422L: return "bfk_ia32_pmovusqb256mem_mask";
            case 2423L: return "bfk_ia32_pmovusqb512_mask";
            case 2424L: return "bfk_ia32_pmovusqb512mem_mask";
            case 2425L: return "bfk_ia32_pmovusqd128_mask";
            case 2426L: return "bfk_ia32_pmovusqd128mem_mask";
            case 2427L: return "bfk_ia32_pmovusqd256_mask";
            case 2428L: return "bfk_ia32_pmovusqd256mem_mask";
            case 2429L: return "bfk_ia32_pmovusqd512_mask";
            case 2430L: return "bfk_ia32_pmovusqd512mem_mask";
            case 2431L: return "bfk_ia32_pmovusqw128_mask";
            case 2432L: return "bfk_ia32_pmovusqw128mem_mask";
            case 2433L: return "bfk_ia32_pmovusqw256_mask";
            case 2434L: return "bfk_ia32_pmovusqw256mem_mask";
            case 2435L: return "bfk_ia32_pmovusqw512_mask";
            case 2436L: return "bfk_ia32_pmovusqw512mem_mask";
            case 2437L: return "bfk_ia32_pmovuswb128_mask";
            case 2438L: return "bfk_ia32_pmovuswb128mem_mask";
            case 2439L: return "bfk_ia32_pmovuswb256_mask";
            case 2440L: return "bfk_ia32_pmovuswb256mem_mask";
            case 2441L: return "bfk_ia32_pmovuswb512_mask";
            case 2442L: return "bfk_ia32_pmovuswb512mem_mask";
            case 2443L: return "bfk_ia32_pmovwb128_mask";
            case 2444L: return "bfk_ia32_pmovwb128mem_mask";
            case 2445L: return "bfk_ia32_pmovwb256_mask";
            case 2446L: return "bfk_ia32_pmovwb256mem_mask";
            case 2447L: return "bfk_ia32_pmovwb512_mask";
            case 2448L: return "bfk_ia32_pmovwb512mem_mask";
            case 2449L: return "bfk_ia32_pmovzxbd128";
            case 2450L: return "bfk_ia32_pmovzxbd128_mask";
            case 2451L: return "bfk_ia32_pmovzxbd256";
            case 2452L: return "bfk_ia32_pmovzxbd256_mask";
            case 2453L: return "bfk_ia32_pmovzxbd512_mask";
            case 2454L: return "bfk_ia32_pmovzxbq128";
            case 2455L: return "bfk_ia32_pmovzxbq128_mask";
            case 2456L: return "bfk_ia32_pmovzxbq256";
            case 2457L: return "bfk_ia32_pmovzxbq256_mask";
            case 2458L: return "bfk_ia32_pmovzxbq512_mask";
            case 2459L: return "bfk_ia32_pmovzxbw128";
            case 2460L: return "bfk_ia32_pmovzxbw128_mask";
            case 2461L: return "bfk_ia32_pmovzxbw256";
            case 2462L: return "bfk_ia32_pmovzxbw256_mask";
            case 2463L: return "bfk_ia32_pmovzxbw512_mask";
            case 2464L: return "bfk_ia32_pmovzxdq128";
            case 2465L: return "bfk_ia32_pmovzxdq128_mask";
            case 2466L: return "bfk_ia32_pmovzxdq256";
            case 2467L: return "bfk_ia32_pmovzxdq256_mask";
            case 2468L: return "bfk_ia32_pmovzxdq512_mask";
            case 2469L: return "bfk_ia32_pmovzxwd128";
            case 2470L: return "bfk_ia32_pmovzxwd128_mask";
            case 2471L: return "bfk_ia32_pmovzxwd256";
            case 2472L: return "bfk_ia32_pmovzxwd256_mask";
            case 2473L: return "bfk_ia32_pmovzxwd512_mask";
            case 2474L: return "bfk_ia32_pmovzxwq128";
            case 2475L: return "bfk_ia32_pmovzxwq128_mask";
            case 2476L: return "bfk_ia32_pmovzxwq256";
            case 2477L: return "bfk_ia32_pmovzxwq256_mask";
            case 2478L: return "bfk_ia32_pmovzxwq512_mask";
            case 2479L: return "bfk_ia32_pmuldq128";
            case 2480L: return "bfk_ia32_pmuldq128_mask";
            case 2481L: return "bfk_ia32_pmuldq256";
            case 2482L: return "bfk_ia32_pmuldq256_mask";
            case 2483L: return "bfk_ia32_pmuldq512";
            case 2484L: return "bfk_ia32_pmuldq512_mask";
            case 2485L: return "bfk_ia32_pmulhrsw";
            case 2486L: return "bfk_ia32_pmulhrsw128";
            case 2487L: return "bfk_ia32_pmulhrsw128_mask";
            case 2488L: return "bfk_ia32_pmulhrsw256";
            case 2489L: return "bfk_ia32_pmulhrsw256_mask";
            case 2490L: return "bfk_ia32_pmulhrsw512";
            case 2491L: return "bfk_ia32_pmulhrsw512_mask";
            case 2492L: return "bfk_ia32_pmulhrw";
            case 2493L: return "bfk_ia32_pmulhuw";
            case 2494L: return "bfk_ia32_pmulhuw128";
            case 2495L: return "bfk_ia32_pmulhuw128_mask";
            case 2496L: return "bfk_ia32_pmulhuw256";
            case 2497L: return "bfk_ia32_pmulhuw256_mask";
            case 2498L: return "bfk_ia32_pmulhuw512";
            case 2499L: return "bfk_ia32_pmulhuw512_mask";
            case 2500L: return "bfk_ia32_pmulhw";
            case 2501L: return "bfk_ia32_pmulhw128";
            case 2502L: return "bfk_ia32_pmulhw128_mask";
            case 2503L: return "bfk_ia32_pmulhw256";
            case 2504L: return "bfk_ia32_pmulhw256_mask";
            case 2505L: return "bfk_ia32_pmulhw512";
            case 2506L: return "bfk_ia32_pmulhw512_mask";
            case 2507L: return "bfk_ia32_pmulld128";
            case 2508L: return "bfk_ia32_pmulld128_mask";
            case 2509L: return "bfk_ia32_pmulld256";
            case 2510L: return "bfk_ia32_pmulld256_mask";
            case 2511L: return "bfk_ia32_pmulld512_mask";
            case 2512L: return "bfk_ia32_pmullq128_mask";
            case 2513L: return "bfk_ia32_pmullq256_mask";
            case 2514L: return "bfk_ia32_pmullq512_mask";
            case 2515L: return "bfk_ia32_pmullw";
            case 2516L: return "bfk_ia32_pmullw128";
            case 2517L: return "bfk_ia32_pmullw128_mask";
            case 2518L: return "bfk_ia32_pmullw256";
            case 2519L: return "bfk_ia32_pmullw256_mask";
            case 2520L: return "bfk_ia32_pmullw512_mask";
            case 2521L: return "bfk_ia32_pmuludq";
            case 2522L: return "bfk_ia32_pmuludq128";
            case 2523L: return "bfk_ia32_pmuludq128_mask";
            case 2524L: return "bfk_ia32_pmuludq256";
            case 2525L: return "bfk_ia32_pmuludq256_mask";
            case 2526L: return "bfk_ia32_pmuludq512";
            case 2527L: return "bfk_ia32_pmuludq512_mask";
            case 2528L: return "bfk_ia32_por";
            case 2529L: return "bfk_ia32_por128";
            case 2530L: return "bfk_ia32_por256";
            case 2531L: return "bfk_ia32_pord128_mask";
            case 2532L: return "bfk_ia32_pord256_mask";
            case 2533L: return "bfk_ia32_pord512_mask";
            case 2534L: return "bfk_ia32_porq128_mask";
            case 2535L: return "bfk_ia32_porq256_mask";
            case 2536L: return "bfk_ia32_porq512_mask";
            case 2537L: return "bfk_ia32_pperm";
            case 2538L: return "bfk_ia32_prold128";
            case 2539L: return "bfk_ia32_prold128_mask";
            case 2540L: return "bfk_ia32_prold256";
            case 2541L: return "bfk_ia32_prold256_mask";
            case 2542L: return "bfk_ia32_prold512";
            case 2543L: return "bfk_ia32_prold512_mask";
            case 2544L: return "bfk_ia32_prolq128";
            case 2545L: return "bfk_ia32_prolq128_mask";
            case 2546L: return "bfk_ia32_prolq256";
            case 2547L: return "bfk_ia32_prolq256_mask";
            case 2548L: return "bfk_ia32_prolq512";
            case 2549L: return "bfk_ia32_prolq512_mask";
            case 2550L: return "bfk_ia32_prolvd128";
            case 2551L: return "bfk_ia32_prolvd128_mask";
            case 2552L: return "bfk_ia32_prolvd256";
            case 2553L: return "bfk_ia32_prolvd256_mask";
            case 2554L: return "bfk_ia32_prolvd512";
            case 2555L: return "bfk_ia32_prolvd512_mask";
            case 2556L: return "bfk_ia32_prolvq128";
            case 2557L: return "bfk_ia32_prolvq128_mask";
            case 2558L: return "bfk_ia32_prolvq256";
            case 2559L: return "bfk_ia32_prolvq256_mask";
            case 2560L: return "bfk_ia32_prolvq512";
            case 2561L: return "bfk_ia32_prolvq512_mask";
            case 2562L: return "bfk_ia32_prord128";
            case 2563L: return "bfk_ia32_prord128_mask";
            case 2564L: return "bfk_ia32_prord256";
            case 2565L: return "bfk_ia32_prord256_mask";
            case 2566L: return "bfk_ia32_prord512";
            case 2567L: return "bfk_ia32_prord512_mask";
            case 2568L: return "bfk_ia32_prorq128";
            case 2569L: return "bfk_ia32_prorq128_mask";
            case 2570L: return "bfk_ia32_prorq256";
            case 2571L: return "bfk_ia32_prorq256_mask";
            case 2572L: return "bfk_ia32_prorq512";
            case 2573L: return "bfk_ia32_prorq512_mask";
            case 2574L: return "bfk_ia32_prorvd128";
            case 2575L: return "bfk_ia32_prorvd128_mask";
            case 2576L: return "bfk_ia32_prorvd256";
            case 2577L: return "bfk_ia32_prorvd256_mask";
            case 2578L: return "bfk_ia32_prorvd512";
            case 2579L: return "bfk_ia32_prorvd512_mask";
            case 2580L: return "bfk_ia32_prorvq128";
            case 2581L: return "bfk_ia32_prorvq128_mask";
            case 2582L: return "bfk_ia32_prorvq256";
            case 2583L: return "bfk_ia32_prorvq256_mask";
            case 2584L: return "bfk_ia32_prorvq512";
            case 2585L: return "bfk_ia32_prorvq512_mask";
            case 2586L: return "bfk_ia32_protb";
            case 2587L: return "bfk_ia32_protd";
            case 2588L: return "bfk_ia32_protq";
            case 2589L: return "bfk_ia32_protw";
            case 2590L: return "bfk_ia32_ps256_ps";
            case 2591L: return "bfk_ia32_ps512_256ps";
            case 2592L: return "bfk_ia32_ps512_ps";
            case 2593L: return "bfk_ia32_ps_ps256";
            case 2594L: return "bfk_ia32_psadbw";
            case 2595L: return "bfk_ia32_psadbw128";
            case 2596L: return "bfk_ia32_psadbw256";
            case 2597L: return "bfk_ia32_psadbw512";
            case 2598L: return "bfk_ia32_pshab";
            case 2599L: return "bfk_ia32_pshad";
            case 2600L: return "bfk_ia32_pshaq";
            case 2601L: return "bfk_ia32_pshaw";
            case 2602L: return "bfk_ia32_pshlb";
            case 2603L: return "bfk_ia32_pshld";
            case 2604L: return "bfk_ia32_pshlq";
            case 2605L: return "bfk_ia32_pshlw";
            case 2606L: return "bfk_ia32_pshufb";
            case 2607L: return "bfk_ia32_pshufb128";
            case 2608L: return "bfk_ia32_pshufb128_mask";
            case 2609L: return "bfk_ia32_pshufb256";
            case 2610L: return "bfk_ia32_pshufb256_mask";
            case 2611L: return "bfk_ia32_pshufb512";
            case 2612L: return "bfk_ia32_pshufb512_mask";
            case 2613L: return "bfk_ia32_pshufd";
            case 2614L: return "bfk_ia32_pshufd128_mask";
            case 2615L: return "bfk_ia32_pshufd256";
            case 2616L: return "bfk_ia32_pshufd256_mask";
            case 2617L: return "bfk_ia32_pshufd512";
            case 2618L: return "bfk_ia32_pshufd512_mask";
            case 2619L: return "bfk_ia32_pshufhw";
            case 2620L: return "bfk_ia32_pshufhw128_mask";
            case 2621L: return "bfk_ia32_pshufhw256";
            case 2622L: return "bfk_ia32_pshufhw256_mask";
            case 2623L: return "bfk_ia32_pshufhw512";
            case 2624L: return "bfk_ia32_pshufhw512_mask";
            case 2625L: return "bfk_ia32_pshuflw";
            case 2626L: return "bfk_ia32_pshuflw128_mask";
            case 2627L: return "bfk_ia32_pshuflw256";
            case 2628L: return "bfk_ia32_pshuflw256_mask";
            case 2629L: return "bfk_ia32_pshuflw512";
            case 2630L: return "bfk_ia32_pshuflw512_mask";
            case 2631L: return "bfk_ia32_pshufw";
            case 2632L: return "bfk_ia32_psignb";
            case 2633L: return "bfk_ia32_psignb128";
            case 2634L: return "bfk_ia32_psignb256";
            case 2635L: return "bfk_ia32_psignd";
            case 2636L: return "bfk_ia32_psignd128";
            case 2637L: return "bfk_ia32_psignd256";
            case 2638L: return "bfk_ia32_psignw";
            case 2639L: return "bfk_ia32_psignw128";
            case 2640L: return "bfk_ia32_psignw256";
            case 2641L: return "bfk_ia32_pslld";
            case 2642L: return "bfk_ia32_pslld128";
            case 2643L: return "bfk_ia32_pslld128_mask";
            case 2644L: return "bfk_ia32_pslld256";
            case 2645L: return "bfk_ia32_pslld256_mask";
            case 2646L: return "bfk_ia32_pslld512";
            case 2647L: return "bfk_ia32_pslld512_mask";
            case 2648L: return "bfk_ia32_pslldi";
            case 2649L: return "bfk_ia32_pslldi128";
            case 2650L: return "bfk_ia32_pslldi128_mask";
            case 2651L: return "bfk_ia32_pslldi256";
            case 2652L: return "bfk_ia32_pslldi256_mask";
            case 2653L: return "bfk_ia32_pslldi512";
            case 2654L: return "bfk_ia32_pslldi512_mask";
            case 2655L: return "bfk_ia32_pslldq512";
            case 2656L: return "bfk_ia32_pslldqi128";
            case 2657L: return "bfk_ia32_pslldqi128_byteshift";
            case 2658L: return "bfk_ia32_pslldqi256";
            case 2659L: return "bfk_ia32_pslldqi256_byteshift";
            case 2660L: return "bfk_ia32_pslldqi512_byteshift";
            case 2661L: return "bfk_ia32_psllq";
            case 2662L: return "bfk_ia32_psllq128";
            case 2663L: return "bfk_ia32_psllq128_mask";
            case 2664L: return "bfk_ia32_psllq256";
            case 2665L: return "bfk_ia32_psllq256_mask";
            case 2666L: return "bfk_ia32_psllq512";
            case 2667L: return "bfk_ia32_psllq512_mask";
            case 2668L: return "bfk_ia32_psllqi";
            case 2669L: return "bfk_ia32_psllqi128";
            case 2670L: return "bfk_ia32_psllqi128_mask";
            case 2671L: return "bfk_ia32_psllqi256";
            case 2672L: return "bfk_ia32_psllqi256_mask";
            case 2673L: return "bfk_ia32_psllqi512";
            case 2674L: return "bfk_ia32_psllqi512_mask";
            case 2675L: return "bfk_ia32_psllv16hi";
            case 2676L: return "bfk_ia32_psllv16hi_mask";
            case 2677L: return "bfk_ia32_psllv16si";
            case 2678L: return "bfk_ia32_psllv16si_mask";
            case 2679L: return "bfk_ia32_psllv2di";
            case 2680L: return "bfk_ia32_psllv2di_mask";
            case 2681L: return "bfk_ia32_psllv32hi";
            case 2682L: return "bfk_ia32_psllv32hi_mask";
            case 2683L: return "bfk_ia32_psllv4di";
            case 2684L: return "bfk_ia32_psllv4di_mask";
            case 2685L: return "bfk_ia32_psllv4si";
            case 2686L: return "bfk_ia32_psllv4si_mask";
            case 2687L: return "bfk_ia32_psllv8di";
            case 2688L: return "bfk_ia32_psllv8di_mask";
            case 2689L: return "bfk_ia32_psllv8hi";
            case 2690L: return "bfk_ia32_psllv8hi_mask";
            case 2691L: return "bfk_ia32_psllv8si";
            case 2692L: return "bfk_ia32_psllv8si_mask";
            case 2693L: return "bfk_ia32_psllw";
            case 2694L: return "bfk_ia32_psllw128";
            case 2695L: return "bfk_ia32_psllw128_mask";
            case 2696L: return "bfk_ia32_psllw256";
            case 2697L: return "bfk_ia32_psllw256_mask";
            case 2698L: return "bfk_ia32_psllw512";
            case 2699L: return "bfk_ia32_psllw512_mask";
            case 2700L: return "bfk_ia32_psllwi";
            case 2701L: return "bfk_ia32_psllwi128";
            case 2702L: return "bfk_ia32_psllwi128_mask";
            case 2703L: return "bfk_ia32_psllwi256";
            case 2704L: return "bfk_ia32_psllwi256_mask";
            case 2705L: return "bfk_ia32_psllwi512";
            case 2706L: return "bfk_ia32_psllwi512_mask";
            case 2707L: return "bfk_ia32_psrad";
            case 2708L: return "bfk_ia32_psrad128";
            case 2709L: return "bfk_ia32_psrad128_mask";
            case 2710L: return "bfk_ia32_psrad256";
            case 2711L: return "bfk_ia32_psrad256_mask";
            case 2712L: return "bfk_ia32_psrad512";
            case 2713L: return "bfk_ia32_psrad512_mask";
            case 2714L: return "bfk_ia32_psradi";
            case 2715L: return "bfk_ia32_psradi128";
            case 2716L: return "bfk_ia32_psradi128_mask";
            case 2717L: return "bfk_ia32_psradi256";
            case 2718L: return "bfk_ia32_psradi256_mask";
            case 2719L: return "bfk_ia32_psradi512";
            case 2720L: return "bfk_ia32_psradi512_mask";
            case 2721L: return "bfk_ia32_psraq128";
            case 2722L: return "bfk_ia32_psraq128_mask";
            case 2723L: return "bfk_ia32_psraq256";
            case 2724L: return "bfk_ia32_psraq256_mask";
            case 2725L: return "bfk_ia32_psraq512";
            case 2726L: return "bfk_ia32_psraq512_mask";
            case 2727L: return "bfk_ia32_psraqi128";
            case 2728L: return "bfk_ia32_psraqi128_mask";
            case 2729L: return "bfk_ia32_psraqi256";
            case 2730L: return "bfk_ia32_psraqi256_mask";
            case 2731L: return "bfk_ia32_psraqi512";
            case 2732L: return "bfk_ia32_psraqi512_mask";
            case 2733L: return "bfk_ia32_psrav16hi";
            case 2734L: return "bfk_ia32_psrav16hi_mask";
            case 2735L: return "bfk_ia32_psrav16si";
            case 2736L: return "bfk_ia32_psrav16si_mask";
            case 2737L: return "bfk_ia32_psrav32hi";
            case 2738L: return "bfk_ia32_psrav32hi_mask";
            case 2739L: return "bfk_ia32_psrav4si";
            case 2740L: return "bfk_ia32_psrav4si_mask";
            case 2741L: return "bfk_ia32_psrav8di";
            case 2742L: return "bfk_ia32_psrav8di_mask";
            case 2743L: return "bfk_ia32_psrav8hi";
            case 2744L: return "bfk_ia32_psrav8hi_mask";
            case 2745L: return "bfk_ia32_psrav8si";
            case 2746L: return "bfk_ia32_psrav8si_mask";
            case 2747L: return "bfk_ia32_psravq128";
            case 2748L: return "bfk_ia32_psravq128_mask";
            case 2749L: return "bfk_ia32_psravq256";
            case 2750L: return "bfk_ia32_psravq256_mask";
            case 2751L: return "bfk_ia32_psraw";
            case 2752L: return "bfk_ia32_psraw128";
            case 2753L: return "bfk_ia32_psraw128_mask";
            case 2754L: return "bfk_ia32_psraw256";
            case 2755L: return "bfk_ia32_psraw256_mask";
            case 2756L: return "bfk_ia32_psraw512";
            case 2757L: return "bfk_ia32_psraw512_mask";
            case 2758L: return "bfk_ia32_psrawi";
            case 2759L: return "bfk_ia32_psrawi128";
            case 2760L: return "bfk_ia32_psrawi128_mask";
            case 2761L: return "bfk_ia32_psrawi256";
            case 2762L: return "bfk_ia32_psrawi256_mask";
            case 2763L: return "bfk_ia32_psrawi512";
            case 2764L: return "bfk_ia32_psrawi512_mask";
            case 2765L: return "bfk_ia32_psrld";
            case 2766L: return "bfk_ia32_psrld128";
            case 2767L: return "bfk_ia32_psrld128_mask";
            case 2768L: return "bfk_ia32_psrld256";
            case 2769L: return "bfk_ia32_psrld256_mask";
            case 2770L: return "bfk_ia32_psrld512";
            case 2771L: return "bfk_ia32_psrld512_mask";
            case 2772L: return "bfk_ia32_psrldi";
            case 2773L: return "bfk_ia32_psrldi128";
            case 2774L: return "bfk_ia32_psrldi128_mask";
            case 2775L: return "bfk_ia32_psrldi256";
            case 2776L: return "bfk_ia32_psrldi256_mask";
            case 2777L: return "bfk_ia32_psrldi512";
            case 2778L: return "bfk_ia32_psrldi512_mask";
            case 2779L: return "bfk_ia32_psrldq512";
            case 2780L: return "bfk_ia32_psrldqi128";
            case 2781L: return "bfk_ia32_psrldqi128_byteshift";
            case 2782L: return "bfk_ia32_psrldqi256";
            case 2783L: return "bfk_ia32_psrldqi256_byteshift";
            case 2784L: return "bfk_ia32_psrldqi512_byteshift";
            case 2785L: return "bfk_ia32_psrlq";
            case 2786L: return "bfk_ia32_psrlq128";
            case 2787L: return "bfk_ia32_psrlq128_mask";
            case 2788L: return "bfk_ia32_psrlq256";
            case 2789L: return "bfk_ia32_psrlq256_mask";
            case 2790L: return "bfk_ia32_psrlq512";
            case 2791L: return "bfk_ia32_psrlq512_mask";
            case 2792L: return "bfk_ia32_psrlqi";
            case 2793L: return "bfk_ia32_psrlqi128";
            case 2794L: return "bfk_ia32_psrlqi128_mask";
            case 2795L: return "bfk_ia32_psrlqi256";
            case 2796L: return "bfk_ia32_psrlqi256_mask";
            case 2797L: return "bfk_ia32_psrlqi512";
            case 2798L: return "bfk_ia32_psrlqi512_mask";
            case 2799L: return "bfk_ia32_psrlv16hi";
            case 2800L: return "bfk_ia32_psrlv16hi_mask";
            case 2801L: return "bfk_ia32_psrlv16si";
            case 2802L: return "bfk_ia32_psrlv16si_mask";
            case 2803L: return "bfk_ia32_psrlv2di";
            case 2804L: return "bfk_ia32_psrlv2di_mask";
            case 2805L: return "bfk_ia32_psrlv32hi";
            case 2806L: return "bfk_ia32_psrlv32hi_mask";
            case 2807L: return "bfk_ia32_psrlv4di";
            case 2808L: return "bfk_ia32_psrlv4di_mask";
            case 2809L: return "bfk_ia32_psrlv4si";
            case 2810L: return "bfk_ia32_psrlv4si_mask";
            case 2811L: return "bfk_ia32_psrlv8di";
            case 2812L: return "bfk_ia32_psrlv8di_mask";
            case 2813L: return "bfk_ia32_psrlv8hi";
            case 2814L: return "bfk_ia32_psrlv8hi_mask";
            case 2815L: return "bfk_ia32_psrlv8si";
            case 2816L: return "bfk_ia32_psrlv8si_mask";
            case 2817L: return "bfk_ia32_psrlw";
            case 2818L: return "bfk_ia32_psrlw128";
            case 2819L: return "bfk_ia32_psrlw128_mask";
            case 2820L: return "bfk_ia32_psrlw256";
            case 2821L: return "bfk_ia32_psrlw256_mask";
            case 2822L: return "bfk_ia32_psrlw512";
            case 2823L: return "bfk_ia32_psrlw512_mask";
            case 2824L: return "bfk_ia32_psrlwi";
            case 2825L: return "bfk_ia32_psrlwi128";
            case 2826L: return "bfk_ia32_psrlwi128_mask";
            case 2827L: return "bfk_ia32_psrlwi256";
            case 2828L: return "bfk_ia32_psrlwi256_mask";
            case 2829L: return "bfk_ia32_psrlwi512";
            case 2830L: return "bfk_ia32_psrlwi512_mask";
            case 2831L: return "bfk_ia32_psubb";
            case 2832L: return "bfk_ia32_psubb128";
            case 2833L: return "bfk_ia32_psubb128_mask";
            case 2834L: return "bfk_ia32_psubb256";
            case 2835L: return "bfk_ia32_psubb256_mask";
            case 2836L: return "bfk_ia32_psubb512_mask";
            case 2837L: return "bfk_ia32_psubd";
            case 2838L: return "bfk_ia32_psubd128";
            case 2839L: return "bfk_ia32_psubd128_mask";
            case 2840L: return "bfk_ia32_psubd256";
            case 2841L: return "bfk_ia32_psubd256_mask";
            case 2842L: return "bfk_ia32_psubd512_mask";
            case 2843L: return "bfk_ia32_psubq";
            case 2844L: return "bfk_ia32_psubq128";
            case 2845L: return "bfk_ia32_psubq128_mask";
            case 2846L: return "bfk_ia32_psubq256";
            case 2847L: return "bfk_ia32_psubq256_mask";
            case 2848L: return "bfk_ia32_psubq512_mask";
            case 2849L: return "bfk_ia32_psubsb";
            case 2850L: return "bfk_ia32_psubsb128";
            case 2851L: return "bfk_ia32_psubsb128_mask";
            case 2852L: return "bfk_ia32_psubsb256";
            case 2853L: return "bfk_ia32_psubsb256_mask";
            case 2854L: return "bfk_ia32_psubsb512";
            case 2855L: return "bfk_ia32_psubsb512_mask";
            case 2856L: return "bfk_ia32_psubsw";
            case 2857L: return "bfk_ia32_psubsw128";
            case 2858L: return "bfk_ia32_psubsw128_mask";
            case 2859L: return "bfk_ia32_psubsw256";
            case 2860L: return "bfk_ia32_psubsw256_mask";
            case 2861L: return "bfk_ia32_psubsw512";
            case 2862L: return "bfk_ia32_psubsw512_mask";
            case 2863L: return "bfk_ia32_psubusb";
            case 2864L: return "bfk_ia32_psubusb128";
            case 2865L: return "bfk_ia32_psubusb128_mask";
            case 2866L: return "bfk_ia32_psubusb256";
            case 2867L: return "bfk_ia32_psubusb256_mask";
            case 2868L: return "bfk_ia32_psubusb512";
            case 2869L: return "bfk_ia32_psubusb512_mask";
            case 2870L: return "bfk_ia32_psubusw";
            case 2871L: return "bfk_ia32_psubusw128";
            case 2872L: return "bfk_ia32_psubusw128_mask";
            case 2873L: return "bfk_ia32_psubusw256";
            case 2874L: return "bfk_ia32_psubusw256_mask";
            case 2875L: return "bfk_ia32_psubusw512";
            case 2876L: return "bfk_ia32_psubusw512_mask";
            case 2877L: return "bfk_ia32_psubw";
            case 2878L: return "bfk_ia32_psubw128";
            case 2879L: return "bfk_ia32_psubw128_mask";
            case 2880L: return "bfk_ia32_psubw256";
            case 2881L: return "bfk_ia32_psubw256_mask";
            case 2882L: return "bfk_ia32_psubw512_mask";
            case 2883L: return "bfk_ia32_pswapdsf";
            case 2884L: return "bfk_ia32_pswapdsi";
            case 2885L: return "bfk_ia32_pternlogd128_mask";
            case 2886L: return "bfk_ia32_pternlogd128_maskz";
            case 2887L: return "bfk_ia32_pternlogd256_mask";
            case 2888L: return "bfk_ia32_pternlogd256_maskz";
            case 2889L: return "bfk_ia32_pternlogd512_mask";
            case 2890L: return "bfk_ia32_pternlogd512_maskz";
            case 2891L: return "bfk_ia32_pternlogq128_mask";
            case 2892L: return "bfk_ia32_pternlogq128_maskz";
            case 2893L: return "bfk_ia32_pternlogq256_mask";
            case 2894L: return "bfk_ia32_pternlogq256_maskz";
            case 2895L: return "bfk_ia32_pternlogq512_mask";
            case 2896L: return "bfk_ia32_pternlogq512_maskz";
            case 2897L: return "bfk_ia32_ptestc128";
            case 2898L: return "bfk_ia32_ptestc256";
            case 2899L: return "bfk_ia32_ptestmb128";
            case 2900L: return "bfk_ia32_ptestmb256";
            case 2901L: return "bfk_ia32_ptestmb512";
            case 2902L: return "bfk_ia32_ptestmd128";
            case 2903L: return "bfk_ia32_ptestmd256";
            case 2904L: return "bfk_ia32_ptestmd512";
            case 2905L: return "bfk_ia32_ptestmq128";
            case 2906L: return "bfk_ia32_ptestmq256";
            case 2907L: return "bfk_ia32_ptestmq512";
            case 2908L: return "bfk_ia32_ptestmw128";
            case 2909L: return "bfk_ia32_ptestmw256";
            case 2910L: return "bfk_ia32_ptestmw512";
            case 2911L: return "bfk_ia32_ptestnmb128";
            case 2912L: return "bfk_ia32_ptestnmb256";
            case 2913L: return "bfk_ia32_ptestnmb512";
            case 2914L: return "bfk_ia32_ptestnmd128";
            case 2915L: return "bfk_ia32_ptestnmd256";
            case 2916L: return "bfk_ia32_ptestnmd512";
            case 2917L: return "bfk_ia32_ptestnmq128";
            case 2918L: return "bfk_ia32_ptestnmq256";
            case 2919L: return "bfk_ia32_ptestnmq512";
            case 2920L: return "bfk_ia32_ptestnmw128";
            case 2921L: return "bfk_ia32_ptestnmw256";
            case 2922L: return "bfk_ia32_ptestnmw512";
            case 2923L: return "bfk_ia32_ptestnzc128";
            case 2924L: return "bfk_ia32_ptestnzc256";
            case 2925L: return "bfk_ia32_ptestz128";
            case 2926L: return "bfk_ia32_ptestz256";
            case 2927L: return "bfk_ia32_ptwrite32";
            case 2928L: return "bfk_ia32_ptwrite64";
            case 2929L: return "bfk_ia32_punpckhbw";
            case 2930L: return "bfk_ia32_punpckhbw128";
            case 2931L: return "bfk_ia32_punpckhbw128_mask";
            case 2932L: return "bfk_ia32_punpckhbw256";
            case 2933L: return "bfk_ia32_punpckhbw256_mask";
            case 2934L: return "bfk_ia32_punpckhbw512_mask";
            case 2935L: return "bfk_ia32_punpckhdq";
            case 2936L: return "bfk_ia32_punpckhdq128";
            case 2937L: return "bfk_ia32_punpckhdq128_mask";
            case 2938L: return "bfk_ia32_punpckhdq256";
            case 2939L: return "bfk_ia32_punpckhdq256_mask";
            case 2940L: return "bfk_ia32_punpckhdq512_mask";
            case 2941L: return "bfk_ia32_punpckhqdq128";
            case 2942L: return "bfk_ia32_punpckhqdq128_mask";
            case 2943L: return "bfk_ia32_punpckhqdq256";
            case 2944L: return "bfk_ia32_punpckhqdq256_mask";
            case 2945L: return "bfk_ia32_punpckhqdq512_mask";
            case 2946L: return "bfk_ia32_punpckhwd";
            case 2947L: return "bfk_ia32_punpckhwd128";
            case 2948L: return "bfk_ia32_punpckhwd128_mask";
            case 2949L: return "bfk_ia32_punpckhwd256";
            case 2950L: return "bfk_ia32_punpckhwd256_mask";
            case 2951L: return "bfk_ia32_punpckhwd512_mask";
            case 2952L: return "bfk_ia32_punpcklbw";
            case 2953L: return "bfk_ia32_punpcklbw128";
            case 2954L: return "bfk_ia32_punpcklbw128_mask";
            case 2955L: return "bfk_ia32_punpcklbw256";
            case 2956L: return "bfk_ia32_punpcklbw256_mask";
            case 2957L: return "bfk_ia32_punpcklbw512_mask";
            case 2958L: return "bfk_ia32_punpckldq";
            case 2959L: return "bfk_ia32_punpckldq128";
            case 2960L: return "bfk_ia32_punpckldq128_mask";
            case 2961L: return "bfk_ia32_punpckldq256";
            case 2962L: return "bfk_ia32_punpckldq256_mask";
            case 2963L: return "bfk_ia32_punpckldq512_mask";
            case 2964L: return "bfk_ia32_punpcklqdq128";
            case 2965L: return "bfk_ia32_punpcklqdq128_mask";
            case 2966L: return "bfk_ia32_punpcklqdq256";
            case 2967L: return "bfk_ia32_punpcklqdq256_mask";
            case 2968L: return "bfk_ia32_punpcklqdq512_mask";
            case 2969L: return "bfk_ia32_punpcklwd";
            case 2970L: return "bfk_ia32_punpcklwd128";
            case 2971L: return "bfk_ia32_punpcklwd128_mask";
            case 2972L: return "bfk_ia32_punpcklwd256";
            case 2973L: return "bfk_ia32_punpcklwd256_mask";
            case 2974L: return "bfk_ia32_punpcklwd512_mask";
            case 2975L: return "bfk_ia32_pxor";
            case 2976L: return "bfk_ia32_pxor128";
            case 2977L: return "bfk_ia32_pxor256";
            case 2978L: return "bfk_ia32_pxord128_mask";
            case 2979L: return "bfk_ia32_pxord256_mask";
            case 2980L: return "bfk_ia32_pxord512_mask";
            case 2981L: return "bfk_ia32_pxorq128_mask";
            case 2982L: return "bfk_ia32_pxorq256_mask";
            case 2983L: return "bfk_ia32_pxorq512_mask";
            case 2984L: return "bfk_ia32_rangepd128_mask";
            case 2985L: return "bfk_ia32_rangepd256_mask";
            case 2986L: return "bfk_ia32_rangepd512_mask";
            case 2987L: return "bfk_ia32_rangeps128_mask";
            case 2988L: return "bfk_ia32_rangeps256_mask";
            case 2989L: return "bfk_ia32_rangeps512_mask";
            case 2990L: return "bfk_ia32_rangesd128_mask_round";
            case 2991L: return "bfk_ia32_rangesd128_round";
            case 2992L: return "bfk_ia32_rangesd128_round_mask";
            case 2993L: return "bfk_ia32_rangess128_mask_round";
            case 2994L: return "bfk_ia32_rangess128_round";
            case 2995L: return "bfk_ia32_rangess128_round_mask";
            case 2996L: return "bfk_ia32_rcp14pd128_mask";
            case 2997L: return "bfk_ia32_rcp14pd256_mask";
            case 2998L: return "bfk_ia32_rcp14pd512_mask";
            case 2999L: return "bfk_ia32_rcp14ps128_mask";
            case 3000L: return "bfk_ia32_rcp14ps256_mask";
            case 3001L: return "bfk_ia32_rcp14ps512_mask";
            case 3002L: return "bfk_ia32_rcp14sd";
            case 3003L: return "bfk_ia32_rcp14sd_mask";
            case 3004L: return "bfk_ia32_rcp14ss";
            case 3005L: return "bfk_ia32_rcp14ss_mask";
            case 3006L: return "bfk_ia32_rcp28pd_mask";
            case 3007L: return "bfk_ia32_rcp28ps_mask";
            case 3008L: return "bfk_ia32_rcp28sd_mask";
            case 3009L: return "bfk_ia32_rcp28sd_round";
            case 3010L: return "bfk_ia32_rcp28sd_round_mask";
            case 3011L: return "bfk_ia32_rcp28ss_mask";
            case 3012L: return "bfk_ia32_rcp28ss_round";
            case 3013L: return "bfk_ia32_rcp28ss_round_mask";
            case 3014L: return "bfk_ia32_rcpps";
            case 3015L: return "bfk_ia32_rcpps256";
            case 3016L: return "bfk_ia32_rcpss";
            case 3017L: return "bfk_ia32_rdfsbase32";
            case 3018L: return "bfk_ia32_rdfsbase64";
            case 3019L: return "bfk_ia32_rdgsbase32";
            case 3020L: return "bfk_ia32_rdgsbase64";
            case 3021L: return "bfk_ia32_rdpid";
            case 3022L: return "bfk_ia32_rdpkru";
            case 3023L: return "bfk_ia32_rdpmc";
            case 3024L: return "bfk_ia32_rdrand16_step";
            case 3025L: return "bfk_ia32_rdrand32_step";
            case 3026L: return "bfk_ia32_rdrand64_step";
            case 3027L: return "bfk_ia32_rdseed16_step";
            case 3028L: return "bfk_ia32_rdseed32_step";
            case 3029L: return "bfk_ia32_rdseed64_step";
            case 3030L: return "bfk_ia32_rdseed_di_step";
            case 3031L: return "bfk_ia32_rdseed_hi_step";
            case 3032L: return "bfk_ia32_rdseed_si_step";
            case 3033L: return "bfk_ia32_rdsspd";
            case 3034L: return "bfk_ia32_rdsspq";
            case 3035L: return "bfk_ia32_rdtsc";
            case 3036L: return "bfk_ia32_rdtscp";
            case 3037L: return "bfk_ia32_readeflags_u32";
            case 3038L: return "bfk_ia32_readeflags_u64";
            case 3039L: return "bfk_ia32_reducepd128_mask";
            case 3040L: return "bfk_ia32_reducepd256_mask";
            case 3041L: return "bfk_ia32_reducepd512_mask";
            case 3042L: return "bfk_ia32_reduceps128_mask";
            case 3043L: return "bfk_ia32_reduceps256_mask";
            case 3044L: return "bfk_ia32_reduceps512_mask";
            case 3045L: return "bfk_ia32_reducesd";
            case 3046L: return "bfk_ia32_reducesd_mask";
            case 3047L: return "bfk_ia32_reducess";
            case 3048L: return "bfk_ia32_reducess_mask";
            case 3049L: return "bfk_ia32_rintpd";
            case 3050L: return "bfk_ia32_rintpd256";
            case 3051L: return "bfk_ia32_rintps";
            case 3052L: return "bfk_ia32_rintps256";
            case 3053L: return "bfk_ia32_rndscalepd_128_mask";
            case 3054L: return "bfk_ia32_rndscalepd_256_mask";
            case 3055L: return "bfk_ia32_rndscalepd_mask";
            case 3056L: return "bfk_ia32_rndscaleps_128_mask";
            case 3057L: return "bfk_ia32_rndscaleps_256_mask";
            case 3058L: return "bfk_ia32_rndscaleps_mask";
            case 3059L: return "bfk_ia32_rndscalesd_round";
            case 3060L: return "bfk_ia32_rndscalesd_round_mask";
            case 3061L: return "bfk_ia32_rndscaless_round";
            case 3062L: return "bfk_ia32_rndscaless_round_mask";
            case 3063L: return "bfk_ia32_rolhi";
            case 3064L: return "bfk_ia32_rolqi";
            case 3065L: return "bfk_ia32_rorhi";
            case 3066L: return "bfk_ia32_rorqi";
            case 3067L: return "bfk_ia32_roundpd";
            case 3068L: return "bfk_ia32_roundpd256";
            case 3069L: return "bfk_ia32_roundpd_az";
            case 3070L: return "bfk_ia32_roundpd_az256";
            case 3071L: return "bfk_ia32_roundpd_az_vec_pack_sfix";
            case 3072L: return "bfk_ia32_roundpd_az_vec_pack_sfix256";
            case 3073L: return "bfk_ia32_roundpd_az_vec_pack_sfix512";
            case 3074L: return "bfk_ia32_roundps";
            case 3075L: return "bfk_ia32_roundps256";
            case 3076L: return "bfk_ia32_roundps_az";
            case 3077L: return "bfk_ia32_roundps_az256";
            case 3078L: return "bfk_ia32_roundps_az_sfix";
            case 3079L: return "bfk_ia32_roundps_az_sfix256";
            case 3080L: return "bfk_ia32_roundps_az_sfix512";
            case 3081L: return "bfk_ia32_roundsd";
            case 3082L: return "bfk_ia32_roundss";
            case 3083L: return "bfk_ia32_rsqrt14pd128_mask";
            case 3084L: return "bfk_ia32_rsqrt14pd256_mask";
            case 3085L: return "bfk_ia32_rsqrt14pd512_mask";
            case 3086L: return "bfk_ia32_rsqrt14ps128_mask";
            case 3087L: return "bfk_ia32_rsqrt14ps256_mask";
            case 3088L: return "bfk_ia32_rsqrt14ps512_mask";
            case 3089L: return "bfk_ia32_rsqrt14sd";
            case 3090L: return "bfk_ia32_rsqrt14sd_mask";
            case 3091L: return "bfk_ia32_rsqrt14ss";
            case 3092L: return "bfk_ia32_rsqrt14ss_mask";
            case 3093L: return "bfk_ia32_rsqrt28pd_mask";
            case 3094L: return "bfk_ia32_rsqrt28ps_mask";
            case 3095L: return "bfk_ia32_rsqrt28sd_mask";
            case 3096L: return "bfk_ia32_rsqrt28sd_round";
            case 3097L: return "bfk_ia32_rsqrt28sd_round_mask";
            case 3098L: return "bfk_ia32_rsqrt28ss_mask";
            case 3099L: return "bfk_ia32_rsqrt28ss_round";
            case 3100L: return "bfk_ia32_rsqrt28ss_round_mask";
            case 3101L: return "bfk_ia32_rsqrtf";
            case 3102L: return "bfk_ia32_rsqrtps";
            case 3103L: return "bfk_ia32_rsqrtps256";
            case 3104L: return "bfk_ia32_rsqrtps_nr";
            case 3105L: return "bfk_ia32_rsqrtps_nr256";
            case 3106L: return "bfk_ia32_rsqrtss";
            case 3107L: return "bfk_ia32_rstorssp";
            case 3108L: return "bfk_ia32_saveprevssp";
            case 3109L: return "bfk_ia32_sbb_u32";
            case 3110L: return "bfk_ia32_sbb_u64";
            case 3111L: return "bfk_ia32_scalefpd128_mask";
            case 3112L: return "bfk_ia32_scalefpd256_mask";
            case 3113L: return "bfk_ia32_scalefpd512_mask";
            case 3114L: return "bfk_ia32_scalefps128_mask";
            case 3115L: return "bfk_ia32_scalefps256_mask";
            case 3116L: return "bfk_ia32_scalefps512_mask";
            case 3117L: return "bfk_ia32_scalefsd_mask_round";
            case 3118L: return "bfk_ia32_scalefsd_round";
            case 3119L: return "bfk_ia32_scalefsd_round_mask";
            case 3120L: return "bfk_ia32_scalefss_mask_round";
            case 3121L: return "bfk_ia32_scalefss_round";
            case 3122L: return "bfk_ia32_scalefss_round_mask";
            case 3123L: return "bfk_ia32_scatteraltdiv16sf";
            case 3124L: return "bfk_ia32_scatteraltdiv16si";
            case 3125L: return "bfk_ia32_scatteraltdiv4sf";
            case 3126L: return "bfk_ia32_scatteraltdiv4si";
            case 3127L: return "bfk_ia32_scatteraltdiv8sf";
            case 3128L: return "bfk_ia32_scatteraltdiv8si";
            case 3129L: return "bfk_ia32_scatteraltsiv2df";
            case 3130L: return "bfk_ia32_scatteraltsiv2di";
            case 3131L: return "bfk_ia32_scatteraltsiv4df";
            case 3132L: return "bfk_ia32_scatteraltsiv4di";
            case 3133L: return "bfk_ia32_scatteraltsiv8df";
            case 3134L: return "bfk_ia32_scatteraltsiv8di";
            case 3135L: return "bfk_ia32_scatterdiv16sf";
            case 3136L: return "bfk_ia32_scatterdiv16si";
            case 3137L: return "bfk_ia32_scatterdiv2df";
            case 3138L: return "bfk_ia32_scatterdiv2di";
            case 3139L: return "bfk_ia32_scatterdiv4df";
            case 3140L: return "bfk_ia32_scatterdiv4di";
            case 3141L: return "bfk_ia32_scatterdiv4sf";
            case 3142L: return "bfk_ia32_scatterdiv4si";
            case 3143L: return "bfk_ia32_scatterdiv8df";
            case 3144L: return "bfk_ia32_scatterdiv8di";
            case 3145L: return "bfk_ia32_scatterdiv8sf";
            case 3146L: return "bfk_ia32_scatterdiv8si";
            case 3147L: return "bfk_ia32_scatterpfdpd";
            case 3148L: return "bfk_ia32_scatterpfdps";
            case 3149L: return "bfk_ia32_scatterpfqpd";
            case 3150L: return "bfk_ia32_scatterpfqps";
            case 3151L: return "bfk_ia32_scattersiv16sf";
            case 3152L: return "bfk_ia32_scattersiv16si";
            case 3153L: return "bfk_ia32_scattersiv2df";
            case 3154L: return "bfk_ia32_scattersiv2di";
            case 3155L: return "bfk_ia32_scattersiv4df";
            case 3156L: return "bfk_ia32_scattersiv4di";
            case 3157L: return "bfk_ia32_scattersiv4sf";
            case 3158L: return "bfk_ia32_scattersiv4si";
            case 3159L: return "bfk_ia32_scattersiv8df";
            case 3160L: return "bfk_ia32_scattersiv8di";
            case 3161L: return "bfk_ia32_scattersiv8sf";
            case 3162L: return "bfk_ia32_scattersiv8si";
            case 3163L: return "bfk_ia32_selectb_128";
            case 3164L: return "bfk_ia32_selectb_256";
            case 3165L: return "bfk_ia32_selectb_512";
            case 3166L: return "bfk_ia32_selectd_128";
            case 3167L: return "bfk_ia32_selectd_256";
            case 3168L: return "bfk_ia32_selectd_512";
            case 3169L: return "bfk_ia32_selectpd_128";
            case 3170L: return "bfk_ia32_selectpd_256";
            case 3171L: return "bfk_ia32_selectpd_512";
            case 3172L: return "bfk_ia32_selectps_128";
            case 3173L: return "bfk_ia32_selectps_256";
            case 3174L: return "bfk_ia32_selectps_512";
            case 3175L: return "bfk_ia32_selectq_128";
            case 3176L: return "bfk_ia32_selectq_256";
            case 3177L: return "bfk_ia32_selectq_512";
            case 3178L: return "bfk_ia32_selectsd_128";
            case 3179L: return "bfk_ia32_selectss_128";
            case 3180L: return "bfk_ia32_selectw_128";
            case 3181L: return "bfk_ia32_selectw_256";
            case 3182L: return "bfk_ia32_selectw_512";
            case 3183L: return "bfk_ia32_setssbsy";
            case 3184L: return "bfk_ia32_sfence";
            case 3185L: return "bfk_ia32_sha1msg1";
            case 3186L: return "bfk_ia32_sha1msg2";
            case 3187L: return "bfk_ia32_sha1nexte";
            case 3188L: return "bfk_ia32_sha1rnds4";
            case 3189L: return "bfk_ia32_sha256msg1";
            case 3190L: return "bfk_ia32_sha256msg2";
            case 3191L: return "bfk_ia32_sha256rnds2";
            case 3192L: return "bfk_ia32_shuf_f32x4";
            case 3193L: return "bfk_ia32_shuf_f32x4_256";
            case 3194L: return "bfk_ia32_shuf_f32x4_256_mask";
            case 3195L: return "bfk_ia32_shuf_f32x4_mask";
            case 3196L: return "bfk_ia32_shuf_f64x2";
            case 3197L: return "bfk_ia32_shuf_f64x2_256";
            case 3198L: return "bfk_ia32_shuf_f64x2_256_mask";
            case 3199L: return "bfk_ia32_shuf_f64x2_mask";
            case 3200L: return "bfk_ia32_shuf_i32x4";
            case 3201L: return "bfk_ia32_shuf_i32x4_256";
            case 3202L: return "bfk_ia32_shuf_i32x4_256_mask";
            case 3203L: return "bfk_ia32_shuf_i32x4_mask";
            case 3204L: return "bfk_ia32_shuf_i64x2";
            case 3205L: return "bfk_ia32_shuf_i64x2_256";
            case 3206L: return "bfk_ia32_shuf_i64x2_256_mask";
            case 3207L: return "bfk_ia32_shuf_i64x2_mask";
            case 3208L: return "bfk_ia32_shufpd";
            case 3209L: return "bfk_ia32_shufpd128_mask";
            case 3210L: return "bfk_ia32_shufpd256";
            case 3211L: return "bfk_ia32_shufpd256_mask";
            case 3212L: return "bfk_ia32_shufpd512";
            case 3213L: return "bfk_ia32_shufpd512_mask";
            case 3214L: return "bfk_ia32_shufps";
            case 3215L: return "bfk_ia32_shufps128_mask";
            case 3216L: return "bfk_ia32_shufps256";
            case 3217L: return "bfk_ia32_shufps256_mask";
            case 3218L: return "bfk_ia32_shufps512";
            case 3219L: return "bfk_ia32_shufps512_mask";
            case 3220L: return "bfk_ia32_si256_si";
            case 3221L: return "bfk_ia32_si512_256si";
            case 3222L: return "bfk_ia32_si512_si";
            case 3223L: return "bfk_ia32_si_si256";
            case 3224L: return "bfk_ia32_slwpcb";
            case 3225L: return "bfk_ia32_sqrtpd";
            case 3226L: return "bfk_ia32_sqrtpd128_mask";
            case 3227L: return "bfk_ia32_sqrtpd256";
            case 3228L: return "bfk_ia32_sqrtpd256_mask";
            case 3229L: return "bfk_ia32_sqrtpd512";
            case 3230L: return "bfk_ia32_sqrtpd512_mask";
            case 3231L: return "bfk_ia32_sqrtps";
            case 3232L: return "bfk_ia32_sqrtps128_mask";
            case 3233L: return "bfk_ia32_sqrtps256";
            case 3234L: return "bfk_ia32_sqrtps256_mask";
            case 3235L: return "bfk_ia32_sqrtps512";
            case 3236L: return "bfk_ia32_sqrtps512_mask";
            case 3237L: return "bfk_ia32_sqrtps_nr";
            case 3238L: return "bfk_ia32_sqrtps_nr256";
            case 3239L: return "bfk_ia32_sqrtsd";
            case 3240L: return "bfk_ia32_sqrtsd_mask_round";
            case 3241L: return "bfk_ia32_sqrtsd_round";
            case 3242L: return "bfk_ia32_sqrtsd_round_mask";
            case 3243L: return "bfk_ia32_sqrtss";
            case 3244L: return "bfk_ia32_sqrtss_mask_round";
            case 3245L: return "bfk_ia32_sqrtss_round";
            case 3246L: return "bfk_ia32_sqrtss_round_mask";
            case 3247L: return "bfk_ia32_stmxcsr";
            case 3248L: return "bfk_ia32_storeapd128_mask";
            case 3249L: return "bfk_ia32_storeapd256_mask";
            case 3250L: return "bfk_ia32_storeapd512_mask";
            case 3251L: return "bfk_ia32_storeaps";
            case 3252L: return "bfk_ia32_storeaps128_mask";
            case 3253L: return "bfk_ia32_storeaps256_mask";
            case 3254L: return "bfk_ia32_storeaps512_mask";
            case 3255L: return "bfk_ia32_storedqu";
            case 3256L: return "bfk_ia32_storedqu256";
            case 3257L: return "bfk_ia32_storedqudi128_mask";
            case 3258L: return "bfk_ia32_storedqudi256_mask";
            case 3259L: return "bfk_ia32_storedqudi512_mask";
            case 3260L: return "bfk_ia32_storedquhi128_mask";
            case 3261L: return "bfk_ia32_storedquhi256_mask";
            case 3262L: return "bfk_ia32_storedquhi512_mask";
            case 3263L: return "bfk_ia32_storedquqi128_mask";
            case 3264L: return "bfk_ia32_storedquqi256_mask";
            case 3265L: return "bfk_ia32_storedquqi512_mask";
            case 3266L: return "bfk_ia32_storedqusi128_mask";
            case 3267L: return "bfk_ia32_storedqusi256_mask";
            case 3268L: return "bfk_ia32_storedqusi512_mask";
            case 3269L: return "bfk_ia32_storehps";
            case 3270L: return "bfk_ia32_storelps";
            case 3271L: return "bfk_ia32_storesd128_mask";
            case 3272L: return "bfk_ia32_storesd_mask";
            case 3273L: return "bfk_ia32_storess";
            case 3274L: return "bfk_ia32_storess128_mask";
            case 3275L: return "bfk_ia32_storess_mask";
            case 3276L: return "bfk_ia32_storeupd";
            case 3277L: return "bfk_ia32_storeupd128_mask";
            case 3278L: return "bfk_ia32_storeupd256";
            case 3279L: return "bfk_ia32_storeupd256_mask";
            case 3280L: return "bfk_ia32_storeupd512_mask";
            case 3281L: return "bfk_ia32_storeups";
            case 3282L: return "bfk_ia32_storeups128_mask";
            case 3283L: return "bfk_ia32_storeups256";
            case 3284L: return "bfk_ia32_storeups256_mask";
            case 3285L: return "bfk_ia32_storeups512_mask";
            case 3286L: return "bfk_ia32_subborrow_u32";
            case 3287L: return "bfk_ia32_subborrow_u64";
            case 3288L: return "bfk_ia32_subpd";
            case 3289L: return "bfk_ia32_subpd128_mask";
            case 3290L: return "bfk_ia32_subpd256";
            case 3291L: return "bfk_ia32_subpd256_mask";
            case 3292L: return "bfk_ia32_subpd512";
            case 3293L: return "bfk_ia32_subpd512_mask";
            case 3294L: return "bfk_ia32_subps";
            case 3295L: return "bfk_ia32_subps128_mask";
            case 3296L: return "bfk_ia32_subps256";
            case 3297L: return "bfk_ia32_subps256_mask";
            case 3298L: return "bfk_ia32_subps512";
            case 3299L: return "bfk_ia32_subps512_mask";
            case 3300L: return "bfk_ia32_subsd";
            case 3301L: return "bfk_ia32_subsd_mask_round";
            case 3302L: return "bfk_ia32_subsd_round";
            case 3303L: return "bfk_ia32_subsd_round_mask";
            case 3304L: return "bfk_ia32_subss";
            case 3305L: return "bfk_ia32_subss_mask_round";
            case 3306L: return "bfk_ia32_subss_round";
            case 3307L: return "bfk_ia32_subss_round_mask";
            case 3308L: return "bfk_ia32_tpause";
            case 3309L: return "bfk_ia32_truncpd";
            case 3310L: return "bfk_ia32_truncpd256";
            case 3311L: return "bfk_ia32_truncpd512";
            case 3312L: return "bfk_ia32_truncps";
            case 3313L: return "bfk_ia32_truncps256";
            case 3314L: return "bfk_ia32_truncps512";
            case 3315L: return "bfk_ia32_tzcnt_u16";
            case 3316L: return "bfk_ia32_tzcnt_u32";
            case 3317L: return "bfk_ia32_tzcnt_u64";
            case 3318L: return "bfk_ia32_ucmpb128_mask";
            case 3319L: return "bfk_ia32_ucmpb256_mask";
            case 3320L: return "bfk_ia32_ucmpb512_mask";
            case 3321L: return "bfk_ia32_ucmpd128_mask";
            case 3322L: return "bfk_ia32_ucmpd256_mask";
            case 3323L: return "bfk_ia32_ucmpd512_mask";
            case 3324L: return "bfk_ia32_ucmpq128_mask";
            case 3325L: return "bfk_ia32_ucmpq256_mask";
            case 3326L: return "bfk_ia32_ucmpq512_mask";
            case 3327L: return "bfk_ia32_ucmpw128_mask";
            case 3328L: return "bfk_ia32_ucmpw256_mask";
            case 3329L: return "bfk_ia32_ucmpw512_mask";
            case 3330L: return "bfk_ia32_ucomieq";
            case 3331L: return "bfk_ia32_ucomige";
            case 3332L: return "bfk_ia32_ucomigt";
            case 3333L: return "bfk_ia32_ucomile";
            case 3334L: return "bfk_ia32_ucomilt";
            case 3335L: return "bfk_ia32_ucomineq";
            case 3336L: return "bfk_ia32_ucomisdeq";
            case 3337L: return "bfk_ia32_ucomisdge";
            case 3338L: return "bfk_ia32_ucomisdgt";
            case 3339L: return "bfk_ia32_ucomisdle";
            case 3340L: return "bfk_ia32_ucomisdlt";
            case 3341L: return "bfk_ia32_ucomisdneq";
            case 3342L: return "bfk_ia32_umonitor";
            case 3343L: return "bfk_ia32_umwait";
            case 3344L: return "bfk_ia32_undef128";
            case 3345L: return "bfk_ia32_undef256";
            case 3346L: return "bfk_ia32_undef512";
            case 3347L: return "bfk_ia32_unpckhpd";
            case 3348L: return "bfk_ia32_unpckhpd128_mask";
            case 3349L: return "bfk_ia32_unpckhpd256";
            case 3350L: return "bfk_ia32_unpckhpd256_mask";
            case 3351L: return "bfk_ia32_unpckhpd512_mask";
            case 3352L: return "bfk_ia32_unpckhps";
            case 3353L: return "bfk_ia32_unpckhps128_mask";
            case 3354L: return "bfk_ia32_unpckhps256";
            case 3355L: return "bfk_ia32_unpckhps256_mask";
            case 3356L: return "bfk_ia32_unpckhps512_mask";
            case 3357L: return "bfk_ia32_unpcklpd";
            case 3358L: return "bfk_ia32_unpcklpd128_mask";
            case 3359L: return "bfk_ia32_unpcklpd256";
            case 3360L: return "bfk_ia32_unpcklpd256_mask";
            case 3361L: return "bfk_ia32_unpcklpd512_mask";
            case 3362L: return "bfk_ia32_unpcklps";
            case 3363L: return "bfk_ia32_unpcklps128_mask";
            case 3364L: return "bfk_ia32_unpcklps256";
            case 3365L: return "bfk_ia32_unpcklps256_mask";
            case 3366L: return "bfk_ia32_unpcklps512_mask";
            case 3367L: return "bfk_ia32_vaesdec_v16qi";
            case 3368L: return "bfk_ia32_vaesdec_v32qi";
            case 3369L: return "bfk_ia32_vaesdec_v64qi";
            case 3370L: return "bfk_ia32_vaesdeclast_v16qi";
            case 3371L: return "bfk_ia32_vaesdeclast_v32qi";
            case 3372L: return "bfk_ia32_vaesdeclast_v64qi";
            case 3373L: return "bfk_ia32_vaesenc_v16qi";
            case 3374L: return "bfk_ia32_vaesenc_v32qi";
            case 3375L: return "bfk_ia32_vaesenc_v64qi";
            case 3376L: return "bfk_ia32_vaesenclast_v16qi";
            case 3377L: return "bfk_ia32_vaesenclast_v32qi";
            case 3378L: return "bfk_ia32_vaesenclast_v64qi";
            case 3379L: return "bfk_ia32_vbroadcastf128_pd256";
            case 3380L: return "bfk_ia32_vbroadcastf128_ps256";
            case 3381L: return "bfk_ia32_vbroadcastsd256";
            case 3382L: return "bfk_ia32_vbroadcastsd_pd256";
            case 3383L: return "bfk_ia32_vbroadcastsi256";
            case 3384L: return "bfk_ia32_vbroadcastss";
            case 3385L: return "bfk_ia32_vbroadcastss256";
            case 3386L: return "bfk_ia32_vbroadcastss_ps";
            case 3387L: return "bfk_ia32_vbroadcastss_ps256";
            case 3388L: return "bfk_ia32_vcomisd";
            case 3389L: return "bfk_ia32_vcomiss";
            case 3390L: return "bfk_ia32_vcvtph2ps";
            case 3391L: return "bfk_ia32_vcvtph2ps256";
            case 3392L: return "bfk_ia32_vcvtph2ps256_mask";
            case 3393L: return "bfk_ia32_vcvtph2ps512";
            case 3394L: return "bfk_ia32_vcvtph2ps512_mask";
            case 3395L: return "bfk_ia32_vcvtph2ps_mask";
            case 3396L: return "bfk_ia32_vcvtps2ph";
            case 3397L: return "bfk_ia32_vcvtps2ph256";
            case 3398L: return "bfk_ia32_vcvtps2ph256_mask";
            case 3399L: return "bfk_ia32_vcvtps2ph512";
            case 3400L: return "bfk_ia32_vcvtps2ph512_mask";
            case 3401L: return "bfk_ia32_vcvtps2ph_mask";
            case 3402L: return "bfk_ia32_vcvtsd2si32";
            case 3403L: return "bfk_ia32_vcvtsd2si64";
            case 3404L: return "bfk_ia32_vcvtsd2usi32";
            case 3405L: return "bfk_ia32_vcvtsd2usi64";
            case 3406L: return "bfk_ia32_vcvtss2si32";
            case 3407L: return "bfk_ia32_vcvtss2si64";
            case 3408L: return "bfk_ia32_vcvtss2usi32";
            case 3409L: return "bfk_ia32_vcvtss2usi64";
            case 3410L: return "bfk_ia32_vcvttsd2si32";
            case 3411L: return "bfk_ia32_vcvttsd2si64";
            case 3412L: return "bfk_ia32_vcvttsd2usi32";
            case 3413L: return "bfk_ia32_vcvttsd2usi64";
            case 3414L: return "bfk_ia32_vcvttss2si32";
            case 3415L: return "bfk_ia32_vcvttss2si64";
            case 3416L: return "bfk_ia32_vcvttss2usi32";
            case 3417L: return "bfk_ia32_vcvttss2usi64";
            case 3418L: return "bfk_ia32_vec_ext_v16hi";
            case 3419L: return "bfk_ia32_vec_ext_v16qi";
            case 3420L: return "bfk_ia32_vec_ext_v2df";
            case 3421L: return "bfk_ia32_vec_ext_v2di";
            case 3422L: return "bfk_ia32_vec_ext_v2si";
            case 3423L: return "bfk_ia32_vec_ext_v32qi";
            case 3424L: return "bfk_ia32_vec_ext_v4di";
            case 3425L: return "bfk_ia32_vec_ext_v4hi";
            case 3426L: return "bfk_ia32_vec_ext_v4sf";
            case 3427L: return "bfk_ia32_vec_ext_v4si";
            case 3428L: return "bfk_ia32_vec_ext_v8hi";
            case 3429L: return "bfk_ia32_vec_ext_v8si";
            case 3430L: return "bfk_ia32_vec_init_v2si";
            case 3431L: return "bfk_ia32_vec_init_v4hi";
            case 3432L: return "bfk_ia32_vec_init_v8qi";
            case 3433L: return "bfk_ia32_vec_pack_sfix";
            case 3434L: return "bfk_ia32_vec_pack_sfix256";
            case 3435L: return "bfk_ia32_vec_pack_sfix512";
            case 3436L: return "bfk_ia32_vec_perm_v16qi";
            case 3437L: return "bfk_ia32_vec_perm_v16qi_u";
            case 3438L: return "bfk_ia32_vec_perm_v2df";
            case 3439L: return "bfk_ia32_vec_perm_v2di";
            case 3440L: return "bfk_ia32_vec_perm_v2di_u";
            case 3441L: return "bfk_ia32_vec_perm_v4df";
            case 3442L: return "bfk_ia32_vec_perm_v4sf";
            case 3443L: return "bfk_ia32_vec_perm_v4si";
            case 3444L: return "bfk_ia32_vec_perm_v4si_u";
            case 3445L: return "bfk_ia32_vec_perm_v8hi";
            case 3446L: return "bfk_ia32_vec_perm_v8hi_u";
            case 3447L: return "bfk_ia32_vec_perm_v8sf";
            case 3448L: return "bfk_ia32_vec_set_v16hi";
            case 3449L: return "bfk_ia32_vec_set_v16qi";
            case 3450L: return "bfk_ia32_vec_set_v2di";
            case 3451L: return "bfk_ia32_vec_set_v32qi";
            case 3452L: return "bfk_ia32_vec_set_v4di";
            case 3453L: return "bfk_ia32_vec_set_v4hi";
            case 3454L: return "bfk_ia32_vec_set_v4sf";
            case 3455L: return "bfk_ia32_vec_set_v4si";
            case 3456L: return "bfk_ia32_vec_set_v8hi";
            case 3457L: return "bfk_ia32_vec_set_v8si";
            case 3458L: return "bfk_ia32_vextractf128_pd256";
            case 3459L: return "bfk_ia32_vextractf128_ps256";
            case 3460L: return "bfk_ia32_vextractf128_si256";
            case 3461L: return "bfk_ia32_vfmaddpd";
            case 3462L: return "bfk_ia32_vfmaddpd128_mask";
            case 3463L: return "bfk_ia32_vfmaddpd128_mask3";
            case 3464L: return "bfk_ia32_vfmaddpd128_maskz";
            case 3465L: return "bfk_ia32_vfmaddpd256";
            case 3466L: return "bfk_ia32_vfmaddpd256_mask";
            case 3467L: return "bfk_ia32_vfmaddpd256_mask3";
            case 3468L: return "bfk_ia32_vfmaddpd256_maskz";
            case 3469L: return "bfk_ia32_vfmaddpd512_mask";
            case 3470L: return "bfk_ia32_vfmaddpd512_mask3";
            case 3471L: return "bfk_ia32_vfmaddpd512_maskz";
            case 3472L: return "bfk_ia32_vfmaddps";
            case 3473L: return "bfk_ia32_vfmaddps128_mask";
            case 3474L: return "bfk_ia32_vfmaddps128_mask3";
            case 3475L: return "bfk_ia32_vfmaddps128_maskz";
            case 3476L: return "bfk_ia32_vfmaddps256";
            case 3477L: return "bfk_ia32_vfmaddps256_mask";
            case 3478L: return "bfk_ia32_vfmaddps256_mask3";
            case 3479L: return "bfk_ia32_vfmaddps256_maskz";
            case 3480L: return "bfk_ia32_vfmaddps512_mask";
            case 3481L: return "bfk_ia32_vfmaddps512_mask3";
            case 3482L: return "bfk_ia32_vfmaddps512_maskz";
            case 3483L: return "bfk_ia32_vfmaddsd";
            case 3484L: return "bfk_ia32_vfmaddsd3";
            case 3485L: return "bfk_ia32_vfmaddsd3_mask";
            case 3486L: return "bfk_ia32_vfmaddsd3_mask3";
            case 3487L: return "bfk_ia32_vfmaddsd3_maskz";
            case 3488L: return "bfk_ia32_vfmaddsd3_round";
            case 3489L: return "bfk_ia32_vfmaddss";
            case 3490L: return "bfk_ia32_vfmaddss3";
            case 3491L: return "bfk_ia32_vfmaddss3_mask";
            case 3492L: return "bfk_ia32_vfmaddss3_mask3";
            case 3493L: return "bfk_ia32_vfmaddss3_maskz";
            case 3494L: return "bfk_ia32_vfmaddss3_round";
            case 3495L: return "bfk_ia32_vfmaddsubpd";
            case 3496L: return "bfk_ia32_vfmaddsubpd128_mask";
            case 3497L: return "bfk_ia32_vfmaddsubpd128_mask3";
            case 3498L: return "bfk_ia32_vfmaddsubpd128_maskz";
            case 3499L: return "bfk_ia32_vfmaddsubpd256";
            case 3500L: return "bfk_ia32_vfmaddsubpd256_mask";
            case 3501L: return "bfk_ia32_vfmaddsubpd256_mask3";
            case 3502L: return "bfk_ia32_vfmaddsubpd256_maskz";
            case 3503L: return "bfk_ia32_vfmaddsubpd512_mask";
            case 3504L: return "bfk_ia32_vfmaddsubpd512_mask3";
            case 3505L: return "bfk_ia32_vfmaddsubpd512_maskz";
            case 3506L: return "bfk_ia32_vfmaddsubps";
            case 3507L: return "bfk_ia32_vfmaddsubps128_mask";
            case 3508L: return "bfk_ia32_vfmaddsubps128_mask3";
            case 3509L: return "bfk_ia32_vfmaddsubps128_maskz";
            case 3510L: return "bfk_ia32_vfmaddsubps256";
            case 3511L: return "bfk_ia32_vfmaddsubps256_mask";
            case 3512L: return "bfk_ia32_vfmaddsubps256_mask3";
            case 3513L: return "bfk_ia32_vfmaddsubps256_maskz";
            case 3514L: return "bfk_ia32_vfmaddsubps512_mask";
            case 3515L: return "bfk_ia32_vfmaddsubps512_mask3";
            case 3516L: return "bfk_ia32_vfmaddsubps512_maskz";
            case 3517L: return "bfk_ia32_vfmsubaddpd";
            case 3518L: return "bfk_ia32_vfmsubaddpd128_mask3";
            case 3519L: return "bfk_ia32_vfmsubaddpd256";
            case 3520L: return "bfk_ia32_vfmsubaddpd256_mask3";
            case 3521L: return "bfk_ia32_vfmsubaddpd512_mask3";
            case 3522L: return "bfk_ia32_vfmsubaddps";
            case 3523L: return "bfk_ia32_vfmsubaddps128_mask3";
            case 3524L: return "bfk_ia32_vfmsubaddps256";
            case 3525L: return "bfk_ia32_vfmsubaddps256_mask3";
            case 3526L: return "bfk_ia32_vfmsubaddps512_mask3";
            case 3527L: return "bfk_ia32_vfmsubpd";
            case 3528L: return "bfk_ia32_vfmsubpd128_mask";
            case 3529L: return "bfk_ia32_vfmsubpd128_mask3";
            case 3530L: return "bfk_ia32_vfmsubpd128_maskz";
            case 3531L: return "bfk_ia32_vfmsubpd256";
            case 3532L: return "bfk_ia32_vfmsubpd256_mask";
            case 3533L: return "bfk_ia32_vfmsubpd256_mask3";
            case 3534L: return "bfk_ia32_vfmsubpd256_maskz";
            case 3535L: return "bfk_ia32_vfmsubpd512_mask";
            case 3536L: return "bfk_ia32_vfmsubpd512_mask3";
            case 3537L: return "bfk_ia32_vfmsubpd512_maskz";
            case 3538L: return "bfk_ia32_vfmsubps";
            case 3539L: return "bfk_ia32_vfmsubps128_mask";
            case 3540L: return "bfk_ia32_vfmsubps128_mask3";
            case 3541L: return "bfk_ia32_vfmsubps128_maskz";
            case 3542L: return "bfk_ia32_vfmsubps256";
            case 3543L: return "bfk_ia32_vfmsubps256_mask";
            case 3544L: return "bfk_ia32_vfmsubps256_mask3";
            case 3545L: return "bfk_ia32_vfmsubps256_maskz";
            case 3546L: return "bfk_ia32_vfmsubps512_mask";
            case 3547L: return "bfk_ia32_vfmsubps512_mask3";
            case 3548L: return "bfk_ia32_vfmsubps512_maskz";
            case 3549L: return "bfk_ia32_vfmsubsd";
            case 3550L: return "bfk_ia32_vfmsubsd3";
            case 3551L: return "bfk_ia32_vfmsubsd3_mask3";
            case 3552L: return "bfk_ia32_vfmsubss";
            case 3553L: return "bfk_ia32_vfmsubss3";
            case 3554L: return "bfk_ia32_vfmsubss3_mask3";
            case 3555L: return "bfk_ia32_vfnmaddpd";
            case 3556L: return "bfk_ia32_vfnmaddpd128_mask";
            case 3557L: return "bfk_ia32_vfnmaddpd128_mask3";
            case 3558L: return "bfk_ia32_vfnmaddpd128_maskz";
            case 3559L: return "bfk_ia32_vfnmaddpd256";
            case 3560L: return "bfk_ia32_vfnmaddpd256_mask";
            case 3561L: return "bfk_ia32_vfnmaddpd256_mask3";
            case 3562L: return "bfk_ia32_vfnmaddpd256_maskz";
            case 3563L: return "bfk_ia32_vfnmaddpd512_mask";
            case 3564L: return "bfk_ia32_vfnmaddpd512_mask3";
            case 3565L: return "bfk_ia32_vfnmaddpd512_maskz";
            case 3566L: return "bfk_ia32_vfnmaddps";
            case 3567L: return "bfk_ia32_vfnmaddps128_mask";
            case 3568L: return "bfk_ia32_vfnmaddps128_mask3";
            case 3569L: return "bfk_ia32_vfnmaddps128_maskz";
            case 3570L: return "bfk_ia32_vfnmaddps256";
            case 3571L: return "bfk_ia32_vfnmaddps256_mask";
            case 3572L: return "bfk_ia32_vfnmaddps256_mask3";
            case 3573L: return "bfk_ia32_vfnmaddps256_maskz";
            case 3574L: return "bfk_ia32_vfnmaddps512_mask";
            case 3575L: return "bfk_ia32_vfnmaddps512_mask3";
            case 3576L: return "bfk_ia32_vfnmaddps512_maskz";
            case 3577L: return "bfk_ia32_vfnmaddsd";
            case 3578L: return "bfk_ia32_vfnmaddsd3";
            case 3579L: return "bfk_ia32_vfnmaddss";
            case 3580L: return "bfk_ia32_vfnmaddss3";
            case 3581L: return "bfk_ia32_vfnmsubpd";
            case 3582L: return "bfk_ia32_vfnmsubpd128_mask";
            case 3583L: return "bfk_ia32_vfnmsubpd128_mask3";
            case 3584L: return "bfk_ia32_vfnmsubpd128_maskz";
            case 3585L: return "bfk_ia32_vfnmsubpd256";
            case 3586L: return "bfk_ia32_vfnmsubpd256_mask";
            case 3587L: return "bfk_ia32_vfnmsubpd256_mask3";
            case 3588L: return "bfk_ia32_vfnmsubpd256_maskz";
            case 3589L: return "bfk_ia32_vfnmsubpd512_mask";
            case 3590L: return "bfk_ia32_vfnmsubpd512_mask3";
            case 3591L: return "bfk_ia32_vfnmsubpd512_maskz";
            case 3592L: return "bfk_ia32_vfnmsubps";
            case 3593L: return "bfk_ia32_vfnmsubps128_mask";
            case 3594L: return "bfk_ia32_vfnmsubps128_mask3";
            case 3595L: return "bfk_ia32_vfnmsubps128_maskz";
            case 3596L: return "bfk_ia32_vfnmsubps256";
            case 3597L: return "bfk_ia32_vfnmsubps256_mask";
            case 3598L: return "bfk_ia32_vfnmsubps256_mask3";
            case 3599L: return "bfk_ia32_vfnmsubps256_maskz";
            case 3600L: return "bfk_ia32_vfnmsubps512_mask";
            case 3601L: return "bfk_ia32_vfnmsubps512_mask3";
            case 3602L: return "bfk_ia32_vfnmsubps512_maskz";
            case 3603L: return "bfk_ia32_vfnmsubsd";
            case 3604L: return "bfk_ia32_vfnmsubsd3";
            case 3605L: return "bfk_ia32_vfnmsubsd3_mask3";
            case 3606L: return "bfk_ia32_vfnmsubss";
            case 3607L: return "bfk_ia32_vfnmsubss3";
            case 3608L: return "bfk_ia32_vfnmsubss3_mask3";
            case 3609L: return "bfk_ia32_vfrczpd";
            case 3610L: return "bfk_ia32_vfrczpd256";
            case 3611L: return "bfk_ia32_vfrczps";
            case 3612L: return "bfk_ia32_vfrczps256";
            case 3613L: return "bfk_ia32_vfrczsd";
            case 3614L: return "bfk_ia32_vfrczss";
            case 3615L: return "bfk_ia32_vgf2p8affineinvqb_v16qi";
            case 3616L: return "bfk_ia32_vgf2p8affineinvqb_v16qi_mask";
            case 3617L: return "bfk_ia32_vgf2p8affineinvqb_v32qi";
            case 3618L: return "bfk_ia32_vgf2p8affineinvqb_v32qi_mask";
            case 3619L: return "bfk_ia32_vgf2p8affineinvqb_v64qi";
            case 3620L: return "bfk_ia32_vgf2p8affineinvqb_v64qi_mask";
            case 3621L: return "bfk_ia32_vgf2p8affineqb_v16qi";
            case 3622L: return "bfk_ia32_vgf2p8affineqb_v16qi_mask";
            case 3623L: return "bfk_ia32_vgf2p8affineqb_v32qi";
            case 3624L: return "bfk_ia32_vgf2p8affineqb_v32qi_mask";
            case 3625L: return "bfk_ia32_vgf2p8affineqb_v64qi";
            case 3626L: return "bfk_ia32_vgf2p8affineqb_v64qi_mask";
            case 3627L: return "bfk_ia32_vgf2p8mulb_v16qi";
            case 3628L: return "bfk_ia32_vgf2p8mulb_v16qi_mask";
            case 3629L: return "bfk_ia32_vgf2p8mulb_v32qi";
            case 3630L: return "bfk_ia32_vgf2p8mulb_v32qi_mask";
            case 3631L: return "bfk_ia32_vgf2p8mulb_v64qi";
            case 3632L: return "bfk_ia32_vgf2p8mulb_v64qi_mask";
            case 3633L: return "bfk_ia32_vinsertf128_pd256";
            case 3634L: return "bfk_ia32_vinsertf128_ps256";
            case 3635L: return "bfk_ia32_vinsertf128_si256";
            case 3636L: return "bfk_ia32_vp2intersect_d_128";
            case 3637L: return "bfk_ia32_vp2intersect_d_256";
            case 3638L: return "bfk_ia32_vp2intersect_d_512";
            case 3639L: return "bfk_ia32_vp2intersect_q_128";
            case 3640L: return "bfk_ia32_vp2intersect_q_256";
            case 3641L: return "bfk_ia32_vp2intersect_q_512";
            case 3642L: return "bfk_ia32_vp4dpwssd";
            case 3643L: return "bfk_ia32_vp4dpwssd_mask";
            case 3644L: return "bfk_ia32_vp4dpwssds";
            case 3645L: return "bfk_ia32_vp4dpwssds_mask";
            case 3646L: return "bfk_ia32_vpclmulqdq_v2di";
            case 3647L: return "bfk_ia32_vpclmulqdq_v4di";
            case 3648L: return "bfk_ia32_vpclmulqdq_v8di";
            case 3649L: return "bfk_ia32_vpcmov";
            case 3650L: return "bfk_ia32_vpcmov256";
            case 3651L: return "bfk_ia32_vpcmov_256";
            case 3652L: return "bfk_ia32_vpcmov_v16hi256";
            case 3653L: return "bfk_ia32_vpcmov_v16qi";
            case 3654L: return "bfk_ia32_vpcmov_v2df";
            case 3655L: return "bfk_ia32_vpcmov_v2di";
            case 3656L: return "bfk_ia32_vpcmov_v32qi256";
            case 3657L: return "bfk_ia32_vpcmov_v4df256";
            case 3658L: return "bfk_ia32_vpcmov_v4di256";
            case 3659L: return "bfk_ia32_vpcmov_v4sf";
            case 3660L: return "bfk_ia32_vpcmov_v4si";
            case 3661L: return "bfk_ia32_vpcmov_v8hi";
            case 3662L: return "bfk_ia32_vpcmov_v8sf256";
            case 3663L: return "bfk_ia32_vpcmov_v8si256";
            case 3664L: return "bfk_ia32_vpcomb";
            case 3665L: return "bfk_ia32_vpcomd";
            case 3666L: return "bfk_ia32_vpcomeqb";
            case 3667L: return "bfk_ia32_vpcomeqd";
            case 3668L: return "bfk_ia32_vpcomeqq";
            case 3669L: return "bfk_ia32_vpcomequb";
            case 3670L: return "bfk_ia32_vpcomequd";
            case 3671L: return "bfk_ia32_vpcomequq";
            case 3672L: return "bfk_ia32_vpcomequw";
            case 3673L: return "bfk_ia32_vpcomeqw";
            case 3674L: return "bfk_ia32_vpcomfalseb";
            case 3675L: return "bfk_ia32_vpcomfalsed";
            case 3676L: return "bfk_ia32_vpcomfalseq";
            case 3677L: return "bfk_ia32_vpcomfalseub";
            case 3678L: return "bfk_ia32_vpcomfalseud";
            case 3679L: return "bfk_ia32_vpcomfalseuq";
            case 3680L: return "bfk_ia32_vpcomfalseuw";
            case 3681L: return "bfk_ia32_vpcomfalsew";
            case 3682L: return "bfk_ia32_vpcomgeb";
            case 3683L: return "bfk_ia32_vpcomged";
            case 3684L: return "bfk_ia32_vpcomgeq";
            case 3685L: return "bfk_ia32_vpcomgeub";
            case 3686L: return "bfk_ia32_vpcomgeud";
            case 3687L: return "bfk_ia32_vpcomgeuq";
            case 3688L: return "bfk_ia32_vpcomgeuw";
            case 3689L: return "bfk_ia32_vpcomgew";
            case 3690L: return "bfk_ia32_vpcomgtb";
            case 3691L: return "bfk_ia32_vpcomgtd";
            case 3692L: return "bfk_ia32_vpcomgtq";
            case 3693L: return "bfk_ia32_vpcomgtub";
            case 3694L: return "bfk_ia32_vpcomgtud";
            case 3695L: return "bfk_ia32_vpcomgtuq";
            case 3696L: return "bfk_ia32_vpcomgtuw";
            case 3697L: return "bfk_ia32_vpcomgtw";
            case 3698L: return "bfk_ia32_vpcomleb";
            case 3699L: return "bfk_ia32_vpcomled";
            case 3700L: return "bfk_ia32_vpcomleq";
            case 3701L: return "bfk_ia32_vpcomleub";
            case 3702L: return "bfk_ia32_vpcomleud";
            case 3703L: return "bfk_ia32_vpcomleuq";
            case 3704L: return "bfk_ia32_vpcomleuw";
            case 3705L: return "bfk_ia32_vpcomlew";
            case 3706L: return "bfk_ia32_vpcomltb";
            case 3707L: return "bfk_ia32_vpcomltd";
            case 3708L: return "bfk_ia32_vpcomltq";
            case 3709L: return "bfk_ia32_vpcomltub";
            case 3710L: return "bfk_ia32_vpcomltud";
            case 3711L: return "bfk_ia32_vpcomltuq";
            case 3712L: return "bfk_ia32_vpcomltuw";
            case 3713L: return "bfk_ia32_vpcomltw";
            case 3714L: return "bfk_ia32_vpcomneb";
            case 3715L: return "bfk_ia32_vpcomned";
            case 3716L: return "bfk_ia32_vpcomneq";
            case 3717L: return "bfk_ia32_vpcomneqb";
            case 3718L: return "bfk_ia32_vpcomneqd";
            case 3719L: return "bfk_ia32_vpcomneqq";
            case 3720L: return "bfk_ia32_vpcomnequb";
            case 3721L: return "bfk_ia32_vpcomnequd";
            case 3722L: return "bfk_ia32_vpcomnequq";
            case 3723L: return "bfk_ia32_vpcomnequw";
            case 3724L: return "bfk_ia32_vpcomneqw";
            case 3725L: return "bfk_ia32_vpcomneub";
            case 3726L: return "bfk_ia32_vpcomneud";
            case 3727L: return "bfk_ia32_vpcomneuq";
            case 3728L: return "bfk_ia32_vpcomneuw";
            case 3729L: return "bfk_ia32_vpcomnew";
            case 3730L: return "bfk_ia32_vpcomq";
            case 3731L: return "bfk_ia32_vpcomtrueb";
            case 3732L: return "bfk_ia32_vpcomtrued";
            case 3733L: return "bfk_ia32_vpcomtrueq";
            case 3734L: return "bfk_ia32_vpcomtrueub";
            case 3735L: return "bfk_ia32_vpcomtrueud";
            case 3736L: return "bfk_ia32_vpcomtrueuq";
            case 3737L: return "bfk_ia32_vpcomtrueuw";
            case 3738L: return "bfk_ia32_vpcomtruew";
            case 3739L: return "bfk_ia32_vpcomub";
            case 3740L: return "bfk_ia32_vpcomud";
            case 3741L: return "bfk_ia32_vpcomuq";
            case 3742L: return "bfk_ia32_vpcomuw";
            case 3743L: return "bfk_ia32_vpcomw";
            case 3744L: return "bfk_ia32_vpconflictdi_128";
            case 3745L: return "bfk_ia32_vpconflictdi_128_mask";
            case 3746L: return "bfk_ia32_vpconflictdi_256";
            case 3747L: return "bfk_ia32_vpconflictdi_256_mask";
            case 3748L: return "bfk_ia32_vpconflictdi_512";
            case 3749L: return "bfk_ia32_vpconflictdi_512_mask";
            case 3750L: return "bfk_ia32_vpconflictsi_128";
            case 3751L: return "bfk_ia32_vpconflictsi_128_mask";
            case 3752L: return "bfk_ia32_vpconflictsi_256";
            case 3753L: return "bfk_ia32_vpconflictsi_256_mask";
            case 3754L: return "bfk_ia32_vpconflictsi_512";
            case 3755L: return "bfk_ia32_vpconflictsi_512_mask";
            case 3756L: return "bfk_ia32_vpdpbusd128";
            case 3757L: return "bfk_ia32_vpdpbusd128_mask";
            case 3758L: return "bfk_ia32_vpdpbusd128_maskz";
            case 3759L: return "bfk_ia32_vpdpbusd256";
            case 3760L: return "bfk_ia32_vpdpbusd256_mask";
            case 3761L: return "bfk_ia32_vpdpbusd256_maskz";
            case 3762L: return "bfk_ia32_vpdpbusd512";
            case 3763L: return "bfk_ia32_vpdpbusd512_mask";
            case 3764L: return "bfk_ia32_vpdpbusd512_maskz";
            case 3765L: return "bfk_ia32_vpdpbusd_v16si";
            case 3766L: return "bfk_ia32_vpdpbusd_v16si_mask";
            case 3767L: return "bfk_ia32_vpdpbusd_v16si_maskz";
            case 3768L: return "bfk_ia32_vpdpbusd_v4si";
            case 3769L: return "bfk_ia32_vpdpbusd_v4si_mask";
            case 3770L: return "bfk_ia32_vpdpbusd_v4si_maskz";
            case 3771L: return "bfk_ia32_vpdpbusd_v8si";
            case 3772L: return "bfk_ia32_vpdpbusd_v8si_mask";
            case 3773L: return "bfk_ia32_vpdpbusd_v8si_maskz";
            case 3774L: return "bfk_ia32_vpdpbusds128";
            case 3775L: return "bfk_ia32_vpdpbusds128_mask";
            case 3776L: return "bfk_ia32_vpdpbusds128_maskz";
            case 3777L: return "bfk_ia32_vpdpbusds256";
            case 3778L: return "bfk_ia32_vpdpbusds256_mask";
            case 3779L: return "bfk_ia32_vpdpbusds256_maskz";
            case 3780L: return "bfk_ia32_vpdpbusds512";
            case 3781L: return "bfk_ia32_vpdpbusds512_mask";
            case 3782L: return "bfk_ia32_vpdpbusds512_maskz";
            case 3783L: return "bfk_ia32_vpdpbusds_v16si";
            case 3784L: return "bfk_ia32_vpdpbusds_v16si_mask";
            case 3785L: return "bfk_ia32_vpdpbusds_v16si_maskz";
            case 3786L: return "bfk_ia32_vpdpbusds_v4si";
            case 3787L: return "bfk_ia32_vpdpbusds_v4si_mask";
            case 3788L: return "bfk_ia32_vpdpbusds_v4si_maskz";
            case 3789L: return "bfk_ia32_vpdpbusds_v8si";
            case 3790L: return "bfk_ia32_vpdpbusds_v8si_mask";
            case 3791L: return "bfk_ia32_vpdpbusds_v8si_maskz";
            case 3792L: return "bfk_ia32_vpdpwssd128";
            case 3793L: return "bfk_ia32_vpdpwssd128_mask";
            case 3794L: return "bfk_ia32_vpdpwssd128_maskz";
            case 3795L: return "bfk_ia32_vpdpwssd256";
            case 3796L: return "bfk_ia32_vpdpwssd256_mask";
            case 3797L: return "bfk_ia32_vpdpwssd256_maskz";
            case 3798L: return "bfk_ia32_vpdpwssd512";
            case 3799L: return "bfk_ia32_vpdpwssd512_mask";
            case 3800L: return "bfk_ia32_vpdpwssd512_maskz";
            case 3801L: return "bfk_ia32_vpdpwssd_v16si";
            case 3802L: return "bfk_ia32_vpdpwssd_v16si_mask";
            case 3803L: return "bfk_ia32_vpdpwssd_v16si_maskz";
            case 3804L: return "bfk_ia32_vpdpwssd_v4si";
            case 3805L: return "bfk_ia32_vpdpwssd_v4si_mask";
            case 3806L: return "bfk_ia32_vpdpwssd_v4si_maskz";
            case 3807L: return "bfk_ia32_vpdpwssd_v8si";
            case 3808L: return "bfk_ia32_vpdpwssd_v8si_mask";
            case 3809L: return "bfk_ia32_vpdpwssd_v8si_maskz";
            case 3810L: return "bfk_ia32_vpdpwssds128";
            case 3811L: return "bfk_ia32_vpdpwssds128_mask";
            case 3812L: return "bfk_ia32_vpdpwssds128_maskz";
            case 3813L: return "bfk_ia32_vpdpwssds256";
            case 3814L: return "bfk_ia32_vpdpwssds256_mask";
            case 3815L: return "bfk_ia32_vpdpwssds256_maskz";
            case 3816L: return "bfk_ia32_vpdpwssds512";
            case 3817L: return "bfk_ia32_vpdpwssds512_mask";
            case 3818L: return "bfk_ia32_vpdpwssds512_maskz";
            case 3819L: return "bfk_ia32_vpdpwssds_v16si";
            case 3820L: return "bfk_ia32_vpdpwssds_v16si_mask";
            case 3821L: return "bfk_ia32_vpdpwssds_v16si_maskz";
            case 3822L: return "bfk_ia32_vpdpwssds_v4si";
            case 3823L: return "bfk_ia32_vpdpwssds_v4si_mask";
            case 3824L: return "bfk_ia32_vpdpwssds_v4si_maskz";
            case 3825L: return "bfk_ia32_vpdpwssds_v8si";
            case 3826L: return "bfk_ia32_vpdpwssds_v8si_mask";
            case 3827L: return "bfk_ia32_vpdpwssds_v8si_maskz";
            case 3828L: return "bfk_ia32_vperm2f128_pd256";
            case 3829L: return "bfk_ia32_vperm2f128_ps256";
            case 3830L: return "bfk_ia32_vperm2f128_si256";
            case 3831L: return "bfk_ia32_vpermi2vard128";
            case 3832L: return "bfk_ia32_vpermi2vard128_mask";
            case 3833L: return "bfk_ia32_vpermi2vard256";
            case 3834L: return "bfk_ia32_vpermi2vard256_mask";
            case 3835L: return "bfk_ia32_vpermi2vard512";
            case 3836L: return "bfk_ia32_vpermi2vard512_mask";
            case 3837L: return "bfk_ia32_vpermi2varhi128";
            case 3838L: return "bfk_ia32_vpermi2varhi128_mask";
            case 3839L: return "bfk_ia32_vpermi2varhi256";
            case 3840L: return "bfk_ia32_vpermi2varhi256_mask";
            case 3841L: return "bfk_ia32_vpermi2varhi512";
            case 3842L: return "bfk_ia32_vpermi2varhi512_mask";
            case 3843L: return "bfk_ia32_vpermi2varpd128";
            case 3844L: return "bfk_ia32_vpermi2varpd128_mask";
            case 3845L: return "bfk_ia32_vpermi2varpd256";
            case 3846L: return "bfk_ia32_vpermi2varpd256_mask";
            case 3847L: return "bfk_ia32_vpermi2varpd512";
            case 3848L: return "bfk_ia32_vpermi2varpd512_mask";
            case 3849L: return "bfk_ia32_vpermi2varps128";
            case 3850L: return "bfk_ia32_vpermi2varps128_mask";
            case 3851L: return "bfk_ia32_vpermi2varps256";
            case 3852L: return "bfk_ia32_vpermi2varps256_mask";
            case 3853L: return "bfk_ia32_vpermi2varps512";
            case 3854L: return "bfk_ia32_vpermi2varps512_mask";
            case 3855L: return "bfk_ia32_vpermi2varq128";
            case 3856L: return "bfk_ia32_vpermi2varq128_mask";
            case 3857L: return "bfk_ia32_vpermi2varq256";
            case 3858L: return "bfk_ia32_vpermi2varq256_mask";
            case 3859L: return "bfk_ia32_vpermi2varq512";
            case 3860L: return "bfk_ia32_vpermi2varq512_mask";
            case 3861L: return "bfk_ia32_vpermi2varqi128";
            case 3862L: return "bfk_ia32_vpermi2varqi128_mask";
            case 3863L: return "bfk_ia32_vpermi2varqi256";
            case 3864L: return "bfk_ia32_vpermi2varqi256_mask";
            case 3865L: return "bfk_ia32_vpermi2varqi512";
            case 3866L: return "bfk_ia32_vpermi2varqi512_mask";
            case 3867L: return "bfk_ia32_vpermil2pd";
            case 3868L: return "bfk_ia32_vpermil2pd256";
            case 3869L: return "bfk_ia32_vpermil2ps";
            case 3870L: return "bfk_ia32_vpermil2ps256";
            case 3871L: return "bfk_ia32_vpermilpd";
            case 3872L: return "bfk_ia32_vpermilpd256";
            case 3873L: return "bfk_ia32_vpermilpd256_mask";
            case 3874L: return "bfk_ia32_vpermilpd512";
            case 3875L: return "bfk_ia32_vpermilpd512_mask";
            case 3876L: return "bfk_ia32_vpermilpd_mask";
            case 3877L: return "bfk_ia32_vpermilps";
            case 3878L: return "bfk_ia32_vpermilps256";
            case 3879L: return "bfk_ia32_vpermilps256_mask";
            case 3880L: return "bfk_ia32_vpermilps512";
            case 3881L: return "bfk_ia32_vpermilps512_mask";
            case 3882L: return "bfk_ia32_vpermilps_mask";
            case 3883L: return "bfk_ia32_vpermilvarpd";
            case 3884L: return "bfk_ia32_vpermilvarpd256";
            case 3885L: return "bfk_ia32_vpermilvarpd256_mask";
            case 3886L: return "bfk_ia32_vpermilvarpd512";
            case 3887L: return "bfk_ia32_vpermilvarpd512_mask";
            case 3888L: return "bfk_ia32_vpermilvarpd_mask";
            case 3889L: return "bfk_ia32_vpermilvarps";
            case 3890L: return "bfk_ia32_vpermilvarps256";
            case 3891L: return "bfk_ia32_vpermilvarps256_mask";
            case 3892L: return "bfk_ia32_vpermilvarps512";
            case 3893L: return "bfk_ia32_vpermilvarps512_mask";
            case 3894L: return "bfk_ia32_vpermilvarps_mask";
            case 3895L: return "bfk_ia32_vpermt2vard128_mask";
            case 3896L: return "bfk_ia32_vpermt2vard128_maskz";
            case 3897L: return "bfk_ia32_vpermt2vard256_mask";
            case 3898L: return "bfk_ia32_vpermt2vard256_maskz";
            case 3899L: return "bfk_ia32_vpermt2vard512_mask";
            case 3900L: return "bfk_ia32_vpermt2vard512_maskz";
            case 3901L: return "bfk_ia32_vpermt2varhi128_mask";
            case 3902L: return "bfk_ia32_vpermt2varhi128_maskz";
            case 3903L: return "bfk_ia32_vpermt2varhi256_mask";
            case 3904L: return "bfk_ia32_vpermt2varhi256_maskz";
            case 3905L: return "bfk_ia32_vpermt2varhi512_mask";
            case 3906L: return "bfk_ia32_vpermt2varhi512_maskz";
            case 3907L: return "bfk_ia32_vpermt2varpd128_mask";
            case 3908L: return "bfk_ia32_vpermt2varpd128_maskz";
            case 3909L: return "bfk_ia32_vpermt2varpd256_mask";
            case 3910L: return "bfk_ia32_vpermt2varpd256_maskz";
            case 3911L: return "bfk_ia32_vpermt2varpd512_mask";
            case 3912L: return "bfk_ia32_vpermt2varpd512_maskz";
            case 3913L: return "bfk_ia32_vpermt2varps128_mask";
            case 3914L: return "bfk_ia32_vpermt2varps128_maskz";
            case 3915L: return "bfk_ia32_vpermt2varps256_mask";
            case 3916L: return "bfk_ia32_vpermt2varps256_maskz";
            case 3917L: return "bfk_ia32_vpermt2varps512_mask";
            case 3918L: return "bfk_ia32_vpermt2varps512_maskz";
            case 3919L: return "bfk_ia32_vpermt2varq128_mask";
            case 3920L: return "bfk_ia32_vpermt2varq128_maskz";
            case 3921L: return "bfk_ia32_vpermt2varq256_mask";
            case 3922L: return "bfk_ia32_vpermt2varq256_maskz";
            case 3923L: return "bfk_ia32_vpermt2varq512_mask";
            case 3924L: return "bfk_ia32_vpermt2varq512_maskz";
            case 3925L: return "bfk_ia32_vpermt2varqi128_mask";
            case 3926L: return "bfk_ia32_vpermt2varqi128_maskz";
            case 3927L: return "bfk_ia32_vpermt2varqi256_mask";
            case 3928L: return "bfk_ia32_vpermt2varqi256_maskz";
            case 3929L: return "bfk_ia32_vpermt2varqi512_mask";
            case 3930L: return "bfk_ia32_vpermt2varqi512_maskz";
            case 3931L: return "bfk_ia32_vphaddbd";
            case 3932L: return "bfk_ia32_vphaddbq";
            case 3933L: return "bfk_ia32_vphaddbw";
            case 3934L: return "bfk_ia32_vphadddq";
            case 3935L: return "bfk_ia32_vphaddubd";
            case 3936L: return "bfk_ia32_vphaddubq";
            case 3937L: return "bfk_ia32_vphaddubw";
            case 3938L: return "bfk_ia32_vphaddudq";
            case 3939L: return "bfk_ia32_vphadduwd";
            case 3940L: return "bfk_ia32_vphadduwq";
            case 3941L: return "bfk_ia32_vphaddwd";
            case 3942L: return "bfk_ia32_vphaddwq";
            case 3943L: return "bfk_ia32_vphsubbw";
            case 3944L: return "bfk_ia32_vphsubdq";
            case 3945L: return "bfk_ia32_vphsubwd";
            case 3946L: return "bfk_ia32_vplzcntd_128";
            case 3947L: return "bfk_ia32_vplzcntd_128_mask";
            case 3948L: return "bfk_ia32_vplzcntd_256";
            case 3949L: return "bfk_ia32_vplzcntd_256_mask";
            case 3950L: return "bfk_ia32_vplzcntd_512";
            case 3951L: return "bfk_ia32_vplzcntd_512_mask";
            case 3952L: return "bfk_ia32_vplzcntq_128";
            case 3953L: return "bfk_ia32_vplzcntq_128_mask";
            case 3954L: return "bfk_ia32_vplzcntq_256";
            case 3955L: return "bfk_ia32_vplzcntq_256_mask";
            case 3956L: return "bfk_ia32_vplzcntq_512";
            case 3957L: return "bfk_ia32_vplzcntq_512_mask";
            case 3958L: return "bfk_ia32_vpmacsdd";
            case 3959L: return "bfk_ia32_vpmacsdqh";
            case 3960L: return "bfk_ia32_vpmacsdql";
            case 3961L: return "bfk_ia32_vpmacssdd";
            case 3962L: return "bfk_ia32_vpmacssdqh";
            case 3963L: return "bfk_ia32_vpmacssdql";
            case 3964L: return "bfk_ia32_vpmacsswd";
            case 3965L: return "bfk_ia32_vpmacssww";
            case 3966L: return "bfk_ia32_vpmacswd";
            case 3967L: return "bfk_ia32_vpmacsww";
            case 3968L: return "bfk_ia32_vpmadcsswd";
            case 3969L: return "bfk_ia32_vpmadcswd";
            case 3970L: return "bfk_ia32_vpmadd52huq128";
            case 3971L: return "bfk_ia32_vpmadd52huq128_mask";
            case 3972L: return "bfk_ia32_vpmadd52huq128_maskz";
            case 3973L: return "bfk_ia32_vpmadd52huq256";
            case 3974L: return "bfk_ia32_vpmadd52huq256_mask";
            case 3975L: return "bfk_ia32_vpmadd52huq256_maskz";
            case 3976L: return "bfk_ia32_vpmadd52huq512";
            case 3977L: return "bfk_ia32_vpmadd52huq512_mask";
            case 3978L: return "bfk_ia32_vpmadd52huq512_maskz";
            case 3979L: return "bfk_ia32_vpmadd52luq128";
            case 3980L: return "bfk_ia32_vpmadd52luq128_mask";
            case 3981L: return "bfk_ia32_vpmadd52luq128_maskz";
            case 3982L: return "bfk_ia32_vpmadd52luq256";
            case 3983L: return "bfk_ia32_vpmadd52luq256_mask";
            case 3984L: return "bfk_ia32_vpmadd52luq256_maskz";
            case 3985L: return "bfk_ia32_vpmadd52luq512";
            case 3986L: return "bfk_ia32_vpmadd52luq512_mask";
            case 3987L: return "bfk_ia32_vpmadd52luq512_maskz";
            case 3988L: return "bfk_ia32_vpmultishiftqb128";
            case 3989L: return "bfk_ia32_vpmultishiftqb128_mask";
            case 3990L: return "bfk_ia32_vpmultishiftqb256";
            case 3991L: return "bfk_ia32_vpmultishiftqb256_mask";
            case 3992L: return "bfk_ia32_vpmultishiftqb512";
            case 3993L: return "bfk_ia32_vpmultishiftqb512_mask";
            case 3994L: return "bfk_ia32_vpopcntb_128";
            case 3995L: return "bfk_ia32_vpopcntb_256";
            case 3996L: return "bfk_ia32_vpopcntb_512";
            case 3997L: return "bfk_ia32_vpopcntd_128";
            case 3998L: return "bfk_ia32_vpopcntd_256";
            case 3999L: return "bfk_ia32_vpopcntd_512";
            case 4000L: return "bfk_ia32_vpopcntq_128";
            case 4001L: return "bfk_ia32_vpopcntq_256";
            case 4002L: return "bfk_ia32_vpopcntq_512";
            case 4003L: return "bfk_ia32_vpopcntw_128";
            case 4004L: return "bfk_ia32_vpopcntw_256";
            case 4005L: return "bfk_ia32_vpopcntw_512";
            case 4006L: return "bfk_ia32_vpopcountb_v16qi";
            case 4007L: return "bfk_ia32_vpopcountb_v16qi_mask";
            case 4008L: return "bfk_ia32_vpopcountb_v32qi";
            case 4009L: return "bfk_ia32_vpopcountb_v32qi_mask";
            case 4010L: return "bfk_ia32_vpopcountb_v64qi";
            case 4011L: return "bfk_ia32_vpopcountb_v64qi_mask";
            case 4012L: return "bfk_ia32_vpopcountd_v16si";
            case 4013L: return "bfk_ia32_vpopcountd_v16si_mask";
            case 4014L: return "bfk_ia32_vpopcountd_v4si";
            case 4015L: return "bfk_ia32_vpopcountd_v4si_mask";
            case 4016L: return "bfk_ia32_vpopcountd_v8si";
            case 4017L: return "bfk_ia32_vpopcountd_v8si_mask";
            case 4018L: return "bfk_ia32_vpopcountq_v2di";
            case 4019L: return "bfk_ia32_vpopcountq_v2di_mask";
            case 4020L: return "bfk_ia32_vpopcountq_v4di";
            case 4021L: return "bfk_ia32_vpopcountq_v4di_mask";
            case 4022L: return "bfk_ia32_vpopcountq_v8di";
            case 4023L: return "bfk_ia32_vpopcountq_v8di_mask";
            case 4024L: return "bfk_ia32_vpopcountw_v16hi";
            case 4025L: return "bfk_ia32_vpopcountw_v16hi_mask";
            case 4026L: return "bfk_ia32_vpopcountw_v32hi";
            case 4027L: return "bfk_ia32_vpopcountw_v32hi_mask";
            case 4028L: return "bfk_ia32_vpopcountw_v8hi";
            case 4029L: return "bfk_ia32_vpopcountw_v8hi_mask";
            case 4030L: return "bfk_ia32_vpperm";
            case 4031L: return "bfk_ia32_vprotb";
            case 4032L: return "bfk_ia32_vprotbi";
            case 4033L: return "bfk_ia32_vprotd";
            case 4034L: return "bfk_ia32_vprotdi";
            case 4035L: return "bfk_ia32_vprotq";
            case 4036L: return "bfk_ia32_vprotqi";
            case 4037L: return "bfk_ia32_vprotw";
            case 4038L: return "bfk_ia32_vprotwi";
            case 4039L: return "bfk_ia32_vpshab";
            case 4040L: return "bfk_ia32_vpshad";
            case 4041L: return "bfk_ia32_vpshaq";
            case 4042L: return "bfk_ia32_vpshaw";
            case 4043L: return "bfk_ia32_vpshlb";
            case 4044L: return "bfk_ia32_vpshld";
            case 4045L: return "bfk_ia32_vpshld_v16hi";
            case 4046L: return "bfk_ia32_vpshld_v16hi_mask";
            case 4047L: return "bfk_ia32_vpshld_v16si";
            case 4048L: return "bfk_ia32_vpshld_v16si_mask";
            case 4049L: return "bfk_ia32_vpshld_v2di";
            case 4050L: return "bfk_ia32_vpshld_v2di_mask";
            case 4051L: return "bfk_ia32_vpshld_v32hi";
            case 4052L: return "bfk_ia32_vpshld_v32hi_mask";
            case 4053L: return "bfk_ia32_vpshld_v4di";
            case 4054L: return "bfk_ia32_vpshld_v4di_mask";
            case 4055L: return "bfk_ia32_vpshld_v4si";
            case 4056L: return "bfk_ia32_vpshld_v4si_mask";
            case 4057L: return "bfk_ia32_vpshld_v8di";
            case 4058L: return "bfk_ia32_vpshld_v8di_mask";
            case 4059L: return "bfk_ia32_vpshld_v8hi";
            case 4060L: return "bfk_ia32_vpshld_v8hi_mask";
            case 4061L: return "bfk_ia32_vpshld_v8si";
            case 4062L: return "bfk_ia32_vpshld_v8si_mask";
            case 4063L: return "bfk_ia32_vpshldd128";
            case 4064L: return "bfk_ia32_vpshldd128_mask";
            case 4065L: return "bfk_ia32_vpshldd256";
            case 4066L: return "bfk_ia32_vpshldd256_mask";
            case 4067L: return "bfk_ia32_vpshldd512";
            case 4068L: return "bfk_ia32_vpshldd512_mask";
            case 4069L: return "bfk_ia32_vpshldq128";
            case 4070L: return "bfk_ia32_vpshldq128_mask";
            case 4071L: return "bfk_ia32_vpshldq256";
            case 4072L: return "bfk_ia32_vpshldq256_mask";
            case 4073L: return "bfk_ia32_vpshldq512";
            case 4074L: return "bfk_ia32_vpshldq512_mask";
            case 4075L: return "bfk_ia32_vpshldv_v16hi";
            case 4076L: return "bfk_ia32_vpshldv_v16hi_mask";
            case 4077L: return "bfk_ia32_vpshldv_v16hi_maskz";
            case 4078L: return "bfk_ia32_vpshldv_v16si";
            case 4079L: return "bfk_ia32_vpshldv_v16si_mask";
            case 4080L: return "bfk_ia32_vpshldv_v16si_maskz";
            case 4081L: return "bfk_ia32_vpshldv_v2di";
            case 4082L: return "bfk_ia32_vpshldv_v2di_mask";
            case 4083L: return "bfk_ia32_vpshldv_v2di_maskz";
            case 4084L: return "bfk_ia32_vpshldv_v32hi";
            case 4085L: return "bfk_ia32_vpshldv_v32hi_mask";
            case 4086L: return "bfk_ia32_vpshldv_v32hi_maskz";
            case 4087L: return "bfk_ia32_vpshldv_v4di";
            case 4088L: return "bfk_ia32_vpshldv_v4di_mask";
            case 4089L: return "bfk_ia32_vpshldv_v4di_maskz";
            case 4090L: return "bfk_ia32_vpshldv_v4si";
            case 4091L: return "bfk_ia32_vpshldv_v4si_mask";
            case 4092L: return "bfk_ia32_vpshldv_v4si_maskz";
            case 4093L: return "bfk_ia32_vpshldv_v8di";
            case 4094L: return "bfk_ia32_vpshldv_v8di_mask";
            case 4095L: return "bfk_ia32_vpshldv_v8di_maskz";
            case 4096L: return "bfk_ia32_vpshldv_v8hi";
            case 4097L: return "bfk_ia32_vpshldv_v8hi_mask";
            case 4098L: return "bfk_ia32_vpshldv_v8hi_maskz";
            case 4099L: return "bfk_ia32_vpshldv_v8si";
            case 4100L: return "bfk_ia32_vpshldv_v8si_mask";
            case 4101L: return "bfk_ia32_vpshldv_v8si_maskz";
            case 4102L: return "bfk_ia32_vpshldvd128";
            case 4103L: return "bfk_ia32_vpshldvd128_mask";
            case 4104L: return "bfk_ia32_vpshldvd128_maskz";
            case 4105L: return "bfk_ia32_vpshldvd256";
            case 4106L: return "bfk_ia32_vpshldvd256_mask";
            case 4107L: return "bfk_ia32_vpshldvd256_maskz";
            case 4108L: return "bfk_ia32_vpshldvd512";
            case 4109L: return "bfk_ia32_vpshldvd512_mask";
            case 4110L: return "bfk_ia32_vpshldvd512_maskz";
            case 4111L: return "bfk_ia32_vpshldvq128";
            case 4112L: return "bfk_ia32_vpshldvq128_mask";
            case 4113L: return "bfk_ia32_vpshldvq128_maskz";
            case 4114L: return "bfk_ia32_vpshldvq256";
            case 4115L: return "bfk_ia32_vpshldvq256_mask";
            case 4116L: return "bfk_ia32_vpshldvq256_maskz";
            case 4117L: return "bfk_ia32_vpshldvq512";
            case 4118L: return "bfk_ia32_vpshldvq512_mask";
            case 4119L: return "bfk_ia32_vpshldvq512_maskz";
            case 4120L: return "bfk_ia32_vpshldvw128";
            case 4121L: return "bfk_ia32_vpshldvw128_mask";
            case 4122L: return "bfk_ia32_vpshldvw128_maskz";
            case 4123L: return "bfk_ia32_vpshldvw256";
            case 4124L: return "bfk_ia32_vpshldvw256_mask";
            case 4125L: return "bfk_ia32_vpshldvw256_maskz";
            case 4126L: return "bfk_ia32_vpshldvw512";
            case 4127L: return "bfk_ia32_vpshldvw512_mask";
            case 4128L: return "bfk_ia32_vpshldvw512_maskz";
            case 4129L: return "bfk_ia32_vpshldw128";
            case 4130L: return "bfk_ia32_vpshldw128_mask";
            case 4131L: return "bfk_ia32_vpshldw256";
            case 4132L: return "bfk_ia32_vpshldw256_mask";
            case 4133L: return "bfk_ia32_vpshldw512";
            case 4134L: return "bfk_ia32_vpshldw512_mask";
            case 4135L: return "bfk_ia32_vpshlq";
            case 4136L: return "bfk_ia32_vpshlw";
            case 4137L: return "bfk_ia32_vpshrd_v16hi";
            case 4138L: return "bfk_ia32_vpshrd_v16hi_mask";
            case 4139L: return "bfk_ia32_vpshrd_v16si";
            case 4140L: return "bfk_ia32_vpshrd_v16si_mask";
            case 4141L: return "bfk_ia32_vpshrd_v2di";
            case 4142L: return "bfk_ia32_vpshrd_v2di_mask";
            case 4143L: return "bfk_ia32_vpshrd_v32hi";
            case 4144L: return "bfk_ia32_vpshrd_v32hi_mask";
            case 4145L: return "bfk_ia32_vpshrd_v4di";
            case 4146L: return "bfk_ia32_vpshrd_v4di_mask";
            case 4147L: return "bfk_ia32_vpshrd_v4si";
            case 4148L: return "bfk_ia32_vpshrd_v4si_mask";
            case 4149L: return "bfk_ia32_vpshrd_v8di";
            case 4150L: return "bfk_ia32_vpshrd_v8di_mask";
            case 4151L: return "bfk_ia32_vpshrd_v8hi";
            case 4152L: return "bfk_ia32_vpshrd_v8hi_mask";
            case 4153L: return "bfk_ia32_vpshrd_v8si";
            case 4154L: return "bfk_ia32_vpshrd_v8si_mask";
            case 4155L: return "bfk_ia32_vpshrdd128";
            case 4156L: return "bfk_ia32_vpshrdd128_mask";
            case 4157L: return "bfk_ia32_vpshrdd256";
            case 4158L: return "bfk_ia32_vpshrdd256_mask";
            case 4159L: return "bfk_ia32_vpshrdd512";
            case 4160L: return "bfk_ia32_vpshrdd512_mask";
            case 4161L: return "bfk_ia32_vpshrdq128";
            case 4162L: return "bfk_ia32_vpshrdq128_mask";
            case 4163L: return "bfk_ia32_vpshrdq256";
            case 4164L: return "bfk_ia32_vpshrdq256_mask";
            case 4165L: return "bfk_ia32_vpshrdq512";
            case 4166L: return "bfk_ia32_vpshrdq512_mask";
            case 4167L: return "bfk_ia32_vpshrdv_v16hi";
            case 4168L: return "bfk_ia32_vpshrdv_v16hi_mask";
            case 4169L: return "bfk_ia32_vpshrdv_v16hi_maskz";
            case 4170L: return "bfk_ia32_vpshrdv_v16si";
            case 4171L: return "bfk_ia32_vpshrdv_v16si_mask";
            case 4172L: return "bfk_ia32_vpshrdv_v16si_maskz";
            case 4173L: return "bfk_ia32_vpshrdv_v2di";
            case 4174L: return "bfk_ia32_vpshrdv_v2di_mask";
            case 4175L: return "bfk_ia32_vpshrdv_v2di_maskz";
            case 4176L: return "bfk_ia32_vpshrdv_v32hi";
            case 4177L: return "bfk_ia32_vpshrdv_v32hi_mask";
            case 4178L: return "bfk_ia32_vpshrdv_v32hi_maskz";
            case 4179L: return "bfk_ia32_vpshrdv_v4di";
            case 4180L: return "bfk_ia32_vpshrdv_v4di_mask";
            case 4181L: return "bfk_ia32_vpshrdv_v4di_maskz";
            case 4182L: return "bfk_ia32_vpshrdv_v4si";
            case 4183L: return "bfk_ia32_vpshrdv_v4si_mask";
            case 4184L: return "bfk_ia32_vpshrdv_v4si_maskz";
            case 4185L: return "bfk_ia32_vpshrdv_v8di";
            case 4186L: return "bfk_ia32_vpshrdv_v8di_mask";
            case 4187L: return "bfk_ia32_vpshrdv_v8di_maskz";
            case 4188L: return "bfk_ia32_vpshrdv_v8hi";
            case 4189L: return "bfk_ia32_vpshrdv_v8hi_mask";
            case 4190L: return "bfk_ia32_vpshrdv_v8hi_maskz";
            case 4191L: return "bfk_ia32_vpshrdv_v8si";
            case 4192L: return "bfk_ia32_vpshrdv_v8si_mask";
            case 4193L: return "bfk_ia32_vpshrdv_v8si_maskz";
            case 4194L: return "bfk_ia32_vpshrdvd128";
            case 4195L: return "bfk_ia32_vpshrdvd128_mask";
            case 4196L: return "bfk_ia32_vpshrdvd128_maskz";
            case 4197L: return "bfk_ia32_vpshrdvd256";
            case 4198L: return "bfk_ia32_vpshrdvd256_mask";
            case 4199L: return "bfk_ia32_vpshrdvd256_maskz";
            case 4200L: return "bfk_ia32_vpshrdvd512";
            case 4201L: return "bfk_ia32_vpshrdvd512_mask";
            case 4202L: return "bfk_ia32_vpshrdvd512_maskz";
            case 4203L: return "bfk_ia32_vpshrdvq128";
            case 4204L: return "bfk_ia32_vpshrdvq128_mask";
            case 4205L: return "bfk_ia32_vpshrdvq128_maskz";
            case 4206L: return "bfk_ia32_vpshrdvq256";
            case 4207L: return "bfk_ia32_vpshrdvq256_mask";
            case 4208L: return "bfk_ia32_vpshrdvq256_maskz";
            case 4209L: return "bfk_ia32_vpshrdvq512";
            case 4210L: return "bfk_ia32_vpshrdvq512_mask";
            case 4211L: return "bfk_ia32_vpshrdvq512_maskz";
            case 4212L: return "bfk_ia32_vpshrdvw128";
            case 4213L: return "bfk_ia32_vpshrdvw128_mask";
            case 4214L: return "bfk_ia32_vpshrdvw128_maskz";
            case 4215L: return "bfk_ia32_vpshrdvw256";
            case 4216L: return "bfk_ia32_vpshrdvw256_mask";
            case 4217L: return "bfk_ia32_vpshrdvw256_maskz";
            case 4218L: return "bfk_ia32_vpshrdvw512";
            case 4219L: return "bfk_ia32_vpshrdvw512_mask";
            case 4220L: return "bfk_ia32_vpshrdvw512_maskz";
            case 4221L: return "bfk_ia32_vpshrdw128";
            case 4222L: return "bfk_ia32_vpshrdw128_mask";
            case 4223L: return "bfk_ia32_vpshrdw256";
            case 4224L: return "bfk_ia32_vpshrdw256_mask";
            case 4225L: return "bfk_ia32_vpshrdw512";
            case 4226L: return "bfk_ia32_vpshrdw512_mask";
            case 4227L: return "bfk_ia32_vpshufbitqmb128_mask";
            case 4228L: return "bfk_ia32_vpshufbitqmb256_mask";
            case 4229L: return "bfk_ia32_vpshufbitqmb512_mask";
            case 4230L: return "bfk_ia32_vtestcpd";
            case 4231L: return "bfk_ia32_vtestcpd256";
            case 4232L: return "bfk_ia32_vtestcps";
            case 4233L: return "bfk_ia32_vtestcps256";
            case 4234L: return "bfk_ia32_vtestnzcpd";
            case 4235L: return "bfk_ia32_vtestnzcpd256";
            case 4236L: return "bfk_ia32_vtestnzcps";
            case 4237L: return "bfk_ia32_vtestnzcps256";
            case 4238L: return "bfk_ia32_vtestzpd";
            case 4239L: return "bfk_ia32_vtestzpd256";
            case 4240L: return "bfk_ia32_vtestzps";
            case 4241L: return "bfk_ia32_vtestzps256";
            case 4242L: return "bfk_ia32_vzeroall";
            case 4243L: return "bfk_ia32_vzeroupper";
            case 4244L: return "bfk_ia32_wbinvd";
            case 4245L: return "bfk_ia32_wbnoinvd";
            case 4246L: return "bfk_ia32_wrfsbase32";
            case 4247L: return "bfk_ia32_wrfsbase64";
            case 4248L: return "bfk_ia32_wrgsbase32";
            case 4249L: return "bfk_ia32_wrgsbase64";
            case 4250L: return "bfk_ia32_writeeflags_u32";
            case 4251L: return "bfk_ia32_writeeflags_u64";
            case 4252L: return "bfk_ia32_wrpkru";
            case 4253L: return "bfk_ia32_wrssd";
            case 4254L: return "bfk_ia32_wrssq";
            case 4255L: return "bfk_ia32_wrussd";
            case 4256L: return "bfk_ia32_wrussq";
            case 4257L: return "bfk_ia32_xabort";
            case 4258L: return "bfk_ia32_xbegin";
            case 4259L: return "bfk_ia32_xend";
            case 4260L: return "bfk_ia32_xgetbv";
            case 4261L: return "bfk_ia32_xorpd";
            case 4262L: return "bfk_ia32_xorpd128_mask";
            case 4263L: return "bfk_ia32_xorpd256";
            case 4264L: return "bfk_ia32_xorpd256_mask";
            case 4265L: return "bfk_ia32_xorpd512_mask";
            case 4266L: return "bfk_ia32_xorps";
            case 4267L: return "bfk_ia32_xorps128_mask";
            case 4268L: return "bfk_ia32_xorps256";
            case 4269L: return "bfk_ia32_xorps256_mask";
            case 4270L: return "bfk_ia32_xorps512_mask";
            case 4271L: return "bfk_ia32_xrstor";
            case 4272L: return "bfk_ia32_xrstor64";
            case 4273L: return "bfk_ia32_xrstors";
            case 4274L: return "bfk_ia32_xrstors64";
            case 4275L: return "bfk_ia32_xsave";
            case 4276L: return "bfk_ia32_xsave64";
            case 4277L: return "bfk_ia32_xsavec";
            case 4278L: return "bfk_ia32_xsavec64";
            case 4279L: return "bfk_ia32_xsaveopt";
            case 4280L: return "bfk_ia32_xsaveopt64";
            case 4281L: return "bfk_ia32_xsaves";
            case 4282L: return "bfk_ia32_xsaves64";
            case 4283L: return "bfk_ia32_xsetbv";
            case 4284L: return "bfk_ia32_xtest";
            case 4285L: return "bfk_iceil";
            case 4286L: return "bfk_iceilf";
            case 4287L: return "bfk_iceill";
            case 4288L: return "bfk_ifloor";
            case 4289L: return "bfk_ifloorf";
            case 4290L: return "bfk_ifloorl";
            case 4291L: return "bfk_ilogb";
            case 4292L: return "bfk_ilogbf";
            case 4293L: return "bfk_ilogbl";
            case 4294L: return "bfk_imaxabs";
            case 4295L: return "bfk_index";
            case 4296L: return "bfk_inf";
            case 4297L: return "bfk_inff";
            case 4298L: return "bfk_inff128";
            case 4299L: return "bfk_inff32";
            case 4300L: return "bfk_inff32x";
            case 4301L: return "bfk_inff64";
            case 4302L: return "bfk_inff64x";
            case 4303L: return "bfk_infl";
            case 4304L: return "bfk_init_descriptor";
            case 4305L: return "bfk_init_dwarf_reg_size_table";
            case 4306L: return "bfk_init_heap_trampoline";
            case 4307L: return "bfk_init_trampoline";
            case 4308L: return "bfk_irint";
            case 4309L: return "bfk_irintf";
            case 4310L: return "bfk_irintl";
            case 4311L: return "bfk_iround";
            case 4312L: return "bfk_iroundf";
            case 4313L: return "bfk_iroundl";
            case 4314L: return "bfk_is_constant_evaluated";
            case 4315L: return "bfk_isalnum";
            case 4316L: return "bfk_isalpha";
            case 4317L: return "bfk_isascii";
            case 4318L: return "bfk_isblank";
            case 4319L: return "bfk_iscntrl";
            case 4320L: return "bfk_isdigit";
            case 4321L: return "bfk_isfinite";
            case 4322L: return "bfk_isgraph";
            case 4323L: return "bfk_isgreater";
            case 4324L: return "bfk_isgreaterequal";
            case 4325L: return "bfk_isinf";
            case 4326L: return "bfk_isinf_sign";
            case 4327L: return "bfk_isinff";
            case 4328L: return "bfk_isinfl";
            case 4329L: return "bfk_isless";
            case 4330L: return "bfk_islessequal";
            case 4331L: return "bfk_islessgreater";
            case 4332L: return "bfk_islower";
            case 4333L: return "bfk_isnan";
            case 4334L: return "bfk_isnanf";
            case 4335L: return "bfk_isnanl";
            case 4336L: return "bfk_isnormal";
            case 4337L: return "bfk_isprint";
            case 4338L: return "bfk_ispunct";
            case 4339L: return "bfk_isspace";
            case 4340L: return "bfk_isunordered";
            case 4341L: return "bfk_isupper";
            case 4342L: return "bfk_iswalnum";
            case 4343L: return "bfk_iswalpha";
            case 4344L: return "bfk_iswblank";
            case 4345L: return "bfk_iswcntrl";
            case 4346L: return "bfk_iswdigit";
            case 4347L: return "bfk_iswgraph";
            case 4348L: return "bfk_iswlower";
            case 4349L: return "bfk_iswprint";
            case 4350L: return "bfk_iswpunct";
            case 4351L: return "bfk_iswspace";
            case 4352L: return "bfk_iswupper";
            case 4353L: return "bfk_iswxdigit";
            case 4354L: return "bfk_isxdigit";
            case 4355L: return "bfk_j0";
            case 4356L: return "bfk_j0f";
            case 4357L: return "bfk_j0l";
            case 4358L: return "bfk_j1";
            case 4359L: return "bfk_j1f";
            case 4360L: return "bfk_j1l";
            case 4361L: return "bfk_jn";
            case 4362L: return "bfk_jnf";
            case 4363L: return "bfk_jnl";
            case 4364L: return "bfk_labs";
            case 4365L: return "bfk_launder";
            case 4366L: return "bfk_lceil";
            case 4367L: return "bfk_lceilf";
            case 4368L: return "bfk_lceill";
            case 4369L: return "bfk_ldexp";
            case 4370L: return "bfk_ldexpf";
            case 4371L: return "bfk_ldexpl";
            case 4372L: return "bfk_lfloor";
            case 4373L: return "bfk_lfloorf";
            case 4374L: return "bfk_lfloorl";
            case 4375L: return "bfk_lgamma";
            case 4376L: return "bfk_lgamma_r";
            case 4377L: return "bfk_lgammaf";
            case 4378L: return "bfk_lgammaf_r";
            case 4379L: return "bfk_lgammal";
            case 4380L: return "bfk_lgammal_r";
            case 4381L: return "bfk_llabs";
            case 4382L: return "bfk_llceil";
            case 4383L: return "bfk_llceilf";
            case 4384L: return "bfk_llceill";
            case 4385L: return "bfk_llfloor";
            case 4386L: return "bfk_llfloorf";
            case 4387L: return "bfk_llfloorl";
            case 4388L: return "bfk_llrint";
            case 4389L: return "bfk_llrintf";
            case 4390L: return "bfk_llrintl";
            case 4391L: return "bfk_llround";
            case 4392L: return "bfk_llroundf";
            case 4393L: return "bfk_llroundl";
            case 4394L: return "bfk_log";
            case 4395L: return "bfk_log10";
            case 4396L: return "bfk_log10f";
            case 4397L: return "bfk_log10l";
            case 4398L: return "bfk_log1p";
            case 4399L: return "bfk_log1pf";
            case 4400L: return "bfk_log1pl";
            case 4401L: return "bfk_log2";
            case 4402L: return "bfk_log2f";
            case 4403L: return "bfk_log2l";
            case 4404L: return "bfk_logb";
            case 4405L: return "bfk_logbf";
            case 4406L: return "bfk_logbl";
            case 4407L: return "bfk_logf";
            case 4408L: return "bfk_logl";
            case 4409L: return "bfk_longjmp";
            case 4410L: return "bfk_lrint";
            case 4411L: return "bfk_lrintf";
            case 4412L: return "bfk_lrintl";
            case 4413L: return "bfk_lround";
            case 4414L: return "bfk_lroundf";
            case 4415L: return "bfk_lroundl";
            case 4416L: return "bfk_malloc";
            case 4417L: return "bfk_memchr";
            case 4418L: return "bfk_memcmp";
            case 4419L: return "bfk_memcmp_eq";
            case 4420L: return "bfk_memcpy";
            case 4421L: return "bfk_memmove";
            case 4422L: return "bfk_mempcpy";
            case 4423L: return "bfk_memset";
            case 4424L: return "bfk_modf";
            case 4425L: return "bfk_modff";
            case 4426L: return "bfk_modfl";
            case 4427L: return "bfk_ms_va_copy";
            case 4428L: return "bfk_ms_va_end";
            case 4429L: return "bfk_ms_va_start";
            case 4430L: return "bfk_mul_overflow";
            case 4431L: return "bfk_mul_overflow_p";
            case 4432L: return "bfk_nan";
            case 4433L: return "bfk_nanf";
            case 4434L: return "bfk_nanf128";
            case 4435L: return "bfk_nanf32";
            case 4436L: return "bfk_nanf32x";
            case 4437L: return "bfk_nanf64";
            case 4438L: return "bfk_nanf64x";
            case 4439L: return "bfk_nanl";
            case 4440L: return "bfk_nans";
            case 4441L: return "bfk_nansf";
            case 4442L: return "bfk_nansf128";
            case 4443L: return "bfk_nansf32";
            case 4444L: return "bfk_nansf32x";
            case 4445L: return "bfk_nansf64";
            case 4446L: return "bfk_nansf64x";
            case 4447L: return "bfk_nansl";
            case 4448L: return "bfk_nearbyint";
            case 4449L: return "bfk_nearbyintf";
            case 4450L: return "bfk_nearbyintf32";
            case 4451L: return "bfk_nearbyintf32x";
            case 4452L: return "bfk_nearbyintf64";
            case 4453L: return "bfk_nearbyintf64x";
            case 4454L: return "bfk_nearbyintl";
            case 4455L: return "bfk_next_arg";
            case 4456L: return "bfk_nextafter";
            case 4457L: return "bfk_nextafterf";
            case 4458L: return "bfk_nextafterl";
            case 4459L: return "bfk_nexttoward";
            case 4460L: return "bfk_nexttowardf";
            case 4461L: return "bfk_nexttowardl";
            case 4462L: return "bfk_nonlocal_goto";
            case 4463L: return "bfk_nontemporal_load";
            case 4464L: return "bfk_nontemporal_store";
            case 4465L: return "bfk_objc_memmove_collectable";
            case 4466L: return "bfk_object_size";
            case 4467L: return "bfk_omp_get_num_teams";
            case 4468L: return "bfk_omp_get_num_threads";
            case 4469L: return "bfk_omp_get_team_num";
            case 4470L: return "bfk_omp_get_thread_num";
            case 4471L: return "bfk_operator_delete";
            case 4472L: return "bfk_operator_new";
            case 4473L: return "bfk_os_log_format";
            case 4474L: return "bfk_os_log_format_buffer_size";
            case 4475L: return "bfk_parity";
            case 4476L: return "bfk_parityimax";
            case 4477L: return "bfk_parityl";
            case 4478L: return "bfk_parityll";
            case 4479L: return "bfk_popcount";
            case 4480L: return "bfk_popcountimax";
            case 4481L: return "bfk_popcountl";
            case 4482L: return "bfk_popcountll";
            case 4483L: return "bfk_posix_memalign";
            case 4484L: return "bfk_pow";
            case 4485L: return "bfk_pow10";
            case 4486L: return "bfk_pow10f";
            case 4487L: return "bfk_pow10l";
            case 4488L: return "bfk_powf";
            case 4489L: return "bfk_powi";
            case 4490L: return "bfk_powif";
            case 4491L: return "bfk_powil";
            case 4492L: return "bfk_powl";
            case 4493L: return "bfk_prefetch";
            case 4494L: return "bfk_preserve_access_index";
            case 4495L: return "bfk_printf";
            case 4496L: return "bfk_printf_unlocked";
            case 4497L: return "bfk_profile_func_enter";
            case 4498L: return "bfk_profile_func_exit";
            case 4499L: return "bfk_putc";
            case 4500L: return "bfk_putc_unlocked";
            case 4501L: return "bfk_putchar";
            case 4502L: return "bfk_putchar_unlocked";
            case 4503L: return "bfk_puts";
            case 4504L: return "bfk_puts_unlocked";
            case 4505L: return "bfk_readcyclecounter";
            case 4506L: return "bfk_realloc";
            case 4507L: return "bfk_remainder";
            case 4508L: return "bfk_remainderf";
            case 4509L: return "bfk_remainderl";
            case 4510L: return "bfk_remquo";
            case 4511L: return "bfk_remquof";
            case 4512L: return "bfk_remquol";
            case 4513L: return "bfk_return";
            case 4514L: return "bfk_return_address";
            case 4515L: return "bfk_rindex";
            case 4516L: return "bfk_rint";
            case 4517L: return "bfk_rintf";
            case 4518L: return "bfk_rintf32";
            case 4519L: return "bfk_rintf32x";
            case 4520L: return "bfk_rintf64";
            case 4521L: return "bfk_rintf64x";
            case 4522L: return "bfk_rintl";
            case 4523L: return "bfk_rotateleft16";
            case 4524L: return "bfk_rotateleft32";
            case 4525L: return "bfk_rotateleft64";
            case 4526L: return "bfk_rotateleft8";
            case 4527L: return "bfk_rotateright16";
            case 4528L: return "bfk_rotateright32";
            case 4529L: return "bfk_rotateright64";
            case 4530L: return "bfk_rotateright8";
            case 4531L: return "bfk_round";
            case 4532L: return "bfk_roundf";
            case 4533L: return "bfk_roundf32";
            case 4534L: return "bfk_roundf32x";
            case 4535L: return "bfk_roundf64";
            case 4536L: return "bfk_roundf64x";
            case 4537L: return "bfk_roundl";
            case 4538L: return "bfk_sadd_overflow";
            case 4539L: return "bfk_saddl_overflow";
            case 4540L: return "bfk_saddll_overflow";
            case 4541L: return "bfk_saveregs";
            case 4542L: return "bfk_scalb";
            case 4543L: return "bfk_scalbf";
            case 4544L: return "bfk_scalbl";
            case 4545L: return "bfk_scalbln";
            case 4546L: return "bfk_scalblnf";
            case 4547L: return "bfk_scalblnl";
            case 4548L: return "bfk_scalbn";
            case 4549L: return "bfk_scalbnf";
            case 4550L: return "bfk_scalbnl";
            case 4551L: return "bfk_scanf";
            case 4552L: return "bfk_set_thread_pointer";
            case 4553L: return "bfk_setjmp";
            case 4554L: return "bfk_setjmp_dispatcher";
            case 4555L: return "bfk_setjmp_receiver";
            case 4556L: return "bfk_setjmp_setup";
            case 4557L: return "bfk_shufflevector";
            case 4558L: return "bfk_signbit";
            case 4559L: return "bfk_signbitf";
            case 4560L: return "bfk_signbitl";
            case 4561L: return "bfk_significand";
            case 4562L: return "bfk_significandf";
            case 4563L: return "bfk_significandl";
            case 4564L: return "bfk_sin";
            case 4565L: return "bfk_sincos";
            case 4566L: return "bfk_sincosf";
            case 4567L: return "bfk_sincosl";
            case 4568L: return "bfk_sinf";
            case 4569L: return "bfk_sinh";
            case 4570L: return "bfk_sinhf";
            case 4571L: return "bfk_sinhl";
            case 4572L: return "bfk_sinl";
            case 4573L: return "bfk_smul_overflow";
            case 4574L: return "bfk_smull_overflow";
            case 4575L: return "bfk_smulll_overflow";
            case 4576L: return "bfk_snprintf";
            case 4577L: return "bfk_speculation_safe_value";
            case 4578L: return "bfk_speculation_safe_value_1";
            case 4579L: return "bfk_speculation_safe_value_16";
            case 4580L: return "bfk_speculation_safe_value_2";
            case 4581L: return "bfk_speculation_safe_value_4";
            case 4582L: return "bfk_speculation_safe_value_8";
            case 4583L: return "bfk_speculation_safe_value_ptr";
            case 4584L: return "bfk_sprintf";
            case 4585L: return "bfk_sqrt";
            case 4586L: return "bfk_sqrtf";
            case 4587L: return "bfk_sqrtf32";
            case 4588L: return "bfk_sqrtf32x";
            case 4589L: return "bfk_sqrtf64";
            case 4590L: return "bfk_sqrtf64x";
            case 4591L: return "bfk_sqrtl";
            case 4592L: return "bfk_sscanf";
            case 4593L: return "bfk_ssub_overflow";
            case 4594L: return "bfk_ssubl_overflow";
            case 4595L: return "bfk_ssubll_overflow";
            case 4596L: return "bfk_stack_restore";
            case 4597L: return "bfk_stack_save";
            case 4598L: return "bfk_stdarg_start";
            case 4599L: return "bfk_stpcpy";
            case 4600L: return "bfk_stpncpy";
            case 4601L: return "bfk_strcasecmp";
            case 4602L: return "bfk_strcat";
            case 4603L: return "bfk_strchr";
            case 4604L: return "bfk_strcmp";
            case 4605L: return "bfk_strcmp_eq";
            case 4606L: return "bfk_strcpy";
            case 4607L: return "bfk_strcspn";
            case 4608L: return "bfk_strdup";
            case 4609L: return "bfk_strerror";
            case 4610L: return "bfk_strfmon";
            case 4611L: return "bfk_strftime";
            case 4612L: return "bfk_strlcat";
            case 4613L: return "bfk_strlcpy";
            case 4614L: return "bfk_strlen";
            case 4615L: return "bfk_strncasecmp";
            case 4616L: return "bfk_strncat";
            case 4617L: return "bfk_strncmp";
            case 4618L: return "bfk_strncmp_eq";
            case 4619L: return "bfk_strncpy";
            case 4620L: return "bfk_strndup";
            case 4621L: return "bfk_strnlen";
            case 4622L: return "bfk_strpbrk";
            case 4623L: return "bfk_strrchr";
            case 4624L: return "bfk_strspn";
            case 4625L: return "bfk_strstr";
            case 4626L: return "bfk_strtod";
            case 4627L: return "bfk_strtof";
            case 4628L: return "bfk_strtok";
            case 4629L: return "bfk_strtol";
            case 4630L: return "bfk_strtold";
            case 4631L: return "bfk_strtoll";
            case 4632L: return "bfk_strtoul";
            case 4633L: return "bfk_strtoull";
            case 4634L: return "bfk_strxfrm";
            case 4635L: return "bfk_sub_overflow";
            case 4636L: return "bfk_sub_overflow_p";
            case 4637L: return "bfk_subc";
            case 4638L: return "bfk_subcb";
            case 4639L: return "bfk_subcl";
            case 4640L: return "bfk_subcll";
            case 4641L: return "bfk_subcs";
            case 4642L: return "bfk_sync_add_and_fetch";
            case 4643L: return "bfk_sync_add_and_fetch_1";
            case 4644L: return "bfk_sync_add_and_fetch_16";
            case 4645L: return "bfk_sync_add_and_fetch_2";
            case 4646L: return "bfk_sync_add_and_fetch_4";
            case 4647L: return "bfk_sync_add_and_fetch_8";
            case 4648L: return "bfk_sync_and_and_fetch";
            case 4649L: return "bfk_sync_and_and_fetch_1";
            case 4650L: return "bfk_sync_and_and_fetch_16";
            case 4651L: return "bfk_sync_and_and_fetch_2";
            case 4652L: return "bfk_sync_and_and_fetch_4";
            case 4653L: return "bfk_sync_and_and_fetch_8";
            case 4654L: return "bfk_sync_bool_compare_and_swap";
            case 4655L: return "bfk_sync_bool_compare_and_swap_1";
            case 4656L: return "bfk_sync_bool_compare_and_swap_16";
            case 4657L: return "bfk_sync_bool_compare_and_swap_2";
            case 4658L: return "bfk_sync_bool_compare_and_swap_4";
            case 4659L: return "bfk_sync_bool_compare_and_swap_8";
            case 4660L: return "bfk_sync_fetch_and_add";
            case 4661L: return "bfk_sync_fetch_and_add_1";
            case 4662L: return "bfk_sync_fetch_and_add_16";
            case 4663L: return "bfk_sync_fetch_and_add_2";
            case 4664L: return "bfk_sync_fetch_and_add_4";
            case 4665L: return "bfk_sync_fetch_and_add_8";
            case 4666L: return "bfk_sync_fetch_and_and";
            case 4667L: return "bfk_sync_fetch_and_and_1";
            case 4668L: return "bfk_sync_fetch_and_and_16";
            case 4669L: return "bfk_sync_fetch_and_and_2";
            case 4670L: return "bfk_sync_fetch_and_and_4";
            case 4671L: return "bfk_sync_fetch_and_and_8";
            case 4672L: return "bfk_sync_fetch_and_max";
            case 4673L: return "bfk_sync_fetch_and_min";
            case 4674L: return "bfk_sync_fetch_and_nand";
            case 4675L: return "bfk_sync_fetch_and_nand_1";
            case 4676L: return "bfk_sync_fetch_and_nand_16";
            case 4677L: return "bfk_sync_fetch_and_nand_2";
            case 4678L: return "bfk_sync_fetch_and_nand_4";
            case 4679L: return "bfk_sync_fetch_and_nand_8";
            case 4680L: return "bfk_sync_fetch_and_or";
            case 4681L: return "bfk_sync_fetch_and_or_1";
            case 4682L: return "bfk_sync_fetch_and_or_16";
            case 4683L: return "bfk_sync_fetch_and_or_2";
            case 4684L: return "bfk_sync_fetch_and_or_4";
            case 4685L: return "bfk_sync_fetch_and_or_8";
            case 4686L: return "bfk_sync_fetch_and_sub";
            case 4687L: return "bfk_sync_fetch_and_sub_1";
            case 4688L: return "bfk_sync_fetch_and_sub_16";
            case 4689L: return "bfk_sync_fetch_and_sub_2";
            case 4690L: return "bfk_sync_fetch_and_sub_4";
            case 4691L: return "bfk_sync_fetch_and_sub_8";
            case 4692L: return "bfk_sync_fetch_and_umax";
            case 4693L: return "bfk_sync_fetch_and_umin";
            case 4694L: return "bfk_sync_fetch_and_xor";
            case 4695L: return "bfk_sync_fetch_and_xor_1";
            case 4696L: return "bfk_sync_fetch_and_xor_16";
            case 4697L: return "bfk_sync_fetch_and_xor_2";
            case 4698L: return "bfk_sync_fetch_and_xor_4";
            case 4699L: return "bfk_sync_fetch_and_xor_8";
            case 4700L: return "bfk_sync_lock_release";
            case 4701L: return "bfk_sync_lock_release_1";
            case 4702L: return "bfk_sync_lock_release_16";
            case 4703L: return "bfk_sync_lock_release_2";
            case 4704L: return "bfk_sync_lock_release_4";
            case 4705L: return "bfk_sync_lock_release_8";
            case 4706L: return "bfk_sync_lock_test_and_set";
            case 4707L: return "bfk_sync_lock_test_and_set_1";
            case 4708L: return "bfk_sync_lock_test_and_set_16";
            case 4709L: return "bfk_sync_lock_test_and_set_2";
            case 4710L: return "bfk_sync_lock_test_and_set_4";
            case 4711L: return "bfk_sync_lock_test_and_set_8";
            case 4712L: return "bfk_sync_nand_and_fetch";
            case 4713L: return "bfk_sync_nand_and_fetch_1";
            case 4714L: return "bfk_sync_nand_and_fetch_16";
            case 4715L: return "bfk_sync_nand_and_fetch_2";
            case 4716L: return "bfk_sync_nand_and_fetch_4";
            case 4717L: return "bfk_sync_nand_and_fetch_8";
            case 4718L: return "bfk_sync_or_and_fetch";
            case 4719L: return "bfk_sync_or_and_fetch_1";
            case 4720L: return "bfk_sync_or_and_fetch_16";
            case 4721L: return "bfk_sync_or_and_fetch_2";
            case 4722L: return "bfk_sync_or_and_fetch_4";
            case 4723L: return "bfk_sync_or_and_fetch_8";
            case 4724L: return "bfk_sync_sub_and_fetch";
            case 4725L: return "bfk_sync_sub_and_fetch_1";
            case 4726L: return "bfk_sync_sub_and_fetch_16";
            case 4727L: return "bfk_sync_sub_and_fetch_2";
            case 4728L: return "bfk_sync_sub_and_fetch_4";
            case 4729L: return "bfk_sync_sub_and_fetch_8";
            case 4730L: return "bfk_sync_swap";
            case 4731L: return "bfk_sync_swap_1";
            case 4732L: return "bfk_sync_swap_16";
            case 4733L: return "bfk_sync_swap_2";
            case 4734L: return "bfk_sync_swap_4";
            case 4735L: return "bfk_sync_swap_8";
            case 4736L: return "bfk_sync_synchronize";
            case 4737L: return "bfk_sync_val_compare_and_swap";
            case 4738L: return "bfk_sync_val_compare_and_swap_1";
            case 4739L: return "bfk_sync_val_compare_and_swap_16";
            case 4740L: return "bfk_sync_val_compare_and_swap_2";
            case 4741L: return "bfk_sync_val_compare_and_swap_4";
            case 4742L: return "bfk_sync_val_compare_and_swap_8";
            case 4743L: return "bfk_sync_xor_and_fetch";
            case 4744L: return "bfk_sync_xor_and_fetch_1";
            case 4745L: return "bfk_sync_xor_and_fetch_16";
            case 4746L: return "bfk_sync_xor_and_fetch_2";
            case 4747L: return "bfk_sync_xor_and_fetch_4";
            case 4748L: return "bfk_sync_xor_and_fetch_8";
            case 4749L: return "bfk_sysv_va_copy";
            case 4750L: return "bfk_sysv_va_end";
            case 4751L: return "bfk_sysv_va_start";
            case 4752L: return "bfk_tan";
            case 4753L: return "bfk_tanf";
            case 4754L: return "bfk_tanh";
            case 4755L: return "bfk_tanhf";
            case 4756L: return "bfk_tanhl";
            case 4757L: return "bfk_tanl";
            case 4758L: return "bfk_tgamma";
            case 4759L: return "bfk_tgammaf";
            case 4760L: return "bfk_tgammal";
            case 4761L: return "bfk_thread_pointer";
            case 4762L: return "bfk_toascii";
            case 4763L: return "bfk_tolower";
            case 4764L: return "bfk_toupper";
            case 4765L: return "bfk_towlower";
            case 4766L: return "bfk_towupper";
            case 4767L: return "bfk_trap";
            case 4768L: return "bfk_trunc";
            case 4769L: return "bfk_truncf";
            case 4770L: return "bfk_truncf32";
            case 4771L: return "bfk_truncf32x";
            case 4772L: return "bfk_truncf64";
            case 4773L: return "bfk_truncf64x";
            case 4774L: return "bfk_truncl";
            case 4775L: return "bfk_uadd_overflow";
            case 4776L: return "bfk_uaddl_overflow";
            case 4777L: return "bfk_uaddll_overflow";
            case 4778L: return "bfk_umul_overflow";
            case 4779L: return "bfk_umull_overflow";
            case 4780L: return "bfk_umulll_overflow";
            case 4781L: return "bfk_unpredictable";
            case 4782L: return "bfk_unreachable";
            case 4783L: return "bfk_unwind_init";
            case 4784L: return "bfk_unwind_resume";
            case 4785L: return "bfk_update_setjmp_buf";
            case 4786L: return "bfk_usub_overflow";
            case 4787L: return "bfk_usubl_overflow";
            case 4788L: return "bfk_usubll_overflow";
            case 4789L: return "bfk_va_arg";
            case 4790L: return "bfk_va_arg_pack";
            case 4791L: return "bfk_va_arg_pack_len";
            case 4792L: return "bfk_va_copy";
            case 4793L: return "bfk_va_end";
            case 4794L: return "bfk_va_start";
            case 4795L: return "bfk_varargs_start";
            case 4796L: return "bfk_vfork";
            case 4797L: return "bfk_vfprintf";
            case 4798L: return "bfk_vfscanf";
            case 4799L: return "bfk_vprintf";
            case 4800L: return "bfk_vscanf";
            case 4801L: return "bfk_vsnprintf";
            case 4802L: return "bfk_vsprintf";
            case 4803L: return "bfk_vsscanf";
            case 4804L: return "bfk_wcschr";
            case 4805L: return "bfk_wcscmp";
            case 4806L: return "bfk_wcslen";
            case 4807L: return "bfk_wcsncmp";
            case 4808L: return "bfk_wmemchr";
            case 4809L: return "bfk_wmemcmp";
            case 4810L: return "bfk_wmemcpy";
            case 4811L: return "bfk_wmemmove";
            case 4812L: return "bfk_y0";
            case 4813L: return "bfk_y0f";
            case 4814L: return "bfk_y0l";
            case 4815L: return "bfk_y1";
            case 4816L: return "bfk_y1f";
            case 4817L: return "bfk_y1l";
            case 4818L: return "bfk_yn";
            case 4819L: return "bfk_ynf";
            case 4820L: return "bfk_ynl";
            case 4821L: return "bfk_last";
            default: return "";
        }
    }

    std::string a_builtin_function_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_builtin_function_kind_tag(i);
        if (s.empty())
            s = "(a_builtin_function_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_builtin_function_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L,
            58L,
            59L,
            60L,
            61L,
            62L,
            63L,
            64L,
            65L,
            66L,
            67L,
            68L,
            69L,
            70L,
            71L,
            72L,
            73L,
            74L,
            75L,
            76L,
            77L,
            78L,
            79L,
            80L,
            81L,
            82L,
            83L,
            84L,
            85L,
            86L,
            87L,
            88L,
            89L,
            90L,
            91L,
            92L,
            93L,
            94L,
            95L,
            96L,
            97L,
            98L,
            99L,
            100L,
            101L,
            102L,
            103L,
            104L,
            105L,
            106L,
            107L,
            108L,
            109L,
            110L,
            111L,
            112L,
            113L,
            114L,
            115L,
            116L,
            117L,
            118L,
            119L,
            120L,
            121L,
            122L,
            123L,
            124L,
            125L,
            126L,
            127L,
            128L,
            129L,
            130L,
            131L,
            132L,
            133L,
            134L,
            135L,
            136L,
            137L,
            138L,
            139L,
            140L,
            141L,
            142L,
            143L,
            144L,
            145L,
            146L,
            147L,
            148L,
            149L,
            150L,
            151L,
            152L,
            153L,
            154L,
            155L,
            156L,
            157L,
            158L,
            159L,
            160L,
            161L,
            162L,
            163L,
            164L,
            165L,
            166L,
            167L,
            168L,
            169L,
            170L,
            171L,
            172L,
            173L,
            174L,
            175L,
            176L,
            177L,
            178L,
            179L,
            180L,
            181L,
            182L,
            183L,
            184L,
            185L,
            186L,
            187L,
            188L,
            189L,
            190L,
            191L,
            192L,
            193L,
            194L,
            195L,
            196L,
            197L,
            198L,
            199L,
            200L,
            201L,
            202L,
            203L,
            204L,
            205L,
            206L,
            207L,
            208L,
            209L,
            210L,
            211L,
            212L,
            213L,
            214L,
            215L,
            216L,
            217L,
            218L,
            219L,
            220L,
            221L,
            222L,
            223L,
            224L,
            225L,
            226L,
            227L,
            228L,
            229L,
            230L,
            231L,
            232L,
            233L,
            234L,
            235L,
            236L,
            237L,
            238L,
            239L,
            240L,
            241L,
            242L,
            243L,
            244L,
            245L,
            246L,
            247L,
            248L,
            249L,
            250L,
            251L,
            252L,
            253L,
            254L,
            255L,
            256L,
            257L,
            258L,
            259L,
            260L,
            261L,
            262L,
            263L,
            264L,
            265L,
            266L,
            267L,
            268L,
            269L,
            270L,
            271L,
            272L,
            273L,
            274L,
            275L,
            276L,
            277L,
            278L,
            279L,
            280L,
            281L,
            282L,
            283L,
            284L,
            285L,
            286L,
            287L,
            288L,
            289L,
            290L,
            291L,
            292L,
            293L,
            294L,
            295L,
            296L,
            297L,
            298L,
            299L,
            300L,
            301L,
            302L,
            303L,
            304L,
            305L,
            306L,
            307L,
            308L,
            309L,
            310L,
            311L,
            312L,
            313L,
            314L,
            315L,
            316L,
            317L,
            318L,
            319L,
            320L,
            321L,
            322L,
            323L,
            324L,
            325L,
            326L,
            327L,
            328L,
            329L,
            330L,
            331L,
            332L,
            333L,
            334L,
            335L,
            336L,
            337L,
            338L,
            339L,
            340L,
            341L,
            342L,
            343L,
            344L,
            345L,
            346L,
            347L,
            348L,
            349L,
            350L,
            351L,
            352L,
            353L,
            354L,
            355L,
            356L,
            357L,
            358L,
            359L,
            360L,
            361L,
            362L,
            363L,
            364L,
            365L,
            366L,
            367L,
            368L,
            369L,
            370L,
            371L,
            372L,
            373L,
            374L,
            375L,
            376L,
            377L,
            378L,
            379L,
            380L,
            381L,
            382L,
            383L,
            384L,
            385L,
            386L,
            387L,
            388L,
            389L,
            390L,
            391L,
            392L,
            393L,
            394L,
            395L,
            396L,
            397L,
            398L,
            399L,
            400L,
            401L,
            402L,
            403L,
            404L,
            405L,
            406L,
            407L,
            408L,
            409L,
            410L,
            411L,
            412L,
            413L,
            414L,
            415L,
            416L,
            417L,
            418L,
            419L,
            420L,
            421L,
            422L,
            423L,
            424L,
            425L,
            426L,
            427L,
            428L,
            429L,
            430L,
            431L,
            432L,
            433L,
            434L,
            435L,
            436L,
            437L,
            438L,
            439L,
            440L,
            441L,
            442L,
            443L,
            444L,
            445L,
            446L,
            447L,
            448L,
            449L,
            450L,
            451L,
            452L,
            453L,
            454L,
            455L,
            456L,
            457L,
            458L,
            459L,
            460L,
            461L,
            462L,
            463L,
            464L,
            465L,
            466L,
            467L,
            468L,
            469L,
            470L,
            471L,
            472L,
            473L,
            474L,
            475L,
            476L,
            477L,
            478L,
            479L,
            480L,
            481L,
            482L,
            483L,
            484L,
            485L,
            486L,
            487L,
            488L,
            489L,
            490L,
            491L,
            492L,
            493L,
            494L,
            495L,
            496L,
            497L,
            498L,
            499L,
            500L,
            501L,
            502L,
            503L,
            504L,
            505L,
            506L,
            507L,
            508L,
            509L,
            510L,
            511L,
            512L,
            513L,
            514L,
            515L,
            516L,
            517L,
            518L,
            519L,
            520L,
            521L,
            522L,
            523L,
            524L,
            525L,
            526L,
            527L,
            528L,
            529L,
            530L,
            531L,
            532L,
            533L,
            534L,
            535L,
            536L,
            537L,
            538L,
            539L,
            540L,
            541L,
            542L,
            543L,
            544L,
            545L,
            546L,
            547L,
            548L,
            549L,
            550L,
            551L,
            552L,
            553L,
            554L,
            555L,
            556L,
            557L,
            558L,
            559L,
            560L,
            561L,
            562L,
            563L,
            564L,
            565L,
            566L,
            567L,
            568L,
            569L,
            570L,
            571L,
            572L,
            573L,
            574L,
            575L,
            576L,
            577L,
            578L,
            579L,
            580L,
            581L,
            582L,
            583L,
            584L,
            585L,
            586L,
            587L,
            588L,
            589L,
            590L,
            591L,
            592L,
            593L,
            594L,
            595L,
            596L,
            597L,
            598L,
            599L,
            600L,
            601L,
            602L,
            603L,
            604L,
            605L,
            606L,
            607L,
            608L,
            609L,
            610L,
            611L,
            612L,
            613L,
            614L,
            615L,
            616L,
            617L,
            618L,
            619L,
            620L,
            621L,
            622L,
            623L,
            624L,
            625L,
            626L,
            627L,
            628L,
            629L,
            630L,
            631L,
            632L,
            633L,
            634L,
            635L,
            636L,
            637L,
            638L,
            639L,
            640L,
            641L,
            642L,
            643L,
            644L,
            645L,
            646L,
            647L,
            648L,
            649L,
            650L,
            651L,
            652L,
            653L,
            654L,
            655L,
            656L,
            657L,
            658L,
            659L,
            660L,
            661L,
            662L,
            663L,
            664L,
            665L,
            666L,
            667L,
            668L,
            669L,
            670L,
            671L,
            672L,
            673L,
            674L,
            675L,
            676L,
            677L,
            678L,
            679L,
            680L,
            681L,
            682L,
            683L,
            684L,
            685L,
            686L,
            687L,
            688L,
            689L,
            690L,
            691L,
            692L,
            693L,
            694L,
            695L,
            696L,
            697L,
            698L,
            699L,
            700L,
            701L,
            702L,
            703L,
            704L,
            705L,
            706L,
            707L,
            708L,
            709L,
            710L,
            711L,
            712L,
            713L,
            714L,
            715L,
            716L,
            717L,
            718L,
            719L,
            720L,
            721L,
            722L,
            723L,
            724L,
            725L,
            726L,
            727L,
            728L,
            729L,
            730L,
            731L,
            732L,
            733L,
            734L,
            735L,
            736L,
            737L,
            738L,
            739L,
            740L,
            741L,
            742L,
            743L,
            744L,
            745L,
            746L,
            747L,
            748L,
            749L,
            750L,
            751L,
            752L,
            753L,
            754L,
            755L,
            756L,
            757L,
            758L,
            759L,
            760L,
            761L,
            762L,
            763L,
            764L,
            765L,
            766L,
            767L,
            768L,
            769L,
            770L,
            771L,
            772L,
            773L,
            774L,
            775L,
            776L,
            777L,
            778L,
            779L,
            780L,
            781L,
            782L,
            783L,
            784L,
            785L,
            786L,
            787L,
            788L,
            789L,
            790L,
            791L,
            792L,
            793L,
            794L,
            795L,
            796L,
            797L,
            798L,
            799L,
            800L,
            801L,
            802L,
            803L,
            804L,
            805L,
            806L,
            807L,
            808L,
            809L,
            810L,
            811L,
            812L,
            813L,
            814L,
            815L,
            816L,
            817L,
            818L,
            819L,
            820L,
            821L,
            822L,
            823L,
            824L,
            825L,
            826L,
            827L,
            828L,
            829L,
            830L,
            831L,
            832L,
            833L,
            834L,
            835L,
            836L,
            837L,
            838L,
            839L,
            840L,
            841L,
            842L,
            843L,
            844L,
            845L,
            846L,
            847L,
            848L,
            849L,
            850L,
            851L,
            852L,
            853L,
            854L,
            855L,
            856L,
            857L,
            858L,
            859L,
            860L,
            861L,
            862L,
            863L,
            864L,
            865L,
            866L,
            867L,
            868L,
            869L,
            870L,
            871L,
            872L,
            873L,
            874L,
            875L,
            876L,
            877L,
            878L,
            879L,
            880L,
            881L,
            882L,
            883L,
            884L,
            885L,
            886L,
            887L,
            888L,
            889L,
            890L,
            891L,
            892L,
            893L,
            894L,
            895L,
            896L,
            897L,
            898L,
            899L,
            900L,
            901L,
            902L,
            903L,
            904L,
            905L,
            906L,
            907L,
            908L,
            909L,
            910L,
            911L,
            912L,
            913L,
            914L,
            915L,
            916L,
            917L,
            918L,
            919L,
            920L,
            921L,
            922L,
            923L,
            924L,
            925L,
            926L,
            927L,
            928L,
            929L,
            930L,
            931L,
            932L,
            933L,
            934L,
            935L,
            936L,
            937L,
            938L,
            939L,
            940L,
            941L,
            942L,
            943L,
            944L,
            945L,
            946L,
            947L,
            948L,
            949L,
            950L,
            951L,
            952L,
            953L,
            954L,
            955L,
            956L,
            957L,
            958L,
            959L,
            960L,
            961L,
            962L,
            963L,
            964L,
            965L,
            966L,
            967L,
            968L,
            969L,
            970L,
            971L,
            972L,
            973L,
            974L,
            975L,
            976L,
            977L,
            978L,
            979L,
            980L,
            981L,
            982L,
            983L,
            984L,
            985L,
            986L,
            987L,
            988L,
            989L,
            990L,
            991L,
            992L,
            993L,
            994L,
            995L,
            996L,
            997L,
            998L,
            999L,
            1000L,
            1001L,
            1002L,
            1003L,
            1004L,
            1005L,
            1006L,
            1007L,
            1008L,
            1009L,
            1010L,
            1011L,
            1012L,
            1013L,
            1014L,
            1015L,
            1016L,
            1017L,
            1018L,
            1019L,
            1020L,
            1021L,
            1022L,
            1023L,
            1024L,
            1025L,
            1026L,
            1027L,
            1028L,
            1029L,
            1030L,
            1031L,
            1032L,
            1033L,
            1034L,
            1035L,
            1036L,
            1037L,
            1038L,
            1039L,
            1040L,
            1041L,
            1042L,
            1043L,
            1044L,
            1045L,
            1046L,
            1047L,
            1048L,
            1049L,
            1050L,
            1051L,
            1052L,
            1053L,
            1054L,
            1055L,
            1056L,
            1057L,
            1058L,
            1059L,
            1060L,
            1061L,
            1062L,
            1063L,
            1064L,
            1065L,
            1066L,
            1067L,
            1068L,
            1069L,
            1070L,
            1071L,
            1072L,
            1073L,
            1074L,
            1075L,
            1076L,
            1077L,
            1078L,
            1079L,
            1080L,
            1081L,
            1082L,
            1083L,
            1084L,
            1085L,
            1086L,
            1087L,
            1088L,
            1089L,
            1090L,
            1091L,
            1092L,
            1093L,
            1094L,
            1095L,
            1096L,
            1097L,
            1098L,
            1099L,
            1100L,
            1101L,
            1102L,
            1103L,
            1104L,
            1105L,
            1106L,
            1107L,
            1108L,
            1109L,
            1110L,
            1111L,
            1112L,
            1113L,
            1114L,
            1115L,
            1116L,
            1117L,
            1118L,
            1119L,
            1120L,
            1121L,
            1122L,
            1123L,
            1124L,
            1125L,
            1126L,
            1127L,
            1128L,
            1129L,
            1130L,
            1131L,
            1132L,
            1133L,
            1134L,
            1135L,
            1136L,
            1137L,
            1138L,
            1139L,
            1140L,
            1141L,
            1142L,
            1143L,
            1144L,
            1145L,
            1146L,
            1147L,
            1148L,
            1149L,
            1150L,
            1151L,
            1152L,
            1153L,
            1154L,
            1155L,
            1156L,
            1157L,
            1158L,
            1159L,
            1160L,
            1161L,
            1162L,
            1163L,
            1164L,
            1165L,
            1166L,
            1167L,
            1168L,
            1169L,
            1170L,
            1171L,
            1172L,
            1173L,
            1174L,
            1175L,
            1176L,
            1177L,
            1178L,
            1179L,
            1180L,
            1181L,
            1182L,
            1183L,
            1184L,
            1185L,
            1186L,
            1187L,
            1188L,
            1189L,
            1190L,
            1191L,
            1192L,
            1193L,
            1194L,
            1195L,
            1196L,
            1197L,
            1198L,
            1199L,
            1200L,
            1201L,
            1202L,
            1203L,
            1204L,
            1205L,
            1206L,
            1207L,
            1208L,
            1209L,
            1210L,
            1211L,
            1212L,
            1213L,
            1214L,
            1215L,
            1216L,
            1217L,
            1218L,
            1219L,
            1220L,
            1221L,
            1222L,
            1223L,
            1224L,
            1225L,
            1226L,
            1227L,
            1228L,
            1229L,
            1230L,
            1231L,
            1232L,
            1233L,
            1234L,
            1235L,
            1236L,
            1237L,
            1238L,
            1239L,
            1240L,
            1241L,
            1242L,
            1243L,
            1244L,
            1245L,
            1246L,
            1247L,
            1248L,
            1249L,
            1250L,
            1251L,
            1252L,
            1253L,
            1254L,
            1255L,
            1256L,
            1257L,
            1258L,
            1259L,
            1260L,
            1261L,
            1262L,
            1263L,
            1264L,
            1265L,
            1266L,
            1267L,
            1268L,
            1269L,
            1270L,
            1271L,
            1272L,
            1273L,
            1274L,
            1275L,
            1276L,
            1277L,
            1278L,
            1279L,
            1280L,
            1281L,
            1282L,
            1283L,
            1284L,
            1285L,
            1286L,
            1287L,
            1288L,
            1289L,
            1290L,
            1291L,
            1292L,
            1293L,
            1294L,
            1295L,
            1296L,
            1297L,
            1298L,
            1299L,
            1300L,
            1301L,
            1302L,
            1303L,
            1304L,
            1305L,
            1306L,
            1307L,
            1308L,
            1309L,
            1310L,
            1311L,
            1312L,
            1313L,
            1314L,
            1315L,
            1316L,
            1317L,
            1318L,
            1319L,
            1320L,
            1321L,
            1322L,
            1323L,
            1324L,
            1325L,
            1326L,
            1327L,
            1328L,
            1329L,
            1330L,
            1331L,
            1332L,
            1333L,
            1334L,
            1335L,
            1336L,
            1337L,
            1338L,
            1339L,
            1340L,
            1341L,
            1342L,
            1343L,
            1344L,
            1345L,
            1346L,
            1347L,
            1348L,
            1349L,
            1350L,
            1351L,
            1352L,
            1353L,
            1354L,
            1355L,
            1356L,
            1357L,
            1358L,
            1359L,
            1360L,
            1361L,
            1362L,
            1363L,
            1364L,
            1365L,
            1366L,
            1367L,
            1368L,
            1369L,
            1370L,
            1371L,
            1372L,
            1373L,
            1374L,
            1375L,
            1376L,
            1377L,
            1378L,
            1379L,
            1380L,
            1381L,
            1382L,
            1383L,
            1384L,
            1385L,
            1386L,
            1387L,
            1388L,
            1389L,
            1390L,
            1391L,
            1392L,
            1393L,
            1394L,
            1395L,
            1396L,
            1397L,
            1398L,
            1399L,
            1400L,
            1401L,
            1402L,
            1403L,
            1404L,
            1405L,
            1406L,
            1407L,
            1408L,
            1409L,
            1410L,
            1411L,
            1412L,
            1413L,
            1414L,
            1415L,
            1416L,
            1417L,
            1418L,
            1419L,
            1420L,
            1421L,
            1422L,
            1423L,
            1424L,
            1425L,
            1426L,
            1427L,
            1428L,
            1429L,
            1430L,
            1431L,
            1432L,
            1433L,
            1434L,
            1435L,
            1436L,
            1437L,
            1438L,
            1439L,
            1440L,
            1441L,
            1442L,
            1443L,
            1444L,
            1445L,
            1446L,
            1447L,
            1448L,
            1449L,
            1450L,
            1451L,
            1452L,
            1453L,
            1454L,
            1455L,
            1456L,
            1457L,
            1458L,
            1459L,
            1460L,
            1461L,
            1462L,
            1463L,
            1464L,
            1465L,
            1466L,
            1467L,
            1468L,
            1469L,
            1470L,
            1471L,
            1472L,
            1473L,
            1474L,
            1475L,
            1476L,
            1477L,
            1478L,
            1479L,
            1480L,
            1481L,
            1482L,
            1483L,
            1484L,
            1485L,
            1486L,
            1487L,
            1488L,
            1489L,
            1490L,
            1491L,
            1492L,
            1493L,
            1494L,
            1495L,
            1496L,
            1497L,
            1498L,
            1499L,
            1500L,
            1501L,
            1502L,
            1503L,
            1504L,
            1505L,
            1506L,
            1507L,
            1508L,
            1509L,
            1510L,
            1511L,
            1512L,
            1513L,
            1514L,
            1515L,
            1516L,
            1517L,
            1518L,
            1519L,
            1520L,
            1521L,
            1522L,
            1523L,
            1524L,
            1525L,
            1526L,
            1527L,
            1528L,
            1529L,
            1530L,
            1531L,
            1532L,
            1533L,
            1534L,
            1535L,
            1536L,
            1537L,
            1538L,
            1539L,
            1540L,
            1541L,
            1542L,
            1543L,
            1544L,
            1545L,
            1546L,
            1547L,
            1548L,
            1549L,
            1550L,
            1551L,
            1552L,
            1553L,
            1554L,
            1555L,
            1556L,
            1557L,
            1558L,
            1559L,
            1560L,
            1561L,
            1562L,
            1563L,
            1564L,
            1565L,
            1566L,
            1567L,
            1568L,
            1569L,
            1570L,
            1571L,
            1572L,
            1573L,
            1574L,
            1575L,
            1576L,
            1577L,
            1578L,
            1579L,
            1580L,
            1581L,
            1582L,
            1583L,
            1584L,
            1585L,
            1586L,
            1587L,
            1588L,
            1589L,
            1590L,
            1591L,
            1592L,
            1593L,
            1594L,
            1595L,
            1596L,
            1597L,
            1598L,
            1599L,
            1600L,
            1601L,
            1602L,
            1603L,
            1604L,
            1605L,
            1606L,
            1607L,
            1608L,
            1609L,
            1610L,
            1611L,
            1612L,
            1613L,
            1614L,
            1615L,
            1616L,
            1617L,
            1618L,
            1619L,
            1620L,
            1621L,
            1622L,
            1623L,
            1624L,
            1625L,
            1626L,
            1627L,
            1628L,
            1629L,
            1630L,
            1631L,
            1632L,
            1633L,
            1634L,
            1635L,
            1636L,
            1637L,
            1638L,
            1639L,
            1640L,
            1641L,
            1642L,
            1643L,
            1644L,
            1645L,
            1646L,
            1647L,
            1648L,
            1649L,
            1650L,
            1651L,
            1652L,
            1653L,
            1654L,
            1655L,
            1656L,
            1657L,
            1658L,
            1659L,
            1660L,
            1661L,
            1662L,
            1663L,
            1664L,
            1665L,
            1666L,
            1667L,
            1668L,
            1669L,
            1670L,
            1671L,
            1672L,
            1673L,
            1674L,
            1675L,
            1676L,
            1677L,
            1678L,
            1679L,
            1680L,
            1681L,
            1682L,
            1683L,
            1684L,
            1685L,
            1686L,
            1687L,
            1688L,
            1689L,
            1690L,
            1691L,
            1692L,
            1693L,
            1694L,
            1695L,
            1696L,
            1697L,
            1698L,
            1699L,
            1700L,
            1701L,
            1702L,
            1703L,
            1704L,
            1705L,
            1706L,
            1707L,
            1708L,
            1709L,
            1710L,
            1711L,
            1712L,
            1713L,
            1714L,
            1715L,
            1716L,
            1717L,
            1718L,
            1719L,
            1720L,
            1721L,
            1722L,
            1723L,
            1724L,
            1725L,
            1726L,
            1727L,
            1728L,
            1729L,
            1730L,
            1731L,
            1732L,
            1733L,
            1734L,
            1735L,
            1736L,
            1737L,
            1738L,
            1739L,
            1740L,
            1741L,
            1742L,
            1743L,
            1744L,
            1745L,
            1746L,
            1747L,
            1748L,
            1749L,
            1750L,
            1751L,
            1752L,
            1753L,
            1754L,
            1755L,
            1756L,
            1757L,
            1758L,
            1759L,
            1760L,
            1761L,
            1762L,
            1763L,
            1764L,
            1765L,
            1766L,
            1767L,
            1768L,
            1769L,
            1770L,
            1771L,
            1772L,
            1773L,
            1774L,
            1775L,
            1776L,
            1777L,
            1778L,
            1779L,
            1780L,
            1781L,
            1782L,
            1783L,
            1784L,
            1785L,
            1786L,
            1787L,
            1788L,
            1789L,
            1790L,
            1791L,
            1792L,
            1793L,
            1794L,
            1795L,
            1796L,
            1797L,
            1798L,
            1799L,
            1800L,
            1801L,
            1802L,
            1803L,
            1804L,
            1805L,
            1806L,
            1807L,
            1808L,
            1809L,
            1810L,
            1811L,
            1812L,
            1813L,
            1814L,
            1815L,
            1816L,
            1817L,
            1818L,
            1819L,
            1820L,
            1821L,
            1822L,
            1823L,
            1824L,
            1825L,
            1826L,
            1827L,
            1828L,
            1829L,
            1830L,
            1831L,
            1832L,
            1833L,
            1834L,
            1835L,
            1836L,
            1837L,
            1838L,
            1839L,
            1840L,
            1841L,
            1842L,
            1843L,
            1844L,
            1845L,
            1846L,
            1847L,
            1848L,
            1849L,
            1850L,
            1851L,
            1852L,
            1853L,
            1854L,
            1855L,
            1856L,
            1857L,
            1858L,
            1859L,
            1860L,
            1861L,
            1862L,
            1863L,
            1864L,
            1865L,
            1866L,
            1867L,
            1868L,
            1869L,
            1870L,
            1871L,
            1872L,
            1873L,
            1874L,
            1875L,
            1876L,
            1877L,
            1878L,
            1879L,
            1880L,
            1881L,
            1882L,
            1883L,
            1884L,
            1885L,
            1886L,
            1887L,
            1888L,
            1889L,
            1890L,
            1891L,
            1892L,
            1893L,
            1894L,
            1895L,
            1896L,
            1897L,
            1898L,
            1899L,
            1900L,
            1901L,
            1902L,
            1903L,
            1904L,
            1905L,
            1906L,
            1907L,
            1908L,
            1909L,
            1910L,
            1911L,
            1912L,
            1913L,
            1914L,
            1915L,
            1916L,
            1917L,
            1918L,
            1919L,
            1920L,
            1921L,
            1922L,
            1923L,
            1924L,
            1925L,
            1926L,
            1927L,
            1928L,
            1929L,
            1930L,
            1931L,
            1932L,
            1933L,
            1934L,
            1935L,
            1936L,
            1937L,
            1938L,
            1939L,
            1940L,
            1941L,
            1942L,
            1943L,
            1944L,
            1945L,
            1946L,
            1947L,
            1948L,
            1949L,
            1950L,
            1951L,
            1952L,
            1953L,
            1954L,
            1955L,
            1956L,
            1957L,
            1958L,
            1959L,
            1960L,
            1961L,
            1962L,
            1963L,
            1964L,
            1965L,
            1966L,
            1967L,
            1968L,
            1969L,
            1970L,
            1971L,
            1972L,
            1973L,
            1974L,
            1975L,
            1976L,
            1977L,
            1978L,
            1979L,
            1980L,
            1981L,
            1982L,
            1983L,
            1984L,
            1985L,
            1986L,
            1987L,
            1988L,
            1989L,
            1990L,
            1991L,
            1992L,
            1993L,
            1994L,
            1995L,
            1996L,
            1997L,
            1998L,
            1999L,
            2000L,
            2001L,
            2002L,
            2003L,
            2004L,
            2005L,
            2006L,
            2007L,
            2008L,
            2009L,
            2010L,
            2011L,
            2012L,
            2013L,
            2014L,
            2015L,
            2016L,
            2017L,
            2018L,
            2019L,
            2020L,
            2021L,
            2022L,
            2023L,
            2024L,
            2025L,
            2026L,
            2027L,
            2028L,
            2029L,
            2030L,
            2031L,
            2032L,
            2033L,
            2034L,
            2035L,
            2036L,
            2037L,
            2038L,
            2039L,
            2040L,
            2041L,
            2042L,
            2043L,
            2044L,
            2045L,
            2046L,
            2047L,
            2048L,
            2049L,
            2050L,
            2051L,
            2052L,
            2053L,
            2054L,
            2055L,
            2056L,
            2057L,
            2058L,
            2059L,
            2060L,
            2061L,
            2062L,
            2063L,
            2064L,
            2065L,
            2066L,
            2067L,
            2068L,
            2069L,
            2070L,
            2071L,
            2072L,
            2073L,
            2074L,
            2075L,
            2076L,
            2077L,
            2078L,
            2079L,
            2080L,
            2081L,
            2082L,
            2083L,
            2084L,
            2085L,
            2086L,
            2087L,
            2088L,
            2089L,
            2090L,
            2091L,
            2092L,
            2093L,
            2094L,
            2095L,
            2096L,
            2097L,
            2098L,
            2099L,
            2100L,
            2101L,
            2102L,
            2103L,
            2104L,
            2105L,
            2106L,
            2107L,
            2108L,
            2109L,
            2110L,
            2111L,
            2112L,
            2113L,
            2114L,
            2115L,
            2116L,
            2117L,
            2118L,
            2119L,
            2120L,
            2121L,
            2122L,
            2123L,
            2124L,
            2125L,
            2126L,
            2127L,
            2128L,
            2129L,
            2130L,
            2131L,
            2132L,
            2133L,
            2134L,
            2135L,
            2136L,
            2137L,
            2138L,
            2139L,
            2140L,
            2141L,
            2142L,
            2143L,
            2144L,
            2145L,
            2146L,
            2147L,
            2148L,
            2149L,
            2150L,
            2151L,
            2152L,
            2153L,
            2154L,
            2155L,
            2156L,
            2157L,
            2158L,
            2159L,
            2160L,
            2161L,
            2162L,
            2163L,
            2164L,
            2165L,
            2166L,
            2167L,
            2168L,
            2169L,
            2170L,
            2171L,
            2172L,
            2173L,
            2174L,
            2175L,
            2176L,
            2177L,
            2178L,
            2179L,
            2180L,
            2181L,
            2182L,
            2183L,
            2184L,
            2185L,
            2186L,
            2187L,
            2188L,
            2189L,
            2190L,
            2191L,
            2192L,
            2193L,
            2194L,
            2195L,
            2196L,
            2197L,
            2198L,
            2199L,
            2200L,
            2201L,
            2202L,
            2203L,
            2204L,
            2205L,
            2206L,
            2207L,
            2208L,
            2209L,
            2210L,
            2211L,
            2212L,
            2213L,
            2214L,
            2215L,
            2216L,
            2217L,
            2218L,
            2219L,
            2220L,
            2221L,
            2222L,
            2223L,
            2224L,
            2225L,
            2226L,
            2227L,
            2228L,
            2229L,
            2230L,
            2231L,
            2232L,
            2233L,
            2234L,
            2235L,
            2236L,
            2237L,
            2238L,
            2239L,
            2240L,
            2241L,
            2242L,
            2243L,
            2244L,
            2245L,
            2246L,
            2247L,
            2248L,
            2249L,
            2250L,
            2251L,
            2252L,
            2253L,
            2254L,
            2255L,
            2256L,
            2257L,
            2258L,
            2259L,
            2260L,
            2261L,
            2262L,
            2263L,
            2264L,
            2265L,
            2266L,
            2267L,
            2268L,
            2269L,
            2270L,
            2271L,
            2272L,
            2273L,
            2274L,
            2275L,
            2276L,
            2277L,
            2278L,
            2279L,
            2280L,
            2281L,
            2282L,
            2283L,
            2284L,
            2285L,
            2286L,
            2287L,
            2288L,
            2289L,
            2290L,
            2291L,
            2292L,
            2293L,
            2294L,
            2295L,
            2296L,
            2297L,
            2298L,
            2299L,
            2300L,
            2301L,
            2302L,
            2303L,
            2304L,
            2305L,
            2306L,
            2307L,
            2308L,
            2309L,
            2310L,
            2311L,
            2312L,
            2313L,
            2314L,
            2315L,
            2316L,
            2317L,
            2318L,
            2319L,
            2320L,
            2321L,
            2322L,
            2323L,
            2324L,
            2325L,
            2326L,
            2327L,
            2328L,
            2329L,
            2330L,
            2331L,
            2332L,
            2333L,
            2334L,
            2335L,
            2336L,
            2337L,
            2338L,
            2339L,
            2340L,
            2341L,
            2342L,
            2343L,
            2344L,
            2345L,
            2346L,
            2347L,
            2348L,
            2349L,
            2350L,
            2351L,
            2352L,
            2353L,
            2354L,
            2355L,
            2356L,
            2357L,
            2358L,
            2359L,
            2360L,
            2361L,
            2362L,
            2363L,
            2364L,
            2365L,
            2366L,
            2367L,
            2368L,
            2369L,
            2370L,
            2371L,
            2372L,
            2373L,
            2374L,
            2375L,
            2376L,
            2377L,
            2378L,
            2379L,
            2380L,
            2381L,
            2382L,
            2383L,
            2384L,
            2385L,
            2386L,
            2387L,
            2388L,
            2389L,
            2390L,
            2391L,
            2392L,
            2393L,
            2394L,
            2395L,
            2396L,
            2397L,
            2398L,
            2399L,
            2400L,
            2401L,
            2402L,
            2403L,
            2404L,
            2405L,
            2406L,
            2407L,
            2408L,
            2409L,
            2410L,
            2411L,
            2412L,
            2413L,
            2414L,
            2415L,
            2416L,
            2417L,
            2418L,
            2419L,
            2420L,
            2421L,
            2422L,
            2423L,
            2424L,
            2425L,
            2426L,
            2427L,
            2428L,
            2429L,
            2430L,
            2431L,
            2432L,
            2433L,
            2434L,
            2435L,
            2436L,
            2437L,
            2438L,
            2439L,
            2440L,
            2441L,
            2442L,
            2443L,
            2444L,
            2445L,
            2446L,
            2447L,
            2448L,
            2449L,
            2450L,
            2451L,
            2452L,
            2453L,
            2454L,
            2455L,
            2456L,
            2457L,
            2458L,
            2459L,
            2460L,
            2461L,
            2462L,
            2463L,
            2464L,
            2465L,
            2466L,
            2467L,
            2468L,
            2469L,
            2470L,
            2471L,
            2472L,
            2473L,
            2474L,
            2475L,
            2476L,
            2477L,
            2478L,
            2479L,
            2480L,
            2481L,
            2482L,
            2483L,
            2484L,
            2485L,
            2486L,
            2487L,
            2488L,
            2489L,
            2490L,
            2491L,
            2492L,
            2493L,
            2494L,
            2495L,
            2496L,
            2497L,
            2498L,
            2499L,
            2500L,
            2501L,
            2502L,
            2503L,
            2504L,
            2505L,
            2506L,
            2507L,
            2508L,
            2509L,
            2510L,
            2511L,
            2512L,
            2513L,
            2514L,
            2515L,
            2516L,
            2517L,
            2518L,
            2519L,
            2520L,
            2521L,
            2522L,
            2523L,
            2524L,
            2525L,
            2526L,
            2527L,
            2528L,
            2529L,
            2530L,
            2531L,
            2532L,
            2533L,
            2534L,
            2535L,
            2536L,
            2537L,
            2538L,
            2539L,
            2540L,
            2541L,
            2542L,
            2543L,
            2544L,
            2545L,
            2546L,
            2547L,
            2548L,
            2549L,
            2550L,
            2551L,
            2552L,
            2553L,
            2554L,
            2555L,
            2556L,
            2557L,
            2558L,
            2559L,
            2560L,
            2561L,
            2562L,
            2563L,
            2564L,
            2565L,
            2566L,
            2567L,
            2568L,
            2569L,
            2570L,
            2571L,
            2572L,
            2573L,
            2574L,
            2575L,
            2576L,
            2577L,
            2578L,
            2579L,
            2580L,
            2581L,
            2582L,
            2583L,
            2584L,
            2585L,
            2586L,
            2587L,
            2588L,
            2589L,
            2590L,
            2591L,
            2592L,
            2593L,
            2594L,
            2595L,
            2596L,
            2597L,
            2598L,
            2599L,
            2600L,
            2601L,
            2602L,
            2603L,
            2604L,
            2605L,
            2606L,
            2607L,
            2608L,
            2609L,
            2610L,
            2611L,
            2612L,
            2613L,
            2614L,
            2615L,
            2616L,
            2617L,
            2618L,
            2619L,
            2620L,
            2621L,
            2622L,
            2623L,
            2624L,
            2625L,
            2626L,
            2627L,
            2628L,
            2629L,
            2630L,
            2631L,
            2632L,
            2633L,
            2634L,
            2635L,
            2636L,
            2637L,
            2638L,
            2639L,
            2640L,
            2641L,
            2642L,
            2643L,
            2644L,
            2645L,
            2646L,
            2647L,
            2648L,
            2649L,
            2650L,
            2651L,
            2652L,
            2653L,
            2654L,
            2655L,
            2656L,
            2657L,
            2658L,
            2659L,
            2660L,
            2661L,
            2662L,
            2663L,
            2664L,
            2665L,
            2666L,
            2667L,
            2668L,
            2669L,
            2670L,
            2671L,
            2672L,
            2673L,
            2674L,
            2675L,
            2676L,
            2677L,
            2678L,
            2679L,
            2680L,
            2681L,
            2682L,
            2683L,
            2684L,
            2685L,
            2686L,
            2687L,
            2688L,
            2689L,
            2690L,
            2691L,
            2692L,
            2693L,
            2694L,
            2695L,
            2696L,
            2697L,
            2698L,
            2699L,
            2700L,
            2701L,
            2702L,
            2703L,
            2704L,
            2705L,
            2706L,
            2707L,
            2708L,
            2709L,
            2710L,
            2711L,
            2712L,
            2713L,
            2714L,
            2715L,
            2716L,
            2717L,
            2718L,
            2719L,
            2720L,
            2721L,
            2722L,
            2723L,
            2724L,
            2725L,
            2726L,
            2727L,
            2728L,
            2729L,
            2730L,
            2731L,
            2732L,
            2733L,
            2734L,
            2735L,
            2736L,
            2737L,
            2738L,
            2739L,
            2740L,
            2741L,
            2742L,
            2743L,
            2744L,
            2745L,
            2746L,
            2747L,
            2748L,
            2749L,
            2750L,
            2751L,
            2752L,
            2753L,
            2754L,
            2755L,
            2756L,
            2757L,
            2758L,
            2759L,
            2760L,
            2761L,
            2762L,
            2763L,
            2764L,
            2765L,
            2766L,
            2767L,
            2768L,
            2769L,
            2770L,
            2771L,
            2772L,
            2773L,
            2774L,
            2775L,
            2776L,
            2777L,
            2778L,
            2779L,
            2780L,
            2781L,
            2782L,
            2783L,
            2784L,
            2785L,
            2786L,
            2787L,
            2788L,
            2789L,
            2790L,
            2791L,
            2792L,
            2793L,
            2794L,
            2795L,
            2796L,
            2797L,
            2798L,
            2799L,
            2800L,
            2801L,
            2802L,
            2803L,
            2804L,
            2805L,
            2806L,
            2807L,
            2808L,
            2809L,
            2810L,
            2811L,
            2812L,
            2813L,
            2814L,
            2815L,
            2816L,
            2817L,
            2818L,
            2819L,
            2820L,
            2821L,
            2822L,
            2823L,
            2824L,
            2825L,
            2826L,
            2827L,
            2828L,
            2829L,
            2830L,
            2831L,
            2832L,
            2833L,
            2834L,
            2835L,
            2836L,
            2837L,
            2838L,
            2839L,
            2840L,
            2841L,
            2842L,
            2843L,
            2844L,
            2845L,
            2846L,
            2847L,
            2848L,
            2849L,
            2850L,
            2851L,
            2852L,
            2853L,
            2854L,
            2855L,
            2856L,
            2857L,
            2858L,
            2859L,
            2860L,
            2861L,
            2862L,
            2863L,
            2864L,
            2865L,
            2866L,
            2867L,
            2868L,
            2869L,
            2870L,
            2871L,
            2872L,
            2873L,
            2874L,
            2875L,
            2876L,
            2877L,
            2878L,
            2879L,
            2880L,
            2881L,
            2882L,
            2883L,
            2884L,
            2885L,
            2886L,
            2887L,
            2888L,
            2889L,
            2890L,
            2891L,
            2892L,
            2893L,
            2894L,
            2895L,
            2896L,
            2897L,
            2898L,
            2899L,
            2900L,
            2901L,
            2902L,
            2903L,
            2904L,
            2905L,
            2906L,
            2907L,
            2908L,
            2909L,
            2910L,
            2911L,
            2912L,
            2913L,
            2914L,
            2915L,
            2916L,
            2917L,
            2918L,
            2919L,
            2920L,
            2921L,
            2922L,
            2923L,
            2924L,
            2925L,
            2926L,
            2927L,
            2928L,
            2929L,
            2930L,
            2931L,
            2932L,
            2933L,
            2934L,
            2935L,
            2936L,
            2937L,
            2938L,
            2939L,
            2940L,
            2941L,
            2942L,
            2943L,
            2944L,
            2945L,
            2946L,
            2947L,
            2948L,
            2949L,
            2950L,
            2951L,
            2952L,
            2953L,
            2954L,
            2955L,
            2956L,
            2957L,
            2958L,
            2959L,
            2960L,
            2961L,
            2962L,
            2963L,
            2964L,
            2965L,
            2966L,
            2967L,
            2968L,
            2969L,
            2970L,
            2971L,
            2972L,
            2973L,
            2974L,
            2975L,
            2976L,
            2977L,
            2978L,
            2979L,
            2980L,
            2981L,
            2982L,
            2983L,
            2984L,
            2985L,
            2986L,
            2987L,
            2988L,
            2989L,
            2990L,
            2991L,
            2992L,
            2993L,
            2994L,
            2995L,
            2996L,
            2997L,
            2998L,
            2999L,
            3000L,
            3001L,
            3002L,
            3003L,
            3004L,
            3005L,
            3006L,
            3007L,
            3008L,
            3009L,
            3010L,
            3011L,
            3012L,
            3013L,
            3014L,
            3015L,
            3016L,
            3017L,
            3018L,
            3019L,
            3020L,
            3021L,
            3022L,
            3023L,
            3024L,
            3025L,
            3026L,
            3027L,
            3028L,
            3029L,
            3030L,
            3031L,
            3032L,
            3033L,
            3034L,
            3035L,
            3036L,
            3037L,
            3038L,
            3039L,
            3040L,
            3041L,
            3042L,
            3043L,
            3044L,
            3045L,
            3046L,
            3047L,
            3048L,
            3049L,
            3050L,
            3051L,
            3052L,
            3053L,
            3054L,
            3055L,
            3056L,
            3057L,
            3058L,
            3059L,
            3060L,
            3061L,
            3062L,
            3063L,
            3064L,
            3065L,
            3066L,
            3067L,
            3068L,
            3069L,
            3070L,
            3071L,
            3072L,
            3073L,
            3074L,
            3075L,
            3076L,
            3077L,
            3078L,
            3079L,
            3080L,
            3081L,
            3082L,
            3083L,
            3084L,
            3085L,
            3086L,
            3087L,
            3088L,
            3089L,
            3090L,
            3091L,
            3092L,
            3093L,
            3094L,
            3095L,
            3096L,
            3097L,
            3098L,
            3099L,
            3100L,
            3101L,
            3102L,
            3103L,
            3104L,
            3105L,
            3106L,
            3107L,
            3108L,
            3109L,
            3110L,
            3111L,
            3112L,
            3113L,
            3114L,
            3115L,
            3116L,
            3117L,
            3118L,
            3119L,
            3120L,
            3121L,
            3122L,
            3123L,
            3124L,
            3125L,
            3126L,
            3127L,
            3128L,
            3129L,
            3130L,
            3131L,
            3132L,
            3133L,
            3134L,
            3135L,
            3136L,
            3137L,
            3138L,
            3139L,
            3140L,
            3141L,
            3142L,
            3143L,
            3144L,
            3145L,
            3146L,
            3147L,
            3148L,
            3149L,
            3150L,
            3151L,
            3152L,
            3153L,
            3154L,
            3155L,
            3156L,
            3157L,
            3158L,
            3159L,
            3160L,
            3161L,
            3162L,
            3163L,
            3164L,
            3165L,
            3166L,
            3167L,
            3168L,
            3169L,
            3170L,
            3171L,
            3172L,
            3173L,
            3174L,
            3175L,
            3176L,
            3177L,
            3178L,
            3179L,
            3180L,
            3181L,
            3182L,
            3183L,
            3184L,
            3185L,
            3186L,
            3187L,
            3188L,
            3189L,
            3190L,
            3191L,
            3192L,
            3193L,
            3194L,
            3195L,
            3196L,
            3197L,
            3198L,
            3199L,
            3200L,
            3201L,
            3202L,
            3203L,
            3204L,
            3205L,
            3206L,
            3207L,
            3208L,
            3209L,
            3210L,
            3211L,
            3212L,
            3213L,
            3214L,
            3215L,
            3216L,
            3217L,
            3218L,
            3219L,
            3220L,
            3221L,
            3222L,
            3223L,
            3224L,
            3225L,
            3226L,
            3227L,
            3228L,
            3229L,
            3230L,
            3231L,
            3232L,
            3233L,
            3234L,
            3235L,
            3236L,
            3237L,
            3238L,
            3239L,
            3240L,
            3241L,
            3242L,
            3243L,
            3244L,
            3245L,
            3246L,
            3247L,
            3248L,
            3249L,
            3250L,
            3251L,
            3252L,
            3253L,
            3254L,
            3255L,
            3256L,
            3257L,
            3258L,
            3259L,
            3260L,
            3261L,
            3262L,
            3263L,
            3264L,
            3265L,
            3266L,
            3267L,
            3268L,
            3269L,
            3270L,
            3271L,
            3272L,
            3273L,
            3274L,
            3275L,
            3276L,
            3277L,
            3278L,
            3279L,
            3280L,
            3281L,
            3282L,
            3283L,
            3284L,
            3285L,
            3286L,
            3287L,
            3288L,
            3289L,
            3290L,
            3291L,
            3292L,
            3293L,
            3294L,
            3295L,
            3296L,
            3297L,
            3298L,
            3299L,
            3300L,
            3301L,
            3302L,
            3303L,
            3304L,
            3305L,
            3306L,
            3307L,
            3308L,
            3309L,
            3310L,
            3311L,
            3312L,
            3313L,
            3314L,
            3315L,
            3316L,
            3317L,
            3318L,
            3319L,
            3320L,
            3321L,
            3322L,
            3323L,
            3324L,
            3325L,
            3326L,
            3327L,
            3328L,
            3329L,
            3330L,
            3331L,
            3332L,
            3333L,
            3334L,
            3335L,
            3336L,
            3337L,
            3338L,
            3339L,
            3340L,
            3341L,
            3342L,
            3343L,
            3344L,
            3345L,
            3346L,
            3347L,
            3348L,
            3349L,
            3350L,
            3351L,
            3352L,
            3353L,
            3354L,
            3355L,
            3356L,
            3357L,
            3358L,
            3359L,
            3360L,
            3361L,
            3362L,
            3363L,
            3364L,
            3365L,
            3366L,
            3367L,
            3368L,
            3369L,
            3370L,
            3371L,
            3372L,
            3373L,
            3374L,
            3375L,
            3376L,
            3377L,
            3378L,
            3379L,
            3380L,
            3381L,
            3382L,
            3383L,
            3384L,
            3385L,
            3386L,
            3387L,
            3388L,
            3389L,
            3390L,
            3391L,
            3392L,
            3393L,
            3394L,
            3395L,
            3396L,
            3397L,
            3398L,
            3399L,
            3400L,
            3401L,
            3402L,
            3403L,
            3404L,
            3405L,
            3406L,
            3407L,
            3408L,
            3409L,
            3410L,
            3411L,
            3412L,
            3413L,
            3414L,
            3415L,
            3416L,
            3417L,
            3418L,
            3419L,
            3420L,
            3421L,
            3422L,
            3423L,
            3424L,
            3425L,
            3426L,
            3427L,
            3428L,
            3429L,
            3430L,
            3431L,
            3432L,
            3433L,
            3434L,
            3435L,
            3436L,
            3437L,
            3438L,
            3439L,
            3440L,
            3441L,
            3442L,
            3443L,
            3444L,
            3445L,
            3446L,
            3447L,
            3448L,
            3449L,
            3450L,
            3451L,
            3452L,
            3453L,
            3454L,
            3455L,
            3456L,
            3457L,
            3458L,
            3459L,
            3460L,
            3461L,
            3462L,
            3463L,
            3464L,
            3465L,
            3466L,
            3467L,
            3468L,
            3469L,
            3470L,
            3471L,
            3472L,
            3473L,
            3474L,
            3475L,
            3476L,
            3477L,
            3478L,
            3479L,
            3480L,
            3481L,
            3482L,
            3483L,
            3484L,
            3485L,
            3486L,
            3487L,
            3488L,
            3489L,
            3490L,
            3491L,
            3492L,
            3493L,
            3494L,
            3495L,
            3496L,
            3497L,
            3498L,
            3499L,
            3500L,
            3501L,
            3502L,
            3503L,
            3504L,
            3505L,
            3506L,
            3507L,
            3508L,
            3509L,
            3510L,
            3511L,
            3512L,
            3513L,
            3514L,
            3515L,
            3516L,
            3517L,
            3518L,
            3519L,
            3520L,
            3521L,
            3522L,
            3523L,
            3524L,
            3525L,
            3526L,
            3527L,
            3528L,
            3529L,
            3530L,
            3531L,
            3532L,
            3533L,
            3534L,
            3535L,
            3536L,
            3537L,
            3538L,
            3539L,
            3540L,
            3541L,
            3542L,
            3543L,
            3544L,
            3545L,
            3546L,
            3547L,
            3548L,
            3549L,
            3550L,
            3551L,
            3552L,
            3553L,
            3554L,
            3555L,
            3556L,
            3557L,
            3558L,
            3559L,
            3560L,
            3561L,
            3562L,
            3563L,
            3564L,
            3565L,
            3566L,
            3567L,
            3568L,
            3569L,
            3570L,
            3571L,
            3572L,
            3573L,
            3574L,
            3575L,
            3576L,
            3577L,
            3578L,
            3579L,
            3580L,
            3581L,
            3582L,
            3583L,
            3584L,
            3585L,
            3586L,
            3587L,
            3588L,
            3589L,
            3590L,
            3591L,
            3592L,
            3593L,
            3594L,
            3595L,
            3596L,
            3597L,
            3598L,
            3599L,
            3600L,
            3601L,
            3602L,
            3603L,
            3604L,
            3605L,
            3606L,
            3607L,
            3608L,
            3609L,
            3610L,
            3611L,
            3612L,
            3613L,
            3614L,
            3615L,
            3616L,
            3617L,
            3618L,
            3619L,
            3620L,
            3621L,
            3622L,
            3623L,
            3624L,
            3625L,
            3626L,
            3627L,
            3628L,
            3629L,
            3630L,
            3631L,
            3632L,
            3633L,
            3634L,
            3635L,
            3636L,
            3637L,
            3638L,
            3639L,
            3640L,
            3641L,
            3642L,
            3643L,
            3644L,
            3645L,
            3646L,
            3647L,
            3648L,
            3649L,
            3650L,
            3651L,
            3652L,
            3653L,
            3654L,
            3655L,
            3656L,
            3657L,
            3658L,
            3659L,
            3660L,
            3661L,
            3662L,
            3663L,
            3664L,
            3665L,
            3666L,
            3667L,
            3668L,
            3669L,
            3670L,
            3671L,
            3672L,
            3673L,
            3674L,
            3675L,
            3676L,
            3677L,
            3678L,
            3679L,
            3680L,
            3681L,
            3682L,
            3683L,
            3684L,
            3685L,
            3686L,
            3687L,
            3688L,
            3689L,
            3690L,
            3691L,
            3692L,
            3693L,
            3694L,
            3695L,
            3696L,
            3697L,
            3698L,
            3699L,
            3700L,
            3701L,
            3702L,
            3703L,
            3704L,
            3705L,
            3706L,
            3707L,
            3708L,
            3709L,
            3710L,
            3711L,
            3712L,
            3713L,
            3714L,
            3715L,
            3716L,
            3717L,
            3718L,
            3719L,
            3720L,
            3721L,
            3722L,
            3723L,
            3724L,
            3725L,
            3726L,
            3727L,
            3728L,
            3729L,
            3730L,
            3731L,
            3732L,
            3733L,
            3734L,
            3735L,
            3736L,
            3737L,
            3738L,
            3739L,
            3740L,
            3741L,
            3742L,
            3743L,
            3744L,
            3745L,
            3746L,
            3747L,
            3748L,
            3749L,
            3750L,
            3751L,
            3752L,
            3753L,
            3754L,
            3755L,
            3756L,
            3757L,
            3758L,
            3759L,
            3760L,
            3761L,
            3762L,
            3763L,
            3764L,
            3765L,
            3766L,
            3767L,
            3768L,
            3769L,
            3770L,
            3771L,
            3772L,
            3773L,
            3774L,
            3775L,
            3776L,
            3777L,
            3778L,
            3779L,
            3780L,
            3781L,
            3782L,
            3783L,
            3784L,
            3785L,
            3786L,
            3787L,
            3788L,
            3789L,
            3790L,
            3791L,
            3792L,
            3793L,
            3794L,
            3795L,
            3796L,
            3797L,
            3798L,
            3799L,
            3800L,
            3801L,
            3802L,
            3803L,
            3804L,
            3805L,
            3806L,
            3807L,
            3808L,
            3809L,
            3810L,
            3811L,
            3812L,
            3813L,
            3814L,
            3815L,
            3816L,
            3817L,
            3818L,
            3819L,
            3820L,
            3821L,
            3822L,
            3823L,
            3824L,
            3825L,
            3826L,
            3827L,
            3828L,
            3829L,
            3830L,
            3831L,
            3832L,
            3833L,
            3834L,
            3835L,
            3836L,
            3837L,
            3838L,
            3839L,
            3840L,
            3841L,
            3842L,
            3843L,
            3844L,
            3845L,
            3846L,
            3847L,
            3848L,
            3849L,
            3850L,
            3851L,
            3852L,
            3853L,
            3854L,
            3855L,
            3856L,
            3857L,
            3858L,
            3859L,
            3860L,
            3861L,
            3862L,
            3863L,
            3864L,
            3865L,
            3866L,
            3867L,
            3868L,
            3869L,
            3870L,
            3871L,
            3872L,
            3873L,
            3874L,
            3875L,
            3876L,
            3877L,
            3878L,
            3879L,
            3880L,
            3881L,
            3882L,
            3883L,
            3884L,
            3885L,
            3886L,
            3887L,
            3888L,
            3889L,
            3890L,
            3891L,
            3892L,
            3893L,
            3894L,
            3895L,
            3896L,
            3897L,
            3898L,
            3899L,
            3900L,
            3901L,
            3902L,
            3903L,
            3904L,
            3905L,
            3906L,
            3907L,
            3908L,
            3909L,
            3910L,
            3911L,
            3912L,
            3913L,
            3914L,
            3915L,
            3916L,
            3917L,
            3918L,
            3919L,
            3920L,
            3921L,
            3922L,
            3923L,
            3924L,
            3925L,
            3926L,
            3927L,
            3928L,
            3929L,
            3930L,
            3931L,
            3932L,
            3933L,
            3934L,
            3935L,
            3936L,
            3937L,
            3938L,
            3939L,
            3940L,
            3941L,
            3942L,
            3943L,
            3944L,
            3945L,
            3946L,
            3947L,
            3948L,
            3949L,
            3950L,
            3951L,
            3952L,
            3953L,
            3954L,
            3955L,
            3956L,
            3957L,
            3958L,
            3959L,
            3960L,
            3961L,
            3962L,
            3963L,
            3964L,
            3965L,
            3966L,
            3967L,
            3968L,
            3969L,
            3970L,
            3971L,
            3972L,
            3973L,
            3974L,
            3975L,
            3976L,
            3977L,
            3978L,
            3979L,
            3980L,
            3981L,
            3982L,
            3983L,
            3984L,
            3985L,
            3986L,
            3987L,
            3988L,
            3989L,
            3990L,
            3991L,
            3992L,
            3993L,
            3994L,
            3995L,
            3996L,
            3997L,
            3998L,
            3999L,
            4000L,
            4001L,
            4002L,
            4003L,
            4004L,
            4005L,
            4006L,
            4007L,
            4008L,
            4009L,
            4010L,
            4011L,
            4012L,
            4013L,
            4014L,
            4015L,
            4016L,
            4017L,
            4018L,
            4019L,
            4020L,
            4021L,
            4022L,
            4023L,
            4024L,
            4025L,
            4026L,
            4027L,
            4028L,
            4029L,
            4030L,
            4031L,
            4032L,
            4033L,
            4034L,
            4035L,
            4036L,
            4037L,
            4038L,
            4039L,
            4040L,
            4041L,
            4042L,
            4043L,
            4044L,
            4045L,
            4046L,
            4047L,
            4048L,
            4049L,
            4050L,
            4051L,
            4052L,
            4053L,
            4054L,
            4055L,
            4056L,
            4057L,
            4058L,
            4059L,
            4060L,
            4061L,
            4062L,
            4063L,
            4064L,
            4065L,
            4066L,
            4067L,
            4068L,
            4069L,
            4070L,
            4071L,
            4072L,
            4073L,
            4074L,
            4075L,
            4076L,
            4077L,
            4078L,
            4079L,
            4080L,
            4081L,
            4082L,
            4083L,
            4084L,
            4085L,
            4086L,
            4087L,
            4088L,
            4089L,
            4090L,
            4091L,
            4092L,
            4093L,
            4094L,
            4095L,
            4096L,
            4097L,
            4098L,
            4099L,
            4100L,
            4101L,
            4102L,
            4103L,
            4104L,
            4105L,
            4106L,
            4107L,
            4108L,
            4109L,
            4110L,
            4111L,
            4112L,
            4113L,
            4114L,
            4115L,
            4116L,
            4117L,
            4118L,
            4119L,
            4120L,
            4121L,
            4122L,
            4123L,
            4124L,
            4125L,
            4126L,
            4127L,
            4128L,
            4129L,
            4130L,
            4131L,
            4132L,
            4133L,
            4134L,
            4135L,
            4136L,
            4137L,
            4138L,
            4139L,
            4140L,
            4141L,
            4142L,
            4143L,
            4144L,
            4145L,
            4146L,
            4147L,
            4148L,
            4149L,
            4150L,
            4151L,
            4152L,
            4153L,
            4154L,
            4155L,
            4156L,
            4157L,
            4158L,
            4159L,
            4160L,
            4161L,
            4162L,
            4163L,
            4164L,
            4165L,
            4166L,
            4167L,
            4168L,
            4169L,
            4170L,
            4171L,
            4172L,
            4173L,
            4174L,
            4175L,
            4176L,
            4177L,
            4178L,
            4179L,
            4180L,
            4181L,
            4182L,
            4183L,
            4184L,
            4185L,
            4186L,
            4187L,
            4188L,
            4189L,
            4190L,
            4191L,
            4192L,
            4193L,
            4194L,
            4195L,
            4196L,
            4197L,
            4198L,
            4199L,
            4200L,
            4201L,
            4202L,
            4203L,
            4204L,
            4205L,
            4206L,
            4207L,
            4208L,
            4209L,
            4210L,
            4211L,
            4212L,
            4213L,
            4214L,
            4215L,
            4216L,
            4217L,
            4218L,
            4219L,
            4220L,
            4221L,
            4222L,
            4223L,
            4224L,
            4225L,
            4226L,
            4227L,
            4228L,
            4229L,
            4230L,
            4231L,
            4232L,
            4233L,
            4234L,
            4235L,
            4236L,
            4237L,
            4238L,
            4239L,
            4240L,
            4241L,
            4242L,
            4243L,
            4244L,
            4245L,
            4246L,
            4247L,
            4248L,
            4249L,
            4250L,
            4251L,
            4252L,
            4253L,
            4254L,
            4255L,
            4256L,
            4257L,
            4258L,
            4259L,
            4260L,
            4261L,
            4262L,
            4263L,
            4264L,
            4265L,
            4266L,
            4267L,
            4268L,
            4269L,
            4270L,
            4271L,
            4272L,
            4273L,
            4274L,
            4275L,
            4276L,
            4277L,
            4278L,
            4279L,
            4280L,
            4281L,
            4282L,
            4283L,
            4284L,
            4285L,
            4286L,
            4287L,
            4288L,
            4289L,
            4290L,
            4291L,
            4292L,
            4293L,
            4294L,
            4295L,
            4296L,
            4297L,
            4298L,
            4299L,
            4300L,
            4301L,
            4302L,
            4303L,
            4304L,
            4305L,
            4306L,
            4307L,
            4308L,
            4309L,
            4310L,
            4311L,
            4312L,
            4313L,
            4314L,
            4315L,
            4316L,
            4317L,
            4318L,
            4319L,
            4320L,
            4321L,
            4322L,
            4323L,
            4324L,
            4325L,
            4326L,
            4327L,
            4328L,
            4329L,
            4330L,
            4331L,
            4332L,
            4333L,
            4334L,
            4335L,
            4336L,
            4337L,
            4338L,
            4339L,
            4340L,
            4341L,
            4342L,
            4343L,
            4344L,
            4345L,
            4346L,
            4347L,
            4348L,
            4349L,
            4350L,
            4351L,
            4352L,
            4353L,
            4354L,
            4355L,
            4356L,
            4357L,
            4358L,
            4359L,
            4360L,
            4361L,
            4362L,
            4363L,
            4364L,
            4365L,
            4366L,
            4367L,
            4368L,
            4369L,
            4370L,
            4371L,
            4372L,
            4373L,
            4374L,
            4375L,
            4376L,
            4377L,
            4378L,
            4379L,
            4380L,
            4381L,
            4382L,
            4383L,
            4384L,
            4385L,
            4386L,
            4387L,
            4388L,
            4389L,
            4390L,
            4391L,
            4392L,
            4393L,
            4394L,
            4395L,
            4396L,
            4397L,
            4398L,
            4399L,
            4400L,
            4401L,
            4402L,
            4403L,
            4404L,
            4405L,
            4406L,
            4407L,
            4408L,
            4409L,
            4410L,
            4411L,
            4412L,
            4413L,
            4414L,
            4415L,
            4416L,
            4417L,
            4418L,
            4419L,
            4420L,
            4421L,
            4422L,
            4423L,
            4424L,
            4425L,
            4426L,
            4427L,
            4428L,
            4429L,
            4430L,
            4431L,
            4432L,
            4433L,
            4434L,
            4435L,
            4436L,
            4437L,
            4438L,
            4439L,
            4440L,
            4441L,
            4442L,
            4443L,
            4444L,
            4445L,
            4446L,
            4447L,
            4448L,
            4449L,
            4450L,
            4451L,
            4452L,
            4453L,
            4454L,
            4455L,
            4456L,
            4457L,
            4458L,
            4459L,
            4460L,
            4461L,
            4462L,
            4463L,
            4464L,
            4465L,
            4466L,
            4467L,
            4468L,
            4469L,
            4470L,
            4471L,
            4472L,
            4473L,
            4474L,
            4475L,
            4476L,
            4477L,
            4478L,
            4479L,
            4480L,
            4481L,
            4482L,
            4483L,
            4484L,
            4485L,
            4486L,
            4487L,
            4488L,
            4489L,
            4490L,
            4491L,
            4492L,
            4493L,
            4494L,
            4495L,
            4496L,
            4497L,
            4498L,
            4499L,
            4500L,
            4501L,
            4502L,
            4503L,
            4504L,
            4505L,
            4506L,
            4507L,
            4508L,
            4509L,
            4510L,
            4511L,
            4512L,
            4513L,
            4514L,
            4515L,
            4516L,
            4517L,
            4518L,
            4519L,
            4520L,
            4521L,
            4522L,
            4523L,
            4524L,
            4525L,
            4526L,
            4527L,
            4528L,
            4529L,
            4530L,
            4531L,
            4532L,
            4533L,
            4534L,
            4535L,
            4536L,
            4537L,
            4538L,
            4539L,
            4540L,
            4541L,
            4542L,
            4543L,
            4544L,
            4545L,
            4546L,
            4547L,
            4548L,
            4549L,
            4550L,
            4551L,
            4552L,
            4553L,
            4554L,
            4555L,
            4556L,
            4557L,
            4558L,
            4559L,
            4560L,
            4561L,
            4562L,
            4563L,
            4564L,
            4565L,
            4566L,
            4567L,
            4568L,
            4569L,
            4570L,
            4571L,
            4572L,
            4573L,
            4574L,
            4575L,
            4576L,
            4577L,
            4578L,
            4579L,
            4580L,
            4581L,
            4582L,
            4583L,
            4584L,
            4585L,
            4586L,
            4587L,
            4588L,
            4589L,
            4590L,
            4591L,
            4592L,
            4593L,
            4594L,
            4595L,
            4596L,
            4597L,
            4598L,
            4599L,
            4600L,
            4601L,
            4602L,
            4603L,
            4604L,
            4605L,
            4606L,
            4607L,
            4608L,
            4609L,
            4610L,
            4611L,
            4612L,
            4613L,
            4614L,
            4615L,
            4616L,
            4617L,
            4618L,
            4619L,
            4620L,
            4621L,
            4622L,
            4623L,
            4624L,
            4625L,
            4626L,
            4627L,
            4628L,
            4629L,
            4630L,
            4631L,
            4632L,
            4633L,
            4634L,
            4635L,
            4636L,
            4637L,
            4638L,
            4639L,
            4640L,
            4641L,
            4642L,
            4643L,
            4644L,
            4645L,
            4646L,
            4647L,
            4648L,
            4649L,
            4650L,
            4651L,
            4652L,
            4653L,
            4654L,
            4655L,
            4656L,
            4657L,
            4658L,
            4659L,
            4660L,
            4661L,
            4662L,
            4663L,
            4664L,
            4665L,
            4666L,
            4667L,
            4668L,
            4669L,
            4670L,
            4671L,
            4672L,
            4673L,
            4674L,
            4675L,
            4676L,
            4677L,
            4678L,
            4679L,
            4680L,
            4681L,
            4682L,
            4683L,
            4684L,
            4685L,
            4686L,
            4687L,
            4688L,
            4689L,
            4690L,
            4691L,
            4692L,
            4693L,
            4694L,
            4695L,
            4696L,
            4697L,
            4698L,
            4699L,
            4700L,
            4701L,
            4702L,
            4703L,
            4704L,
            4705L,
            4706L,
            4707L,
            4708L,
            4709L,
            4710L,
            4711L,
            4712L,
            4713L,
            4714L,
            4715L,
            4716L,
            4717L,
            4718L,
            4719L,
            4720L,
            4721L,
            4722L,
            4723L,
            4724L,
            4725L,
            4726L,
            4727L,
            4728L,
            4729L,
            4730L,
            4731L,
            4732L,
            4733L,
            4734L,
            4735L,
            4736L,
            4737L,
            4738L,
            4739L,
            4740L,
            4741L,
            4742L,
            4743L,
            4744L,
            4745L,
            4746L,
            4747L,
            4748L,
            4749L,
            4750L,
            4751L,
            4752L,
            4753L,
            4754L,
            4755L,
            4756L,
            4757L,
            4758L,
            4759L,
            4760L,
            4761L,
            4762L,
            4763L,
            4764L,
            4765L,
            4766L,
            4767L,
            4768L,
            4769L,
            4770L,
            4771L,
            4772L,
            4773L,
            4774L,
            4775L,
            4776L,
            4777L,
            4778L,
            4779L,
            4780L,
            4781L,
            4782L,
            4783L,
            4784L,
            4785L,
            4786L,
            4787L,
            4788L,
            4789L,
            4790L,
            4791L,
            4792L,
            4793L,
            4794L,
            4795L,
            4796L,
            4797L,
            4798L,
            4799L,
            4800L,
            4801L,
            4802L,
            4803L,
            4804L,
            4805L,
            4806L,
            4807L,
            4808L,
            4809L,
            4810L,
            4811L,
            4812L,
            4813L,
            4814L,
            4815L,
            4816L,
            4817L,
            4818L,
            4819L,
            4820L,
            4821L
        };
        static const std::vector<int64_t> retval(values, values + 4822);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_builtin_function_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_builtin_function_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_builtin_function_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_builtin_function_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_builtin_function_kind_tag() {
        return stringify::a_builtin_function_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/il.h line 83
namespace stringify {
    const char* a_type_info_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "tik_user";
            case 1L: return "tik_fundamental";
            case 2L: return "tik_enum";
            case 3L: return "tik_array";
            case 4L: return "tik_function";
            case 5L: return "tik_class";
            case 6L: return "tik_si_class";
            case 7L: return "tik_vmi_class";
            case 8L: return "tik_pbase";
            case 9L: return "tik_pointer";
            case 10L: return "tik_ptr_to_member";
            case 11L: return "tik_implementation";
            case 12L: return "tik_last";
            default: return "";
        }
    }

    std::string a_type_info_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_type_info_kind_tag(i);
        if (s.empty())
            s = "(a_type_info_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_type_info_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L
        };
        static const std::vector<int64_t> retval(values, values + 13);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_type_info_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_type_info_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_type_info_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_type_info_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_type_info_kind_tag() {
        return stringify::a_type_info_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/symbol_tbl.h line 464
namespace stringify {
    const char* a_symbol_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "sk_keyword";
            case 1L: return "sk_macro";
            case 2L: return "sk_constant";
            case 3L: return "sk_type";
            case 4L: return "sk_class_or_struct_tag";
            case 5L: return "sk_union_tag";
            case 6L: return "sk_enum_tag";
            case 7L: return "sk_variable";
            case 8L: return "sk_field";
            case 9L: return "sk_static_data_member";
            case 10L: return "sk_member_function";
            case 11L: return "sk_routine";
            case 12L: return "sk_label";
            case 13L: return "sk_undefined";
            case 14L: return "sk_extern_variable";
            case 15L: return "sk_extern_routine";
            case 16L: return "sk_projection";
            case 17L: return "sk_overloaded_function";
            case 18L: return "sk_parameter";
            case 19L: return "sk_class_template";
            case 20L: return "sk_function_template";
            case 21L: return "sk_variable_template";
            case 22L: return "sk_namespace";
            case 23L: return "sk_namespace_projection";
            case 24L: return "sk_named_address_space";
            case 25L: return "sk_named_register";
            case 26L: return "sk_property_set";
            case 27L: return "sk_last";
            default: return "";
        }
    }

    std::string a_symbol_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_symbol_kind_tag(i);
        if (s.empty())
            s = "(a_symbol_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_symbol_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L
        };
        static const std::vector<int64_t> retval(values, values + 28);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_symbol_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_symbol_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_symbol_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_symbol_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_symbol_kind_tag() {
        return stringify::a_symbol_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/symbol_tbl.h line 763
namespace stringify {
    const char* a_dependent_type_fixup_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "dtfk_arg_transfer_method";
            case 1L: return "dtfk_routine_calling_method";
            case 2L: return "dtfk_array_type_size";
            case 3L: return "dtfk_array_of_abstract_class_check";
            default: return "";
        }
    }

    std::string a_dependent_type_fixup_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_dependent_type_fixup_kind_tag(i);
        if (s.empty())
            s = "(a_dependent_type_fixup_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_dependent_type_fixup_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_dependent_type_fixup_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_dependent_type_fixup_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_dependent_type_fixup_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_dependent_type_fixup_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_dependent_type_fixup_kind_tag() {
        return stringify::a_dependent_type_fixup_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/symbol_tbl.h line 4006
namespace stringify {
    const char* a_cli_operator_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "cok_none";
            case 1L: return "cok_first";
            case 2L: return "cok_addition_assignment";
            case 3L: return "cok_address_of";
            case 4L: return "cok_assign";
            case 5L: return "cok_bitwise_and";
            case 6L: return "cok_bitwise_and_assignment";
            case 7L: return "cok_bitwise_or";
            case 8L: return "cok_bitwise_or_assignment";
            case 9L: return "cok_comma";
            case 10L: return "cok_decrement";
            case 11L: return "cok_division";
            case 12L: return "cok_division_assignment";
            case 13L: return "cok_equality";
            case 14L: return "cok_exclusive_or";
            case 15L: return "cok_exclusive_or_assignment";
            case 16L: return "cok_explicit";
            case 17L: return "cok_false";
            case 18L: return "cok_function_call";
            case 19L: return "cok_greater_than";
            case 20L: return "cok_greater_than_or_equal";
            case 21L: return "cok_implicit";
            case 22L: return "cok_increment";
            case 23L: return "cok_inequality";
            case 24L: return "cok_left_shift";
            case 25L: return "cok_left_shift_assignment";
            case 26L: return "cok_less_than";
            case 27L: return "cok_less_than_or_equal";
            case 28L: return "cok_logical_and";
            case 29L: return "cok_logical_not";
            case 30L: return "cok_logical_or";
            case 31L: return "cok_member_selection";
            case 32L: return "cok_modulus";
            case 33L: return "cok_modulus_assignment";
            case 34L: return "cok_multiply";
            case 35L: return "cok_multiplication_assignment";
            case 36L: return "cok_ones_complement";
            case 37L: return "cok_pointer_dereference";
            case 38L: return "cok_pointer_to_member_selection";
            case 39L: return "cok_right_shift";
            case 40L: return "cok_right_shift_assignment";
            case 41L: return "cok_signed_right_shift";
            case 42L: return "cok_subscript";
            case 43L: return "cok_subtraction";
            case 44L: return "cok_subtraction_assignment";
            case 45L: return "cok_true";
            case 46L: return "cok_unary_negation";
            case 47L: return "cok_unary_plus";
            case 48L: return "cok_unsigned_right_shift";
            case 49L: return "cok_unsigned_right_shift_assignment";
            case 50L: return "cok_last";
            default: return "";
        }
    }

    std::string a_cli_operator_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_cli_operator_kind_tag(i);
        if (s.empty())
            s = "(a_cli_operator_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_cli_operator_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L
        };
        static const std::vector<int64_t> retval(values, values + 51);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_cli_operator_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_cli_operator_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_cli_operator_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_cli_operator_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_cli_operator_kind_tag() {
        return stringify::a_cli_operator_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/src/symbol_tbl.h line 4901
namespace stringify {
    const char* a_cli_symbol_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "csk_none";
            case 1L: return "csk_first_namespace";
            case 2L: return "csk_system_namespace";
            case 3L: return "csk_system_collections_namespace";
            case 4L: return "csk_system_collections_generic_namespace";
            case 5L: return "csk_platform_details_namespace";
            case 6L: return "csk_platform_metadata_namespace";
            case 7L: return "csk_windows_namespace";
            case 8L: return "csk_windows_foundation_namespace";
            case 9L: return "csk_windows_foundation_metadata_namespace";
            case 10L: return "csk_windows_foundation_collections_namespace";
            case 11L: return "csk_first_type";
            default: return "";
        }
    }

    std::string a_cli_symbol_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_cli_symbol_kind_tag(i);
        if (s.empty())
            s = "(a_cli_symbol_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_cli_symbol_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L
        };
        static const std::vector<int64_t> retval(values, values + 12);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_cli_symbol_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_cli_symbol_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_cli_symbol_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_cli_symbol_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_cli_symbol_kind_tag() {
        return stringify::a_cli_symbol_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/include/cxxabi.h line 62
namespace stringify { namespace __cxxabiv1 { namespace __base_class_type_info {
    const char* __offset_flags_masks(int64_t i) {
        switch (i) {
            case 1L: return "__virtual_mask";
            case 2L: return "__public_mask";
            case 8L: return "__offset_shift";
            default: return "";
        }
    }

    std::string __offset_flags_masks(int64_t i, const std::string &strip) {
        std::string s = __offset_flags_masks(i);
        if (s.empty())
            s = "(__cxxabiv1::__base_class_type_info::__offset_flags_masks)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& __offset_flags_masks() {
        static const int64_t values[] = {
            1L,
            2L,
            8L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}

namespace Rose {
    std::string stringify__cxxabiv1__base_class_type_info__offset_flags_masks(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::__cxxabiv1::__base_class_type_info::__offset_flags_masks(i);
        if (retval.empty()) {
            retval = "(__cxxabiv1::__base_class_type_info::__offset_flags_masks)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "__cxxabiv1::__base_class_type_info::__offset_flags_masks::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify__cxxabiv1__base_class_type_info__offset_flags_masks() {
        return stringify::__cxxabiv1::__base_class_type_info::__offset_flags_masks();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/include/cxxabi.h line 77
namespace stringify { namespace __cxxabiv1 { namespace __vmi_class_type_info {
    const char* __flags_masks(int64_t i) {
        switch (i) {
            case 1L: return "__non_diamond_repeat_mask";
            case 2L: return "__diamond_shaped_mask";
            default: return "";
        }
    }

    std::string __flags_masks(int64_t i, const std::string &strip) {
        std::string s = __flags_masks(i);
        if (s.empty())
            s = "(__cxxabiv1::__vmi_class_type_info::__flags_masks)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& __flags_masks() {
        static const int64_t values[] = {
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}

namespace Rose {
    std::string stringify__cxxabiv1__vmi_class_type_info__flags_masks(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::__cxxabiv1::__vmi_class_type_info::__flags_masks(i);
        if (retval.empty()) {
            retval = "(__cxxabiv1::__vmi_class_type_info::__flags_masks)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "__cxxabiv1::__vmi_class_type_info::__flags_masks::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify__cxxabiv1__vmi_class_type_info__flags_masks() {
        return stringify::__cxxabiv1::__vmi_class_type_info::__flags_masks();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/include/cxxabi.h line 90
namespace stringify { namespace __cxxabiv1 { namespace __pbase_type_info {
    const char* __masks(int64_t i) {
        switch (i) {
            case 1L: return "__const_mask";
            case 2L: return "__volatile_mask";
            case 4L: return "__restrict_mask";
            case 8L: return "__incomplete_mask";
            case 16L: return "__incomplete_class_mask";
            default: return "";
        }
    }

    std::string __masks(int64_t i, const std::string &strip) {
        std::string s = __masks(i);
        if (s.empty())
            s = "(__cxxabiv1::__pbase_type_info::__masks)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& __masks() {
        static const int64_t values[] = {
            1L,
            2L,
            4L,
            8L,
            16L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}}

namespace Rose {
    std::string stringify__cxxabiv1__pbase_type_info__masks(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::__cxxabiv1::__pbase_type_info::__masks(i);
        if (retval.empty()) {
            retval = "(__cxxabiv1::__pbase_type_info::__masks)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "__cxxabiv1::__pbase_type_info::__masks::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify__cxxabiv1__pbase_type_info__masks() {
        return stringify::__cxxabiv1::__pbase_type_info::__masks();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.0/util/decode.c line 4308
namespace stringify {
    const char* a_substitution_kind(int64_t i) {
        switch (i) {
            case 0L: return "subk_unscoped_template_name";
            case 1L: return "subk_prefix";
            case 2L: return "subk_template_prefix";
            case 3L: return "subk_type";
            case 4L: return "subk_template_template_param";
            default: return "";
        }
    }

    std::string a_substitution_kind(int64_t i, const std::string &strip) {
        std::string s = a_substitution_kind(i);
        if (s.empty())
            s = "(a_substitution_kind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_substitution_kind() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_substitution_kind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_substitution_kind(i);
        if (retval.empty()) {
            retval = "(a_substitution_kind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_substitution_kind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_substitution_kind() {
        return stringify::a_substitution_kind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/error.c line 91
namespace stringify {
    const char* a_diag_fill_in_kind(int64_t i) {
        switch (i) {
            case 0L: return "dfk_number";
            case 1L: return "dfk_position";
            case 2L: return "dfk_string";
            case 3L: return "dfk_symbol";
            case 4L: return "dfk_type";
            case 5L: return "dfk_last";
            default: return "";
        }
    }

    std::string a_diag_fill_in_kind(int64_t i, const std::string &strip) {
        std::string s = a_diag_fill_in_kind(i);
        if (s.empty())
            s = "(a_diag_fill_in_kind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_diag_fill_in_kind() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_diag_fill_in_kind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_diag_fill_in_kind(i);
        if (retval.empty()) {
            retval = "(a_diag_fill_in_kind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_diag_fill_in_kind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_diag_fill_in_kind() {
        return stringify::a_diag_fill_in_kind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/error.c line 196
namespace stringify {
    const char* a_diagnostic_kind(int64_t i) {
        switch (i) {
            case 0L: return "dck_primary";
            case 1L: return "dck_sub_message";
            case 2L: return "dck_context";
            case 3L: return "dck_macro_context";
            default: return "";
        }
    }

    std::string a_diagnostic_kind(int64_t i, const std::string &strip) {
        std::string s = a_diagnostic_kind(i);
        if (s.empty())
            s = "(a_diagnostic_kind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_diagnostic_kind() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_diagnostic_kind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_diagnostic_kind(i);
        if (retval.empty()) {
            retval = "(a_diagnostic_kind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_diagnostic_kind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_diagnostic_kind() {
        return stringify::a_diagnostic_kind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/disp/decls.c line 16203
namespace stringify {
    const char* an_end_of_decl_action(int64_t i) {
        switch (i) {
            case 0L: return "eoda_not_at_end";
            case 1L: return "eoda_deferred_actions";
            case 2L: return "eoda_check_semicolon";
            case 3L: return "eoda_skip_final_token";
            case 4L: return "eoda_done";
            default: return "";
        }
    }

    std::string an_end_of_decl_action(int64_t i, const std::string &strip) {
        std::string s = an_end_of_decl_action(i);
        if (s.empty())
            s = "(an_end_of_decl_action)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_end_of_decl_action() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_end_of_decl_action(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_end_of_decl_action(i);
        if (retval.empty()) {
            retval = "(an_end_of_decl_action)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_end_of_decl_action::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_end_of_decl_action() {
        return stringify::an_end_of_decl_action();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.1/src/decls.h line 24
namespace stringify {
    const char* a_tu_decl_stage(int64_t i) {
        switch (i) {
            case 0L: return "tud_none";
            case 1L: return "tud_basic_tu";
            case 2L: return "tud_global_module_fgmt";
            case 3L: return "tud_module_unit";
            case 4L: return "tud_private_module_fgmt";
            default: return "";
        }
    }

    std::string a_tu_decl_stage(int64_t i, const std::string &strip) {
        std::string s = a_tu_decl_stage(i);
        if (s.empty())
            s = "(a_tu_decl_stage)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_tu_decl_stage() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_tu_decl_stage(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_tu_decl_stage(i);
        if (retval.empty()) {
            retval = "(a_tu_decl_stage)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_tu_decl_stage::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_tu_decl_stage() {
        return stringify::a_tu_decl_stage();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.1/src/il_def.h line 17318
namespace stringify {
    const char* a_module_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "mk_none";
            case 1L: return "mk_header";
            case 2L: return "mk_edg";
            case 3L: return "mk_ifc";
            default: return "";
        }
    }

    std::string a_module_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_module_kind_tag(i);
        if (s.empty())
            s = "(a_module_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_module_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_module_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_module_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_module_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_module_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_module_kind_tag() {
        return stringify::a_module_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/Clang/clang-frontend-private.hpp line 150
namespace stringify { namespace ClangToSageTranslator {
    const char* Language(int64_t i) {
        switch (i) {
            case 0L: return "C";
            case 1L: return "CPLUSPLUS";
            case 2L: return "OBJC";
            case 3L: return "CUDA";
            case 4L: return "OPENCL";
            case 5L: return "unknown";
            default: return "";
        }
    }

    std::string Language(int64_t i, const std::string &strip) {
        std::string s = Language(i);
        if (s.empty())
            s = "(ClangToSageTranslator::Language)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Language() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyClangToSageTranslatorLanguage(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ClangToSageTranslator::Language(i);
        if (retval.empty()) {
            retval = "(ClangToSageTranslator::Language)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ClangToSageTranslator::Language::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyClangToSageTranslatorLanguage() {
        return stringify::ClangToSageTranslator::Language();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/Clang/clang-to-dot-private.hpp line 152
namespace stringify { namespace ClangToDotTranslator {
    const char* Language(int64_t i) {
        switch (i) {
            case 0L: return "C";
            case 1L: return "CPLUSPLUS";
            case 2L: return "OBJC";
            case 3L: return "CUDA";
            case 4L: return "OPENCL";
            case 5L: return "unknown";
            default: return "";
        }
    }

    std::string Language(int64_t i, const std::string &strip) {
        std::string s = Language(i);
        if (s.empty())
            s = "(ClangToDotTranslator::Language)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Language() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyClangToDotTranslatorLanguage(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ClangToDotTranslator::Language(i);
        if (retval.empty()) {
            retval = "(ClangToDotTranslator::Language)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ClangToDotTranslator::Language::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyClangToDotTranslatorLanguage() {
        return stringify::ClangToDotTranslator::Language();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/Clang/clang-to-dot-private.hpp line 223
namespace stringify { namespace ClangToDotTranslator { namespace ClangToDotTranslator {
    const char* Language(int64_t i) {
        switch (i) {
            case 0L: return "C";
            case 1L: return "CPLUSPLUS";
            case 2L: return "OBJC";
            case 3L: return "CUDA";
            case 4L: return "OPENCL";
            case 5L: return "unknown";
            default: return "";
        }
    }

    std::string Language(int64_t i, const std::string &strip) {
        std::string s = Language(i);
        if (s.empty())
            s = "(ClangToDotTranslator::ClangToDotTranslator::Language)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Language() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyClangToDotTranslatorClangToDotTranslatorLanguage(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ClangToDotTranslator::ClangToDotTranslator::Language(i);
        if (retval.empty()) {
            retval = "(ClangToDotTranslator::ClangToDotTranslator::Language)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ClangToDotTranslator::ClangToDotTranslator::Language::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyClangToDotTranslatorClangToDotTranslatorLanguage() {
        return stringify::ClangToDotTranslator::ClangToDotTranslator::Language();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_General_Language_Support/general_language_translation.h line 14
namespace stringify { namespace LanguageTranslation {
    const char* FunctionModifier(int64_t i) {
        switch (i) {
            case 0L: return "e_function_modifier_none";
            case 1L: return "e_function_modifier_reentrant";
            case 2L: return "e_function_modifier_recursive";
            case 3L: return "e_function_modifier_definition";
            case 4L: return "e_function_modifier_reference";
            case 5L: return "e_function_modifier_elemental";
            case 6L: return "e_function_modifier_impure";
            case 7L: return "e_function_modifier_module";
            case 8L: return "e_function_modifier_pure";
            case 9L: return "e_function_modifier_last";
            default: return "";
        }
    }

    std::string FunctionModifier(int64_t i, const std::string &strip) {
        std::string s = FunctionModifier(i);
        if (s.empty())
            s = "(LanguageTranslation::FunctionModifier)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& FunctionModifier() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L
        };
        static const std::vector<int64_t> retval(values, values + 10);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyLanguageTranslationFunctionModifier(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::LanguageTranslation::FunctionModifier(i);
        if (retval.empty()) {
            retval = "(LanguageTranslation::FunctionModifier)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "LanguageTranslation::FunctionModifier::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyLanguageTranslationFunctionModifier() {
        return stringify::LanguageTranslation::FunctionModifier();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_General_Language_Support/general_language_translation.h line 35
namespace stringify { namespace LanguageTranslation {
    const char* PackingSpecifier(int64_t i) {
        switch (i) {
            case 0L: return "e_packing_spec_unknown";
            case 1L: return "e_packing_spec_none";
            case 2L: return "e_packing_spec_mixed";
            case 3L: return "e_packing_spec_dense";
            default: return "";
        }
    }

    std::string PackingSpecifier(int64_t i, const std::string &strip) {
        std::string s = PackingSpecifier(i);
        if (s.empty())
            s = "(LanguageTranslation::PackingSpecifier)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& PackingSpecifier() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyLanguageTranslationPackingSpecifier(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::LanguageTranslation::PackingSpecifier(i);
        if (retval.empty()) {
            retval = "(LanguageTranslation::PackingSpecifier)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "LanguageTranslation::PackingSpecifier::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyLanguageTranslationPackingSpecifier() {
        return stringify::LanguageTranslation::PackingSpecifier();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_General_Language_Support/general_language_translation.h line 45
namespace stringify { namespace LanguageTranslation {
    const char* ExpressionKind(int64_t i) {
        switch (i) {
            case 0L: return "e_none";
            case 1L: return "e_unknown";
            case 2L: return "e_access_modifier_public";
            case 3L: return "e_access_modifier_private";
            case 4L: return "e_storage_modifier_contiguous";
            case 5L: return "e_storage_modifier_external";
            case 6L: return "e_storage_modifier_static";
            case 7L: return "e_storage_modifier_location";
            case 8L: return "e_storage_modifier_jovial_def";
            case 9L: return "e_storage_modifier_jovial_ref";
            case 10L: return "e_type_modifier_list";
            case 11L: return "e_type_modifier_allocatable";
            case 12L: return "e_type_modifier_asynchronous";
            case 13L: return "e_type_modifier_const";
            case 14L: return "e_type_modifier_intent_in";
            case 15L: return "e_type_modifier_intent_out";
            case 16L: return "e_type_modifier_intent_inout";
            case 17L: return "e_type_modifier_intrinsic";
            case 18L: return "e_type_modifier_optional";
            case 19L: return "e_type_modifier_pointer";
            case 20L: return "e_type_modifier_protected";
            case 21L: return "e_type_modifier_round";
            case 22L: return "e_type_modifier_save";
            case 23L: return "e_type_modifier_target";
            case 24L: return "e_type_modifier_truncate";
            case 25L: return "e_type_modifier_volatile";
            case 26L: return "e_type_modifier_z";
            case 27L: return "e_param_binding_value";
            case 28L: return "e_param_binding_reference";
            case 29L: return "e_param_binding_result";
            case 30L: return "e_struct_modifier_list";
            case 31L: return "e_struct_item_modifier_list";
            case 32L: return "e_operator_assign";
            case 33L: return "e_operator_exponentiate";
            case 34L: return "e_operator_concatenate";
            case 35L: return "e_operator_add";
            case 36L: return "e_operator_subtract";
            case 37L: return "e_operator_mod";
            case 38L: return "e_operator_multiply";
            case 39L: return "e_operator_divide";
            case 40L: return "e_operator_and";
            case 41L: return "e_operator_or";
            case 42L: return "e_operator_xor";
            case 43L: return "e_operator_equiv";
            case 44L: return "e_operator_less_than";
            case 45L: return "e_operator_greater_than";
            case 46L: return "e_operator_less_or_equal";
            case 47L: return "e_operator_greater_or_equal";
            case 48L: return "e_operator_equality";
            case 49L: return "e_operator_not_equal";
            case 50L: return "e_operator_eqv";
            case 51L: return "e_operator_not_eqv";
            case 52L: return "e_operator_unary_plus";
            case 53L: return "e_operator_unary_minus";
            case 54L: return "e_operator_unary_not";
            case 55L: return "e_operator_unity";
            case 56L: return "e_literalExpression";
            case 57L: return "e_function_reference";
            case 58L: return "e_procedure_call";
            case 59L: return "e_argument_list";
            case 60L: return "e_argument_keyword";
            case 61L: return "e_variable_reference";
            case 62L: return "e_array_reference";
            case 63L: return "e_case_range";
            case 64L: return "e_case_selector";
            case 65L: return "e_array_shape";
            case 66L: return "e_explicit_shape";
            case 67L: return "e_assumed_or_implied_shape";
            case 68L: return "e_assumed_shape";
            case 69L: return "e_assumed_size";
            case 70L: return "e_array_subscripts";
            case 71L: return "e_array_index_triplet";
            case 72L: return "e_section_subscripts";
            case 73L: return "e_explicit_dimension";
            case 74L: return "e_star_dimension";
            case 75L: return "e_star_expression";
            case 76L: return "e_initializer";
            case 77L: return "e_struct_initializer";
            case 78L: return "e_switch_stmt";
            case 79L: return "e_end_switch_stmt";
            case 80L: return "e_case_option_stmt";
            case 81L: return "e_case_default_option_stmt";
            case 82L: return "e_end_proc_ref_stmt";
            case 83L: return "e_end_proc_def_stmt";
            case 84L: return "e_define_directive_stmt";
            case 85L: return "e_fortran_dimension_stmt";
            case 86L: return "e_fortran_import_stmt";
            case 87L: return "e_fortran_if_stmt";
            case 88L: return "e_fortran_if_then_stmt";
            case 89L: return "e_fortran_else_if_stmt";
            case 90L: return "e_fortran_else_stmt";
            case 91L: return "e_fortran_end_do_stmt";
            case 92L: return "e_fortran_do_concurrent_stmt";
            case 93L: return "e_fortran_concurrent_header";
            case 94L: return "e_fortran_concurrent_control";
            case 95L: return "e_fortran_concurrent_locality";
            case 96L: return "e_fortran_forall_stmt";
            case 97L: return "e_fortran_end_forall_stmt";
            case 98L: return "e_fortran_sync_all_stmt";
            case 99L: return "e_fortran_sync_images_stmt";
            case 100L: return "e_fortran_sync_memory_stmt";
            case 101L: return "e_fortran_sync_team_stmt";
            case 102L: return "e_fortran_lock_stmt";
            case 103L: return "e_fortran_unlock_stmt";
            case 104L: return "e_fortran_sync_stat_list";
            case 105L: return "e_fortran_sync_stat_stat";
            case 106L: return "e_fortran_sync_stat_errmsg";
            case 107L: return "e_fortran_stat_acquired_lock";
            case 108L: return "e_jovial_compool_stmt";
            case 109L: return "e_cuda_host";
            case 110L: return "e_cuda_device";
            case 111L: return "e_cuda_global_function";
            case 112L: return "e_cuda_grid_global";
            case 113L: return "e_cuda_global";
            case 114L: return "e_cuda_device_memory";
            case 115L: return "e_cuda_managed";
            case 116L: return "e_cuda_constant";
            case 117L: return "e_cuda_shared";
            case 118L: return "e_cuda_pinned";
            case 119L: return "e_cuda_texture";
            case 120L: return "e_last";
            default: return "";
        }
    }

    std::string ExpressionKind(int64_t i, const std::string &strip) {
        std::string s = ExpressionKind(i);
        if (s.empty())
            s = "(LanguageTranslation::ExpressionKind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ExpressionKind() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L,
            58L,
            59L,
            60L,
            61L,
            62L,
            63L,
            64L,
            65L,
            66L,
            67L,
            68L,
            69L,
            70L,
            71L,
            72L,
            73L,
            74L,
            75L,
            76L,
            77L,
            78L,
            79L,
            80L,
            81L,
            82L,
            83L,
            84L,
            85L,
            86L,
            87L,
            88L,
            89L,
            90L,
            91L,
            92L,
            93L,
            94L,
            95L,
            96L,
            97L,
            98L,
            99L,
            100L,
            101L,
            102L,
            103L,
            104L,
            105L,
            106L,
            107L,
            108L,
            109L,
            110L,
            111L,
            112L,
            113L,
            114L,
            115L,
            116L,
            117L,
            118L,
            119L,
            120L
        };
        static const std::vector<int64_t> retval(values, values + 121);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyLanguageTranslationExpressionKind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::LanguageTranslation::ExpressionKind(i);
        if (retval.empty()) {
            retval = "(LanguageTranslation::ExpressionKind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "LanguageTranslation::ExpressionKind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyLanguageTranslationExpressionKind() {
        return stringify::LanguageTranslation::ExpressionKind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/OpenFortranParser_SAGE_Connection/rose_token_defs.h line 10
namespace stringify {
    const char* ROSE_Fortran_Identifiers(int64_t i) {
        switch (i) {
            case 2L: return "ROSE_ABSTRACT";
            case 3L: return "ROSE_ACCESS";
            case 4L: return "ROSE_ACTION";
            case 5L: return "ROSE_ALLOCATE";
            case 6L: return "ROSE_ALLOCATABLE";
            case 7L: return "ROSE_ASSIGN";
            case 8L: return "ROSE_ASSOCIATE";
            case 9L: return "ROSE_ASYNCHRONOUS";
            case 10L: return "ROSE_BACKSPACE";
            case 11L: return "ROSE_BIND";
            case 12L: return "ROSE_BLANK";
            case 13L: return "ROSE_BLOCK_DATA";
            case 14L: return "ROSE_CALL";
            case 15L: return "ROSE_CHARACTER";
            case 16L: return "ROSE_CLASS";
            case 17L: return "ROSE_CLOSE";
            case 18L: return "ROSE_CONTINUE";
            case 19L: return "ROSE_CYCLE";
            case 20L: return "ROSE_CASE";
            case 21L: return "ROSE_COMMON";
            case 22L: return "ROSE_COMPLEX";
            case 23L: return "ROSE_CONTAINS";
            case 24L: return "ROSE_DEALLOCATE";
            case 25L: return "ROSE_DATA";
            case 26L: return "ROSE_DEFERRED";
            case 27L: return "ROSE_DELIM";
            case 28L: return "ROSE_DIMENSION";
            case 29L: return "ROSE_DO";
            case 30L: return "ROSE_DT";
            case 31L: return "ROSE_DOUBLEPRECISION";
            case 32L: return "ROSE_ENCODING";
            case 33L: return "ROSE_END_CASE";
            case 34L: return "ROSE_ENDDO";
            case 35L: return "ROSE_END_FILE";
            case 36L: return "ROSE_END_ENUM";
            case 37L: return "ROSE_END_INTERFACE";
            case 38L: return "ROSE_END_TYPE";
            case 39L: return "ROSE_ERR";
            case 40L: return "ROSE_ERRMSG";
            case 41L: return "ROSE_EXIT";
            case 42L: return "ROSE_ELSE";
            case 43L: return "ROSE_ELSEWHERE";
            case 44L: return "ROSE_ELSEIF";
            case 45L: return "ROSE_ENDIF";
            case 46L: return "ROSE_ENTRY";
            case 47L: return "ROSE_ENUM";
            case 49L: return "ROSE_ENUMERATOR";
            case 50L: return "ROSE_EQUIVALENCE";
            case 51L: return "ROSE_EXTERNAL";
            case 52L: return "ROSE_EXTENDS";
            case 53L: return "ROSE_FILE";
            case 54L: return "ROSE_FINAL";
            case 55L: return "ROSE_FMT";
            case 56L: return "ROSE_FORALL";
            case 57L: return "ROSE_FORM";
            case 58L: return "ROSE_FORMATTED";
            case 59L: return "ROSE_FORMAT";
            case 60L: return "ROSE_FLUSH";
            case 61L: return "ROSE_FUNCTION";
            case 62L: return "ROSE_GENERIC";
            case 63L: return "ROSE_GOTO";
            case 64L: return "ROSE_ID";
            case 65L: return "ROSE_IF";
            case 66L: return "ROSE_INQUIRE";
            case 67L: return "ROSE_INTEGER";
            case 68L: return "ROSE_IOMSG";
            case 69L: return "ROSE_IOSTAT";
            case 70L: return "ROSE_IMPLICIT";
            case 71L: return "ROSE_IMPLICIT_NONE";
            case 72L: return "ROSE_IMPORT";
            case 73L: return "ROSE_INTERFACE";
            case 74L: return "ROSE_INTENT";
            case 75L: return "ROSE_INTRINSIC";
            case 76L: return "ROSE_LEN";
            case 77L: return "ROSE_LOGICAL";
            case 78L: return "ROSE_KIND";
            case 79L: return "ROSE_MODULE_PROC";
            case 80L: return "ROSE_MODULE";
            case 81L: return "ROSE_NON_INTRINSIC";
            case 82L: return "ROSE_NON_OVERRIDABLE";
            case 83L: return "ROSE_NULL";
            case 84L: return "ROSE_NULLIFY";
            case 85L: return "ROSE_NAMELIST";
            case 86L: return "ROSE_NML";
            case 87L: return "ROSE_NONE";
            case 88L: return "ROSE_NOPASS";
            case 89L: return "ROSE_ONLY";
            case 90L: return "ROSE_OPTIONAL";
            case 91L: return "ROSE_PARAMETER";
            case 92L: return "ROSE_PASS";
            case 93L: return "ROSE_PAUSE";
            case 94L: return "ROSE_POINTER";
            case 96L: return "ROSE_PRINT";
            case 97L: return "ROSE_PRIVATE";
            case 98L: return "ROSE_PROCEDURE";
            case 99L: return "ROSE_PROGRAM";
            case 100L: return "ROSE_PROTECTED";
            case 101L: return "ROSE_READ";
            case 102L: return "ROSE_REAL";
            case 103L: return "ROSE_RETURN";
            case 104L: return "ROSE_REWIND";
            case 105L: return "ROSE_ROUND";
            case 106L: return "ROSE_SELECTCASE";
            case 107L: return "ROSE_SELECTTYPE";
            case 108L: return "ROSE_SEQUENCE";
            case 109L: return "ROSE_SAVE";
            case 110L: return "ROSE_SIGN";
            case 111L: return "ROSE_SIZE";
            case 112L: return "ROSE_SOURCE";
            case 113L: return "ROSE_STAT";
            case 114L: return "ROSE_STOP";
            case 115L: return "ROSE_SUBROUTINE";
            case 116L: return "ROSE_TARGET";
            case 117L: return "ROSE_THEN";
            case 118L: return "ROSE_DERIVED_DECL";
            case 119L: return "ROSE_TYPEIS";
            case 120L: return "ROSE_UNFORMATTED";
            case 121L: return "ROSE_UNIT";
            case 122L: return "ROSE_USE";
            case 123L: return "ROSE_VALUE";
            case 124L: return "ROSE_VOLATILE";
            case 125L: return "ROSE_WAIT";
            case 126L: return "ROSE_WHERE";
            case 127L: return "ROSE_WRITE";
            default: return "";
        }
    }

    std::string ROSE_Fortran_Identifiers(int64_t i, const std::string &strip) {
        std::string s = ROSE_Fortran_Identifiers(i);
        if (s.empty())
            s = "(ROSE_Fortran_Identifiers)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ROSE_Fortran_Identifiers() {
        static const int64_t values[] = {
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L,
            58L,
            59L,
            60L,
            61L,
            62L,
            63L,
            64L,
            65L,
            66L,
            67L,
            68L,
            69L,
            70L,
            71L,
            72L,
            73L,
            74L,
            75L,
            76L,
            77L,
            78L,
            79L,
            80L,
            81L,
            82L,
            83L,
            84L,
            85L,
            86L,
            87L,
            88L,
            89L,
            90L,
            91L,
            92L,
            93L,
            94L,
            96L,
            97L,
            98L,
            99L,
            100L,
            101L,
            102L,
            103L,
            104L,
            105L,
            106L,
            107L,
            108L,
            109L,
            110L,
            111L,
            112L,
            113L,
            114L,
            115L,
            116L,
            117L,
            118L,
            119L,
            120L,
            121L,
            122L,
            123L,
            124L,
            125L,
            126L,
            127L
        };
        static const std::vector<int64_t> retval(values, values + 124);
        return retval;
    }

}

namespace Rose {
    std::string stringifyROSE_Fortran_Identifiers(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ROSE_Fortran_Identifiers(i);
        if (retval.empty()) {
            retval = "(ROSE_Fortran_Identifiers)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ROSE_Fortran_Identifiers::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyROSE_Fortran_Identifiers() {
        return stringify::ROSE_Fortran_Identifiers();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/OpenFortranParser_SAGE_Connection/rose_token_defs.h line 140
namespace stringify {
    const char* ROSE_Fortran_Operators(int64_t i) {
        switch (i) {
            case 1001L: return "ROSE_INTRINSIC_PLUS";
            case 1002L: return "ROSE_INTRINSIC_MINUS";
            case 1003L: return "ROSE_INTRINSIC_POWER";
            case 1004L: return "ROSE_INTRINSIC_CONCAT";
            case 1005L: return "ROSE_INTRINSIC_TIMES";
            case 1006L: return "ROSE_INTRINSIC_DIVIDE";
            case 1007L: return "ROSE_INTRINSIC_AND";
            case 1008L: return "ROSE_INTRINSIC_OR";
            case 1009L: return "ROSE_INTRINSIC_EQV";
            case 1010L: return "ROSE_INTRINSIC_NEQV";
            case 1011L: return "ROSE_INTRINSIC_EQ";
            case 1012L: return "ROSE_INTRINSIC_NE";
            case 1013L: return "ROSE_INTRINSIC_GE";
            case 1014L: return "ROSE_INTRINSIC_LE";
            case 1015L: return "ROSE_INTRINSIC_LT";
            case 1016L: return "ROSE_INTRINSIC_GT";
            case 1017L: return "ROSE_INTRINSIC_NOT";
            case 1018L: return "ROSE_INTRINSIC_OLDEQ";
            case 1019L: return "ROSE_INTRINSIC_OLDNE";
            case 1020L: return "ROSE_INTRINSIC_OLDGE";
            case 1021L: return "ROSE_INTRINSIC_OLDLE";
            case 1022L: return "ROSE_INTRINSIC_OLDLT";
            case 1023L: return "ROSE_INTRINSIC_OLDGT";
            default: return "";
        }
    }

    std::string ROSE_Fortran_Operators(int64_t i, const std::string &strip) {
        std::string s = ROSE_Fortran_Operators(i);
        if (s.empty())
            s = "(ROSE_Fortran_Operators)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ROSE_Fortran_Operators() {
        static const int64_t values[] = {
            1001L,
            1002L,
            1003L,
            1004L,
            1005L,
            1006L,
            1007L,
            1008L,
            1009L,
            1010L,
            1011L,
            1012L,
            1013L,
            1014L,
            1015L,
            1016L,
            1017L,
            1018L,
            1019L,
            1020L,
            1021L,
            1022L,
            1023L
        };
        static const std::vector<int64_t> retval(values, values + 23);
        return retval;
    }

}

namespace Rose {
    std::string stringifyROSE_Fortran_Operators(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ROSE_Fortran_Operators(i);
        if (retval.empty()) {
            retval = "(ROSE_Fortran_Operators)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ROSE_Fortran_Operators::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyROSE_Fortran_Operators() {
        return stringify::ROSE_Fortran_Operators();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/OpenFortranParser_SAGE_Connection/rose_token_defs.h line 167
namespace stringify {
    const char* ROSE_Fortran_Additional_Info(int64_t i) {
        switch (i) {
            case 10001L: return "ROSE_FORT_COMMENTS";
            case 10002L: return "ROSE_STRING_LITERALS";
            case 10003L: return "ROSE_IDENTIFIER";
            default: return "";
        }
    }

    std::string ROSE_Fortran_Additional_Info(int64_t i, const std::string &strip) {
        std::string s = ROSE_Fortran_Additional_Info(i);
        if (s.empty())
            s = "(ROSE_Fortran_Additional_Info)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ROSE_Fortran_Additional_Info() {
        static const int64_t values[] = {
            10001L,
            10002L,
            10003L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyROSE_Fortran_Additional_Info(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ROSE_Fortran_Additional_Info(i);
        if (retval.empty()) {
            retval = "(ROSE_Fortran_Additional_Info)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ROSE_Fortran_Additional_Info::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyROSE_Fortran_Additional_Info() {
        return stringify::ROSE_Fortran_Additional_Info();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/OpenFortranParser_SAGE_Connection/rose_token_defs_gen.h line 14
namespace stringify { namespace ROSE_Fortran_defs {
    const char* ROSE_Fortran_keywords(int64_t i) {
        switch (i) {
            case 0L: return "FORTRAN_ABSTRACT";
            case 1L: return "FORTRAN_ACCESS";
            case 2L: return "FORTRAN_ACTION";
            case 3L: return "FORTRAN_ALLOCATE";
            case 4L: return "FORTRAN_ALLOCATABLE";
            case 5L: return "FORTRAN_ASSIGN";
            case 6L: return "FORTRAN_ASSOCIATE";
            case 7L: return "FORTRAN_ASYNCHRONOUS";
            case 8L: return "FORTRAN_BACKSPACE";
            case 9L: return "FORTRAN_BIND";
            case 10L: return "FORTRAN_BLANK";
            case 11L: return "FORTRAN_BLOCK_DATA";
            case 12L: return "FORTRAN_CALL";
            case 13L: return "FORTRAN_CHARACTER";
            case 14L: return "FORTRAN_CLASS";
            case 15L: return "FORTRAN_CLOSE";
            case 16L: return "FORTRAN_CONTINUE";
            case 17L: return "FORTRAN_CYCLE";
            case 18L: return "FORTRAN_CASE";
            case 19L: return "FORTRAN_COMMON";
            case 20L: return "FORTRAN_COMPLEX";
            case 21L: return "FORTRAN_CONTAINS";
            case 22L: return "FORTRAN_DEALLOCATE";
            case 23L: return "FORTRAN_DATA";
            case 24L: return "FORTRAN_DEFERRED";
            case 25L: return "FORTRAN_DELIM";
            case 26L: return "FORTRAN_DIMENSION";
            case 27L: return "FORTRAN_DO";
            case 28L: return "FORTRAN_DT";
            case 29L: return "FORTRAN_DOUBLEPRECISION";
            case 30L: return "FORTRAN_ENCODING";
            case 31L: return "FORTRAN_END_CASE";
            case 32L: return "FORTRAN_ENDDO";
            case 33L: return "FORTRAN_END_FILE";
            case 34L: return "FORTRAN_END_ENUM";
            case 35L: return "FORTRAN_END_INTERFACE";
            case 36L: return "FORTRAN_END_TYPE";
            case 37L: return "FORTRAN_ERR";
            case 38L: return "FORTRAN_ERRMSG";
            case 39L: return "FORTRAN_EXIT";
            case 40L: return "FORTRAN_ELSE";
            case 41L: return "FORTRAN_ELSEWHERE";
            case 42L: return "FORTRAN_ELSEIF";
            case 43L: return "FORTRAN_ENDIF";
            case 44L: return "FORTRAN_ENTRY";
            case 45L: return "FORTRAN_END";
            case 46L: return "FORTRAN_ENUM";
            case 47L: return "FORTRAN_ENUMERATOR";
            case 48L: return "FORTRAN_EQUIVALENCE";
            case 49L: return "FORTRAN_EXTERNAL";
            case 50L: return "FORTRAN_EXTENDS";
            case 51L: return "FORTRAN_FILE";
            case 52L: return "FORTRAN_FINAL";
            case 53L: return "FORTRAN_FMT";
            case 54L: return "FORTRAN_FORALL";
            case 55L: return "FORTRAN_FORM";
            case 56L: return "FORTRAN_FORMATTED";
            case 57L: return "FORTRAN_FORMAT";
            case 58L: return "FORTRAN_FLUSH";
            case 59L: return "FORTRAN_FUNCTION";
            case 60L: return "FORTRAN_GENERIC";
            case 61L: return "FORTRAN_GOTO";
            case 62L: return "FORTRAN_ID";
            case 63L: return "FORTRAN_IF";
            case 64L: return "FORTRAN_INQUIRE";
            case 65L: return "FORTRAN_INTEGER";
            case 66L: return "FORTRAN_IOMSG";
            case 67L: return "FORTRAN_IOSTAT";
            case 68L: return "FORTRAN_IMPLICIT";
            case 69L: return "FORTRAN_IMPLICIT_NONE";
            case 70L: return "FORTRAN_IMPORT";
            case 71L: return "FORTRAN_INTERFACE";
            case 72L: return "FORTRAN_INTENT";
            case 73L: return "FORTRAN_INTRINSIC";
            case 74L: return "FORTRAN_LEN";
            case 75L: return "FORTRAN_LOGICAL";
            case 76L: return "FORTRAN_KIND";
            case 77L: return "FORTRAN_MODULE_PROC";
            case 78L: return "FORTRAN_MODULE";
            case 79L: return "FORTRAN_NON_INTRINSIC";
            case 80L: return "FORTRAN_NON_OVERRIDABLE";
            case 81L: return "FORTRAN_NULL";
            case 82L: return "FORTRAN_NULLIFY";
            case 83L: return "FORTRAN_NAMELIST";
            case 84L: return "FORTRAN_NML";
            case 85L: return "FORTRAN_NONE";
            case 86L: return "FORTRAN_NOPASS";
            case 87L: return "FORTRAN_ONLY";
            case 88L: return "FORTRAN_OPEN";
            case 89L: return "FORTRAN_OPTIONAL";
            case 90L: return "FORTRAN_PARAMETER";
            case 91L: return "FORTRAN_PASS";
            case 92L: return "FORTRAN_PAUSE";
            case 93L: return "FORTRAN_POINTER";
            case 94L: return "FORTRAN_PRINT";
            case 95L: return "FORTRAN_PRIVATE";
            case 96L: return "FORTRAN_PROCEDURE";
            case 97L: return "FORTRAN_PROGRAM";
            case 98L: return "FORTRAN_PROTECTED";
            case 99L: return "FORTRAN_READ";
            case 100L: return "FORTRAN_REAL";
            case 101L: return "FORTRAN_RETURN";
            case 102L: return "FORTRAN_REWIND";
            case 103L: return "FORTRAN_ROUND";
            case 104L: return "FORTRAN_SELECTCASE";
            case 105L: return "FORTRAN_SELECTTYPE";
            case 106L: return "FORTRAN_SEQUENCE";
            case 107L: return "FORTRAN_SAVE";
            case 108L: return "FORTRAN_SIGN";
            case 109L: return "FORTRAN_SIZE";
            case 110L: return "FORTRAN_SOURCE";
            case 111L: return "FORTRAN_STAT";
            case 112L: return "FORTRAN_STOP";
            case 113L: return "FORTRAN_SUBROUTINE";
            case 114L: return "FORTRAN_TARGET";
            case 115L: return "FORTRAN_THEN";
            case 116L: return "FORTRAN_DERIVED_DECL";
            case 117L: return "FORTRAN_TYPEIS";
            case 118L: return "FORTRAN_UNFORMATTED";
            case 119L: return "FORTRAN_UNIT";
            case 120L: return "FORTRAN_USE";
            case 121L: return "FORTRAN_VALUE";
            case 122L: return "FORTRAN_VOLATILE";
            case 123L: return "FORTRAN_WAIT";
            case 124L: return "FORTRAN_WHERE";
            case 125L: return "FORTRAN_WRITE";
            default: return "";
        }
    }

    std::string ROSE_Fortran_keywords(int64_t i, const std::string &strip) {
        std::string s = ROSE_Fortran_keywords(i);
        if (s.empty())
            s = "(ROSE_Fortran_defs::ROSE_Fortran_keywords)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ROSE_Fortran_keywords() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L,
            58L,
            59L,
            60L,
            61L,
            62L,
            63L,
            64L,
            65L,
            66L,
            67L,
            68L,
            69L,
            70L,
            71L,
            72L,
            73L,
            74L,
            75L,
            76L,
            77L,
            78L,
            79L,
            80L,
            81L,
            82L,
            83L,
            84L,
            85L,
            86L,
            87L,
            88L,
            89L,
            90L,
            91L,
            92L,
            93L,
            94L,
            95L,
            96L,
            97L,
            98L,
            99L,
            100L,
            101L,
            102L,
            103L,
            104L,
            105L,
            106L,
            107L,
            108L,
            109L,
            110L,
            111L,
            112L,
            113L,
            114L,
            115L,
            116L,
            117L,
            118L,
            119L,
            120L,
            121L,
            122L,
            123L,
            124L,
            125L
        };
        static const std::vector<int64_t> retval(values, values + 126);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyROSE_Fortran_defsROSE_Fortran_keywords(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ROSE_Fortran_defs::ROSE_Fortran_keywords(i);
        if (retval.empty()) {
            retval = "(ROSE_Fortran_defs::ROSE_Fortran_keywords)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ROSE_Fortran_defs::ROSE_Fortran_keywords::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyROSE_Fortran_defsROSE_Fortran_keywords() {
        return stringify::ROSE_Fortran_defs::ROSE_Fortran_keywords();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/OpenFortranParser_SAGE_Connection/rose_token_defs_gen.h line 147
namespace stringify { namespace ROSE_Fortran_defs {
    const char* ROSE_C_CXX_keywords(int64_t i) {
        switch (i) {
            case 500L: return "C_CXX_ASM";
            case 501L: return "C_CXX_AUTO";
            case 502L: return "C_CXX_BOOL";
            case 503L: return "C_CXX_BREAK";
            case 504L: return "C_CXX_CASE";
            case 505L: return "C_CXX_CATCH";
            case 506L: return "C_CXX_CHAR";
            case 507L: return "C_CXX_CLASS";
            case 508L: return "C_CXX_CONST";
            case 509L: return "C_CXX_CONSTCAST";
            case 510L: return "C_CXX_CONTINUE";
            case 511L: return "C_CXX_DEFAULT";
            case 512L: return "C_CXX_DEFINED";
            case 513L: return "C_CXX_DELETE";
            case 514L: return "C_CXX_DO";
            case 515L: return "C_CXX_DOUBLE";
            case 516L: return "C_CXX_DYNAMICCAST";
            case 517L: return "C_CXX_ELSE";
            case 518L: return "C_CXX_ENUM";
            case 519L: return "C_CXX_EXPLICIT";
            case 520L: return "C_CXX_EXPORT";
            case 521L: return "C_CXX_EXTERN";
            case 522L: return "C_CXX_FALSE";
            case 523L: return "C_CXX_FLOAT";
            case 524L: return "C_CXX_FOR";
            case 525L: return "C_CXX_FRIEND";
            case 526L: return "C_CXX_GOTO";
            case 527L: return "C_CXX_IF";
            case 528L: return "C_CXX_INLINE";
            case 529L: return "C_CXX_INT";
            case 530L: return "C_CXX_LONG";
            case 531L: return "C_CXX_MUTABLE";
            case 532L: return "C_CXX_NAMESPACE";
            case 533L: return "C_CXX_NEW";
            case 534L: return "C_CXX_OPERATOR";
            case 535L: return "C_CXX_PRIVATE";
            case 536L: return "C_CXX_PROTECTED";
            case 537L: return "C_CXX_PUBLIC";
            case 538L: return "C_CXX_REGISTER";
            case 539L: return "C_CXX_REINTERPRETCAST";
            case 540L: return "C_CXX_RETURN";
            case 541L: return "C_CXX_SHORT";
            case 542L: return "C_CXX_SIGNED";
            case 543L: return "C_CXX_SIZEOF";
            case 544L: return "C_CXX_STATIC";
            case 545L: return "C_CXX_STATICCAST";
            case 546L: return "C_CXX_STRUCT";
            case 547L: return "C_CXX_SWITCH";
            case 548L: return "C_CXX_TEMPLATE";
            case 549L: return "C_CXX_THIS";
            case 550L: return "C_CXX_THROW";
            case 551L: return "C_CXX_TRY";
            case 552L: return "C_CXX_TRUE";
            case 553L: return "C_CXX_TYPEDEF";
            case 554L: return "C_CXX_TYPEID";
            case 555L: return "C_CXX_TYPENAME";
            case 556L: return "C_CXX_UNION";
            case 557L: return "C_CXX_UNSIGNED";
            case 558L: return "C_CXX_USING";
            case 559L: return "C_CXX_VIRTUAL";
            case 560L: return "C_CXX_VOID";
            case 561L: return "C_CXX_VOLATILE";
            case 562L: return "C_CXX_WCHART";
            case 563L: return "C_CXX_WHILE";
            default: return "";
        }
    }

    std::string ROSE_C_CXX_keywords(int64_t i, const std::string &strip) {
        std::string s = ROSE_C_CXX_keywords(i);
        if (s.empty())
            s = "(ROSE_Fortran_defs::ROSE_C_CXX_keywords)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ROSE_C_CXX_keywords() {
        static const int64_t values[] = {
            500L,
            501L,
            502L,
            503L,
            504L,
            505L,
            506L,
            507L,
            508L,
            509L,
            510L,
            511L,
            512L,
            513L,
            514L,
            515L,
            516L,
            517L,
            518L,
            519L,
            520L,
            521L,
            522L,
            523L,
            524L,
            525L,
            526L,
            527L,
            528L,
            529L,
            530L,
            531L,
            532L,
            533L,
            534L,
            535L,
            536L,
            537L,
            538L,
            539L,
            540L,
            541L,
            542L,
            543L,
            544L,
            545L,
            546L,
            547L,
            548L,
            549L,
            550L,
            551L,
            552L,
            553L,
            554L,
            555L,
            556L,
            557L,
            558L,
            559L,
            560L,
            561L,
            562L,
            563L
        };
        static const std::vector<int64_t> retval(values, values + 64);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyROSE_Fortran_defsROSE_C_CXX_keywords(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ROSE_Fortran_defs::ROSE_C_CXX_keywords(i);
        if (retval.empty()) {
            retval = "(ROSE_Fortran_defs::ROSE_C_CXX_keywords)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ROSE_Fortran_defs::ROSE_C_CXX_keywords::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyROSE_Fortran_defsROSE_C_CXX_keywords() {
        return stringify::ROSE_Fortran_defs::ROSE_C_CXX_keywords();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/OpenFortranParser_SAGE_Connection/rose_token_defs_gen.h line 215
namespace stringify { namespace ROSE_Fortran_defs {
    const char* ROSE_Fortran_Operators(int64_t i) {
        switch (i) {
            case 10000L: return "FORTRAN_INTRINSIC_PLUS";
            case 10001L: return "FORTRAN_INTRINSIC_MINUS";
            case 10002L: return "FORTRAN_INTRINSIC_POWER";
            case 10003L: return "FORTRAN_INTRINSIC_CONCAT";
            case 10004L: return "FORTRAN_INTRINSIC_TIMES";
            case 10005L: return "FORTRAN_INTRINSIC_DIVIDE";
            case 10006L: return "FORTRAN_INTRINSIC_AND";
            case 10007L: return "FORTRAN_INTRINSIC_OR";
            case 10008L: return "FORTRAN_INTRINSIC_EQV";
            case 10009L: return "FORTRAN_INTRINSIC_NEQV";
            case 10010L: return "FORTRAN_INTRINSIC_EQ";
            case 10011L: return "FORTRAN_INTRINSIC_NE";
            case 10012L: return "FORTRAN_INTRINSIC_GE";
            case 10013L: return "FORTRAN_INTRINSIC_LE";
            case 10014L: return "FORTRAN_INTRINSIC_LT";
            case 10015L: return "FORTRAN_INTRINSIC_GT";
            case 10016L: return "FORTRAN_INTRINSIC_NOT";
            case 10017L: return "FORTRAN_INTRINSIC_OLDEQ";
            case 10018L: return "FORTRAN_INTRINSIC_OLDNE";
            case 10019L: return "FORTRAN_INTRINSIC_OLDGE";
            case 10020L: return "FORTRAN_INTRINSIC_OLDLE";
            case 10021L: return "FORTRAN_INTRINSIC_OLDLT";
            case 10022L: return "FORTRAN_INTRINSIC_OLDGT";
            default: return "";
        }
    }

    std::string ROSE_Fortran_Operators(int64_t i, const std::string &strip) {
        std::string s = ROSE_Fortran_Operators(i);
        if (s.empty())
            s = "(ROSE_Fortran_defs::ROSE_Fortran_Operators)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ROSE_Fortran_Operators() {
        static const int64_t values[] = {
            10000L,
            10001L,
            10002L,
            10003L,
            10004L,
            10005L,
            10006L,
            10007L,
            10008L,
            10009L,
            10010L,
            10011L,
            10012L,
            10013L,
            10014L,
            10015L,
            10016L,
            10017L,
            10018L,
            10019L,
            10020L,
            10021L,
            10022L
        };
        static const std::vector<int64_t> retval(values, values + 23);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyROSE_Fortran_defsROSE_Fortran_Operators(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ROSE_Fortran_defs::ROSE_Fortran_Operators(i);
        if (retval.empty()) {
            retval = "(ROSE_Fortran_defs::ROSE_Fortran_Operators)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ROSE_Fortran_defs::ROSE_Fortran_Operators::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyROSE_Fortran_defsROSE_Fortran_Operators() {
        return stringify::ROSE_Fortran_defs::ROSE_Fortran_Operators();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/OpenFortranParser_SAGE_Connection/rose_token_defs_gen.h line 242
namespace stringify { namespace ROSE_Fortran_defs {
    const char* ROSE_C_CXX_operators(int64_t i) {
        switch (i) {
            case 50000L: return "C_CXX_AND";
            case 50001L: return "C_CXX_ANDAND";
            case 50002L: return "C_CXX_ASSIGN";
            case 50003L: return "C_CXX_ANDASSIGN";
            case 50004L: return "C_CXX_OR";
            case 50005L: return "C_CXX_ORASSIGN";
            case 50006L: return "C_CXX_XOR";
            case 50007L: return "C_CXX_XORASSIGN";
            case 50008L: return "C_CXX_COMMA";
            case 50009L: return "C_CXX_COLON";
            case 50010L: return "C_CXX_DIVIDE";
            case 50011L: return "C_CXX_DIVIDEASSIGN";
            case 50012L: return "C_CXX_DOT";
            case 50013L: return "C_CXX_DOTSTAR";
            case 50014L: return "C_CXX_ELLIPSIS";
            case 50015L: return "C_CXX_EQUAL";
            case 50016L: return "C_CXX_GREATER";
            case 50017L: return "C_CXX_GREATEREQUAL";
            case 50018L: return "C_CXX_LEFTBRACE";
            case 50019L: return "C_CXX_LESS";
            case 50020L: return "C_CXX_LESSEQUAL";
            case 50021L: return "C_CXX_LEFTPAREN";
            case 50022L: return "C_CXX_LEFTBRACKET";
            case 50023L: return "C_CXX_MINUS";
            case 50024L: return "C_CXX_MINUSASSIGN";
            case 50025L: return "C_CXX_MINUSMINUS";
            case 50026L: return "C_CXX_PERCENT";
            case 50027L: return "C_CXX_PERCENTASSIGN";
            case 50028L: return "C_CXX_NOT";
            case 50029L: return "C_CXX_NOTEQUAL";
            case 50030L: return "C_CXX_OROR";
            case 50031L: return "C_CXX_PLUS";
            case 50032L: return "C_CXX_PLUSASSIGN";
            case 50033L: return "C_CXX_PLUSPLUS";
            case 50034L: return "C_CXX_ARROW";
            case 50035L: return "C_CXX_ARROWSTAR";
            case 50036L: return "C_CXX_QUESTION_MARK";
            case 50037L: return "C_CXX_RIGHTBRACE";
            case 50038L: return "C_CXX_RIGHTPAREN";
            case 50039L: return "C_CXX_RIGHTBRACKET";
            case 50040L: return "C_CXX_COLON_COLON";
            case 50041L: return "C_CXX_SEMICOLON";
            case 50042L: return "C_CXX_SHIFTLEFT";
            case 50043L: return "C_CXX_SHIFTLEFTASSIGN";
            case 50044L: return "C_CXX_SHIFTRIGHT";
            case 50045L: return "C_CXX_SHIFTRIGHTASSIGN";
            case 50046L: return "C_CXX_STAR";
            case 50047L: return "C_CXX_COMPL";
            case 50048L: return "C_CXX_STARASSIGN";
            case 50049L: return "C_CXX_POUND_POUND";
            case 50050L: return "C_CXX_POUND";
            case 50051L: return "C_CXX_AND_ALT";
            case 50052L: return "C_CXX_ANDASSIGN_ALT";
            case 50053L: return "C_CXX_OR_ALT";
            case 50054L: return "C_CXX_ORASSIGN_ALT";
            case 50055L: return "C_CXX_XOR_ALT";
            case 50056L: return "C_CXX_XORASSIGN_ALT";
            case 50057L: return "C_CXX_LEFTBRACE_ALT";
            case 50058L: return "C_CXX_LEFTBRACKET_ALT";
            case 50059L: return "C_CXX_NOT_ALT";
            case 50060L: return "C_CXX_NOTEQUAL_ALT";
            case 50061L: return "C_CXX_RIGHTBRACE_ALT";
            case 50062L: return "C_CXX_RIGHTBRACKET_ALT";
            case 50063L: return "C_CXX_COMPL_ALT";
            case 50064L: return "C_CXX_POUND_POUND_ALT";
            case 50065L: return "C_CXX_POUND_ALT";
            case 50066L: return "C_CXX_OR_TRIGRAPH";
            case 50067L: return "C_CXX_XOR_TRIGRAPH";
            case 50068L: return "C_CXX_LEFTBRACE_TRIGRAPH";
            case 50069L: return "C_CXX_LEFTBRACKET_TRIGRAPH";
            case 50070L: return "C_CXX_RIGHTBRACE_TRIGRAPH";
            case 50071L: return "C_CXX_RIGHTBRACKET_TRIGRAPH";
            case 50072L: return "C_CXX_COMPL_TRIGRAPH";
            case 50073L: return "C_CXX_POUND_POUND_TRIGRAPH";
            case 50074L: return "C_CXX_POUND_TRIGRAPH";
            default: return "";
        }
    }

    std::string ROSE_C_CXX_operators(int64_t i, const std::string &strip) {
        std::string s = ROSE_C_CXX_operators(i);
        if (s.empty())
            s = "(ROSE_Fortran_defs::ROSE_C_CXX_operators)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ROSE_C_CXX_operators() {
        static const int64_t values[] = {
            50000L,
            50001L,
            50002L,
            50003L,
            50004L,
            50005L,
            50006L,
            50007L,
            50008L,
            50009L,
            50010L,
            50011L,
            50012L,
            50013L,
            50014L,
            50015L,
            50016L,
            50017L,
            50018L,
            50019L,
            50020L,
            50021L,
            50022L,
            50023L,
            50024L,
            50025L,
            50026L,
            50027L,
            50028L,
            50029L,
            50030L,
            50031L,
            50032L,
            50033L,
            50034L,
            50035L,
            50036L,
            50037L,
            50038L,
            50039L,
            50040L,
            50041L,
            50042L,
            50043L,
            50044L,
            50045L,
            50046L,
            50047L,
            50048L,
            50049L,
            50050L,
            50051L,
            50052L,
            50053L,
            50054L,
            50055L,
            50056L,
            50057L,
            50058L,
            50059L,
            50060L,
            50061L,
            50062L,
            50063L,
            50064L,
            50065L,
            50066L,
            50067L,
            50068L,
            50069L,
            50070L,
            50071L,
            50072L,
            50073L,
            50074L
        };
        static const std::vector<int64_t> retval(values, values + 75);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyROSE_Fortran_defsROSE_C_CXX_operators(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ROSE_Fortran_defs::ROSE_C_CXX_operators(i);
        if (retval.empty()) {
            retval = "(ROSE_Fortran_defs::ROSE_C_CXX_operators)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ROSE_Fortran_defs::ROSE_C_CXX_operators::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyROSE_Fortran_defsROSE_C_CXX_operators() {
        return stringify::ROSE_Fortran_defs::ROSE_C_CXX_operators();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/OpenFortranParser_SAGE_Connection/rose_token_defs_gen.h line 321
namespace stringify { namespace ROSE_Fortran_defs {
    const char* ROSE_Fortran_Additional_Info(int64_t i) {
        switch (i) {
            case 100000L: return "FORTRAN_COMMENTS";
            case 100001L: return "FORTRAN_STRING_LITERALS";
            case 100002L: return "FORTRAN_IDENTIFIER";
            case 100003L: return "FORTRAN_UNIDENTIFIED_TOKEN";
            case 100004L: return "FORTRAN_ERROR";
            default: return "";
        }
    }

    std::string ROSE_Fortran_Additional_Info(int64_t i, const std::string &strip) {
        std::string s = ROSE_Fortran_Additional_Info(i);
        if (s.empty())
            s = "(ROSE_Fortran_defs::ROSE_Fortran_Additional_Info)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ROSE_Fortran_Additional_Info() {
        static const int64_t values[] = {
            100000L,
            100001L,
            100002L,
            100003L,
            100004L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyROSE_Fortran_defsROSE_Fortran_Additional_Info(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ROSE_Fortran_defs::ROSE_Fortran_Additional_Info(i);
        if (retval.empty()) {
            retval = "(ROSE_Fortran_defs::ROSE_Fortran_Additional_Info)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ROSE_Fortran_defs::ROSE_Fortran_Additional_Info::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyROSE_Fortran_defsROSE_Fortran_Additional_Info() {
        return stringify::ROSE_Fortran_defs::ROSE_Fortran_Additional_Info();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/ompparser/src/OpenMPKinds.h line 27
namespace stringify {
    const char* OpenMPDirectiveKind(int64_t i) {
        switch (i) {
            default: return "";
        }
    }

    std::string OpenMPDirectiveKind(int64_t i, const std::string &strip) {
        std::string s = OpenMPDirectiveKind(i);
        if (s.empty())
            s = "(OpenMPDirectiveKind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& OpenMPDirectiveKind() {
        static const std::vector<int64_t> retval;
        return retval;
    }

}

namespace Rose {
    std::string stringifyOpenMPDirectiveKind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::OpenMPDirectiveKind(i);
        if (retval.empty()) {
            retval = "(OpenMPDirectiveKind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "OpenMPDirectiveKind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyOpenMPDirectiveKind() {
        return stringify::OpenMPDirectiveKind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/ompparser/src/OpenMPKinds.h line 120
namespace stringify {
    const char* OpenMPClauseKind(int64_t i) {
        switch (i) {
            default: return "";
        }
    }

    std::string OpenMPClauseKind(int64_t i, const std::string &strip) {
        std::string s = OpenMPClauseKind(i);
        if (s.empty())
            s = "(OpenMPClauseKind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& OpenMPClauseKind() {
        static const std::vector<int64_t> retval;
        return retval;
    }

}

namespace Rose {
    std::string stringifyOpenMPClauseKind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::OpenMPClauseKind(i);
        if (retval.empty()) {
            retval = "(OpenMPClauseKind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "OpenMPClauseKind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyOpenMPClauseKind() {
        return stringify::OpenMPClauseKind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/ompparser/src/OpenMPKinds.h line 230
namespace stringify {
    const char* OpenMPWhenClauseSelectorSet(int64_t i) {
        switch (i) {
            default: return "";
        }
    }

    std::string OpenMPWhenClauseSelectorSet(int64_t i, const std::string &strip) {
        std::string s = OpenMPWhenClauseSelectorSet(i);
        if (s.empty())
            s = "(OpenMPWhenClauseSelectorSet)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& OpenMPWhenClauseSelectorSet() {
        static const std::vector<int64_t> retval;
        return retval;
    }

}

namespace Rose {
    std::string stringifyOpenMPWhenClauseSelectorSet(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::OpenMPWhenClauseSelectorSet(i);
        if (retval.empty()) {
            retval = "(OpenMPWhenClauseSelectorSet)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "OpenMPWhenClauseSelectorSet::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyOpenMPWhenClauseSelectorSet() {
        return stringify::OpenMPWhenClauseSelectorSet();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/ompparser/src/OpenMPKinds.h line 241
namespace stringify {
    const char* OpenMPWhenClauseSelectorParameter(int64_t i) {
        switch (i) {
            default: return "";
        }
    }

    std::string OpenMPWhenClauseSelectorParameter(int64_t i, const std::string &strip) {
        std::string s = OpenMPWhenClauseSelectorParameter(i);
        if (s.empty())
            s = "(OpenMPWhenClauseSelectorParameter)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& OpenMPWhenClauseSelectorParameter() {
        static const std::vector<int64_t> retval;
        return retval;
    }

}

namespace Rose {
    std::string stringifyOpenMPWhenClauseSelectorParameter(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::OpenMPWhenClauseSelectorParameter(i);
        if (retval.empty()) {
            retval = "(OpenMPWhenClauseSelectorParameter)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "OpenMPWhenClauseSelectorParameter::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyOpenMPWhenClauseSelectorParameter() {
        return stringify::OpenMPWhenClauseSelectorParameter();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/ompparser/src/OpenMPKinds.h line 250
namespace stringify {
    const char* OpenMPClauseContextKind(int64_t i) {
        switch (i) {
            default: return "";
        }
    }

    std::string OpenMPClauseContextKind(int64_t i, const std::string &strip) {
        std::string s = OpenMPClauseContextKind(i);
        if (s.empty())
            s = "(OpenMPClauseContextKind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& OpenMPClauseContextKind() {
        static const std::vector<int64_t> retval;
        return retval;
    }

}

namespace Rose {
    std::string stringifyOpenMPClauseContextKind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::OpenMPClauseContextKind(i);
        if (retval.empty()) {
            retval = "(OpenMPClauseContextKind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "OpenMPClauseContextKind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyOpenMPClauseContextKind() {
        return stringify::OpenMPClauseContextKind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/ompparser/src/OpenMPKinds.h line 263
namespace stringify {
    const char* OpenMPClauseContextVendor(int64_t i) {
        switch (i) {
            default: return "";
        }
    }

    std::string OpenMPClauseContextVendor(int64_t i, const std::string &strip) {
        std::string s = OpenMPClauseContextVendor(i);
        if (s.empty())
            s = "(OpenMPClauseContextVendor)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& OpenMPClauseContextVendor() {
        static const std::vector<int64_t> retval;
        return retval;
    }

}

namespace Rose {
    std::string stringifyOpenMPClauseContextVendor(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::OpenMPClauseContextVendor(i);
        if (retval.empty()) {
            retval = "(OpenMPClauseContextVendor)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "OpenMPClauseContextVendor::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyOpenMPClauseContextVendor() {
        return stringify::OpenMPClauseContextVendor();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/ompparser/src/OpenMPKinds.h line 284
namespace stringify {
    const char* OpenMPIfClauseModifier(int64_t i) {
        switch (i) {
            default: return "";
        }
    }

    std::string OpenMPIfClauseModifier(int64_t i, const std::string &strip) {
        std::string s = OpenMPIfClauseModifier(i);
        if (s.empty())
            s = "(OpenMPIfClauseModifier)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& OpenMPIfClauseModifier() {
        static const std::vector<int64_t> retval;
        return retval;
    }

}

namespace Rose {
    std::string stringifyOpenMPIfClauseModifier(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::OpenMPIfClauseModifier(i);
        if (retval.empty()) {
            retval = "(OpenMPIfClauseModifier)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "OpenMPIfClauseModifier::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyOpenMPIfClauseModifier() {
        return stringify::OpenMPIfClauseModifier();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/ompparser/src/OpenMPKinds.h line 304
namespace stringify {
    const char* OpenMPDefaultClauseKind(int64_t i) {
        switch (i) {
            default: return "";
        }
    }

    std::string OpenMPDefaultClauseKind(int64_t i, const std::string &strip) {
        std::string s = OpenMPDefaultClauseKind(i);
        if (s.empty())
            s = "(OpenMPDefaultClauseKind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& OpenMPDefaultClauseKind() {
        static const std::vector<int64_t> retval;
        return retval;
    }

}

namespace Rose {
    std::string stringifyOpenMPDefaultClauseKind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::OpenMPDefaultClauseKind(i);
        if (retval.empty()) {
            retval = "(OpenMPDefaultClauseKind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "OpenMPDefaultClauseKind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyOpenMPDefaultClauseKind() {
        return stringify::OpenMPDefaultClauseKind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/ompparser/src/OpenMPKinds.h line 318
namespace stringify {
    const char* OpenMPOrderClauseKind(int64_t i) {
        switch (i) {
            default: return "";
        }
    }

    std::string OpenMPOrderClauseKind(int64_t i, const std::string &strip) {
        std::string s = OpenMPOrderClauseKind(i);
        if (s.empty())
            s = "(OpenMPOrderClauseKind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& OpenMPOrderClauseKind() {
        static const std::vector<int64_t> retval;
        return retval;
    }

}

namespace Rose {
    std::string stringifyOpenMPOrderClauseKind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::OpenMPOrderClauseKind(i);
        if (retval.empty()) {
            retval = "(OpenMPOrderClauseKind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "OpenMPOrderClauseKind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyOpenMPOrderClauseKind() {
        return stringify::OpenMPOrderClauseKind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/ompparser/src/OpenMPKinds.h line 328
namespace stringify {
    const char* OpenMPProcBindClauseKind(int64_t i) {
        switch (i) {
            default: return "";
        }
    }

    std::string OpenMPProcBindClauseKind(int64_t i, const std::string &strip) {
        std::string s = OpenMPProcBindClauseKind(i);
        if (s.empty())
            s = "(OpenMPProcBindClauseKind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& OpenMPProcBindClauseKind() {
        static const std::vector<int64_t> retval;
        return retval;
    }

}

namespace Rose {
    std::string stringifyOpenMPProcBindClauseKind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::OpenMPProcBindClauseKind(i);
        if (retval.empty()) {
            retval = "(OpenMPProcBindClauseKind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "OpenMPProcBindClauseKind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyOpenMPProcBindClauseKind() {
        return stringify::OpenMPProcBindClauseKind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/ompparser/src/OpenMPKinds.h line 339
namespace stringify {
    const char* OpenMPAllocateClauseAllocator(int64_t i) {
        switch (i) {
            default: return "";
        }
    }

    std::string OpenMPAllocateClauseAllocator(int64_t i, const std::string &strip) {
        std::string s = OpenMPAllocateClauseAllocator(i);
        if (s.empty())
            s = "(OpenMPAllocateClauseAllocator)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& OpenMPAllocateClauseAllocator() {
        static const std::vector<int64_t> retval;
        return retval;
    }

}

namespace Rose {
    std::string stringifyOpenMPAllocateClauseAllocator(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::OpenMPAllocateClauseAllocator(i);
        if (retval.empty()) {
            retval = "(OpenMPAllocateClauseAllocator)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "OpenMPAllocateClauseAllocator::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyOpenMPAllocateClauseAllocator() {
        return stringify::OpenMPAllocateClauseAllocator();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/ompparser/src/OpenMPKinds.h line 356
namespace stringify {
    const char* OpenMPAllocatorClauseAllocator(int64_t i) {
        switch (i) {
            default: return "";
        }
    }

    std::string OpenMPAllocatorClauseAllocator(int64_t i, const std::string &strip) {
        std::string s = OpenMPAllocatorClauseAllocator(i);
        if (s.empty())
            s = "(OpenMPAllocatorClauseAllocator)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& OpenMPAllocatorClauseAllocator() {
        static const std::vector<int64_t> retval;
        return retval;
    }

}

namespace Rose {
    std::string stringifyOpenMPAllocatorClauseAllocator(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::OpenMPAllocatorClauseAllocator(i);
        if (retval.empty()) {
            retval = "(OpenMPAllocatorClauseAllocator)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "OpenMPAllocatorClauseAllocator::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyOpenMPAllocatorClauseAllocator() {
        return stringify::OpenMPAllocatorClauseAllocator();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/ompparser/src/OpenMPKinds.h line 372
namespace stringify {
    const char* OpenMPReductionClauseModifier(int64_t i) {
        switch (i) {
            default: return "";
        }
    }

    std::string OpenMPReductionClauseModifier(int64_t i, const std::string &strip) {
        std::string s = OpenMPReductionClauseModifier(i);
        if (s.empty())
            s = "(OpenMPReductionClauseModifier)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& OpenMPReductionClauseModifier() {
        static const std::vector<int64_t> retval;
        return retval;
    }

}

namespace Rose {
    std::string stringifyOpenMPReductionClauseModifier(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::OpenMPReductionClauseModifier(i);
        if (retval.empty()) {
            retval = "(OpenMPReductionClauseModifier)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "OpenMPReductionClauseModifier::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyOpenMPReductionClauseModifier() {
        return stringify::OpenMPReductionClauseModifier();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/ompparser/src/OpenMPKinds.h line 383
namespace stringify {
    const char* OpenMPReductionClauseIdentifier(int64_t i) {
        switch (i) {
            default: return "";
        }
    }

    std::string OpenMPReductionClauseIdentifier(int64_t i, const std::string &strip) {
        std::string s = OpenMPReductionClauseIdentifier(i);
        if (s.empty())
            s = "(OpenMPReductionClauseIdentifier)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& OpenMPReductionClauseIdentifier() {
        static const std::vector<int64_t> retval;
        return retval;
    }

}

namespace Rose {
    std::string stringifyOpenMPReductionClauseIdentifier(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::OpenMPReductionClauseIdentifier(i);
        if (retval.empty()) {
            retval = "(OpenMPReductionClauseIdentifier)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "OpenMPReductionClauseIdentifier::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyOpenMPReductionClauseIdentifier() {
        return stringify::OpenMPReductionClauseIdentifier();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/ompparser/src/OpenMPKinds.h line 404
namespace stringify {
    const char* OpenMPLastprivateClauseModifier(int64_t i) {
        switch (i) {
            default: return "";
        }
    }

    std::string OpenMPLastprivateClauseModifier(int64_t i, const std::string &strip) {
        std::string s = OpenMPLastprivateClauseModifier(i);
        if (s.empty())
            s = "(OpenMPLastprivateClauseModifier)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& OpenMPLastprivateClauseModifier() {
        static const std::vector<int64_t> retval;
        return retval;
    }

}

namespace Rose {
    std::string stringifyOpenMPLastprivateClauseModifier(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::OpenMPLastprivateClauseModifier(i);
        if (retval.empty()) {
            retval = "(OpenMPLastprivateClauseModifier)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "OpenMPLastprivateClauseModifier::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyOpenMPLastprivateClauseModifier() {
        return stringify::OpenMPLastprivateClauseModifier();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/ompparser/src/OpenMPKinds.h line 412
namespace stringify {
    const char* OpenMPLinearClauseStep(int64_t i) {
        switch (i) {
            default: return "";
        }
    }

    std::string OpenMPLinearClauseStep(int64_t i, const std::string &strip) {
        std::string s = OpenMPLinearClauseStep(i);
        if (s.empty())
            s = "(OpenMPLinearClauseStep)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& OpenMPLinearClauseStep() {
        static const std::vector<int64_t> retval;
        return retval;
    }

}

namespace Rose {
    std::string stringifyOpenMPLinearClauseStep(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::OpenMPLinearClauseStep(i);
        if (retval.empty()) {
            retval = "(OpenMPLinearClauseStep)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "OpenMPLinearClauseStep::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyOpenMPLinearClauseStep() {
        return stringify::OpenMPLinearClauseStep();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/ompparser/src/OpenMPKinds.h line 423
namespace stringify {
    const char* OpenMPLinearClauseModifier(int64_t i) {
        switch (i) {
            default: return "";
        }
    }

    std::string OpenMPLinearClauseModifier(int64_t i, const std::string &strip) {
        std::string s = OpenMPLinearClauseModifier(i);
        if (s.empty())
            s = "(OpenMPLinearClauseModifier)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& OpenMPLinearClauseModifier() {
        static const std::vector<int64_t> retval;
        return retval;
    }

}

namespace Rose {
    std::string stringifyOpenMPLinearClauseModifier(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::OpenMPLinearClauseModifier(i);
        if (retval.empty()) {
            retval = "(OpenMPLinearClauseModifier)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "OpenMPLinearClauseModifier::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyOpenMPLinearClauseModifier() {
        return stringify::OpenMPLinearClauseModifier();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/ompparser/src/OpenMPKinds.h line 437
namespace stringify {
    const char* OpenMPScheduleClauseModifier(int64_t i) {
        switch (i) {
            default: return "";
        }
    }

    std::string OpenMPScheduleClauseModifier(int64_t i, const std::string &strip) {
        std::string s = OpenMPScheduleClauseModifier(i);
        if (s.empty())
            s = "(OpenMPScheduleClauseModifier)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& OpenMPScheduleClauseModifier() {
        static const std::vector<int64_t> retval;
        return retval;
    }

}

namespace Rose {
    std::string stringifyOpenMPScheduleClauseModifier(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::OpenMPScheduleClauseModifier(i);
        if (retval.empty()) {
            retval = "(OpenMPScheduleClauseModifier)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "OpenMPScheduleClauseModifier::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyOpenMPScheduleClauseModifier() {
        return stringify::OpenMPScheduleClauseModifier();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/ompparser/src/OpenMPKinds.h line 450
namespace stringify {
    const char* OpenMPScheduleClauseKind(int64_t i) {
        switch (i) {
            default: return "";
        }
    }

    std::string OpenMPScheduleClauseKind(int64_t i, const std::string &strip) {
        std::string s = OpenMPScheduleClauseKind(i);
        if (s.empty())
            s = "(OpenMPScheduleClauseKind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& OpenMPScheduleClauseKind() {
        static const std::vector<int64_t> retval;
        return retval;
    }

}

namespace Rose {
    std::string stringifyOpenMPScheduleClauseKind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::OpenMPScheduleClauseKind(i);
        if (retval.empty()) {
            retval = "(OpenMPScheduleClauseKind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "OpenMPScheduleClauseKind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyOpenMPScheduleClauseKind() {
        return stringify::OpenMPScheduleClauseKind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/ompparser/src/OpenMPKinds.h line 465
namespace stringify {
    const char* OpenMPDistScheduleClauseKind(int64_t i) {
        switch (i) {
            default: return "";
        }
    }

    std::string OpenMPDistScheduleClauseKind(int64_t i, const std::string &strip) {
        std::string s = OpenMPDistScheduleClauseKind(i);
        if (s.empty())
            s = "(OpenMPDistScheduleClauseKind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& OpenMPDistScheduleClauseKind() {
        static const std::vector<int64_t> retval;
        return retval;
    }

}

namespace Rose {
    std::string stringifyOpenMPDistScheduleClauseKind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::OpenMPDistScheduleClauseKind(i);
        if (retval.empty()) {
            retval = "(OpenMPDistScheduleClauseKind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "OpenMPDistScheduleClauseKind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyOpenMPDistScheduleClauseKind() {
        return stringify::OpenMPDistScheduleClauseKind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/ompparser/src/OpenMPKinds.h line 476
namespace stringify {
    const char* OpenMPBindClauseBinding(int64_t i) {
        switch (i) {
            default: return "";
        }
    }

    std::string OpenMPBindClauseBinding(int64_t i, const std::string &strip) {
        std::string s = OpenMPBindClauseBinding(i);
        if (s.empty())
            s = "(OpenMPBindClauseBinding)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& OpenMPBindClauseBinding() {
        static const std::vector<int64_t> retval;
        return retval;
    }

}

namespace Rose {
    std::string stringifyOpenMPBindClauseBinding(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::OpenMPBindClauseBinding(i);
        if (retval.empty()) {
            retval = "(OpenMPBindClauseBinding)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "OpenMPBindClauseBinding::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyOpenMPBindClauseBinding() {
        return stringify::OpenMPBindClauseBinding();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/ompparser/src/OpenMPKinds.h line 489
namespace stringify {
    const char* OpenMPInitializerClausePriv(int64_t i) {
        switch (i) {
            default: return "";
        }
    }

    std::string OpenMPInitializerClausePriv(int64_t i, const std::string &strip) {
        std::string s = OpenMPInitializerClausePriv(i);
        if (s.empty())
            s = "(OpenMPInitializerClausePriv)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& OpenMPInitializerClausePriv() {
        static const std::vector<int64_t> retval;
        return retval;
    }

}

namespace Rose {
    std::string stringifyOpenMPInitializerClausePriv(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::OpenMPInitializerClausePriv(i);
        if (retval.empty()) {
            retval = "(OpenMPInitializerClausePriv)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "OpenMPInitializerClausePriv::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyOpenMPInitializerClausePriv() {
        return stringify::OpenMPInitializerClausePriv();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/ompparser/src/OpenMPKinds.h line 500
namespace stringify {
    const char* OpenMPAtomicDefaultMemOrderClauseKind(int64_t i) {
        switch (i) {
            default: return "";
        }
    }

    std::string OpenMPAtomicDefaultMemOrderClauseKind(int64_t i, const std::string &strip) {
        std::string s = OpenMPAtomicDefaultMemOrderClauseKind(i);
        if (s.empty())
            s = "(OpenMPAtomicDefaultMemOrderClauseKind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& OpenMPAtomicDefaultMemOrderClauseKind() {
        static const std::vector<int64_t> retval;
        return retval;
    }

}

namespace Rose {
    std::string stringifyOpenMPAtomicDefaultMemOrderClauseKind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::OpenMPAtomicDefaultMemOrderClauseKind(i);
        if (retval.empty()) {
            retval = "(OpenMPAtomicDefaultMemOrderClauseKind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "OpenMPAtomicDefaultMemOrderClauseKind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyOpenMPAtomicDefaultMemOrderClauseKind() {
        return stringify::OpenMPAtomicDefaultMemOrderClauseKind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/ompparser/src/OpenMPKinds.h line 511
namespace stringify {
    const char* OpenMPUsesAllocatorsClauseAllocator(int64_t i) {
        switch (i) {
            default: return "";
        }
    }

    std::string OpenMPUsesAllocatorsClauseAllocator(int64_t i, const std::string &strip) {
        std::string s = OpenMPUsesAllocatorsClauseAllocator(i);
        if (s.empty())
            s = "(OpenMPUsesAllocatorsClauseAllocator)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& OpenMPUsesAllocatorsClauseAllocator() {
        static const std::vector<int64_t> retval;
        return retval;
    }

}

namespace Rose {
    std::string stringifyOpenMPUsesAllocatorsClauseAllocator(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::OpenMPUsesAllocatorsClauseAllocator(i);
        if (retval.empty()) {
            retval = "(OpenMPUsesAllocatorsClauseAllocator)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "OpenMPUsesAllocatorsClauseAllocator::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyOpenMPUsesAllocatorsClauseAllocator() {
        return stringify::OpenMPUsesAllocatorsClauseAllocator();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/ompparser/src/OpenMPKinds.h line 528
namespace stringify {
    const char* OpenMPDeviceClauseModifier(int64_t i) {
        switch (i) {
            default: return "";
        }
    }

    std::string OpenMPDeviceClauseModifier(int64_t i, const std::string &strip) {
        std::string s = OpenMPDeviceClauseModifier(i);
        if (s.empty())
            s = "(OpenMPDeviceClauseModifier)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& OpenMPDeviceClauseModifier() {
        static const std::vector<int64_t> retval;
        return retval;
    }

}

namespace Rose {
    std::string stringifyOpenMPDeviceClauseModifier(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::OpenMPDeviceClauseModifier(i);
        if (retval.empty()) {
            retval = "(OpenMPDeviceClauseModifier)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "OpenMPDeviceClauseModifier::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyOpenMPDeviceClauseModifier() {
        return stringify::OpenMPDeviceClauseModifier();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/ompparser/src/OpenMPKinds.h line 537
namespace stringify {
    const char* OpenMPInReductionClauseIdentifier(int64_t i) {
        switch (i) {
            default: return "";
        }
    }

    std::string OpenMPInReductionClauseIdentifier(int64_t i, const std::string &strip) {
        std::string s = OpenMPInReductionClauseIdentifier(i);
        if (s.empty())
            s = "(OpenMPInReductionClauseIdentifier)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& OpenMPInReductionClauseIdentifier() {
        static const std::vector<int64_t> retval;
        return retval;
    }

}

namespace Rose {
    std::string stringifyOpenMPInReductionClauseIdentifier(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::OpenMPInReductionClauseIdentifier(i);
        if (retval.empty()) {
            retval = "(OpenMPInReductionClauseIdentifier)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "OpenMPInReductionClauseIdentifier::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyOpenMPInReductionClauseIdentifier() {
        return stringify::OpenMPInReductionClauseIdentifier();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/ompparser/src/OpenMPKinds.h line 557
namespace stringify {
    const char* OpenMPDependClauseModifier(int64_t i) {
        switch (i) {
            default: return "";
        }
    }

    std::string OpenMPDependClauseModifier(int64_t i, const std::string &strip) {
        std::string s = OpenMPDependClauseModifier(i);
        if (s.empty())
            s = "(OpenMPDependClauseModifier)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& OpenMPDependClauseModifier() {
        static const std::vector<int64_t> retval;
        return retval;
    }

}

namespace Rose {
    std::string stringifyOpenMPDependClauseModifier(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::OpenMPDependClauseModifier(i);
        if (retval.empty()) {
            retval = "(OpenMPDependClauseModifier)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "OpenMPDependClauseModifier::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyOpenMPDependClauseModifier() {
        return stringify::OpenMPDependClauseModifier();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/ompparser/src/OpenMPKinds.h line 565
namespace stringify {
    const char* OpenMPDeclareMapperDirectiveIdentifier(int64_t i) {
        switch (i) {
            default: return "";
        }
    }

    std::string OpenMPDeclareMapperDirectiveIdentifier(int64_t i, const std::string &strip) {
        std::string s = OpenMPDeclareMapperDirectiveIdentifier(i);
        if (s.empty())
            s = "(OpenMPDeclareMapperDirectiveIdentifier)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& OpenMPDeclareMapperDirectiveIdentifier() {
        static const std::vector<int64_t> retval;
        return retval;
    }

}

namespace Rose {
    std::string stringifyOpenMPDeclareMapperDirectiveIdentifier(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::OpenMPDeclareMapperDirectiveIdentifier(i);
        if (retval.empty()) {
            retval = "(OpenMPDeclareMapperDirectiveIdentifier)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "OpenMPDeclareMapperDirectiveIdentifier::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyOpenMPDeclareMapperDirectiveIdentifier() {
        return stringify::OpenMPDeclareMapperDirectiveIdentifier();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/ompparser/src/OpenMPKinds.h line 573
namespace stringify {
    const char* OpenMPDependClauseType(int64_t i) {
        switch (i) {
            default: return "";
        }
    }

    std::string OpenMPDependClauseType(int64_t i, const std::string &strip) {
        std::string s = OpenMPDependClauseType(i);
        if (s.empty())
            s = "(OpenMPDependClauseType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& OpenMPDependClauseType() {
        static const std::vector<int64_t> retval;
        return retval;
    }

}

namespace Rose {
    std::string stringifyOpenMPDependClauseType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::OpenMPDependClauseType(i);
        if (retval.empty()) {
            retval = "(OpenMPDependClauseType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "OpenMPDependClauseType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyOpenMPDependClauseType() {
        return stringify::OpenMPDependClauseType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/ompparser/src/OpenMPKinds.h line 586
namespace stringify {
    const char* OpenMPAffinityClauseModifier(int64_t i) {
        switch (i) {
            default: return "";
        }
    }

    std::string OpenMPAffinityClauseModifier(int64_t i, const std::string &strip) {
        std::string s = OpenMPAffinityClauseModifier(i);
        if (s.empty())
            s = "(OpenMPAffinityClauseModifier)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& OpenMPAffinityClauseModifier() {
        static const std::vector<int64_t> retval;
        return retval;
    }

}

namespace Rose {
    std::string stringifyOpenMPAffinityClauseModifier(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::OpenMPAffinityClauseModifier(i);
        if (retval.empty()) {
            retval = "(OpenMPAffinityClauseModifier)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "OpenMPAffinityClauseModifier::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyOpenMPAffinityClauseModifier() {
        return stringify::OpenMPAffinityClauseModifier();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/ompparser/src/OpenMPKinds.h line 593
namespace stringify {
    const char* OpenMPToClauseKind(int64_t i) {
        switch (i) {
            default: return "";
        }
    }

    std::string OpenMPToClauseKind(int64_t i, const std::string &strip) {
        std::string s = OpenMPToClauseKind(i);
        if (s.empty())
            s = "(OpenMPToClauseKind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& OpenMPToClauseKind() {
        static const std::vector<int64_t> retval;
        return retval;
    }

}

namespace Rose {
    std::string stringifyOpenMPToClauseKind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::OpenMPToClauseKind(i);
        if (retval.empty()) {
            retval = "(OpenMPToClauseKind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "OpenMPToClauseKind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyOpenMPToClauseKind() {
        return stringify::OpenMPToClauseKind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/ompparser/src/OpenMPKinds.h line 600
namespace stringify {
    const char* OpenMPFromClauseKind(int64_t i) {
        switch (i) {
            default: return "";
        }
    }

    std::string OpenMPFromClauseKind(int64_t i, const std::string &strip) {
        std::string s = OpenMPFromClauseKind(i);
        if (s.empty())
            s = "(OpenMPFromClauseKind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& OpenMPFromClauseKind() {
        static const std::vector<int64_t> retval;
        return retval;
    }

}

namespace Rose {
    std::string stringifyOpenMPFromClauseKind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::OpenMPFromClauseKind(i);
        if (retval.empty()) {
            retval = "(OpenMPFromClauseKind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "OpenMPFromClauseKind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyOpenMPFromClauseKind() {
        return stringify::OpenMPFromClauseKind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/ompparser/src/OpenMPKinds.h line 607
namespace stringify {
    const char* OpenMPDefaultmapClauseBehavior(int64_t i) {
        switch (i) {
            default: return "";
        }
    }

    std::string OpenMPDefaultmapClauseBehavior(int64_t i, const std::string &strip) {
        std::string s = OpenMPDefaultmapClauseBehavior(i);
        if (s.empty())
            s = "(OpenMPDefaultmapClauseBehavior)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& OpenMPDefaultmapClauseBehavior() {
        static const std::vector<int64_t> retval;
        return retval;
    }

}

namespace Rose {
    std::string stringifyOpenMPDefaultmapClauseBehavior(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::OpenMPDefaultmapClauseBehavior(i);
        if (retval.empty()) {
            retval = "(OpenMPDefaultmapClauseBehavior)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "OpenMPDefaultmapClauseBehavior::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyOpenMPDefaultmapClauseBehavior() {
        return stringify::OpenMPDefaultmapClauseBehavior();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/ompparser/src/OpenMPKinds.h line 622
namespace stringify {
    const char* OpenMPDefaultmapClauseCategory(int64_t i) {
        switch (i) {
            default: return "";
        }
    }

    std::string OpenMPDefaultmapClauseCategory(int64_t i, const std::string &strip) {
        std::string s = OpenMPDefaultmapClauseCategory(i);
        if (s.empty())
            s = "(OpenMPDefaultmapClauseCategory)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& OpenMPDefaultmapClauseCategory() {
        static const std::vector<int64_t> retval;
        return retval;
    }

}

namespace Rose {
    std::string stringifyOpenMPDefaultmapClauseCategory(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::OpenMPDefaultmapClauseCategory(i);
        if (retval.empty()) {
            retval = "(OpenMPDefaultmapClauseCategory)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "OpenMPDefaultmapClauseCategory::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyOpenMPDefaultmapClauseCategory() {
        return stringify::OpenMPDefaultmapClauseCategory();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/ompparser/src/OpenMPKinds.h line 634
namespace stringify {
    const char* OpenMPDeviceTypeClauseKind(int64_t i) {
        switch (i) {
            default: return "";
        }
    }

    std::string OpenMPDeviceTypeClauseKind(int64_t i, const std::string &strip) {
        std::string s = OpenMPDeviceTypeClauseKind(i);
        if (s.empty())
            s = "(OpenMPDeviceTypeClauseKind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& OpenMPDeviceTypeClauseKind() {
        static const std::vector<int64_t> retval;
        return retval;
    }

}

namespace Rose {
    std::string stringifyOpenMPDeviceTypeClauseKind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::OpenMPDeviceTypeClauseKind(i);
        if (retval.empty()) {
            retval = "(OpenMPDeviceTypeClauseKind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "OpenMPDeviceTypeClauseKind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyOpenMPDeviceTypeClauseKind() {
        return stringify::OpenMPDeviceTypeClauseKind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/ompparser/src/OpenMPKinds.h line 643
namespace stringify {
    const char* OpenMPMapClauseModifier(int64_t i) {
        switch (i) {
            default: return "";
        }
    }

    std::string OpenMPMapClauseModifier(int64_t i, const std::string &strip) {
        std::string s = OpenMPMapClauseModifier(i);
        if (s.empty())
            s = "(OpenMPMapClauseModifier)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& OpenMPMapClauseModifier() {
        static const std::vector<int64_t> retval;
        return retval;
    }

}

namespace Rose {
    std::string stringifyOpenMPMapClauseModifier(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::OpenMPMapClauseModifier(i);
        if (retval.empty()) {
            retval = "(OpenMPMapClauseModifier)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "OpenMPMapClauseModifier::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyOpenMPMapClauseModifier() {
        return stringify::OpenMPMapClauseModifier();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/ompparser/src/OpenMPKinds.h line 651
namespace stringify {
    const char* OpenMPMapClauseType(int64_t i) {
        switch (i) {
            default: return "";
        }
    }

    std::string OpenMPMapClauseType(int64_t i, const std::string &strip) {
        std::string s = OpenMPMapClauseType(i);
        if (s.empty())
            s = "(OpenMPMapClauseType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& OpenMPMapClauseType() {
        static const std::vector<int64_t> retval;
        return retval;
    }

}

namespace Rose {
    std::string stringifyOpenMPMapClauseType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::OpenMPMapClauseType(i);
        if (retval.empty()) {
            retval = "(OpenMPMapClauseType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "OpenMPMapClauseType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyOpenMPMapClauseType() {
        return stringify::OpenMPMapClauseType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/ompparser/src/OpenMPKinds.h line 663
namespace stringify {
    const char* OpenMPTaskReductionClauseIdentifier(int64_t i) {
        switch (i) {
            default: return "";
        }
    }

    std::string OpenMPTaskReductionClauseIdentifier(int64_t i, const std::string &strip) {
        std::string s = OpenMPTaskReductionClauseIdentifier(i);
        if (s.empty())
            s = "(OpenMPTaskReductionClauseIdentifier)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& OpenMPTaskReductionClauseIdentifier() {
        static const std::vector<int64_t> retval;
        return retval;
    }

}

namespace Rose {
    std::string stringifyOpenMPTaskReductionClauseIdentifier(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::OpenMPTaskReductionClauseIdentifier(i);
        if (retval.empty()) {
            retval = "(OpenMPTaskReductionClauseIdentifier)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "OpenMPTaskReductionClauseIdentifier::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyOpenMPTaskReductionClauseIdentifier() {
        return stringify::OpenMPTaskReductionClauseIdentifier();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/ompparser/src/OpenMPKinds.h line 682
namespace stringify {
    const char* OpenMPDepobjUpdateClauseDependeceType(int64_t i) {
        switch (i) {
            default: return "";
        }
    }

    std::string OpenMPDepobjUpdateClauseDependeceType(int64_t i, const std::string &strip) {
        std::string s = OpenMPDepobjUpdateClauseDependeceType(i);
        if (s.empty())
            s = "(OpenMPDepobjUpdateClauseDependeceType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& OpenMPDepobjUpdateClauseDependeceType() {
        static const std::vector<int64_t> retval;
        return retval;
    }

}

namespace Rose {
    std::string stringifyOpenMPDepobjUpdateClauseDependeceType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::OpenMPDepobjUpdateClauseDependeceType(i);
        if (retval.empty()) {
            retval = "(OpenMPDepobjUpdateClauseDependeceType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "OpenMPDepobjUpdateClauseDependeceType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyOpenMPDepobjUpdateClauseDependeceType() {
        return stringify::OpenMPDepobjUpdateClauseDependeceType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/ompparser/src/OpenMPIR.h line 25
namespace stringify {
    const char* OpenMPBaseLang(int64_t i) {
        switch (i) {
            case 0L: return "Lang_C";
            case 1L: return "Lang_Cplusplus";
            case 2L: return "Lang_Fortran";
            case 3L: return "Lang_unknown";
            default: return "";
        }
    }

    std::string OpenMPBaseLang(int64_t i, const std::string &strip) {
        std::string s = OpenMPBaseLang(i);
        if (s.empty())
            s = "(OpenMPBaseLang)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& OpenMPBaseLang() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyOpenMPBaseLang(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::OpenMPBaseLang(i);
        if (retval.empty()) {
            retval = "(OpenMPBaseLang)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "OpenMPBaseLang::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyOpenMPBaseLang() {
        return stringify::OpenMPBaseLang();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/omp.h line 31
namespace stringify {
    const char* omp_lock_hint_t(int64_t i) {
        switch (i) {
            case 0L: return "omp_lock_hint_none";
            case 1L: return "omp_lock_hint_uncontended";
            case 2L: return "omp_lock_hint_contended";
            case 4L: return "omp_lock_hint_nonspeculative";
            case 8L: return "omp_lock_hint_speculative";
            default: return "";
        }
    }

    std::string omp_lock_hint_t(int64_t i, const std::string &strip) {
        std::string s = omp_lock_hint_t(i);
        if (s.empty())
            s = "(omp_lock_hint_t)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& omp_lock_hint_t() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            4L,
            8L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringify_omp_lock_hint_t(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::omp_lock_hint_t(i);
        if (retval.empty()) {
            retval = "(omp_lock_hint_t)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "omp_lock_hint_t::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_omp_lock_hint_t() {
        return stringify::omp_lock_hint_t();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/omp.h line 47
namespace stringify {
    const char* omp_sched_t(int64_t i) {
        switch (i) {
            case 1L: return "omp_sched_static";
            case 2L: return "omp_sched_dynamic";
            case 3L: return "omp_sched_guided";
            case 4L: return "omp_sched_auto";
            default: return "";
        }
    }

    std::string omp_sched_t(int64_t i, const std::string &strip) {
        std::string s = omp_sched_t(i);
        if (s.empty())
            s = "(omp_sched_t)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& omp_sched_t() {
        static const int64_t values[] = {
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringify_omp_sched_t(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::omp_sched_t(i);
        if (retval.empty()) {
            retval = "(omp_sched_t)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "omp_sched_t::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_omp_sched_t() {
        return stringify::omp_sched_t();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/omp.h line 58
namespace stringify {
    const char* omp_proc_bind_t(int64_t i) {
        switch (i) {
            case 0L: return "omp_proc_bind_false";
            case 1L: return "omp_proc_bind_true";
            case 2L: return "omp_proc_bind_master";
            case 3L: return "omp_proc_bind_close";
            case 4L: return "omp_proc_bind_spread";
            default: return "";
        }
    }

    std::string omp_proc_bind_t(int64_t i, const std::string &strip) {
        std::string s = omp_proc_bind_t(i);
        if (s.empty())
            s = "(omp_proc_bind_t)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& omp_proc_bind_t() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringify_omp_proc_bind_t(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::omp_proc_bind_t(i);
        if (retval.empty()) {
            retval = "(omp_proc_bind_t)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "omp_proc_bind_t::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_omp_proc_bind_t() {
        return stringify::omp_proc_bind_t();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/sageInterface/sageBuilder.h line 138
namespace stringify { namespace SageBuilder {
    const char* SourcePositionClassification(int64_t i) {
        switch (i) {
            case 0L: return "e_sourcePositionError";
            case 1L: return "e_sourcePositionDefault";
            case 2L: return "e_sourcePositionTransformation";
            case 3L: return "e_sourcePositionCompilerGenerated";
            case 4L: return "e_sourcePositionNullPointers";
            case 5L: return "e_sourcePositionFrontendConstruction";
            case 6L: return "e_sourcePosition_last";
            default: return "";
        }
    }

    std::string SourcePositionClassification(int64_t i, const std::string &strip) {
        std::string s = SourcePositionClassification(i);
        if (s.empty())
            s = "(SageBuilder::SourcePositionClassification)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& SourcePositionClassification() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySageBuilderSourcePositionClassification(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SageBuilder::SourcePositionClassification(i);
        if (retval.empty()) {
            retval = "(SageBuilder::SourcePositionClassification)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SageBuilder::SourcePositionClassification::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySageBuilderSourcePositionClassification() {
        return stringify::SageBuilder::SourcePositionClassification();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/sageInterface/sageInterface.h line 1827
namespace stringify { namespace SageInterface { namespace DeferredTransformation {
    const char* TransformationKind(int64_t i) {
        switch (i) {
            case 0L: return "e_error";
            case 1L: return "e_default";
            case 2L: return "e_outliner";
            case 3L: return "e_replaceStatement";
            case 4L: return "e_removeStatement";
            case 5L: return "e_replaceDefiningFunctionDeclarationWithFunctionPrototype";
            case 6L: return "e_last";
            default: return "";
        }
    }

    std::string TransformationKind(int64_t i, const std::string &strip) {
        std::string s = TransformationKind(i);
        if (s.empty())
            s = "(SageInterface::DeferredTransformation::TransformationKind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& TransformationKind() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifySageInterfaceDeferredTransformationTransformationKind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SageInterface::DeferredTransformation::TransformationKind(i);
        if (retval.empty()) {
            retval = "(SageInterface::DeferredTransformation::TransformationKind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SageInterface::DeferredTransformation::TransformationKind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySageInterfaceDeferredTransformationTransformationKind() {
        return stringify::SageInterface::DeferredTransformation::TransformationKind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/rose_attributes_list.h line 133
namespace stringify { namespace PreprocessingInfo {
    const char* RelativePositionType(int64_t i) {
        switch (i) {
            case 0L: return "defaultValue";
            case 1L: return "undef";
            case 2L: return "before";
            case 3L: return "after";
            case 4L: return "inside";
            case 6L: return "before_syntax";
            case 7L: return "after_syntax";
            default: return "";
        }
    }

    std::string RelativePositionType(int64_t i, const std::string &strip) {
        std::string s = RelativePositionType(i);
        if (s.empty())
            s = "(PreprocessingInfo::RelativePositionType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& RelativePositionType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyPreprocessingInfoRelativePositionType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::PreprocessingInfo::RelativePositionType(i);
        if (retval.empty()) {
            retval = "(PreprocessingInfo::RelativePositionType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "PreprocessingInfo::RelativePositionType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyPreprocessingInfoRelativePositionType() {
        return stringify::PreprocessingInfo::RelativePositionType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/rose_attributes_list.h line 154
namespace stringify { namespace PreprocessingInfo {
    const char* DirectiveType(int64_t i) {
        switch (i) {
            case 0L: return "CpreprocessorUnknownDeclaration";
            case 1L: return "C_StyleComment";
            case 2L: return "CplusplusStyleComment";
            case 3L: return "FortranStyleComment";
            case 4L: return "F90StyleComment";
            case 5L: return "CpreprocessorBlankLine";
            case 6L: return "CpreprocessorIncludeDeclaration";
            case 7L: return "CpreprocessorIncludeNextDeclaration";
            case 8L: return "CpreprocessorDefineDeclaration";
            case 9L: return "CpreprocessorUndefDeclaration";
            case 10L: return "CpreprocessorIfdefDeclaration";
            case 11L: return "CpreprocessorIfndefDeclaration";
            case 12L: return "CpreprocessorIfDeclaration";
            case 13L: return "CpreprocessorDeadIfDeclaration";
            case 14L: return "CpreprocessorElseDeclaration";
            case 15L: return "CpreprocessorElifDeclaration";
            case 16L: return "CpreprocessorEndifDeclaration";
            case 17L: return "CpreprocessorLineDeclaration";
            case 18L: return "CpreprocessorErrorDeclaration";
            case 19L: return "CpreprocessorWarningDeclaration";
            case 20L: return "CpreprocessorEmptyDeclaration";
            case 21L: return "CSkippedToken";
            case 22L: return "CMacroCall";
            case 23L: return "CMacroCallStatement";
            case 24L: return "LineReplacement";
            case 25L: return "ClinkageSpecificationStart";
            case 26L: return "ClinkageSpecificationEnd";
            case 27L: return "CpreprocessorIdentDeclaration";
            case 28L: return "CpreprocessorCompilerGeneratedLinemarker";
            case 29L: return "RawText";
            case 30L: return "LastDirectiveType";
            default: return "";
        }
    }

    std::string DirectiveType(int64_t i, const std::string &strip) {
        std::string s = DirectiveType(i);
        if (s.empty())
            s = "(PreprocessingInfo::DirectiveType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& DirectiveType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L
        };
        static const std::vector<int64_t> retval(values, values + 31);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyPreprocessingInfoDirectiveType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::PreprocessingInfo::DirectiveType(i);
        if (retval.empty()) {
            retval = "(PreprocessingInfo::DirectiveType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "PreprocessingInfo::DirectiveType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyPreprocessingInfoDirectiveType() {
        return stringify::PreprocessingInfo::DirectiveType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/rose_attributes_list.h line 530
namespace stringify { namespace ROSEAttributesList {
    const char* languageTypeEnum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown_language";
            case 1L: return "e_C_language";
            case 2L: return "e_Cxx_language";
            case 3L: return "e_Fortran77_language";
            case 4L: return "e_Fortran9x_language";
            case 5L: return "e_lastLanguage";
            default: return "";
        }
    }

    std::string languageTypeEnum(int64_t i, const std::string &strip) {
        std::string s = languageTypeEnum(i);
        if (s.empty())
            s = "(ROSEAttributesList::languageTypeEnum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& languageTypeEnum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyROSEAttributesList_languageTypeEnum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ROSEAttributesList::languageTypeEnum(i);
        if (retval.empty()) {
            retval = "(ROSEAttributesList::languageTypeEnum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ROSEAttributesList::languageTypeEnum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyROSEAttributesList_languageTypeEnum() {
        return stringify::ROSEAttributesList::languageTypeEnum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/general_token_defs.h line 12
namespace stringify { namespace ROSE_token_ids {
    const char* whitespace(int64_t i) {
        switch (i) {
            case 0L: return "T_NOTKNOWN";
            default: return "";
        }
    }

    std::string whitespace(int64_t i, const std::string &strip) {
        std::string s = whitespace(i);
        if (s.empty())
            s = "(ROSE_token_ids::whitespace)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& whitespace() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyROSE_token_ids_whitespace(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ROSE_token_ids::whitespace(i);
        if (retval.empty()) {
            retval = "(ROSE_token_ids::whitespace)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ROSE_token_ids::whitespace::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyROSE_token_ids_whitespace() {
        return stringify::ROSE_token_ids::whitespace();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/general_token_defs.h line 21
namespace stringify { namespace ROSE_token_ids {
    const char* ROSE_C_CXX_keywords(int64_t i) {
        switch (i) {
            default: return "";
        }
    }

    std::string ROSE_C_CXX_keywords(int64_t i, const std::string &strip) {
        std::string s = ROSE_C_CXX_keywords(i);
        if (s.empty())
            s = "(ROSE_token_ids::ROSE_C_CXX_keywords)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ROSE_C_CXX_keywords() {
        static const std::vector<int64_t> retval;
        return retval;
    }

}}

namespace Rose {
    std::string stringifyROSE_token_idsROSE_C_CXX_keywords(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ROSE_token_ids::ROSE_C_CXX_keywords(i);
        if (retval.empty()) {
            retval = "(ROSE_token_ids::ROSE_C_CXX_keywords)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ROSE_token_ids::ROSE_C_CXX_keywords::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyROSE_token_idsROSE_C_CXX_keywords() {
        return stringify::ROSE_token_ids::ROSE_C_CXX_keywords();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/general_token_defs.h line 159
namespace stringify { namespace ROSE_token_ids {
    const char* ROSE_C_CXX_alternate_tok(int64_t i) {
        switch (i) {
            case 0L: return "C_CXX_LEFT_CURLY_ALT";
            case 1L: return "C_CXX_RIGHT_CURLY_ALT";
            case 2L: return "C_CXX_LEFT_SQUARE_ALT";
            case 3L: return "C_CXX_RIGHT_SQUARE_ALT";
            case 4L: return "C_CXX_HASH_ALT";
            case 5L: return "C_CXX_HASH_HASH_ALT";
            case 6L: return "C_CXX_and_ALT";
            default: return "";
        }
    }

    std::string ROSE_C_CXX_alternate_tok(int64_t i, const std::string &strip) {
        std::string s = ROSE_C_CXX_alternate_tok(i);
        if (s.empty())
            s = "(ROSE_token_ids::ROSE_C_CXX_alternate_tok)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ROSE_C_CXX_alternate_tok() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyROSE_token_idsROSE_C_CXX_alternate_tok(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ROSE_token_ids::ROSE_C_CXX_alternate_tok(i);
        if (retval.empty()) {
            retval = "(ROSE_token_ids::ROSE_C_CXX_alternate_tok)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ROSE_token_ids::ROSE_C_CXX_alternate_tok::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyROSE_token_idsROSE_C_CXX_alternate_tok() {
        return stringify::ROSE_token_ids::ROSE_C_CXX_alternate_tok();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/general_token_defs.h line 171
namespace stringify { namespace ROSE_token_ids {
    const char* ROSE_C_CXX_Additional_Info(int64_t i) {
        switch (i) {
            case 100000L: return "C_CXX_COMMENTS";
            case 100001L: return "C_CXX_STRING_LITERALS";
            case 100002L: return "C_CXX_IDENTIFIER";
            case 100003L: return "C_CXX_PREPROCESSING_INFO";
            case 100004L: return "C_CXX_UNIDENTIFIED_TOKEN";
            case 100005L: return "C_CXX_SYNTAX";
            case 100006L: return "C_CXX_WHITESPACE";
            case 100007L: return "C_CXX_PRAGMA";
            case 100008L: return "C_CXX_ERROR";
            default: return "";
        }
    }

    std::string ROSE_C_CXX_Additional_Info(int64_t i, const std::string &strip) {
        std::string s = ROSE_C_CXX_Additional_Info(i);
        if (s.empty())
            s = "(ROSE_token_ids::ROSE_C_CXX_Additional_Info)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ROSE_C_CXX_Additional_Info() {
        static const int64_t values[] = {
            100000L,
            100001L,
            100002L,
            100003L,
            100004L,
            100005L,
            100006L,
            100007L,
            100008L
        };
        static const std::vector<int64_t> retval(values, values + 9);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyROSE_token_idsROSE_C_CXX_Additional_Info(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ROSE_token_ids::ROSE_C_CXX_Additional_Info(i);
        if (retval.empty()) {
            retval = "(ROSE_token_ids::ROSE_C_CXX_Additional_Info)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ROSE_token_ids::ROSE_C_CXX_Additional_Info::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyROSE_token_idsROSE_C_CXX_Additional_Info() {
        return stringify::ROSE_token_ids::ROSE_C_CXX_Additional_Info();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/OmpAttribute.h line 32
namespace stringify { namespace OmpSupport {
    const char* omp_construct_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_parallel";
            case 2L: return "e_for";
            case 3L: return "e_for_simd";
            case 4L: return "e_do";
            case 5L: return "e_workshare";
            case 6L: return "e_sections";
            case 7L: return "e_section";
            case 8L: return "e_single";
            case 9L: return "e_master";
            case 10L: return "e_critical";
            case 11L: return "e_barrier";
            case 12L: return "e_atomic";
            case 13L: return "e_flush";
            case 14L: return "e_target";
            case 15L: return "e_target_declare";
            case 16L: return "e_target_data";
            case 17L: return "e_target_update";
            case 18L: return "e_map";
            case 19L: return "e_device";
            case 20L: return "e_begin";
            case 21L: return "e_end";
            case 22L: return "e_threadprivate";
            case 23L: return "e_parallel_for";
            case 24L: return "e_parallel_for_simd";
            case 25L: return "e_parallel_do";
            case 26L: return "e_parallel_sections";
            case 27L: return "e_parallel_workshare";
            case 28L: return "e_task";
            case 29L: return "e_taskwait";
            case 30L: return "e_ordered_directive";
            case 31L: return "e_end_critical";
            case 32L: return "e_end_do";
            case 33L: return "e_end_master";
            case 34L: return "e_end_ordered";
            case 35L: return "e_end_parallel_do";
            case 36L: return "e_end_parallel_sections";
            case 37L: return "e_end_parallel_workshare";
            case 38L: return "e_end_parallel";
            case 39L: return "e_end_sections";
            case 40L: return "e_end_single";
            case 41L: return "e_end_task";
            case 42L: return "e_end_workshare";
            case 43L: return "e_default";
            case 44L: return "e_shared";
            case 45L: return "e_private";
            case 46L: return "e_firstprivate";
            case 47L: return "e_lastprivate";
            case 48L: return "e_copyin";
            case 49L: return "e_copyprivate";
            case 50L: return "e_proc_bind";
            case 51L: return "e_if";
            case 52L: return "e_num_threads";
            case 53L: return "e_nowait";
            case 54L: return "e_ordered_clause";
            case 55L: return "e_reduction";
            case 56L: return "e_schedule";
            case 57L: return "e_collapse";
            case 58L: return "e_untied";
            case 59L: return "e_mergeable";
            case 60L: return "e_final";
            case 61L: return "e_priority";
            case 62L: return "e_atomic_clause";
            case 63L: return "e_inbranch";
            case 64L: return "e_notinbranch";
            case 65L: return "e_depend";
            case 66L: return "e_default_none";
            case 67L: return "e_default_shared";
            case 68L: return "e_default_private";
            case 69L: return "e_default_firstprivate";
            case 70L: return "e_proc_bind_master";
            case 71L: return "e_proc_bind_close";
            case 72L: return "e_proc_bind_spread";
            case 73L: return "e_atomic_read";
            case 74L: return "e_atomic_write";
            case 75L: return "e_atomic_update";
            case 76L: return "e_atomic_capture";
            case 77L: return "e_in_reduction_identifier_plus";
            case 78L: return "e_in_reduction_identifier_mul";
            case 79L: return "e_in_reduction_identifier_minus";
            case 80L: return "e_in_reduction_identifier_bitand";
            case 81L: return "e_in_reduction_identifier_bitor";
            case 82L: return "e_in_reduction_identifier_bitxor";
            case 83L: return "e_in_reduction_identifier_logand";
            case 84L: return "e_in_reduction_identifier_logor";
            case 85L: return "e_in_reduction_identifier_and";
            case 86L: return "e_in_reduction_identifier_or";
            case 87L: return "e_in_reduction_identifier_eqv";
            case 88L: return "e_in_reduction_identifier_neqv";
            case 89L: return "e_in_reduction_identifier_max";
            case 90L: return "e_in_reduction_identifier_min";
            case 91L: return "e_in_reduction_identifier_iand";
            case 92L: return "e_in_reduction_identifier_ior";
            case 93L: return "e_in_reduction_identifier_ieor";
            case 94L: return "e_task_reduction_identifier_plus";
            case 95L: return "e_task_reduction_identifier_mul";
            case 96L: return "e_task_reduction_identifier_minus";
            case 97L: return "e_task_reduction_identifier_bitand";
            case 98L: return "e_task_reduction_identifier_bitor";
            case 99L: return "e_task_reduction_identifier_bitxor";
            case 100L: return "e_task_reduction_identifier_logand";
            case 101L: return "e_task_reduction_identifier_logor";
            case 102L: return "e_task_reduction_identifier_and";
            case 103L: return "e_task_reduction_identifier_or";
            case 104L: return "e_task_reduction_identifier_eqv";
            case 105L: return "e_task_reduction_identifier_neqv";
            case 106L: return "e_task_reduction_identifier_max";
            case 107L: return "e_task_reduction_identifier_min";
            case 108L: return "e_task_reduction_identifier_iand";
            case 109L: return "e_task_reduction_identifier_ior";
            case 110L: return "e_task_reduction_identifier_ieor";
            case 111L: return "e_reduction_plus";
            case 112L: return "e_reduction_mul";
            case 113L: return "e_reduction_minus";
            case 114L: return "e_reduction_bitand";
            case 115L: return "e_reduction_bitor";
            case 116L: return "e_reduction_bitxor";
            case 117L: return "e_reduction_logand";
            case 118L: return "e_reduction_logor";
            case 119L: return "e_reduction_and";
            case 120L: return "e_reduction_or";
            case 121L: return "e_reduction_eqv";
            case 122L: return "e_reduction_neqv";
            case 123L: return "e_reduction_max";
            case 124L: return "e_reduction_min";
            case 125L: return "e_reduction_iand";
            case 126L: return "e_reduction_ior";
            case 127L: return "e_reduction_ieor";
            case 128L: return "e_reduction_inscan";
            case 129L: return "e_reduction_task";
            case 130L: return "e_reduction_default";
            case 131L: return "e_lastprivate_conditional";
            case 132L: return "e_device_ancestor";
            case 133L: return "e_device_device_num";
            case 134L: return "e_linear_ref";
            case 135L: return "e_linear_val";
            case 136L: return "e_linear_uval";
            case 137L: return "e_user_defined_parameter";
            case 138L: return "e_schedule_none";
            case 139L: return "e_schedule_static";
            case 140L: return "e_schedule_dynamic";
            case 141L: return "e_schedule_guided";
            case 142L: return "e_schedule_auto";
            case 143L: return "e_schedule_runtime";
            case 144L: return "e_map_alloc";
            case 145L: return "e_map_to";
            case 146L: return "e_map_from";
            case 147L: return "e_map_tofrom";
            case 148L: return "e_dist_data";
            case 149L: return "e_duplicate";
            case 150L: return "e_block";
            case 151L: return "e_cyclic";
            case 152L: return "e_simd";
            case 153L: return "e_declare_simd";
            case 154L: return "e_safelen";
            case 155L: return "e_simdlen";
            case 156L: return "e_uniform";
            case 157L: return "e_aligned";
            case 158L: return "e_linear";
            case 159L: return "e_depend_in";
            case 160L: return "e_depend_out";
            case 161L: return "e_depend_inout";
            case 162L: return "e_depend_mutexinoutset";
            case 163L: return "e_depend_depobj";
            case 164L: return "e_omp_depend_modifier_iterator";
            case 165L: return "e_allocate";
            case 166L: return "e_allocate_default_mem_alloc";
            case 167L: return "e_allocate_large_cap_mem_alloc";
            case 168L: return "e_allocate_const_mem_alloc";
            case 169L: return "e_allocate_high_bw_mem_alloc";
            case 170L: return "e_allocate_low_lat_mem_alloc";
            case 171L: return "e_allocate_cgroup_mem_alloc";
            case 172L: return "e_allocate_pteam_mem_alloc";
            case 173L: return "e_allocate_thread_mem_alloc";
            case 174L: return "e_not_omp";
            default: return "";
        }
    }

    std::string omp_construct_enum(int64_t i, const std::string &strip) {
        std::string s = omp_construct_enum(i);
        if (s.empty())
            s = "(OmpSupport::omp_construct_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& omp_construct_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L,
            58L,
            59L,
            60L,
            61L,
            62L,
            63L,
            64L,
            65L,
            66L,
            67L,
            68L,
            69L,
            70L,
            71L,
            72L,
            73L,
            74L,
            75L,
            76L,
            77L,
            78L,
            79L,
            80L,
            81L,
            82L,
            83L,
            84L,
            85L,
            86L,
            87L,
            88L,
            89L,
            90L,
            91L,
            92L,
            93L,
            94L,
            95L,
            96L,
            97L,
            98L,
            99L,
            100L,
            101L,
            102L,
            103L,
            104L,
            105L,
            106L,
            107L,
            108L,
            109L,
            110L,
            111L,
            112L,
            113L,
            114L,
            115L,
            116L,
            117L,
            118L,
            119L,
            120L,
            121L,
            122L,
            123L,
            124L,
            125L,
            126L,
            127L,
            128L,
            129L,
            130L,
            131L,
            132L,
            133L,
            134L,
            135L,
            136L,
            137L,
            138L,
            139L,
            140L,
            141L,
            142L,
            143L,
            144L,
            145L,
            146L,
            147L,
            148L,
            149L,
            150L,
            151L,
            152L,
            153L,
            154L,
            155L,
            156L,
            157L,
            158L,
            159L,
            160L,
            161L,
            162L,
            163L,
            164L,
            165L,
            166L,
            167L,
            168L,
            169L,
            170L,
            171L,
            172L,
            173L,
            174L
        };
        static const std::vector<int64_t> retval(values, values + 175);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyOmpSupport_omp_construct_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::OmpSupport::omp_construct_enum(i);
        if (retval.empty()) {
            retval = "(OmpSupport::omp_construct_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "OmpSupport::omp_construct_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyOmpSupport_omp_construct_enum() {
        return stringify::OmpSupport::omp_construct_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/astVisualization/astGraph.h line 12
namespace stringify { namespace AST_Graph {
    const char* pointerHandling(int64_t i) {
        switch (i) {
            case 0L: return "graph_NULL";
            case 1L: return "do_not_graph_NULL";
            default: return "";
        }
    }

    std::string pointerHandling(int64_t i, const std::string &strip) {
        std::string s = pointerHandling(i);
        if (s.empty())
            s = "(AST_Graph::pointerHandling)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& pointerHandling() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyAST_Graph_pointerHandling(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::AST_Graph::pointerHandling(i);
        if (retval.empty()) {
            retval = "(AST_Graph::pointerHandling)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "AST_Graph::pointerHandling::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyAST_Graph_pointerHandling() {
        return stringify::AST_Graph::pointerHandling();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/astVisualization/astGraph.h line 19
namespace stringify { namespace AST_Graph {
    const char* traversalType(int64_t i) {
        switch (i) {
            case 0L: return "memory_pool_traversal";
            case 1L: return "whole_graph_AST";
            default: return "";
        }
    }

    std::string traversalType(int64_t i, const std::string &strip) {
        std::string s = traversalType(i);
        if (s.empty())
            s = "(AST_Graph::traversalType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& traversalType() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyAST_Graph_traversalType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::AST_Graph::traversalType(i);
        if (retval.empty()) {
            retval = "(AST_Graph::traversalType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "AST_Graph::traversalType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyAST_Graph_traversalType() {
        return stringify::AST_Graph::traversalType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/astVisualization/AstAttributeDOT.h line 25
namespace stringify { namespace AstAttributeDOT {
    const char* DOTStyles(int64_t i) {
        switch (i) {
            case 0L: return "UnknownListElementDOTStyles";
            case 1L: return "filled";
            case 2L: return "not_filled";
            case 3L: return "END_OF_NODE_TYPE_LIST_DOTStyles";
            default: return "";
        }
    }

    std::string DOTStyles(int64_t i, const std::string &strip) {
        std::string s = DOTStyles(i);
        if (s.empty())
            s = "(AstAttributeDOT::DOTStyles)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& DOTStyles() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyAstAttributeDOT_DOTStyles(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::AstAttributeDOT::DOTStyles(i);
        if (retval.empty()) {
            retval = "(AstAttributeDOT::DOTStyles)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "AstAttributeDOT::DOTStyles::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyAstAttributeDOT_DOTStyles() {
        return stringify::AstAttributeDOT::DOTStyles();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/astVisualization/AstAttributeDOT.h line 90
namespace stringify { namespace DOTGraphNode {
    const char* DOTShapeTypes(int64_t i) {
        switch (i) {
            case 0L: return "UnknownListElementDOTShapeTypes";
            case 1L: return "polygon";
            case 2L: return "ellipse";
            case 3L: return "record";
            case 4L: return "mrecord";
            case 5L: return "END_OF_NODE_TYPE_LIST_DOTShapeTypes";
            default: return "";
        }
    }

    std::string DOTShapeTypes(int64_t i, const std::string &strip) {
        std::string s = DOTShapeTypes(i);
        if (s.empty())
            s = "(DOTGraphNode::DOTShapeTypes)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& DOTShapeTypes() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyDOTGraphNodeDOTShapeTypes(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::DOTGraphNode::DOTShapeTypes(i);
        if (retval.empty()) {
            retval = "(DOTGraphNode::DOTShapeTypes)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "DOTGraphNode::DOTShapeTypes::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyDOTGraphNodeDOTShapeTypes() {
        return stringify::DOTGraphNode::DOTShapeTypes();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/astVisualization/AstAttributeDOT.h line 137
namespace stringify { namespace DOTGraphEdge {
    const char* DOTArrowTypes(int64_t i) {
        switch (i) {
            case 0L: return "UnknownListElementArrowTypes";
            case 1L: return "normal";
            case 2L: return "inv";
            case 3L: return "dot";
            case 4L: return "invdot";
            case 5L: return "odot";
            case 6L: return "invodot";
            case 7L: return "none";
            case 8L: return "tee";
            case 9L: return "empty";
            case 10L: return "invempty";
            case 11L: return "diamond";
            case 12L: return "odiamond";
            case 13L: return "ediamond";
            case 14L: return "crow";
            case 15L: return "box";
            case 16L: return "obox";
            case 17L: return "open";
            case 18L: return "halfopen";
            case 19L: return "vee";
            case 20L: return "END_OF_NODE_TYPE_LIST_DOTArrowTypes";
            default: return "";
        }
    }

    std::string DOTArrowTypes(int64_t i, const std::string &strip) {
        std::string s = DOTArrowTypes(i);
        if (s.empty())
            s = "(DOTGraphEdge::DOTArrowTypes)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& DOTArrowTypes() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L
        };
        static const std::vector<int64_t> retval(values, values + 21);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyDOTGraphEdgeDOTArrowTypes(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::DOTGraphEdge::DOTArrowTypes(i);
        if (retval.empty()) {
            retval = "(DOTGraphEdge::DOTArrowTypes)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "DOTGraphEdge::DOTArrowTypes::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyDOTGraphEdgeDOTArrowTypes() {
        return stringify::DOTGraphEdge::DOTArrowTypes();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/virtualCFG/virtualCFG.h line 47
namespace stringify { namespace VirtualCFG {
    const char* EdgeConditionKind(int64_t i) {
        switch (i) {
            case 0L: return "eckUnconditional";
            case 1L: return "eckTrue";
            case 2L: return "eckFalse";
            case 3L: return "eckCaseLabel";
            case 4L: return "eckDefault";
            case 5L: return "eckDoConditionPassed";
            case 6L: return "eckDoConditionFailed";
            case 7L: return "eckForallIndicesInRange";
            case 8L: return "eckForallIndicesNotInRange";
            case 9L: return "eckComputedGotoCaseLabel";
            case 10L: return "eckArithmeticIfLess";
            case 11L: return "eckArithmeticIfEqual";
            case 12L: return "eckArithmeticIfGreater";
            case 13L: return "eckInterprocedural";
            case 14L: return "eckError";
            default: return "";
        }
    }

    std::string EdgeConditionKind(int64_t i, const std::string &strip) {
        std::string s = EdgeConditionKind(i);
        if (s.empty())
            s = "(VirtualCFG::EdgeConditionKind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& EdgeConditionKind() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L
        };
        static const std::vector<int64_t> retval(values, values + 15);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyVirtualCFG_EdgeConditionKind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::VirtualCFG::EdgeConditionKind(i);
        if (retval.empty()) {
            retval = "(VirtualCFG::EdgeConditionKind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "VirtualCFG::EdgeConditionKind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyVirtualCFG_EdgeConditionKind() {
        return stringify::VirtualCFG::EdgeConditionKind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/AstNodeClass.h line 100
namespace stringify { namespace AstNodeClass {
    const char* locationInTree(int64_t i) {
        switch (i) {
            case 0L: return "LOCAL_LIST";
            case 1L: return "SUBTREE_LIST";
            default: return "";
        }
    }

    std::string locationInTree(int64_t i, const std::string &strip) {
        std::string s = locationInTree(i);
        if (s.empty())
            s = "(AstNodeClass::locationInTree)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& locationInTree() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyAstNodeClass_locationInTree(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::AstNodeClass::locationInTree(i);
        if (retval.empty()) {
            retval = "(AstNodeClass::locationInTree)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "AstNodeClass::locationInTree::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyAstNodeClass_locationInTree() {
        return stringify::AstNodeClass::locationInTree();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/AstNodeClass.h line 106
namespace stringify { namespace AstNodeClass {
    const char* includeExcludeMechanism(int64_t i) {
        switch (i) {
            case 0L: return "INCLUDE_LIST";
            case 1L: return "EXCLUDE_LIST";
            default: return "";
        }
    }

    std::string includeExcludeMechanism(int64_t i, const std::string &strip) {
        std::string s = includeExcludeMechanism(i);
        if (s.empty())
            s = "(AstNodeClass::includeExcludeMechanism)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& includeExcludeMechanism() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyAstNodeClass_includeExcludeMechanism(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::AstNodeClass::includeExcludeMechanism(i);
        if (retval.empty()) {
            retval = "(AstNodeClass::includeExcludeMechanism)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "AstNodeClass::includeExcludeMechanism::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyAstNodeClass_includeExcludeMechanism() {
        return stringify::AstNodeClass::includeExcludeMechanism();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/AstNodeClass.h line 309
namespace stringify { namespace AstNodeClass {
    const char* TypeEvaluation(int64_t i) {
        switch (i) {
            case 0L: return "CHAR_POINTER";
            case 1L: return "CONST_CHAR_POINTER";
            case 2L: return "ATTACHEDPREPROCESSINGINFOTYPE";
            case 3L: return "ROSE_HASH_MULTIMAP";
            case 4L: return "ROSE_GRAPH_HASH_MULTIMAP";
            case 5L: return "ROSE_GRAPH_DIRECTED_EDGE_HASH_MULTIMAP";
            case 6L: return "ROSE_GRAPH_UNDIRECTED_EDGE_HASH_MULTIMAP";
            case 7L: return "ROSE_GRAPH_NODE_EDGE_HASH_MULTIMAP";
            case 8L: return "ROSE_GRAPH_INTEGER_NODE_HASH_MAP";
            case 9L: return "ROSE_GRAPH_INTEGER_EDGE_HASH_MAP";
            case 10L: return "ROSE_GRAPH_STRING_INTEGER_HASH_MULTIMAP";
            case 11L: return "ROSE_GRAPH_INTEGER_PAIR_EDGE_HASH_MULTIMAP";
            case 12L: return "ROSE_GRAPH_INTEGER_EDGE_HASH_MULTIMAP";
            case 13L: return "SGCLASS_POINTER";
            case 14L: return "ROSEATTRUBUTESLISTCONTAINER";
            case 15L: return "SGCLASS_POINTER_LIST";
            case 16L: return "SGCLASS_POINTER_VECTOR";
            case 17L: return "SGCLASS_POINTER_VECTOR_NAMED_LIST";
            case 18L: return "STL_CONTAINER";
            case 19L: return "STL_SET";
            case 20L: return "STL_MULTIMAP";
            case 21L: return "STL_MAP";
            case 22L: return "STRING";
            case 23L: return "SGNAME";
            case 24L: return "BIT_VECTOR";
            case 25L: return "MODIFIERCLASS";
            case 26L: return "MODIFIERCLASS_WITHOUTEASYSTORAGE";
            case 27L: return "ASTATTRIBUTEMECHANISM";
            case 28L: return "TO_HANDLE";
            case 29L: return "OSTREAM";
            case 30L: return "ENUM_TYPE";
            case 31L: return "BASIC_DATA_TYPE";
            case 32L: return "SKIP_TYPE";
            case 33L: return "SGCLASS_POINTER_LIST_POINTER";
            default: return "";
        }
    }

    std::string TypeEvaluation(int64_t i, const std::string &strip) {
        std::string s = TypeEvaluation(i);
        if (s.empty())
            s = "(AstNodeClass::TypeEvaluation)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& TypeEvaluation() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L
        };
        static const std::vector<int64_t> retval(values, values + 34);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyAstNodeClassTypeEvaluation(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::AstNodeClass::TypeEvaluation(i);
        if (retval.empty()) {
            retval = "(AstNodeClass::TypeEvaluation)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "AstNodeClass::TypeEvaluation::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyAstNodeClassTypeEvaluation() {
        return stringify::AstNodeClass::TypeEvaluation();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/grammar.h line 82
namespace stringify {
    const char* ConstructParamEnum(int64_t i) {
        switch (i) {
            case 0L: return "NO_CONSTRUCTOR_PARAMETER";
            case 1L: return "CONSTRUCTOR_PARAMETER";
            default: return "";
        }
    }

    std::string ConstructParamEnum(int64_t i, const std::string &strip) {
        std::string s = ConstructParamEnum(i);
        if (s.empty())
            s = "(ConstructParamEnum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ConstructParamEnum() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyConstructParamEnum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ConstructParamEnum(i);
        if (retval.empty()) {
            retval = "(ConstructParamEnum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ConstructParamEnum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyConstructParamEnum() {
        return stringify::ConstructParamEnum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/grammar.h line 87
namespace stringify {
    const char* BuildAccessEnum(int64_t i) {
        switch (i) {
            case 0L: return "NO_ACCESS_FUNCTIONS";
            case 1L: return "BUILD_ACCESS_FUNCTIONS";
            case 2L: return "BUILD_FLAG_ACCESS_FUNCTIONS";
            case 3L: return "BUILD_LIST_ACCESS_FUNCTIONS";
            default: return "";
        }
    }

    std::string BuildAccessEnum(int64_t i, const std::string &strip) {
        std::string s = BuildAccessEnum(i);
        if (s.empty())
            s = "(BuildAccessEnum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& BuildAccessEnum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyBuildAccessEnum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::BuildAccessEnum(i);
        if (retval.empty()) {
            retval = "(BuildAccessEnum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "BuildAccessEnum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBuildAccessEnum() {
        return stringify::BuildAccessEnum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/grammar.h line 95
namespace stringify {
    const char* CopyConfigEnum(int64_t i) {
        switch (i) {
            case 0L: return "NO_COPY_DATA";
            case 1L: return "COPY_DATA";
            case 2L: return "CLONE_PTR";
            case 3L: return "CLONE_TREE";
            default: return "";
        }
    }

    std::string CopyConfigEnum(int64_t i, const std::string &strip) {
        std::string s = CopyConfigEnum(i);
        if (s.empty())
            s = "(CopyConfigEnum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& CopyConfigEnum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyCopyConfigEnum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::CopyConfigEnum(i);
        if (retval.empty()) {
            retval = "(CopyConfigEnum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "CopyConfigEnum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyCopyConfigEnum() {
        return stringify::CopyConfigEnum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/grammar.h line 116
namespace stringify {
    const char* TraversalEnum(int64_t i) {
        switch (i) {
            case 0L: return "DEF_TRAVERSAL";
            case 1L: return "NO_TRAVERSAL";
            default: return "";
        }
    }

    std::string TraversalEnum(int64_t i, const std::string &strip) {
        std::string s = TraversalEnum(i);
        if (s.empty())
            s = "(TraversalEnum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& TraversalEnum() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyTraversalEnum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::TraversalEnum(i);
        if (retval.empty()) {
            retval = "(TraversalEnum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "TraversalEnum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyTraversalEnum() {
        return stringify::TraversalEnum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/grammar.h line 121
namespace stringify {
    const char* DeleteEnum(int64_t i) {
        switch (i) {
            case 0L: return "DEF_DELETE";
            case 1L: return "NO_DELETE";
            default: return "";
        }
    }

    std::string DeleteEnum(int64_t i, const std::string &strip) {
        std::string s = DeleteEnum(i);
        if (s.empty())
            s = "(DeleteEnum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& DeleteEnum() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyDeleteEnum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::DeleteEnum(i);
        if (retval.empty()) {
            retval = "(DeleteEnum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "DeleteEnum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyDeleteEnum() {
        return stringify::DeleteEnum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/util/Color.h line 22
namespace stringify { namespace Rose { namespace Color { namespace Enabled {
    const char* Flag(int64_t i) {
        switch (i) {
            case 0L: return "OFF";
            case 1L: return "ON";
            case 2L: return "AUTO";
            default: return "";
        }
    }

    std::string Flag(int64_t i, const std::string &strip) {
        std::string s = Flag(i);
        if (s.empty())
            s = "(Rose::Color::Enabled::Flag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Flag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyColorEnabledFlag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::Color::Enabled::Flag(i);
        if (retval.empty()) {
            retval = "(Rose::Color::Enabled::Flag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::Color::Enabled::Flag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyColorEnabledFlag() {
        return stringify::Rose::Color::Enabled::Flag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/util/Color.h line 33
namespace stringify { namespace Rose { namespace Color { namespace Theme {
    const char* Flag(int64_t i) {
        switch (i) {
            case 0L: return "DARK_ON_LIGHT";
            case 1L: return "LIGHT_ON_DARK";
            default: return "";
        }
    }

    std::string Flag(int64_t i, const std::string &strip) {
        std::string s = Flag(i);
        if (s.empty())
            s = "(Rose::Color::Theme::Flag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Flag() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyColorThemeFlag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::Color::Theme::Flag(i);
        if (retval.empty()) {
            retval = "(Rose::Color::Theme::Flag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::Color::Theme::Flag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyColorThemeFlag() {
        return stringify::Rose::Color::Theme::Flag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/util/Color.h line 53
namespace stringify { namespace Rose { namespace Color { namespace Layer {
    const char* Flag(int64_t i) {
        switch (i) {
            case 0L: return "NONE";
            case 1L: return "FOREGROUND";
            case 2L: return "BACKGROUND";
            default: return "";
        }
    }

    std::string Flag(int64_t i, const std::string &strip) {
        std::string s = Flag(i);
        if (s.empty())
            s = "(Rose::Color::Layer::Flag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Flag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyColorLayerFlag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::Color::Layer::Flag(i);
        if (retval.empty()) {
            retval = "(Rose::Color::Layer::Flag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::Color::Layer::Flag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyColorLayerFlag() {
        return stringify::Rose::Color::Layer::Flag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/util/Color.h line 359
namespace stringify { namespace Rose { namespace Color {
    const char* AnsiColor(int64_t i) {
        switch (i) {
            case 0L: return "ANSI_CLEAR";
            case 1L: return "ANSI_RED";
            case 2L: return "ANSI_GREEN";
            case 3L: return "ANSI_YELLOW";
            case 4L: return "ANSI_BLUE";
            case 5L: return "ANSI_MAGENTA";
            case 6L: return "ANSI_CYAN";
            case 7L: return "ANSI_GRAY";
            default: return "";
        }
    }

    std::string AnsiColor(int64_t i, const std::string &strip) {
        std::string s = AnsiColor(i);
        if (s.empty())
            s = "(Rose::Color::AnsiColor)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& AnsiColor() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyColorAnsiColor(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::Color::AnsiColor(i);
        if (retval.empty()) {
            retval = "(Rose::Color::AnsiColor)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::Color::AnsiColor::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyColorAnsiColor() {
        return stringify::Rose::Color::AnsiColor();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/util/stringSupport/FileUtility.h line 25
namespace stringify { namespace Rose { namespace StringUtility {
    const char* OSType(int64_t i) {
        switch (i) {
            case 0L: return "OS_TYPE_UNKNOWN";
            case 1L: return "OS_TYPE_LINUX";
            case 2L: return "OS_TYPE_OSX";
            case 3L: return "OS_TYPE_WINDOWS";
            case 4L: return "OS_TPYE_WINDOWSXP";
            default: return "";
        }
    }

    std::string OSType(int64_t i, const std::string &strip) {
        std::string s = OSType(i);
        if (s.empty())
            s = "(Rose::StringUtility::OSType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& OSType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyStringUtilityOSType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::StringUtility::OSType(i);
        if (retval.empty()) {
            retval = "(Rose::StringUtility::OSType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::StringUtility::OSType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyStringUtilityOSType() {
        return stringify::Rose::StringUtility::OSType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/util/stringSupport/FileUtility.h line 150
namespace stringify { namespace Rose { namespace StringUtility {
    const char* FileNameLocation(int64_t i) {
        switch (i) {
            case 0L: return "FILENAME_LOCATION_UNKNOWN";
            case 1L: return "FILENAME_LOCATION_USER";
            case 2L: return "FILENAME_LOCATION_LIBRARY";
            case 3L: return "FILENAME_LOCATION_NOT_EXIST";
            default: return "";
        }
    }

    std::string FileNameLocation(int64_t i, const std::string &strip) {
        std::string s = FileNameLocation(i);
        if (s.empty())
            s = "(Rose::StringUtility::FileNameLocation)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& FileNameLocation() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyStringUtilityFileNameLocation(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::StringUtility::FileNameLocation(i);
        if (retval.empty()) {
            retval = "(Rose::StringUtility::FileNameLocation)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::StringUtility::FileNameLocation::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyStringUtilityFileNameLocation() {
        return stringify::Rose::StringUtility::FileNameLocation();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/util/Sawyer/CommandLine.h line 172
namespace stringify { namespace Sawyer { namespace CommandLine {
    const char* SortOrder(int64_t i) {
        switch (i) {
            case 0L: return "INSERTION_ORDER";
            case 1L: return "DOCKEY_ORDER";
            default: return "";
        }
    }

    std::string SortOrder(int64_t i, const std::string &strip) {
        std::string s = SortOrder(i);
        if (s.empty())
            s = "(Sawyer::CommandLine::SortOrder)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& SortOrder() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifySawyerCommandLineSortOrder(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sawyer::CommandLine::SortOrder(i);
        if (retval.empty()) {
            retval = "(Sawyer::CommandLine::SortOrder)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sawyer::CommandLine::SortOrder::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySawyerCommandLineSortOrder() {
        return stringify::Sawyer::CommandLine::SortOrder();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/util/Sawyer/CommandLine.h line 185
namespace stringify { namespace Sawyer { namespace CommandLine {
    const char* Canonical(int64_t i) {
        switch (i) {
            case 0L: return "CANONICAL";
            case 1L: return "NONCANONICAL";
            case 2L: return "ALL_STRINGS";
            default: return "";
        }
    }

    std::string Canonical(int64_t i, const std::string &strip) {
        std::string s = Canonical(i);
        if (s.empty())
            s = "(Sawyer::CommandLine::Canonical)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Canonical() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifySawyerCommandLineCanonical(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sawyer::CommandLine::Canonical(i);
        if (retval.empty()) {
            retval = "(Sawyer::CommandLine::Canonical)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sawyer::CommandLine::Canonical::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySawyerCommandLineCanonical() {
        return stringify::Sawyer::CommandLine::Canonical();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/util/Sawyer/CommandLine.h line 193
namespace stringify { namespace Sawyer { namespace CommandLine {
    const char* ShowGroupName(int64_t i) {
        switch (i) {
            case 0L: return "SHOW_GROUP_OPTIONAL";
            case 1L: return "SHOW_GROUP_REQUIRED";
            case 2L: return "SHOW_GROUP_NONE";
            case 3L: return "SHOW_GROUP_INHERIT";
            default: return "";
        }
    }

    std::string ShowGroupName(int64_t i, const std::string &strip) {
        std::string s = ShowGroupName(i);
        if (s.empty())
            s = "(Sawyer::CommandLine::ShowGroupName)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ShowGroupName() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifySawyerCommandLineShowGroupName(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sawyer::CommandLine::ShowGroupName(i);
        if (retval.empty()) {
            retval = "(Sawyer::CommandLine::ShowGroupName)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sawyer::CommandLine::ShowGroupName::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySawyerCommandLineShowGroupName() {
        return stringify::Sawyer::CommandLine::ShowGroupName();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/util/Sawyer/CommandLine.h line 201
namespace stringify { namespace Sawyer { namespace CommandLine {
    const char* SwitchSkipping(int64_t i) {
        switch (i) {
            case 0L: return "SKIP_NEVER";
            case 1L: return "SKIP_WEAK";
            case 2L: return "SKIP_STRONG";
            default: return "";
        }
    }

    std::string SwitchSkipping(int64_t i, const std::string &strip) {
        std::string s = SwitchSkipping(i);
        if (s.empty())
            s = "(Sawyer::CommandLine::SwitchSkipping)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& SwitchSkipping() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifySawyerCommandLineSwitchSkipping(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sawyer::CommandLine::SwitchSkipping(i);
        if (retval.empty()) {
            retval = "(Sawyer::CommandLine::SwitchSkipping)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sawyer::CommandLine::SwitchSkipping::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySawyerCommandLineSwitchSkipping() {
        return stringify::Sawyer::CommandLine::SwitchSkipping();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/util/Sawyer/CommandLine.h line 1995
namespace stringify { namespace Sawyer { namespace CommandLine {
    const char* WhichValue(int64_t i) {
        switch (i) {
            case 0L: return "SAVE_NONE";
            case 1L: return "SAVE_ONE";
            case 2L: return "SAVE_LAST";
            case 3L: return "SAVE_FIRST";
            case 4L: return "SAVE_ALL";
            case 5L: return "SAVE_AUGMENTED";
            default: return "";
        }
    }

    std::string WhichValue(int64_t i, const std::string &strip) {
        std::string s = WhichValue(i);
        if (s.empty())
            s = "(Sawyer::CommandLine::WhichValue)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& WhichValue() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifySawyerCommandLineWhichValue(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sawyer::CommandLine::WhichValue(i);
        if (retval.empty()) {
            retval = "(Sawyer::CommandLine::WhichValue)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sawyer::CommandLine::WhichValue::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySawyerCommandLineWhichValue() {
        return stringify::Sawyer::CommandLine::WhichValue();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/util/Sawyer/CommandLine.h line 3050
namespace stringify { namespace Sawyer { namespace CommandLine { namespace Parser {
    const char* GroupingFlags(int64_t i) {
        switch (i) {
            case 0L: return "DEFAULT_GROUPING";
            case 1L: return "PROHIBIT_EMPTY_GROUPS";
            case 2L: return "SPLIT_SINGLE_GROUP";
            default: return "";
        }
    }

    std::string GroupingFlags(int64_t i, const std::string &strip) {
        std::string s = GroupingFlags(i);
        if (s.empty())
            s = "(Sawyer::CommandLine::Parser::GroupingFlags)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& GroupingFlags() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifySawyerCommandLineParserGroupingFlags(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sawyer::CommandLine::Parser::GroupingFlags(i);
        if (retval.empty()) {
            retval = "(Sawyer::CommandLine::Parser::GroupingFlags)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sawyer::CommandLine::Parser::GroupingFlags::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySawyerCommandLineParserGroupingFlags() {
        return stringify::Sawyer::CommandLine::Parser::GroupingFlags();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/util/Sawyer/Clexer.h line 25
namespace stringify { namespace Sawyer { namespace Language { namespace Clexer {
    const char* TokenType(int64_t i) {
        switch (i) {
            case 0L: return "TOK_EOF";
            case 1L: return "TOK_LEFT";
            case 2L: return "TOK_RIGHT";
            case 3L: return "TOK_CHAR";
            case 4L: return "TOK_STRING";
            case 5L: return "TOK_NUMBER";
            case 6L: return "TOK_WORD";
            case 7L: return "TOK_CPP";
            case 8L: return "TOK_OTHER";
            default: return "";
        }
    }

    std::string TokenType(int64_t i, const std::string &strip) {
        std::string s = TokenType(i);
        if (s.empty())
            s = "(Sawyer::Language::Clexer::TokenType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& TokenType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L
        };
        static const std::vector<int64_t> retval(values, values + 9);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifySawyerLanguageClexerTokenType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sawyer::Language::Clexer::TokenType(i);
        if (retval.empty()) {
            retval = "(Sawyer::Language::Clexer::TokenType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sawyer::Language::Clexer::TokenType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySawyerLanguageClexerTokenType() {
        return stringify::Sawyer::Language::Clexer::TokenType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/util/Sawyer/Graph.h line 636
namespace stringify { namespace Sawyer { namespace Container { namespace Graph {
    const char* EdgePhase(int64_t i) {
        switch (i) {
            case 0L: return "IN_EDGES";
            case 1L: return "OUT_EDGES";
            case 2L: return "N_PHASES";
            default: return "";
        }
    }

    std::string EdgePhase(int64_t i, const std::string &strip) {
        std::string s = EdgePhase(i);
        if (s.empty())
            s = "(Sawyer::Container::Graph::EdgePhase)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& EdgePhase() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifySawyerContainerGraphEdgePhase(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sawyer::Container::Graph::EdgePhase(i);
        if (retval.empty()) {
            retval = "(Sawyer::Container::Graph::EdgePhase)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sawyer::Container::Graph::EdgePhase::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySawyerContainerGraphEdgePhase() {
        return stringify::Sawyer::Container::Graph::EdgePhase();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/util/Sawyer/DocumentMarkup.h line 42
namespace stringify { namespace Sawyer { namespace Document { namespace Markup {
    const char* TokenType(int64_t i) {
        switch (i) {
            case 0L: return "TOK_DATA";
            case 1L: return "TOK_FUNCTION";
            case 2L: return "TOK_LEFT";
            case 3L: return "TOK_RIGHT";
            case 4L: return "TOK_BLANK_LINE";
            default: return "";
        }
    }

    std::string TokenType(int64_t i, const std::string &strip) {
        std::string s = TokenType(i);
        if (s.empty())
            s = "(Sawyer::Document::Markup::TokenType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& TokenType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifySawyerDocumentMarkupTokenType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sawyer::Document::Markup::TokenType(i);
        if (retval.empty()) {
            retval = "(Sawyer::Document::Markup::TokenType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sawyer::Document::Markup::TokenType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySawyerDocumentMarkupTokenType() {
        return stringify::Sawyer::Document::Markup::TokenType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/util/Sawyer/Access.h line 19
namespace stringify { namespace Sawyer { namespace Access {
    const char* Access(int64_t i) {
        switch (i) {
            case 1L: return "EXECUTABLE";
            case 2L: return "WRITABLE";
            case 4L: return "READABLE";
            case 8L: return "IMMUTABLE";
            case 16L: return "PRIVATE";
            case 255L: return "RESERVED_MASK";
            case 4294967040L: return "USERDEF_MASK";
            default: return "";
        }
    }

    std::string Access(int64_t i, const std::string &strip) {
        std::string s = Access(i);
        if (s.empty())
            s = "(Sawyer::Access::Access)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Access() {
        static const int64_t values[] = {
            1L,
            2L,
            4L,
            8L,
            16L,
            255L,
            4294967040L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifySawyerAccessAccess(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sawyer::Access::Access(i);
        if (retval.empty()) {
            retval = "(Sawyer::Access::Access)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sawyer::Access::Access::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySawyerAccessAccess() {
        return stringify::Sawyer::Access::Access();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/util/Sawyer/GraphAlgorithm.h line 374
namespace stringify { namespace Sawyer { namespace Container { namespace Algorithm {
    const char* CsiNextAction(int64_t i) {
        switch (i) {
            case 0L: return "CSI_CONTINUE";
            case 1L: return "CSI_ABORT";
            default: return "";
        }
    }

    std::string CsiNextAction(int64_t i, const std::string &strip) {
        std::string s = CsiNextAction(i);
        if (s.empty())
            s = "(Sawyer::Container::Algorithm::CsiNextAction)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& CsiNextAction() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifySawyerContainerAlgorithmCsiNextAction(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sawyer::Container::Algorithm::CsiNextAction(i);
        if (retval.empty()) {
            retval = "(Sawyer::Container::Algorithm::CsiNextAction)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sawyer::Container::Algorithm::CsiNextAction::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySawyerContainerAlgorithmCsiNextAction() {
        return stringify::Sawyer::Container::Algorithm::CsiNextAction();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/util/Sawyer/stringifyEnums.C line 39
namespace stringify {
    const char* Generate(int64_t i) {
        switch (i) {
            case 0L: return "GENERATE_NOTHING";
            case 1L: return "GENERATE_DECLARATIONS";
            case 2L: return "GENERATE_DEFINITIONS";
            default: return "";
        }
    }

    std::string Generate(int64_t i, const std::string &strip) {
        std::string s = Generate(i);
        if (s.empty())
            s = "(Generate)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Generate() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyGenerate(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Generate(i);
        if (retval.empty()) {
            retval = "(Generate)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Generate::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyGenerate() {
        return stringify::Generate();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/util/Sawyer/stringifyEnums.C line 46
namespace stringify {
    const char* Flag(int64_t i) {
        switch (i) {
            case 2L: return "NO_CHECK";
            default: return "";
        }
    }

    std::string Flag(int64_t i, const std::string &strip) {
        std::string s = Flag(i);
        if (s.empty())
            s = "(Flag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Flag() {
        static const int64_t values[] = {
            2L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyFlag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Flag(i);
        if (retval.empty()) {
            retval = "(Flag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Flag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyFlag() {
        return stringify::Flag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/util/Sawyer/Message.h line 313
namespace stringify { namespace Sawyer { namespace Message {
    const char* Importance(int64_t i) {
        switch (i) {
            case 0L: return "DEBUG";
            case 1L: return "TRACE";
            case 2L: return "WHERE";
            case 3L: return "MARCH";
            case 4L: return "INFO";
            case 5L: return "WARN";
            case 6L: return "ERROR";
            case 7L: return "FATAL";
            case 8L: return "N_IMPORTANCE";
            default: return "";
        }
    }

    std::string Importance(int64_t i, const std::string &strip) {
        std::string s = Importance(i);
        if (s.empty())
            s = "(Sawyer::Message::Importance)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Importance() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L
        };
        static const std::vector<int64_t> retval(values, values + 9);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifySawyerMessageImportance(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sawyer::Message::Importance(i);
        if (retval.empty()) {
            retval = "(Sawyer::Message::Importance)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sawyer::Message::Importance::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySawyerMessageImportance() {
        return stringify::Sawyer::Message::Importance();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/util/Sawyer/Message.h line 343
namespace stringify { namespace Sawyer { namespace Message {
    const char* AnsiColor(int64_t i) {
        switch (i) {
            case 0L: return "COLOR_BLACK";
            case 1L: return "COLOR_RED";
            case 2L: return "COLOR_GREEN";
            case 3L: return "COLOR_YELLOW";
            case 4L: return "COLOR_BLUE";
            case 5L: return "COLOR_MAGENTA";
            case 6L: return "COLOR_CYAN";
            case 7L: return "COLOR_WHITE";
            case 8L: return "COLOR_DEFAULT";
            default: return "";
        }
    }

    std::string AnsiColor(int64_t i, const std::string &strip) {
        std::string s = AnsiColor(i);
        if (s.empty())
            s = "(Sawyer::Message::AnsiColor)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& AnsiColor() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L
        };
        static const std::vector<int64_t> retval(values, values + 9);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifySawyerMessageAnsiColor(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sawyer::Message::AnsiColor(i);
        if (retval.empty()) {
            retval = "(Sawyer::Message::AnsiColor)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sawyer::Message::AnsiColor::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySawyerMessageAnsiColor() {
        return stringify::Sawyer::Message::AnsiColor();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/util/Sawyer/Message.h line 990
namespace stringify { namespace Sawyer { namespace Message { namespace Prefix {
    const char* When(int64_t i) {
        switch (i) {
            case 0L: return "NEVER";
            case 1L: return "SOMETIMES";
            case 2L: return "ALWAYS";
            default: return "";
        }
    }

    std::string When(int64_t i, const std::string &strip) {
        std::string s = When(i);
        if (s.empty())
            s = "(Sawyer::Message::Prefix::When)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& When() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifySawyerMessagePrefixWhen(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sawyer::Message::Prefix::When(i);
        if (retval.empty()) {
            retval = "(Sawyer::Message::Prefix::When)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sawyer::Message::Prefix::When::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySawyerMessagePrefixWhen() {
        return stringify::Sawyer::Message::Prefix::When();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/util/Sawyer/GraphTraversal.h line 39
namespace stringify { namespace Sawyer { namespace Container { namespace Algorithm {
    const char* TraversalEvent(int64_t i) {
        switch (i) {
            case 0L: return "NO_EVENT";
            case 1L: return "ENTER_VERTEX";
            case 2L: return "ENTER_EDGE";
            case 4L: return "DISCOVER_VERTEX";
            case 8L: return "LEAVE_EDGE";
            case 16L: return "LEAVE_VERTEX";
            case 32L: return "FOLLOW_EDGE";
            default: return "";
        }
    }

    std::string TraversalEvent(int64_t i, const std::string &strip) {
        std::string s = TraversalEvent(i);
        if (s.empty())
            s = "(Sawyer::Container::Algorithm::TraversalEvent)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& TraversalEvent() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            4L,
            8L,
            16L,
            32L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifySawyerContainerAlgorithmTraversalEvent(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sawyer::Container::Algorithm::TraversalEvent(i);
        if (retval.empty()) {
            retval = "(Sawyer::Container::Algorithm::TraversalEvent)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sawyer::Container::Algorithm::TraversalEvent::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySawyerContainerAlgorithmTraversalEvent() {
        return stringify::Sawyer::Container::Algorithm::TraversalEvent();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/util/Sawyer/Database.h line 285
namespace stringify { namespace Sawyer { namespace Database { namespace Statement {
    const char* State(int64_t i) {
        switch (i) {
            case 0L: return "UNBOUND";
            case 1L: return "READY";
            case 2L: return "EXECUTING";
            case 3L: return "FINISHED";
            case 4L: return "DEAD";
            default: return "";
        }
    }

    std::string State(int64_t i, const std::string &strip) {
        std::string s = State(i);
        if (s.empty())
            s = "(Sawyer::Database::Statement::State)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& State() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifySawyerDatabaseStatementState(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sawyer::Database::Statement::State(i);
        if (retval.empty()) {
            retval = "(Sawyer::Database::Statement::State)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sawyer::Database::Statement::State::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySawyerDatabaseStatementState() {
        return stringify::Sawyer::Database::Statement::State();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/util/Sawyer/Tree.h line 119
namespace stringify { namespace Sawyer { namespace Tree {
    const char* TraversalEvent(int64_t i) {
        switch (i) {
            case 1L: return "ENTER";
            case 2L: return "LEAVE";
            default: return "";
        }
    }

    std::string TraversalEvent(int64_t i, const std::string &strip) {
        std::string s = TraversalEvent(i);
        if (s.empty())
            s = "(Sawyer::Tree::TraversalEvent)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& TraversalEvent() {
        static const int64_t values[] = {
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifySawyerTreeTraversalEvent(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sawyer::Tree::TraversalEvent(i);
        if (retval.empty()) {
            retval = "(Sawyer::Tree::TraversalEvent)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sawyer::Tree::TraversalEvent::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySawyerTreeTraversalEvent() {
        return stringify::Sawyer::Tree::TraversalEvent();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/util/Sawyer/Tree.h line 125
namespace stringify { namespace Sawyer { namespace Tree {
    const char* TraversalAction(int64_t i) {
        switch (i) {
            case 0L: return "CONTINUE";
            case 1L: return "SKIP_CHILDREN";
            case 2L: return "ABORT";
            default: return "";
        }
    }

    std::string TraversalAction(int64_t i, const std::string &strip) {
        std::string s = TraversalAction(i);
        if (s.empty())
            s = "(Sawyer::Tree::TraversalAction)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& TraversalAction() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifySawyerTreeTraversalAction(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sawyer::Tree::TraversalAction(i);
        if (retval.empty()) {
            retval = "(Sawyer::Tree::TraversalAction)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sawyer::Tree::TraversalAction::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySawyerTreeTraversalAction() {
        return stringify::Sawyer::Tree::TraversalAction();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/util/Sawyer/Tree.h line 481
namespace stringify { namespace Sawyer { namespace Tree { namespace Node {
    const char* TraversalDirection(int64_t i) {
        switch (i) {
            case 0L: return "TRAVERSE_UPWARD";
            case 1L: return "TRAVERSE_DOWNWARD";
            default: return "";
        }
    }

    std::string TraversalDirection(int64_t i, const std::string &strip) {
        std::string s = TraversalDirection(i);
        if (s.empty())
            s = "(Sawyer::Tree::Node::TraversalDirection)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& TraversalDirection() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifySawyerTreeNodeTraversalDirection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sawyer::Tree::Node::TraversalDirection(i);
        if (retval.empty()) {
            retval = "(Sawyer::Tree::Node::TraversalDirection)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sawyer::Tree::Node::TraversalDirection::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySawyerTreeNodeTraversalDirection() {
        return stringify::Sawyer::Tree::Node::TraversalDirection();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/backend/unparser/languageIndependenceSupport/unparseLanguageIndependentConstructs.h line 19
namespace stringify {
    const char* AssociativitySpecifier(int64_t i) {
        switch (i) {
            case 0L: return "e_assoc_none";
            case 1L: return "e_assoc_right";
            case 2L: return "e_assoc_left";
            case 3L: return "e_assoc_last";
            default: return "";
        }
    }

    std::string AssociativitySpecifier(int64_t i, const std::string &strip) {
        std::string s = AssociativitySpecifier(i);
        if (s.empty())
            s = "(AssociativitySpecifier)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& AssociativitySpecifier() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyAssociativitySpecifier(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::AssociativitySpecifier(i);
        if (retval.empty()) {
            retval = "(AssociativitySpecifier)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "AssociativitySpecifier::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyAssociativitySpecifier() {
        return stringify::AssociativitySpecifier();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/backend/unparser/languageIndependenceSupport/unparseLanguageIndependentConstructs.h line 46
namespace stringify { namespace UnparseLanguageIndependentConstructs {
    const char* token_sequence_position_enum_type(int64_t i) {
        switch (i) {
            case 0L: return "e_leading_whitespace_start";
            case 1L: return "e_leading_whitespace_end";
            case 2L: return "e_token_subsequence_start";
            case 3L: return "e_token_subsequence_end";
            case 4L: return "e_trailing_whitespace_start";
            case 5L: return "e_trailing_whitespace_end";
            case 6L: return "e_else_whitespace_start";
            case 7L: return "e_else_whitespace_end";
            default: return "";
        }
    }

    std::string token_sequence_position_enum_type(int64_t i, const std::string &strip) {
        std::string s = token_sequence_position_enum_type(i);
        if (s.empty())
            s = "(UnparseLanguageIndependentConstructs::token_sequence_position_enum_type)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& token_sequence_position_enum_type() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyUnparseLanguageIndependentConstructs_token_sequence_position_enum_type(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::UnparseLanguageIndependentConstructs::token_sequence_position_enum_type(i);
        if (retval.empty()) {
            retval = "(UnparseLanguageIndependentConstructs::token_sequence_position_enum_type)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "UnparseLanguageIndependentConstructs::token_sequence_position_enum_type::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyUnparseLanguageIndependentConstructs_token_sequence_position_enum_type() {
        return stringify::UnparseLanguageIndependentConstructs::token_sequence_position_enum_type();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/backend/unparser/languageIndependenceSupport/unparseLanguageIndependentConstructs.h line 74
namespace stringify { namespace UnparseLanguageIndependentConstructs {
    const char* unparsed_as_enum_type(int64_t i) {
        switch (i) {
            case 0L: return "e_unparsed_as_error";
            case 1L: return "e_unparsed_as_AST";
            case 2L: return "e_unparsed_as_partial_token_sequence";
            case 3L: return "e_unparsed_as_token_stream";
            case 4L: return "e_unparsed_as_last";
            default: return "";
        }
    }

    std::string unparsed_as_enum_type(int64_t i, const std::string &strip) {
        std::string s = unparsed_as_enum_type(i);
        if (s.empty())
            s = "(UnparseLanguageIndependentConstructs::unparsed_as_enum_type)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& unparsed_as_enum_type() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyUnparseLanguageIndependentConstructs_unparsed_as_enum_type(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::UnparseLanguageIndependentConstructs::unparsed_as_enum_type(i);
        if (retval.empty()) {
            retval = "(UnparseLanguageIndependentConstructs::unparsed_as_enum_type)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "UnparseLanguageIndependentConstructs::unparsed_as_enum_type::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyUnparseLanguageIndependentConstructs_unparsed_as_enum_type() {
        return stringify::UnparseLanguageIndependentConstructs::unparsed_as_enum_type();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/backend/unparser/CxxCodeGeneration/unparseCxx.h line 543
namespace stringify { namespace Unparse_ExprStmt {
    const char* token_sequence_position_enum_type(int64_t i) {
        switch (i) {
            case 0L: return "e_leading_whitespace_start";
            case 1L: return "e_leading_whitespace_end";
            case 2L: return "e_token_subsequence_start";
            case 3L: return "e_token_subsequence_end";
            case 4L: return "e_trailing_whitespace_start";
            case 5L: return "e_trailing_whitespace_end";
            default: return "";
        }
    }

    std::string token_sequence_position_enum_type(int64_t i, const std::string &strip) {
        std::string s = token_sequence_position_enum_type(i);
        if (s.empty())
            s = "(Unparse_ExprStmt::token_sequence_position_enum_type)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& token_sequence_position_enum_type() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyUnparse_ExprStmt_token_sequence_position_enum_type(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Unparse_ExprStmt::token_sequence_position_enum_type(i);
        if (retval.empty()) {
            retval = "(Unparse_ExprStmt::token_sequence_position_enum_type)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Unparse_ExprStmt::token_sequence_position_enum_type::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyUnparse_ExprStmt_token_sequence_position_enum_type() {
        return stringify::Unparse_ExprStmt::token_sequence_position_enum_type();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/backend/unparser/unparser.h line 200
namespace stringify { namespace Unparser {
    const char* token_sequence_position_enum_type(int64_t i) {
        switch (i) {
            case 0L: return "e_leading_whitespace_start";
            case 1L: return "e_leading_whitespace_end";
            case 2L: return "e_token_subsequence_start";
            case 3L: return "e_token_subsequence_end";
            case 4L: return "e_trailing_whitespace_start";
            case 5L: return "e_trailing_whitespace_end";
            default: return "";
        }
    }

    std::string token_sequence_position_enum_type(int64_t i, const std::string &strip) {
        std::string s = token_sequence_position_enum_type(i);
        if (s.empty())
            s = "(Unparser::token_sequence_position_enum_type)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& token_sequence_position_enum_type() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyUnparser_token_sequence_position_enum_type(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Unparser::token_sequence_position_enum_type(i);
        if (retval.empty()) {
            retval = "(Unparser::token_sequence_position_enum_type)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Unparser::token_sequence_position_enum_type::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyUnparser_token_sequence_position_enum_type() {
        return stringify::Unparser::token_sequence_position_enum_type();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/backend/unparser/astUnparseAttribute.h line 33
namespace stringify { namespace AstUnparseAttribute {
    const char* RelativePositionType(int64_t i) {
        switch (i) {
            case 0L: return "e_defaultValue";
            case 1L: return "e_undef";
            case 2L: return "e_before";
            case 3L: return "e_after";
            case 4L: return "e_inside";
            case 5L: return "e_replace";
            case 6L: return "e_before_syntax";
            case 7L: return "e_after_syntax";
            case 8L: return "e_before_but_after_cpp_directives_and_comments";
            default: return "";
        }
    }

    std::string RelativePositionType(int64_t i, const std::string &strip) {
        std::string s = RelativePositionType(i);
        if (s.empty())
            s = "(AstUnparseAttribute::RelativePositionType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& RelativePositionType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L
        };
        static const std::vector<int64_t> retval(values, values + 9);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyAstUnparseAttributeRelativePositionType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::AstUnparseAttribute::RelativePositionType(i);
        if (retval.empty()) {
            retval = "(AstUnparseAttribute::RelativePositionType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "AstUnparseAttribute::RelativePositionType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyAstUnparseAttributeRelativePositionType() {
        return stringify::AstUnparseAttribute::RelativePositionType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/backend/unparser/formatSupport/unparse_format.h line 51
namespace stringify {
    const char* Format_Opt(int64_t i) {
        switch (i) {
            case 0L: return "FORMAT_BEFORE_DIRECTIVE";
            case 1L: return "FORMAT_AFTER_DIRECTIVE";
            case 2L: return "FORMAT_BEFORE_STMT";
            case 3L: return "FORMAT_AFTER_STMT";
            case 4L: return "FORMAT_BEFORE_BASIC_BLOCK1";
            case 5L: return "FORMAT_AFTER_BASIC_BLOCK1";
            case 6L: return "FORMAT_BEFORE_BASIC_BLOCK2";
            case 7L: return "FORMAT_AFTER_BASIC_BLOCK2";
            case 8L: return "FORMAT_BEFORE_NESTED_STATEMENT";
            case 9L: return "FORMAT_AFTER_NESTED_STATEMENT";
            default: return "";
        }
    }

    std::string Format_Opt(int64_t i, const std::string &strip) {
        std::string s = Format_Opt(i);
        if (s.empty())
            s = "(Format_Opt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Format_Opt() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L
        };
        static const std::vector<int64_t> retval(values, values + 10);
        return retval;
    }

}

namespace Rose {
    std::string stringifyFormat_Opt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Format_Opt(i);
        if (retval.empty()) {
            retval = "(Format_Opt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Format_Opt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyFormat_Opt() {
        return stringify::Format_Opt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/MSTL/DOTGeneration.h line 48
namespace stringify { namespace DOTGeneration {
    const char* traversalType(int64_t i) {
        switch (i) {
            case 0L: return "PREORDER";
            case 1L: return "POSTORDER";
            case 2L: return "TOPDOWN";
            case 3L: return "BOTTOMUP";
            case 4L: return "TOPDOWNBOTTOMUP";
            default: return "";
        }
    }

    std::string traversalType(int64_t i, const std::string &strip) {
        std::string s = traversalType(i);
        if (s.empty())
            s = "(DOTGeneration::traversalType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& traversalType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyDOTGeneration_traversalType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::DOTGeneration::traversalType(i);
        if (retval.empty()) {
            retval = "(DOTGeneration::traversalType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "DOTGeneration::traversalType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyDOTGeneration_traversalType() {
        return stringify::DOTGeneration::traversalType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/libharu-2.1.0/include/hpdf_font.h line 31
namespace stringify {
    const char* _HPDF_FontType(int64_t i) {
        switch (i) {
            case 0L: return "HPDF_FONT_TYPE1";
            case 1L: return "HPDF_FONT_TRUETYPE";
            case 2L: return "HPDF_FONT_TYPE3";
            case 3L: return "HPDF_FONT_TYPE0_CID";
            case 4L: return "HPDF_FONT_TYPE0_TT";
            case 5L: return "HPDF_FONT_CID_TYPE0";
            case 6L: return "HPDF_FONT_CID_TYPE2";
            case 7L: return "HPDF_FONT_MMTYPE1";
            default: return "";
        }
    }

    std::string _HPDF_FontType(int64_t i, const std::string &strip) {
        std::string s = _HPDF_FontType(i);
        if (s.empty())
            s = "(_HPDF_FontType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _HPDF_FontType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}

namespace Rose {
    std::string stringify_HPDF_FontType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_HPDF_FontType(i);
        if (retval.empty()) {
            retval = "(_HPDF_FontType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_HPDF_FontType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_HPDF_FontType() {
        return stringify::_HPDF_FontType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/libharu-2.1.0/include/hpdf_fontdef.h line 63
namespace stringify {
    const char* _HPDF_FontDefType(int64_t i) {
        switch (i) {
            case 0L: return "HPDF_FONTDEF_TYPE_TYPE1";
            case 1L: return "HPDF_FONTDEF_TYPE_TRUETYPE";
            case 2L: return "HPDF_FONTDEF_TYPE_CID";
            case 3L: return "HPDF_FONTDEF_TYPE_UNINITIALIZED";
            case 4L: return "HPDF_FONTDEF_TYPE_EOF";
            default: return "";
        }
    }

    std::string _HPDF_FontDefType(int64_t i, const std::string &strip) {
        std::string s = _HPDF_FontDefType(i);
        if (s.empty())
            s = "(_HPDF_FontDefType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _HPDF_FontDefType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringify_HPDF_FontDefType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_HPDF_FontDefType(i);
        if (retval.empty()) {
            retval = "(_HPDF_FontDefType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_HPDF_FontDefType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_HPDF_FontDefType() {
        return stringify::_HPDF_FontDefType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/libharu-2.1.0/include/hpdf_types.h line 128
namespace stringify {
    const char* _HPDF_InfoType(int64_t i) {
        switch (i) {
            case 0L: return "HPDF_INFO_CREATION_DATE";
            case 1L: return "HPDF_INFO_MOD_DATE";
            case 2L: return "HPDF_INFO_AUTHOR";
            case 3L: return "HPDF_INFO_CREATOR";
            case 4L: return "HPDF_INFO_PRODUCER";
            case 5L: return "HPDF_INFO_TITLE";
            case 6L: return "HPDF_INFO_SUBJECT";
            case 7L: return "HPDF_INFO_KEYWORDS";
            case 8L: return "HPDF_INFO_EOF";
            default: return "";
        }
    }

    std::string _HPDF_InfoType(int64_t i, const std::string &strip) {
        std::string s = _HPDF_InfoType(i);
        if (s.empty())
            s = "(_HPDF_InfoType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _HPDF_InfoType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L
        };
        static const std::vector<int64_t> retval(values, values + 9);
        return retval;
    }

}

namespace Rose {
    std::string stringify_HPDF_InfoType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_HPDF_InfoType(i);
        if (retval.empty()) {
            retval = "(_HPDF_InfoType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_HPDF_InfoType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_HPDF_InfoType() {
        return stringify::_HPDF_InfoType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/libharu-2.1.0/include/hpdf_types.h line 144
namespace stringify {
    const char* _HPDF_PdfVer(int64_t i) {
        switch (i) {
            case 0L: return "HPDF_VER_12";
            case 1L: return "HPDF_VER_13";
            case 2L: return "HPDF_VER_14";
            case 3L: return "HPDF_VER_15";
            case 4L: return "HPDF_VER_16";
            case 5L: return "HPDF_VER_17";
            case 6L: return "HPDF_VER_EOF";
            default: return "";
        }
    }

    std::string _HPDF_PdfVer(int64_t i, const std::string &strip) {
        std::string s = _HPDF_PdfVer(i);
        if (s.empty())
            s = "(_HPDF_PdfVer)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _HPDF_PdfVer() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}

namespace Rose {
    std::string stringify_HPDF_PdfVer(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_HPDF_PdfVer(i);
        if (retval.empty()) {
            retval = "(_HPDF_PdfVer)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_HPDF_PdfVer::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_HPDF_PdfVer() {
        return stringify::_HPDF_PdfVer();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/libharu-2.1.0/include/hpdf_types.h line 154
namespace stringify {
    const char* _HPDF_EncryptMode(int64_t i) {
        switch (i) {
            case 2L: return "HPDF_ENCRYPT_R2";
            case 3L: return "HPDF_ENCRYPT_R3";
            default: return "";
        }
    }

    std::string _HPDF_EncryptMode(int64_t i, const std::string &strip) {
        std::string s = _HPDF_EncryptMode(i);
        if (s.empty())
            s = "(_HPDF_EncryptMode)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _HPDF_EncryptMode() {
        static const int64_t values[] = {
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringify_HPDF_EncryptMode(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_HPDF_EncryptMode(i);
        if (retval.empty()) {
            retval = "(_HPDF_EncryptMode)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_HPDF_EncryptMode::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_HPDF_EncryptMode() {
        return stringify::_HPDF_EncryptMode();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/libharu-2.1.0/include/hpdf_types.h line 213
namespace stringify {
    const char* _HPDF_ColorSpace(int64_t i) {
        switch (i) {
            case 0L: return "HPDF_CS_DEVICE_GRAY";
            case 1L: return "HPDF_CS_DEVICE_RGB";
            case 2L: return "HPDF_CS_DEVICE_CMYK";
            case 3L: return "HPDF_CS_CAL_GRAY";
            case 4L: return "HPDF_CS_CAL_RGB";
            case 5L: return "HPDF_CS_LAB";
            case 6L: return "HPDF_CS_ICC_BASED";
            case 7L: return "HPDF_CS_SEPARATION";
            case 8L: return "HPDF_CS_DEVICE_N";
            case 9L: return "HPDF_CS_INDEXED";
            case 10L: return "HPDF_CS_PATTERN";
            case 11L: return "HPDF_CS_EOF";
            default: return "";
        }
    }

    std::string _HPDF_ColorSpace(int64_t i, const std::string &strip) {
        std::string s = _HPDF_ColorSpace(i);
        if (s.empty())
            s = "(_HPDF_ColorSpace)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _HPDF_ColorSpace() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L
        };
        static const std::vector<int64_t> retval(values, values + 12);
        return retval;
    }

}

namespace Rose {
    std::string stringify_HPDF_ColorSpace(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_HPDF_ColorSpace(i);
        if (retval.empty()) {
            retval = "(_HPDF_ColorSpace)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_HPDF_ColorSpace::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_HPDF_ColorSpace() {
        return stringify::_HPDF_ColorSpace();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/libharu-2.1.0/include/hpdf_types.h line 250
namespace stringify {
    const char* _HPDF_LineCap(int64_t i) {
        switch (i) {
            case 0L: return "HPDF_BUTT_END";
            case 1L: return "HPDF_ROUND_END";
            case 2L: return "HPDF_PROJECTING_SCUARE_END";
            case 3L: return "HPDF_LINECAP_EOF";
            default: return "";
        }
    }

    std::string _HPDF_LineCap(int64_t i, const std::string &strip) {
        std::string s = _HPDF_LineCap(i);
        if (s.empty())
            s = "(_HPDF_LineCap)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _HPDF_LineCap() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringify_HPDF_LineCap(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_HPDF_LineCap(i);
        if (retval.empty()) {
            retval = "(_HPDF_LineCap)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_HPDF_LineCap::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_HPDF_LineCap() {
        return stringify::_HPDF_LineCap();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/libharu-2.1.0/include/hpdf_types.h line 260
namespace stringify {
    const char* _HPDF_LineJoin(int64_t i) {
        switch (i) {
            case 0L: return "HPDF_MITER_JOIN";
            case 1L: return "HPDF_ROUND_JOIN";
            case 2L: return "HPDF_BEVEL_JOIN";
            case 3L: return "HPDF_LINEJOIN_EOF";
            default: return "";
        }
    }

    std::string _HPDF_LineJoin(int64_t i, const std::string &strip) {
        std::string s = _HPDF_LineJoin(i);
        if (s.empty())
            s = "(_HPDF_LineJoin)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _HPDF_LineJoin() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringify_HPDF_LineJoin(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_HPDF_LineJoin(i);
        if (retval.empty()) {
            retval = "(_HPDF_LineJoin)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_HPDF_LineJoin::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_HPDF_LineJoin() {
        return stringify::_HPDF_LineJoin();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/libharu-2.1.0/include/hpdf_types.h line 270
namespace stringify {
    const char* _HPDF_TextRenderingMode(int64_t i) {
        switch (i) {
            case 0L: return "HPDF_FILL";
            case 1L: return "HPDF_STROKE";
            case 2L: return "HPDF_FILL_THEN_STROKE";
            case 3L: return "HPDF_INVISIBLE";
            case 4L: return "HPDF_FILL_CLIPPING";
            case 5L: return "HPDF_STROKE_CLIPPING";
            case 6L: return "HPDF_FILL_STROKE_CLIPPING";
            case 7L: return "HPDF_CLIPPING";
            case 8L: return "HPDF_RENDERING_MODE_EOF";
            default: return "";
        }
    }

    std::string _HPDF_TextRenderingMode(int64_t i, const std::string &strip) {
        std::string s = _HPDF_TextRenderingMode(i);
        if (s.empty())
            s = "(_HPDF_TextRenderingMode)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _HPDF_TextRenderingMode() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L
        };
        static const std::vector<int64_t> retval(values, values + 9);
        return retval;
    }

}

namespace Rose {
    std::string stringify_HPDF_TextRenderingMode(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_HPDF_TextRenderingMode(i);
        if (retval.empty()) {
            retval = "(_HPDF_TextRenderingMode)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_HPDF_TextRenderingMode::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_HPDF_TextRenderingMode() {
        return stringify::_HPDF_TextRenderingMode();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/libharu-2.1.0/include/hpdf_types.h line 283
namespace stringify {
    const char* _HPDF_WritingMode(int64_t i) {
        switch (i) {
            case 0L: return "HPDF_WMODE_HORIZONTAL";
            case 1L: return "HPDF_WMODE_VERTICAL";
            case 2L: return "HPDF_WMODE_EOF";
            default: return "";
        }
    }

    std::string _HPDF_WritingMode(int64_t i, const std::string &strip) {
        std::string s = _HPDF_WritingMode(i);
        if (s.empty())
            s = "(_HPDF_WritingMode)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _HPDF_WritingMode() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringify_HPDF_WritingMode(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_HPDF_WritingMode(i);
        if (retval.empty()) {
            retval = "(_HPDF_WritingMode)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_HPDF_WritingMode::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_HPDF_WritingMode() {
        return stringify::_HPDF_WritingMode();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/libharu-2.1.0/include/hpdf_types.h line 290
namespace stringify {
    const char* _HPDF_PageLayout(int64_t i) {
        switch (i) {
            case 0L: return "HPDF_PAGE_LAYOUT_SINGLE";
            case 1L: return "HPDF_PAGE_LAYOUT_ONE_COLUMN";
            case 2L: return "HPDF_PAGE_LAYOUT_TWO_COLUMN_LEFT";
            case 3L: return "HPDF_PAGE_LAYOUT_TWO_COLUMN_RIGHT";
            case 4L: return "HPDF_PAGE_LAYOUT_EOF";
            default: return "";
        }
    }

    std::string _HPDF_PageLayout(int64_t i, const std::string &strip) {
        std::string s = _HPDF_PageLayout(i);
        if (s.empty())
            s = "(_HPDF_PageLayout)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _HPDF_PageLayout() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringify_HPDF_PageLayout(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_HPDF_PageLayout(i);
        if (retval.empty()) {
            retval = "(_HPDF_PageLayout)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_HPDF_PageLayout::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_HPDF_PageLayout() {
        return stringify::_HPDF_PageLayout();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/libharu-2.1.0/include/hpdf_types.h line 299
namespace stringify {
    const char* _HPDF_PageMode(int64_t i) {
        switch (i) {
            case 0L: return "HPDF_PAGE_MODE_USE_NONE";
            case 1L: return "HPDF_PAGE_MODE_USE_OUTLINE";
            case 2L: return "HPDF_PAGE_MODE_USE_THUMBS";
            case 3L: return "HPDF_PAGE_MODE_FULL_SCREEN";
            case 4L: return "HPDF_PAGE_MODE_EOF";
            default: return "";
        }
    }

    std::string _HPDF_PageMode(int64_t i, const std::string &strip) {
        std::string s = _HPDF_PageMode(i);
        if (s.empty())
            s = "(_HPDF_PageMode)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _HPDF_PageMode() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringify_HPDF_PageMode(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_HPDF_PageMode(i);
        if (retval.empty()) {
            retval = "(_HPDF_PageMode)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_HPDF_PageMode::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_HPDF_PageMode() {
        return stringify::_HPDF_PageMode();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/libharu-2.1.0/include/hpdf_types.h line 311
namespace stringify {
    const char* _HPDF_PageNumStyle(int64_t i) {
        switch (i) {
            case 0L: return "HPDF_PAGE_NUM_STYLE_DECIMAL";
            case 1L: return "HPDF_PAGE_NUM_STYLE_UPPER_ROMAN";
            case 2L: return "HPDF_PAGE_NUM_STYLE_LOWER_ROMAN";
            case 3L: return "HPDF_PAGE_NUM_STYLE_UPPER_LETTERS";
            case 4L: return "HPDF_PAGE_NUM_STYLE_LOWER_LETTERS";
            case 5L: return "HPDF_PAGE_NUM_STYLE_EOF";
            default: return "";
        }
    }

    std::string _HPDF_PageNumStyle(int64_t i, const std::string &strip) {
        std::string s = _HPDF_PageNumStyle(i);
        if (s.empty())
            s = "(_HPDF_PageNumStyle)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _HPDF_PageNumStyle() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}

namespace Rose {
    std::string stringify_HPDF_PageNumStyle(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_HPDF_PageNumStyle(i);
        if (retval.empty()) {
            retval = "(_HPDF_PageNumStyle)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_HPDF_PageNumStyle::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_HPDF_PageNumStyle() {
        return stringify::_HPDF_PageNumStyle();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/libharu-2.1.0/include/hpdf_types.h line 321
namespace stringify {
    const char* _HPDF_DestinationType(int64_t i) {
        switch (i) {
            case 0L: return "HPDF_XYZ";
            case 1L: return "HPDF_FIT";
            case 2L: return "HPDF_FIT_H";
            case 3L: return "HPDF_FIT_V";
            case 4L: return "HPDF_FIT_R";
            case 5L: return "HPDF_FIT_B";
            case 6L: return "HPDF_FIT_BH";
            case 7L: return "HPDF_FIT_BV";
            case 8L: return "HPDF_DST_EOF";
            default: return "";
        }
    }

    std::string _HPDF_DestinationType(int64_t i, const std::string &strip) {
        std::string s = _HPDF_DestinationType(i);
        if (s.empty())
            s = "(_HPDF_DestinationType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _HPDF_DestinationType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L
        };
        static const std::vector<int64_t> retval(values, values + 9);
        return retval;
    }

}

namespace Rose {
    std::string stringify_HPDF_DestinationType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_HPDF_DestinationType(i);
        if (retval.empty()) {
            retval = "(_HPDF_DestinationType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_HPDF_DestinationType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_HPDF_DestinationType() {
        return stringify::_HPDF_DestinationType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/libharu-2.1.0/include/hpdf_types.h line 334
namespace stringify {
    const char* _HPDF_AnnotType(int64_t i) {
        switch (i) {
            case 0L: return "HPDF_ANNOT_TEXT_NOTES";
            case 1L: return "HPDF_ANNOT_LINK";
            case 2L: return "HPDF_ANNOT_SOUND";
            case 3L: return "HPDF_ANNOT_FREE_TEXT";
            case 4L: return "HPDF_ANNOT_STAMP";
            case 5L: return "HPDF_ANNOT_SQUARE";
            case 6L: return "HPDF_ANNOT_CIRCLE";
            case 7L: return "HPDF_ANNOT_STRIKE_OUT";
            case 8L: return "HPDF_ANNOT_HIGHTLIGHT";
            case 9L: return "HPDF_ANNOT_UNDERLINE";
            case 10L: return "HPDF_ANNOT_INK";
            case 11L: return "HPDF_ANNOT_FILE_ATTACHMENT";
            case 12L: return "HPDF_ANNOT_POPUP";
            case 13L: return "HPDF_ANNOT_3D";
            default: return "";
        }
    }

    std::string _HPDF_AnnotType(int64_t i, const std::string &strip) {
        std::string s = _HPDF_AnnotType(i);
        if (s.empty())
            s = "(_HPDF_AnnotType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _HPDF_AnnotType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L
        };
        static const std::vector<int64_t> retval(values, values + 14);
        return retval;
    }

}

namespace Rose {
    std::string stringify_HPDF_AnnotType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_HPDF_AnnotType(i);
        if (retval.empty()) {
            retval = "(_HPDF_AnnotType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_HPDF_AnnotType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_HPDF_AnnotType() {
        return stringify::_HPDF_AnnotType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/libharu-2.1.0/include/hpdf_types.h line 352
namespace stringify {
    const char* _HPDF_AnnotFlgs(int64_t i) {
        switch (i) {
            case 0L: return "HPDF_ANNOT_INVISIBLE";
            case 1L: return "HPDF_ANNOT_HIDDEN";
            case 2L: return "HPDF_ANNOT_PRINT";
            case 3L: return "HPDF_ANNOT_NOZOOM";
            case 4L: return "HPDF_ANNOT_NOROTATE";
            case 5L: return "HPDF_ANNOT_NOVIEW";
            case 6L: return "HPDF_ANNOT_READONLY";
            default: return "";
        }
    }

    std::string _HPDF_AnnotFlgs(int64_t i, const std::string &strip) {
        std::string s = _HPDF_AnnotFlgs(i);
        if (s.empty())
            s = "(_HPDF_AnnotFlgs)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _HPDF_AnnotFlgs() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}

namespace Rose {
    std::string stringify_HPDF_AnnotFlgs(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_HPDF_AnnotFlgs(i);
        if (retval.empty()) {
            retval = "(_HPDF_AnnotFlgs)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_HPDF_AnnotFlgs::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_HPDF_AnnotFlgs() {
        return stringify::_HPDF_AnnotFlgs();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/libharu-2.1.0/include/hpdf_types.h line 363
namespace stringify {
    const char* _HPDF_AnnotHighlightMode(int64_t i) {
        switch (i) {
            case 0L: return "HPDF_ANNOT_NO_HIGHTLIGHT";
            case 1L: return "HPDF_ANNOT_INVERT_BOX";
            case 2L: return "HPDF_ANNOT_INVERT_BORDER";
            case 3L: return "HPDF_ANNOT_DOWN_APPEARANCE";
            case 4L: return "HPDF_ANNOT_HIGHTLIGHT_MODE_EOF";
            default: return "";
        }
    }

    std::string _HPDF_AnnotHighlightMode(int64_t i, const std::string &strip) {
        std::string s = _HPDF_AnnotHighlightMode(i);
        if (s.empty())
            s = "(_HPDF_AnnotHighlightMode)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _HPDF_AnnotHighlightMode() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringify_HPDF_AnnotHighlightMode(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_HPDF_AnnotHighlightMode(i);
        if (retval.empty()) {
            retval = "(_HPDF_AnnotHighlightMode)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_HPDF_AnnotHighlightMode::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_HPDF_AnnotHighlightMode() {
        return stringify::_HPDF_AnnotHighlightMode();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/libharu-2.1.0/include/hpdf_types.h line 372
namespace stringify {
    const char* _HPDF_AnnotIcon(int64_t i) {
        switch (i) {
            case 0L: return "HPDF_ANNOT_ICON_COMMENT";
            case 1L: return "HPDF_ANNOT_ICON_KEY";
            case 2L: return "HPDF_ANNOT_ICON_NOTE";
            case 3L: return "HPDF_ANNOT_ICON_HELP";
            case 4L: return "HPDF_ANNOT_ICON_NEW_PARAGRAPH";
            case 5L: return "HPDF_ANNOT_ICON_PARAGRAPH";
            case 6L: return "HPDF_ANNOT_ICON_INSERT";
            case 7L: return "HPDF_ANNOT_ICON_EOF";
            default: return "";
        }
    }

    std::string _HPDF_AnnotIcon(int64_t i, const std::string &strip) {
        std::string s = _HPDF_AnnotIcon(i);
        if (s.empty())
            s = "(_HPDF_AnnotIcon)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _HPDF_AnnotIcon() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}

namespace Rose {
    std::string stringify_HPDF_AnnotIcon(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_HPDF_AnnotIcon(i);
        if (retval.empty()) {
            retval = "(_HPDF_AnnotIcon)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_HPDF_AnnotIcon::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_HPDF_AnnotIcon() {
        return stringify::_HPDF_AnnotIcon();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/libharu-2.1.0/include/hpdf_types.h line 388
namespace stringify {
    const char* _HPDF_BSSubtype(int64_t i) {
        switch (i) {
            case 0L: return "HPDF_BS_SOLID";
            case 1L: return "HPDF_BS_DASHED";
            case 2L: return "HPDF_BS_BEVELED";
            case 3L: return "HPDF_BS_INSET";
            case 4L: return "HPDF_BS_UNDERLINED";
            default: return "";
        }
    }

    std::string _HPDF_BSSubtype(int64_t i, const std::string &strip) {
        std::string s = _HPDF_BSSubtype(i);
        if (s.empty())
            s = "(_HPDF_BSSubtype)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _HPDF_BSSubtype() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringify_HPDF_BSSubtype(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_HPDF_BSSubtype(i);
        if (retval.empty()) {
            retval = "(_HPDF_BSSubtype)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_HPDF_BSSubtype::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_HPDF_BSSubtype() {
        return stringify::_HPDF_BSSubtype();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/libharu-2.1.0/include/hpdf_types.h line 399
namespace stringify {
    const char* _HPDF_BlendMode(int64_t i) {
        switch (i) {
            case 0L: return "HPDF_BM_NORMAL";
            case 1L: return "HPDF_BM_MULTIPLY";
            case 2L: return "HPDF_BM_SCREEN";
            case 3L: return "HPDF_BM_OVERLAY";
            case 4L: return "HPDF_BM_DARKEN";
            case 5L: return "HPDF_BM_LIGHTEN";
            case 6L: return "HPDF_BM_COLOR_DODGE";
            case 7L: return "HPDF_BM_COLOR_BUM";
            case 8L: return "HPDF_BM_HARD_LIGHT";
            case 9L: return "HPDF_BM_SOFT_LIGHT";
            case 10L: return "HPDF_BM_DIFFERENCE";
            case 11L: return "HPDF_BM_EXCLUSHON";
            case 12L: return "HPDF_BM_EOF";
            default: return "";
        }
    }

    std::string _HPDF_BlendMode(int64_t i, const std::string &strip) {
        std::string s = _HPDF_BlendMode(i);
        if (s.empty())
            s = "(_HPDF_BlendMode)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _HPDF_BlendMode() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L
        };
        static const std::vector<int64_t> retval(values, values + 13);
        return retval;
    }

}

namespace Rose {
    std::string stringify_HPDF_BlendMode(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_HPDF_BlendMode(i);
        if (retval.empty()) {
            retval = "(_HPDF_BlendMode)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_HPDF_BlendMode::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_HPDF_BlendMode() {
        return stringify::_HPDF_BlendMode();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/libharu-2.1.0/include/hpdf_types.h line 417
namespace stringify {
    const char* _HPDF_TransitionStyle(int64_t i) {
        switch (i) {
            case 0L: return "HPDF_TS_WIPE_RIGHT";
            case 1L: return "HPDF_TS_WIPE_UP";
            case 2L: return "HPDF_TS_WIPE_LEFT";
            case 3L: return "HPDF_TS_WIPE_DOWN";
            case 4L: return "HPDF_TS_BARN_DOORS_HORIZONTAL_OUT";
            case 5L: return "HPDF_TS_BARN_DOORS_HORIZONTAL_IN";
            case 6L: return "HPDF_TS_BARN_DOORS_VERTICAL_OUT";
            case 7L: return "HPDF_TS_BARN_DOORS_VERTICAL_IN";
            case 8L: return "HPDF_TS_BOX_OUT";
            case 9L: return "HPDF_TS_BOX_IN";
            case 10L: return "HPDF_TS_BLINDS_HORIZONTAL";
            case 11L: return "HPDF_TS_BLINDS_VERTICAL";
            case 12L: return "HPDF_TS_DISSOLVE";
            case 13L: return "HPDF_TS_GLITTER_RIGHT";
            case 14L: return "HPDF_TS_GLITTER_DOWN";
            case 15L: return "HPDF_TS_GLITTER_TOP_LEFT_TO_BOTTOM_RIGHT";
            case 16L: return "HPDF_TS_REPLACE";
            case 17L: return "HPDF_TS_EOF";
            default: return "";
        }
    }

    std::string _HPDF_TransitionStyle(int64_t i, const std::string &strip) {
        std::string s = _HPDF_TransitionStyle(i);
        if (s.empty())
            s = "(_HPDF_TransitionStyle)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _HPDF_TransitionStyle() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L
        };
        static const std::vector<int64_t> retval(values, values + 18);
        return retval;
    }

}

namespace Rose {
    std::string stringify_HPDF_TransitionStyle(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_HPDF_TransitionStyle(i);
        if (retval.empty()) {
            retval = "(_HPDF_TransitionStyle)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_HPDF_TransitionStyle::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_HPDF_TransitionStyle() {
        return stringify::_HPDF_TransitionStyle();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/libharu-2.1.0/include/hpdf_types.h line 440
namespace stringify {
    const char* _HPDF_PageSizes(int64_t i) {
        switch (i) {
            case 0L: return "HPDF_PAGE_SIZE_LETTER";
            case 1L: return "HPDF_PAGE_SIZE_LEGAL";
            case 2L: return "HPDF_PAGE_SIZE_A3";
            case 3L: return "HPDF_PAGE_SIZE_A4";
            case 4L: return "HPDF_PAGE_SIZE_A5";
            case 5L: return "HPDF_PAGE_SIZE_B4";
            case 6L: return "HPDF_PAGE_SIZE_B5";
            case 7L: return "HPDF_PAGE_SIZE_EXECUTIVE";
            case 8L: return "HPDF_PAGE_SIZE_US4x6";
            case 9L: return "HPDF_PAGE_SIZE_US4x8";
            case 10L: return "HPDF_PAGE_SIZE_US5x7";
            case 11L: return "HPDF_PAGE_SIZE_COMM10";
            case 12L: return "HPDF_PAGE_SIZE_EOF";
            default: return "";
        }
    }

    std::string _HPDF_PageSizes(int64_t i, const std::string &strip) {
        std::string s = _HPDF_PageSizes(i);
        if (s.empty())
            s = "(_HPDF_PageSizes)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _HPDF_PageSizes() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L
        };
        static const std::vector<int64_t> retval(values, values + 13);
        return retval;
    }

}

namespace Rose {
    std::string stringify_HPDF_PageSizes(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_HPDF_PageSizes(i);
        if (retval.empty()) {
            retval = "(_HPDF_PageSizes)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_HPDF_PageSizes::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_HPDF_PageSizes() {
        return stringify::_HPDF_PageSizes();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/libharu-2.1.0/include/hpdf_types.h line 457
namespace stringify {
    const char* _HPDF_PageDirection(int64_t i) {
        switch (i) {
            case 0L: return "HPDF_PAGE_PORTRAIT";
            case 1L: return "HPDF_PAGE_LANDSCAPE";
            default: return "";
        }
    }

    std::string _HPDF_PageDirection(int64_t i, const std::string &strip) {
        std::string s = _HPDF_PageDirection(i);
        if (s.empty())
            s = "(_HPDF_PageDirection)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _HPDF_PageDirection() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringify_HPDF_PageDirection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_HPDF_PageDirection(i);
        if (retval.empty()) {
            retval = "(_HPDF_PageDirection)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_HPDF_PageDirection::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_HPDF_PageDirection() {
        return stringify::_HPDF_PageDirection();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/libharu-2.1.0/include/hpdf_types.h line 463
namespace stringify {
    const char* _HPDF_EncoderType(int64_t i) {
        switch (i) {
            case 0L: return "HPDF_ENCODER_TYPE_SINGLE_BYTE";
            case 1L: return "HPDF_ENCODER_TYPE_DOUBLE_BYTE";
            case 2L: return "HPDF_ENCODER_TYPE_UNINITIALIZED";
            case 3L: return "HPDF_ENCODER_UNKNOWN";
            default: return "";
        }
    }

    std::string _HPDF_EncoderType(int64_t i, const std::string &strip) {
        std::string s = _HPDF_EncoderType(i);
        if (s.empty())
            s = "(_HPDF_EncoderType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _HPDF_EncoderType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringify_HPDF_EncoderType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_HPDF_EncoderType(i);
        if (retval.empty()) {
            retval = "(_HPDF_EncoderType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_HPDF_EncoderType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_HPDF_EncoderType() {
        return stringify::_HPDF_EncoderType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/libharu-2.1.0/include/hpdf_types.h line 471
namespace stringify {
    const char* _HPDF_ByteType(int64_t i) {
        switch (i) {
            case 0L: return "HPDF_BYTE_TYPE_SINGLE";
            case 1L: return "HPDF_BYTE_TYPE_LEAD";
            case 2L: return "HPDF_BYTE_TYPE_TRIAL";
            case 3L: return "HPDF_BYTE_TYPE_UNKNOWN";
            default: return "";
        }
    }

    std::string _HPDF_ByteType(int64_t i, const std::string &strip) {
        std::string s = _HPDF_ByteType(i);
        if (s.empty())
            s = "(_HPDF_ByteType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _HPDF_ByteType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringify_HPDF_ByteType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_HPDF_ByteType(i);
        if (retval.empty()) {
            retval = "(_HPDF_ByteType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_HPDF_ByteType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_HPDF_ByteType() {
        return stringify::_HPDF_ByteType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/libharu-2.1.0/include/hpdf_types.h line 479
namespace stringify {
    const char* _HPDF_TextAlignment(int64_t i) {
        switch (i) {
            case 0L: return "HPDF_TALIGN_LEFT";
            case 1L: return "HPDF_TALIGN_RIGHT";
            case 2L: return "HPDF_TALIGN_CENTER";
            case 3L: return "HPDF_TALIGN_JUSTIFY";
            default: return "";
        }
    }

    std::string _HPDF_TextAlignment(int64_t i, const std::string &strip) {
        std::string s = _HPDF_TextAlignment(i);
        if (s.empty())
            s = "(_HPDF_TextAlignment)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _HPDF_TextAlignment() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringify_HPDF_TextAlignment(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_HPDF_TextAlignment(i);
        if (retval.empty()) {
            retval = "(_HPDF_TextAlignment)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_HPDF_TextAlignment::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_HPDF_TextAlignment() {
        return stringify::_HPDF_TextAlignment();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/libharu-2.1.0/include/hpdf_streams.h line 33
namespace stringify {
    const char* _HPDF_StreamType(int64_t i) {
        switch (i) {
            case 0L: return "HPDF_STREAM_UNKNOWN";
            case 1L: return "HPDF_STREAM_CALLBACK";
            case 2L: return "HPDF_STREAM_FILE";
            case 3L: return "HPDF_STREAM_MEMORY";
            default: return "";
        }
    }

    std::string _HPDF_StreamType(int64_t i, const std::string &strip) {
        std::string s = _HPDF_StreamType(i);
        if (s.empty())
            s = "(_HPDF_StreamType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _HPDF_StreamType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringify_HPDF_StreamType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_HPDF_StreamType(i);
        if (retval.empty()) {
            retval = "(_HPDF_StreamType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_HPDF_StreamType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_HPDF_StreamType() {
        return stringify::_HPDF_StreamType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/libharu-2.1.0/include/hpdf_streams.h line 46
namespace stringify {
    const char* _HPDF_WhenceMode(int64_t i) {
        switch (i) {
            case 0L: return "HPDF_SEEK_SET";
            case 1L: return "HPDF_SEEK_CUR";
            case 2L: return "HPDF_SEEK_END";
            default: return "";
        }
    }

    std::string _HPDF_WhenceMode(int64_t i, const std::string &strip) {
        std::string s = _HPDF_WhenceMode(i);
        if (s.empty())
            s = "(_HPDF_WhenceMode)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _HPDF_WhenceMode() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringify_HPDF_WhenceMode(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_HPDF_WhenceMode(i);
        if (retval.empty()) {
            retval = "(_HPDF_WhenceMode)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_HPDF_WhenceMode::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_HPDF_WhenceMode() {
        return stringify::_HPDF_WhenceMode();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/libharu-2.1.0/include/hpdf_encoder.h line 69
namespace stringify {
    const char* _HPDF_EncodingType(int64_t i) {
        switch (i) {
            case 0L: return "HPDF_STANDARD_ENCODING";
            case 1L: return "HPDF_MAC_ROMAN_ENCODING";
            case 2L: return "HPDF_WIN_ANSI_ENCODING";
            case 3L: return "HPDF_FONT_SPECIFIC";
            case 4L: return "HPDF_ENCODING_EOF";
            default: return "";
        }
    }

    std::string _HPDF_EncodingType(int64_t i, const std::string &strip) {
        std::string s = _HPDF_EncodingType(i);
        if (s.empty())
            s = "(_HPDF_EncodingType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _HPDF_EncodingType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringify_HPDF_EncodingType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_HPDF_EncodingType(i);
        if (retval.empty()) {
            retval = "(_HPDF_EncodingType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_HPDF_EncodingType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_HPDF_EncodingType() {
        return stringify::_HPDF_EncodingType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/libharu-2.1.0/include/hpdf_encoder.h line 130
namespace stringify {
    const char* _HPDF_BaseEncodings(int64_t i) {
        switch (i) {
            case 0L: return "HPDF_BASE_ENCODING_STANDARD";
            case 1L: return "HPDF_BASE_ENCODING_WIN_ANSI";
            case 2L: return "HPDF_BASE_ENCODING_MAC_ROMAN";
            case 3L: return "HPDF_BASE_ENCODING_FONT_SPECIFIC";
            case 4L: return "HPDF_BASE_ENCODING_EOF";
            default: return "";
        }
    }

    std::string _HPDF_BaseEncodings(int64_t i, const std::string &strip) {
        std::string s = _HPDF_BaseEncodings(i);
        if (s.empty())
            s = "(_HPDF_BaseEncodings)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _HPDF_BaseEncodings() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringify_HPDF_BaseEncodings(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_HPDF_BaseEncodings(i);
        if (retval.empty()) {
            retval = "(_HPDF_BaseEncodings)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_HPDF_BaseEncodings::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_HPDF_BaseEncodings() {
        return stringify::_HPDF_BaseEncodings();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/abstractMemoryObject/memory_object_impl.h line 84
namespace stringify { namespace AbstractMemoryObject { namespace IndexSet {
    const char* Index_type(int64_t i) {
        switch (i) {
            case 0L: return "Integer_type";
            case 1L: return "Unknown_type";
            default: return "";
        }
    }

    std::string Index_type(int64_t i, const std::string &strip) {
        std::string s = Index_type(i);
        if (s.empty())
            s = "(AbstractMemoryObject::IndexSet::Index_type)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Index_type() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyAbstractMemoryObjectIndexSetIndex_type(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::AbstractMemoryObject::IndexSet::Index_type(i);
        if (retval.empty()) {
            retval = "(AbstractMemoryObject::IndexSet::Index_type)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "AbstractMemoryObject::IndexSet::Index_type::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyAbstractMemoryObjectIndexSetIndex_type() {
        return stringify::AbstractMemoryObject::IndexSet::Index_type();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programTransformation/extractFunctionArgumentsNormalization/functionEvaluationOrderTraversal.h line 40
namespace stringify { namespace FunctionCallInfo {
    const char* InsertionMode(int64_t i) {
        switch (i) {
            case 0L: return "INSERT_BEFORE";
            case 1L: return "APPEND_SCOPE";
            case 2L: return "INVALID";
            default: return "";
        }
    }

    std::string InsertionMode(int64_t i, const std::string &strip) {
        std::string s = InsertionMode(i);
        if (s.empty())
            s = "(FunctionCallInfo::InsertionMode)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& InsertionMode() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyFunctionCallInfoInsertionMode(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::FunctionCallInfo::InsertionMode(i);
        if (retval.empty()) {
            retval = "(FunctionCallInfo::InsertionMode)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "FunctionCallInfo::InsertionMode::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyFunctionCallInfoInsertionMode() {
        return stringify::FunctionCallInfo::InsertionMode();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programTransformation/ompLowering/omp_lowering.h line 37
namespace stringify { namespace OmpSupport {
    const char* omp_rtl_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_gomp";
            case 1L: return "e_omni";
            case 2L: return "e_last_rtl";
            default: return "";
        }
    }

    std::string omp_rtl_enum(int64_t i, const std::string &strip) {
        std::string s = omp_rtl_enum(i);
        if (s.empty())
            s = "(OmpSupport::omp_rtl_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& omp_rtl_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyOmpSupport_omp_rtl_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::OmpSupport::omp_rtl_enum(i);
        if (retval.empty()) {
            retval = "(OmpSupport::omp_rtl_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "OmpSupport::omp_rtl_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyOmpSupport_omp_rtl_enum() {
        return stringify::OmpSupport::omp_rtl_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programTransformation/ompLowering/rex_llvm.h line 2
namespace stringify {
    const char* tgt_map_type(int64_t i) {
        switch (i) {
            case -281474976710656L: return "OMP_TGT_MAPTYPE_MEMBER_OF";
            case 0L: return "OMP_TGT_MAPTYPE_NONE";
            case 1L: return "OMP_TGT_MAPTYPE_TO";
            case 2L: return "OMP_TGT_MAPTYPE_FROM";
            case 4L: return "OMP_TGT_MAPTYPE_ALWAYS";
            case 8L: return "OMP_TGT_MAPTYPE_DELETE";
            case 16L: return "OMP_TGT_MAPTYPE_PTR_AND_OBJ";
            case 32L: return "OMP_TGT_MAPTYPE_TARGET_PARAM";
            case 64L: return "OMP_TGT_MAPTYPE_RETURN_PARAM";
            case 128L: return "OMP_TGT_MAPTYPE_PRIVATE";
            case 256L: return "OMP_TGT_MAPTYPE_LITERAL";
            case 512L: return "OMP_TGT_MAPTYPE_IMPLICIT";
            case 1024L: return "OMP_TGT_MAPTYPE_CLOSE";
            case 4096L: return "OMP_TGT_MAPTYPE_PRESENT";
            case 17592186044416L: return "OMP_TGT_MAPTYPE_NON_CONTIG";
            default: return "";
        }
    }

    std::string tgt_map_type(int64_t i, const std::string &strip) {
        std::string s = tgt_map_type(i);
        if (s.empty())
            s = "(tgt_map_type)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& tgt_map_type() {
        static const int64_t values[] = {
            -281474976710656L,
            0L,
            1L,
            2L,
            4L,
            8L,
            16L,
            32L,
            64L,
            128L,
            256L,
            512L,
            1024L,
            4096L,
            17592186044416L
        };
        static const std::vector<int64_t> retval(values, values + 15);
        return retval;
    }

}

namespace Rose {
    std::string stringify_tgt_map_type(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::tgt_map_type(i);
        if (retval.empty()) {
            retval = "(tgt_map_type)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "tgt_map_type::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_tgt_map_type() {
        return stringify::tgt_map_type();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programTransformation/ompLowering/rex_llvm.h line 35
namespace stringify {
    const char* kmp_sched_t(int64_t i) {
        switch (i) {
            case 33L: return "kmp_sched_unordered_first";
            case 34L: return "kmp_sched_static_nochunk";
            case 35L: return "kmp_sched_dynamic";
            case 36L: return "kmp_sched_guided";
            case 37L: return "kmp_sched_runtime";
            case 38L: return "kmp_sched_unordered_last";
            case 45L: return "kmp_sched_static_balanced_chunk";
            case 65L: return "kmp_sched_static_ordered";
            case 66L: return "kmp_sched_static_nochunk_ordered";
            case 67L: return "kmp_sched_dynamic_ordered";
            case 68L: return "kmp_sched_guided_ordered";
            case 69L: return "kmp_sched_runtime_ordered";
            case 70L: return "kmp_sched_ordered_last";
            case 91L: return "kmp_sched_distribute_first";
            case 92L: return "kmp_sched_distr_static_nochunk";
            case 93L: return "kmp_sched_distribute_last";
            case 536870912L: return "kmp_sched_modifier_monotonic";
            case 1073741824L: return "kmp_sched_modifier_nonmonotonic";
            default: return "";
        }
    }

    std::string kmp_sched_t(int64_t i, const std::string &strip) {
        std::string s = kmp_sched_t(i);
        if (s.empty())
            s = "(kmp_sched_t)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& kmp_sched_t() {
        static const int64_t values[] = {
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            45L,
            65L,
            66L,
            67L,
            68L,
            69L,
            70L,
            91L,
            92L,
            93L,
            536870912L,
            1073741824L
        };
        static const std::vector<int64_t> retval(values, values + 18);
        return retval;
    }

}

namespace Rose {
    std::string stringify_kmp_sched_t(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::kmp_sched_t(i);
        if (retval.empty()) {
            retval = "(kmp_sched_t)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "kmp_sched_t::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_kmp_sched_t() {
        return stringify::kmp_sched_t();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programTransformation/ompLowering/omp_simd.h line 3
namespace stringify {
    const char* SimdType(int64_t i) {
        switch (i) {
            case 0L: return "Nothing";
            case 1L: return "Addr3";
            case 2L: return "Intel_AVX512";
            case 3L: return "Arm_SVE2";
            default: return "";
        }
    }

    std::string SimdType(int64_t i, const std::string &strip) {
        std::string s = SimdType(i);
        if (s.empty())
            s = "(SimdType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& SimdType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifySimdType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SimdType(i);
        if (retval.empty()) {
            retval = "(SimdType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SimdType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySimdType() {
        return stringify::SimdType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programTransformation/ompLowering/omp_simd.h line 10
namespace stringify {
    const char* OpType(int64_t i) {
        switch (i) {
            case 0L: return "None";
            case 1L: return "Load";
            case 2L: return "Broadcast";
            case 3L: return "BroadcastZero";
            case 4L: return "Gather";
            case 5L: return "Scatter";
            case 6L: return "ScalarStore";
            case 7L: return "Store";
            case 8L: return "HAdd";
            case 9L: return "Add";
            case 10L: return "Sub";
            case 11L: return "Mul";
            case 12L: return "Div";
            case 13L: return "Extract";
            default: return "";
        }
    }

    std::string OpType(int64_t i, const std::string &strip) {
        std::string s = OpType(i);
        if (s.empty())
            s = "(OpType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& OpType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L
        };
        static const std::vector<int64_t> retval(values, values + 14);
        return retval;
    }

}

namespace Rose {
    std::string stringifyOpType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::OpType(i);
        if (retval.empty()) {
            retval = "(OpType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "OpType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyOpType() {
        return stringify::OpType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programTransformation/ompLowering/xomp.c line 63
namespace stringify {
    const char* omp_rtl_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_undefined";
            case 1L: return "e_gomp";
            case 2L: return "e_omni";
            case 3L: return "e_last_rtl";
            default: return "";
        }
    }

    std::string omp_rtl_enum(int64_t i, const std::string &strip) {
        std::string s = omp_rtl_enum(i);
        if (s.empty())
            s = "(omp_rtl_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& omp_rtl_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringify_omp_rtl_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::omp_rtl_enum(i);
        if (retval.empty()) {
            retval = "(omp_rtl_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "omp_rtl_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_omp_rtl_enum() {
        return stringify::omp_rtl_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programTransformation/implicitCodeGeneration/defaultFunctionGenerator.C line 17
namespace stringify {
    const char* defaultEnumFunctionType(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_constructor";
            case 2L: return "e_destructor";
            case 3L: return "e_copy_constructor";
            case 4L: return "e_assignment_operator";
            case 5L: return "e_last_type";
            default: return "";
        }
    }

    std::string defaultEnumFunctionType(int64_t i, const std::string &strip) {
        std::string s = defaultEnumFunctionType(i);
        if (s.empty())
            s = "(defaultEnumFunctionType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& defaultEnumFunctionType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}

namespace Rose {
    std::string stringify_defaultEnumFunctionType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::defaultEnumFunctionType(i);
        if (retval.empty()) {
            retval = "(defaultEnumFunctionType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "defaultEnumFunctionType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_defaultEnumFunctionType() {
        return stringify::defaultEnumFunctionType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astRewriteMechanism/rewrite.h line 52
namespace stringify { namespace MidLevelCollectionTypedefs {
    const char* ScopeIdentifier_Enum(int64_t i) {
        switch (i) {
            case 0L: return "unknownScope";
            case 1L: return "StatementScope";
            case 2L: return "SurroundingScope";
            case 3L: return "Preamble";
            case 4L: return "LAST_SCOPE_TAG";
            default: return "";
        }
    }

    std::string ScopeIdentifier_Enum(int64_t i, const std::string &strip) {
        std::string s = ScopeIdentifier_Enum(i);
        if (s.empty())
            s = "(MidLevelCollectionTypedefs::ScopeIdentifier_Enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ScopeIdentifier_Enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyMidLevelCollectionTypedefsScopeIdentifier_Enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::MidLevelCollectionTypedefs::ScopeIdentifier_Enum(i);
        if (retval.empty()) {
            retval = "(MidLevelCollectionTypedefs::ScopeIdentifier_Enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "MidLevelCollectionTypedefs::ScopeIdentifier_Enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyMidLevelCollectionTypedefsScopeIdentifier_Enum() {
        return stringify::MidLevelCollectionTypedefs::ScopeIdentifier_Enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astRewriteMechanism/rewrite.h line 66
namespace stringify { namespace MidLevelCollectionTypedefs {
    const char* PlacementPosition_Enum(int64_t i) {
        switch (i) {
            case 0L: return "unknownPositionInScope";
            case 1L: return "PreamblePositionInScope";
            case 2L: return "TopOfCurrentScope";
            case 3L: return "BeforeCurrentPosition";
            case 4L: return "ReplaceCurrentPosition";
            case 5L: return "AfterCurrentPosition";
            case 6L: return "BottomOfCurrentScope";
            case 7L: return "LAST_PLACEMENT_TAG";
            default: return "";
        }
    }

    std::string PlacementPosition_Enum(int64_t i, const std::string &strip) {
        std::string s = PlacementPosition_Enum(i);
        if (s.empty())
            s = "(MidLevelCollectionTypedefs::PlacementPosition_Enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& PlacementPosition_Enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyMidLevelCollectionTypedefsPlacementPosition_Enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::MidLevelCollectionTypedefs::PlacementPosition_Enum(i);
        if (retval.empty()) {
            retval = "(MidLevelCollectionTypedefs::PlacementPosition_Enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "MidLevelCollectionTypedefs::PlacementPosition_Enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyMidLevelCollectionTypedefsPlacementPosition_Enum() {
        return stringify::MidLevelCollectionTypedefs::PlacementPosition_Enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astRewriteMechanism/rewrite.h line 79
namespace stringify { namespace MidLevelCollectionTypedefs {
    const char* IntermediateFileStringPosition_Enum(int64_t i) {
        switch (i) {
            case 0L: return "unknownIntermediatePositionInScope";
            case 1L: return "GlobalScopePreamble";
            case 2L: return "CurrentLocationTopOfScope";
            case 3L: return "CurrentLocationAfter";
            case 4L: return "LAST_INTERMEDIATE_SOURCE_CODE_PLACEMENT_TAG";
            case 6L: return "CurrentLocationBottomOfScope";
            default: return "";
        }
    }

    std::string IntermediateFileStringPosition_Enum(int64_t i, const std::string &strip) {
        std::string s = IntermediateFileStringPosition_Enum(i);
        if (s.empty())
            s = "(MidLevelCollectionTypedefs::IntermediateFileStringPosition_Enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& IntermediateFileStringPosition_Enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyMidLevelCollectionTypedefsIntermediateFileStringPosition_Enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::MidLevelCollectionTypedefs::IntermediateFileStringPosition_Enum(i);
        if (retval.empty()) {
            retval = "(MidLevelCollectionTypedefs::IntermediateFileStringPosition_Enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "MidLevelCollectionTypedefs::IntermediateFileStringPosition_Enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyMidLevelCollectionTypedefsIntermediateFileStringPosition_Enum() {
        return stringify::MidLevelCollectionTypedefs::IntermediateFileStringPosition_Enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astRewriteMechanism/rewrite.h line 141
namespace stringify { namespace HighLevelCollectionTypedefs {
    const char* ScopeIdentifier_Enum(int64_t i) {
        switch (i) {
            case 0L: return "unknownScope";
            case 1L: return "SurroundingScope";
            case 2L: return "ParentScope";
            case 3L: return "NestedLoopScope";
            case 4L: return "NestedConditionalScope";
            case 5L: return "FunctionScope";
            case 6L: return "FileScope";
            case 7L: return "GlobalScope";
            case 8L: return "Preamble";
            case 9L: return "LAST_SCOPE_TAG";
            default: return "";
        }
    }

    std::string ScopeIdentifier_Enum(int64_t i, const std::string &strip) {
        std::string s = ScopeIdentifier_Enum(i);
        if (s.empty())
            s = "(HighLevelCollectionTypedefs::ScopeIdentifier_Enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ScopeIdentifier_Enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L
        };
        static const std::vector<int64_t> retval(values, values + 10);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyHighLevelCollectionTypedefsScopeIdentifier_Enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::HighLevelCollectionTypedefs::ScopeIdentifier_Enum(i);
        if (retval.empty()) {
            retval = "(HighLevelCollectionTypedefs::ScopeIdentifier_Enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "HighLevelCollectionTypedefs::ScopeIdentifier_Enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyHighLevelCollectionTypedefsScopeIdentifier_Enum() {
        return stringify::HighLevelCollectionTypedefs::ScopeIdentifier_Enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astRewriteMechanism/rewrite.h line 162
namespace stringify { namespace HighLevelCollectionTypedefs {
    const char* PlacementPosition_Enum(int64_t i) {
        switch (i) {
            case 0L: return "unknownPositionInScope";
            case 1L: return "PreamblePositionInScope";
            case 2L: return "TopOfScope";
            case 3L: return "TopOfIncludeRegion";
            case 4L: return "BottomOfIncludeRegion";
            case 5L: return "BeforeCurrentPosition";
            case 6L: return "ReplaceCurrentPosition";
            case 7L: return "AfterCurrentPosition";
            case 8L: return "BottomOfScope";
            case 9L: return "LAST_PLACEMENT_TAG";
            default: return "";
        }
    }

    std::string PlacementPosition_Enum(int64_t i, const std::string &strip) {
        std::string s = PlacementPosition_Enum(i);
        if (s.empty())
            s = "(HighLevelCollectionTypedefs::PlacementPosition_Enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& PlacementPosition_Enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L
        };
        static const std::vector<int64_t> retval(values, values + 10);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyHighLevelCollectionTypedefsPlacementPosition_Enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::HighLevelCollectionTypedefs::PlacementPosition_Enum(i);
        if (retval.empty()) {
            retval = "(HighLevelCollectionTypedefs::PlacementPosition_Enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "HighLevelCollectionTypedefs::PlacementPosition_Enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyHighLevelCollectionTypedefsPlacementPosition_Enum() {
        return stringify::HighLevelCollectionTypedefs::PlacementPosition_Enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astRewriteMechanism/rewrite.h line 176
namespace stringify { namespace HighLevelCollectionTypedefs {
    const char* IntermediateFileStringPosition_Enum(int64_t i) {
        switch (i) {
            case 0L: return "unknownIntermediatePositionInScope";
            case 1L: return "GlobalScopePreamble";
            case 2L: return "GlobalScopeTopOfScope";
            case 3L: return "GlobalScopeTopOfIncludeRegion";
            case 4L: return "GlobalScopeBottomOfIncludeRegion";
            case 5L: return "GlobalScopeBeforeCurrentPosition";
            case 6L: return "GlobalScopeReplaceCurrentPosition";
            case 7L: return "FunctionScopePreamble";
            case 8L: return "FunctionScopeTopOfScope";
            case 9L: return "FunctionScopeBeforeCurrentPosition";
            case 10L: return "FunctionScopeReplaceCurrentPosition";
            case 11L: return "FunctionScopeAfterCurrentPosition";
            case 12L: return "FunctionScopeBottomOfScope";
            case 13L: return "GlobalScopeAfterCurrentPosition";
            case 14L: return "GlobalScopeBottomOfScope";
            case 15L: return "LAST_INTERMEDIATE_SOURCE_CODE_PLACEMENT_TAG";
            default: return "";
        }
    }

    std::string IntermediateFileStringPosition_Enum(int64_t i, const std::string &strip) {
        std::string s = IntermediateFileStringPosition_Enum(i);
        if (s.empty())
            s = "(HighLevelCollectionTypedefs::IntermediateFileStringPosition_Enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& IntermediateFileStringPosition_Enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L
        };
        static const std::vector<int64_t> retval(values, values + 16);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyHighLevelCollectionTypedefsIntermediateFileStringPosition_Enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::HighLevelCollectionTypedefs::IntermediateFileStringPosition_Enum(i);
        if (retval.empty()) {
            retval = "(HighLevelCollectionTypedefs::IntermediateFileStringPosition_Enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "HighLevelCollectionTypedefs::IntermediateFileStringPosition_Enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyHighLevelCollectionTypedefsIntermediateFileStringPosition_Enum() {
        return stringify::HighLevelCollectionTypedefs::IntermediateFileStringPosition_Enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astProcessing/AstAttributeMechanism.C line 21
namespace stringify {
    const char* WarningType(int64_t i) {
        switch (i) {
            case 0L: return "HAS_MEMORY_LEAK";
            case 1L: return "HAS_UNKNOWN_OWNERSHIP";
            case 2L: return "HAS_NULL_COPY";
            case 3L: return "HAS_SELF_COPY";
            case 4L: return "HAS_NO_CLASS_NAME";
            default: return "";
        }
    }

    std::string WarningType(int64_t i, const std::string &strip) {
        std::string s = WarningType(i);
        if (s.empty())
            s = "(WarningType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& WarningType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringifyWarningType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::WarningType(i);
        if (retval.empty()) {
            retval = "(WarningType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "WarningType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyWarningType() {
        return stringify::WarningType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astProcessing/AstAttributeMechanism.h line 41
namespace stringify { namespace AstAttribute {
    const char* OwnershipPolicy(int64_t i) {
        switch (i) {
            case 0L: return "CONTAINER_OWNERSHIP";
            case 1L: return "NO_OWNERSHIP";
            case 2L: return "CUSTOM_OWNERSHIP";
            case 3L: return "UNKNOWN_OWNERSHIP";
            default: return "";
        }
    }

    std::string OwnershipPolicy(int64_t i, const std::string &strip) {
        std::string s = OwnershipPolicy(i);
        if (s.empty())
            s = "(AstAttribute::OwnershipPolicy)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& OwnershipPolicy() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyAstAttributeOwnershipPolicy(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::AstAttribute::OwnershipPolicy(i);
        if (retval.empty()) {
            retval = "(AstAttribute::OwnershipPolicy)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "AstAttribute::OwnershipPolicy::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyAstAttributeOwnershipPolicy() {
        return stringify::AstAttribute::OwnershipPolicy();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/systemDependenceGraph/SDG.h line 21
namespace stringify { namespace SDG { namespace SDGNode {
    const char* NodeType(int64_t i) {
        switch (i) {
            case 0L: return "Entry";
            case 1L: return "ASTNode";
            case 2L: return "FunctionCall";
            case 3L: return "ActualIn";
            case 4L: return "ActualOut";
            case 5L: return "FormalIn";
            case 6L: return "FormalOut";
            default: return "";
        }
    }

    std::string NodeType(int64_t i, const std::string &strip) {
        std::string s = NodeType(i);
        if (s.empty())
            s = "(SDG::SDGNode::NodeType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& NodeType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifySDG_SDGNodeNodeType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SDG::SDGNode::NodeType(i);
        if (retval.empty()) {
            retval = "(SDG::SDGNode::NodeType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SDG::SDGNode::NodeType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySDG_SDGNodeNodeType() {
        return stringify::SDG::SDGNode::NodeType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/systemDependenceGraph/SDG.h line 48
namespace stringify { namespace SDG { namespace SDGEdge {
    const char* EdgeType(int64_t i) {
        switch (i) {
            case 0L: return "ControlDependence";
            case 1L: return "DataDependence";
            case 2L: return "ParameterIn";
            case 3L: return "ParameterOut";
            case 4L: return "Call";
            case 5L: return "Summary";
            default: return "";
        }
    }

    std::string EdgeType(int64_t i, const std::string &strip) {
        std::string s = EdgeType(i);
        if (s.empty())
            s = "(SDG::SDGEdge::EdgeType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& EdgeType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifySDG_SDGEdgeEdgeType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SDG::SDGEdge::EdgeType(i);
        if (retval.empty()) {
            retval = "(SDG::SDGEdge::EdgeType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SDG::SDGEdge::EdgeType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySDG_SDGEdgeEdgeType() {
        return stringify::SDG::SDGEdge::EdgeType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/systemDependenceGraph/SDG.h line 58
namespace stringify { namespace SDG { namespace SDGEdge {
    const char* ControlDependenceType(int64_t i) {
        switch (i) {
            case 0L: return "cdTrue";
            case 1L: return "cdFalse";
            case 2L: return "cdCase";
            case 3L: return "cdDefault";
            default: return "";
        }
    }

    std::string ControlDependenceType(int64_t i, const std::string &strip) {
        std::string s = ControlDependenceType(i);
        if (s.empty())
            s = "(SDG::SDGEdge::ControlDependenceType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ControlDependenceType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifySDG_SDGEdgeControlDependenceType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SDG::SDGEdge::ControlDependenceType(i);
        if (retval.empty()) {
            retval = "(SDG::SDGEdge::ControlDependenceType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SDG::SDGEdge::ControlDependenceType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySDG_SDGEdgeControlDependenceType() {
        return stringify::SDG::SDGEdge::ControlDependenceType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/systemDependenceGraph/PDG.h line 32
namespace stringify { namespace SDG { namespace PDGEdge {
    const char* EdgeType(int64_t i) {
        switch (i) {
            case 0L: return "ControlDependence";
            case 1L: return "DataDependence";
            default: return "";
        }
    }

    std::string EdgeType(int64_t i, const std::string &strip) {
        std::string s = EdgeType(i);
        if (s.empty())
            s = "(SDG::PDGEdge::EdgeType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& EdgeType() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifySDG_PDGEdgeEdgeType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SDG::PDGEdge::EdgeType(i);
        if (retval.empty()) {
            retval = "(SDG::PDGEdge::EdgeType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SDG::PDGEdge::EdgeType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySDG_PDGEdgeEdgeType() {
        return stringify::SDG::PDGEdge::EdgeType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/genericDataflow/lattice/ConstrGraph.h line 45
namespace stringify { namespace ConstrGraph {
    const char* levels(int64_t i) {
        switch (i) {
            case 0L: return "uninitialized";
            case 1L: return "bottom";
            case 2L: return "constrKnown";
            case 3L: return "top";
            default: return "";
        }
    }

    std::string levels(int64_t i, const std::string &strip) {
        std::string s = levels(i);
        if (s.empty())
            s = "(ConstrGraph::levels)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& levels() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyConstrGraph_levels(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ConstrGraph::levels(i);
        if (retval.empty()) {
            retval = "(ConstrGraph::levels)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ConstrGraph::levels::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyConstrGraph_levels() {
        return stringify::ConstrGraph::levels();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/genericDataflow/simpleAnalyses/taintAnalysis.h line 63
namespace stringify { namespace TaintLattice {
    const char* Vertex(int64_t i) {
        switch (i) {
            case 0L: return "VERTEX_BOTTOM";
            case 1L: return "VERTEX_UNTAINTED";
            case 2L: return "VERTEX_TAINTED";
            default: return "";
        }
    }

    std::string Vertex(int64_t i, const std::string &strip) {
        std::string s = Vertex(i);
        if (s.empty())
            s = "(TaintLattice::Vertex)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Vertex() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyTaintLatticeVertex(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::TaintLattice::Vertex(i);
        if (retval.empty()) {
            retval = "(TaintLattice::Vertex)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "TaintLattice::Vertex::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyTaintLatticeVertex() {
        return stringify::TaintLattice::Vertex();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/genericDataflow/cfgUtils/CallGraphTraverse.h line 124
namespace stringify { namespace CGFunction { namespace iterator {
    const char* direction(int64_t i) {
        switch (i) {
            case 0L: return "fw";
            case 1L: return "bw";
            default: return "";
        }
    }

    std::string direction(int64_t i, const std::string &strip) {
        std::string s = direction(i);
        if (s.empty())
            s = "(CGFunction::iterator::direction)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& direction() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyCGFunction_iterator_direction(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::CGFunction::iterator::direction(i);
        if (retval.empty()) {
            retval = "(CGFunction::iterator::direction)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "CGFunction::iterator::direction::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyCGFunction_iterator_direction() {
        return stringify::CGFunction::iterator::direction();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/dominatorTreesAndDominanceFrontiers/DominatorTree.h line 50
namespace stringify { namespace DominatorTreesAndDominanceFrontiers { namespace DominatorTree {
    const char* Direction(int64_t i) {
        switch (i) {
            case 0L: return "PRE";
            case 1L: return "POST";
            default: return "";
        }
    }

    std::string Direction(int64_t i, const std::string &strip) {
        std::string s = Direction(i);
        if (s.empty())
            s = "(DominatorTreesAndDominanceFrontiers::DominatorTree::Direction)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Direction() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyDominatorTreesAndDominanceFrontiersDominatorTreeDirection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::DominatorTreesAndDominanceFrontiers::DominatorTree::Direction(i);
        if (retval.empty()) {
            retval = "(DominatorTreesAndDominanceFrontiers::DominatorTree::Direction)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "DominatorTreesAndDominanceFrontiers::DominatorTree::Direction::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyDominatorTreesAndDominanceFrontiersDominatorTreeDirection() {
        return stringify::DominatorTreesAndDominanceFrontiers::DominatorTree::Direction();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/ssaUnfilteredCfg/reachingDefUnfilteredCfg.h line 19
namespace stringify { namespace ssa_unfiltered_cfg { namespace ReachingDef {
    const char* Type(int64_t i) {
        switch (i) {
            case 0L: return "PHI_FUNCTION";
            case 1L: return "ORIGINAL_DEF";
            case 2L: return "EXPANDED_DEF";
            case 3L: return "EXTERNAL_DEF";
            default: return "";
        }
    }

    std::string Type(int64_t i, const std::string &strip) {
        std::string s = Type(i);
        if (s.empty())
            s = "(ssa_unfiltered_cfg::ReachingDef::Type)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Type() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}

namespace Rose {
    std::string stringify_ssa_unfiltered_cfgReachingDefType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ssa_unfiltered_cfg::ReachingDef::Type(i);
        if (retval.empty()) {
            retval = "(ssa_unfiltered_cfg::ReachingDef::Type)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ssa_unfiltered_cfg::ReachingDef::Type::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_ssa_unfiltered_cfgReachingDefType() {
        return stringify::ssa_unfiltered_cfg::ReachingDef::Type();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/OpenAnalysis/Interface/IRInterface.h line 163
namespace stringify {
    const char* IRProcType(int64_t i) {
        switch (i) {
            case 0L: return "ProcType_PGM";
            case 1L: return "ProcType_SUB";
            case 2L: return "ProcType_FUNC";
            case 3L: return "ProcType_BDATA";
            case 4L: return "ProcType_ILLEGAL";
            default: return "";
        }
    }

    std::string IRProcType(int64_t i, const std::string &strip) {
        std::string s = IRProcType(i);
        if (s.empty())
            s = "(IRProcType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& IRProcType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringifyIRProcType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::IRProcType(i);
        if (retval.empty()) {
            retval = "(IRProcType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "IRProcType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyIRProcType() {
        return stringify::IRProcType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/OpenAnalysis/Interface/IRInterface.h line 173
namespace stringify {
    const char* IRStmtType(int64_t i) {
        switch (i) {
            case 0L: return "SIMPLE";
            case 1L: return "COMPOUND";
            case 2L: return "LOOP";
            case 3L: return "END_TESTED_LOOP";
            case 4L: return "STRUCT_TWOWAY_CONDITIONAL";
            case 5L: return "STRUCT_MULTIWAY_CONDITIONAL";
            case 6L: return "USTRUCT_TWOWAY_CONDITIONAL_T";
            case 7L: return "USTRUCT_TWOWAY_CONDITIONAL_F";
            case 8L: return "USTRUCT_MULTIWAY_CONDITIONAL";
            case 9L: return "RETURN";
            case 10L: return "BREAK";
            case 11L: return "LOOP_CONTINUE";
            case 12L: return "ALTERNATE_PROC_ENTRY";
            case 13L: return "UNCONDITIONAL_JUMP";
            case 14L: return "UNCONDITIONAL_JUMP_I";
            case 15L: return "NONE";
            default: return "";
        }
    }

    std::string IRStmtType(int64_t i, const std::string &strip) {
        std::string s = IRStmtType(i);
        if (s.empty())
            s = "(IRStmtType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& IRStmtType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L
        };
        static const std::vector<int64_t> retval(values, values + 16);
        return retval;
    }

}

namespace Rose {
    std::string stringifyIRStmtType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::IRStmtType(i);
        if (retval.empty()) {
            retval = "(IRStmtType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "IRStmtType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyIRStmtType() {
        return stringify::IRStmtType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/OpenAnalysis/CallGraph/CallGraph.h line 73
namespace stringify { namespace CallGraph {
    const char* EdgeType(int64_t i) {
        switch (i) {
            case 0L: return "NORMAL_EDGE";
            default: return "";
        }
    }

    std::string EdgeType(int64_t i, const std::string &strip) {
        std::string s = EdgeType(i);
        if (s.empty())
            s = "(CallGraph::EdgeType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& EdgeType() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyCallGraphEdgeType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::CallGraph::EdgeType(i);
        if (retval.empty()) {
            retval = "(CallGraph::EdgeType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "CallGraph::EdgeType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyCallGraphEdgeType() {
        return stringify::CallGraph::EdgeType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/OpenAnalysis/CFG/CFG.h line 83
namespace stringify { namespace CFG {
    const char* EdgeType(int64_t i) {
        switch (i) {
            case 0L: return "TRUE_EDGE";
            case 1L: return "FALLTHROUGH_EDGE";
            case 2L: return "FALSE_EDGE";
            case 3L: return "BACK_EDGE";
            case 4L: return "MULTIWAY_EDGE";
            case 5L: return "BREAK_EDGE";
            case 6L: return "CONTINUE_EDGE";
            case 7L: return "RETURN_EDGE";
            default: return "";
        }
    }

    std::string EdgeType(int64_t i, const std::string &strip) {
        std::string s = EdgeType(i);
        if (s.empty())
            s = "(CFG::EdgeType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& EdgeType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyCFG_EdgeType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::CFG::EdgeType(i);
        if (retval.empty()) {
            retval = "(CFG::EdgeType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "CFG::EdgeType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyCFG_EdgeType() {
        return stringify::CFG::EdgeType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/OpenAnalysis/CFG/TarjanIntervals.h line 65
namespace stringify {
    const char* RITarjType(int64_t i) {
        switch (i) {
            case 0L: return "RI_TARJ_NOTHING";
            case 1L: return "RI_TARJ_ACYCLIC";
            case 2L: return "RI_TARJ_INTERVAL";
            case 3L: return "RI_TARJ_IRREDUCIBLE";
            default: return "";
        }
    }

    std::string RITarjType(int64_t i, const std::string &strip) {
        std::string s = RITarjType(i);
        if (s.empty())
            s = "(RITarjType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& RITarjType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyRITarjType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::RITarjType(i);
        if (retval.empty()) {
            retval = "(RITarjType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "RITarjType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyRITarjType() {
        return stringify::RITarjType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/OpenAnalysis/CFG/TarjanIntervals.h line 67
namespace stringify {
    const char* RITarjEdgeType(int64_t i) {
        switch (i) {
            case 0L: return "RI_TARJ_NORMAL";
            case 1L: return "RI_TARJ_LOOP_ENTRY";
            case 2L: return "RI_TARJ_IRRED_ENTRY";
            case 3L: return "RI_TARJ_ITERATE";
            default: return "";
        }
    }

    std::string RITarjEdgeType(int64_t i, const std::string &strip) {
        std::string s = RITarjEdgeType(i);
        if (s.empty())
            s = "(RITarjEdgeType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& RITarjEdgeType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyRITarjEdgeType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::RITarjEdgeType(i);
        if (retval.empty()) {
            retval = "(RITarjEdgeType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "RITarjEdgeType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyRITarjEdgeType() {
        return stringify::RITarjEdgeType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/OpenAnalysis/CFG/RIFG.h line 63
namespace stringify { namespace RIFG {
    const char* EdgeDirection(int64_t i) {
        switch (i) {
            case 0L: return "ED_INCOMING";
            case 1L: return "ED_OUTGOING";
            default: return "";
        }
    }

    std::string EdgeDirection(int64_t i, const std::string &strip) {
        std::string s = EdgeDirection(i);
        if (s.empty())
            s = "(RIFG::EdgeDirection)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& EdgeDirection() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyRIFG_EdgeDirection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::RIFG::EdgeDirection(i);
        if (retval.empty()) {
            retval = "(RIFG::EdgeDirection)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "RIFG::EdgeDirection::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyRIFG_EdgeDirection() {
        return stringify::RIFG::EdgeDirection();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/OpenAnalysis/CFG/RIFG.h line 64
namespace stringify { namespace RIFG {
    const char* ForwardBackward(int64_t i) {
        switch (i) {
            case 0L: return "FORWARD";
            case 1L: return "BACKWARD";
            default: return "";
        }
    }

    std::string ForwardBackward(int64_t i, const std::string &strip) {
        std::string s = ForwardBackward(i);
        if (s.empty())
            s = "(RIFG::ForwardBackward)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ForwardBackward() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyRIFG_ForwardBackward(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::RIFG::ForwardBackward(i);
        if (retval.empty()) {
            retval = "(RIFG::ForwardBackward)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "RIFG::ForwardBackward::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyRIFG_ForwardBackward() {
        return stringify::RIFG::ForwardBackward();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/OpenAnalysis/Utils/BaseGraph.h line 261
namespace stringify { namespace BaseGraph { namespace BiDirNodesIterator {
    const char* dirType(int64_t i) {
        switch (i) {
            case 0L: return "Forward";
            case 1L: return "Reverse";
            default: return "";
        }
    }

    std::string dirType(int64_t i, const std::string &strip) {
        std::string s = dirType(i);
        if (s.empty())
            s = "(BaseGraph::BiDirNodesIterator::dirType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& dirType() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBaseGraphBiDirNodesIterator_dirType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::BaseGraph::BiDirNodesIterator::dirType(i);
        if (retval.empty()) {
            retval = "(BaseGraph::BiDirNodesIterator::dirType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "BaseGraph::BiDirNodesIterator::dirType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBaseGraphBiDirNodesIterator_dirType() {
        return stringify::BaseGraph::BiDirNodesIterator::dirType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/dominanceAnalysis/DominatorTree.h line 13
namespace stringify { namespace DominatorTreesAndDominanceFrontiers {
    const char* Dir_ection(int64_t i) {
        switch (i) {
            case 0L: return "PRE_DOMINATOR";
            case 1L: return "POST_DOMINATOR";
            default: return "";
        }
    }

    std::string Dir_ection(int64_t i, const std::string &strip) {
        std::string s = Dir_ection(i);
        if (s.empty())
            s = "(DominatorTreesAndDominanceFrontiers::Dir_ection)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Dir_ection() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyDominatorTreesAndDominanceFrontiersDir_ection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::DominatorTreesAndDominanceFrontiers::Dir_ection(i);
        if (retval.empty()) {
            retval = "(DominatorTreesAndDominanceFrontiers::Dir_ection)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "DominatorTreesAndDominanceFrontiers::Dir_ection::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyDominatorTreesAndDominanceFrontiersDir_ection() {
        return stringify::DominatorTreesAndDominanceFrontiers::Dir_ection();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/arithmeticIntensity/ai_measurement.h line 25
namespace stringify { namespace ArithmeticIntensityMeasurement {
    const char* running_mode_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_analysis_and_instrument";
            case 1L: return "e_static_counting";
            default: return "";
        }
    }

    std::string running_mode_enum(int64_t i, const std::string &strip) {
        std::string s = running_mode_enum(i);
        if (s.empty())
            s = "(ArithmeticIntensityMeasurement::running_mode_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& running_mode_enum() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyArithmeticIntensityMeasurement_running_mode_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ArithmeticIntensityMeasurement::running_mode_enum(i);
        if (retval.empty()) {
            retval = "(ArithmeticIntensityMeasurement::running_mode_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ArithmeticIntensityMeasurement::running_mode_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyArithmeticIntensityMeasurement_running_mode_enum() {
        return stringify::ArithmeticIntensityMeasurement::running_mode_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/arithmeticIntensity/ai_measurement.h line 30
namespace stringify { namespace ArithmeticIntensityMeasurement {
    const char* fp_operation_kind_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_total";
            case 2L: return "e_plus";
            case 3L: return "e_minus";
            case 4L: return "e_multiply";
            case 5L: return "e_divide";
            default: return "";
        }
    }

    std::string fp_operation_kind_enum(int64_t i, const std::string &strip) {
        std::string s = fp_operation_kind_enum(i);
        if (s.empty())
            s = "(ArithmeticIntensityMeasurement::fp_operation_kind_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& fp_operation_kind_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyArithmeticIntensityMeasurement_fp_operation_kind_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ArithmeticIntensityMeasurement::fp_operation_kind_enum(i);
        if (retval.empty()) {
            retval = "(ArithmeticIntensityMeasurement::fp_operation_kind_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ArithmeticIntensityMeasurement::fp_operation_kind_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyArithmeticIntensityMeasurement_fp_operation_kind_enum() {
        return stringify::ArithmeticIntensityMeasurement::fp_operation_kind_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/staticSingleAssignment/reachingDef.h line 18
namespace stringify { namespace ReachingDef {
    const char* Type(int64_t i) {
        switch (i) {
            case 0L: return "PHI_FUNCTION";
            case 1L: return "ORIGINAL_DEF";
            case 2L: return "EXPANDED_DEF";
            default: return "";
        }
    }

    std::string Type(int64_t i, const std::string &strip) {
        std::string s = Type(i);
        if (s.empty())
            s = "(ReachingDef::Type)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Type() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyReachingDefType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ReachingDef::Type(i);
        if (retval.empty()) {
            retval = "(ReachingDef::Type)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ReachingDef::Type::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyReachingDefType() {
        return stringify::ReachingDef::Type();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/EditDistance/TreeEditDistance.h line 60
namespace stringify { namespace Rose { namespace EditDistance { namespace TreeEditDistance {
    const char* EditType(int64_t i) {
        switch (i) {
            case 0L: return "INSERT";
            case 1L: return "DELETE";
            case 2L: return "SUBSTITUTE";
            default: return "";
        }
    }

    std::string EditType(int64_t i, const std::string &strip) {
        std::string s = EditType(i);
        if (s.empty())
            s = "(Rose::EditDistance::TreeEditDistance::EditType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& EditType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyEditDistanceTreeEditDistanceEditType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::EditDistance::TreeEditDistance::EditType(i);
        if (retval.empty()) {
            retval = "(Rose::EditDistance::TreeEditDistance::EditType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::EditDistance::TreeEditDistance::EditType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyEditDistanceTreeEditDistanceEditType() {
        return stringify::Rose::EditDistance::TreeEditDistance::EditType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/VirtualFunctionAnalysis/IntraProcAliasAnalysis.h line 279
namespace stringify { namespace CollectAliasRelations {
    const char* COLOR(int64_t i) {
        switch (i) {
            case 0L: return "WHITE";
            case 1L: return "GREY";
            case 2L: return "BLACK";
            default: return "";
        }
    }

    std::string COLOR(int64_t i, const std::string &strip) {
        std::string s = COLOR(i);
        if (s.empty())
            s = "(CollectAliasRelations::COLOR)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& COLOR() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyCollectAliasRelationsCOLOR(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::CollectAliasRelations::COLOR(i);
        if (retval.empty()) {
            retval = "(CollectAliasRelations::COLOR)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "CollectAliasRelations::COLOR::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyCollectAliasRelationsCOLOR() {
        return stringify::CollectAliasRelations::COLOR();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/VirtualFunctionAnalysis/IntraProcAliasAnalysis.h line 280
namespace stringify { namespace CollectAliasRelations {
    const char* TRAVERSAL_TYPE(int64_t i) {
        switch (i) {
            case 0L: return "TOPOLOGICAL";
            case 1L: return "NON_TOPOLOGICAL";
            default: return "";
        }
    }

    std::string TRAVERSAL_TYPE(int64_t i, const std::string &strip) {
        std::string s = TRAVERSAL_TYPE(i);
        if (s.empty())
            s = "(CollectAliasRelations::TRAVERSAL_TYPE)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& TRAVERSAL_TYPE() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyCollectAliasRelationsTRAVERSAL_TYPE(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::CollectAliasRelations::TRAVERSAL_TYPE(i);
        if (retval.empty()) {
            retval = "(CollectAliasRelations::TRAVERSAL_TYPE)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "CollectAliasRelations::TRAVERSAL_TYPE::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyCollectAliasRelationsTRAVERSAL_TYPE() {
        return stringify::CollectAliasRelations::TRAVERSAL_TYPE();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/VirtualFunctionAnalysis/PtrAliasAnalysis.h line 31
namespace stringify { namespace PtrAliasAnalysis {
    const char* COLOR(int64_t i) {
        switch (i) {
            case 0L: return "WHITE";
            case 1L: return "GREY";
            case 2L: return "BLACK";
            default: return "";
        }
    }

    std::string COLOR(int64_t i, const std::string &strip) {
        std::string s = COLOR(i);
        if (s.empty())
            s = "(PtrAliasAnalysis::COLOR)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& COLOR() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyPtrAliasAnalysisCOLOR(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::PtrAliasAnalysis::COLOR(i);
        if (retval.empty()) {
            retval = "(PtrAliasAnalysis::COLOR)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "PtrAliasAnalysis::COLOR::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyPtrAliasAnalysisCOLOR() {
        return stringify::PtrAliasAnalysis::COLOR();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/VirtualFunctionAnalysis/PtrAliasAnalysis.h line 33
namespace stringify { namespace PtrAliasAnalysis {
    const char* TRAVERSAL_TYPE(int64_t i) {
        switch (i) {
            case 0L: return "TOPOLOGICAL";
            case 1L: return "REVERSE_TOPOLOGICAL";
            default: return "";
        }
    }

    std::string TRAVERSAL_TYPE(int64_t i, const std::string &strip) {
        std::string s = TRAVERSAL_TYPE(i);
        if (s.empty())
            s = "(PtrAliasAnalysis::TRAVERSAL_TYPE)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& TRAVERSAL_TYPE() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyPtrAliasAnalysisTRAVERSAL_TYPE(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::PtrAliasAnalysis::TRAVERSAL_TYPE(i);
        if (retval.empty()) {
            retval = "(PtrAliasAnalysis::TRAVERSAL_TYPE)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "PtrAliasAnalysis::TRAVERSAL_TYPE::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyPtrAliasAnalysisTRAVERSAL_TYPE() {
        return stringify::PtrAliasAnalysis::TRAVERSAL_TYPE();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astMatching/matcherparser.h line 49
namespace stringify {
    const char* yytokentype(int64_t i) {
        switch (i) {
            case 258L: return "ALTERNATION";
            case 259L: return "NOT";
            case 260L: return "AND";
            case 261L: return "XOR";
            case 262L: return "OR";
            case 263L: return "NEQ";
            case 264L: return "EQ";
            case 265L: return "C_NEQ";
            case 266L: return "C_EQ";
            case 267L: return "WHERE";
            case 268L: return "TRUE";
            case 269L: return "FALSE";
            case 270L: return "IDENT";
            case 271L: return "VARIABLE";
            case 272L: return "INTEGER";
            case 273L: return "SQ_STRING";
            case 274L: return "NULL_NODE";
            case 275L: return "DOTDOT";
            default: return "";
        }
    }

    std::string yytokentype(int64_t i, const std::string &strip) {
        std::string s = yytokentype(i);
        if (s.empty())
            s = "(yytokentype)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& yytokentype() {
        static const int64_t values[] = {
            258L,
            259L,
            260L,
            261L,
            262L,
            263L,
            264L,
            265L,
            266L,
            267L,
            268L,
            269L,
            270L,
            271L,
            272L,
            273L,
            274L,
            275L
        };
        static const std::vector<int64_t> retval(values, values + 18);
        return retval;
    }

}

namespace Rose {
    std::string stringify_yytokentype(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::yytokentype(i);
        if (retval.empty()) {
            retval = "(yytokentype)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "yytokentype::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_yytokentype() {
        return stringify::yytokentype();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astMatching/MatchOperation.h line 40
namespace stringify { namespace MatchStatus {
    const char* PatternMatchMode(int64_t i) {
        switch (i) {
            case 0L: return "MATCHMODE_SHALLOW";
            case 1L: return "MATCHMODE_DEEP";
            case 2L: return "MATCHMODE_SINGLE";
            default: return "";
        }
    }

    std::string PatternMatchMode(int64_t i, const std::string &strip) {
        std::string s = PatternMatchMode(i);
        if (s.empty())
            s = "(MatchStatus::PatternMatchMode)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& PatternMatchMode() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyMatchStatusPatternMatchMode(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::MatchStatus::PatternMatchMode(i);
        if (retval.empty()) {
            retval = "(MatchStatus::PatternMatchMode)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "MatchStatus::PatternMatchMode::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyMatchStatusPatternMatchMode() {
        return stringify::MatchStatus::PatternMatchMode();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astMatching/MatchOperation.h line 41
namespace stringify { namespace MatchStatus {
    const char* CheckNodeMode(int64_t i) {
        switch (i) {
            case 0L: return "NODECHECKMODE_TYPEID";
            case 1L: return "NODECHECKMODE_VARIANT";
            default: return "";
        }
    }

    std::string CheckNodeMode(int64_t i, const std::string &strip) {
        std::string s = CheckNodeMode(i);
        if (s.empty())
            s = "(MatchStatus::CheckNodeMode)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& CheckNodeMode() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyMatchStatusCheckNodeMode(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::MatchStatus::CheckNodeMode(i);
        if (retval.empty()) {
            retval = "(MatchStatus::CheckNodeMode)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "MatchStatus::CheckNodeMode::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyMatchStatusCheckNodeMode() {
        return stringify::MatchStatus::CheckNodeMode();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astSnippet/Snippet.h line 319
namespace stringify { namespace Rose { namespace Snippet {
    const char* InsertMechanism(int64_t i) {
        switch (i) {
            case 0L: return "INSERT_BODY";
            case 1L: return "INSERT_STMTS";
            default: return "";
        }
    }

    std::string InsertMechanism(int64_t i, const std::string &strip) {
        std::string s = InsertMechanism(i);
        if (s.empty())
            s = "(Rose::Snippet::InsertMechanism)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& InsertMechanism() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifySnippetInsertMechanism(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::Snippet::InsertMechanism(i);
        if (retval.empty()) {
            retval = "(Rose::Snippet::InsertMechanism)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::Snippet::InsertMechanism::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySnippetInsertMechanism() {
        return stringify::Rose::Snippet::InsertMechanism();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astSnippet/Snippet.h line 329
namespace stringify { namespace Rose { namespace Snippet {
    const char* LocalDeclarationPosition(int64_t i) {
        switch (i) {
            case 0L: return "LOCDECLS_AT_BEGINNING";
            case 1L: return "LOCDECLS_AT_END";
            case 2L: return "LOCDECLS_AT_CURSOR";
            default: return "";
        }
    }

    std::string LocalDeclarationPosition(int64_t i, const std::string &strip) {
        std::string s = LocalDeclarationPosition(i);
        if (s.empty())
            s = "(Rose::Snippet::LocalDeclarationPosition)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& LocalDeclarationPosition() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifySnippetLocalDeclarationPosition(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::Snippet::LocalDeclarationPosition(i);
        if (retval.empty()) {
            retval = "(Rose::Snippet::LocalDeclarationPosition)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::Snippet::LocalDeclarationPosition::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySnippetLocalDeclarationPosition() {
        return stringify::Rose::Snippet::LocalDeclarationPosition();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/abstractLayer/VariableIdMapping.h line 173
namespace stringify { namespace CodeThorn { namespace VariableIdMapping {
    const char* AggregateType(int64_t i) {
        switch (i) {
            case 0L: return "AT_UNKNOWN";
            case 1L: return "AT_SINGLE";
            case 2L: return "AT_ARRAY";
            case 3L: return "AT_STRUCT";
            default: return "";
        }
    }

    std::string AggregateType(int64_t i, const std::string &strip) {
        std::string s = AggregateType(i);
        if (s.empty())
            s = "(CodeThorn::VariableIdMapping::AggregateType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& AggregateType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyCodeThornVariableIdMappingAggregateType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::CodeThorn::VariableIdMapping::AggregateType(i);
        if (retval.empty()) {
            retval = "(CodeThorn::VariableIdMapping::AggregateType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "CodeThorn::VariableIdMapping::AggregateType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyCodeThornVariableIdMappingAggregateType() {
        return stringify::CodeThorn::VariableIdMapping::AggregateType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/abstractLayer/VariableIdMapping.h line 174
namespace stringify { namespace CodeThorn { namespace VariableIdMapping {
    const char* VariableScope(int64_t i) {
        switch (i) {
            case 0L: return "VS_UNKNOWN";
            case 1L: return "VS_LOCAL";
            case 2L: return "VS_GLOBAL";
            case 3L: return "VS_MEMBER";
            default: return "";
        }
    }

    std::string VariableScope(int64_t i, const std::string &strip) {
        std::string s = VariableScope(i);
        if (s.empty())
            s = "(CodeThorn::VariableIdMapping::VariableScope)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& VariableScope() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyCodeThornVariableIdMappingVariableScope(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::CodeThorn::VariableIdMapping::VariableScope(i);
        if (retval.empty()) {
            retval = "(CodeThorn::VariableIdMapping::VariableScope)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "CodeThorn::VariableIdMapping::VariableScope::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyCodeThornVariableIdMappingVariableScope() {
        return stringify::CodeThorn::VariableIdMapping::VariableScope();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/abstractLayer/SgNodeHelper.h line 537
namespace stringify { namespace SgNodeHelper { namespace Pattern { namespace OutputTarget {
    const char* OType(int64_t i) {
        switch (i) {
            case 0L: return "VAR";
            case 1L: return "INT";
            case 2L: return "UNKNOWNPRINTF";
            case 3L: return "UNKNOWNOPERATION";
            default: return "";
        }
    }

    std::string OType(int64_t i, const std::string &strip) {
        std::string s = OType(i);
        if (s.empty())
            s = "(SgNodeHelper::Pattern::OutputTarget::OType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& OType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifySgNodeHelperPatternOutputTargetOType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgNodeHelper::Pattern::OutputTarget::OType(i);
        if (retval.empty()) {
            retval = "(SgNodeHelper::Pattern::OutputTarget::OType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgNodeHelper::Pattern::OutputTarget::OType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgNodeHelperPatternOutputTargetOType() {
        return stringify::SgNodeHelper::Pattern::OutputTarget::OType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/abstractLayer/Labeler.h line 59
namespace stringify { namespace CodeThorn { namespace LabelProperty {
    const char* LabelType(int64_t i) {
        switch (i) {
            case 1L: return "LABEL_UNDEF";
            case 2L: return "LABEL_OTHER";
            case 100L: return "LABEL_FUNCTIONCALL";
            case 101L: return "LABEL_FUNCTIONCALLRETURN";
            case 102L: return "LABEL_FUNCTIONENTRY";
            case 103L: return "LABEL_FUNCTIONEXIT";
            case 104L: return "LABEL_BLOCKBEGIN";
            case 105L: return "LABEL_BLOCKEND";
            case 106L: return "LABEL_EMPTY_STMT";
            case 107L: return "LABEL_FORK";
            case 108L: return "LABEL_JOIN";
            case 109L: return "LABEL_WORKSHARE";
            case 110L: return "LABEL_BARRIER";
            default: return "";
        }
    }

    std::string LabelType(int64_t i, const std::string &strip) {
        std::string s = LabelType(i);
        if (s.empty())
            s = "(CodeThorn::LabelProperty::LabelType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& LabelType() {
        static const int64_t values[] = {
            1L,
            2L,
            100L,
            101L,
            102L,
            103L,
            104L,
            105L,
            106L,
            107L,
            108L,
            109L,
            110L
        };
        static const std::vector<int64_t> retval(values, values + 13);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyCodeThornLabelPropertyLabelType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::CodeThorn::LabelProperty::LabelType(i);
        if (retval.empty()) {
            retval = "(CodeThorn::LabelProperty::LabelType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "CodeThorn::LabelProperty::LabelType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyCodeThornLabelPropertyLabelType() {
        return stringify::CodeThorn::LabelProperty::LabelType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/abstractLayer/Labeler.h line 95
namespace stringify { namespace CodeThorn { namespace LabelProperty {
    const char* IOType(int64_t i) {
        switch (i) {
            case 0L: return "LABELIO_NONE";
            case 1L: return "LABELIO_STDIN";
            case 2L: return "LABELIO_STDOUTVAR";
            case 3L: return "LABELIO_STDOUTCONST";
            case 4L: return "LABELIO_STDERR";
            default: return "";
        }
    }

    std::string IOType(int64_t i, const std::string &strip) {
        std::string s = IOType(i);
        if (s.empty())
            s = "(CodeThorn::LabelProperty::IOType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& IOType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyCodeThornLabelPropertyIOType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::CodeThorn::LabelProperty::IOType(i);
        if (retval.empty()) {
            retval = "(CodeThorn::LabelProperty::IOType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "CodeThorn::LabelProperty::IOType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyCodeThornLabelPropertyIOType() {
        return stringify::CodeThorn::LabelProperty::IOType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astQuery/booleanQuery.h line 43
namespace stringify { namespace BooleanQuery {
    const char* TypeOfQueryType(int64_t i) {
        switch (i) {
            case 0L: return "UnknownListElementType";
            case 1L: return "VariableDeclaration";
            case 2L: return "Type";
            case 3L: return "FunctionDeclaration";
            case 4L: return "MemberFunctionDeclaration";
            case 5L: return "ClassDeclaration";
            case 6L: return "Argument";
            case 7L: return "Field";
            case 8L: return "UnionedField";
            case 9L: return "Struct";
            case 10L: return "ContainedInSubtreeOfType";
            case 11L: return "END_OF_BOOLEAN_QUERY_TYPE";
            default: return "";
        }
    }

    std::string TypeOfQueryType(int64_t i, const std::string &strip) {
        std::string s = TypeOfQueryType(i);
        if (s.empty())
            s = "(BooleanQuery::TypeOfQueryType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& TypeOfQueryType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L
        };
        static const std::vector<int64_t> retval(values, values + 12);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyBooleanQueryTypeOfQueryType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::BooleanQuery::TypeOfQueryType(i);
        if (retval.empty()) {
            retval = "(BooleanQuery::TypeOfQueryType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "BooleanQuery::TypeOfQueryType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBooleanQueryTypeOfQueryType() {
        return stringify::BooleanQuery::TypeOfQueryType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astQuery/nameQuery.h line 74
namespace stringify { namespace NameQuery {
    const char* TypeOfQueryTypeOneParameter(int64_t i) {
        switch (i) {
            case 0L: return "UnknownListElementType";
            case 1L: return "VariableNames";
            case 2L: return "VariableTypeNames";
            case 3L: return "FunctionDeclarationNames";
            case 4L: return "MemberFunctionDeclarationNames";
            case 5L: return "ClassDeclarationNames";
            case 6L: return "ArgumentNames";
            case 7L: return "ClassFieldNames";
            case 8L: return "UnionFieldNames";
            case 9L: return "StructFieldNames";
            case 10L: return "FunctionReferenceNames";
            case 11L: return "StructNames";
            case 12L: return "UnionNames";
            case 13L: return "TypedefDeclarationNames";
            case 14L: return "TypeNames";
            case 15L: return "END_OF_NAME_TYPE_LIST";
            default: return "";
        }
    }

    std::string TypeOfQueryTypeOneParameter(int64_t i, const std::string &strip) {
        std::string s = TypeOfQueryTypeOneParameter(i);
        if (s.empty())
            s = "(NameQuery::TypeOfQueryTypeOneParameter)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& TypeOfQueryTypeOneParameter() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L
        };
        static const std::vector<int64_t> retval(values, values + 16);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyNameQueryTypeOfQueryTypeOneParameter(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::NameQuery::TypeOfQueryTypeOneParameter(i);
        if (retval.empty()) {
            retval = "(NameQuery::TypeOfQueryTypeOneParameter)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "NameQuery::TypeOfQueryTypeOneParameter::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyNameQueryTypeOfQueryTypeOneParameter() {
        return stringify::NameQuery::TypeOfQueryTypeOneParameter();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astQuery/nameQuery.h line 94
namespace stringify { namespace NameQuery {
    const char* TypeOfQueryTypeTwoParameters(int64_t i) {
        switch (i) {
            case 0L: return "UnknownListElementTypeTwoParameters";
            case 1L: return "VariableNamesWithTypeName";
            case 2L: return "END_OF_NODE_TYPE_LIST_TWO_PARAMETERS";
            default: return "";
        }
    }

    std::string TypeOfQueryTypeTwoParameters(int64_t i, const std::string &strip) {
        std::string s = TypeOfQueryTypeTwoParameters(i);
        if (s.empty())
            s = "(NameQuery::TypeOfQueryTypeTwoParameters)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& TypeOfQueryTypeTwoParameters() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyNameQueryTypeOfQueryTypeTwoParameters(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::NameQuery::TypeOfQueryTypeTwoParameters(i);
        if (retval.empty()) {
            retval = "(NameQuery::TypeOfQueryTypeTwoParameters)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "NameQuery::TypeOfQueryTypeTwoParameters::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyNameQueryTypeOfQueryTypeTwoParameters() {
        return stringify::NameQuery::TypeOfQueryTypeTwoParameters();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astQuery/astQuery.h line 97
namespace stringify { namespace AstQueryNamespace {
    const char* QueryDepth(int64_t i) {
        switch (i) {
            case 0L: return "UnknownListElementTypeQueryDepth";
            case 1L: return "ChildrenOnly";
            case 2L: return "AllNodes";
            case 3L: return "ExtractTypes";
            case 4L: return "END_OF_NODE_TYPE_LIST_QUERY_DEPTH";
            default: return "";
        }
    }

    std::string QueryDepth(int64_t i, const std::string &strip) {
        std::string s = QueryDepth(i);
        if (s.empty())
            s = "(AstQueryNamespace::QueryDepth)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& QueryDepth() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyAstQueryNamespaceQueryDepth(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::AstQueryNamespace::QueryDepth(i);
        if (retval.empty()) {
            retval = "(AstQueryNamespace::QueryDepth)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "AstQueryNamespace::QueryDepth::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyAstQueryNamespaceQueryDepth() {
        return stringify::AstQueryNamespace::QueryDepth();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astQuery/numberQuery.h line 10
namespace stringify { namespace NumberQuery {
    const char* TypeOfQueryTypeOneParameter(int64_t i) {
        switch (i) {
            case 0L: return "UnknownListElementType";
            case 1L: return "NumberOfArgsInConstructor";
            case 2L: return "NumberOfOperands";
            case 3L: return "NumberOfArgsInScalarIndexingOperator";
            case 4L: return "END_OF_NODE_TYPE_LIST_ONE_PARAMETER";
            default: return "";
        }
    }

    std::string TypeOfQueryTypeOneParameter(int64_t i, const std::string &strip) {
        std::string s = TypeOfQueryTypeOneParameter(i);
        if (s.empty())
            s = "(NumberQuery::TypeOfQueryTypeOneParameter)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& TypeOfQueryTypeOneParameter() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyNumberQueryTypeOfQueryTypeOneParameter(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::NumberQuery::TypeOfQueryTypeOneParameter(i);
        if (retval.empty()) {
            retval = "(NumberQuery::TypeOfQueryTypeOneParameter)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "NumberQuery::TypeOfQueryTypeOneParameter::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyNumberQueryTypeOfQueryTypeOneParameter() {
        return stringify::NumberQuery::TypeOfQueryTypeOneParameter();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astQuery/numberQuery.h line 19
namespace stringify { namespace NumberQuery {
    const char* TypeOfQueryTypeTwoParameters(int64_t i) {
        switch (i) {
            case 0L: return "UnknownListElementTypeTwoParameters";
            case 1L: return "NumberOfArgsInParanthesisOperator";
            case 2L: return "END_OF_NODE_TYPE_LIST_TWO_PARAMETERS";
            default: return "";
        }
    }

    std::string TypeOfQueryTypeTwoParameters(int64_t i, const std::string &strip) {
        std::string s = TypeOfQueryTypeTwoParameters(i);
        if (s.empty())
            s = "(NumberQuery::TypeOfQueryTypeTwoParameters)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& TypeOfQueryTypeTwoParameters() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyNumberQueryTypeOfQueryTypeTwoParameters(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::NumberQuery::TypeOfQueryTypeTwoParameters(i);
        if (retval.empty()) {
            retval = "(NumberQuery::TypeOfQueryTypeTwoParameters)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "NumberQuery::TypeOfQueryTypeTwoParameters::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyNumberQueryTypeOfQueryTypeTwoParameters() {
        return stringify::NumberQuery::TypeOfQueryTypeTwoParameters();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astQuery/nodeQuery.h line 133
namespace stringify { namespace NodeQuery {
    const char* TypeOfQueryTypeOneParameter(int64_t i) {
        switch (i) {
            case 0L: return "UnknownListElementType";
            case 1L: return "VariableDeclarations";
            case 2L: return "VariableTypes";
            case 3L: return "FunctionDeclarations";
            case 4L: return "MemberFunctionDeclarations";
            case 5L: return "ClassDeclarations";
            case 6L: return "StructDeclarations";
            case 7L: return "UnionDeclarations";
            case 8L: return "Arguments";
            case 9L: return "ClassFields";
            case 10L: return "StructFields";
            case 11L: return "UnionFields";
            case 12L: return "StructDefinitions";
            case 13L: return "TypedefDeclarations";
            case 14L: return "AnonymousTypedefs";
            case 15L: return "AnonymousTypedefClassDeclarations";
            case 16L: return "END_OF_NODE_TYPE_LIST_ONE_PARAMETER";
            default: return "";
        }
    }

    std::string TypeOfQueryTypeOneParameter(int64_t i, const std::string &strip) {
        std::string s = TypeOfQueryTypeOneParameter(i);
        if (s.empty())
            s = "(NodeQuery::TypeOfQueryTypeOneParameter)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& TypeOfQueryTypeOneParameter() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L
        };
        static const std::vector<int64_t> retval(values, values + 17);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyNodeQueryTypeOfQueryTypeOneParameter(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::NodeQuery::TypeOfQueryTypeOneParameter(i);
        if (retval.empty()) {
            retval = "(NodeQuery::TypeOfQueryTypeOneParameter)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "NodeQuery::TypeOfQueryTypeOneParameter::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyNodeQueryTypeOfQueryTypeOneParameter() {
        return stringify::NodeQuery::TypeOfQueryTypeOneParameter();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astQuery/nodeQuery.h line 154
namespace stringify { namespace NodeQuery {
    const char* TypeOfQueryTypeTwoParameters(int64_t i) {
        switch (i) {
            case 0L: return "UnknownListElementTypeTwoParameters";
            case 1L: return "FunctionDeclarationFromDefinition";
            case 2L: return "ClassDeclarationFromName";
            case 3L: return "ClassDeclarationsFromTypeName";
            case 4L: return "PragmaDeclarationFromName";
            case 5L: return "VariableDeclarationFromName";
            case 6L: return "END_OF_NODE_TYPE_LIST_TWO_PARAMETERS";
            default: return "";
        }
    }

    std::string TypeOfQueryTypeTwoParameters(int64_t i, const std::string &strip) {
        std::string s = TypeOfQueryTypeTwoParameters(i);
        if (s.empty())
            s = "(NodeQuery::TypeOfQueryTypeTwoParameters)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& TypeOfQueryTypeTwoParameters() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyNodeQueryTypeOfQueryTypeTwoParameters(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::NodeQuery::TypeOfQueryTypeTwoParameters(i);
        if (retval.empty()) {
            retval = "(NodeQuery::TypeOfQueryTypeTwoParameters)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "NodeQuery::TypeOfQueryTypeTwoParameters::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyNodeQueryTypeOfQueryTypeTwoParameters() {
        return stringify::NodeQuery::TypeOfQueryTypeTwoParameters();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 17
namespace stringify {
    const char* Cxx_GrammarVariants(int64_t i) {
        switch (i) {
            case 1L: return "AccessModifierTag";
            case 2L: return "ACTUAL_ARGUMENT_EXPRESSION";
            case 4L: return "ADD_OP";
            case 5L: return "ADDRESS_OP";
            case 6L: return "AGGREGATE_INIT";
            case 7L: return "ALIAS_SYMBOL";
            case 8L: return "TEMP_Allocate_Statement";
            case 9L: return "AND_ASSIGN_OP";
            case 10L: return "AND_OP";
            case 11L: return "TEMP_Arithmetic_If_Statement";
            case 12L: return "T_ARRAY";
            case 13L: return "POINTST_OP";
            case 14L: return "ARROWSTAR_OP";
            case 15L: return "ASM_OP";
            case 16L: return "ASM_STMT";
            case 17L: return "ASSERT_STMT";
            case 18L: return "ASSIGN_INIT";
            case 19L: return "ASSIGN_OP";
            case 20L: return "TEMP_Assign_Statement";
            case 21L: return "TEMP_Assigned_Goto_Statement";
            case 22L: return "TEMP_Associate_Statement";
            case 23L: return "TEMP_AsteriskShapeExp";
            case 24L: return "AttributeTag";
            case 25L: return "TEMP_Attribute_Specification_Statement";
            case 26L: return "T_AUTO";
            case 27L: return "AWAIT_EXPR";
            case 28L: return "BACKSPACE_STATEMENT";
            case 29L: return "BaseClassTag";
            case 30L: return "ExpBaseClassTag";
            case 31L: return "BaseClassModifierTag";
            case 32L: return "BASIC_BLOCK_STMT";
            case 33L: return "BidirectionalGraphTag";
            case 35L: return "BINARY_EXPRESSION";
            case 36L: return "BITAND_OP";
            case 37L: return "BitAttributeTag";
            case 38L: return "BIT_COMPLEMENT_OP";
            case 39L: return "BITEQV_OP";
            case 40L: return "BITOR_OP";
            case 41L: return "BITXOR_OP";
            case 42L: return "TEMP_Block_Data_Statement";
            case 43L: return "BOOL_VAL";
            case 44L: return "BREAK_STMT";
            case 45L: return "BRACED_INIT";
            case 46L: return "CPP_DIRECTIVE_STMT";
            case 47L: return "CASE_STMT";
            case 48L: return "CAST_OP";
            case 49L: return "CATCH_STMT";
            case 50L: return "CATCH_STATEMENT_SEQ";
            case 51L: return "CHAR_VAL";
            case 52L: return "CHAR16_VAL";
            case 53L: return "CHAR32_VAL";
            case 54L: return "CHOOSE_EXPR";
            case 55L: return "ClassDecl_attrTag";
            case 56L: return "CLASS_DECL_STMT";
            case 57L: return "CLASS_DEFN_STMT";
            case 58L: return "CLASSNAME_REF";
            case 59L: return "CLASS_NAME";
            case 60L: return "T_CLASS";
            case 61L: return "C_LINKAGE_DECLARATION_STMT";
            case 62L: return "C_LINKAGE_END_STMT";
            case 63L: return "C_LINKAGE_START_STMT";
            case 64L: return "CLOSE_STATEMENT";
            case 65L: return "TEMP_ColonShapeExp";
            case 66L: return "COMMA_OP";
            case 67L: return "COMMON_BLOCK";
            case 68L: return "TEMP_CommonBlockObject";
            case 69L: return "COMMON_SYMBOL";
            case 70L: return "COMPLEX_VAL";
            case 71L: return "COMPREHENSION";
            case 73L: return "COMPOUND_ASSIGN_OP";
            case 74L: return "COMPOUND_INIT";
            case 75L: return "COMPOUND_LITERAL";
            case 76L: return "TEMP_Computed_Goto_Statement";
            case 77L: return "CONCATENATION_OP";
            case 78L: return "EXPR_CONDITIONAL";
            case 79L: return "CONJUGATE_OP";
            case 80L: return "ConstVolatileModifierTag";
            case 81L: return "CONSTRUCTOR_INIT";
            case 82L: return "TEMP_Contains_Statement";
            case 83L: return "CONTINUE_STMT";
            case 84L: return "CTOR_INITIALIZER_LIST";
            case 85L: return "TEMP_DataStatementGroup";
            case 86L: return "TEMP_DataStatementObject";
            case 87L: return "TEMP_DataStatementValue";
            case 88L: return "DEAD_IF_DIRECTIVE_STMT";
            case 89L: return "TEMP_Deallocate_Statement";
            case 90L: return "DeclarationModifierTag";
            case 91L: return "DECLARATION_SCOPE";
            case 92L: return "DECL_STMT";
            case 93L: return "T_DECLTYPE";
            case 94L: return "DEFAULT_STMT";
            case 95L: return "DEFAULT_NAME";
            case 96L: return "DEFINE_DIRECTIVE_STMT";
            case 97L: return "DELETE_OP";
            case 98L: return "TEMP_Derived_Type_Statement";
            case 99L: return "DESIGNATED_INITIALIZER";
            case 100L: return "DICTIONARY_COMPREHENSION";
            case 101L: return "DICT_EXP";
            case 102L: return "TEMP_DimensionObject";
            case 104L: return "DirectedGraphEdgeTag";
            case 106L: return "DirectoryTag";
            case 107L: return "DirectoryListTag";
            case 108L: return "DIV_ASSIGN_OP";
            case 109L: return "DIV_OP";
            case 110L: return "DO_WHILE_STMT";
            case 111L: return "RECORD_REF";
            case 112L: return "DOTSTAR_OP";
            case 113L: return "DOUBLE_VAL";
            case 114L: return "ElaboratedTypeModifierTag";
            case 115L: return "ELEMENT_WISE_OP";
            case 116L: return "ELEMENT_ADD_OP";
            case 117L: return "ELEMENT_DIVIDE_OP";
            case 118L: return "ELEMENT_LEFT_DIVIDE_OP";
            case 119L: return "ELEMENT_MULT_OP";
            case 120L: return "ELEMENT_POWER_OP";
            case 121L: return "ELEMENT_SUBTRACT_OP";
            case 122L: return "ELSE_DIRECTIVE_STMT";
            case 123L: return "TEMP_Else_Where_Statement";
            case 124L: return "ELSEIF_DIRECTIVE_STMT";
            case 125L: return "EMPTY_DECLARATION_STMT";
            case 126L: return "EMPTY_DIRECTIVE_STMT";
            case 127L: return "ENDFILE_STATEMENT";
            case 128L: return "ENDIF_DIRECTIVE_STMT";
            case 129L: return "ENTRY_STMT";
            case 130L: return "ENUM_DECL_STMT";
            case 131L: return "FIELD_NAME";
            case 132L: return "ENUM_NAME";
            case 133L: return "T_ENUM";
            case 134L: return "ENUM_VAL";
            case 135L: return "EQ_OP";
            case 136L: return "TEMP_Equivalence_Statement";
            case 137L: return "ERROR_DIRECTIVE_STMT";
            case 138L: return "EXEC_STMT";
            case 139L: return "EXPONENTIATION_OP";
            case 140L: return "EXP_ASSIGN_OP";
            case 141L: return "EXPR_LIST";
            case 142L: return "EXPR_STMT";
            case 143L: return "ExpressionTag";
            case 144L: return "EXPRESSION_ROOT";
            case 145L: return "FileTag";
            case 146L: return "FileListTag";
            case 147L: return "FLOAT_VAL";
            case 148L: return "FLOAT_128_VAL";
            case 149L: return "FLOAT_80_VAL";
            case 150L: return "FOLD_EXPR";
            case 151L: return "FLUSH_STATEMENT";
            case 152L: return "FOR_ALL_STMT";
            case 153L: return "FOR_INIT_STMT";
            case 154L: return "FOR_STMT";
            case 155L: return "TEMP_FormatItem";
            case 156L: return "TEMP_FormatItemList";
            case 157L: return "FORMAT_STATEMENT";
            case 158L: return "FORTRAN_DO";
            case 159L: return "TEMP_Fortran_Include_Line";
            case 160L: return "FORTRAN_NONBLOCKED_DO";
            case 161L: return "FuncDecl_attrTag";
            case 162L: return "FUNC_CALL";
            case 163L: return "FUNC_DECL_STMT";
            case 164L: return "FUNC_DEFN_STMT";
            case 165L: return "FUNCTION_PARAMETER_SCOPE";
            case 166L: return "FunctionModifierTag";
            case 167L: return "FUNCTION_PARAMETER_LIST";
            case 168L: return "FUNCTION_PARAMETER_REF_EXP";
            case 169L: return "T_FUNCTION_PARAMETER_TYPE_LIST";
            case 170L: return "FUNCTION_REF";
            case 171L: return "FUNCTION_NAME";
            case 172L: return "T_FUNCTION";
            case 173L: return "FUNCTYPE_NAME";
            case 174L: return "FUNC_TBL_STMT";
            case 175L: return "TYPE_TABLE";
            case 176L: return "GLOBAL_STMT";
            case 177L: return "GOTO_STMT";
            case 178L: return "GraphTag";
            case 179L: return "GraphEdgeTag";
            case 180L: return "GraphEdgeListTag";
            case 181L: return "GraphNodeTag";
            case 182L: return "GraphNodeListTag";
            case 183L: return "GE_OP";
            case 184L: return "GT_OP";
            case 185L: return "IO_ITEM_EXPR";
            case 186L: return "IO_STATEMENT";
            case 187L: return "IDENT_DIRECTIVE_STMT";
            case 188L: return "IF_DIRECTIVE_STMT";
            case 189L: return "IF_STMT";
            case 190L: return "IFDEF_DIRECTIVE_STMT";
            case 191L: return "IFNDEF_DIRECTIVE_STMT";
            case 192L: return "IMAGE_CONTROL_STATEMENT";
            case 193L: return "IMAG_PART_OP";
            case 194L: return "TEMP_Implicit_Statement";
            case 195L: return "IMPLIED_DO";
            case 196L: return "TEMP_Import_Statement";
            case 197L: return "IncidenceDirectedGraphTag";
            case 198L: return "IncidenceUndirectedGraphTag";
            case 199L: return "INCLUDE_DIRECTIVE_STMT";
            case 200L: return "IncludeFileTag";
            case 201L: return "INCLUDE_NEXT_DIRECTIVE_STMT";
            case 202L: return "InitializedNameTag";
            case 203L: return "EXPR_INIT";
            case 204L: return "INQUIRE_STATEMENT";
            case 205L: return "IntKeyedBidirectionalGraphTag";
            case 206L: return "INT_VAL";
            case 207L: return "INTEGER_DIV_OP";
            case 208L: return "IDIV_ASSIGN_OP";
            case 209L: return "TEMP_Interface_Body";
            case 210L: return "TEMP_Header_File_Body";
            case 211L: return "HeaderFileReportTag";
            case 212L: return "INTERFACE_STATEMENT";
            case 213L: return "INTERFACE_SYMBOL";
            case 214L: return "INTRINSIC_SYMBOL";
            case 215L: return "IS_OP";
            case 216L: return "IS_NOT_OP";
            case 217L: return "IOR_ASSIGN_OP";
            case 218L: return "KEY_DATUM_PAIR";
            case 219L: return "EXEC_CONF";
            case 220L: return "KERN_CALL";
            case 221L: return "LABEL_REF";
            case 222L: return "LABEL_STMT";
            case 223L: return "LABEL_NAME";
            case 224L: return "LambdaCaptureTag";
            case 225L: return "LambdaCaptureListTag";
            case 226L: return "LAMBDA_EXP";
            case 227L: return "LAMBDA_REF_EXP";
            case 228L: return "LEFT_DIVIDE_OP";
            case 229L: return "LE_OP";
            case 230L: return "LT_OP";
            case 231L: return "LINE_DIRECTIVE_STMT";
            case 232L: return "LINEMARKER_DIRECTIVE_STMT";
            case 233L: return "LinkageModifierTag";
            case 234L: return "LIST_COMPREHENSION";
            case 235L: return "LIST_EXP";
            case 236L: return "LocatedNodeTag";
            case 237L: return "LocatedNodeSupportTag";
            case 238L: return "LONG_DOUBLE_VAL";
            case 239L: return "LONG_INT_VAL";
            case 240L: return "LONG_LONG_INT_VAL";
            case 241L: return "LSHIFT_ASSIGN_OP";
            case 242L: return "LSHIFT_OP";
            case 243L: return "MAGIC_COLON_EXP";
            case 244L: return "MATRIX_EXP";
            case 245L: return "MATRIX_TRANSPOSE_OP";
            case 246L: return "MFUNC_DECL_STMT";
            case 247L: return "MEMBER_FUNCTION_REF";
            case 248L: return "MEMBER_FUNC_NAME";
            case 249L: return "T_MEMBERFUNCTION";
            case 250L: return "MEMBERSHIP_OP";
            case 251L: return "MS_ATTRIBUTE_DECL_STMT";
            case 252L: return "MINUS_ASSIGN_OP";
            case 253L: return "MINUSMINUS_OP";
            case 254L: return "UNARY_MINUS_OP";
            case 255L: return "MOD_ASSIGN_OP";
            case 256L: return "MOD_OP";
            case 257L: return "ModifierTag";
            case 258L: return "ModifierNodesTag";
            case 259L: return "T_MODIFIER";
            case 260L: return "MODULE_STATEMENT";
            case 261L: return "MODULE_SYMBOL";
            case 262L: return "MULT_ASSIGN_OP";
            case 263L: return "MULT_OP";
            case 264L: return "NameTag";
            case 265L: return "TEMP_Name_Group";
            case 266L: return "T_NAME";
            case 267L: return "TEMP_Namelist_Statement";
            case 268L: return "NAMESPACE_ALIAS_DECLARATION_STMT";
            case 269L: return "NAMESPACE_DECLARATION_STMT";
            case 270L: return "NAMESPACE_DEFINITION_STMT";
            case 271L: return "NAMESPACE_NAME";
            case 272L: return "NARY_EXPRESSION";
            case 273L: return "NARY_BOOLEAN_OP";
            case 274L: return "NARY_COMPARISON_OP";
            case 275L: return "NEW_OP";
            case 276L: return "NodeTag";
            case 277L: return "NOEXCEPT_OP";
            case 278L: return "NE_OP";
            case 279L: return "NOT_OP";
            case 280L: return "NON_MEMBERSHIP_OP";
            case 281L: return "NONREAL_DECL";
            case 282L: return "NONREAL_REF";
            case 283L: return "NONREAL_SYMBOL";
            case 284L: return "T_NONREAL";
            case 285L: return "NonrealBaseClassTag";
            case 286L: return "NULL_EXPR";
            case 287L: return "NULLPTR_VAL";
            case 288L: return "NULL_STMT";
            case 289L: return "TEMP_Nullify_Statement";
            case 290L: return "OMP_ATOMIC_STMT";
            case 291L: return "OMP_BARRIER_STMT";
            case 292L: return "OMP_CRITICAL_STMT";
            case 293L: return "OMP_CLAUSEBODY_STMT";
            case 294L: return "OMP_BODY_STMT";
            case 295L: return "OMP_CLAUSE_STMT";
            case 296L: return "OMP_DO_STMT";
            case 297L: return "OMP_FLUSH_STMT";
            case 298L: return "OMP_DECLARE_SIMD_STMT";
            case 299L: return "OMP_FOR_STMT";
            case 300L: return "OMP_FOR_SIMD_STMT";
            case 301L: return "OMP_MASTER_STMT";
            case 302L: return "OMP_TASKYIELD_STMT";
            case 303L: return "OMP_METADIRECTIVE_STMT";
            case 304L: return "OMP_ORDERED_STMT";
            case 305L: return "OMP_PARALLEL_STMT";
            case 306L: return "OMP_TEAMS_STMT";
            case 307L: return "OMP_CANCELLATION_POINT_STMT";
            case 308L: return "OMP_DECLARE_MAPPER_STMT";
            case 309L: return "OMP_CANCEL_STMT";
            case 310L: return "OMP_TASKGROUP_STMT";
            case 311L: return "OMP_DEPOBJ_STMT";
            case 312L: return "OMP_DISTRIBUTE_STMT";
            case 313L: return "OMP_LOOP_STMT";
            case 314L: return "OMP_SCAN_STMT";
            case 315L: return "OMP_TASKLOOP_STMT";
            case 316L: return "OMP_TARGET_ENTER_DATA_STMT";
            case 317L: return "OMP_TARGET_EXIT_DATA_STMT";
            case 318L: return "OMP_SECTION_STMT";
            case 319L: return "OMP_SECTIONS_STMT";
            case 320L: return "OMP_SINGLE_STMT";
            case 321L: return "OMP_TASK_STMT";
            case 322L: return "OMP_TASKWAIT_STMT";
            case 323L: return "OMP_THREADPRIVATE_STMT";
            case 324L: return "OMP_WORKSHARE_STMT";
            case 325L: return "OMP_TARGET_STMT";
            case 326L: return "OMP_TARGET_DATA_STMT";
            case 327L: return "OMP_TARGET_PARALLEL_FOR_STMT";
            case 328L: return "OMP_SIMD_STMT";
            case 329L: return "OmpClauseTag";
            case 330L: return "OmpAllocateClauseTag";
            case 331L: return "OmpBeginClauseTag";
            case 332L: return "OmpCollapseClauseTag";
            case 333L: return "OmpCopyinClauseTag";
            case 334L: return "OmpCopyprivateClauseTag";
            case 335L: return "OmpDefaultClauseTag";
            case 336L: return "OmpEndClauseTag";
            case 337L: return "OmpExpressionClauseTag";
            case 338L: return "OmpFirstprivateClauseTag";
            case 339L: return "OmpIfClauseTag";
            case 340L: return "OmpFinalClauseTag";
            case 341L: return "OmpPriorityClauseTag";
            case 342L: return "OmpIfDeviceTag";
            case 343L: return "OmpLastprivateClauseTag";
            case 344L: return "OmpNowaitClauseTag";
            case 345L: return "OmpReadClauseTag";
            case 346L: return "OmpWriteClauseTag";
            case 347L: return "OmpUpdateClauseTag";
            case 348L: return "OmpDepobjUpdateClauseTag";
            case 349L: return "OmpDestroyClauseTag";
            case 350L: return "OmpCaptureClauseTag";
            case 351L: return "OmpSeqCstClauseTag";
            case 352L: return "OmpAcqRelClauseTag";
            case 353L: return "OmpReleaseClauseTag";
            case 354L: return "OmpAcquireClauseTag";
            case 355L: return "OmpRelaxedClauseTag";
            case 356L: return "OmpParallelClauseTag";
            case 357L: return "OmpSectionsClauseTag";
            case 358L: return "OmpForClauseTag";
            case 359L: return "OmpTaskgroupClauseTag";
            case 360L: return "OmpNumThreadsClauseTag";
            case 361L: return "OmpNumTeamsClauseTag";
            case 362L: return "OmpGrainsizeClauseTag";
            case 363L: return "OmpDetachClauseTag";
            case 364L: return "OmpNumTasksClauseTag";
            case 365L: return "OmpNogroupClauseTag";
            case 366L: return "OmpHintClauseTag";
            case 367L: return "OmpOrderClauseTag";
            case 368L: return "OmpDistScheduleClauseTag";
            case 369L: return "OmpBindClauseTag";
            case 370L: return "OmpNontemporalClauseTag";
            case 371L: return "OmpInclusiveClauseTag";
            case 372L: return "OmpExclusiveClauseTag";
            case 373L: return "OmpIsDevicePtrClauseTag";
            case 374L: return "OmpUseDevicePtrClauseTag";
            case 375L: return "OmpUseDeviceAddrClauseTag";
            case 376L: return "OmpThreadLimitClauseTag";
            case 377L: return "OmpOrderedClauseTag";
            case 378L: return "OmpPrivateClauseTag";
            case 379L: return "OmpReductionClauseTag";
            case 380L: return "OmpInReductionClauseTag";
            case 381L: return "OmpTaskReductionClauseTag";
            case 382L: return "OmpDefaultmapClauseTag";
            case 383L: return "OmpScheduleClauseTag";
            case 384L: return "OmpSharedClauseTag";
            case 385L: return "OmpUntiedClauseTag";
            case 386L: return "OmpMergeableClauseTag";
            case 387L: return "OmpVariablesClauseTag";
            case 388L: return "OmpMapClauseTag";
            case 389L: return "OmpSafelenTag";
            case 390L: return "OmpSimdlenTag";
            case 391L: return "OmpLinearClauseTag";
            case 392L: return "OmpUniformClauseTag";
            case 393L: return "OmpAlignedClauseTag";
            case 394L: return "OmpProcBindClauseTag";
            case 395L: return "OmpAtomicClauseTag";
            case 396L: return "OmpInbranchClauseTag";
            case 397L: return "OmpNotinbranchClauseTag";
            case 398L: return "OmpDependClauseTag";
            case 399L: return "OmpWhenClauseTag";
            case 400L: return "OPENCL_ACCESS_MODE";
            case 401L: return "OPEN_STATEMENT";
            case 402L: return "OptionsTag";
            case 403L: return "OR_OP";
            case 404L: return "PARAMETER_STATEMENT";
            case 405L: return "T_PARTIAL_FUNCTION_MODIFIER";
            case 406L: return "T_PARTIAL_FUNCTION";
            case 407L: return "PASS_STATEMENT";
            case 408L: return "PLUS_ASSIGN_OP";
            case 409L: return "PLUSPLUS_OP";
            case 410L: return "ARRAY_OP";
            case 411L: return "POINTER_ASSIGN_OP";
            case 412L: return "DEREF_OP";
            case 413L: return "T_MEMBER_POINTER";
            case 414L: return "T_POINTER";
            case 415L: return "POWER_OP";
            case 416L: return "PragmaTag";
            case 417L: return "PRAGMA_DECL";
            case 418L: return "PRINT_STATEMENT";
            case 419L: return "PROCEDURE_HEADER_STMT";
            case 420L: return "PROGRAM_HEADER_STMT";
            case 421L: return "ProjectTag";
            case 422L: return "PSEUDO_DESTRUCTOR_REF";
            case 425L: return "QualifiedNameTag";
            case 426L: return "T_QUALIFIED_NAME";
            case 427L: return "RANGE_EXP";
            case 428L: return "RANGE_BASED_FOR_STMT";
            case 429L: return "READ_STATEMENT";
            case 430L: return "REAL_PART_OP";
            case 431L: return "TYPE_REF";
            case 432L: return "T_REFERENCE";
            case 434L: return "TEMP_Rename_Pair";
            case 435L: return "RENAME_SYMBOL";
            case 436L: return "RETURN_STMT";
            case 437L: return "REWIND_STATEMENT";
            case 438L: return "RSHIFT_ASSIGN_OP";
            case 439L: return "RSHIFT_OP";
            case 440L: return "T_RVALUE_REFERENCE";
            case 441L: return "SCOPE_OP";
            case 442L: return "SCOPE_STMT";
            case 443L: return "TEMP_Sequence_Statement";
            case 444L: return "SET_COMPREHENSION";
            case 445L: return "SHORT_VAL";
            case 446L: return "SIMD_BINARY_OP";
            case 447L: return "SIMD_ADD_OP";
            case 448L: return "SIMD_SUB_OP";
            case 449L: return "SIMD_MUL_OP";
            case 450L: return "SIMD_DIV_OP";
            case 451L: return "SIMD_FMA_OP";
            case 452L: return "SIMD_LOAD";
            case 453L: return "SIMD_BROADCAST";
            case 454L: return "SIMD_STORE";
            case 455L: return "SIMD_PARTIAL_STORE";
            case 456L: return "SIMD_SCALAR_STORE";
            case 457L: return "SIMD_GATHER";
            case 458L: return "SIMD_SCATTER";
            case 459L: return "SIZEOF_OP";
            case 460L: return "ALIGNOF_OP";
            case 461L: return "SourceFileTag";
            case 462L: return "SPACESHIP_OP";
            case 463L: return "SPAWN_STMT";
            case 464L: return "SYNC_ALL_STATEMENT";
            case 465L: return "SYNC_IMAGES_STATEMENT";
            case 466L: return "SYNC_MEMORY_STATEMENT";
            case 467L: return "SYNC_TEAM_STATEMENT";
            case 468L: return "LOCK_STATEMENT";
            case 469L: return "UNLOCK_STATEMENT";
            case 470L: return "PROCESS_CONTROL_STATEMENT";
            case 471L: return "SpecialFunctionModifierTag";
            case 472L: return "StatementTag";
            case 473L: return "STATIC_ASSERTION_DECLARATION";
            case 474L: return "STMT_DECL_STMT";
            case 475L: return "STMT_EXPR";
            case 476L: return "TEMP_Statement_Function_Statement";
            case 478L: return "StorageModifierTag";
            case 479L: return "STR_CONV";
            case 480L: return "StringKeyedBidirectionalGraphTag";
            case 481L: return "STRING_VAL";
            case 482L: return "StructureModifierTag";
            case 483L: return "SUBSCRIPT_EXPR";
            case 484L: return "SUBT_OP";
            case 485L: return "SupportTag";
            case 486L: return "SWITCH_STMT";
            case 487L: return "SymbolTag";
            case 488L: return "SymbolTableTag";
            case 489L: return "TemplateArgumentTag";
            case 490L: return "TemplateArgumentListTag";
            case 491L: return "TEMPLATE_DECL_STMT";
            case 492L: return "TEMPLATE_CLASS_DECL_STMT";
            case 493L: return "TEMPLATE_CLASS_NAME";
            case 494L: return "TEMPLATE_FUNCTION_DECL_STMT";
            case 495L: return "TEMPLATE_FUNCTION_REF";
            case 496L: return "TEMPLATE_FUNC_NAME";
            case 497L: return "TEMPLATE_MEMBER_FUNCTION_DECL_STMT";
            case 498L: return "TEMPLATE_MEMBER_FUNCTION_REF";
            case 499L: return "TEMPLATE_MEMBER_FUNC_NAME";
            case 500L: return "TEMPLATE_TYPEDEF_DECL_STMT";
            case 501L: return "TEMPLATE_TYPEDEF_NAME";
            case 502L: return "TEMPLATE_VARIABLE_DECL_STMT";
            case 503L: return "TEMPLATE_VARIABLE_NAME";
            case 504L: return "TEMPLATE_CLASS_DEF_STMT";
            case 505L: return "TEMPLATE_FUNCTION_DEF_STMT";
            case 506L: return "TEMPLATE_INST_DECL_STMT";
            case 507L: return "TEMPLATE_INST_DEFN_STMT";
            case 508L: return "TEMPLATE_INST_DIRECTIVE_STMT";
            case 509L: return "TEMPLATE_INST_FUNCTION_DECL_STMT";
            case 510L: return "TEMPLATE_INST_MEMBER_FUNCTION_DECL_STMT";
            case 511L: return "TEMPLATE_INST_TYPEDEF_DECL_STMT";
            case 512L: return "TemplateParameterTag";
            case 513L: return "TEMPLATE_PARAMETER_VAL";
            case 514L: return "TemplateParameterListTag";
            case 515L: return "TEMPLATE_NAME";
            case 516L: return "T_TEMPLATE";
            case 517L: return "THIS_NODE";
            case 518L: return "TYPE_TRAIT_BUILTIN_OPERATOR";
            case 519L: return "SUPER_NODE";
            case 520L: return "THROW_OP";
            case 521L: return "TOKEN";
            case 522L: return "TRY_STMT";
            case 523L: return "TUPLE_EXP";
            case 524L: return "TypeTag";
            case 525L: return "T_BOOL";
            case 526L: return "T_CHAR";
            case 527L: return "T_CHAR16";
            case 528L: return "T_CHAR32";
            case 529L: return "T_COMPLEX";
            case 530L: return "T_DEFAULT";
            case 531L: return "TYPE_EXPRESSION";
            case 532L: return "T_LABEL";
            case 533L: return "T_DOUBLE";
            case 534L: return "T_ELLIPSE";
            case 535L: return "T_FIXED";
            case 536L: return "T_FLOAT";
            case 537L: return "T_FLOAT128";
            case 538L: return "T_FLOAT80";
            case 539L: return "T_GLOBAL_VOID";
            case 540L: return "TYPEID_OP";
            case 541L: return "T_IMAGINARY";
            case 542L: return "T_INT";
            case 543L: return "T_LONG";
            case 544L: return "T_LONG_DOUBLE";
            case 545L: return "T_LONG_LONG";
            case 546L: return "TypeModifierTag";
            case 547L: return "T_MATRIX";
            case 548L: return "T_TUPLE";
            case 549L: return "T_NULLPTR";
            case 550L: return "T_TYPEOF_TYPE";
            case 551L: return "T_SHORT";
            case 552L: return "T_SIGNED_128BIT_INTEGER";
            case 553L: return "T_SIGNED_CHAR";
            case 554L: return "T_SIGNED_INT";
            case 555L: return "T_SIGNED_LONG";
            case 556L: return "T_SIGNED_LONG_LONG";
            case 557L: return "T_SIGNED_SHORT";
            case 558L: return "T_STRING";
            case 559L: return "T_UNKNOWN";
            case 560L: return "T_UNSIGNED_128BIT_INTEGER";
            case 561L: return "T_UNSIGNED_CHAR";
            case 562L: return "T_UNSIGNED_INT";
            case 563L: return "T_UNSIGNED_LONG";
            case 564L: return "T_UNSIGNED_LONG_LONG";
            case 565L: return "T_UNSIGNED_SHORT";
            case 566L: return "T_VOID";
            case 567L: return "T_WCHAR";
            case 568L: return "TYPEDEF_STMT";
            case 569L: return "T_TYPEDEF_SEQ";
            case 570L: return "TYPEDEF_NAME";
            case 571L: return "T_TYPEDEF";
            case 572L: return "UPC_AccessModifierTag";
            case 573L: return "UNARY_ADD_OP";
            case 574L: return "UNARY_EXPRESSION";
            case 575L: return "UNDEF_DIRECTIVE_STMT";
            case 576L: return "UndirectedGraphEdgeTag";
            case 577L: return "TEMP_UnknownArrayOrFunctionReference";
            case 578L: return "UnknownFileTag";
            case 580L: return "Unparse_InfoTag";
            case 581L: return "UNSIGNED_CHAR_VAL";
            case 582L: return "UNSIGNED_INT_VAL";
            case 583L: return "UNSIGNED_LONG_LONG_INT_VAL";
            case 584L: return "UNSIGNED_LONG_INT_VAL";
            case 585L: return "UNSIGNED_SHORT_VAL";
            case 586L: return "UntypedNodeTag";
            case 587L: return "UntypedExpressionTag";
            case 588L: return "TEMP_UntypedUnaryOperator";
            case 589L: return "TEMP_UntypedBinaryOperator";
            case 590L: return "TEMP_UntypedValueExpression";
            case 591L: return "TEMP_UntypedArrayReferenceExpression";
            case 592L: return "TEMP_UntypedSubscriptExpression";
            case 593L: return "TEMP_UntypedOtherExpression";
            case 594L: return "TEMP_UntypedNamedExpression";
            case 595L: return "TEMP_UntypedNullExpression";
            case 596L: return "TEMP_UntypedExprListExpression";
            case 597L: return "TEMP_UntypedFunctionCallOrArrayReferenceExpression";
            case 598L: return "UntypedStatementTag";
            case 599L: return "TEMP_UntypedLabelStatement";
            case 600L: return "TEMP_UntypedNamedStatement";
            case 601L: return "TEMP_UntypedAssignmentStatement";
            case 602L: return "TEMP_UntypedBlockStatement";
            case 603L: return "TEMP_UntypedExpressionStatement";
            case 604L: return "TEMP_UntypedForAllStatement";
            case 605L: return "TEMP_UntypedFunctionCallStatement";
            case 606L: return "TEMP_UntypedImageControlStatement";
            case 607L: return "TEMP_UntypedOtherStatement";
            case 608L: return "TEMP_UntypedUseStatement";
            case 609L: return "UntypedDeclarationStatementTag";
            case 610L: return "TEMP_UntypedDirectiveDeclaration";
            case 611L: return "TEMP_UntypedEnumDeclaration";
            case 612L: return "TEMP_UntypedInitializedName";
            case 613L: return "TEMP_UntypedName";
            case 614L: return "TEMP_UntypedNameListDeclaration";
            case 615L: return "TEMP_UntypedInitializedNameListDeclaration";
            case 616L: return "TEMP_UntypedImplicitDeclaration";
            case 617L: return "TEMP_UntypedVariableDeclaration";
            case 618L: return "TEMP_UntypedTypedefDeclaration";
            case 619L: return "TEMP_UntypedProgramHeaderDeclaration";
            case 620L: return "UntypedFunctionDeclarationTag";
            case 621L: return "TEMP_UntypedSubroutineDeclaration";
            case 622L: return "TEMP_UntypedInterfaceDeclaration";
            case 623L: return "TEMP_UntypedNullDeclaration";
            case 624L: return "TEMP_UntypedNullStatement";
            case 625L: return "TEMP_UntypedIfStatement";
            case 626L: return "TEMP_UntypedCaseStatement";
            case 627L: return "TEMP_UntypedLoopStatement";
            case 628L: return "TEMP_UntypedWhileStatement";
            case 629L: return "TEMP_UntypedForStatement";
            case 630L: return "TEMP_UntypedExitStatement";
            case 631L: return "TEMP_UntypedGotoStatement";
            case 632L: return "TEMP_UntypedProcedureCallStatement";
            case 633L: return "TEMP_UntypedReturnStatement";
            case 634L: return "TEMP_UntypedExtendedReturnStatement";
            case 635L: return "TEMP_UntypedStopStatement";
            case 636L: return "TEMP_UntypedAcceptStatement";
            case 637L: return "TEMP_UntypedEntryCallStatement";
            case 638L: return "TEMP_UntypedRequeueStatement";
            case 639L: return "TEMP_UntypedDelayUntilStatement";
            case 640L: return "TEMP_UntypedDelayRelativeStatement";
            case 641L: return "TEMP_UntypedTerminateAlternativeStatement";
            case 642L: return "TEMP_UntypedSelectiveAcceptStatement";
            case 643L: return "TEMP_UntypedTimedEntryCallStatement";
            case 644L: return "TEMP_UntypedConditionalEntryCallStatement";
            case 645L: return "TEMP_UntypedAsynchronousSelectStatement";
            case 646L: return "TEMP_UntypedAbortStatement";
            case 647L: return "TEMP_UntypedRaiseStatement";
            case 648L: return "TEMP_UntypedCodeStatement";
            case 649L: return "TEMP_UntypedReferenceExpression";
            case 650L: return "TEMP_UntypedToken";
            case 651L: return "TEMP_UntypedTokenPair";
            case 652L: return "UntypedTypeTag";
            case 653L: return "TEMP_UntypedArrayType";
            case 654L: return "TEMP_UntypedTableType";
            case 655L: return "TEMP_UntypedAttribute";
            case 656L: return "TEMP_UntypedFile";
            case 657L: return "UntypedScopeTag";
            case 658L: return "TEMP_UntypedFunctionScope";
            case 659L: return "TEMP_UntypedModuleScope";
            case 660L: return "TEMP_UntypedGlobalScope";
            case 661L: return "TEMP_UntypedModuleDeclaration";
            case 662L: return "TEMP_UntypedSubmoduleDeclaration";
            case 663L: return "TEMP_UntypedBlockDataDeclaration";
            case 664L: return "TEMP_UntypedStructureDeclaration";
            case 665L: return "TEMP_UntypedStructureDefinition";
            case 666L: return "TEMP_UntypedPackageDeclaration";
            case 667L: return "TEMP_UntypedExceptionDeclaration";
            case 668L: return "TEMP_UntypedExceptionHandlerDeclaration";
            case 669L: return "TEMP_UntypedTaskDeclaration";
            case 670L: return "TEMP_UntypedUnitDeclaration";
            case 671L: return "TEMP_UntypedStatementList";
            case 672L: return "TEMP_UntypedDeclarationStatementList";
            case 673L: return "TEMP_UntypedFunctionDeclarationList";
            case 674L: return "TEMP_UntypedInitializedNameList";
            case 675L: return "TEMP_UntypedNameList";
            case 676L: return "TEMP_UntypedTokenList";
            case 677L: return "TEMP_UntypedTokenPairList";
            case 678L: return "UPC_BARRIER_STMT";
            case 679L: return "UPC_BLOCK_SIZEOF_EXPR";
            case 680L: return "UPC_ELEM_SIZEOF_EXPR";
            case 681L: return "UPC_FENCE_STMT";
            case 682L: return "UPC_FORALL_STMT";
            case 683L: return "UPC_LOCAL_SIZEOF_EXPR";
            case 684L: return "UPC_MYTHREAD";
            case 685L: return "UPC_NOTIFY_STMT";
            case 686L: return "UPC_THREADS";
            case 687L: return "UPC_WAIT_STMT";
            case 688L: return "USE_STATEMENT";
            case 689L: return "USER_DEFINED_BINARY_OP";
            case 690L: return "USER_DEFINED_UNARY_OP";
            case 691L: return "USING_DECLARATION_STMT";
            case 692L: return "USING_DIRECTIVE_STMT";
            case 693L: return "ValueExpTag";
            case 694L: return "VA_COPY_OP";
            case 695L: return "VA_END_OP";
            case 696L: return "VA_OP";
            case 697L: return "VA_START_ONE_OPERAND_OP";
            case 698L: return "VA_START_OP";
            case 699L: return "VAR_REF";
            case 700L: return "VAR_DECL_STMT";
            case 701L: return "VAR_DEFN_STMT";
            case 702L: return "VARIABLE_NAME";
            case 703L: return "VARIANT_EXPR";
            case 704L: return "VARIANT_STMT";
            case 705L: return "VOID_VAL";
            case 706L: return "WAIT_STATEMENT";
            case 707L: return "WARNING_DIRECTIVE_STMT";
            case 708L: return "WITH_STATEMENT";
            case 709L: return "WCHAR_VAL";
            case 710L: return "TEMP_Where_Statement";
            case 711L: return "WHILE_STMT";
            case 712L: return "WRITE_STATEMENT";
            case 713L: return "XOR_ASSIGN_OP";
            case 714L: return "YIELD_EXP";
            case 715L: return "_File_InfoTag";
            case 716L: return "T_CAFTEAM";
            case 717L: return "WITHTEAM_STMT";
            case 718L: return "COARRAY_REF_EXPR";
            case 719L: return "CALL_EXPRESSION";
            case 720L: return "T_CRAY_POINTER";
            case 721L: return "CLASS_NODE";
            case 723L: return "Cxx_Grammar_UNKNOWN_GRAMMAR";
            case 724L: return "Cxx_Grammar_LAST_TAG";
            default: return "";
        }
    }

    std::string Cxx_GrammarVariants(int64_t i, const std::string &strip) {
        std::string s = Cxx_GrammarVariants(i);
        if (s.empty())
            s = "(Cxx_GrammarVariants)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Cxx_GrammarVariants() {
        static const int64_t values[] = {
            1L,
            2L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L,
            58L,
            59L,
            60L,
            61L,
            62L,
            63L,
            64L,
            65L,
            66L,
            67L,
            68L,
            69L,
            70L,
            71L,
            73L,
            74L,
            75L,
            76L,
            77L,
            78L,
            79L,
            80L,
            81L,
            82L,
            83L,
            84L,
            85L,
            86L,
            87L,
            88L,
            89L,
            90L,
            91L,
            92L,
            93L,
            94L,
            95L,
            96L,
            97L,
            98L,
            99L,
            100L,
            101L,
            102L,
            104L,
            106L,
            107L,
            108L,
            109L,
            110L,
            111L,
            112L,
            113L,
            114L,
            115L,
            116L,
            117L,
            118L,
            119L,
            120L,
            121L,
            122L,
            123L,
            124L,
            125L,
            126L,
            127L,
            128L,
            129L,
            130L,
            131L,
            132L,
            133L,
            134L,
            135L,
            136L,
            137L,
            138L,
            139L,
            140L,
            141L,
            142L,
            143L,
            144L,
            145L,
            146L,
            147L,
            148L,
            149L,
            150L,
            151L,
            152L,
            153L,
            154L,
            155L,
            156L,
            157L,
            158L,
            159L,
            160L,
            161L,
            162L,
            163L,
            164L,
            165L,
            166L,
            167L,
            168L,
            169L,
            170L,
            171L,
            172L,
            173L,
            174L,
            175L,
            176L,
            177L,
            178L,
            179L,
            180L,
            181L,
            182L,
            183L,
            184L,
            185L,
            186L,
            187L,
            188L,
            189L,
            190L,
            191L,
            192L,
            193L,
            194L,
            195L,
            196L,
            197L,
            198L,
            199L,
            200L,
            201L,
            202L,
            203L,
            204L,
            205L,
            206L,
            207L,
            208L,
            209L,
            210L,
            211L,
            212L,
            213L,
            214L,
            215L,
            216L,
            217L,
            218L,
            219L,
            220L,
            221L,
            222L,
            223L,
            224L,
            225L,
            226L,
            227L,
            228L,
            229L,
            230L,
            231L,
            232L,
            233L,
            234L,
            235L,
            236L,
            237L,
            238L,
            239L,
            240L,
            241L,
            242L,
            243L,
            244L,
            245L,
            246L,
            247L,
            248L,
            249L,
            250L,
            251L,
            252L,
            253L,
            254L,
            255L,
            256L,
            257L,
            258L,
            259L,
            260L,
            261L,
            262L,
            263L,
            264L,
            265L,
            266L,
            267L,
            268L,
            269L,
            270L,
            271L,
            272L,
            273L,
            274L,
            275L,
            276L,
            277L,
            278L,
            279L,
            280L,
            281L,
            282L,
            283L,
            284L,
            285L,
            286L,
            287L,
            288L,
            289L,
            290L,
            291L,
            292L,
            293L,
            294L,
            295L,
            296L,
            297L,
            298L,
            299L,
            300L,
            301L,
            302L,
            303L,
            304L,
            305L,
            306L,
            307L,
            308L,
            309L,
            310L,
            311L,
            312L,
            313L,
            314L,
            315L,
            316L,
            317L,
            318L,
            319L,
            320L,
            321L,
            322L,
            323L,
            324L,
            325L,
            326L,
            327L,
            328L,
            329L,
            330L,
            331L,
            332L,
            333L,
            334L,
            335L,
            336L,
            337L,
            338L,
            339L,
            340L,
            341L,
            342L,
            343L,
            344L,
            345L,
            346L,
            347L,
            348L,
            349L,
            350L,
            351L,
            352L,
            353L,
            354L,
            355L,
            356L,
            357L,
            358L,
            359L,
            360L,
            361L,
            362L,
            363L,
            364L,
            365L,
            366L,
            367L,
            368L,
            369L,
            370L,
            371L,
            372L,
            373L,
            374L,
            375L,
            376L,
            377L,
            378L,
            379L,
            380L,
            381L,
            382L,
            383L,
            384L,
            385L,
            386L,
            387L,
            388L,
            389L,
            390L,
            391L,
            392L,
            393L,
            394L,
            395L,
            396L,
            397L,
            398L,
            399L,
            400L,
            401L,
            402L,
            403L,
            404L,
            405L,
            406L,
            407L,
            408L,
            409L,
            410L,
            411L,
            412L,
            413L,
            414L,
            415L,
            416L,
            417L,
            418L,
            419L,
            420L,
            421L,
            422L,
            425L,
            426L,
            427L,
            428L,
            429L,
            430L,
            431L,
            432L,
            434L,
            435L,
            436L,
            437L,
            438L,
            439L,
            440L,
            441L,
            442L,
            443L,
            444L,
            445L,
            446L,
            447L,
            448L,
            449L,
            450L,
            451L,
            452L,
            453L,
            454L,
            455L,
            456L,
            457L,
            458L,
            459L,
            460L,
            461L,
            462L,
            463L,
            464L,
            465L,
            466L,
            467L,
            468L,
            469L,
            470L,
            471L,
            472L,
            473L,
            474L,
            475L,
            476L,
            478L,
            479L,
            480L,
            481L,
            482L,
            483L,
            484L,
            485L,
            486L,
            487L,
            488L,
            489L,
            490L,
            491L,
            492L,
            493L,
            494L,
            495L,
            496L,
            497L,
            498L,
            499L,
            500L,
            501L,
            502L,
            503L,
            504L,
            505L,
            506L,
            507L,
            508L,
            509L,
            510L,
            511L,
            512L,
            513L,
            514L,
            515L,
            516L,
            517L,
            518L,
            519L,
            520L,
            521L,
            522L,
            523L,
            524L,
            525L,
            526L,
            527L,
            528L,
            529L,
            530L,
            531L,
            532L,
            533L,
            534L,
            535L,
            536L,
            537L,
            538L,
            539L,
            540L,
            541L,
            542L,
            543L,
            544L,
            545L,
            546L,
            547L,
            548L,
            549L,
            550L,
            551L,
            552L,
            553L,
            554L,
            555L,
            556L,
            557L,
            558L,
            559L,
            560L,
            561L,
            562L,
            563L,
            564L,
            565L,
            566L,
            567L,
            568L,
            569L,
            570L,
            571L,
            572L,
            573L,
            574L,
            575L,
            576L,
            577L,
            578L,
            580L,
            581L,
            582L,
            583L,
            584L,
            585L,
            586L,
            587L,
            588L,
            589L,
            590L,
            591L,
            592L,
            593L,
            594L,
            595L,
            596L,
            597L,
            598L,
            599L,
            600L,
            601L,
            602L,
            603L,
            604L,
            605L,
            606L,
            607L,
            608L,
            609L,
            610L,
            611L,
            612L,
            613L,
            614L,
            615L,
            616L,
            617L,
            618L,
            619L,
            620L,
            621L,
            622L,
            623L,
            624L,
            625L,
            626L,
            627L,
            628L,
            629L,
            630L,
            631L,
            632L,
            633L,
            634L,
            635L,
            636L,
            637L,
            638L,
            639L,
            640L,
            641L,
            642L,
            643L,
            644L,
            645L,
            646L,
            647L,
            648L,
            649L,
            650L,
            651L,
            652L,
            653L,
            654L,
            655L,
            656L,
            657L,
            658L,
            659L,
            660L,
            661L,
            662L,
            663L,
            664L,
            665L,
            666L,
            667L,
            668L,
            669L,
            670L,
            671L,
            672L,
            673L,
            674L,
            675L,
            676L,
            677L,
            678L,
            679L,
            680L,
            681L,
            682L,
            683L,
            684L,
            685L,
            686L,
            687L,
            688L,
            689L,
            690L,
            691L,
            692L,
            693L,
            694L,
            695L,
            696L,
            697L,
            698L,
            699L,
            700L,
            701L,
            702L,
            703L,
            704L,
            705L,
            706L,
            707L,
            708L,
            709L,
            710L,
            711L,
            712L,
            713L,
            714L,
            715L,
            716L,
            717L,
            718L,
            719L,
            720L,
            721L,
            723L,
            724L
        };
        static const std::vector<int64_t> retval(values, values + 713);
        return retval;
    }

}

namespace Rose {
    std::string stringifyCxx_GrammarVariants(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Cxx_GrammarVariants(i);
        if (retval.empty()) {
            retval = "(Cxx_GrammarVariants)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Cxx_GrammarVariants::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyCxx_GrammarVariants() {
        return stringify::Cxx_GrammarVariants();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 734
namespace stringify {
    const char* VariantT(int64_t i) {
        switch (i) {
            case 1L: return "V_SgAccessModifier";
            case 2L: return "V_SgActualArgumentExpression";
            case 4L: return "V_SgAddOp";
            case 5L: return "V_SgAddressOfOp";
            case 6L: return "V_SgAggregateInitializer";
            case 7L: return "V_SgAliasSymbol";
            case 8L: return "V_SgAllocateStatement";
            case 9L: return "V_SgAndAssignOp";
            case 10L: return "V_SgAndOp";
            case 11L: return "V_SgArithmeticIfStatement";
            case 12L: return "V_SgArrayType";
            case 13L: return "V_SgArrowExp";
            case 14L: return "V_SgArrowStarOp";
            case 15L: return "V_SgAsmOp";
            case 16L: return "V_SgAsmStmt";
            case 17L: return "V_SgAssertStmt";
            case 18L: return "V_SgAssignInitializer";
            case 19L: return "V_SgAssignOp";
            case 20L: return "V_SgAssignStatement";
            case 21L: return "V_SgAssignedGotoStatement";
            case 22L: return "V_SgAssociateStatement";
            case 23L: return "V_SgAsteriskShapeExp";
            case 24L: return "V_SgAttribute";
            case 25L: return "V_SgAttributeSpecificationStatement";
            case 26L: return "V_SgAutoType";
            case 27L: return "V_SgAwaitExpression";
            case 28L: return "V_SgBackspaceStatement";
            case 29L: return "V_SgBaseClass";
            case 30L: return "V_SgExpBaseClass";
            case 31L: return "V_SgBaseClassModifier";
            case 32L: return "V_SgBasicBlock";
            case 33L: return "V_SgBidirectionalGraph";
            case 35L: return "V_SgBinaryOp";
            case 36L: return "V_SgBitAndOp";
            case 37L: return "V_SgBitAttribute";
            case 38L: return "V_SgBitComplementOp";
            case 39L: return "V_SgBitEqvOp";
            case 40L: return "V_SgBitOrOp";
            case 41L: return "V_SgBitXorOp";
            case 42L: return "V_SgBlockDataStatement";
            case 43L: return "V_SgBoolValExp";
            case 44L: return "V_SgBreakStmt";
            case 45L: return "V_SgBracedInitializer";
            case 46L: return "V_SgC_PreprocessorDirectiveStatement";
            case 47L: return "V_SgCaseOptionStmt";
            case 48L: return "V_SgCastExp";
            case 49L: return "V_SgCatchOptionStmt";
            case 50L: return "V_SgCatchStatementSeq";
            case 51L: return "V_SgCharVal";
            case 52L: return "V_SgChar16Val";
            case 53L: return "V_SgChar32Val";
            case 54L: return "V_SgChooseExpression";
            case 55L: return "V_SgClassDecl_attr";
            case 56L: return "V_SgClassDeclaration";
            case 57L: return "V_SgClassDefinition";
            case 58L: return "V_SgClassNameRefExp";
            case 59L: return "V_SgClassSymbol";
            case 60L: return "V_SgClassType";
            case 61L: return "V_SgClinkageDeclarationStatement";
            case 62L: return "V_SgClinkageEndStatement";
            case 63L: return "V_SgClinkageStartStatement";
            case 64L: return "V_SgCloseStatement";
            case 65L: return "V_SgColonShapeExp";
            case 66L: return "V_SgCommaOpExp";
            case 67L: return "V_SgCommonBlock";
            case 68L: return "V_SgCommonBlockObject";
            case 69L: return "V_SgCommonSymbol";
            case 70L: return "V_SgComplexVal";
            case 71L: return "V_SgComprehension";
            case 73L: return "V_SgCompoundAssignOp";
            case 74L: return "V_SgCompoundInitializer";
            case 75L: return "V_SgCompoundLiteralExp";
            case 76L: return "V_SgComputedGotoStatement";
            case 77L: return "V_SgConcatenationOp";
            case 78L: return "V_SgConditionalExp";
            case 79L: return "V_SgConjugateOp";
            case 80L: return "V_SgConstVolatileModifier";
            case 81L: return "V_SgConstructorInitializer";
            case 82L: return "V_SgContainsStatement";
            case 83L: return "V_SgContinueStmt";
            case 84L: return "V_SgCtorInitializerList";
            case 85L: return "V_SgDataStatementGroup";
            case 86L: return "V_SgDataStatementObject";
            case 87L: return "V_SgDataStatementValue";
            case 88L: return "V_SgDeadIfDirectiveStatement";
            case 89L: return "V_SgDeallocateStatement";
            case 90L: return "V_SgDeclarationModifier";
            case 91L: return "V_SgDeclarationScope";
            case 92L: return "V_SgDeclarationStatement";
            case 93L: return "V_SgDeclType";
            case 94L: return "V_SgDefaultOptionStmt";
            case 95L: return "V_SgDefaultSymbol";
            case 96L: return "V_SgDefineDirectiveStatement";
            case 97L: return "V_SgDeleteExp";
            case 98L: return "V_SgDerivedTypeStatement";
            case 99L: return "V_SgDesignatedInitializer";
            case 100L: return "V_SgDictionaryComprehension";
            case 101L: return "V_SgDictionaryExp";
            case 102L: return "V_SgDimensionObject";
            case 104L: return "V_SgDirectedGraphEdge";
            case 106L: return "V_SgDirectory";
            case 107L: return "V_SgDirectoryList";
            case 108L: return "V_SgDivAssignOp";
            case 109L: return "V_SgDivideOp";
            case 110L: return "V_SgDoWhileStmt";
            case 111L: return "V_SgDotExp";
            case 112L: return "V_SgDotStarOp";
            case 113L: return "V_SgDoubleVal";
            case 114L: return "V_SgElaboratedTypeModifier";
            case 115L: return "V_SgElementwiseOp";
            case 116L: return "V_SgElementwiseAddOp";
            case 117L: return "V_SgElementwiseDivideOp";
            case 118L: return "V_SgElementwiseLeftDivideOp";
            case 119L: return "V_SgElementwiseMultiplyOp";
            case 120L: return "V_SgElementwisePowerOp";
            case 121L: return "V_SgElementwiseSubtractOp";
            case 122L: return "V_SgElseDirectiveStatement";
            case 123L: return "V_SgElseWhereStatement";
            case 124L: return "V_SgElseifDirectiveStatement";
            case 125L: return "V_SgEmptyDeclaration";
            case 126L: return "V_SgEmptyDirectiveStatement";
            case 127L: return "V_SgEndfileStatement";
            case 128L: return "V_SgEndifDirectiveStatement";
            case 129L: return "V_SgEntryStatement";
            case 130L: return "V_SgEnumDeclaration";
            case 131L: return "V_SgEnumFieldSymbol";
            case 132L: return "V_SgEnumSymbol";
            case 133L: return "V_SgEnumType";
            case 134L: return "V_SgEnumVal";
            case 135L: return "V_SgEqualityOp";
            case 136L: return "V_SgEquivalenceStatement";
            case 137L: return "V_SgErrorDirectiveStatement";
            case 138L: return "V_SgExecStatement";
            case 139L: return "V_SgExponentiationOp";
            case 140L: return "V_SgExponentiationAssignOp";
            case 141L: return "V_SgExprListExp";
            case 142L: return "V_SgExprStatement";
            case 143L: return "V_SgExpression";
            case 144L: return "V_SgExpressionRoot";
            case 145L: return "V_SgFile";
            case 146L: return "V_SgFileList";
            case 147L: return "V_SgFloatVal";
            case 148L: return "V_SgFloat128Val";
            case 149L: return "V_SgFloat80Val";
            case 150L: return "V_SgFoldExpression";
            case 151L: return "V_SgFlushStatement";
            case 152L: return "V_SgForAllStatement";
            case 153L: return "V_SgForInitStatement";
            case 154L: return "V_SgForStatement";
            case 155L: return "V_SgFormatItem";
            case 156L: return "V_SgFormatItemList";
            case 157L: return "V_SgFormatStatement";
            case 158L: return "V_SgFortranDo";
            case 159L: return "V_SgFortranIncludeLine";
            case 160L: return "V_SgFortranNonblockedDo";
            case 161L: return "V_SgFuncDecl_attr";
            case 162L: return "V_SgFunctionCallExp";
            case 163L: return "V_SgFunctionDeclaration";
            case 164L: return "V_SgFunctionDefinition";
            case 165L: return "V_SgFunctionParameterScope";
            case 166L: return "V_SgFunctionModifier";
            case 167L: return "V_SgFunctionParameterList";
            case 168L: return "V_SgFunctionParameterRefExp";
            case 169L: return "V_SgFunctionParameterTypeList";
            case 170L: return "V_SgFunctionRefExp";
            case 171L: return "V_SgFunctionSymbol";
            case 172L: return "V_SgFunctionType";
            case 173L: return "V_SgFunctionTypeSymbol";
            case 174L: return "V_SgFunctionTypeTable";
            case 175L: return "V_SgTypeTable";
            case 176L: return "V_SgGlobal";
            case 177L: return "V_SgGotoStatement";
            case 178L: return "V_SgGraph";
            case 179L: return "V_SgGraphEdge";
            case 180L: return "V_SgGraphEdgeList";
            case 181L: return "V_SgGraphNode";
            case 182L: return "V_SgGraphNodeList";
            case 183L: return "V_SgGreaterOrEqualOp";
            case 184L: return "V_SgGreaterThanOp";
            case 185L: return "V_SgIOItemExpression";
            case 186L: return "V_SgIOStatement";
            case 187L: return "V_SgIdentDirectiveStatement";
            case 188L: return "V_SgIfDirectiveStatement";
            case 189L: return "V_SgIfStmt";
            case 190L: return "V_SgIfdefDirectiveStatement";
            case 191L: return "V_SgIfndefDirectiveStatement";
            case 192L: return "V_SgImageControlStatement";
            case 193L: return "V_SgImagPartOp";
            case 194L: return "V_SgImplicitStatement";
            case 195L: return "V_SgImpliedDo";
            case 196L: return "V_SgImportStatement";
            case 197L: return "V_SgIncidenceDirectedGraph";
            case 198L: return "V_SgIncidenceUndirectedGraph";
            case 199L: return "V_SgIncludeDirectiveStatement";
            case 200L: return "V_SgIncludeFile";
            case 201L: return "V_SgIncludeNextDirectiveStatement";
            case 202L: return "V_SgInitializedName";
            case 203L: return "V_SgInitializer";
            case 204L: return "V_SgInquireStatement";
            case 205L: return "V_SgIntKeyedBidirectionalGraph";
            case 206L: return "V_SgIntVal";
            case 207L: return "V_SgIntegerDivideOp";
            case 208L: return "V_SgIntegerDivideAssignOp";
            case 209L: return "V_SgInterfaceBody";
            case 210L: return "V_SgHeaderFileBody";
            case 211L: return "V_SgHeaderFileReport";
            case 212L: return "V_SgInterfaceStatement";
            case 213L: return "V_SgInterfaceSymbol";
            case 214L: return "V_SgIntrinsicSymbol";
            case 215L: return "V_SgIsOp";
            case 216L: return "V_SgIsNotOp";
            case 217L: return "V_SgIorAssignOp";
            case 218L: return "V_SgKeyDatumPair";
            case 219L: return "V_SgCudaKernelExecConfig";
            case 220L: return "V_SgCudaKernelCallExp";
            case 221L: return "V_SgLabelRefExp";
            case 222L: return "V_SgLabelStatement";
            case 223L: return "V_SgLabelSymbol";
            case 224L: return "V_SgLambdaCapture";
            case 225L: return "V_SgLambdaCaptureList";
            case 226L: return "V_SgLambdaExp";
            case 227L: return "V_SgLambdaRefExp";
            case 228L: return "V_SgLeftDivideOp";
            case 229L: return "V_SgLessOrEqualOp";
            case 230L: return "V_SgLessThanOp";
            case 231L: return "V_SgLineDirectiveStatement";
            case 232L: return "V_SgLinemarkerDirectiveStatement";
            case 233L: return "V_SgLinkageModifier";
            case 234L: return "V_SgListComprehension";
            case 235L: return "V_SgListExp";
            case 236L: return "V_SgLocatedNode";
            case 237L: return "V_SgLocatedNodeSupport";
            case 238L: return "V_SgLongDoubleVal";
            case 239L: return "V_SgLongIntVal";
            case 240L: return "V_SgLongLongIntVal";
            case 241L: return "V_SgLshiftAssignOp";
            case 242L: return "V_SgLshiftOp";
            case 243L: return "V_SgMagicColonExp";
            case 244L: return "V_SgMatrixExp";
            case 245L: return "V_SgMatrixTransposeOp";
            case 246L: return "V_SgMemberFunctionDeclaration";
            case 247L: return "V_SgMemberFunctionRefExp";
            case 248L: return "V_SgMemberFunctionSymbol";
            case 249L: return "V_SgMemberFunctionType";
            case 250L: return "V_SgMembershipOp";
            case 251L: return "V_SgMicrosoftAttributeDeclaration";
            case 252L: return "V_SgMinusAssignOp";
            case 253L: return "V_SgMinusMinusOp";
            case 254L: return "V_SgMinusOp";
            case 255L: return "V_SgModAssignOp";
            case 256L: return "V_SgModOp";
            case 257L: return "V_SgModifier";
            case 258L: return "V_SgModifierNodes";
            case 259L: return "V_SgModifierType";
            case 260L: return "V_SgModuleStatement";
            case 261L: return "V_SgModuleSymbol";
            case 262L: return "V_SgMultAssignOp";
            case 263L: return "V_SgMultiplyOp";
            case 264L: return "V_SgName";
            case 265L: return "V_SgNameGroup";
            case 266L: return "V_SgNamedType";
            case 267L: return "V_SgNamelistStatement";
            case 268L: return "V_SgNamespaceAliasDeclarationStatement";
            case 269L: return "V_SgNamespaceDeclarationStatement";
            case 270L: return "V_SgNamespaceDefinitionStatement";
            case 271L: return "V_SgNamespaceSymbol";
            case 272L: return "V_SgNaryOp";
            case 273L: return "V_SgNaryBooleanOp";
            case 274L: return "V_SgNaryComparisonOp";
            case 275L: return "V_SgNewExp";
            case 276L: return "V_SgNode";
            case 277L: return "V_SgNoexceptOp";
            case 278L: return "V_SgNotEqualOp";
            case 279L: return "V_SgNotOp";
            case 280L: return "V_SgNonMembershipOp";
            case 281L: return "V_SgNonrealDecl";
            case 282L: return "V_SgNonrealRefExp";
            case 283L: return "V_SgNonrealSymbol";
            case 284L: return "V_SgNonrealType";
            case 285L: return "V_SgNonrealBaseClass";
            case 286L: return "V_SgNullExpression";
            case 287L: return "V_SgNullptrValExp";
            case 288L: return "V_SgNullStatement";
            case 289L: return "V_SgNullifyStatement";
            case 290L: return "V_SgOmpAtomicStatement";
            case 291L: return "V_SgOmpBarrierStatement";
            case 292L: return "V_SgOmpCriticalStatement";
            case 293L: return "V_SgOmpClauseBodyStatement";
            case 294L: return "V_SgOmpBodyStatement";
            case 295L: return "V_SgOmpClauseStatement";
            case 296L: return "V_SgOmpDoStatement";
            case 297L: return "V_SgOmpFlushStatement";
            case 298L: return "V_SgOmpDeclareSimdStatement";
            case 299L: return "V_SgOmpForStatement";
            case 300L: return "V_SgOmpForSimdStatement";
            case 301L: return "V_SgOmpMasterStatement";
            case 302L: return "V_SgOmpTaskyieldStatement";
            case 303L: return "V_SgOmpMetadirectiveStatement";
            case 304L: return "V_SgOmpOrderedStatement";
            case 305L: return "V_SgOmpParallelStatement";
            case 306L: return "V_SgOmpTeamsStatement";
            case 307L: return "V_SgOmpCancellationPointStatement";
            case 308L: return "V_SgOmpDeclareMapperStatement";
            case 309L: return "V_SgOmpCancelStatement";
            case 310L: return "V_SgOmpTaskgroupStatement";
            case 311L: return "V_SgOmpDepobjStatement";
            case 312L: return "V_SgOmpDistributeStatement";
            case 313L: return "V_SgOmpLoopStatement";
            case 314L: return "V_SgOmpScanStatement";
            case 315L: return "V_SgOmpTaskloopStatement";
            case 316L: return "V_SgOmpTargetEnterDataStatement";
            case 317L: return "V_SgOmpTargetExitDataStatement";
            case 318L: return "V_SgOmpSectionStatement";
            case 319L: return "V_SgOmpSectionsStatement";
            case 320L: return "V_SgOmpSingleStatement";
            case 321L: return "V_SgOmpTaskStatement";
            case 322L: return "V_SgOmpTaskwaitStatement";
            case 323L: return "V_SgOmpThreadprivateStatement";
            case 324L: return "V_SgOmpWorkshareStatement";
            case 325L: return "V_SgOmpTargetStatement";
            case 326L: return "V_SgOmpTargetDataStatement";
            case 327L: return "V_SgOmpTargetParallelForStatement";
            case 328L: return "V_SgOmpSimdStatement";
            case 329L: return "V_SgOmpClause";
            case 330L: return "V_SgOmpAllocateClause";
            case 331L: return "V_SgOmpBeginClause";
            case 332L: return "V_SgOmpCollapseClause";
            case 333L: return "V_SgOmpCopyinClause";
            case 334L: return "V_SgOmpCopyprivateClause";
            case 335L: return "V_SgOmpDefaultClause";
            case 336L: return "V_SgOmpEndClause";
            case 337L: return "V_SgOmpExpressionClause";
            case 338L: return "V_SgOmpFirstprivateClause";
            case 339L: return "V_SgOmpIfClause";
            case 340L: return "V_SgOmpFinalClause";
            case 341L: return "V_SgOmpPriorityClause";
            case 342L: return "V_SgOmpDeviceClause";
            case 343L: return "V_SgOmpLastprivateClause";
            case 344L: return "V_SgOmpNowaitClause";
            case 345L: return "V_SgOmpReadClause";
            case 346L: return "V_SgOmpWriteClause";
            case 347L: return "V_SgOmpUpdateClause";
            case 348L: return "V_SgOmpDepobjUpdateClause";
            case 349L: return "V_SgOmpDestroyClause";
            case 350L: return "V_SgOmpCaptureClause";
            case 351L: return "V_SgOmpSeqCstClause";
            case 352L: return "V_SgOmpAcqRelClause";
            case 353L: return "V_SgOmpReleaseClause";
            case 354L: return "V_SgOmpAcquireClause";
            case 355L: return "V_SgOmpRelaxedClause";
            case 356L: return "V_SgOmpParallelClause";
            case 357L: return "V_SgOmpSectionsClause";
            case 358L: return "V_SgOmpForClause";
            case 359L: return "V_SgOmpTaskgroupClause";
            case 360L: return "V_SgOmpNumThreadsClause";
            case 361L: return "V_SgOmpNumTeamsClause";
            case 362L: return "V_SgOmpGrainsizeClause";
            case 363L: return "V_SgOmpDetachClause";
            case 364L: return "V_SgOmpNumTasksClause";
            case 365L: return "V_SgOmpNogroupClause";
            case 366L: return "V_SgOmpHintClause";
            case 367L: return "V_SgOmpOrderClause";
            case 368L: return "V_SgOmpDistScheduleClause";
            case 369L: return "V_SgOmpBindClause";
            case 370L: return "V_SgOmpNontemporalClause";
            case 371L: return "V_SgOmpInclusiveClause";
            case 372L: return "V_SgOmpExclusiveClause";
            case 373L: return "V_SgOmpIsDevicePtrClause";
            case 374L: return "V_SgOmpUseDevicePtrClause";
            case 375L: return "V_SgOmpUseDeviceAddrClause";
            case 376L: return "V_SgOmpThreadLimitClause";
            case 377L: return "V_SgOmpOrderedClause";
            case 378L: return "V_SgOmpPrivateClause";
            case 379L: return "V_SgOmpReductionClause";
            case 380L: return "V_SgOmpInReductionClause";
            case 381L: return "V_SgOmpTaskReductionClause";
            case 382L: return "V_SgOmpDefaultmapClause";
            case 383L: return "V_SgOmpScheduleClause";
            case 384L: return "V_SgOmpSharedClause";
            case 385L: return "V_SgOmpUntiedClause";
            case 386L: return "V_SgOmpMergeableClause";
            case 387L: return "V_SgOmpVariablesClause";
            case 388L: return "V_SgOmpMapClause";
            case 389L: return "V_SgOmpSafelenClause";
            case 390L: return "V_SgOmpSimdlenClause";
            case 391L: return "V_SgOmpLinearClause";
            case 392L: return "V_SgOmpUniformClause";
            case 393L: return "V_SgOmpAlignedClause";
            case 394L: return "V_SgOmpProcBindClause";
            case 395L: return "V_SgOmpAtomicClause";
            case 396L: return "V_SgOmpInbranchClause";
            case 397L: return "V_SgOmpNotinbranchClause";
            case 398L: return "V_SgOmpDependClause";
            case 399L: return "V_SgOmpWhenClause";
            case 400L: return "V_SgOpenclAccessModeModifier";
            case 401L: return "V_SgOpenStatement";
            case 402L: return "V_SgOptions";
            case 403L: return "V_SgOrOp";
            case 404L: return "V_SgParameterStatement";
            case 405L: return "V_SgPartialFunctionModifierType";
            case 406L: return "V_SgPartialFunctionType";
            case 407L: return "V_SgPassStatement";
            case 408L: return "V_SgPlusAssignOp";
            case 409L: return "V_SgPlusPlusOp";
            case 410L: return "V_SgPntrArrRefExp";
            case 411L: return "V_SgPointerAssignOp";
            case 412L: return "V_SgPointerDerefExp";
            case 413L: return "V_SgPointerMemberType";
            case 414L: return "V_SgPointerType";
            case 415L: return "V_SgPowerOp";
            case 416L: return "V_SgPragma";
            case 417L: return "V_SgPragmaDeclaration";
            case 418L: return "V_SgPrintStatement";
            case 419L: return "V_SgProcedureHeaderStatement";
            case 420L: return "V_SgProgramHeaderStatement";
            case 421L: return "V_SgProject";
            case 422L: return "V_SgPseudoDestructorRefExp";
            case 425L: return "V_SgQualifiedName";
            case 426L: return "V_SgQualifiedNameType";
            case 427L: return "V_SgRangeExp";
            case 428L: return "V_SgRangeBasedForStatement";
            case 429L: return "V_SgReadStatement";
            case 430L: return "V_SgRealPartOp";
            case 431L: return "V_SgRefExp";
            case 432L: return "V_SgReferenceType";
            case 434L: return "V_SgRenamePair";
            case 435L: return "V_SgRenameSymbol";
            case 436L: return "V_SgReturnStmt";
            case 437L: return "V_SgRewindStatement";
            case 438L: return "V_SgRshiftAssignOp";
            case 439L: return "V_SgRshiftOp";
            case 440L: return "V_SgRvalueReferenceType";
            case 441L: return "V_SgScopeOp";
            case 442L: return "V_SgScopeStatement";
            case 443L: return "V_SgSequenceStatement";
            case 444L: return "V_SgSetComprehension";
            case 445L: return "V_SgShortVal";
            case 446L: return "V_SgSIMDBinaryOp";
            case 447L: return "V_SgSIMDAddOp";
            case 448L: return "V_SgSIMDSubOp";
            case 449L: return "V_SgSIMDMulOp";
            case 450L: return "V_SgSIMDDivOp";
            case 451L: return "V_SgSIMDFmaOp";
            case 452L: return "V_SgSIMDLoad";
            case 453L: return "V_SgSIMDBroadcast";
            case 454L: return "V_SgSIMDStore";
            case 455L: return "V_SgSIMDPartialStore";
            case 456L: return "V_SgSIMDScalarStore";
            case 457L: return "V_SgSIMDGather";
            case 458L: return "V_SgSIMDScatter";
            case 459L: return "V_SgSizeOfOp";
            case 460L: return "V_SgAlignOfOp";
            case 461L: return "V_SgSourceFile";
            case 462L: return "V_SgSpaceshipOp";
            case 463L: return "V_SgSpawnStmt";
            case 464L: return "V_SgSyncAllStatement";
            case 465L: return "V_SgSyncImagesStatement";
            case 466L: return "V_SgSyncMemoryStatement";
            case 467L: return "V_SgSyncTeamStatement";
            case 468L: return "V_SgLockStatement";
            case 469L: return "V_SgUnlockStatement";
            case 470L: return "V_SgProcessControlStatement";
            case 471L: return "V_SgSpecialFunctionModifier";
            case 472L: return "V_SgStatement";
            case 473L: return "V_SgStaticAssertionDeclaration";
            case 474L: return "V_SgStmtDeclarationStatement";
            case 475L: return "V_SgStatementExpression";
            case 476L: return "V_SgStatementFunctionStatement";
            case 478L: return "V_SgStorageModifier";
            case 479L: return "V_SgStringConversion";
            case 480L: return "V_SgStringKeyedBidirectionalGraph";
            case 481L: return "V_SgStringVal";
            case 482L: return "V_SgStructureModifier";
            case 483L: return "V_SgSubscriptExpression";
            case 484L: return "V_SgSubtractOp";
            case 485L: return "V_SgSupport";
            case 486L: return "V_SgSwitchStatement";
            case 487L: return "V_SgSymbol";
            case 488L: return "V_SgSymbolTable";
            case 489L: return "V_SgTemplateArgument";
            case 490L: return "V_SgTemplateArgumentList";
            case 491L: return "V_SgTemplateDeclaration";
            case 492L: return "V_SgTemplateClassDeclaration";
            case 493L: return "V_SgTemplateClassSymbol";
            case 494L: return "V_SgTemplateFunctionDeclaration";
            case 495L: return "V_SgTemplateFunctionRefExp";
            case 496L: return "V_SgTemplateFunctionSymbol";
            case 497L: return "V_SgTemplateMemberFunctionDeclaration";
            case 498L: return "V_SgTemplateMemberFunctionRefExp";
            case 499L: return "V_SgTemplateMemberFunctionSymbol";
            case 500L: return "V_SgTemplateTypedefDeclaration";
            case 501L: return "V_SgTemplateTypedefSymbol";
            case 502L: return "V_SgTemplateVariableDeclaration";
            case 503L: return "V_SgTemplateVariableSymbol";
            case 504L: return "V_SgTemplateClassDefinition";
            case 505L: return "V_SgTemplateFunctionDefinition";
            case 506L: return "V_SgTemplateInstantiationDecl";
            case 507L: return "V_SgTemplateInstantiationDefn";
            case 508L: return "V_SgTemplateInstantiationDirectiveStatement";
            case 509L: return "V_SgTemplateInstantiationFunctionDecl";
            case 510L: return "V_SgTemplateInstantiationMemberFunctionDecl";
            case 511L: return "V_SgTemplateInstantiationTypedefDeclaration";
            case 512L: return "V_SgTemplateParameter";
            case 513L: return "V_SgTemplateParameterVal";
            case 514L: return "V_SgTemplateParameterList";
            case 515L: return "V_SgTemplateSymbol";
            case 516L: return "V_SgTemplateType";
            case 517L: return "V_SgThisExp";
            case 518L: return "V_SgTypeTraitBuiltinOperator";
            case 519L: return "V_SgSuperExp";
            case 520L: return "V_SgThrowOp";
            case 521L: return "V_SgToken";
            case 522L: return "V_SgTryStmt";
            case 523L: return "V_SgTupleExp";
            case 524L: return "V_SgType";
            case 525L: return "V_SgTypeBool";
            case 526L: return "V_SgTypeChar";
            case 527L: return "V_SgTypeChar16";
            case 528L: return "V_SgTypeChar32";
            case 529L: return "V_SgTypeComplex";
            case 530L: return "V_SgTypeDefault";
            case 531L: return "V_SgTypeExpression";
            case 532L: return "V_SgTypeLabel";
            case 533L: return "V_SgTypeDouble";
            case 534L: return "V_SgTypeEllipse";
            case 535L: return "V_SgTypeFixed";
            case 536L: return "V_SgTypeFloat";
            case 537L: return "V_SgTypeFloat128";
            case 538L: return "V_SgTypeFloat80";
            case 539L: return "V_SgTypeGlobalVoid";
            case 540L: return "V_SgTypeIdOp";
            case 541L: return "V_SgTypeImaginary";
            case 542L: return "V_SgTypeInt";
            case 543L: return "V_SgTypeLong";
            case 544L: return "V_SgTypeLongDouble";
            case 545L: return "V_SgTypeLongLong";
            case 546L: return "V_SgTypeModifier";
            case 547L: return "V_SgTypeMatrix";
            case 548L: return "V_SgTypeTuple";
            case 549L: return "V_SgTypeNullptr";
            case 550L: return "V_SgTypeOfType";
            case 551L: return "V_SgTypeShort";
            case 552L: return "V_SgTypeSigned128bitInteger";
            case 553L: return "V_SgTypeSignedChar";
            case 554L: return "V_SgTypeSignedInt";
            case 555L: return "V_SgTypeSignedLong";
            case 556L: return "V_SgTypeSignedLongLong";
            case 557L: return "V_SgTypeSignedShort";
            case 558L: return "V_SgTypeString";
            case 559L: return "V_SgTypeUnknown";
            case 560L: return "V_SgTypeUnsigned128bitInteger";
            case 561L: return "V_SgTypeUnsignedChar";
            case 562L: return "V_SgTypeUnsignedInt";
            case 563L: return "V_SgTypeUnsignedLong";
            case 564L: return "V_SgTypeUnsignedLongLong";
            case 565L: return "V_SgTypeUnsignedShort";
            case 566L: return "V_SgTypeVoid";
            case 567L: return "V_SgTypeWchar";
            case 568L: return "V_SgTypedefDeclaration";
            case 569L: return "V_SgTypedefSeq";
            case 570L: return "V_SgTypedefSymbol";
            case 571L: return "V_SgTypedefType";
            case 572L: return "V_SgUPC_AccessModifier";
            case 573L: return "V_SgUnaryAddOp";
            case 574L: return "V_SgUnaryOp";
            case 575L: return "V_SgUndefDirectiveStatement";
            case 576L: return "V_SgUndirectedGraphEdge";
            case 577L: return "V_SgUnknownArrayOrFunctionReference";
            case 578L: return "V_SgUnknownFile";
            case 580L: return "V_SgUnparse_Info";
            case 581L: return "V_SgUnsignedCharVal";
            case 582L: return "V_SgUnsignedIntVal";
            case 583L: return "V_SgUnsignedLongLongIntVal";
            case 584L: return "V_SgUnsignedLongVal";
            case 585L: return "V_SgUnsignedShortVal";
            case 586L: return "V_SgUntypedNode";
            case 587L: return "V_SgUntypedExpression";
            case 588L: return "V_SgUntypedUnaryOperator";
            case 589L: return "V_SgUntypedBinaryOperator";
            case 590L: return "V_SgUntypedValueExpression";
            case 591L: return "V_SgUntypedArrayReferenceExpression";
            case 592L: return "V_SgUntypedSubscriptExpression";
            case 593L: return "V_SgUntypedOtherExpression";
            case 594L: return "V_SgUntypedNamedExpression";
            case 595L: return "V_SgUntypedNullExpression";
            case 596L: return "V_SgUntypedExprListExpression";
            case 597L: return "V_SgUntypedFunctionCallOrArrayReferenceExpression";
            case 598L: return "V_SgUntypedStatement";
            case 599L: return "V_SgUntypedLabelStatement";
            case 600L: return "V_SgUntypedNamedStatement";
            case 601L: return "V_SgUntypedAssignmentStatement";
            case 602L: return "V_SgUntypedBlockStatement";
            case 603L: return "V_SgUntypedExpressionStatement";
            case 604L: return "V_SgUntypedForAllStatement";
            case 605L: return "V_SgUntypedFunctionCallStatement";
            case 606L: return "V_SgUntypedImageControlStatement";
            case 607L: return "V_SgUntypedOtherStatement";
            case 608L: return "V_SgUntypedUseStatement";
            case 609L: return "V_SgUntypedDeclarationStatement";
            case 610L: return "V_SgUntypedDirectiveDeclaration";
            case 611L: return "V_SgUntypedEnumDeclaration";
            case 612L: return "V_SgUntypedInitializedName";
            case 613L: return "V_SgUntypedName";
            case 614L: return "V_SgUntypedNameListDeclaration";
            case 615L: return "V_SgUntypedInitializedNameListDeclaration";
            case 616L: return "V_SgUntypedImplicitDeclaration";
            case 617L: return "V_SgUntypedVariableDeclaration";
            case 618L: return "V_SgUntypedTypedefDeclaration";
            case 619L: return "V_SgUntypedProgramHeaderDeclaration";
            case 620L: return "V_SgUntypedFunctionDeclaration";
            case 621L: return "V_SgUntypedSubroutineDeclaration";
            case 622L: return "V_SgUntypedInterfaceDeclaration";
            case 623L: return "V_SgUntypedNullDeclaration";
            case 624L: return "V_SgUntypedNullStatement";
            case 625L: return "V_SgUntypedIfStatement";
            case 626L: return "V_SgUntypedCaseStatement";
            case 627L: return "V_SgUntypedLoopStatement";
            case 628L: return "V_SgUntypedWhileStatement";
            case 629L: return "V_SgUntypedForStatement";
            case 630L: return "V_SgUntypedExitStatement";
            case 631L: return "V_SgUntypedGotoStatement";
            case 632L: return "V_SgUntypedProcedureCallStatement";
            case 633L: return "V_SgUntypedReturnStatement";
            case 634L: return "V_SgUntypedExtendedReturnStatement";
            case 635L: return "V_SgUntypedStopStatement";
            case 636L: return "V_SgUntypedAcceptStatement";
            case 637L: return "V_SgUntypedEntryCallStatement";
            case 638L: return "V_SgUntypedRequeueStatement";
            case 639L: return "V_SgUntypedDelayUntilStatement";
            case 640L: return "V_SgUntypedDelayRelativeStatement";
            case 641L: return "V_SgUntypedTerminateAlternativeStatement";
            case 642L: return "V_SgUntypedSelectiveAcceptStatement";
            case 643L: return "V_SgUntypedTimedEntryCallStatement";
            case 644L: return "V_SgUntypedConditionalEntryCallStatement";
            case 645L: return "V_SgUntypedAsynchronousSelectStatement";
            case 646L: return "V_SgUntypedAbortStatement";
            case 647L: return "V_SgUntypedRaiseStatement";
            case 648L: return "V_SgUntypedCodeStatement";
            case 649L: return "V_SgUntypedReferenceExpression";
            case 650L: return "V_SgUntypedToken";
            case 651L: return "V_SgUntypedTokenPair";
            case 652L: return "V_SgUntypedType";
            case 653L: return "V_SgUntypedArrayType";
            case 654L: return "V_SgUntypedTableType";
            case 655L: return "V_SgUntypedAttribute";
            case 656L: return "V_SgUntypedFile";
            case 657L: return "V_SgUntypedScope";
            case 658L: return "V_SgUntypedFunctionScope";
            case 659L: return "V_SgUntypedModuleScope";
            case 660L: return "V_SgUntypedGlobalScope";
            case 661L: return "V_SgUntypedModuleDeclaration";
            case 662L: return "V_SgUntypedSubmoduleDeclaration";
            case 663L: return "V_SgUntypedBlockDataDeclaration";
            case 664L: return "V_SgUntypedStructureDeclaration";
            case 665L: return "V_SgUntypedStructureDefinition";
            case 666L: return "V_SgUntypedPackageDeclaration";
            case 667L: return "V_SgUntypedExceptionDeclaration";
            case 668L: return "V_SgUntypedExceptionHandlerDeclaration";
            case 669L: return "V_SgUntypedTaskDeclaration";
            case 670L: return "V_SgUntypedUnitDeclaration";
            case 671L: return "V_SgUntypedStatementList";
            case 672L: return "V_SgUntypedDeclarationStatementList";
            case 673L: return "V_SgUntypedFunctionDeclarationList";
            case 674L: return "V_SgUntypedInitializedNameList";
            case 675L: return "V_SgUntypedNameList";
            case 676L: return "V_SgUntypedTokenList";
            case 677L: return "V_SgUntypedTokenPairList";
            case 678L: return "V_SgUpcBarrierStatement";
            case 679L: return "V_SgUpcBlocksizeofExpression";
            case 680L: return "V_SgUpcElemsizeofExpression";
            case 681L: return "V_SgUpcFenceStatement";
            case 682L: return "V_SgUpcForAllStatement";
            case 683L: return "V_SgUpcLocalsizeofExpression";
            case 684L: return "V_SgUpcMythread";
            case 685L: return "V_SgUpcNotifyStatement";
            case 686L: return "V_SgUpcThreads";
            case 687L: return "V_SgUpcWaitStatement";
            case 688L: return "V_SgUseStatement";
            case 689L: return "V_SgUserDefinedBinaryOp";
            case 690L: return "V_SgUserDefinedUnaryOp";
            case 691L: return "V_SgUsingDeclarationStatement";
            case 692L: return "V_SgUsingDirectiveStatement";
            case 693L: return "V_SgValueExp";
            case 694L: return "V_SgVarArgCopyOp";
            case 695L: return "V_SgVarArgEndOp";
            case 696L: return "V_SgVarArgOp";
            case 697L: return "V_SgVarArgStartOneOperandOp";
            case 698L: return "V_SgVarArgStartOp";
            case 699L: return "V_SgVarRefExp";
            case 700L: return "V_SgVariableDeclaration";
            case 701L: return "V_SgVariableDefinition";
            case 702L: return "V_SgVariableSymbol";
            case 703L: return "V_SgVariantExpression";
            case 704L: return "V_SgVariantStatement";
            case 705L: return "V_SgVoidVal";
            case 706L: return "V_SgWaitStatement";
            case 707L: return "V_SgWarningDirectiveStatement";
            case 708L: return "V_SgWithStatement";
            case 709L: return "V_SgWcharVal";
            case 710L: return "V_SgWhereStatement";
            case 711L: return "V_SgWhileStmt";
            case 712L: return "V_SgWriteStatement";
            case 713L: return "V_SgXorAssignOp";
            case 714L: return "V_SgYieldExpression";
            case 715L: return "V_Sg_File_Info";
            case 716L: return "V_SgTypeCAFTeam";
            case 717L: return "V_SgCAFWithTeamStatement";
            case 718L: return "V_SgCAFCoExpression";
            case 719L: return "V_SgCallExpression";
            case 720L: return "V_SgTypeCrayPointer";
            case 721L: return "V_SgClassExp";
            case 723L: return "V_SgNumVariants";
            default: return "";
        }
    }

    std::string VariantT(int64_t i, const std::string &strip) {
        std::string s = VariantT(i);
        if (s.empty())
            s = "(VariantT)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& VariantT() {
        static const int64_t values[] = {
            1L,
            2L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L,
            58L,
            59L,
            60L,
            61L,
            62L,
            63L,
            64L,
            65L,
            66L,
            67L,
            68L,
            69L,
            70L,
            71L,
            73L,
            74L,
            75L,
            76L,
            77L,
            78L,
            79L,
            80L,
            81L,
            82L,
            83L,
            84L,
            85L,
            86L,
            87L,
            88L,
            89L,
            90L,
            91L,
            92L,
            93L,
            94L,
            95L,
            96L,
            97L,
            98L,
            99L,
            100L,
            101L,
            102L,
            104L,
            106L,
            107L,
            108L,
            109L,
            110L,
            111L,
            112L,
            113L,
            114L,
            115L,
            116L,
            117L,
            118L,
            119L,
            120L,
            121L,
            122L,
            123L,
            124L,
            125L,
            126L,
            127L,
            128L,
            129L,
            130L,
            131L,
            132L,
            133L,
            134L,
            135L,
            136L,
            137L,
            138L,
            139L,
            140L,
            141L,
            142L,
            143L,
            144L,
            145L,
            146L,
            147L,
            148L,
            149L,
            150L,
            151L,
            152L,
            153L,
            154L,
            155L,
            156L,
            157L,
            158L,
            159L,
            160L,
            161L,
            162L,
            163L,
            164L,
            165L,
            166L,
            167L,
            168L,
            169L,
            170L,
            171L,
            172L,
            173L,
            174L,
            175L,
            176L,
            177L,
            178L,
            179L,
            180L,
            181L,
            182L,
            183L,
            184L,
            185L,
            186L,
            187L,
            188L,
            189L,
            190L,
            191L,
            192L,
            193L,
            194L,
            195L,
            196L,
            197L,
            198L,
            199L,
            200L,
            201L,
            202L,
            203L,
            204L,
            205L,
            206L,
            207L,
            208L,
            209L,
            210L,
            211L,
            212L,
            213L,
            214L,
            215L,
            216L,
            217L,
            218L,
            219L,
            220L,
            221L,
            222L,
            223L,
            224L,
            225L,
            226L,
            227L,
            228L,
            229L,
            230L,
            231L,
            232L,
            233L,
            234L,
            235L,
            236L,
            237L,
            238L,
            239L,
            240L,
            241L,
            242L,
            243L,
            244L,
            245L,
            246L,
            247L,
            248L,
            249L,
            250L,
            251L,
            252L,
            253L,
            254L,
            255L,
            256L,
            257L,
            258L,
            259L,
            260L,
            261L,
            262L,
            263L,
            264L,
            265L,
            266L,
            267L,
            268L,
            269L,
            270L,
            271L,
            272L,
            273L,
            274L,
            275L,
            276L,
            277L,
            278L,
            279L,
            280L,
            281L,
            282L,
            283L,
            284L,
            285L,
            286L,
            287L,
            288L,
            289L,
            290L,
            291L,
            292L,
            293L,
            294L,
            295L,
            296L,
            297L,
            298L,
            299L,
            300L,
            301L,
            302L,
            303L,
            304L,
            305L,
            306L,
            307L,
            308L,
            309L,
            310L,
            311L,
            312L,
            313L,
            314L,
            315L,
            316L,
            317L,
            318L,
            319L,
            320L,
            321L,
            322L,
            323L,
            324L,
            325L,
            326L,
            327L,
            328L,
            329L,
            330L,
            331L,
            332L,
            333L,
            334L,
            335L,
            336L,
            337L,
            338L,
            339L,
            340L,
            341L,
            342L,
            343L,
            344L,
            345L,
            346L,
            347L,
            348L,
            349L,
            350L,
            351L,
            352L,
            353L,
            354L,
            355L,
            356L,
            357L,
            358L,
            359L,
            360L,
            361L,
            362L,
            363L,
            364L,
            365L,
            366L,
            367L,
            368L,
            369L,
            370L,
            371L,
            372L,
            373L,
            374L,
            375L,
            376L,
            377L,
            378L,
            379L,
            380L,
            381L,
            382L,
            383L,
            384L,
            385L,
            386L,
            387L,
            388L,
            389L,
            390L,
            391L,
            392L,
            393L,
            394L,
            395L,
            396L,
            397L,
            398L,
            399L,
            400L,
            401L,
            402L,
            403L,
            404L,
            405L,
            406L,
            407L,
            408L,
            409L,
            410L,
            411L,
            412L,
            413L,
            414L,
            415L,
            416L,
            417L,
            418L,
            419L,
            420L,
            421L,
            422L,
            425L,
            426L,
            427L,
            428L,
            429L,
            430L,
            431L,
            432L,
            434L,
            435L,
            436L,
            437L,
            438L,
            439L,
            440L,
            441L,
            442L,
            443L,
            444L,
            445L,
            446L,
            447L,
            448L,
            449L,
            450L,
            451L,
            452L,
            453L,
            454L,
            455L,
            456L,
            457L,
            458L,
            459L,
            460L,
            461L,
            462L,
            463L,
            464L,
            465L,
            466L,
            467L,
            468L,
            469L,
            470L,
            471L,
            472L,
            473L,
            474L,
            475L,
            476L,
            478L,
            479L,
            480L,
            481L,
            482L,
            483L,
            484L,
            485L,
            486L,
            487L,
            488L,
            489L,
            490L,
            491L,
            492L,
            493L,
            494L,
            495L,
            496L,
            497L,
            498L,
            499L,
            500L,
            501L,
            502L,
            503L,
            504L,
            505L,
            506L,
            507L,
            508L,
            509L,
            510L,
            511L,
            512L,
            513L,
            514L,
            515L,
            516L,
            517L,
            518L,
            519L,
            520L,
            521L,
            522L,
            523L,
            524L,
            525L,
            526L,
            527L,
            528L,
            529L,
            530L,
            531L,
            532L,
            533L,
            534L,
            535L,
            536L,
            537L,
            538L,
            539L,
            540L,
            541L,
            542L,
            543L,
            544L,
            545L,
            546L,
            547L,
            548L,
            549L,
            550L,
            551L,
            552L,
            553L,
            554L,
            555L,
            556L,
            557L,
            558L,
            559L,
            560L,
            561L,
            562L,
            563L,
            564L,
            565L,
            566L,
            567L,
            568L,
            569L,
            570L,
            571L,
            572L,
            573L,
            574L,
            575L,
            576L,
            577L,
            578L,
            580L,
            581L,
            582L,
            583L,
            584L,
            585L,
            586L,
            587L,
            588L,
            589L,
            590L,
            591L,
            592L,
            593L,
            594L,
            595L,
            596L,
            597L,
            598L,
            599L,
            600L,
            601L,
            602L,
            603L,
            604L,
            605L,
            606L,
            607L,
            608L,
            609L,
            610L,
            611L,
            612L,
            613L,
            614L,
            615L,
            616L,
            617L,
            618L,
            619L,
            620L,
            621L,
            622L,
            623L,
            624L,
            625L,
            626L,
            627L,
            628L,
            629L,
            630L,
            631L,
            632L,
            633L,
            634L,
            635L,
            636L,
            637L,
            638L,
            639L,
            640L,
            641L,
            642L,
            643L,
            644L,
            645L,
            646L,
            647L,
            648L,
            649L,
            650L,
            651L,
            652L,
            653L,
            654L,
            655L,
            656L,
            657L,
            658L,
            659L,
            660L,
            661L,
            662L,
            663L,
            664L,
            665L,
            666L,
            667L,
            668L,
            669L,
            670L,
            671L,
            672L,
            673L,
            674L,
            675L,
            676L,
            677L,
            678L,
            679L,
            680L,
            681L,
            682L,
            683L,
            684L,
            685L,
            686L,
            687L,
            688L,
            689L,
            690L,
            691L,
            692L,
            693L,
            694L,
            695L,
            696L,
            697L,
            698L,
            699L,
            700L,
            701L,
            702L,
            703L,
            704L,
            705L,
            706L,
            707L,
            708L,
            709L,
            710L,
            711L,
            712L,
            713L,
            714L,
            715L,
            716L,
            717L,
            718L,
            719L,
            720L,
            721L,
            723L
        };
        static const std::vector<int64_t> retval(values, values + 712);
        return retval;
    }

}

namespace Rose {
    std::string stringifyVariantT(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::VariantT(i);
        if (retval.empty()) {
            retval = "(VariantT)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "VariantT::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyVariantT() {
        return stringify::VariantT();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 9299
namespace stringify { namespace SgConstVolatileModifier {
    const char* cv_modifier_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_default";
            case 2L: return "e_const";
            case 3L: return "e_volatile";
            case 4L: return "e_const_volatile";
            case 5L: return "e_last_modifier";
            default: return "";
        }
    }

    std::string cv_modifier_enum(int64_t i, const std::string &strip) {
        std::string s = cv_modifier_enum(i);
        if (s.empty())
            s = "(SgConstVolatileModifier::cv_modifier_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& cv_modifier_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgConstVolatileModifier_cv_modifier_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgConstVolatileModifier::cv_modifier_enum(i);
        if (retval.empty()) {
            retval = "(SgConstVolatileModifier::cv_modifier_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgConstVolatileModifier::cv_modifier_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgConstVolatileModifier_cv_modifier_enum() {
        return stringify::SgConstVolatileModifier::cv_modifier_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 9795
namespace stringify { namespace SgStorageModifier {
    const char* storage_modifier_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_default";
            case 2L: return "e_extern";
            case 3L: return "e_static";
            case 4L: return "e_auto";
            case 5L: return "e_unspecified";
            case 6L: return "e_register";
            case 7L: return "e_mutable";
            case 8L: return "e_typedef";
            case 9L: return "e_asm";
            case 10L: return "e_local";
            case 11L: return "e_common";
            case 12L: return "e_associated";
            case 13L: return "e_intrinsic";
            case 14L: return "e_pointer_based";
            case 15L: return "e_contiguous";
            case 16L: return "e_cuda_global";
            case 17L: return "e_cuda_constant";
            case 18L: return "e_cuda_shared";
            case 19L: return "e_cuda_dynamic_shared";
            case 20L: return "e_cuda_device_memory";
            case 21L: return "e_cuda_managed";
            case 22L: return "e_cuda_pinned";
            case 23L: return "e_cuda_texture";
            case 24L: return "e_last_modifier";
            default: return "";
        }
    }

    std::string storage_modifier_enum(int64_t i, const std::string &strip) {
        std::string s = storage_modifier_enum(i);
        if (s.empty())
            s = "(SgStorageModifier::storage_modifier_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& storage_modifier_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L
        };
        static const std::vector<int64_t> retval(values, values + 25);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgStorageModifier_storage_modifier_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgStorageModifier::storage_modifier_enum(i);
        if (retval.empty()) {
            retval = "(SgStorageModifier::storage_modifier_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgStorageModifier::storage_modifier_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgStorageModifier_storage_modifier_enum() {
        return stringify::SgStorageModifier::storage_modifier_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 10387
namespace stringify { namespace SgAccessModifier {
    const char* access_modifier_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_private";
            case 2L: return "e_protected";
            case 3L: return "e_public";
            case 5L: return "e_undefined";
            case 6L: return "e_last_modifier";
            default: return "";
        }
    }

    std::string access_modifier_enum(int64_t i, const std::string &strip) {
        std::string s = access_modifier_enum(i);
        if (s.empty())
            s = "(SgAccessModifier::access_modifier_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& access_modifier_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAccessModifier_access_modifier_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAccessModifier::access_modifier_enum(i);
        if (retval.empty()) {
            retval = "(SgAccessModifier::access_modifier_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAccessModifier::access_modifier_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAccessModifier_access_modifier_enum() {
        return stringify::SgAccessModifier::access_modifier_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 10881
namespace stringify { namespace SgFunctionModifier {
    const char* function_modifier_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_default";
            case 2L: return "e_inline";
            case 3L: return "e_virtual";
            case 4L: return "e_pure_virtual";
            case 5L: return "e_explicit";
            case 7L: return "e_pure";
            case 8L: return "e_elemental";
            case 9L: return "e_recursive";
            case 10L: return "e_gnu_attribute__constructor__";
            case 11L: return "e_gnu_attribute__destructor__";
            case 12L: return "e_gnu_attribute__pure__";
            case 13L: return "e_gnu_attribute__weak__";
            case 14L: return "e_gnu_attribute__unused__";
            case 15L: return "e_gnu_attribute__used__";
            case 16L: return "e_gnu_attribute__deprecated__";
            case 17L: return "e_gnu_attribute__malloc__";
            case 18L: return "e_gnu_attribute__naked__";
            case 19L: return "e_gnu_attribute__no_instrument_function__";
            case 20L: return "e_gnu_attribute__no_check_memory_usage__";
            case 21L: return "e_gnu_attribute__noinline__";
            case 22L: return "e_gnu_attribute__always_inline__";
            case 23L: return "e_gnu_attribute__nothrow__";
            case 24L: return "e_gnu_attribute__weakref__";
            case 25L: return "e_cuda_device";
            case 26L: return "e_cuda_kernel";
            case 27L: return "e_cuda_host";
            case 28L: return "e_cuda_global_function";
            case 29L: return "e_cuda_grid_global";
            case 30L: return "e_opencl_kernel";
            case 31L: return "e_opencl_vec_type_hint";
            case 32L: return "e_opencl_work_group_size_hint";
            case 33L: return "e_opencl_work_group_size_req";
            case 38L: return "e_marked_default";
            case 39L: return "e_marked_delete";
            case 40L: return "e_reentrant";
            case 41L: return "e_last_modifier";
            default: return "";
        }
    }

    std::string function_modifier_enum(int64_t i, const std::string &strip) {
        std::string s = function_modifier_enum(i);
        if (s.empty())
            s = "(SgFunctionModifier::function_modifier_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& function_modifier_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            38L,
            39L,
            40L,
            41L
        };
        static const std::vector<int64_t> retval(values, values + 37);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgFunctionModifier_function_modifier_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgFunctionModifier::function_modifier_enum(i);
        if (retval.empty()) {
            retval = "(SgFunctionModifier::function_modifier_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgFunctionModifier::function_modifier_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgFunctionModifier_function_modifier_enum() {
        return stringify::SgFunctionModifier::function_modifier_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 11606
namespace stringify { namespace SgUPC_AccessModifier {
    const char* upc_access_modifier_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_default";
            case 2L: return "e_upc_strict";
            case 3L: return "e_upc_relaxed";
            case 4L: return "e_last_modifier";
            default: return "";
        }
    }

    std::string upc_access_modifier_enum(int64_t i, const std::string &strip) {
        std::string s = upc_access_modifier_enum(i);
        if (s.empty())
            s = "(SgUPC_AccessModifier::upc_access_modifier_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& upc_access_modifier_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgUPC_AccessModifier_upc_access_modifier_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgUPC_AccessModifier::upc_access_modifier_enum(i);
        if (retval.empty()) {
            retval = "(SgUPC_AccessModifier::upc_access_modifier_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgUPC_AccessModifier::upc_access_modifier_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgUPC_AccessModifier_upc_access_modifier_enum() {
        return stringify::SgUPC_AccessModifier::upc_access_modifier_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 12108
namespace stringify { namespace SgSpecialFunctionModifier {
    const char* special_function_modifier_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_default";
            case 2L: return "e_constructor";
            case 3L: return "e_destructor";
            case 4L: return "e_conversion";
            case 5L: return "e_operator";
            case 6L: return "e_uld_operator";
            case 7L: return "e_lambda_entry_point";
            case 8L: return "e_last_modifier";
            default: return "";
        }
    }

    std::string special_function_modifier_enum(int64_t i, const std::string &strip) {
        std::string s = special_function_modifier_enum(i);
        if (s.empty())
            s = "(SgSpecialFunctionModifier::special_function_modifier_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& special_function_modifier_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L
        };
        static const std::vector<int64_t> retval(values, values + 9);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgSpecialFunctionModifier_special_function_modifier_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgSpecialFunctionModifier::special_function_modifier_enum(i);
        if (retval.empty()) {
            retval = "(SgSpecialFunctionModifier::special_function_modifier_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgSpecialFunctionModifier::special_function_modifier_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgSpecialFunctionModifier_special_function_modifier_enum() {
        return stringify::SgSpecialFunctionModifier::special_function_modifier_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 12617
namespace stringify { namespace SgElaboratedTypeModifier {
    const char* elaborated_type_modifier_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_default";
            case 2L: return "e_class";
            case 3L: return "e_struct";
            case 4L: return "e_union";
            case 5L: return "e_enum";
            case 6L: return "e_typename";
            case 7L: return "e_last_modifier";
            default: return "";
        }
    }

    std::string elaborated_type_modifier_enum(int64_t i, const std::string &strip) {
        std::string s = elaborated_type_modifier_enum(i);
        if (s.empty())
            s = "(SgElaboratedTypeModifier::elaborated_type_modifier_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& elaborated_type_modifier_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgElaboratedTypeModifier_elaborated_type_modifier_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgElaboratedTypeModifier::elaborated_type_modifier_enum(i);
        if (retval.empty()) {
            retval = "(SgElaboratedTypeModifier::elaborated_type_modifier_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgElaboratedTypeModifier::elaborated_type_modifier_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgElaboratedTypeModifier_elaborated_type_modifier_enum() {
        return stringify::SgElaboratedTypeModifier::elaborated_type_modifier_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 13111
namespace stringify { namespace SgLinkageModifier {
    const char* linkage_modifier_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_default";
            case 2L: return "e_C_linkage";
            case 3L: return "e_Cpp_linkage";
            case 4L: return "e_fortran_linkage";
            case 5L: return "e_fortran90_linkage";
            case 6L: return "e_last_modifier";
            default: return "";
        }
    }

    std::string linkage_modifier_enum(int64_t i, const std::string &strip) {
        std::string s = linkage_modifier_enum(i);
        if (s.empty())
            s = "(SgLinkageModifier::linkage_modifier_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& linkage_modifier_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgLinkageModifier_linkage_modifier_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgLinkageModifier::linkage_modifier_enum(i);
        if (retval.empty()) {
            retval = "(SgLinkageModifier::linkage_modifier_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgLinkageModifier::linkage_modifier_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgLinkageModifier_linkage_modifier_enum() {
        return stringify::SgLinkageModifier::linkage_modifier_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 13596
namespace stringify { namespace SgBaseClassModifier {
    const char* baseclass_modifier_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_default";
            case 2L: return "e_virtual";
            case 3L: return "e_last_modifier";
            default: return "";
        }
    }

    std::string baseclass_modifier_enum(int64_t i, const std::string &strip) {
        std::string s = baseclass_modifier_enum(i);
        if (s.empty())
            s = "(SgBaseClassModifier::baseclass_modifier_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& baseclass_modifier_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgBaseClassModifier_baseclass_modifier_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgBaseClassModifier::baseclass_modifier_enum(i);
        if (retval.empty()) {
            retval = "(SgBaseClassModifier::baseclass_modifier_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgBaseClassModifier::baseclass_modifier_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgBaseClassModifier_baseclass_modifier_enum() {
        return stringify::SgBaseClassModifier::baseclass_modifier_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 14081
namespace stringify { namespace SgStructureModifier {
    const char* jovial_structure_modifier_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_default";
            case 2L: return "e_table_structure_parallel";
            case 3L: return "e_table_structure_tight";
            case 4L: return "e_last_modifier";
            default: return "";
        }
    }

    std::string jovial_structure_modifier_enum(int64_t i, const std::string &strip) {
        std::string s = jovial_structure_modifier_enum(i);
        if (s.empty())
            s = "(SgStructureModifier::jovial_structure_modifier_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& jovial_structure_modifier_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgStructureModifier_jovial_structure_modifier_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgStructureModifier::jovial_structure_modifier_enum(i);
        if (retval.empty()) {
            retval = "(SgStructureModifier::jovial_structure_modifier_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgStructureModifier::jovial_structure_modifier_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgStructureModifier_jovial_structure_modifier_enum() {
        return stringify::SgStructureModifier::jovial_structure_modifier_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 14573
namespace stringify { namespace SgTypeModifier {
    const char* type_modifier_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_default";
            case 2L: return "e_restrict";
            case 3L: return "e_allocatable";
            case 4L: return "e_asynchronous";
            case 5L: return "e_bind";
            case 6L: return "e_data";
            case 7L: return "e_dimension";
            case 8L: return "e_intent_in";
            case 9L: return "e_intent_out";
            case 10L: return "e_intent_inout";
            case 11L: return "e_intrinsic";
            case 12L: return "e_optional";
            case 13L: return "e_extends";
            case 14L: return "e_abstract";
            case 15L: return "e_save";
            case 16L: return "e_target";
            case 17L: return "e_value";
            case 18L: return "e_gnu_attribute__unused__";
            case 19L: return "e_gnu_attribute__packed__";
            case 20L: return "e_gnu_attribute__deprecated__";
            case 21L: return "e_gnu_attribute__transparent_union__";
            case 22L: return "e_gnu_attribute__noreturn__";
            case 23L: return "e_gnu_attribute__const__";
            case 24L: return "e_gnu_attribute__cdecl__";
            case 25L: return "e_gnu_attribute__stdcall__";
            case 26L: return "e_gnu_attribute__warn_unused_result__";
            case 27L: return "e_gnu_attribute__nonnull__";
            case 28L: return "e_gnu_attribute__sentinel__";
            case 29L: return "e_address_space__";
            case 30L: return "e_ocl_global__";
            case 31L: return "e_ocl_local__";
            case 32L: return "e_ocl_constant__";
            case 33L: return "e_vector_type__";
            case 34L: return "e_gnu_attribute__device__";
            case 35L: return "e_round";
            case 36L: return "e_truncate";
            case 37L: return "e_truncate_towards_zero";
            case 38L: return "e_last_modifier";
            default: return "";
        }
    }

    std::string type_modifier_enum(int64_t i, const std::string &strip) {
        std::string s = type_modifier_enum(i);
        if (s.empty())
            s = "(SgTypeModifier::type_modifier_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& type_modifier_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L
        };
        static const std::vector<int64_t> retval(values, values + 39);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgTypeModifier_type_modifier_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgTypeModifier::type_modifier_enum(i);
        if (retval.empty()) {
            retval = "(SgTypeModifier::type_modifier_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgTypeModifier::type_modifier_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgTypeModifier_type_modifier_enum() {
        return stringify::SgTypeModifier::type_modifier_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 14662
namespace stringify { namespace SgTypeModifier {
    const char* gnu_extension_machine_mode_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_gnu_extension_machine_mode_unknown";
            case 1L: return "e_gnu_extension_machine_mode_unspecified";
            case 2L: return "e_gnu_extension_machine_mode_BImode";
            case 3L: return "e_gnu_extension_machine_mode_QImode";
            case 4L: return "e_gnu_extension_machine_mode_HImode";
            case 5L: return "e_gnu_extension_machine_mode_PSImode";
            case 6L: return "e_gnu_extension_machine_mode_SImode";
            case 7L: return "e_gnu_extension_machine_mode_PDImode";
            case 8L: return "e_gnu_extension_machine_mode_DImode";
            case 9L: return "e_gnu_extension_machine_mode_TImode";
            case 10L: return "e_gnu_extension_machine_mode_OImode";
            case 11L: return "e_gnu_extension_machine_mode_QFmode";
            case 12L: return "e_gnu_extension_machine_mode_HFmode";
            case 13L: return "e_gnu_extension_machine_mode_TQFmode";
            case 14L: return "e_gnu_extension_machine_mode_SFmode";
            case 15L: return "e_gnu_extension_machine_mode_DFmode";
            case 16L: return "e_gnu_extension_machine_mode_XFmode";
            case 17L: return "e_gnu_extension_machine_mode_SDmode";
            case 18L: return "e_gnu_extension_machine_mode_DDmode";
            case 19L: return "e_gnu_extension_machine_mode_TDmode";
            case 20L: return "e_gnu_extension_machine_mode_TFmode";
            case 21L: return "e_gnu_extension_machine_mode_QQmode";
            case 22L: return "e_gnu_extension_machine_mode_HQmode";
            case 23L: return "e_gnu_extension_machine_mode_SQmode";
            case 24L: return "e_gnu_extension_machine_mode_DQmode";
            case 25L: return "e_gnu_extension_machine_mode_TQmode";
            case 26L: return "e_gnu_extension_machine_mode_UQQmode";
            case 27L: return "e_gnu_extension_machine_mode_UHQmode";
            case 28L: return "e_gnu_extension_machine_mode_USQmode";
            case 29L: return "e_gnu_extension_machine_mode_UDQmode";
            case 30L: return "e_gnu_extension_machine_mode_UTQmode";
            case 31L: return "e_gnu_extension_machine_mode_HAmode";
            case 32L: return "e_gnu_extension_machine_mode_SAmode";
            case 33L: return "e_gnu_extension_machine_mode_DAmode";
            case 34L: return "e_gnu_extension_machine_mode_TAmode";
            case 35L: return "e_gnu_extension_machine_mode_UHAmode";
            case 36L: return "e_gnu_extension_machine_mode_USAmode";
            case 37L: return "e_gnu_extension_machine_mode_UDAmode";
            case 38L: return "e_gnu_extension_machine_mode_UTAmode";
            case 39L: return "e_gnu_extension_machine_mode_CCmode";
            case 40L: return "e_gnu_extension_machine_mode_BLKmode";
            case 41L: return "e_gnu_extension_machine_mode_VOIDmode";
            case 42L: return "e_gnu_extension_machine_mode_QCmode";
            case 43L: return "e_gnu_extension_machine_mode_HCmode";
            case 44L: return "e_gnu_extension_machine_mode_SCmode";
            case 45L: return "e_gnu_extension_machine_mode_DCmode";
            case 46L: return "e_gnu_extension_machine_mode_XCmode";
            case 47L: return "e_gnu_extension_machine_mode_TCmode";
            case 48L: return "e_gnu_extension_machine_mode_CQImode";
            case 49L: return "e_gnu_extension_machine_mode_CHImode";
            case 50L: return "e_gnu_extension_machine_mode_CSImode";
            case 51L: return "e_gnu_extension_machine_mode_CDImode";
            case 52L: return "e_gnu_extension_machine_mode_CTImode";
            case 53L: return "e_gnu_extension_machine_mode_COImode";
            case 54L: return "e_last_machine_mode";
            default: return "";
        }
    }

    std::string gnu_extension_machine_mode_enum(int64_t i, const std::string &strip) {
        std::string s = gnu_extension_machine_mode_enum(i);
        if (s.empty())
            s = "(SgTypeModifier::gnu_extension_machine_mode_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& gnu_extension_machine_mode_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L
        };
        static const std::vector<int64_t> retval(values, values + 55);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgTypeModifier_gnu_extension_machine_mode_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgTypeModifier::gnu_extension_machine_mode_enum(i);
        if (retval.empty()) {
            retval = "(SgTypeModifier::gnu_extension_machine_mode_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgTypeModifier::gnu_extension_machine_mode_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgTypeModifier_gnu_extension_machine_mode_enum() {
        return stringify::SgTypeModifier::gnu_extension_machine_mode_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 15426
namespace stringify { namespace SgDeclarationModifier {
    const char* declaration_modifier_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_default";
            case 2L: return "e_friend";
            case 3L: return "e_typedef";
            case 4L: return "e_export";
            case 5L: return "e_throw";
            case 6L: return "e_bind";
            case 7L: return "e_final";
            case 8L: return "e_override";
            case 10L: return "e_ms_declspec_align";
            case 11L: return "e_ms_declspec_allocate";
            case 12L: return "e_ms_declspec_appdomain";
            case 13L: return "e_ms_declspec_code_seg";
            case 14L: return "e_ms_declspec_deprecated";
            case 15L: return "e_ms_declspec_dllimport";
            case 16L: return "e_ms_declspec_dllexport";
            case 17L: return "e_ms_declspec_jitintrinsic";
            case 18L: return "e_ms_declspec_naked";
            case 19L: return "e_ms_declspec_noalias";
            case 20L: return "e_ms_declspec_noinline";
            case 21L: return "e_ms_declspec_noreturn";
            case 22L: return "e_ms_declspec_nothrow";
            case 23L: return "e_ms_declspec_novtable";
            case 24L: return "e_ms_declspec_process";
            case 25L: return "e_ms_declspec_property";
            case 26L: return "e_ms_declspec_restrict";
            case 27L: return "e_ms_declspec_safebuffers";
            case 28L: return "e_ms_declspec_selectany";
            case 29L: return "e_ms_declspec_thread";
            case 30L: return "e_ms_declspec_uuid";
            case 31L: return "e_last_modifier";
            default: return "";
        }
    }

    std::string declaration_modifier_enum(int64_t i, const std::string &strip) {
        std::string s = declaration_modifier_enum(i);
        if (s.empty())
            s = "(SgDeclarationModifier::declaration_modifier_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& declaration_modifier_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L
        };
        static const std::vector<int64_t> retval(values, values + 31);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgDeclarationModifier_declaration_modifier_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgDeclarationModifier::declaration_modifier_enum(i);
        if (retval.empty()) {
            retval = "(SgDeclarationModifier::declaration_modifier_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgDeclarationModifier::declaration_modifier_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgDeclarationModifier_declaration_modifier_enum() {
        return stringify::SgDeclarationModifier::declaration_modifier_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 15470
namespace stringify { namespace SgDeclarationModifier {
    const char* gnu_declaration_visability_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown_visibility";
            case 1L: return "e_error_visibility";
            case 2L: return "e_unspecified_visibility";
            case 3L: return "e_hidden_visibility";
            case 4L: return "e_protected_visibility";
            case 5L: return "e_internal_visibility";
            case 6L: return "e_default_visibility";
            case 7L: return "e_last_visibility_attribute";
            default: return "";
        }
    }

    std::string gnu_declaration_visability_enum(int64_t i, const std::string &strip) {
        std::string s = gnu_declaration_visability_enum(i);
        if (s.empty())
            s = "(SgDeclarationModifier::gnu_declaration_visability_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& gnu_declaration_visability_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgDeclarationModifier_gnu_declaration_visability_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgDeclarationModifier::gnu_declaration_visability_enum(i);
        if (retval.empty()) {
            retval = "(SgDeclarationModifier::gnu_declaration_visability_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgDeclarationModifier::gnu_declaration_visability_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgDeclarationModifier_gnu_declaration_visability_enum() {
        return stringify::SgDeclarationModifier::gnu_declaration_visability_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 16142
namespace stringify { namespace SgOpenclAccessModeModifier {
    const char* access_mode_modifier_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_default";
            case 2L: return "e_read_only";
            case 3L: return "e_write_only";
            case 4L: return "e_read_write";
            case 5L: return "e_last_modifier";
            default: return "";
        }
    }

    std::string access_mode_modifier_enum(int64_t i, const std::string &strip) {
        std::string s = access_mode_modifier_enum(i);
        if (s.empty())
            s = "(SgOpenclAccessModeModifier::access_mode_modifier_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& access_mode_modifier_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgOpenclAccessModeModifier_access_mode_modifier_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgOpenclAccessModeModifier::access_mode_modifier_enum(i);
        if (retval.empty()) {
            retval = "(SgOpenclAccessModeModifier::access_mode_modifier_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgOpenclAccessModeModifier::access_mode_modifier_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgOpenclAccessModeModifier_access_mode_modifier_enum() {
        return stringify::SgOpenclAccessModeModifier::access_mode_modifier_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 20445
namespace stringify { namespace Sg_File_Info {
    const char* classifier(int64_t i) {
        switch (i) {
            case 1L: return "e_transformation";
            case 2L: return "e_compiler_generated";
            case 4L: return "e_output_in_code_generation";
            case 8L: return "e_shared";
            case 16L: return "e_frontend_specific";
            case 32L: return "e_source_position_unavailable_in_frontend";
            case 64L: return "e_comment_or_directive";
            case 128L: return "e_token";
            case 256L: return "e_default_argument";
            case 512L: return "e_implicit_cast";
            default: return "";
        }
    }

    std::string classifier(int64_t i, const std::string &strip) {
        std::string s = classifier(i);
        if (s.empty())
            s = "(Sg_File_Info::classifier)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& classifier() {
        static const int64_t values[] = {
            1L,
            2L,
            4L,
            8L,
            16L,
            32L,
            64L,
            128L,
            256L,
            512L
        };
        static const std::vector<int64_t> retval(values, values + 10);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySg_File_Info_classifier(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sg_File_Info::classifier(i);
        if (retval.empty()) {
            retval = "(Sg_File_Info::classifier)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sg_File_Info::classifier::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySg_File_Info_classifier() {
        return stringify::Sg_File_Info::classifier();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 20710
namespace stringify { namespace Sg_File_Info {
    const char* p_fileflags(int64_t i) {
        switch (i) {
            case -6L: return "BAD_FILE_ID";
            case -5L: return "COMPILER_GENERATED_MARKED_FOR_OUTPUT_FILE_ID";
            case -4L: return "COMPILER_GENERATED_FILE_ID";
            case -3L: return "TRANSFORMATION_FILE_ID";
            case -2L: return "NULL_FILE_ID";
            case -1L: return "COPY_FILE_ID";
            default: return "";
        }
    }

    std::string p_fileflags(int64_t i, const std::string &strip) {
        std::string s = p_fileflags(i);
        if (s.empty())
            s = "(Sg_File_Info::p_fileflags)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& p_fileflags() {
        static const int64_t values[] = {
            -6L,
            -5L,
            -4L,
            -3L,
            -2L,
            -1L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySg_File_Info_p_fileflags(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sg_File_Info::p_fileflags(i);
        if (retval.empty()) {
            retval = "(Sg_File_Info::p_fileflags)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sg_File_Info::p_fileflags::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySg_File_Info_p_fileflags() {
        return stringify::Sg_File_Info::p_fileflags();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 21254
namespace stringify { namespace SgFile {
    const char* outputFormatOption_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown_output_format";
            case 1L: return "e_fixed_form_output_format";
            case 2L: return "e_free_form_output_format";
            default: return "";
        }
    }

    std::string outputFormatOption_enum(int64_t i, const std::string &strip) {
        std::string s = outputFormatOption_enum(i);
        if (s.empty())
            s = "(SgFile::outputFormatOption_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& outputFormatOption_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgFile_outputFormatOption_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgFile::outputFormatOption_enum(i);
        if (retval.empty()) {
            retval = "(SgFile::outputFormatOption_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgFile::outputFormatOption_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgFile_outputFormatOption_enum() {
        return stringify::SgFile::outputFormatOption_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 21269
namespace stringify { namespace SgFile {
    const char* languageOption_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_error_language";
            case 1L: return "e_default_language";
            case 2L: return "e_C_language";
            case 3L: return "e_Cxx_language";
            case 4L: return "e_Fortran_language";
            case 5L: return "e_last_language";
            default: return "";
        }
    }

    std::string languageOption_enum(int64_t i, const std::string &strip) {
        std::string s = languageOption_enum(i);
        if (s.empty())
            s = "(SgFile::languageOption_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& languageOption_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgFile_languageOption_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgFile::languageOption_enum(i);
        if (retval.empty()) {
            retval = "(SgFile::languageOption_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgFile::languageOption_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgFile_languageOption_enum() {
        return stringify::SgFile::languageOption_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 21280
namespace stringify { namespace SgFile {
    const char* standard_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_default_standard";
            case 1L: return "e_c89_standard";
            case 2L: return "e_c90_standard";
            case 3L: return "e_c99_standard";
            case 4L: return "e_c11_standard";
            case 5L: return "e_c14_standard";
            case 6L: return "e_c18_standard";
            case 7L: return "e_upc_standard";
            case 8L: return "e_cxx98_standard";
            case 9L: return "e_cxx03_standard";
            case 10L: return "e_cxx11_standard";
            case 11L: return "e_cxx14_standard";
            case 12L: return "e_cxx17_standard";
            case 13L: return "e_cxx20_standard";
            case 14L: return "e_upcxx_standard";
            case 15L: return "e_f77_standard";
            case 16L: return "e_f90_standard";
            case 17L: return "e_f95_standard";
            case 18L: return "e_f03_standard";
            case 19L: return "e_f08_standard";
            case 20L: return "e_f18_standard";
            default: return "";
        }
    }

    std::string standard_enum(int64_t i, const std::string &strip) {
        std::string s = standard_enum(i);
        if (s.empty())
            s = "(SgFile::standard_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& standard_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L
        };
        static const std::vector<int64_t> retval(values, values + 21);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgFile_standard_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgFile::standard_enum(i);
        if (retval.empty()) {
            retval = "(SgFile::standard_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgFile::standard_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgFile_standard_enum() {
        return stringify::SgFile::standard_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 24125
namespace stringify { namespace SgProject {
    const char* template_instantiation_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_default";
            case 2L: return "e_none";
            case 3L: return "e_used";
            case 4L: return "e_all";
            case 5L: return "e_local";
            case 6L: return "e_last";
            default: return "";
        }
    }

    std::string template_instantiation_enum(int64_t i, const std::string &strip) {
        std::string s = template_instantiation_enum(i);
        if (s.empty())
            s = "(SgProject::template_instantiation_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& template_instantiation_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgProject_template_instantiation_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgProject::template_instantiation_enum(i);
        if (retval.empty()) {
            retval = "(SgProject::template_instantiation_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgProject::template_instantiation_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgProject_template_instantiation_enum() {
        return stringify::SgProject::template_instantiation_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 25930
namespace stringify { namespace SgUnparse_Info {
    const char* unparse_type_num(int64_t i) {
        switch (i) {
            case 0L: return "b_enum_defaultValue";
            case 1L: return "b_isPointerToSomething";
            case 2L: return "b_isReferenceToSomething";
            case 3L: return "b_inVarDecl";
            case 4L: return "b_inArgList";
            case 5L: return "b_SkipSemiColon";
            case 6L: return "b_inEnumDecl";
            case 7L: return "b_inTemplateList";
            case 8L: return "b_SkipBaseType";
            case 9L: return "b_inAggregateInitializer";
            case 10L: return "b_isWithType";
            case 11L: return "b_inConditional";
            case 12L: return "b_SkipDefinition";
            case 13L: return "b_SkipClassSpecifier";
            case 14L: return "b_inEmbeddedDecl";
            case 15L: return "b_SkipGlobal";
            case 16L: return "b_SkipAtomic";
            case 17L: return "b_PrintName";
            case 18L: return "b_CheckAccess";
            case 19L: return "b_SkipFunctionQualifier";
            case 20L: return "b_isArrayType";
            case 21L: return "b_inRhsExpr";
            case 22L: return "b_SkipParen";
            case 23L: return "b_isTypeSecondPart";
            case 24L: return "b_isTypeFirstPart";
            case 25L: return "b_SkipInitializer";
            case 26L: return "b_SkipComments";
            case 27L: return "b_SkipCPPDirectives";
            case 28L: return "b_SkipEnumDefinition";
            case 29L: return "b_SkipFunctionDefinition";
            case 30L: return "b_SkipClassDefinition";
            case 31L: return "b_AddSemiColonAfterDeclaration";
            case 32L: return "b_SkipWhitespaces";
            case 33L: return "b_SkipBasicBlock";
            case 34L: return "b_outputClassTemplateName";
            case 35L: return "b_outputCompilerGeneratedStatements";
            case 36L: return "b_SkipConstantFoldedExpressions";
            case 37L: return "b_forceQualifiedNames";
            case 38L: return "b_SkipQualifiedNames";
            case 39L: return "b_skipCheckAccess";
            case 40L: return "b_requiresGlobalNameQualification";
            case 41L: return "b_useTypeAttributes";
            case 42L: return "b_SkipFormatting";
            case 43L: return "b_outputFortranModFile";
            case 44L: return "b_supressStrippedTypeName";
            case 45L: return "b_prefixOperator";
            case 46L: return "b_supressArrayBound";
            case 47L: return "b_supressImplicitThisOperator";
            case 48L: return "b_unparsedPartiallyUsingTokenStream";
            case 49L: return "b_skipCompilerGeneratedSubExpressions";
            case 50L: return "b_parentStatementListBeingUnparsedUsingPartialTokenSequence";
            case 51L: return "b_cxx11_initialization_list";
            case 52L: return "b_inTypedefDecl";
            case 53L: return "b_SkipNameQualification";
            case 54L: return "b_useAlternativeDefiningDeclaration";
            case 55L: return "b_usedInUparseToStringFunction";
            case 56L: return "UNPARSE_TYPE_LAST";
            default: return "";
        }
    }

    std::string unparse_type_num(int64_t i, const std::string &strip) {
        std::string s = unparse_type_num(i);
        if (s.empty())
            s = "(SgUnparse_Info::unparse_type_num)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& unparse_type_num() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L
        };
        static const std::vector<int64_t> retval(values, values + 57);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgUnparse_Info_unparse_type_num(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgUnparse_Info::unparse_type_num(i);
        if (retval.empty()) {
            retval = "(SgUnparse_Info::unparse_type_num)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgUnparse_Info::unparse_type_num::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgUnparse_Info_unparse_type_num() {
        return stringify::SgUnparse_Info::unparse_type_num();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 26107
namespace stringify { namespace SgUnparse_Info {
    const char* access_attr_enum(int64_t i) {
        switch (i) {
            case 1L: return "a_unset_access";
            case 2L: return "a_private_access";
            case 3L: return "a_protected_access";
            case 4L: return "a_public_access";
            case 5L: return "a_default_access";
            default: return "";
        }
    }

    std::string access_attr_enum(int64_t i, const std::string &strip) {
        std::string s = access_attr_enum(i);
        if (s.empty())
            s = "(SgUnparse_Info::access_attr_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& access_attr_enum() {
        static const int64_t values[] = {
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgUnparse_Info_access_attr_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgUnparse_Info::access_attr_enum(i);
        if (retval.empty()) {
            retval = "(SgUnparse_Info::access_attr_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgUnparse_Info::access_attr_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgUnparse_Info_access_attr_enum() {
        return stringify::SgUnparse_Info::access_attr_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 28959
namespace stringify { namespace SgTemplateParameter {
    const char* template_parameter_enum(int64_t i) {
        switch (i) {
            case 0L: return "parameter_undefined";
            case 1L: return "type_parameter";
            case 2L: return "nontype_parameter";
            case 3L: return "template_parameter";
            default: return "";
        }
    }

    std::string template_parameter_enum(int64_t i, const std::string &strip) {
        std::string s = template_parameter_enum(i);
        if (s.empty())
            s = "(SgTemplateParameter::template_parameter_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& template_parameter_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgTemplateParameter_template_parameter_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgTemplateParameter::template_parameter_enum(i);
        if (retval.empty()) {
            retval = "(SgTemplateParameter::template_parameter_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgTemplateParameter::template_parameter_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgTemplateParameter_template_parameter_enum() {
        return stringify::SgTemplateParameter::template_parameter_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 29479
namespace stringify { namespace SgTemplateArgument {
    const char* template_argument_enum(int64_t i) {
        switch (i) {
            case 0L: return "argument_undefined";
            case 1L: return "type_argument";
            case 2L: return "nontype_argument";
            case 3L: return "template_template_argument";
            case 4L: return "start_of_pack_expansion_argument";
            default: return "";
        }
    }

    std::string template_argument_enum(int64_t i, const std::string &strip) {
        std::string s = template_argument_enum(i);
        if (s.empty())
            s = "(SgTemplateArgument::template_argument_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& template_argument_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgTemplateArgument_template_argument_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgTemplateArgument::template_argument_enum(i);
        if (retval.empty()) {
            retval = "(SgTemplateArgument::template_argument_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgTemplateArgument::template_argument_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgTemplateArgument_template_argument_enum() {
        return stringify::SgTemplateArgument::template_argument_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 33364
namespace stringify { namespace SgGraph {
    const char* GraphEdgeType(int64_t i) {
        switch (i) {
            case 0L: return "e_type_error";
            case 1L: return "none";
            case 2L: return "cfg";
            case 3L: return "usage";
            case 4L: return "e_last_type";
            default: return "";
        }
    }

    std::string GraphEdgeType(int64_t i, const std::string &strip) {
        std::string s = GraphEdgeType(i);
        if (s.empty())
            s = "(SgGraph::GraphEdgeType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& GraphEdgeType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgGraphGraphEdgeType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgGraph::GraphEdgeType(i);
        if (retval.empty()) {
            retval = "(SgGraph::GraphEdgeType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgGraph::GraphEdgeType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgGraphGraphEdgeType() {
        return stringify::SgGraph::GraphEdgeType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 33378
namespace stringify { namespace SgGraph {
    const char* GraphProperties(int64_t i) {
        switch (i) {
            case 0L: return "e_property_error";
            case 1L: return "name";
            case 2L: return "type";
            case 3L: return "nodest_jmp";
            case 4L: return "itself_call";
            case 5L: return "nodest_call";
            case 6L: return "interrupt";
            case 7L: return "eval";
            case 8L: return "regs";
            case 9L: return "done";
            case 10L: return "dfa_standard";
            case 11L: return "dfa_resolved_func";
            case 12L: return "dfa_unresolved_func";
            case 13L: return "dfa_variable";
            case 14L: return "dfa_conditional_def";
            case 15L: return "edgeLabel";
            case 16L: return "visitedCounter";
            case 17L: return "variable";
            case 18L: return "dfa_bufferoverflow";
            case 19L: return "e_last_property";
            default: return "";
        }
    }

    std::string GraphProperties(int64_t i, const std::string &strip) {
        std::string s = GraphProperties(i);
        if (s.empty())
            s = "(SgGraph::GraphProperties)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& GraphProperties() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L
        };
        static const std::vector<int64_t> retval(values, values + 20);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgGraphGraphProperties(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgGraph::GraphProperties(i);
        if (retval.empty()) {
            retval = "(SgGraph::GraphProperties)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgGraph::GraphProperties::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgGraphGraphProperties() {
        return stringify::SgGraph::GraphProperties();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 42791
namespace stringify { namespace SgDataStatementValue {
    const char* data_statement_value_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_default";
            case 2L: return "e_explict_list";
            case 3L: return "e_implicit_list";
            case 4L: return "e_implied_do";
            case 5L: return "e_last_initializer_form";
            default: return "";
        }
    }

    std::string data_statement_value_enum(int64_t i, const std::string &strip) {
        std::string s = data_statement_value_enum(i);
        if (s.empty())
            s = "(SgDataStatementValue::data_statement_value_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& data_statement_value_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgDataStatementValue_data_statement_value_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgDataStatementValue::data_statement_value_enum(i);
        if (retval.empty()) {
            retval = "(SgDataStatementValue::data_statement_value_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgDataStatementValue::data_statement_value_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgDataStatementValue_data_statement_value_enum() {
        return stringify::SgDataStatementValue::data_statement_value_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 43860
namespace stringify { namespace SgType {
    const char* useWithinDeclarationEnum(int64_t i) {
        switch (i) {
            case 1L: return "e_first_declaration";
            case 2L: return "e_autonomous_tag_declaration";
            default: return "";
        }
    }

    std::string useWithinDeclarationEnum(int64_t i, const std::string &strip) {
        std::string s = useWithinDeclarationEnum(i);
        if (s.empty())
            s = "(SgType::useWithinDeclarationEnum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& useWithinDeclarationEnum() {
        static const int64_t values[] = {
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgType_useWithinDeclarationEnum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgType::useWithinDeclarationEnum(i);
        if (retval.empty()) {
            retval = "(SgType::useWithinDeclarationEnum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgType::useWithinDeclarationEnum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgType_useWithinDeclarationEnum() {
        return stringify::SgType::useWithinDeclarationEnum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 43878
namespace stringify { namespace SgType {
    const char* fortran_attribute_specifiers_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown_attribute_specifier";
            case 1L: return "e_public_access";
            case 2L: return "e_private_access";
            case 3L: return "e_allocatable";
            case 4L: return "e_asynchronous";
            case 5L: return "e_bind";
            case 6L: return "e_data";
            case 7L: return "e_dimension";
            case 8L: return "e_intent";
            case 9L: return "e_optional";
            case 10L: return "e_parameter";
            case 11L: return "e_pointer";
            case 12L: return "e_protected";
            case 13L: return "e_save";
            case 14L: return "e_target";
            case 15L: return "e_value";
            case 16L: return "e_volatile";
            case 17L: return "e_last_attribute_specifier";
            default: return "";
        }
    }

    std::string fortran_attribute_specifiers_enum(int64_t i, const std::string &strip) {
        std::string s = fortran_attribute_specifiers_enum(i);
        if (s.empty())
            s = "(SgType::fortran_attribute_specifiers_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& fortran_attribute_specifiers_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L
        };
        static const std::vector<int64_t> retval(values, values + 18);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgType_fortran_attribute_specifiers_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgType::fortran_attribute_specifiers_enum(i);
        if (retval.empty()) {
            retval = "(SgType::fortran_attribute_specifiers_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgType::fortran_attribute_specifiers_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgType_fortran_attribute_specifiers_enum() {
        return stringify::SgType::fortran_attribute_specifiers_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 60985
namespace stringify { namespace SgModifierType {
    const char* modifiers(int64_t i) {
        switch (i) {
            case 1L: return "m_volatile";
            case 2L: return "m_global";
            case 4L: return "m_sync";
            case 8L: return "m_const";
            case 16L: return "m_restrict";
            case 32L: return "m_shared";
            case 64L: return "m_strict";
            case 128L: return "m_relaxed";
            default: return "";
        }
    }

    std::string modifiers(int64_t i, const std::string &strip) {
        std::string s = modifiers(i);
        if (s.empty())
            s = "(SgModifierType::modifiers)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& modifiers() {
        static const int64_t values[] = {
            1L,
            2L,
            4L,
            8L,
            16L,
            32L,
            64L,
            128L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgModifierType_modifiers(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgModifierType::modifiers(i);
        if (retval.empty()) {
            retval = "(SgModifierType::modifiers)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgModifierType::modifiers::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgModifierType_modifiers() {
        return stringify::SgModifierType::modifiers();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 61039
namespace stringify { namespace SgModifierType {
    const char* type_modifier_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_const";
            case 2L: return "e_volatile";
            case 4L: return "e_restrict";
            case 8L: return "e_unaligned";
            case 16L: return "e_near";
            case 32L: return "e_far";
            case 64L: return "e_upc_shared";
            case 128L: return "e_upc_strict";
            case 256L: return "e_upc_relaxed";
            case 512L: return "e_last_type_modifier";
            default: return "";
        }
    }

    std::string type_modifier_enum(int64_t i, const std::string &strip) {
        std::string s = type_modifier_enum(i);
        if (s.empty())
            s = "(SgModifierType::type_modifier_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& type_modifier_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            4L,
            8L,
            16L,
            32L,
            64L,
            128L,
            256L,
            512L
        };
        static const std::vector<int64_t> retval(values, values + 11);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgModifierType_type_modifier_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgModifierType::type_modifier_enum(i);
        if (retval.empty()) {
            retval = "(SgModifierType::type_modifier_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgModifierType::type_modifier_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgModifierType_type_modifier_enum() {
        return stringify::SgModifierType::type_modifier_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 61056
namespace stringify { namespace SgModifierType {
    const char* storage_modifier_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown_storage";
            case 1L: return "e_extern";
            case 2L: return "e_static";
            case 3L: return "e_auto";
            case 4L: return "e_unspecified";
            case 5L: return "e_typedef";
            case 6L: return "e_register";
            case 7L: return "e_asm";
            case 8L: return "e_local";
            case 9L: return "e_common";
            case 10L: return "e_associated";
            case 11L: return "e_intrinsic";
            case 12L: return "e_pointer_based";
            case 13L: return "e_last_storage_modifier";
            default: return "";
        }
    }

    std::string storage_modifier_enum(int64_t i, const std::string &strip) {
        std::string s = storage_modifier_enum(i);
        if (s.empty())
            s = "(SgModifierType::storage_modifier_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& storage_modifier_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L
        };
        static const std::vector<int64_t> retval(values, values + 14);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgModifierType_storage_modifier_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgModifierType::storage_modifier_enum(i);
        if (retval.empty()) {
            retval = "(SgModifierType::storage_modifier_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgModifierType::storage_modifier_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgModifierType_storage_modifier_enum() {
        return stringify::SgModifierType::storage_modifier_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 61078
namespace stringify { namespace SgModifierType {
    const char* access_modifier_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown_access";
            case 1L: return "e_private";
            case 2L: return "e_protected";
            case 3L: return "e_public";
            case 4L: return "e_virtual";
            case 5L: return "e_last_access_modifier";
            default: return "";
        }
    }

    std::string access_modifier_enum(int64_t i, const std::string &strip) {
        std::string s = access_modifier_enum(i);
        if (s.empty())
            s = "(SgModifierType::access_modifier_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& access_modifier_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgModifierType_access_modifier_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgModifierType::access_modifier_enum(i);
        if (retval.empty()) {
            retval = "(SgModifierType::access_modifier_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgModifierType::access_modifier_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgModifierType_access_modifier_enum() {
        return stringify::SgModifierType::access_modifier_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 62233
namespace stringify { namespace SgMemberFunctionType {
    const char* mfunc_specifier_enum(int64_t i) {
        switch (i) {
            case 1L: return "e_const";
            case 2L: return "e_volatile";
            case 4L: return "e_restrict";
            case 8L: return "e_ref_qualifier_lvalue";
            case 16L: return "e_ref_qualifier_rvalue";
            default: return "";
        }
    }

    std::string mfunc_specifier_enum(int64_t i, const std::string &strip) {
        std::string s = mfunc_specifier_enum(i);
        if (s.empty())
            s = "(SgMemberFunctionType::mfunc_specifier_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& mfunc_specifier_enum() {
        static const int64_t values[] = {
            1L,
            2L,
            4L,
            8L,
            16L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgMemberFunctionType_mfunc_specifier_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgMemberFunctionType::mfunc_specifier_enum(i);
        if (retval.empty()) {
            retval = "(SgMemberFunctionType::mfunc_specifier_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgMemberFunctionType::mfunc_specifier_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgMemberFunctionType_mfunc_specifier_enum() {
        return stringify::SgMemberFunctionType::mfunc_specifier_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 73653
namespace stringify { namespace SgLocatedNode {
    const char* PositionOfPreprocessingInfoInListType(int64_t i) {
        switch (i) {
            case 0L: return "defaultValue";
            case 1L: return "prependPreprocessingInfoToList";
            case 2L: return "appendPreprocessingInfoToList";
            default: return "";
        }
    }

    std::string PositionOfPreprocessingInfoInListType(int64_t i, const std::string &strip) {
        std::string s = PositionOfPreprocessingInfoInListType(i);
        if (s.empty())
            s = "(SgLocatedNode::PositionOfPreprocessingInfoInListType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& PositionOfPreprocessingInfoInListType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgLocatedNodePositionOfPreprocessingInfoInListType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgLocatedNode::PositionOfPreprocessingInfoInListType(i);
        if (retval.empty()) {
            retval = "(SgLocatedNode::PositionOfPreprocessingInfoInListType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgLocatedNode::PositionOfPreprocessingInfoInListType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgLocatedNodePositionOfPreprocessingInfoInListType() {
        return stringify::SgLocatedNode::PositionOfPreprocessingInfoInListType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 74403
namespace stringify { namespace SgToken {
    const char* ROSE_Fortran_Keywords(int64_t i) {
        switch (i) {
            case 0L: return "FORTRAN_ABSTRACT";
            case 1L: return "FORTRAN_ACCESS";
            case 2L: return "FORTRAN_ACTION";
            case 3L: return "FORTRAN_ALLOCATE";
            case 4L: return "FORTRAN_ALLOCATABLE";
            case 5L: return "FORTRAN_ASSIGN";
            case 6L: return "FORTRAN_ASSOCIATE";
            case 7L: return "FORTRAN_ASYNCHRONOUS";
            case 8L: return "FORTRAN_BACKSPACE";
            case 9L: return "FORTRAN_BIND";
            case 10L: return "FORTRAN_BLANK";
            case 11L: return "FORTRAN_BLOCK_DATA";
            case 12L: return "FORTRAN_CALL";
            case 13L: return "FORTRAN_CHARACTER";
            case 14L: return "FORTRAN_CLASS";
            case 15L: return "FORTRAN_CLOSE";
            case 16L: return "FORTRAN_CONTINUE";
            case 17L: return "FORTRAN_CYCLE";
            case 18L: return "FORTRAN_CASE";
            case 19L: return "FORTRAN_COMMON";
            case 20L: return "FORTRAN_COMPLEX";
            case 21L: return "FORTRAN_CONTAINS";
            case 22L: return "FORTRAN_DEALLOCATE";
            case 23L: return "FORTRAN_DATA";
            case 24L: return "FORTRAN_DEFERRED";
            case 25L: return "FORTRAN_DELIM";
            case 26L: return "FORTRAN_DIMENSION";
            case 27L: return "FORTRAN_DO";
            case 28L: return "FORTRAN_DT";
            case 29L: return "FORTRAN_DOUBLEPRECISION";
            case 30L: return "FORTRAN_ENCODING";
            case 31L: return "FORTRAN_END_CASE";
            case 32L: return "FORTRAN_ENDDO";
            case 33L: return "FORTRAN_END_FILE";
            case 34L: return "FORTRAN_END_ENUM";
            case 35L: return "FORTRAN_END_INTERFACE";
            case 36L: return "FORTRAN_END_TYPE";
            case 37L: return "FORTRAN_ERR";
            case 38L: return "FORTRAN_ERRMSG";
            case 39L: return "FORTRAN_EXIT";
            case 40L: return "FORTRAN_ELSE";
            case 41L: return "FORTRAN_ELSEWHERE";
            case 42L: return "FORTRAN_ELSEIF";
            case 43L: return "FORTRAN_ENDIF";
            case 44L: return "FORTRAN_ENTRY";
            case 45L: return "FORTRAN_END";
            case 46L: return "FORTRAN_ENUM";
            case 47L: return "FORTRAN_ENUMERATOR";
            case 48L: return "FORTRAN_EQUIVALENCE";
            case 49L: return "FORTRAN_EXTERNAL";
            case 50L: return "FORTRAN_EXTENDS";
            case 51L: return "FORTRAN_FILE";
            case 52L: return "FORTRAN_FINAL";
            case 53L: return "FORTRAN_FMT";
            case 54L: return "FORTRAN_FORALL";
            case 55L: return "FORTRAN_FORM";
            case 56L: return "FORTRAN_FORMATTED";
            case 57L: return "FORTRAN_FORMAT";
            case 58L: return "FORTRAN_FLUSH";
            case 59L: return "FORTRAN_FUNCTION";
            case 60L: return "FORTRAN_GENERIC";
            case 61L: return "FORTRAN_GOTO";
            case 62L: return "FORTRAN_ID";
            case 63L: return "FORTRAN_IF";
            case 64L: return "FORTRAN_INQUIRE";
            case 65L: return "FORTRAN_INTEGER";
            case 66L: return "FORTRAN_IOMSG";
            case 67L: return "FORTRAN_IOSTAT";
            case 68L: return "FORTRAN_IMPLICIT";
            case 69L: return "FORTRAN_IMPLICIT_NONE";
            case 70L: return "FORTRAN_IMPORT";
            case 71L: return "FORTRAN_INTERFACE";
            case 72L: return "FORTRAN_INTENT";
            case 73L: return "FORTRAN_INTRINSIC";
            case 74L: return "FORTRAN_LEN";
            case 75L: return "FORTRAN_LOGICAL";
            case 76L: return "FORTRAN_KIND";
            case 77L: return "FORTRAN_MODULE_PROC";
            case 78L: return "FORTRAN_MODULE";
            case 79L: return "FORTRAN_NON_INTRINSIC";
            case 80L: return "FORTRAN_NON_OVERRIDABLE";
            case 81L: return "FORTRAN_NULL";
            case 82L: return "FORTRAN_NULLIFY";
            case 83L: return "FORTRAN_NAMELIST";
            case 84L: return "FORTRAN_NML";
            case 85L: return "FORTRAN_NONE";
            case 86L: return "FORTRAN_NOPASS";
            case 87L: return "FORTRAN_ONLY";
            case 88L: return "FORTRAN_OPEN";
            case 89L: return "FORTRAN_OPTIONAL";
            case 90L: return "FORTRAN_PARAMETER";
            case 91L: return "FORTRAN_PASS";
            case 92L: return "FORTRAN_PAUSE";
            case 93L: return "FORTRAN_POINTER";
            case 94L: return "FORTRAN_PRINT";
            case 95L: return "FORTRAN_PRIVATE";
            case 96L: return "FORTRAN_PROCEDURE";
            case 97L: return "FORTRAN_PROGRAM";
            case 98L: return "FORTRAN_PROTECTED";
            case 99L: return "FORTRAN_READ";
            case 100L: return "FORTRAN_REAL";
            case 101L: return "FORTRAN_RETURN";
            case 102L: return "FORTRAN_REWIND";
            case 103L: return "FORTRAN_ROUND";
            case 104L: return "FORTRAN_SELECTCASE";
            case 105L: return "FORTRAN_SELECTTYPE";
            case 106L: return "FORTRAN_SEQUENCE";
            case 107L: return "FORTRAN_SAVE";
            case 108L: return "FORTRAN_SIGN";
            case 109L: return "FORTRAN_SIZE";
            case 110L: return "FORTRAN_SOURCE";
            case 111L: return "FORTRAN_STAT";
            case 112L: return "FORTRAN_STOP";
            case 113L: return "FORTRAN_SUBROUTINE";
            case 114L: return "FORTRAN_TARGET";
            case 115L: return "FORTRAN_THEN";
            case 116L: return "FORTRAN_DERIVED_DECL";
            case 117L: return "FORTRAN_TYPEIS";
            case 118L: return "FORTRAN_UNFORMATTED";
            case 119L: return "FORTRAN_UNIT";
            case 120L: return "FORTRAN_USE";
            case 121L: return "FORTRAN_VALUE";
            case 122L: return "FORTRAN_VOLATILE";
            case 123L: return "FORTRAN_WAIT";
            case 124L: return "FORTRAN_WHERE";
            case 125L: return "FORTRAN_WRITE";
            case 126L: return "FORTRAN_END_PROGRAM";
            case 127L: return "FORTRAN_END_FUNCTION";
            case 128L: return "FORTRAN_END_SUBROUTINE";
            case 129L: return "FORTRAN_END_MODULE";
            case 130L: return "FORTRAN_END_BLOCK_DATA";
            case 131L: return "FORTRAN_SUBMODULE";
            case 132L: return "FORTRAN_END_SUBMODULE";
            case 133L: return "FORTRAN_DOUBLE_COMPLEX";
            case 134L: return "FORTRAN_TYPE";
            case 135L: return "FORTRAN_ABSTRACT_INTERFACE";
            case 136L: return "FORTRAN_ERROR_STOP";
            case 137L: return "FORTRAN_CONTIGUOUS";
            case 138L: return "FORTRAN_PUBLIC";
            case 139L: return "FORTRAN_ELEMENTAL";
            case 140L: return "FORTRAN_IMPURE";
            case 141L: return "FORTRAN_PURE";
            case 142L: return "FORTRAN_RECURSIVE";
            case 143L: return "FORTRAN_INTENT_IN";
            case 144L: return "FORTRAN_INTENT_OUT";
            case 145L: return "FORTRAN_INTENT_INOUT";
            case 146L: return "FORTRAN_ASSIGNMENT";
            case 147L: return "FORTRAN_OPERATOR";
            case 148L: return "FORTRAN_READ_FORMATTED";
            case 149L: return "FORTRAN_READ_UNFORMATTED";
            case 150L: return "FORTRAN_WRITE_FORMATTED";
            case 151L: return "FORTRAN_WRITE_UNFORMATTED";
            case 152L: return "FORTRAN_UNKNOWN";
            default: return "";
        }
    }

    std::string ROSE_Fortran_Keywords(int64_t i, const std::string &strip) {
        std::string s = ROSE_Fortran_Keywords(i);
        if (s.empty())
            s = "(SgToken::ROSE_Fortran_Keywords)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ROSE_Fortran_Keywords() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L,
            58L,
            59L,
            60L,
            61L,
            62L,
            63L,
            64L,
            65L,
            66L,
            67L,
            68L,
            69L,
            70L,
            71L,
            72L,
            73L,
            74L,
            75L,
            76L,
            77L,
            78L,
            79L,
            80L,
            81L,
            82L,
            83L,
            84L,
            85L,
            86L,
            87L,
            88L,
            89L,
            90L,
            91L,
            92L,
            93L,
            94L,
            95L,
            96L,
            97L,
            98L,
            99L,
            100L,
            101L,
            102L,
            103L,
            104L,
            105L,
            106L,
            107L,
            108L,
            109L,
            110L,
            111L,
            112L,
            113L,
            114L,
            115L,
            116L,
            117L,
            118L,
            119L,
            120L,
            121L,
            122L,
            123L,
            124L,
            125L,
            126L,
            127L,
            128L,
            129L,
            130L,
            131L,
            132L,
            133L,
            134L,
            135L,
            136L,
            137L,
            138L,
            139L,
            140L,
            141L,
            142L,
            143L,
            144L,
            145L,
            146L,
            147L,
            148L,
            149L,
            150L,
            151L,
            152L
        };
        static const std::vector<int64_t> retval(values, values + 153);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgTokenROSE_Fortran_Keywords(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgToken::ROSE_Fortran_Keywords(i);
        if (retval.empty()) {
            retval = "(SgToken::ROSE_Fortran_Keywords)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgToken::ROSE_Fortran_Keywords::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgTokenROSE_Fortran_Keywords() {
        return stringify::SgToken::ROSE_Fortran_Keywords();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 74570
namespace stringify { namespace SgToken {
    const char* ROSE_C_CXX_keywords(int64_t i) {
        switch (i) {
            case 500L: return "C_CXX_ASM";
            case 501L: return "C_CXX_AUTO";
            case 502L: return "C_CXX_BOOL";
            case 503L: return "C_CXX_BREAK";
            case 504L: return "C_CXX_CASE";
            case 505L: return "C_CXX_CATCH";
            case 506L: return "C_CXX_CHAR";
            case 507L: return "C_CXX_CLASS";
            case 508L: return "C_CXX_CONST";
            case 509L: return "C_CXX_CONSTCAST";
            case 510L: return "C_CXX_CONTINUE";
            case 511L: return "C_CXX_DEFAULT";
            case 512L: return "C_CXX_DEFINED";
            case 513L: return "C_CXX_DELETE";
            case 514L: return "C_CXX_DO";
            case 515L: return "C_CXX_DOUBLE";
            case 516L: return "C_CXX_DYNAMICCAST";
            case 517L: return "C_CXX_ELSE";
            case 518L: return "C_CXX_ENUM";
            case 519L: return "C_CXX_EXPLICIT";
            case 520L: return "C_CXX_EXPORT";
            case 521L: return "C_CXX_EXTERN";
            case 522L: return "C_CXX_FALSE";
            case 523L: return "C_CXX_FLOAT";
            case 524L: return "C_CXX_FOR";
            case 525L: return "C_CXX_FRIEND";
            case 526L: return "C_CXX_GOTO";
            case 527L: return "C_CXX_IF";
            case 528L: return "C_CXX_INLINE";
            case 529L: return "C_CXX_INT";
            case 530L: return "C_CXX_LONG";
            case 531L: return "C_CXX_MUTABLE";
            case 532L: return "C_CXX_NAMESPACE";
            case 533L: return "C_CXX_NEW";
            case 534L: return "C_CXX_OPERATOR";
            case 535L: return "C_CXX_PRIVATE";
            case 536L: return "C_CXX_PROTECTED";
            case 537L: return "C_CXX_PUBLIC";
            case 538L: return "C_CXX_REGISTER";
            case 539L: return "C_CXX_REINTERPRETCAST";
            case 540L: return "C_CXX_RETURN";
            case 541L: return "C_CXX_SHORT";
            case 542L: return "C_CXX_SIGNED";
            case 543L: return "C_CXX_SIZEOF";
            case 544L: return "C_CXX_STATIC";
            case 545L: return "C_CXX_STATICCAST";
            case 546L: return "C_CXX_STRUCT";
            case 547L: return "C_CXX_SWITCH";
            case 548L: return "C_CXX_TEMPLATE";
            case 549L: return "C_CXX_THIS";
            case 550L: return "C_CXX_THROW";
            case 551L: return "C_CXX_TRY";
            case 552L: return "C_CXX_TRUE";
            case 553L: return "C_CXX_TYPEDEF";
            case 554L: return "C_CXX_TYPEID";
            case 555L: return "C_CXX_TYPENAME";
            case 556L: return "C_CXX_UNION";
            case 557L: return "C_CXX_UNSIGNED";
            case 558L: return "C_CXX_USING";
            case 559L: return "C_CXX_VIRTUAL";
            case 560L: return "C_CXX_VOID";
            case 561L: return "C_CXX_VOLATILE";
            case 562L: return "C_CXX_WCHART";
            case 563L: return "C_CXX_WHILE";
            default: return "";
        }
    }

    std::string ROSE_C_CXX_keywords(int64_t i, const std::string &strip) {
        std::string s = ROSE_C_CXX_keywords(i);
        if (s.empty())
            s = "(SgToken::ROSE_C_CXX_keywords)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ROSE_C_CXX_keywords() {
        static const int64_t values[] = {
            500L,
            501L,
            502L,
            503L,
            504L,
            505L,
            506L,
            507L,
            508L,
            509L,
            510L,
            511L,
            512L,
            513L,
            514L,
            515L,
            516L,
            517L,
            518L,
            519L,
            520L,
            521L,
            522L,
            523L,
            524L,
            525L,
            526L,
            527L,
            528L,
            529L,
            530L,
            531L,
            532L,
            533L,
            534L,
            535L,
            536L,
            537L,
            538L,
            539L,
            540L,
            541L,
            542L,
            543L,
            544L,
            545L,
            546L,
            547L,
            548L,
            549L,
            550L,
            551L,
            552L,
            553L,
            554L,
            555L,
            556L,
            557L,
            558L,
            559L,
            560L,
            561L,
            562L,
            563L
        };
        static const std::vector<int64_t> retval(values, values + 64);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgTokenROSE_C_CXX_keywords(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgToken::ROSE_C_CXX_keywords(i);
        if (retval.empty()) {
            retval = "(SgToken::ROSE_C_CXX_keywords)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgToken::ROSE_C_CXX_keywords::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgTokenROSE_C_CXX_keywords() {
        return stringify::SgToken::ROSE_C_CXX_keywords();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 74639
namespace stringify { namespace SgToken {
    const char* ROSE_Fortran_Operators(int64_t i) {
        switch (i) {
            case 10000L: return "FORTRAN_INTRINSIC_PLUS";
            case 10001L: return "FORTRAN_INTRINSIC_MINUS";
            case 10002L: return "FORTRAN_INTRINSIC_POWER";
            case 10003L: return "FORTRAN_INTRINSIC_CONCAT";
            case 10004L: return "FORTRAN_INTRINSIC_TIMES";
            case 10005L: return "FORTRAN_INTRINSIC_DIVIDE";
            case 10006L: return "FORTRAN_INTRINSIC_AND";
            case 10007L: return "FORTRAN_INTRINSIC_OR";
            case 10008L: return "FORTRAN_INTRINSIC_EQV";
            case 10009L: return "FORTRAN_INTRINSIC_NEQV";
            case 10010L: return "FORTRAN_INTRINSIC_EQ";
            case 10011L: return "FORTRAN_INTRINSIC_NE";
            case 10012L: return "FORTRAN_INTRINSIC_GE";
            case 10013L: return "FORTRAN_INTRINSIC_LE";
            case 10014L: return "FORTRAN_INTRINSIC_LT";
            case 10015L: return "FORTRAN_INTRINSIC_GT";
            case 10016L: return "FORTRAN_INTRINSIC_NOT";
            case 10017L: return "FORTRAN_INTRINSIC_OLDEQ";
            case 10018L: return "FORTRAN_INTRINSIC_OLDNE";
            case 10019L: return "FORTRAN_INTRINSIC_OLDGE";
            case 10020L: return "FORTRAN_INTRINSIC_OLDLE";
            case 10021L: return "FORTRAN_INTRINSIC_OLDLT";
            case 10022L: return "FORTRAN_INTRINSIC_OLDGT";
            default: return "";
        }
    }

    std::string ROSE_Fortran_Operators(int64_t i, const std::string &strip) {
        std::string s = ROSE_Fortran_Operators(i);
        if (s.empty())
            s = "(SgToken::ROSE_Fortran_Operators)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ROSE_Fortran_Operators() {
        static const int64_t values[] = {
            10000L,
            10001L,
            10002L,
            10003L,
            10004L,
            10005L,
            10006L,
            10007L,
            10008L,
            10009L,
            10010L,
            10011L,
            10012L,
            10013L,
            10014L,
            10015L,
            10016L,
            10017L,
            10018L,
            10019L,
            10020L,
            10021L,
            10022L
        };
        static const std::vector<int64_t> retval(values, values + 23);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgTokenROSE_Fortran_Operators(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgToken::ROSE_Fortran_Operators(i);
        if (retval.empty()) {
            retval = "(SgToken::ROSE_Fortran_Operators)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgToken::ROSE_Fortran_Operators::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgTokenROSE_Fortran_Operators() {
        return stringify::SgToken::ROSE_Fortran_Operators();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 74666
namespace stringify { namespace SgToken {
    const char* ROSE_C_CXX_Operators(int64_t i) {
        switch (i) {
            case 50000L: return "C_CXX_AND";
            case 50001L: return "C_CXX_ANDAND";
            case 50002L: return "C_CXX_ASSIGN";
            case 50003L: return "C_CXX_ANDASSIGN";
            case 50004L: return "C_CXX_OR";
            case 50005L: return "C_CXX_ORASSIGN";
            case 50006L: return "C_CXX_XOR";
            case 50007L: return "C_CXX_XORASSIGN";
            case 50008L: return "C_CXX_COMMA";
            case 50009L: return "C_CXX_COLON";
            case 50010L: return "C_CXX_DIVIDE";
            case 50011L: return "C_CXX_DIVIDEASSIGN";
            case 50012L: return "C_CXX_DOT";
            case 50013L: return "C_CXX_DOTSTAR";
            case 50014L: return "C_CXX_ELLIPSIS";
            case 50015L: return "C_CXX_EQUAL";
            case 50016L: return "C_CXX_GREATER";
            case 50017L: return "C_CXX_GREATEREQUAL";
            case 50018L: return "C_CXX_LEFTBRACE";
            case 50019L: return "C_CXX_LESS";
            case 50020L: return "C_CXX_LESSEQUAL";
            case 50021L: return "C_CXX_LEFTPAREN";
            case 50022L: return "C_CXX_LEFTBRACKET";
            case 50023L: return "C_CXX_MINUS";
            case 50024L: return "C_CXX_MINUSASSIGN";
            case 50025L: return "C_CXX_MINUSMINUS";
            case 50026L: return "C_CXX_PERCENT";
            case 50027L: return "C_CXX_PERCENTASSIGN";
            case 50028L: return "C_CXX_NOT";
            case 50029L: return "C_CXX_NOTEQUAL";
            case 50030L: return "C_CXX_OROR";
            case 50031L: return "C_CXX_PLUS";
            case 50032L: return "C_CXX_PLUSASSIGN";
            case 50033L: return "C_CXX_PLUSPLUS";
            case 50034L: return "C_CXX_ARROW";
            case 50035L: return "C_CXX_ARROWSTAR";
            case 50036L: return "C_CXX_QUESTION_MARK";
            case 50037L: return "C_CXX_RIGHTBRACE";
            case 50038L: return "C_CXX_RIGHTPAREN";
            case 50039L: return "C_CXX_RIGHTBRACKET";
            case 50040L: return "C_CXX_COLON_COLON";
            case 50041L: return "C_CXX_SEMICOLON";
            case 50042L: return "C_CXX_SHIFTLEFT";
            case 50043L: return "C_CXX_SHIFTLEFTASSIGN";
            case 50044L: return "C_CXX_SHIFTRIGHT";
            case 50045L: return "C_CXX_SHIFTRIGHTASSIGN";
            case 50046L: return "C_CXX_STAR";
            case 50047L: return "C_CXX_COMPL";
            case 50048L: return "C_CXX_STARASSIGN";
            case 50049L: return "C_CXX_POUND_POUND";
            case 50050L: return "C_CXX_POUND";
            case 50051L: return "C_CXX_AND_ALT";
            case 50052L: return "C_CXX_ANDASSIGN_ALT";
            case 50053L: return "C_CXX_OR_ALT";
            case 50054L: return "C_CXX_ORASSIGN_ALT";
            case 50055L: return "C_CXX_XOR_ALT";
            case 50056L: return "C_CXX_XORASSIGN_ALT";
            case 50057L: return "C_CXX_LEFTBRACE_ALT";
            case 50058L: return "C_CXX_LEFTBRACKET_ALT";
            case 50059L: return "C_CXX_NOT_ALT";
            case 50060L: return "C_CXX_NOTEQUAL_ALT";
            case 50061L: return "C_CXX_RIGHTBRACE_ALT";
            case 50062L: return "C_CXX_RIGHTBRACKET_ALT";
            case 50063L: return "C_CXX_COMPL_ALT";
            case 50064L: return "C_CXX_POUND_POUND_ALT";
            case 50065L: return "C_CXX_POUND_ALT";
            case 50066L: return "C_CXX_OR_TRIGRAPH";
            case 50067L: return "C_CXX_XOR_TRIGRAPH";
            case 50068L: return "C_CXX_LEFTBRACE_TRIGRAPH";
            case 50069L: return "C_CXX_LEFTBRACKET_TRIGRAPH";
            case 50070L: return "C_CXX_RIGHTBRACE_TRIGRAPH";
            case 50071L: return "C_CXX_RIGHTBRACKET_TRIGRAPH";
            case 50072L: return "C_CXX_COMPL_TRIGRAPH";
            case 50073L: return "C_CXX_POUND_POUND_TRIGRAPH";
            case 50074L: return "C_CXX_POUND_TRIGRAPH";
            default: return "";
        }
    }

    std::string ROSE_C_CXX_Operators(int64_t i, const std::string &strip) {
        std::string s = ROSE_C_CXX_Operators(i);
        if (s.empty())
            s = "(SgToken::ROSE_C_CXX_Operators)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ROSE_C_CXX_Operators() {
        static const int64_t values[] = {
            50000L,
            50001L,
            50002L,
            50003L,
            50004L,
            50005L,
            50006L,
            50007L,
            50008L,
            50009L,
            50010L,
            50011L,
            50012L,
            50013L,
            50014L,
            50015L,
            50016L,
            50017L,
            50018L,
            50019L,
            50020L,
            50021L,
            50022L,
            50023L,
            50024L,
            50025L,
            50026L,
            50027L,
            50028L,
            50029L,
            50030L,
            50031L,
            50032L,
            50033L,
            50034L,
            50035L,
            50036L,
            50037L,
            50038L,
            50039L,
            50040L,
            50041L,
            50042L,
            50043L,
            50044L,
            50045L,
            50046L,
            50047L,
            50048L,
            50049L,
            50050L,
            50051L,
            50052L,
            50053L,
            50054L,
            50055L,
            50056L,
            50057L,
            50058L,
            50059L,
            50060L,
            50061L,
            50062L,
            50063L,
            50064L,
            50065L,
            50066L,
            50067L,
            50068L,
            50069L,
            50070L,
            50071L,
            50072L,
            50073L,
            50074L
        };
        static const std::vector<int64_t> retval(values, values + 75);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgTokenROSE_C_CXX_Operators(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgToken::ROSE_C_CXX_Operators(i);
        if (retval.empty()) {
            retval = "(SgToken::ROSE_C_CXX_Operators)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgToken::ROSE_C_CXX_Operators::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgTokenROSE_C_CXX_Operators() {
        return stringify::SgToken::ROSE_C_CXX_Operators();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 74746
namespace stringify { namespace SgToken {
    const char* ROSE_Fortran_Additional_Info(int64_t i) {
        switch (i) {
            case 100000L: return "FORTRAN_COMMENTS";
            case 100001L: return "FORTRAN_STRING_LITERALS";
            case 100002L: return "FORTRAN_IDENTIFIER";
            case 100003L: return "FORTRAN_UNIDENTIFIED_TOKEN";
            case 100004L: return "FORTRAN_ERROR";
            default: return "";
        }
    }

    std::string ROSE_Fortran_Additional_Info(int64_t i, const std::string &strip) {
        std::string s = ROSE_Fortran_Additional_Info(i);
        if (s.empty())
            s = "(SgToken::ROSE_Fortran_Additional_Info)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ROSE_Fortran_Additional_Info() {
        static const int64_t values[] = {
            100000L,
            100001L,
            100002L,
            100003L,
            100004L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgTokenROSE_Fortran_Additional_Info(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgToken::ROSE_Fortran_Additional_Info(i);
        if (retval.empty()) {
            retval = "(SgToken::ROSE_Fortran_Additional_Info)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgToken::ROSE_Fortran_Additional_Info::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgTokenROSE_Fortran_Additional_Info() {
        return stringify::SgToken::ROSE_Fortran_Additional_Info();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 76084
namespace stringify { namespace SgInitializedName {
    const char* preinitialization_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown_preinitialization";
            case 1L: return "e_virtual_base_class";
            case 2L: return "e_nonvirtual_base_class";
            case 3L: return "e_data_member";
            case 4L: return "e_delegation_constructor";
            case 5L: return "e_last_preinitialization";
            default: return "";
        }
    }

    std::string preinitialization_enum(int64_t i, const std::string &strip) {
        std::string s = preinitialization_enum(i);
        if (s.empty())
            s = "(SgInitializedName::preinitialization_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& preinitialization_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgInitializedName_preinitialization_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgInitializedName::preinitialization_enum(i);
        if (retval.empty()) {
            retval = "(SgInitializedName::preinitialization_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgInitializedName::preinitialization_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgInitializedName_preinitialization_enum() {
        return stringify::SgInitializedName::preinitialization_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 76099
namespace stringify { namespace SgInitializedName {
    const char* asm_register_name_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_invalid_register";
            case 1L: return "e_memory_register";
            case 2L: return "e_register_a";
            case 3L: return "e_register_b";
            case 4L: return "e_register_c";
            case 5L: return "e_register_d";
            case 6L: return "e_register_si";
            case 7L: return "e_register_di";
            case 8L: return "e_register_bp";
            case 9L: return "e_register_sp";
            case 10L: return "e_register_r8";
            case 11L: return "e_register_r9";
            case 12L: return "e_register_r10";
            case 13L: return "e_register_r11";
            case 14L: return "e_register_r12";
            case 15L: return "e_register_r13";
            case 16L: return "e_register_r14";
            case 17L: return "e_register_r15";
            case 18L: return "e_register_st0";
            case 19L: return "e_register_st1";
            case 20L: return "e_register_st2";
            case 21L: return "e_register_st3";
            case 22L: return "e_register_st4";
            case 23L: return "e_register_st5";
            case 24L: return "e_register_st6";
            case 25L: return "e_register_st7";
            case 26L: return "e_register_mm0";
            case 27L: return "e_register_mm1";
            case 28L: return "e_register_mm2";
            case 29L: return "e_register_mm3";
            case 30L: return "e_register_mm4";
            case 31L: return "e_register_mm5";
            case 32L: return "e_register_mm6";
            case 33L: return "e_register_mm7";
            case 34L: return "e_register_f0";
            case 35L: return "e_register_f1";
            case 36L: return "e_register_f2";
            case 37L: return "e_register_f3";
            case 38L: return "e_register_f4";
            case 39L: return "e_register_f5";
            case 40L: return "e_register_f6";
            case 41L: return "e_register_f7";
            case 42L: return "e_register_f8";
            case 43L: return "e_register_f9";
            case 44L: return "e_register_f10";
            case 45L: return "e_register_f11";
            case 46L: return "e_register_f12";
            case 47L: return "e_register_f13";
            case 48L: return "e_register_f14";
            case 49L: return "e_register_f15";
            case 50L: return "e_register_flags";
            case 51L: return "e_register_fpsr";
            case 52L: return "e_register_dirflag";
            case 53L: return "e_unrecognized_register";
            case 54L: return "e_last_register";
            default: return "";
        }
    }

    std::string asm_register_name_enum(int64_t i, const std::string &strip) {
        std::string s = asm_register_name_enum(i);
        if (s.empty())
            s = "(SgInitializedName::asm_register_name_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& asm_register_name_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L
        };
        static const std::vector<int64_t> retval(values, values + 55);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgInitializedName_asm_register_name_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgInitializedName::asm_register_name_enum(i);
        if (retval.empty()) {
            retval = "(SgInitializedName::asm_register_name_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgInitializedName::asm_register_name_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgInitializedName_asm_register_name_enum() {
        return stringify::SgInitializedName::asm_register_name_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 76161
namespace stringify { namespace SgInitializedName {
    const char* gnu_variable_attribute_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_gnu_attribute__weak__";
            case 1L: return "e_gnu_attribute__unused__";
            case 2L: return "e_gnu_attribute__used__";
            case 3L: return "e_gnu_attribute__deprecated__";
            case 4L: return "e_gnu_attribute__nocommon__";
            case 5L: return "e_gnu_attribute__transparent_union__";
            case 6L: return "e_gnu_attribute__weakref__";
            case 7L: return "e_gnu_attribute__packed__";
            case 8L: return "e_gnu_attribute__noreturn__";
            case 9L: return "e_ms_declspec_parameter_appdomain";
            case 10L: return "e_ms_declspec_parameter_deprecated";
            case 11L: return "e_ms_declspec_parameter_dllimport";
            case 12L: return "e_ms_declspec_parameter_dllexport";
            case 13L: return "e_ms_declspec_parameter_novtable";
            case 14L: return "e_ms_declspec_parameter_process";
            case 15L: return "e_ms_declspec_parameter_property";
            case 16L: return "e_ms_declspec_parameter_restrict";
            case 18L: return "e_ms_declspec_parameter_selectany";
            case 19L: return "e_ms_declspec_parameter_thread";
            case 20L: return "e_ms_declspec_parameter_uuid";
            case 21L: return "e_last_gnu_variable_attribute";
            default: return "";
        }
    }

    std::string gnu_variable_attribute_enum(int64_t i, const std::string &strip) {
        std::string s = gnu_variable_attribute_enum(i);
        if (s.empty())
            s = "(SgInitializedName::gnu_variable_attribute_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& gnu_variable_attribute_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            18L,
            19L,
            20L,
            21L
        };
        static const std::vector<int64_t> retval(values, values + 21);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgInitializedName_gnu_variable_attribute_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgInitializedName::gnu_variable_attribute_enum(i);
        if (retval.empty()) {
            retval = "(SgInitializedName::gnu_variable_attribute_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgInitializedName::gnu_variable_attribute_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgInitializedName_gnu_variable_attribute_enum() {
        return stringify::SgInitializedName::gnu_variable_attribute_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 76195
namespace stringify { namespace SgInitializedName {
    const char* excess_specifier_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_excess_specifier_none";
            case 1L: return "e_excess_specifier_positionals";
            case 2L: return "e_excess_specifier_keywords";
            case 3L: return "e_excess_specifier_last";
            default: return "";
        }
    }

    std::string excess_specifier_enum(int64_t i, const std::string &strip) {
        std::string s = excess_specifier_enum(i);
        if (s.empty())
            s = "(SgInitializedName::excess_specifier_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& excess_specifier_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgInitializedName_excess_specifier_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgInitializedName::excess_specifier_enum(i);
        if (retval.empty()) {
            retval = "(SgInitializedName::excess_specifier_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgInitializedName::excess_specifier_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgInitializedName_excess_specifier_enum() {
        return stringify::SgInitializedName::excess_specifier_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 78590
namespace stringify { namespace SgOmpClause {
    const char* omp_default_option_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_omp_default_unknown";
            case 1L: return "e_omp_default_variant";
            case 2L: return "e_omp_default_none";
            case 3L: return "e_omp_default_shared";
            case 4L: return "e_omp_default_private";
            case 5L: return "e_omp_default_firstprivate";
            case 6L: return "e_omp_default_last";
            default: return "";
        }
    }

    std::string omp_default_option_enum(int64_t i, const std::string &strip) {
        std::string s = omp_default_option_enum(i);
        if (s.empty())
            s = "(SgOmpClause::omp_default_option_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& omp_default_option_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgOmpClause_omp_default_option_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgOmpClause::omp_default_option_enum(i);
        if (retval.empty()) {
            retval = "(SgOmpClause::omp_default_option_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgOmpClause::omp_default_option_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgOmpClause_omp_default_option_enum() {
        return stringify::SgOmpClause::omp_default_option_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 78603
namespace stringify { namespace SgOmpClause {
    const char* omp_schedule_kind_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_omp_schedule_kind_unspecified";
            case 1L: return "e_omp_schedule_kind_static";
            case 2L: return "e_omp_schedule_kind_dynamic";
            case 3L: return "e_omp_schedule_kind_guided";
            case 4L: return "e_omp_schedule_kind_auto";
            case 5L: return "e_omp_schedule_kind_runtime";
            default: return "";
        }
    }

    std::string omp_schedule_kind_enum(int64_t i, const std::string &strip) {
        std::string s = omp_schedule_kind_enum(i);
        if (s.empty())
            s = "(SgOmpClause::omp_schedule_kind_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& omp_schedule_kind_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgOmpClause_omp_schedule_kind_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgOmpClause::omp_schedule_kind_enum(i);
        if (retval.empty()) {
            retval = "(SgOmpClause::omp_schedule_kind_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgOmpClause::omp_schedule_kind_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgOmpClause_omp_schedule_kind_enum() {
        return stringify::SgOmpClause::omp_schedule_kind_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 78612
namespace stringify { namespace SgOmpClause {
    const char* omp_schedule_modifier_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_omp_schedule_modifier_unspecified";
            case 1L: return "e_omp_schedule_modifier_monotonic";
            case 2L: return "e_omp_schedule_modifier_nonmonotonic";
            case 3L: return "e_omp_schedule_modifier_simd";
            default: return "";
        }
    }

    std::string omp_schedule_modifier_enum(int64_t i, const std::string &strip) {
        std::string s = omp_schedule_modifier_enum(i);
        if (s.empty())
            s = "(SgOmpClause::omp_schedule_modifier_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& omp_schedule_modifier_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgOmpClause_omp_schedule_modifier_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgOmpClause::omp_schedule_modifier_enum(i);
        if (retval.empty()) {
            retval = "(SgOmpClause::omp_schedule_modifier_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgOmpClause::omp_schedule_modifier_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgOmpClause_omp_schedule_modifier_enum() {
        return stringify::SgOmpClause::omp_schedule_modifier_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 78619
namespace stringify { namespace SgOmpClause {
    const char* omp_in_reduction_identifier_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_omp_in_reduction_identifier_unspecified";
            case 1L: return "e_omp_in_reduction_identifier_plus";
            case 2L: return "e_omp_in_reduction_identifier_mul";
            case 3L: return "e_omp_in_reduction_identifier_minus";
            case 4L: return "e_omp_in_reduction_identifier_bitand";
            case 5L: return "e_omp_in_reduction_identifier_bitor";
            case 6L: return "e_omp_in_reduction_identifier_bitxor";
            case 7L: return "e_omp_in_reduction_identifier_logand";
            case 8L: return "e_omp_in_reduction_identifier_logor";
            case 9L: return "e_omp_in_reduction_identifier_and";
            case 10L: return "e_omp_in_reduction_identifier_or";
            case 11L: return "e_omp_in_reduction_identifier_eqv";
            case 12L: return "e_omp_in_reduction_identifier_neqv";
            case 13L: return "e_omp_in_reduction_identifier_max";
            case 14L: return "e_omp_in_reduction_identifier_min";
            case 15L: return "e_omp_in_reduction_identifier_iand";
            case 16L: return "e_omp_in_reduction_identifier_ior";
            case 17L: return "e_omp_in_reduction_identifier_ieor";
            case 18L: return "e_omp_in_reduction_user_defined_identifier";
            case 19L: return "e_omp_in_reduction_identifier_last";
            default: return "";
        }
    }

    std::string omp_in_reduction_identifier_enum(int64_t i, const std::string &strip) {
        std::string s = omp_in_reduction_identifier_enum(i);
        if (s.empty())
            s = "(SgOmpClause::omp_in_reduction_identifier_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& omp_in_reduction_identifier_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L
        };
        static const std::vector<int64_t> retval(values, values + 20);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgOmpClause_omp_in_reduction_identifier_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgOmpClause::omp_in_reduction_identifier_enum(i);
        if (retval.empty()) {
            retval = "(SgOmpClause::omp_in_reduction_identifier_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgOmpClause::omp_in_reduction_identifier_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgOmpClause_omp_in_reduction_identifier_enum() {
        return stringify::SgOmpClause::omp_in_reduction_identifier_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 78646
namespace stringify { namespace SgOmpClause {
    const char* omp_task_reduction_identifier_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_omp_task_reduction_identifier_unspecified";
            case 1L: return "e_omp_task_reduction_identifier_plus";
            case 2L: return "e_omp_task_reduction_identifier_mul";
            case 3L: return "e_omp_task_reduction_identifier_minus";
            case 4L: return "e_omp_task_reduction_identifier_bitand";
            case 5L: return "e_omp_task_reduction_identifier_bitor";
            case 6L: return "e_omp_task_reduction_identifier_bitxor";
            case 7L: return "e_omp_task_reduction_identifier_logand";
            case 8L: return "e_omp_task_reduction_identifier_logor";
            case 9L: return "e_omp_task_reduction_identifier_and";
            case 10L: return "e_omp_task_reduction_identifier_or";
            case 11L: return "e_omp_task_reduction_identifier_eqv";
            case 12L: return "e_omp_task_reduction_identifier_neqv";
            case 13L: return "e_omp_task_reduction_identifier_max";
            case 14L: return "e_omp_task_reduction_identifier_min";
            case 15L: return "e_omp_task_reduction_identifier_iand";
            case 16L: return "e_omp_task_reduction_identifier_ior";
            case 17L: return "e_omp_task_reduction_identifier_ieor";
            case 18L: return "e_omp_task_reduction_user_defined_identifier";
            case 19L: return "e_omp_task_reduction_identifier_last";
            default: return "";
        }
    }

    std::string omp_task_reduction_identifier_enum(int64_t i, const std::string &strip) {
        std::string s = omp_task_reduction_identifier_enum(i);
        if (s.empty())
            s = "(SgOmpClause::omp_task_reduction_identifier_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& omp_task_reduction_identifier_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L
        };
        static const std::vector<int64_t> retval(values, values + 20);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgOmpClause_omp_task_reduction_identifier_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgOmpClause::omp_task_reduction_identifier_enum(i);
        if (retval.empty()) {
            retval = "(SgOmpClause::omp_task_reduction_identifier_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgOmpClause::omp_task_reduction_identifier_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgOmpClause_omp_task_reduction_identifier_enum() {
        return stringify::SgOmpClause::omp_task_reduction_identifier_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 78673
namespace stringify { namespace SgOmpClause {
    const char* omp_defaultmap_behavior_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_omp_defaultmap_behavior_unspecified";
            case 1L: return "e_omp_defaultmap_behavior_alloc";
            case 2L: return "e_omp_defaultmap_behavior_to";
            case 3L: return "e_omp_defaultmap_behavior_from";
            case 4L: return "e_omp_defaultmap_behavior_tofrom";
            case 5L: return "e_omp_defaultmap_behavior_firstprivate";
            case 6L: return "e_omp_defaultmap_behavior_none";
            case 7L: return "e_omp_defaultmap_behavior_default";
            default: return "";
        }
    }

    std::string omp_defaultmap_behavior_enum(int64_t i, const std::string &strip) {
        std::string s = omp_defaultmap_behavior_enum(i);
        if (s.empty())
            s = "(SgOmpClause::omp_defaultmap_behavior_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& omp_defaultmap_behavior_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgOmpClause_omp_defaultmap_behavior_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgOmpClause::omp_defaultmap_behavior_enum(i);
        if (retval.empty()) {
            retval = "(SgOmpClause::omp_defaultmap_behavior_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgOmpClause::omp_defaultmap_behavior_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgOmpClause_omp_defaultmap_behavior_enum() {
        return stringify::SgOmpClause::omp_defaultmap_behavior_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 78685
namespace stringify { namespace SgOmpClause {
    const char* omp_defaultmap_category_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_omp_defaultmap_category_unspecified";
            case 1L: return "e_omp_defaultmap_category_scalar";
            case 2L: return "e_omp_defaultmap_category_aggregate";
            case 3L: return "e_omp_defaultmap_category_pointer";
            case 4L: return "e_omp_defaultmap_category_allocatable";
            default: return "";
        }
    }

    std::string omp_defaultmap_category_enum(int64_t i, const std::string &strip) {
        std::string s = omp_defaultmap_category_enum(i);
        if (s.empty())
            s = "(SgOmpClause::omp_defaultmap_category_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& omp_defaultmap_category_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgOmpClause_omp_defaultmap_category_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgOmpClause::omp_defaultmap_category_enum(i);
        if (retval.empty()) {
            retval = "(SgOmpClause::omp_defaultmap_category_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgOmpClause::omp_defaultmap_category_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgOmpClause_omp_defaultmap_category_enum() {
        return stringify::SgOmpClause::omp_defaultmap_category_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 78694
namespace stringify { namespace SgOmpClause {
    const char* omp_reduction_identifier_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_omp_reduction_unknown";
            case 1L: return "e_omp_reduction_plus";
            case 2L: return "e_omp_reduction_mul";
            case 3L: return "e_omp_reduction_minus";
            case 4L: return "e_omp_reduction_bitand";
            case 5L: return "e_omp_reduction_bitor";
            case 6L: return "e_omp_reduction_bitxor";
            case 7L: return "e_omp_reduction_logand";
            case 8L: return "e_omp_reduction_logor";
            case 9L: return "e_omp_reduction_and";
            case 10L: return "e_omp_reduction_or";
            case 11L: return "e_omp_reduction_eqv";
            case 12L: return "e_omp_reduction_neqv";
            case 13L: return "e_omp_reduction_max";
            case 14L: return "e_omp_reduction_min";
            case 15L: return "e_omp_reduction_iand";
            case 16L: return "e_omp_reduction_ior";
            case 17L: return "e_omp_reduction_ieor";
            case 18L: return "e_omp_reduction_user_defined_identifier";
            case 19L: return "e_omp_reduction_last";
            default: return "";
        }
    }

    std::string omp_reduction_identifier_enum(int64_t i, const std::string &strip) {
        std::string s = omp_reduction_identifier_enum(i);
        if (s.empty())
            s = "(SgOmpClause::omp_reduction_identifier_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& omp_reduction_identifier_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L
        };
        static const std::vector<int64_t> retval(values, values + 20);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgOmpClause_omp_reduction_identifier_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgOmpClause::omp_reduction_identifier_enum(i);
        if (retval.empty()) {
            retval = "(SgOmpClause::omp_reduction_identifier_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgOmpClause::omp_reduction_identifier_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgOmpClause_omp_reduction_identifier_enum() {
        return stringify::SgOmpClause::omp_reduction_identifier_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 78724
namespace stringify { namespace SgOmpClause {
    const char* omp_reduction_modifier_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_omp_reduction_modifier_unknown";
            case 1L: return "e_omp_reduction_inscan";
            case 2L: return "e_omp_reduction_task";
            case 3L: return "e_omp_reduction_default";
            default: return "";
        }
    }

    std::string omp_reduction_modifier_enum(int64_t i, const std::string &strip) {
        std::string s = omp_reduction_modifier_enum(i);
        if (s.empty())
            s = "(SgOmpClause::omp_reduction_modifier_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& omp_reduction_modifier_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgOmpClause_omp_reduction_modifier_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgOmpClause::omp_reduction_modifier_enum(i);
        if (retval.empty()) {
            retval = "(SgOmpClause::omp_reduction_modifier_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgOmpClause::omp_reduction_modifier_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgOmpClause_omp_reduction_modifier_enum() {
        return stringify::SgOmpClause::omp_reduction_modifier_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 78732
namespace stringify { namespace SgOmpClause {
    const char* omp_linear_modifier_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_omp_linear_modifier_unspecified";
            case 1L: return "e_omp_linear_modifier_ref";
            case 2L: return "e_omp_linear_modifier_val";
            case 3L: return "e_omp_linear_modifier_uval";
            default: return "";
        }
    }

    std::string omp_linear_modifier_enum(int64_t i, const std::string &strip) {
        std::string s = omp_linear_modifier_enum(i);
        if (s.empty())
            s = "(SgOmpClause::omp_linear_modifier_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& omp_linear_modifier_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgOmpClause_omp_linear_modifier_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgOmpClause::omp_linear_modifier_enum(i);
        if (retval.empty()) {
            retval = "(SgOmpClause::omp_linear_modifier_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgOmpClause::omp_linear_modifier_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgOmpClause_omp_linear_modifier_enum() {
        return stringify::SgOmpClause::omp_linear_modifier_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 78740
namespace stringify { namespace SgOmpClause {
    const char* omp_device_modifier_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_omp_device_modifier_unspecified";
            case 1L: return "e_omp_device_modifier_ancestor";
            case 2L: return "e_omp_device_modifier_device_num";
            default: return "";
        }
    }

    std::string omp_device_modifier_enum(int64_t i, const std::string &strip) {
        std::string s = omp_device_modifier_enum(i);
        if (s.empty())
            s = "(SgOmpClause::omp_device_modifier_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& omp_device_modifier_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgOmpClause_omp_device_modifier_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgOmpClause::omp_device_modifier_enum(i);
        if (retval.empty()) {
            retval = "(SgOmpClause::omp_device_modifier_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgOmpClause::omp_device_modifier_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgOmpClause_omp_device_modifier_enum() {
        return stringify::SgOmpClause::omp_device_modifier_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 78747
namespace stringify { namespace SgOmpClause {
    const char* omp_lastprivate_modifier_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_omp_lastprivate_modifier_unspecified";
            case 1L: return "e_omp_lastprivate_conditional";
            default: return "";
        }
    }

    std::string omp_lastprivate_modifier_enum(int64_t i, const std::string &strip) {
        std::string s = omp_lastprivate_modifier_enum(i);
        if (s.empty())
            s = "(SgOmpClause::omp_lastprivate_modifier_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& omp_lastprivate_modifier_enum() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgOmpClause_omp_lastprivate_modifier_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgOmpClause::omp_lastprivate_modifier_enum(i);
        if (retval.empty()) {
            retval = "(SgOmpClause::omp_lastprivate_modifier_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgOmpClause::omp_lastprivate_modifier_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgOmpClause_omp_lastprivate_modifier_enum() {
        return stringify::SgOmpClause::omp_lastprivate_modifier_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 78753
namespace stringify { namespace SgOmpClause {
    const char* omp_when_context_kind_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_omp_when_context_kind_unknown";
            case 1L: return "e_omp_when_context_kind_host";
            case 2L: return "e_omp_when_context_kind_nohost";
            case 3L: return "e_omp_when_context_kind_any";
            case 4L: return "e_omp_when_context_kind_cpu";
            case 5L: return "e_omp_when_context_kind_gpu";
            case 6L: return "e_omp_when_context_kind_fpga";
            default: return "";
        }
    }

    std::string omp_when_context_kind_enum(int64_t i, const std::string &strip) {
        std::string s = omp_when_context_kind_enum(i);
        if (s.empty())
            s = "(SgOmpClause::omp_when_context_kind_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& omp_when_context_kind_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgOmpClause_omp_when_context_kind_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgOmpClause::omp_when_context_kind_enum(i);
        if (retval.empty()) {
            retval = "(SgOmpClause::omp_when_context_kind_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgOmpClause::omp_when_context_kind_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgOmpClause_omp_when_context_kind_enum() {
        return stringify::SgOmpClause::omp_when_context_kind_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 78764
namespace stringify { namespace SgOmpClause {
    const char* omp_when_context_vendor_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_omp_when_context_vendor_unspecified";
            case 1L: return "e_omp_when_context_vendor_amd";
            case 2L: return "e_omp_when_context_vendor_arm";
            case 3L: return "e_omp_when_context_vendor_bsc";
            case 4L: return "e_omp_when_context_vendor_cray";
            case 5L: return "e_omp_when_context_vendor_fujitsu";
            case 6L: return "e_omp_when_context_vendor_gnu";
            case 7L: return "e_omp_when_context_vendor_ibm";
            case 8L: return "e_omp_when_context_vendor_intel";
            case 9L: return "e_omp_when_context_vendor_llvm";
            case 10L: return "e_omp_when_context_vendor_pgi";
            case 11L: return "e_omp_when_context_vendor_ti";
            case 12L: return "e_omp_when_context_vendor_unknown";
            default: return "";
        }
    }

    std::string omp_when_context_vendor_enum(int64_t i, const std::string &strip) {
        std::string s = omp_when_context_vendor_enum(i);
        if (s.empty())
            s = "(SgOmpClause::omp_when_context_vendor_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& omp_when_context_vendor_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L
        };
        static const std::vector<int64_t> retval(values, values + 13);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgOmpClause_omp_when_context_vendor_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgOmpClause::omp_when_context_vendor_enum(i);
        if (retval.empty()) {
            retval = "(SgOmpClause::omp_when_context_vendor_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgOmpClause::omp_when_context_vendor_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgOmpClause_omp_when_context_vendor_enum() {
        return stringify::SgOmpClause::omp_when_context_vendor_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 78781
namespace stringify { namespace SgOmpClause {
    const char* omp_allocate_modifier_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_omp_allocate_modifier_unknown";
            case 1L: return "e_omp_allocate_default_mem_alloc";
            case 2L: return "e_omp_allocate_large_cap_mem_alloc";
            case 3L: return "e_omp_allocate_const_mem_alloc";
            case 4L: return "e_omp_allocate_high_bw_mem_alloc";
            case 5L: return "e_omp_allocate_low_lat_mem_alloc";
            case 6L: return "e_omp_allocate_cgroup_mem_alloc";
            case 7L: return "e_omp_allocate_pteam_mem_alloc";
            case 8L: return "e_omp_allocate_thread_mem_alloc";
            case 9L: return "e_omp_allocate_user_defined_modifier";
            default: return "";
        }
    }

    std::string omp_allocate_modifier_enum(int64_t i, const std::string &strip) {
        std::string s = omp_allocate_modifier_enum(i);
        if (s.empty())
            s = "(SgOmpClause::omp_allocate_modifier_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& omp_allocate_modifier_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L
        };
        static const std::vector<int64_t> retval(values, values + 10);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgOmpClause_omp_allocate_modifier_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgOmpClause::omp_allocate_modifier_enum(i);
        if (retval.empty()) {
            retval = "(SgOmpClause::omp_allocate_modifier_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgOmpClause::omp_allocate_modifier_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgOmpClause_omp_allocate_modifier_enum() {
        return stringify::SgOmpClause::omp_allocate_modifier_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 78797
namespace stringify { namespace SgOmpClause {
    const char* omp_dependence_type_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_omp_depend_unspecified";
            case 1L: return "e_omp_depend_in";
            case 2L: return "e_omp_depend_out";
            case 3L: return "e_omp_depend_inout";
            case 4L: return "e_omp_depend_mutexinoutset";
            case 5L: return "e_omp_depend_depobj";
            default: return "";
        }
    }

    std::string omp_dependence_type_enum(int64_t i, const std::string &strip) {
        std::string s = omp_dependence_type_enum(i);
        if (s.empty())
            s = "(SgOmpClause::omp_dependence_type_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& omp_dependence_type_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgOmpClause_omp_dependence_type_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgOmpClause::omp_dependence_type_enum(i);
        if (retval.empty()) {
            retval = "(SgOmpClause::omp_dependence_type_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgOmpClause::omp_dependence_type_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgOmpClause_omp_dependence_type_enum() {
        return stringify::SgOmpClause::omp_dependence_type_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 78807
namespace stringify { namespace SgOmpClause {
    const char* omp_depend_modifier_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_omp_depend_modifier_unspecified";
            case 1L: return "e_omp_depend_modifier_iterator";
            default: return "";
        }
    }

    std::string omp_depend_modifier_enum(int64_t i, const std::string &strip) {
        std::string s = omp_depend_modifier_enum(i);
        if (s.empty())
            s = "(SgOmpClause::omp_depend_modifier_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& omp_depend_modifier_enum() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgOmpClause_omp_depend_modifier_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgOmpClause::omp_depend_modifier_enum(i);
        if (retval.empty()) {
            retval = "(SgOmpClause::omp_depend_modifier_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgOmpClause::omp_depend_modifier_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgOmpClause_omp_depend_modifier_enum() {
        return stringify::SgOmpClause::omp_depend_modifier_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 78814
namespace stringify { namespace SgOmpClause {
    const char* omp_map_operator_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_omp_map_unknown";
            case 1L: return "e_omp_map_alloc";
            case 2L: return "e_omp_map_to";
            case 3L: return "e_omp_map_from";
            case 4L: return "e_omp_map_tofrom";
            case 5L: return "e_omp_map_last";
            default: return "";
        }
    }

    std::string omp_map_operator_enum(int64_t i, const std::string &strip) {
        std::string s = omp_map_operator_enum(i);
        if (s.empty())
            s = "(SgOmpClause::omp_map_operator_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& omp_map_operator_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgOmpClause_omp_map_operator_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgOmpClause::omp_map_operator_enum(i);
        if (retval.empty()) {
            retval = "(SgOmpClause::omp_map_operator_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgOmpClause::omp_map_operator_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgOmpClause_omp_map_operator_enum() {
        return stringify::SgOmpClause::omp_map_operator_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 78825
namespace stringify { namespace SgOmpClause {
    const char* omp_map_dist_data_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_omp_map_dist_data_unknown";
            case 1L: return "e_omp_map_dist_data_duplicate";
            case 2L: return "e_omp_map_dist_data_block";
            case 3L: return "e_omp_map_dist_data_cyclic";
            case 4L: return "e_omp_map_dist_data_last";
            default: return "";
        }
    }

    std::string omp_map_dist_data_enum(int64_t i, const std::string &strip) {
        std::string s = omp_map_dist_data_enum(i);
        if (s.empty())
            s = "(SgOmpClause::omp_map_dist_data_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& omp_map_dist_data_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgOmpClause_omp_map_dist_data_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgOmpClause::omp_map_dist_data_enum(i);
        if (retval.empty()) {
            retval = "(SgOmpClause::omp_map_dist_data_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgOmpClause::omp_map_dist_data_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgOmpClause_omp_map_dist_data_enum() {
        return stringify::SgOmpClause::omp_map_dist_data_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 78835
namespace stringify { namespace SgOmpClause {
    const char* omp_proc_bind_policy_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_omp_proc_bind_policy_unknown";
            case 1L: return "e_omp_proc_bind_policy_master";
            case 2L: return "e_omp_proc_bind_policy_close";
            case 3L: return "e_omp_proc_bind_policy_spread";
            case 4L: return "e_omp_proc_bind_policy_last";
            default: return "";
        }
    }

    std::string omp_proc_bind_policy_enum(int64_t i, const std::string &strip) {
        std::string s = omp_proc_bind_policy_enum(i);
        if (s.empty())
            s = "(SgOmpClause::omp_proc_bind_policy_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& omp_proc_bind_policy_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgOmpClause_omp_proc_bind_policy_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgOmpClause::omp_proc_bind_policy_enum(i);
        if (retval.empty()) {
            retval = "(SgOmpClause::omp_proc_bind_policy_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgOmpClause::omp_proc_bind_policy_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgOmpClause_omp_proc_bind_policy_enum() {
        return stringify::SgOmpClause::omp_proc_bind_policy_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 78844
namespace stringify { namespace SgOmpClause {
    const char* omp_bind_binding_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_omp_bind_binding_unspecified";
            case 1L: return "e_omp_bind_binding_teams";
            case 2L: return "e_omp_bind_binding_parallel";
            case 3L: return "e_omp_bind_binding_thread";
            default: return "";
        }
    }

    std::string omp_bind_binding_enum(int64_t i, const std::string &strip) {
        std::string s = omp_bind_binding_enum(i);
        if (s.empty())
            s = "(SgOmpClause::omp_bind_binding_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& omp_bind_binding_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgOmpClause_omp_bind_binding_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgOmpClause::omp_bind_binding_enum(i);
        if (retval.empty()) {
            retval = "(SgOmpClause::omp_bind_binding_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgOmpClause::omp_bind_binding_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgOmpClause_omp_bind_binding_enum() {
        return stringify::SgOmpClause::omp_bind_binding_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 78852
namespace stringify { namespace SgOmpClause {
    const char* omp_atomic_default_mem_order_kind_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_omp_atomic_default_mem_order_kind_unspecified";
            case 1L: return "e_omp_atomic_default_mem_order_kind_seq_cst";
            case 2L: return "e_omp_atomic_default_mem_order_kind_acq_rel";
            case 3L: return "e_omp_atomic_default_mem_order_kind_relaxed";
            default: return "";
        }
    }

    std::string omp_atomic_default_mem_order_kind_enum(int64_t i, const std::string &strip) {
        std::string s = omp_atomic_default_mem_order_kind_enum(i);
        if (s.empty())
            s = "(SgOmpClause::omp_atomic_default_mem_order_kind_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& omp_atomic_default_mem_order_kind_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgOmpClause_omp_atomic_default_mem_order_kind_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgOmpClause::omp_atomic_default_mem_order_kind_enum(i);
        if (retval.empty()) {
            retval = "(SgOmpClause::omp_atomic_default_mem_order_kind_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgOmpClause::omp_atomic_default_mem_order_kind_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgOmpClause_omp_atomic_default_mem_order_kind_enum() {
        return stringify::SgOmpClause::omp_atomic_default_mem_order_kind_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 78860
namespace stringify { namespace SgOmpClause {
    const char* omp_order_kind_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_omp_order_kind_unspecified";
            case 1L: return "e_omp_order_kind_concurrent";
            default: return "";
        }
    }

    std::string omp_order_kind_enum(int64_t i, const std::string &strip) {
        std::string s = omp_order_kind_enum(i);
        if (s.empty())
            s = "(SgOmpClause::omp_order_kind_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& omp_order_kind_enum() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgOmpClause_omp_order_kind_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgOmpClause::omp_order_kind_enum(i);
        if (retval.empty()) {
            retval = "(SgOmpClause::omp_order_kind_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgOmpClause::omp_order_kind_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgOmpClause_omp_order_kind_enum() {
        return stringify::SgOmpClause::omp_order_kind_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 78866
namespace stringify { namespace SgOmpClause {
    const char* omp_dist_schedule_kind_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_omp_dist_schedule_kind_unspecified";
            case 1L: return "e_omp_dist_schedule_kind_static";
            default: return "";
        }
    }

    std::string omp_dist_schedule_kind_enum(int64_t i, const std::string &strip) {
        std::string s = omp_dist_schedule_kind_enum(i);
        if (s.empty())
            s = "(SgOmpClause::omp_dist_schedule_kind_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& omp_dist_schedule_kind_enum() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgOmpClause_omp_dist_schedule_kind_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgOmpClause::omp_dist_schedule_kind_enum(i);
        if (retval.empty()) {
            retval = "(SgOmpClause::omp_dist_schedule_kind_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgOmpClause::omp_dist_schedule_kind_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgOmpClause_omp_dist_schedule_kind_enum() {
        return stringify::SgOmpClause::omp_dist_schedule_kind_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 78872
namespace stringify { namespace SgOmpClause {
    const char* omp_atomic_clause_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_omp_atomic_clause_unknown";
            case 1L: return "e_omp_atomic_clause_read";
            case 2L: return "e_omp_atomic_clause_write";
            case 3L: return "e_omp_atomic_clause_update";
            case 4L: return "e_omp_atomic_clause_capture";
            default: return "";
        }
    }

    std::string omp_atomic_clause_enum(int64_t i, const std::string &strip) {
        std::string s = omp_atomic_clause_enum(i);
        if (s.empty())
            s = "(SgOmpClause::omp_atomic_clause_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& omp_atomic_clause_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgOmpClause_omp_atomic_clause_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgOmpClause::omp_atomic_clause_enum(i);
        if (retval.empty()) {
            retval = "(SgOmpClause::omp_atomic_clause_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgOmpClause::omp_atomic_clause_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgOmpClause_omp_atomic_clause_enum() {
        return stringify::SgOmpClause::omp_atomic_clause_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 78881
namespace stringify { namespace SgOmpClause {
    const char* omp_if_modifier_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_omp_if_modifier_unknown";
            case 1L: return "e_omp_if_parallel";
            case 2L: return "e_omp_if_simd";
            case 3L: return "e_omp_if_target";
            case 4L: return "e_omp_if_cancel";
            case 5L: return "e_omp_if_taskloop";
            case 6L: return "e_omp_if_target_data";
            case 7L: return "e_omp_if_target_enter_data";
            case 8L: return "e_omp_if_target_exit_data";
            case 9L: return "e_omp_if_task";
            case 10L: return "e_omp_if_target_update";
            default: return "";
        }
    }

    std::string omp_if_modifier_enum(int64_t i, const std::string &strip) {
        std::string s = omp_if_modifier_enum(i);
        if (s.empty())
            s = "(SgOmpClause::omp_if_modifier_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& omp_if_modifier_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L
        };
        static const std::vector<int64_t> retval(values, values + 10);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgOmpClause_omp_if_modifier_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgOmpClause::omp_if_modifier_enum(i);
        if (retval.empty()) {
            retval = "(SgOmpClause::omp_if_modifier_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgOmpClause::omp_if_modifier_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgOmpClause_omp_if_modifier_enum() {
        return stringify::SgOmpClause::omp_if_modifier_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 78895
namespace stringify { namespace SgOmpClause {
    const char* omp_depobj_modifier_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_omp_depobj_modifier_unknown";
            case 1L: return "e_omp_depobj_modifier_in";
            case 2L: return "e_omp_depobj_modifier_out";
            case 3L: return "e_omp_depobj_modifier_inout";
            case 4L: return "e_omp_depobj_modifier_mutexinoutset";
            case 5L: return "e_omp_depobj_modifier_depobj";
            case 6L: return "e_omp_depobj_modifier_sink";
            case 7L: return "e_omp_depobj_modifier_source";
            default: return "";
        }
    }

    std::string omp_depobj_modifier_enum(int64_t i, const std::string &strip) {
        std::string s = omp_depobj_modifier_enum(i);
        if (s.empty())
            s = "(SgOmpClause::omp_depobj_modifier_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& omp_depobj_modifier_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgOmpClause_omp_depobj_modifier_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgOmpClause::omp_depobj_modifier_enum(i);
        if (retval.empty()) {
            retval = "(SgOmpClause::omp_depobj_modifier_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgOmpClause::omp_depobj_modifier_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgOmpClause_omp_depobj_modifier_enum() {
        return stringify::SgOmpClause::omp_depobj_modifier_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 144081
namespace stringify { namespace SgUntypedType {
    const char* type_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_implicit";
            case 2L: return "e_void";
            case 3L: return "e_int";
            case 4L: return "e_float";
            case 5L: return "e_double";
            case 6L: return "e_complex";
            case 7L: return "e_double_complex";
            case 8L: return "e_bool";
            case 9L: return "e_char";
            case 10L: return "e_string";
            case 11L: return "e_user_defined";
            case 12L: return "e_last";
            default: return "";
        }
    }

    std::string type_enum(int64_t i, const std::string &strip) {
        std::string s = type_enum(i);
        if (s.empty())
            s = "(SgUntypedType::type_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& type_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L
        };
        static const std::vector<int64_t> retval(values, values + 13);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgUntypedType_type_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgUntypedType::type_enum(i);
        if (retval.empty()) {
            retval = "(SgUntypedType::type_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgUntypedType::type_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgUntypedType_type_enum() {
        return stringify::SgUntypedType::type_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 161374
namespace stringify { namespace SgForAllStatement {
    const char* forall_statement_kind_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_forall_statement";
            case 2L: return "e_do_concurrent_statement";
            case 3L: return "e_last_forall_statement_kind";
            default: return "";
        }
    }

    std::string forall_statement_kind_enum(int64_t i, const std::string &strip) {
        std::string s = forall_statement_kind_enum(i);
        if (s.empty())
            s = "(SgForAllStatement::forall_statement_kind_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& forall_statement_kind_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgForAllStatement_forall_statement_kind_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgForAllStatement::forall_statement_kind_enum(i);
        if (retval.empty()) {
            retval = "(SgForAllStatement::forall_statement_kind_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgForAllStatement::forall_statement_kind_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgForAllStatement_forall_statement_kind_enum() {
        return stringify::SgForAllStatement::forall_statement_kind_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 164748
namespace stringify { namespace SgDeclarationStatement {
    const char* template_specialization_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_no_specialization";
            case 2L: return "e_partial_specialization";
            case 3L: return "e_specialization";
            case 4L: return "e_template_specialization_last";
            default: return "";
        }
    }

    std::string template_specialization_enum(int64_t i, const std::string &strip) {
        std::string s = template_specialization_enum(i);
        if (s.empty())
            s = "(SgDeclarationStatement::template_specialization_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& template_specialization_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgDeclarationStatement_template_specialization_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgDeclarationStatement::template_specialization_enum(i);
        if (retval.empty()) {
            retval = "(SgDeclarationStatement::template_specialization_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgDeclarationStatement::template_specialization_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgDeclarationStatement_template_specialization_enum() {
        return stringify::SgDeclarationStatement::template_specialization_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 164763
namespace stringify { namespace SgDeclarationStatement {
    const char* gnu_extension_visability_attribute_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_gnu_attribute_visability_unknown";
            case 1L: return "e_gnu_attribute_visability_unspecified";
            case 2L: return "e_gnu_attribute_visability_hidden";
            case 3L: return "e_gnu_attribute_visability_protected";
            case 4L: return "e_gnu_attribute_visability_internal";
            case 5L: return "e_last_gnu_visability_attribute";
            default: return "";
        }
    }

    std::string gnu_extension_visability_attribute_enum(int64_t i, const std::string &strip) {
        std::string s = gnu_extension_visability_attribute_enum(i);
        if (s.empty())
            s = "(SgDeclarationStatement::gnu_extension_visability_attribute_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& gnu_extension_visability_attribute_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgDeclarationStatement_gnu_extension_visability_attribute_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgDeclarationStatement::gnu_extension_visability_attribute_enum(i);
        if (retval.empty()) {
            retval = "(SgDeclarationStatement::gnu_extension_visability_attribute_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgDeclarationStatement::gnu_extension_visability_attribute_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgDeclarationStatement_gnu_extension_visability_attribute_enum() {
        return stringify::SgDeclarationStatement::gnu_extension_visability_attribute_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 166146
namespace stringify { namespace SgVariableDeclaration {
    const char* gnu_extension_declaration_attributes_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_gnu_attribute_unknown";
            case 1L: return "e_gnu_attribute_unspecified";
            case 2L: return "e_gnu_attribute__weak__";
            case 3L: return "e_gnu_attribute__unused__";
            case 4L: return "e_gnu_attribute__deprecated__";
            case 5L: return "e_gnu_attribute__nocommon__";
            case 6L: return "e_gnu_attribute__transparent_union__";
            case 7L: return "e_last_gnu_declaration_attribute";
            default: return "";
        }
    }

    std::string gnu_extension_declaration_attributes_enum(int64_t i, const std::string &strip) {
        std::string s = gnu_extension_declaration_attributes_enum(i);
        if (s.empty())
            s = "(SgVariableDeclaration::gnu_extension_declaration_attributes_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& gnu_extension_declaration_attributes_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgVariableDeclaration_gnu_extension_declaration_attributes_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgVariableDeclaration::gnu_extension_declaration_attributes_enum(i);
        if (retval.empty()) {
            retval = "(SgVariableDeclaration::gnu_extension_declaration_attributes_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgVariableDeclaration::gnu_extension_declaration_attributes_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgVariableDeclaration_gnu_extension_declaration_attributes_enum() {
        return stringify::SgVariableDeclaration::gnu_extension_declaration_attributes_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 170266
namespace stringify { namespace SgAttributeSpecificationStatement {
    const char* attribute_spec_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown_attribute_spec";
            case 1L: return "e_accessStatement_private";
            case 2L: return "e_accessStatement_public";
            case 3L: return "e_allocatableStatement";
            case 4L: return "e_asynchronousStatement";
            case 5L: return "e_bindStatement";
            case 6L: return "e_dataStatement";
            case 7L: return "e_dimensionStatement";
            case 8L: return "e_externalStatement";
            case 9L: return "e_intentStatement";
            case 10L: return "e_intrinsicStatement";
            case 11L: return "e_optionalStatement";
            case 12L: return "e_parameterStatement";
            case 13L: return "e_pointerStatement";
            case 14L: return "e_protectedStatement";
            case 15L: return "e_saveStatement";
            case 16L: return "e_targetStatement";
            case 17L: return "e_valueStatement";
            case 18L: return "e_volatileStatement";
            case 19L: return "e_last_attribute_spec";
            default: return "";
        }
    }

    std::string attribute_spec_enum(int64_t i, const std::string &strip) {
        std::string s = attribute_spec_enum(i);
        if (s.empty())
            s = "(SgAttributeSpecificationStatement::attribute_spec_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& attribute_spec_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L
        };
        static const std::vector<int64_t> retval(values, values + 20);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAttributeSpecificationStatement_attribute_spec_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAttributeSpecificationStatement::attribute_spec_enum(i);
        if (retval.empty()) {
            retval = "(SgAttributeSpecificationStatement::attribute_spec_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAttributeSpecificationStatement::attribute_spec_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAttributeSpecificationStatement_attribute_spec_enum() {
        return stringify::SgAttributeSpecificationStatement::attribute_spec_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 171244
namespace stringify { namespace SgTemplateDeclaration {
    const char* template_type_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_template_none";
            case 1L: return "e_template_class";
            case 2L: return "e_template_m_class";
            case 3L: return "e_template_function";
            case 4L: return "e_template_m_function";
            case 5L: return "e_template_m_data";
            default: return "";
        }
    }

    std::string template_type_enum(int64_t i, const std::string &strip) {
        std::string s = template_type_enum(i);
        if (s.empty())
            s = "(SgTemplateDeclaration::template_type_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& template_type_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgTemplateDeclaration_template_type_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgTemplateDeclaration::template_type_enum(i);
        if (retval.empty()) {
            retval = "(SgTemplateDeclaration::template_type_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgTemplateDeclaration::template_type_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgTemplateDeclaration_template_type_enum() {
        return stringify::SgTemplateDeclaration::template_type_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 174092
namespace stringify { namespace SgInterfaceStatement {
    const char* generic_spec_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_error_interface_type";
            case 1L: return "e_default_interface_type";
            case 2L: return "e_unnamed_interface_type";
            case 3L: return "e_named_interface_type";
            case 4L: return "e_operator_interface_type";
            case 5L: return "e_assignment_interface_type";
            case 6L: return "e_last_interface_type";
            default: return "";
        }
    }

    std::string generic_spec_enum(int64_t i, const std::string &strip) {
        std::string s = generic_spec_enum(i);
        if (s.empty())
            s = "(SgInterfaceStatement::generic_spec_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& generic_spec_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgInterfaceStatement_generic_spec_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgInterfaceStatement::generic_spec_enum(i);
        if (retval.empty()) {
            retval = "(SgInterfaceStatement::generic_spec_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgInterfaceStatement::generic_spec_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgInterfaceStatement_generic_spec_enum() {
        return stringify::SgInterfaceStatement::generic_spec_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 178970
namespace stringify { namespace SgClassDeclaration {
    const char* class_types(int64_t i) {
        switch (i) {
            case 0L: return "e_class";
            case 1L: return "e_struct";
            case 2L: return "e_union";
            case 3L: return "e_template_parameter";
            case 4L: return "e_fortran_module";
            default: return "";
        }
    }

    std::string class_types(int64_t i, const std::string &strip) {
        std::string s = class_types(i);
        if (s.empty())
            s = "(SgClassDeclaration::class_types)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& class_types() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgClassDeclaration_class_types(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgClassDeclaration::class_types(i);
        if (retval.empty()) {
            retval = "(SgClassDeclaration::class_types)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgClassDeclaration::class_types::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgClassDeclaration_class_types() {
        return stringify::SgClassDeclaration::class_types();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 179630
namespace stringify { namespace SgTemplateClassDeclaration {
    const char* class_types(int64_t i) {
        switch (i) {
            case 0L: return "e_class";
            case 1L: return "e_struct";
            case 2L: return "e_union";
            case 3L: return "e_template_parameter";
            default: return "";
        }
    }

    std::string class_types(int64_t i, const std::string &strip) {
        std::string s = class_types(i);
        if (s.empty())
            s = "(SgTemplateClassDeclaration::class_types)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& class_types() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgTemplateClassDeclaration_class_types(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgTemplateClassDeclaration::class_types(i);
        if (retval.empty()) {
            retval = "(SgTemplateClassDeclaration::class_types)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgTemplateClassDeclaration::class_types::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgTemplateClassDeclaration_class_types() {
        return stringify::SgTemplateClassDeclaration::class_types();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 181531
namespace stringify { namespace SgImplicitStatement {
    const char* implicit_spec_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown_implicit_spec";
            case 1L: return "e_has_implicit_spec_list";
            case 2L: return "e_none";
            case 3L: return "e_none_external";
            case 4L: return "e_none_type";
            case 5L: return "e_none_external_and_type";
            default: return "";
        }
    }

    std::string implicit_spec_enum(int64_t i, const std::string &strip) {
        std::string s = implicit_spec_enum(i);
        if (s.empty())
            s = "(SgImplicitStatement::implicit_spec_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& implicit_spec_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgImplicitStatement_implicit_spec_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgImplicitStatement::implicit_spec_enum(i);
        if (retval.empty()) {
            retval = "(SgImplicitStatement::implicit_spec_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgImplicitStatement::implicit_spec_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgImplicitStatement_implicit_spec_enum() {
        return stringify::SgImplicitStatement::implicit_spec_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 187204
namespace stringify { namespace SgProcedureHeaderStatement {
    const char* subprogram_kind_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown_kind";
            case 1L: return "e_function_subprogram_kind";
            case 2L: return "e_subroutine_subprogram_kind";
            case 3L: return "e_block_data_subprogram_kind";
            case 4L: return "e_last_subprogram_kind";
            default: return "";
        }
    }

    std::string subprogram_kind_enum(int64_t i, const std::string &strip) {
        std::string s = subprogram_kind_enum(i);
        if (s.empty())
            s = "(SgProcedureHeaderStatement::subprogram_kind_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& subprogram_kind_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgProcedureHeaderStatement_subprogram_kind_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgProcedureHeaderStatement::subprogram_kind_enum(i);
        if (retval.empty()) {
            retval = "(SgProcedureHeaderStatement::subprogram_kind_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgProcedureHeaderStatement::subprogram_kind_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgProcedureHeaderStatement_subprogram_kind_enum() {
        return stringify::SgProcedureHeaderStatement::subprogram_kind_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 206599
namespace stringify { namespace SgProcessControlStatement {
    const char* control_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_abort";
            case 2L: return "e_stop";
            case 3L: return "e_error_stop";
            case 4L: return "e_exit";
            case 5L: return "e_pause";
            default: return "";
        }
    }

    std::string control_enum(int64_t i, const std::string &strip) {
        std::string s = control_enum(i);
        if (s.empty())
            s = "(SgProcessControlStatement::control_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& control_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgProcessControlStatement_control_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgProcessControlStatement::control_enum(i);
        if (retval.empty()) {
            retval = "(SgProcessControlStatement::control_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgProcessControlStatement::control_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgProcessControlStatement_control_enum() {
        return stringify::SgProcessControlStatement::control_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 207078
namespace stringify { namespace SgIOStatement {
    const char* io_statement_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_read";
            case 2L: return "e_print";
            case 3L: return "e_write";
            case 4L: return "e_open";
            case 5L: return "e_close";
            case 6L: return "e_inquire";
            case 7L: return "e_backspace";
            case 8L: return "e_endfile";
            case 9L: return "e_rewind";
            case 10L: return "e_last_io_statment_kind";
            default: return "";
        }
    }

    std::string io_statement_enum(int64_t i, const std::string &strip) {
        std::string s = io_statement_enum(i);
        if (s.empty())
            s = "(SgIOStatement::io_statement_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& io_statement_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L
        };
        static const std::vector<int64_t> retval(values, values + 11);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgIOStatement_io_statement_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgIOStatement::io_statement_enum(i);
        if (retval.empty()) {
            retval = "(SgIOStatement::io_statement_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgIOStatement::io_statement_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgIOStatement_io_statement_enum() {
        return stringify::SgIOStatement::io_statement_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 237065
namespace stringify { namespace SgImageControlStatement {
    const char* image_control_statement_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_sync_all";
            case 2L: return "e_sync_images";
            case 3L: return "e_sync_memory";
            case 4L: return "e_sync_team";
            case 5L: return "e_change_team";
            case 6L: return "e_critical";
            case 7L: return "e_event_post";
            case 8L: return "e_event_wait";
            case 9L: return "e_form_team";
            case 10L: return "e_lock";
            case 11L: return "e_unlock";
            case 12L: return "e_last_image_control_statement";
            default: return "";
        }
    }

    std::string image_control_statement_enum(int64_t i, const std::string &strip) {
        std::string s = image_control_statement_enum(i);
        if (s.empty())
            s = "(SgImageControlStatement::image_control_statement_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& image_control_statement_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L
        };
        static const std::vector<int64_t> retval(values, values + 13);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgImageControlStatement_image_control_statement_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgImageControlStatement::image_control_statement_enum(i);
        if (retval.empty()) {
            retval = "(SgImageControlStatement::image_control_statement_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgImageControlStatement::image_control_statement_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgImageControlStatement_image_control_statement_enum() {
        return stringify::SgImageControlStatement::image_control_statement_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 240850
namespace stringify { namespace SgUnaryOp {
    const char* Sgop_mode(int64_t i) {
        switch (i) {
            case 0L: return "prefix";
            case 1L: return "postfix";
            default: return "";
        }
    }

    std::string Sgop_mode(int64_t i, const std::string &strip) {
        std::string s = Sgop_mode(i);
        if (s.empty())
            s = "(SgUnaryOp::Sgop_mode)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Sgop_mode() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgUnaryOpSgop_mode(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgUnaryOp::Sgop_mode(i);
        if (retval.empty()) {
            retval = "(SgUnaryOp::Sgop_mode)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgUnaryOp::Sgop_mode::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgUnaryOpSgop_mode() {
        return stringify::SgUnaryOp::Sgop_mode();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 245335
namespace stringify { namespace SgCastExp {
    const char* cast_type_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_default";
            case 2L: return "e_C_style_cast";
            case 3L: return "e_const_cast";
            case 4L: return "e_static_cast";
            case 5L: return "e_dynamic_cast";
            case 6L: return "e_reinterpret_cast";
            case 8L: return "e_safe_cast";
            case 9L: return "e_last_cast";
            default: return "";
        }
    }

    std::string cast_type_enum(int64_t i, const std::string &strip) {
        std::string s = cast_type_enum(i);
        if (s.empty())
            s = "(SgCastExp::cast_type_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& cast_type_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            8L,
            9L
        };
        static const std::vector<int64_t> retval(values, values + 9);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgCastExp_cast_type_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgCastExp::cast_type_enum(i);
        if (retval.empty()) {
            retval = "(SgCastExp::cast_type_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgCastExp::cast_type_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgCastExp_cast_type_enum() {
        return stringify::SgCastExp::cast_type_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 245897
namespace stringify { namespace SgThrowOp {
    const char* e_throw_kind(int64_t i) {
        switch (i) {
            case 0L: return "unknown_throw";
            case 1L: return "throw_expression";
            case 2L: return "rethrow";
            default: return "";
        }
    }

    std::string e_throw_kind(int64_t i, const std::string &strip) {
        std::string s = e_throw_kind(i);
        if (s.empty())
            s = "(SgThrowOp::e_throw_kind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& e_throw_kind() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgThrowOp_e_throw_kind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgThrowOp::e_throw_kind(i);
        if (retval.empty()) {
            retval = "(SgThrowOp::e_throw_kind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgThrowOp::e_throw_kind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgThrowOp_e_throw_kind() {
        return stringify::SgThrowOp::e_throw_kind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 313756
namespace stringify { namespace SgAsmOp {
    const char* asm_operand_modifier_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_input";
            case 2L: return "e_output";
            case 3L: return "e_modify";
            case 4L: return "e_earlyclobber";
            case 8L: return "e_commutative";
            case 16L: return "e_ignore_next";
            case 32L: return "e_ignore_till_comma";
            case 64L: return "e_poor_choice";
            case 128L: return "e_bad_choice";
            default: return "";
        }
    }

    std::string asm_operand_modifier_enum(int64_t i, const std::string &strip) {
        std::string s = asm_operand_modifier_enum(i);
        if (s.empty())
            s = "(SgAsmOp::asm_operand_modifier_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& asm_operand_modifier_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            8L,
            16L,
            32L,
            64L,
            128L
        };
        static const std::vector<int64_t> retval(values, values + 10);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmOp_asm_operand_modifier_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmOp::asm_operand_modifier_enum(i);
        if (retval.empty()) {
            retval = "(SgAsmOp::asm_operand_modifier_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmOp::asm_operand_modifier_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmOp_asm_operand_modifier_enum() {
        return stringify::SgAsmOp::asm_operand_modifier_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 313775
namespace stringify { namespace SgAsmOp {
    const char* asm_operand_constraint_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_invalid";
            case 1L: return "e_any";
            case 2L: return "e_general";
            case 3L: return "e_match_0";
            case 4L: return "aoc_match_1";
            case 5L: return "aoc_match_2";
            case 6L: return "aoc_match_3";
            case 7L: return "aoc_match_4";
            case 8L: return "e_match_5";
            case 9L: return "aoc_match_6";
            case 10L: return "aoc_match_7";
            case 11L: return "aoc_match_8";
            case 12L: return "aoc_match_9";
            case 13L: return "e_reg_integer";
            case 14L: return "e_reg_float";
            case 15L: return "e_mem_any";
            case 16L: return "e_mem_offset";
            case 17L: return "e_mem_nonoffset";
            case 18L: return "e_mem_autoinc";
            case 19L: return "e_mem_autodec";
            case 20L: return "e_imm_int";
            case 21L: return "e_imm_number";
            case 22L: return "e_imm_symbol";
            case 23L: return "e_imm_float";
            case 24L: return "e_reg_a";
            case 25L: return "e_reg_b";
            case 26L: return "e_reg_c";
            case 27L: return "e_reg_d";
            case 28L: return "e_reg_si";
            case 29L: return "e_reg_di";
            case 30L: return "e_reg_legacy";
            case 31L: return "e_reg_q";
            case 32L: return "e_reg_ad";
            case 33L: return "e_reg_float_tos";
            case 34L: return "e_reg_float_second";
            case 35L: return "e_reg_sse";
            case 36L: return "e_reg_sse2";
            case 37L: return "e_reg_mmx";
            case 38L: return "e_imm_short_shift";
            case 39L: return "e_imm_long_shift";
            case 40L: return "e_imm_lea_shift";
            case 41L: return "e_imm_signed8";
            case 42L: return "e_imm_unsigned8";
            case 43L: return "e_imm_and_zext";
            case 44L: return "e_imm_80387";
            case 45L: return "e_imm_sse";
            case 46L: return "e_imm_sext32";
            case 47L: return "e_imm_zext32";
            case 48L: return "e_last";
            default: return "";
        }
    }

    std::string asm_operand_constraint_enum(int64_t i, const std::string &strip) {
        std::string s = asm_operand_constraint_enum(i);
        if (s.empty())
            s = "(SgAsmOp::asm_operand_constraint_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& asm_operand_constraint_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L
        };
        static const std::vector<int64_t> retval(values, values + 49);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmOp_asm_operand_constraint_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmOp::asm_operand_constraint_enum(i);
        if (retval.empty()) {
            retval = "(SgAsmOp::asm_operand_constraint_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmOp::asm_operand_constraint_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmOp_asm_operand_constraint_enum() {
        return stringify::SgAsmOp::asm_operand_constraint_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_Grammar.h line 337767
namespace stringify { namespace SgLabelSymbol {
    const char* label_type_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown_label_type";
            case 1L: return "e_non_numeric_label_type";
            case 2L: return "e_start_label_type";
            case 3L: return "e_else_label_type";
            case 4L: return "e_end_label_type";
            case 5L: return "e_alternative_return_type";
            case 6L: return "e_last_label_type";
            default: return "";
        }
    }

    std::string label_type_enum(int64_t i, const std::string &strip) {
        std::string s = label_type_enum(i);
        if (s.empty())
            s = "(SgLabelSymbol::label_type_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& label_type_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgLabelSymbol_label_type_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgLabelSymbol::label_type_enum(i);
        if (retval.empty()) {
            retval = "(SgLabelSymbol::label_type_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgLabelSymbol::label_type_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgLabelSymbol_label_type_enum() {
        return stringify::SgLabelSymbol::label_type_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 3
namespace stringify {
    const char* E_SgSourceFile(int64_t i) {
        switch (i) {
            case 0L: return "SgSourceFile_globalScope";
            default: return "";
        }
    }

    std::string E_SgSourceFile(int64_t i, const std::string &strip) {
        std::string s = E_SgSourceFile(i);
        if (s.empty())
            s = "(E_SgSourceFile)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgSourceFile() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgSourceFile(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgSourceFile(i);
        if (retval.empty()) {
            retval = "(E_SgSourceFile)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgSourceFile::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgSourceFile() {
        return stringify::E_SgSourceFile();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 6
namespace stringify {
    const char* E_SgUnknownFile(int64_t i) {
        switch (i) {
            case 0L: return "SgUnknownFile_globalScope";
            default: return "";
        }
    }

    std::string E_SgUnknownFile(int64_t i, const std::string &strip) {
        std::string s = E_SgUnknownFile(i);
        if (s.empty())
            s = "(E_SgUnknownFile)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUnknownFile() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUnknownFile(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUnknownFile(i);
        if (retval.empty()) {
            retval = "(E_SgUnknownFile)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUnknownFile::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUnknownFile() {
        return stringify::E_SgUnknownFile();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 9
namespace stringify {
    const char* E_SgProject(int64_t i) {
        switch (i) {
            case 0L: return "SgProject_fileList_ptr";
            default: return "";
        }
    }

    std::string E_SgProject(int64_t i, const std::string &strip) {
        std::string s = E_SgProject(i);
        if (s.empty())
            s = "(E_SgProject)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgProject() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgProject(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgProject(i);
        if (retval.empty()) {
            retval = "(E_SgProject)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgProject::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgProject() {
        return stringify::E_SgProject();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 12
namespace stringify {
    const char* E_SgExpBaseClass(int64_t i) {
        switch (i) {
            case 0L: return "SgExpBaseClass_base_class";
            case 1L: return "SgExpBaseClass_base_class_exp";
            default: return "";
        }
    }

    std::string E_SgExpBaseClass(int64_t i, const std::string &strip) {
        std::string s = E_SgExpBaseClass(i);
        if (s.empty())
            s = "(E_SgExpBaseClass)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgExpBaseClass() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgExpBaseClass(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgExpBaseClass(i);
        if (retval.empty()) {
            retval = "(E_SgExpBaseClass)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgExpBaseClass::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgExpBaseClass() {
        return stringify::E_SgExpBaseClass();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 15
namespace stringify {
    const char* E_SgNonrealBaseClass(int64_t i) {
        switch (i) {
            case 0L: return "SgNonrealBaseClass_base_class";
            case 1L: return "SgNonrealBaseClass_base_class_nonreal";
            default: return "";
        }
    }

    std::string E_SgNonrealBaseClass(int64_t i, const std::string &strip) {
        std::string s = E_SgNonrealBaseClass(i);
        if (s.empty())
            s = "(E_SgNonrealBaseClass)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgNonrealBaseClass() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgNonrealBaseClass(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgNonrealBaseClass(i);
        if (retval.empty()) {
            retval = "(E_SgNonrealBaseClass)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgNonrealBaseClass::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgNonrealBaseClass() {
        return stringify::E_SgNonrealBaseClass();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 18
namespace stringify {
    const char* E_SgBaseClass(int64_t i) {
        switch (i) {
            case 0L: return "SgBaseClass_base_class";
            default: return "";
        }
    }

    std::string E_SgBaseClass(int64_t i, const std::string &strip) {
        std::string s = E_SgBaseClass(i);
        if (s.empty())
            s = "(E_SgBaseClass)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgBaseClass() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgBaseClass(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgBaseClass(i);
        if (retval.empty()) {
            retval = "(E_SgBaseClass)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgBaseClass::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgBaseClass() {
        return stringify::E_SgBaseClass();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 21
namespace stringify {
    const char* E_SgTemplateParameter(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateParameter_expression";
            case 1L: return "SgTemplateParameter_defaultExpressionParameter";
            case 2L: return "SgTemplateParameter_templateDeclaration";
            case 3L: return "SgTemplateParameter_defaultTemplateDeclarationParameter";
            case 4L: return "SgTemplateParameter_initializedName";
            default: return "";
        }
    }

    std::string E_SgTemplateParameter(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateParameter(i);
        if (s.empty())
            s = "(E_SgTemplateParameter)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateParameter() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateParameter(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateParameter(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateParameter)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateParameter::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateParameter() {
        return stringify::E_SgTemplateParameter();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 24
namespace stringify {
    const char* E_SgTemplateArgument(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateArgument_expression";
            case 1L: return "SgTemplateArgument_templateDeclaration";
            case 2L: return "SgTemplateArgument_initializedName";
            default: return "";
        }
    }

    std::string E_SgTemplateArgument(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateArgument(i);
        if (s.empty())
            s = "(E_SgTemplateArgument)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateArgument() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateArgument(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateArgument(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateArgument)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateArgument::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateArgument() {
        return stringify::E_SgTemplateArgument();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 27
namespace stringify {
    const char* E_SgDirectory(int64_t i) {
        switch (i) {
            case 0L: return "SgDirectory_fileList";
            case 1L: return "SgDirectory_directoryList";
            default: return "";
        }
    }

    std::string E_SgDirectory(int64_t i, const std::string &strip) {
        std::string s = E_SgDirectory(i);
        if (s.empty())
            s = "(E_SgDirectory)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgDirectory() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgDirectory(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgDirectory(i);
        if (retval.empty()) {
            retval = "(E_SgDirectory)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgDirectory::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgDirectory() {
        return stringify::E_SgDirectory();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 30
namespace stringify {
    const char* E_SgFileList(int64_t i) {
        switch (i) {
            case 0L: return "SgFileList_listOfFiles";
            default: return "";
        }
    }

    std::string E_SgFileList(int64_t i, const std::string &strip) {
        std::string s = E_SgFileList(i);
        if (s.empty())
            s = "(E_SgFileList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgFileList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgFileList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgFileList(i);
        if (retval.empty()) {
            retval = "(E_SgFileList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgFileList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgFileList() {
        return stringify::E_SgFileList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 33
namespace stringify {
    const char* E_SgDirectoryList(int64_t i) {
        switch (i) {
            case 0L: return "SgDirectoryList_listOfDirectories";
            default: return "";
        }
    }

    std::string E_SgDirectoryList(int64_t i, const std::string &strip) {
        std::string s = E_SgDirectoryList(i);
        if (s.empty())
            s = "(E_SgDirectoryList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgDirectoryList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgDirectoryList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgDirectoryList(i);
        if (retval.empty()) {
            retval = "(E_SgDirectoryList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgDirectoryList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgDirectoryList() {
        return stringify::E_SgDirectoryList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 36
namespace stringify {
    const char* E_SgTemplateArgumentList(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateArgumentList_args";
            default: return "";
        }
    }

    std::string E_SgTemplateArgumentList(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateArgumentList(i);
        if (s.empty())
            s = "(E_SgTemplateArgumentList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateArgumentList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateArgumentList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateArgumentList(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateArgumentList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateArgumentList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateArgumentList() {
        return stringify::E_SgTemplateArgumentList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 39
namespace stringify {
    const char* E_SgTemplateParameterList(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateParameterList_args";
            default: return "";
        }
    }

    std::string E_SgTemplateParameterList(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateParameterList(i);
        if (s.empty())
            s = "(E_SgTemplateParameterList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateParameterList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateParameterList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateParameterList(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateParameterList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateParameterList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateParameterList() {
        return stringify::E_SgTemplateParameterList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 42
namespace stringify {
    const char* E_SgIncludeFile(int64_t i) {
        switch (i) {
            case 0L: return "SgIncludeFile_include_file_list";
            default: return "";
        }
    }

    std::string E_SgIncludeFile(int64_t i, const std::string &strip) {
        std::string s = E_SgIncludeFile(i);
        if (s.empty())
            s = "(E_SgIncludeFile)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgIncludeFile() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgIncludeFile(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgIncludeFile(i);
        if (retval.empty()) {
            retval = "(E_SgIncludeFile)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgIncludeFile::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgIncludeFile() {
        return stringify::E_SgIncludeFile();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 45
namespace stringify {
    const char* E_SgTypeUnknown(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeUnknown_type_kind";
            case 1L: return "SgTypeUnknown_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeUnknown(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeUnknown(i);
        if (s.empty())
            s = "(E_SgTypeUnknown)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeUnknown() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeUnknown(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeUnknown(i);
        if (retval.empty()) {
            retval = "(E_SgTypeUnknown)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeUnknown::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeUnknown() {
        return stringify::E_SgTypeUnknown();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 48
namespace stringify {
    const char* E_SgTypeChar(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeChar_type_kind";
            case 1L: return "SgTypeChar_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeChar(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeChar(i);
        if (s.empty())
            s = "(E_SgTypeChar)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeChar() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeChar(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeChar(i);
        if (retval.empty()) {
            retval = "(E_SgTypeChar)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeChar::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeChar() {
        return stringify::E_SgTypeChar();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 51
namespace stringify {
    const char* E_SgTypeSignedChar(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeSignedChar_type_kind";
            case 1L: return "SgTypeSignedChar_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeSignedChar(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeSignedChar(i);
        if (s.empty())
            s = "(E_SgTypeSignedChar)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeSignedChar() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeSignedChar(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeSignedChar(i);
        if (retval.empty()) {
            retval = "(E_SgTypeSignedChar)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeSignedChar::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeSignedChar() {
        return stringify::E_SgTypeSignedChar();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 54
namespace stringify {
    const char* E_SgTypeUnsignedChar(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeUnsignedChar_type_kind";
            case 1L: return "SgTypeUnsignedChar_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeUnsignedChar(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeUnsignedChar(i);
        if (s.empty())
            s = "(E_SgTypeUnsignedChar)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeUnsignedChar() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeUnsignedChar(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeUnsignedChar(i);
        if (retval.empty()) {
            retval = "(E_SgTypeUnsignedChar)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeUnsignedChar::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeUnsignedChar() {
        return stringify::E_SgTypeUnsignedChar();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 57
namespace stringify {
    const char* E_SgTypeShort(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeShort_type_kind";
            case 1L: return "SgTypeShort_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeShort(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeShort(i);
        if (s.empty())
            s = "(E_SgTypeShort)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeShort() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeShort(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeShort(i);
        if (retval.empty()) {
            retval = "(E_SgTypeShort)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeShort::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeShort() {
        return stringify::E_SgTypeShort();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 60
namespace stringify {
    const char* E_SgTypeSignedShort(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeSignedShort_type_kind";
            case 1L: return "SgTypeSignedShort_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeSignedShort(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeSignedShort(i);
        if (s.empty())
            s = "(E_SgTypeSignedShort)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeSignedShort() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeSignedShort(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeSignedShort(i);
        if (retval.empty()) {
            retval = "(E_SgTypeSignedShort)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeSignedShort::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeSignedShort() {
        return stringify::E_SgTypeSignedShort();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 63
namespace stringify {
    const char* E_SgTypeUnsignedShort(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeUnsignedShort_type_kind";
            case 1L: return "SgTypeUnsignedShort_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeUnsignedShort(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeUnsignedShort(i);
        if (s.empty())
            s = "(E_SgTypeUnsignedShort)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeUnsignedShort() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeUnsignedShort(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeUnsignedShort(i);
        if (retval.empty()) {
            retval = "(E_SgTypeUnsignedShort)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeUnsignedShort::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeUnsignedShort() {
        return stringify::E_SgTypeUnsignedShort();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 66
namespace stringify {
    const char* E_SgTypeInt(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeInt_type_kind";
            case 1L: return "SgTypeInt_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeInt(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeInt(i);
        if (s.empty())
            s = "(E_SgTypeInt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeInt() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeInt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeInt(i);
        if (retval.empty()) {
            retval = "(E_SgTypeInt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeInt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeInt() {
        return stringify::E_SgTypeInt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 69
namespace stringify {
    const char* E_SgTypeSignedInt(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeSignedInt_type_kind";
            case 1L: return "SgTypeSignedInt_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeSignedInt(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeSignedInt(i);
        if (s.empty())
            s = "(E_SgTypeSignedInt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeSignedInt() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeSignedInt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeSignedInt(i);
        if (retval.empty()) {
            retval = "(E_SgTypeSignedInt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeSignedInt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeSignedInt() {
        return stringify::E_SgTypeSignedInt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 72
namespace stringify {
    const char* E_SgTypeUnsignedInt(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeUnsignedInt_type_kind";
            case 1L: return "SgTypeUnsignedInt_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeUnsignedInt(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeUnsignedInt(i);
        if (s.empty())
            s = "(E_SgTypeUnsignedInt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeUnsignedInt() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeUnsignedInt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeUnsignedInt(i);
        if (retval.empty()) {
            retval = "(E_SgTypeUnsignedInt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeUnsignedInt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeUnsignedInt() {
        return stringify::E_SgTypeUnsignedInt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 75
namespace stringify {
    const char* E_SgTypeLong(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeLong_type_kind";
            case 1L: return "SgTypeLong_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeLong(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeLong(i);
        if (s.empty())
            s = "(E_SgTypeLong)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeLong() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeLong(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeLong(i);
        if (retval.empty()) {
            retval = "(E_SgTypeLong)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeLong::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeLong() {
        return stringify::E_SgTypeLong();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 78
namespace stringify {
    const char* E_SgTypeSignedLong(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeSignedLong_type_kind";
            case 1L: return "SgTypeSignedLong_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeSignedLong(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeSignedLong(i);
        if (s.empty())
            s = "(E_SgTypeSignedLong)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeSignedLong() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeSignedLong(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeSignedLong(i);
        if (retval.empty()) {
            retval = "(E_SgTypeSignedLong)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeSignedLong::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeSignedLong() {
        return stringify::E_SgTypeSignedLong();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 81
namespace stringify {
    const char* E_SgTypeUnsignedLong(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeUnsignedLong_type_kind";
            case 1L: return "SgTypeUnsignedLong_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeUnsignedLong(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeUnsignedLong(i);
        if (s.empty())
            s = "(E_SgTypeUnsignedLong)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeUnsignedLong() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeUnsignedLong(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeUnsignedLong(i);
        if (retval.empty()) {
            retval = "(E_SgTypeUnsignedLong)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeUnsignedLong::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeUnsignedLong() {
        return stringify::E_SgTypeUnsignedLong();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 84
namespace stringify {
    const char* E_SgTypeVoid(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeVoid_type_kind";
            case 1L: return "SgTypeVoid_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeVoid(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeVoid(i);
        if (s.empty())
            s = "(E_SgTypeVoid)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeVoid() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeVoid(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeVoid(i);
        if (retval.empty()) {
            retval = "(E_SgTypeVoid)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeVoid::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeVoid() {
        return stringify::E_SgTypeVoid();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 87
namespace stringify {
    const char* E_SgTypeGlobalVoid(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeGlobalVoid_type_kind";
            case 1L: return "SgTypeGlobalVoid_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeGlobalVoid(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeGlobalVoid(i);
        if (s.empty())
            s = "(E_SgTypeGlobalVoid)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeGlobalVoid() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeGlobalVoid(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeGlobalVoid(i);
        if (retval.empty()) {
            retval = "(E_SgTypeGlobalVoid)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeGlobalVoid::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeGlobalVoid() {
        return stringify::E_SgTypeGlobalVoid();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 90
namespace stringify {
    const char* E_SgTypeWchar(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeWchar_type_kind";
            case 1L: return "SgTypeWchar_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeWchar(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeWchar(i);
        if (s.empty())
            s = "(E_SgTypeWchar)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeWchar() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeWchar(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeWchar(i);
        if (retval.empty()) {
            retval = "(E_SgTypeWchar)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeWchar::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeWchar() {
        return stringify::E_SgTypeWchar();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 93
namespace stringify {
    const char* E_SgTypeFloat(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeFloat_type_kind";
            case 1L: return "SgTypeFloat_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeFloat(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeFloat(i);
        if (s.empty())
            s = "(E_SgTypeFloat)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeFloat() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeFloat(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeFloat(i);
        if (retval.empty()) {
            retval = "(E_SgTypeFloat)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeFloat::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeFloat() {
        return stringify::E_SgTypeFloat();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 96
namespace stringify {
    const char* E_SgTypeDouble(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeDouble_type_kind";
            case 1L: return "SgTypeDouble_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeDouble(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeDouble(i);
        if (s.empty())
            s = "(E_SgTypeDouble)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeDouble() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeDouble(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeDouble(i);
        if (retval.empty()) {
            retval = "(E_SgTypeDouble)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeDouble::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeDouble() {
        return stringify::E_SgTypeDouble();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 99
namespace stringify {
    const char* E_SgTypeLongLong(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeLongLong_type_kind";
            case 1L: return "SgTypeLongLong_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeLongLong(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeLongLong(i);
        if (s.empty())
            s = "(E_SgTypeLongLong)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeLongLong() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeLongLong(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeLongLong(i);
        if (retval.empty()) {
            retval = "(E_SgTypeLongLong)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeLongLong::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeLongLong() {
        return stringify::E_SgTypeLongLong();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 102
namespace stringify {
    const char* E_SgTypeSignedLongLong(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeSignedLongLong_type_kind";
            case 1L: return "SgTypeSignedLongLong_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeSignedLongLong(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeSignedLongLong(i);
        if (s.empty())
            s = "(E_SgTypeSignedLongLong)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeSignedLongLong() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeSignedLongLong(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeSignedLongLong(i);
        if (retval.empty()) {
            retval = "(E_SgTypeSignedLongLong)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeSignedLongLong::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeSignedLongLong() {
        return stringify::E_SgTypeSignedLongLong();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 105
namespace stringify {
    const char* E_SgTypeUnsignedLongLong(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeUnsignedLongLong_type_kind";
            case 1L: return "SgTypeUnsignedLongLong_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeUnsignedLongLong(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeUnsignedLongLong(i);
        if (s.empty())
            s = "(E_SgTypeUnsignedLongLong)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeUnsignedLongLong() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeUnsignedLongLong(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeUnsignedLongLong(i);
        if (retval.empty()) {
            retval = "(E_SgTypeUnsignedLongLong)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeUnsignedLongLong::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeUnsignedLongLong() {
        return stringify::E_SgTypeUnsignedLongLong();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 108
namespace stringify {
    const char* E_SgTypeSigned128bitInteger(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeSigned128bitInteger_type_kind";
            case 1L: return "SgTypeSigned128bitInteger_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeSigned128bitInteger(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeSigned128bitInteger(i);
        if (s.empty())
            s = "(E_SgTypeSigned128bitInteger)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeSigned128bitInteger() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeSigned128bitInteger(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeSigned128bitInteger(i);
        if (retval.empty()) {
            retval = "(E_SgTypeSigned128bitInteger)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeSigned128bitInteger::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeSigned128bitInteger() {
        return stringify::E_SgTypeSigned128bitInteger();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 111
namespace stringify {
    const char* E_SgTypeUnsigned128bitInteger(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeUnsigned128bitInteger_type_kind";
            case 1L: return "SgTypeUnsigned128bitInteger_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeUnsigned128bitInteger(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeUnsigned128bitInteger(i);
        if (s.empty())
            s = "(E_SgTypeUnsigned128bitInteger)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeUnsigned128bitInteger() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeUnsigned128bitInteger(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeUnsigned128bitInteger(i);
        if (retval.empty()) {
            retval = "(E_SgTypeUnsigned128bitInteger)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeUnsigned128bitInteger::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeUnsigned128bitInteger() {
        return stringify::E_SgTypeUnsigned128bitInteger();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 114
namespace stringify {
    const char* E_SgTypeFloat80(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeFloat80_type_kind";
            case 1L: return "SgTypeFloat80_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeFloat80(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeFloat80(i);
        if (s.empty())
            s = "(E_SgTypeFloat80)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeFloat80() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeFloat80(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeFloat80(i);
        if (retval.empty()) {
            retval = "(E_SgTypeFloat80)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeFloat80::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeFloat80() {
        return stringify::E_SgTypeFloat80();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 117
namespace stringify {
    const char* E_SgTypeLongDouble(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeLongDouble_type_kind";
            case 1L: return "SgTypeLongDouble_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeLongDouble(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeLongDouble(i);
        if (s.empty())
            s = "(E_SgTypeLongDouble)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeLongDouble() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeLongDouble(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeLongDouble(i);
        if (retval.empty()) {
            retval = "(E_SgTypeLongDouble)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeLongDouble::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeLongDouble() {
        return stringify::E_SgTypeLongDouble();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 120
namespace stringify {
    const char* E_SgTypeString(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeString_type_kind";
            case 1L: return "SgTypeString_lengthExpression";
            default: return "";
        }
    }

    std::string E_SgTypeString(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeString(i);
        if (s.empty())
            s = "(E_SgTypeString)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeString() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeString(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeString(i);
        if (retval.empty()) {
            retval = "(E_SgTypeString)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeString::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeString() {
        return stringify::E_SgTypeString();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 123
namespace stringify {
    const char* E_SgTypeBool(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeBool_type_kind";
            case 1L: return "SgTypeBool_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeBool(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeBool(i);
        if (s.empty())
            s = "(E_SgTypeBool)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeBool() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeBool(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeBool(i);
        if (retval.empty()) {
            retval = "(E_SgTypeBool)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeBool::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeBool() {
        return stringify::E_SgTypeBool();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 126
namespace stringify {
    const char* E_SgPointerMemberType(int64_t i) {
        switch (i) {
            case 0L: return "SgPointerMemberType_type_kind";
            case 1L: return "SgPointerMemberType_base_type";
            default: return "";
        }
    }

    std::string E_SgPointerMemberType(int64_t i, const std::string &strip) {
        std::string s = E_SgPointerMemberType(i);
        if (s.empty())
            s = "(E_SgPointerMemberType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgPointerMemberType() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgPointerMemberType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgPointerMemberType(i);
        if (retval.empty()) {
            retval = "(E_SgPointerMemberType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgPointerMemberType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgPointerMemberType() {
        return stringify::E_SgPointerMemberType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 129
namespace stringify {
    const char* E_SgPointerType(int64_t i) {
        switch (i) {
            case 0L: return "SgPointerType_type_kind";
            case 1L: return "SgPointerType_base_type";
            default: return "";
        }
    }

    std::string E_SgPointerType(int64_t i, const std::string &strip) {
        std::string s = E_SgPointerType(i);
        if (s.empty())
            s = "(E_SgPointerType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgPointerType() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgPointerType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgPointerType(i);
        if (retval.empty()) {
            retval = "(E_SgPointerType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgPointerType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgPointerType() {
        return stringify::E_SgPointerType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 132
namespace stringify {
    const char* E_SgReferenceType(int64_t i) {
        switch (i) {
            case 0L: return "SgReferenceType_type_kind";
            default: return "";
        }
    }

    std::string E_SgReferenceType(int64_t i, const std::string &strip) {
        std::string s = E_SgReferenceType(i);
        if (s.empty())
            s = "(E_SgReferenceType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgReferenceType() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgReferenceType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgReferenceType(i);
        if (retval.empty()) {
            retval = "(E_SgReferenceType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgReferenceType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgReferenceType() {
        return stringify::E_SgReferenceType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 135
namespace stringify {
    const char* E_SgClassType(int64_t i) {
        switch (i) {
            case 0L: return "SgClassType_type_kind";
            case 1L: return "SgClassType_builtin_type";
            case 2L: return "SgClassType_declaration";
            default: return "";
        }
    }

    std::string E_SgClassType(int64_t i, const std::string &strip) {
        std::string s = E_SgClassType(i);
        if (s.empty())
            s = "(E_SgClassType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgClassType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgClassType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgClassType(i);
        if (retval.empty()) {
            retval = "(E_SgClassType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgClassType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgClassType() {
        return stringify::E_SgClassType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 138
namespace stringify {
    const char* E_SgEnumType(int64_t i) {
        switch (i) {
            case 0L: return "SgEnumType_type_kind";
            case 1L: return "SgEnumType_builtin_type";
            case 2L: return "SgEnumType_declaration";
            default: return "";
        }
    }

    std::string E_SgEnumType(int64_t i, const std::string &strip) {
        std::string s = E_SgEnumType(i);
        if (s.empty())
            s = "(E_SgEnumType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgEnumType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgEnumType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgEnumType(i);
        if (retval.empty()) {
            retval = "(E_SgEnumType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgEnumType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgEnumType() {
        return stringify::E_SgEnumType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 141
namespace stringify {
    const char* E_SgTypedefType(int64_t i) {
        switch (i) {
            case 0L: return "SgTypedefType_type_kind";
            case 1L: return "SgTypedefType_builtin_type";
            case 2L: return "SgTypedefType_declaration";
            default: return "";
        }
    }

    std::string E_SgTypedefType(int64_t i, const std::string &strip) {
        std::string s = E_SgTypedefType(i);
        if (s.empty())
            s = "(E_SgTypedefType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypedefType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypedefType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypedefType(i);
        if (retval.empty()) {
            retval = "(E_SgTypedefType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypedefType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypedefType() {
        return stringify::E_SgTypedefType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 144
namespace stringify {
    const char* E_SgNonrealType(int64_t i) {
        switch (i) {
            case 0L: return "SgNonrealType_type_kind";
            case 1L: return "SgNonrealType_builtin_type";
            case 2L: return "SgNonrealType_declaration";
            default: return "";
        }
    }

    std::string E_SgNonrealType(int64_t i, const std::string &strip) {
        std::string s = E_SgNonrealType(i);
        if (s.empty())
            s = "(E_SgNonrealType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgNonrealType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgNonrealType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgNonrealType(i);
        if (retval.empty()) {
            retval = "(E_SgNonrealType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgNonrealType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgNonrealType() {
        return stringify::E_SgNonrealType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 147
namespace stringify {
    const char* E_SgNamedType(int64_t i) {
        switch (i) {
            case 0L: return "SgNamedType_type_kind";
            case 1L: return "SgNamedType_builtin_type";
            case 2L: return "SgNamedType_declaration";
            default: return "";
        }
    }

    std::string E_SgNamedType(int64_t i, const std::string &strip) {
        std::string s = E_SgNamedType(i);
        if (s.empty())
            s = "(E_SgNamedType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgNamedType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgNamedType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgNamedType(i);
        if (retval.empty()) {
            retval = "(E_SgNamedType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgNamedType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgNamedType() {
        return stringify::E_SgNamedType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 150
namespace stringify {
    const char* E_SgModifierType(int64_t i) {
        switch (i) {
            case 0L: return "SgModifierType_type_kind";
            case 1L: return "SgModifierType_base_type";
            default: return "";
        }
    }

    std::string E_SgModifierType(int64_t i, const std::string &strip) {
        std::string s = E_SgModifierType(i);
        if (s.empty())
            s = "(E_SgModifierType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgModifierType() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgModifierType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgModifierType(i);
        if (retval.empty()) {
            retval = "(E_SgModifierType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgModifierType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgModifierType() {
        return stringify::E_SgModifierType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 153
namespace stringify {
    const char* E_SgPartialFunctionModifierType(int64_t i) {
        switch (i) {
            case 0L: return "SgPartialFunctionModifierType_type_kind";
            case 1L: return "SgPartialFunctionModifierType_return_type";
            case 2L: return "SgPartialFunctionModifierType_orig_return_type";
            case 3L: return "SgPartialFunctionModifierType_builtin_type";
            default: return "";
        }
    }

    std::string E_SgPartialFunctionModifierType(int64_t i, const std::string &strip) {
        std::string s = E_SgPartialFunctionModifierType(i);
        if (s.empty())
            s = "(E_SgPartialFunctionModifierType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgPartialFunctionModifierType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgPartialFunctionModifierType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgPartialFunctionModifierType(i);
        if (retval.empty()) {
            retval = "(E_SgPartialFunctionModifierType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgPartialFunctionModifierType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgPartialFunctionModifierType() {
        return stringify::E_SgPartialFunctionModifierType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 156
namespace stringify {
    const char* E_SgPartialFunctionType(int64_t i) {
        switch (i) {
            case 0L: return "SgPartialFunctionType_type_kind";
            case 1L: return "SgPartialFunctionType_return_type";
            case 2L: return "SgPartialFunctionType_orig_return_type";
            default: return "";
        }
    }

    std::string E_SgPartialFunctionType(int64_t i, const std::string &strip) {
        std::string s = E_SgPartialFunctionType(i);
        if (s.empty())
            s = "(E_SgPartialFunctionType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgPartialFunctionType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgPartialFunctionType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgPartialFunctionType(i);
        if (retval.empty()) {
            retval = "(E_SgPartialFunctionType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgPartialFunctionType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgPartialFunctionType() {
        return stringify::E_SgPartialFunctionType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 159
namespace stringify {
    const char* E_SgMemberFunctionType(int64_t i) {
        switch (i) {
            case 0L: return "SgMemberFunctionType_type_kind";
            case 1L: return "SgMemberFunctionType_return_type";
            case 2L: return "SgMemberFunctionType_orig_return_type";
            default: return "";
        }
    }

    std::string E_SgMemberFunctionType(int64_t i, const std::string &strip) {
        std::string s = E_SgMemberFunctionType(i);
        if (s.empty())
            s = "(E_SgMemberFunctionType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgMemberFunctionType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgMemberFunctionType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgMemberFunctionType(i);
        if (retval.empty()) {
            retval = "(E_SgMemberFunctionType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgMemberFunctionType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgMemberFunctionType() {
        return stringify::E_SgMemberFunctionType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 162
namespace stringify {
    const char* E_SgFunctionType(int64_t i) {
        switch (i) {
            case 0L: return "SgFunctionType_type_kind";
            case 1L: return "SgFunctionType_return_type";
            case 2L: return "SgFunctionType_orig_return_type";
            default: return "";
        }
    }

    std::string E_SgFunctionType(int64_t i, const std::string &strip) {
        std::string s = E_SgFunctionType(i);
        if (s.empty())
            s = "(E_SgFunctionType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgFunctionType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgFunctionType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgFunctionType(i);
        if (retval.empty()) {
            retval = "(E_SgFunctionType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgFunctionType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgFunctionType() {
        return stringify::E_SgFunctionType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 165
namespace stringify {
    const char* E_SgArrayType(int64_t i) {
        switch (i) {
            case 0L: return "SgArrayType_type_kind";
            case 1L: return "SgArrayType_index";
            case 2L: return "SgArrayType_dim_info";
            default: return "";
        }
    }

    std::string E_SgArrayType(int64_t i, const std::string &strip) {
        std::string s = E_SgArrayType(i);
        if (s.empty())
            s = "(E_SgArrayType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgArrayType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgArrayType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgArrayType(i);
        if (retval.empty()) {
            retval = "(E_SgArrayType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgArrayType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgArrayType() {
        return stringify::E_SgArrayType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 168
namespace stringify {
    const char* E_SgTypeEllipse(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeEllipse_type_kind";
            case 1L: return "SgTypeEllipse_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeEllipse(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeEllipse(i);
        if (s.empty())
            s = "(E_SgTypeEllipse)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeEllipse() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeEllipse(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeEllipse(i);
        if (retval.empty()) {
            retval = "(E_SgTypeEllipse)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeEllipse::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeEllipse() {
        return stringify::E_SgTypeEllipse();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 171
namespace stringify {
    const char* E_SgTemplateType(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateType_type_kind";
            case 1L: return "SgTemplateType_class_type";
            case 2L: return "SgTemplateType_parent_class_type";
            case 3L: return "SgTemplateType_template_parameter";
            default: return "";
        }
    }

    std::string E_SgTemplateType(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateType(i);
        if (s.empty())
            s = "(E_SgTemplateType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateType(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateType() {
        return stringify::E_SgTemplateType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 174
namespace stringify {
    const char* E_SgQualifiedNameType(int64_t i) {
        switch (i) {
            case 0L: return "SgQualifiedNameType_type_kind";
            default: return "";
        }
    }

    std::string E_SgQualifiedNameType(int64_t i, const std::string &strip) {
        std::string s = E_SgQualifiedNameType(i);
        if (s.empty())
            s = "(E_SgQualifiedNameType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgQualifiedNameType() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgQualifiedNameType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgQualifiedNameType(i);
        if (retval.empty()) {
            retval = "(E_SgQualifiedNameType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgQualifiedNameType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgQualifiedNameType() {
        return stringify::E_SgQualifiedNameType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 177
namespace stringify {
    const char* E_SgTypeComplex(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeComplex_type_kind";
            default: return "";
        }
    }

    std::string E_SgTypeComplex(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeComplex(i);
        if (s.empty())
            s = "(E_SgTypeComplex)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeComplex() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeComplex(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeComplex(i);
        if (retval.empty()) {
            retval = "(E_SgTypeComplex)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeComplex::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeComplex() {
        return stringify::E_SgTypeComplex();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 180
namespace stringify {
    const char* E_SgTypeImaginary(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeImaginary_type_kind";
            default: return "";
        }
    }

    std::string E_SgTypeImaginary(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeImaginary(i);
        if (s.empty())
            s = "(E_SgTypeImaginary)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeImaginary() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeImaginary(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeImaginary(i);
        if (retval.empty()) {
            retval = "(E_SgTypeImaginary)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeImaginary::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeImaginary() {
        return stringify::E_SgTypeImaginary();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 183
namespace stringify {
    const char* E_SgTypeDefault(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeDefault_type_kind";
            case 1L: return "SgTypeDefault_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeDefault(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeDefault(i);
        if (s.empty())
            s = "(E_SgTypeDefault)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeDefault() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeDefault(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeDefault(i);
        if (retval.empty()) {
            retval = "(E_SgTypeDefault)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeDefault::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeDefault() {
        return stringify::E_SgTypeDefault();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 186
namespace stringify {
    const char* E_SgTypeCAFTeam(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeCAFTeam_type_kind";
            case 1L: return "SgTypeCAFTeam_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeCAFTeam(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeCAFTeam(i);
        if (s.empty())
            s = "(E_SgTypeCAFTeam)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeCAFTeam() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeCAFTeam(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeCAFTeam(i);
        if (retval.empty()) {
            retval = "(E_SgTypeCAFTeam)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeCAFTeam::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeCAFTeam() {
        return stringify::E_SgTypeCAFTeam();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 189
namespace stringify {
    const char* E_SgTypeCrayPointer(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeCrayPointer_type_kind";
            case 1L: return "SgTypeCrayPointer_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeCrayPointer(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeCrayPointer(i);
        if (s.empty())
            s = "(E_SgTypeCrayPointer)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeCrayPointer() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeCrayPointer(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeCrayPointer(i);
        if (retval.empty()) {
            retval = "(E_SgTypeCrayPointer)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeCrayPointer::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeCrayPointer() {
        return stringify::E_SgTypeCrayPointer();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 192
namespace stringify {
    const char* E_SgTypeLabel(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeLabel_type_kind";
            case 1L: return "SgTypeLabel_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeLabel(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeLabel(i);
        if (s.empty())
            s = "(E_SgTypeLabel)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeLabel() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeLabel(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeLabel(i);
        if (retval.empty()) {
            retval = "(E_SgTypeLabel)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeLabel::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeLabel() {
        return stringify::E_SgTypeLabel();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 195
namespace stringify {
    const char* E_SgRvalueReferenceType(int64_t i) {
        switch (i) {
            case 0L: return "SgRvalueReferenceType_type_kind";
            default: return "";
        }
    }

    std::string E_SgRvalueReferenceType(int64_t i, const std::string &strip) {
        std::string s = E_SgRvalueReferenceType(i);
        if (s.empty())
            s = "(E_SgRvalueReferenceType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgRvalueReferenceType() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgRvalueReferenceType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgRvalueReferenceType(i);
        if (retval.empty()) {
            retval = "(E_SgRvalueReferenceType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgRvalueReferenceType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgRvalueReferenceType() {
        return stringify::E_SgRvalueReferenceType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 198
namespace stringify {
    const char* E_SgTypeNullptr(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeNullptr_type_kind";
            case 1L: return "SgTypeNullptr_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeNullptr(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeNullptr(i);
        if (s.empty())
            s = "(E_SgTypeNullptr)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeNullptr() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeNullptr(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeNullptr(i);
        if (retval.empty()) {
            retval = "(E_SgTypeNullptr)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeNullptr::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeNullptr() {
        return stringify::E_SgTypeNullptr();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 201
namespace stringify {
    const char* E_SgDeclType(int64_t i) {
        switch (i) {
            case 0L: return "SgDeclType_type_kind";
            default: return "";
        }
    }

    std::string E_SgDeclType(int64_t i, const std::string &strip) {
        std::string s = E_SgDeclType(i);
        if (s.empty())
            s = "(E_SgDeclType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgDeclType() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgDeclType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgDeclType(i);
        if (retval.empty()) {
            retval = "(E_SgDeclType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgDeclType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgDeclType() {
        return stringify::E_SgDeclType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 204
namespace stringify {
    const char* E_SgTypeOfType(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeOfType_type_kind";
            default: return "";
        }
    }

    std::string E_SgTypeOfType(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeOfType(i);
        if (s.empty())
            s = "(E_SgTypeOfType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeOfType() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeOfType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeOfType(i);
        if (retval.empty()) {
            retval = "(E_SgTypeOfType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeOfType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeOfType() {
        return stringify::E_SgTypeOfType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 207
namespace stringify {
    const char* E_SgTypeMatrix(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeMatrix_type_kind";
            case 1L: return "SgTypeMatrix_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeMatrix(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeMatrix(i);
        if (s.empty())
            s = "(E_SgTypeMatrix)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeMatrix() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeMatrix(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeMatrix(i);
        if (retval.empty()) {
            retval = "(E_SgTypeMatrix)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeMatrix::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeMatrix() {
        return stringify::E_SgTypeMatrix();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 210
namespace stringify {
    const char* E_SgTypeTuple(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeTuple_type_kind";
            case 1L: return "SgTypeTuple_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeTuple(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeTuple(i);
        if (s.empty())
            s = "(E_SgTypeTuple)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeTuple() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeTuple(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeTuple(i);
        if (retval.empty()) {
            retval = "(E_SgTypeTuple)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeTuple::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeTuple() {
        return stringify::E_SgTypeTuple();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 213
namespace stringify {
    const char* E_SgTypeChar16(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeChar16_type_kind";
            case 1L: return "SgTypeChar16_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeChar16(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeChar16(i);
        if (s.empty())
            s = "(E_SgTypeChar16)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeChar16() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeChar16(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeChar16(i);
        if (retval.empty()) {
            retval = "(E_SgTypeChar16)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeChar16::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeChar16() {
        return stringify::E_SgTypeChar16();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 216
namespace stringify {
    const char* E_SgTypeChar32(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeChar32_type_kind";
            case 1L: return "SgTypeChar32_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeChar32(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeChar32(i);
        if (s.empty())
            s = "(E_SgTypeChar32)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeChar32() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeChar32(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeChar32(i);
        if (retval.empty()) {
            retval = "(E_SgTypeChar32)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeChar32::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeChar32() {
        return stringify::E_SgTypeChar32();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 219
namespace stringify {
    const char* E_SgTypeFloat128(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeFloat128_type_kind";
            case 1L: return "SgTypeFloat128_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeFloat128(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeFloat128(i);
        if (s.empty())
            s = "(E_SgTypeFloat128)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeFloat128() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeFloat128(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeFloat128(i);
        if (retval.empty()) {
            retval = "(E_SgTypeFloat128)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeFloat128::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeFloat128() {
        return stringify::E_SgTypeFloat128();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 222
namespace stringify {
    const char* E_SgTypeFixed(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeFixed_type_kind";
            case 1L: return "SgTypeFixed_scale";
            case 2L: return "SgTypeFixed_fraction";
            default: return "";
        }
    }

    std::string E_SgTypeFixed(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeFixed(i);
        if (s.empty())
            s = "(E_SgTypeFixed)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeFixed() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeFixed(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeFixed(i);
        if (retval.empty()) {
            retval = "(E_SgTypeFixed)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeFixed::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeFixed() {
        return stringify::E_SgTypeFixed();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 225
namespace stringify {
    const char* E_SgAutoType(int64_t i) {
        switch (i) {
            case 0L: return "SgAutoType_type_kind";
            default: return "";
        }
    }

    std::string E_SgAutoType(int64_t i, const std::string &strip) {
        std::string s = E_SgAutoType(i);
        if (s.empty())
            s = "(E_SgAutoType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAutoType() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAutoType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAutoType(i);
        if (retval.empty()) {
            retval = "(E_SgAutoType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAutoType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAutoType() {
        return stringify::E_SgAutoType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 228
namespace stringify {
    const char* E_SgType(int64_t i) {
        switch (i) {
            case 0L: return "SgType_type_kind";
            default: return "";
        }
    }

    std::string E_SgType(int64_t i, const std::string &strip) {
        std::string s = E_SgType(i);
        if (s.empty())
            s = "(E_SgType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgType() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgType(i);
        if (retval.empty()) {
            retval = "(E_SgType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgType() {
        return stringify::E_SgType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 231
namespace stringify {
    const char* E_SgCommonBlockObject(int64_t i) {
        switch (i) {
            case 0L: return "SgCommonBlockObject_variable_reference_list";
            default: return "";
        }
    }

    std::string E_SgCommonBlockObject(int64_t i, const std::string &strip) {
        std::string s = E_SgCommonBlockObject(i);
        if (s.empty())
            s = "(E_SgCommonBlockObject)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgCommonBlockObject() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgCommonBlockObject(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgCommonBlockObject(i);
        if (retval.empty()) {
            retval = "(E_SgCommonBlockObject)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgCommonBlockObject::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgCommonBlockObject() {
        return stringify::E_SgCommonBlockObject();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 234
namespace stringify {
    const char* E_SgInitializedName(int64_t i) {
        switch (i) {
            case 0L: return "SgInitializedName_initptr";
            default: return "";
        }
    }

    std::string E_SgInitializedName(int64_t i, const std::string &strip) {
        std::string s = E_SgInitializedName(i);
        if (s.empty())
            s = "(E_SgInitializedName)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgInitializedName() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgInitializedName(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgInitializedName(i);
        if (retval.empty()) {
            retval = "(E_SgInitializedName)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgInitializedName::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgInitializedName() {
        return stringify::E_SgInitializedName();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 237
namespace stringify {
    const char* E_SgOmpDefaultClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpDefaultClause_variant_directive";
            default: return "";
        }
    }

    std::string E_SgOmpDefaultClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpDefaultClause(i);
        if (s.empty())
            s = "(E_SgOmpDefaultClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpDefaultClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpDefaultClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpDefaultClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpDefaultClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpDefaultClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpDefaultClause() {
        return stringify::E_SgOmpDefaultClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 240
namespace stringify {
    const char* E_SgOmpDistScheduleClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpDistScheduleClause_chunk_size";
            default: return "";
        }
    }

    std::string E_SgOmpDistScheduleClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpDistScheduleClause(i);
        if (s.empty())
            s = "(E_SgOmpDistScheduleClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpDistScheduleClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpDistScheduleClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpDistScheduleClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpDistScheduleClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpDistScheduleClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpDistScheduleClause() {
        return stringify::E_SgOmpDistScheduleClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 243
namespace stringify {
    const char* E_SgOmpOrderedClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpOrderedClause_expression";
            default: return "";
        }
    }

    std::string E_SgOmpOrderedClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpOrderedClause(i);
        if (s.empty())
            s = "(E_SgOmpOrderedClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpOrderedClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpOrderedClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpOrderedClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpOrderedClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpOrderedClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpOrderedClause() {
        return stringify::E_SgOmpOrderedClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 246
namespace stringify {
    const char* E_SgOmpCollapseClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpCollapseClause_expression";
            default: return "";
        }
    }

    std::string E_SgOmpCollapseClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpCollapseClause(i);
        if (s.empty())
            s = "(E_SgOmpCollapseClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpCollapseClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpCollapseClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpCollapseClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpCollapseClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpCollapseClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpCollapseClause() {
        return stringify::E_SgOmpCollapseClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 249
namespace stringify {
    const char* E_SgOmpIfClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpIfClause_expression";
            default: return "";
        }
    }

    std::string E_SgOmpIfClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpIfClause(i);
        if (s.empty())
            s = "(E_SgOmpIfClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpIfClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpIfClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpIfClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpIfClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpIfClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpIfClause() {
        return stringify::E_SgOmpIfClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 252
namespace stringify {
    const char* E_SgOmpNumThreadsClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpNumThreadsClause_expression";
            default: return "";
        }
    }

    std::string E_SgOmpNumThreadsClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpNumThreadsClause(i);
        if (s.empty())
            s = "(E_SgOmpNumThreadsClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpNumThreadsClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpNumThreadsClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpNumThreadsClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpNumThreadsClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpNumThreadsClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpNumThreadsClause() {
        return stringify::E_SgOmpNumThreadsClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 255
namespace stringify {
    const char* E_SgOmpNumTeamsClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpNumTeamsClause_expression";
            default: return "";
        }
    }

    std::string E_SgOmpNumTeamsClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpNumTeamsClause(i);
        if (s.empty())
            s = "(E_SgOmpNumTeamsClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpNumTeamsClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpNumTeamsClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpNumTeamsClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpNumTeamsClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpNumTeamsClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpNumTeamsClause() {
        return stringify::E_SgOmpNumTeamsClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 258
namespace stringify {
    const char* E_SgOmpThreadLimitClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpThreadLimitClause_expression";
            default: return "";
        }
    }

    std::string E_SgOmpThreadLimitClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpThreadLimitClause(i);
        if (s.empty())
            s = "(E_SgOmpThreadLimitClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpThreadLimitClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpThreadLimitClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpThreadLimitClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpThreadLimitClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpThreadLimitClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpThreadLimitClause() {
        return stringify::E_SgOmpThreadLimitClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 261
namespace stringify {
    const char* E_SgOmpDeviceClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpDeviceClause_expression";
            default: return "";
        }
    }

    std::string E_SgOmpDeviceClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpDeviceClause(i);
        if (s.empty())
            s = "(E_SgOmpDeviceClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpDeviceClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpDeviceClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpDeviceClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpDeviceClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpDeviceClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpDeviceClause() {
        return stringify::E_SgOmpDeviceClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 264
namespace stringify {
    const char* E_SgOmpHintClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpHintClause_expression";
            default: return "";
        }
    }

    std::string E_SgOmpHintClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpHintClause(i);
        if (s.empty())
            s = "(E_SgOmpHintClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpHintClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpHintClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpHintClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpHintClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpHintClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpHintClause() {
        return stringify::E_SgOmpHintClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 267
namespace stringify {
    const char* E_SgOmpGrainsizeClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpGrainsizeClause_expression";
            default: return "";
        }
    }

    std::string E_SgOmpGrainsizeClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpGrainsizeClause(i);
        if (s.empty())
            s = "(E_SgOmpGrainsizeClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpGrainsizeClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpGrainsizeClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpGrainsizeClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpGrainsizeClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpGrainsizeClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpGrainsizeClause() {
        return stringify::E_SgOmpGrainsizeClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 270
namespace stringify {
    const char* E_SgOmpNumTasksClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpNumTasksClause_expression";
            default: return "";
        }
    }

    std::string E_SgOmpNumTasksClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpNumTasksClause(i);
        if (s.empty())
            s = "(E_SgOmpNumTasksClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpNumTasksClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpNumTasksClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpNumTasksClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpNumTasksClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpNumTasksClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpNumTasksClause() {
        return stringify::E_SgOmpNumTasksClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 273
namespace stringify {
    const char* E_SgOmpDetachClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpDetachClause_expression";
            default: return "";
        }
    }

    std::string E_SgOmpDetachClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpDetachClause(i);
        if (s.empty())
            s = "(E_SgOmpDetachClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpDetachClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpDetachClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpDetachClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpDetachClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpDetachClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpDetachClause() {
        return stringify::E_SgOmpDetachClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 276
namespace stringify {
    const char* E_SgOmpSafelenClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpSafelenClause_expression";
            default: return "";
        }
    }

    std::string E_SgOmpSafelenClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpSafelenClause(i);
        if (s.empty())
            s = "(E_SgOmpSafelenClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpSafelenClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpSafelenClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpSafelenClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpSafelenClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpSafelenClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpSafelenClause() {
        return stringify::E_SgOmpSafelenClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 279
namespace stringify {
    const char* E_SgOmpSimdlenClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpSimdlenClause_expression";
            default: return "";
        }
    }

    std::string E_SgOmpSimdlenClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpSimdlenClause(i);
        if (s.empty())
            s = "(E_SgOmpSimdlenClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpSimdlenClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpSimdlenClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpSimdlenClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpSimdlenClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpSimdlenClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpSimdlenClause() {
        return stringify::E_SgOmpSimdlenClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 282
namespace stringify {
    const char* E_SgOmpFinalClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpFinalClause_expression";
            default: return "";
        }
    }

    std::string E_SgOmpFinalClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpFinalClause(i);
        if (s.empty())
            s = "(E_SgOmpFinalClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpFinalClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpFinalClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpFinalClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpFinalClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpFinalClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpFinalClause() {
        return stringify::E_SgOmpFinalClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 285
namespace stringify {
    const char* E_SgOmpPriorityClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpPriorityClause_expression";
            default: return "";
        }
    }

    std::string E_SgOmpPriorityClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpPriorityClause(i);
        if (s.empty())
            s = "(E_SgOmpPriorityClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpPriorityClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpPriorityClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpPriorityClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpPriorityClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpPriorityClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpPriorityClause() {
        return stringify::E_SgOmpPriorityClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 288
namespace stringify {
    const char* E_SgOmpExpressionClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpExpressionClause_expression";
            default: return "";
        }
    }

    std::string E_SgOmpExpressionClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpExpressionClause(i);
        if (s.empty())
            s = "(E_SgOmpExpressionClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpExpressionClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpExpressionClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpExpressionClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpExpressionClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpExpressionClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpExpressionClause() {
        return stringify::E_SgOmpExpressionClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 291
namespace stringify {
    const char* E_SgOmpCopyprivateClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpCopyprivateClause_variables";
            default: return "";
        }
    }

    std::string E_SgOmpCopyprivateClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpCopyprivateClause(i);
        if (s.empty())
            s = "(E_SgOmpCopyprivateClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpCopyprivateClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpCopyprivateClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpCopyprivateClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpCopyprivateClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpCopyprivateClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpCopyprivateClause() {
        return stringify::E_SgOmpCopyprivateClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 294
namespace stringify {
    const char* E_SgOmpPrivateClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpPrivateClause_variables";
            default: return "";
        }
    }

    std::string E_SgOmpPrivateClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpPrivateClause(i);
        if (s.empty())
            s = "(E_SgOmpPrivateClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpPrivateClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpPrivateClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpPrivateClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpPrivateClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpPrivateClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpPrivateClause() {
        return stringify::E_SgOmpPrivateClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 297
namespace stringify {
    const char* E_SgOmpFirstprivateClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpFirstprivateClause_variables";
            default: return "";
        }
    }

    std::string E_SgOmpFirstprivateClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpFirstprivateClause(i);
        if (s.empty())
            s = "(E_SgOmpFirstprivateClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpFirstprivateClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpFirstprivateClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpFirstprivateClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpFirstprivateClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpFirstprivateClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpFirstprivateClause() {
        return stringify::E_SgOmpFirstprivateClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 300
namespace stringify {
    const char* E_SgOmpNontemporalClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpNontemporalClause_variables";
            default: return "";
        }
    }

    std::string E_SgOmpNontemporalClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpNontemporalClause(i);
        if (s.empty())
            s = "(E_SgOmpNontemporalClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpNontemporalClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpNontemporalClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpNontemporalClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpNontemporalClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpNontemporalClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpNontemporalClause() {
        return stringify::E_SgOmpNontemporalClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 303
namespace stringify {
    const char* E_SgOmpInclusiveClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpInclusiveClause_variables";
            default: return "";
        }
    }

    std::string E_SgOmpInclusiveClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpInclusiveClause(i);
        if (s.empty())
            s = "(E_SgOmpInclusiveClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpInclusiveClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpInclusiveClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpInclusiveClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpInclusiveClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpInclusiveClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpInclusiveClause() {
        return stringify::E_SgOmpInclusiveClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 306
namespace stringify {
    const char* E_SgOmpExclusiveClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpExclusiveClause_variables";
            default: return "";
        }
    }

    std::string E_SgOmpExclusiveClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpExclusiveClause(i);
        if (s.empty())
            s = "(E_SgOmpExclusiveClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpExclusiveClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpExclusiveClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpExclusiveClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpExclusiveClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpExclusiveClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpExclusiveClause() {
        return stringify::E_SgOmpExclusiveClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 309
namespace stringify {
    const char* E_SgOmpIsDevicePtrClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpIsDevicePtrClause_variables";
            default: return "";
        }
    }

    std::string E_SgOmpIsDevicePtrClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpIsDevicePtrClause(i);
        if (s.empty())
            s = "(E_SgOmpIsDevicePtrClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpIsDevicePtrClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpIsDevicePtrClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpIsDevicePtrClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpIsDevicePtrClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpIsDevicePtrClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpIsDevicePtrClause() {
        return stringify::E_SgOmpIsDevicePtrClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 312
namespace stringify {
    const char* E_SgOmpUseDevicePtrClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpUseDevicePtrClause_variables";
            default: return "";
        }
    }

    std::string E_SgOmpUseDevicePtrClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpUseDevicePtrClause(i);
        if (s.empty())
            s = "(E_SgOmpUseDevicePtrClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpUseDevicePtrClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpUseDevicePtrClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpUseDevicePtrClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpUseDevicePtrClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpUseDevicePtrClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpUseDevicePtrClause() {
        return stringify::E_SgOmpUseDevicePtrClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 315
namespace stringify {
    const char* E_SgOmpUseDeviceAddrClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpUseDeviceAddrClause_variables";
            default: return "";
        }
    }

    std::string E_SgOmpUseDeviceAddrClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpUseDeviceAddrClause(i);
        if (s.empty())
            s = "(E_SgOmpUseDeviceAddrClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpUseDeviceAddrClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpUseDeviceAddrClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpUseDeviceAddrClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpUseDeviceAddrClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpUseDeviceAddrClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpUseDeviceAddrClause() {
        return stringify::E_SgOmpUseDeviceAddrClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 318
namespace stringify {
    const char* E_SgOmpSharedClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpSharedClause_variables";
            default: return "";
        }
    }

    std::string E_SgOmpSharedClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpSharedClause(i);
        if (s.empty())
            s = "(E_SgOmpSharedClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpSharedClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpSharedClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpSharedClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpSharedClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpSharedClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpSharedClause() {
        return stringify::E_SgOmpSharedClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 321
namespace stringify {
    const char* E_SgOmpCopyinClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpCopyinClause_variables";
            default: return "";
        }
    }

    std::string E_SgOmpCopyinClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpCopyinClause(i);
        if (s.empty())
            s = "(E_SgOmpCopyinClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpCopyinClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpCopyinClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpCopyinClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpCopyinClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpCopyinClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpCopyinClause() {
        return stringify::E_SgOmpCopyinClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 324
namespace stringify {
    const char* E_SgOmpLastprivateClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpLastprivateClause_variables";
            default: return "";
        }
    }

    std::string E_SgOmpLastprivateClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpLastprivateClause(i);
        if (s.empty())
            s = "(E_SgOmpLastprivateClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpLastprivateClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpLastprivateClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpLastprivateClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpLastprivateClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpLastprivateClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpLastprivateClause() {
        return stringify::E_SgOmpLastprivateClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 327
namespace stringify {
    const char* E_SgOmpReductionClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpReductionClause_variables";
            default: return "";
        }
    }

    std::string E_SgOmpReductionClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpReductionClause(i);
        if (s.empty())
            s = "(E_SgOmpReductionClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpReductionClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpReductionClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpReductionClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpReductionClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpReductionClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpReductionClause() {
        return stringify::E_SgOmpReductionClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 330
namespace stringify {
    const char* E_SgOmpInReductionClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpInReductionClause_variables";
            default: return "";
        }
    }

    std::string E_SgOmpInReductionClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpInReductionClause(i);
        if (s.empty())
            s = "(E_SgOmpInReductionClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpInReductionClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpInReductionClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpInReductionClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpInReductionClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpInReductionClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpInReductionClause() {
        return stringify::E_SgOmpInReductionClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 333
namespace stringify {
    const char* E_SgOmpTaskReductionClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpTaskReductionClause_variables";
            default: return "";
        }
    }

    std::string E_SgOmpTaskReductionClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpTaskReductionClause(i);
        if (s.empty())
            s = "(E_SgOmpTaskReductionClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpTaskReductionClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpTaskReductionClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpTaskReductionClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpTaskReductionClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpTaskReductionClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpTaskReductionClause() {
        return stringify::E_SgOmpTaskReductionClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 336
namespace stringify {
    const char* E_SgOmpMapClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpMapClause_variables";
            default: return "";
        }
    }

    std::string E_SgOmpMapClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpMapClause(i);
        if (s.empty())
            s = "(E_SgOmpMapClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpMapClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpMapClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpMapClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpMapClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpMapClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpMapClause() {
        return stringify::E_SgOmpMapClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 339
namespace stringify {
    const char* E_SgOmpAllocateClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpAllocateClause_variables";
            default: return "";
        }
    }

    std::string E_SgOmpAllocateClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpAllocateClause(i);
        if (s.empty())
            s = "(E_SgOmpAllocateClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpAllocateClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpAllocateClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpAllocateClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpAllocateClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpAllocateClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpAllocateClause() {
        return stringify::E_SgOmpAllocateClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 342
namespace stringify {
    const char* E_SgOmpUniformClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpUniformClause_variables";
            default: return "";
        }
    }

    std::string E_SgOmpUniformClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpUniformClause(i);
        if (s.empty())
            s = "(E_SgOmpUniformClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpUniformClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpUniformClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpUniformClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpUniformClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpUniformClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpUniformClause() {
        return stringify::E_SgOmpUniformClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 345
namespace stringify {
    const char* E_SgOmpAlignedClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpAlignedClause_variables";
            case 1L: return "SgOmpAlignedClause_alignment";
            default: return "";
        }
    }

    std::string E_SgOmpAlignedClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpAlignedClause(i);
        if (s.empty())
            s = "(E_SgOmpAlignedClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpAlignedClause() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpAlignedClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpAlignedClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpAlignedClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpAlignedClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpAlignedClause() {
        return stringify::E_SgOmpAlignedClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 348
namespace stringify {
    const char* E_SgOmpLinearClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpLinearClause_variables";
            case 1L: return "SgOmpLinearClause_step";
            default: return "";
        }
    }

    std::string E_SgOmpLinearClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpLinearClause(i);
        if (s.empty())
            s = "(E_SgOmpLinearClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpLinearClause() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpLinearClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpLinearClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpLinearClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpLinearClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpLinearClause() {
        return stringify::E_SgOmpLinearClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 351
namespace stringify {
    const char* E_SgOmpDependClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpDependClause_variables";
            default: return "";
        }
    }

    std::string E_SgOmpDependClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpDependClause(i);
        if (s.empty())
            s = "(E_SgOmpDependClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpDependClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpDependClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpDependClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpDependClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpDependClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpDependClause() {
        return stringify::E_SgOmpDependClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 354
namespace stringify {
    const char* E_SgOmpVariablesClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpVariablesClause_variables";
            default: return "";
        }
    }

    std::string E_SgOmpVariablesClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpVariablesClause(i);
        if (s.empty())
            s = "(E_SgOmpVariablesClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpVariablesClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpVariablesClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpVariablesClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpVariablesClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpVariablesClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpVariablesClause() {
        return stringify::E_SgOmpVariablesClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 357
namespace stringify {
    const char* E_SgOmpScheduleClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpScheduleClause_chunk_size";
            default: return "";
        }
    }

    std::string E_SgOmpScheduleClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpScheduleClause(i);
        if (s.empty())
            s = "(E_SgOmpScheduleClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpScheduleClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpScheduleClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpScheduleClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpScheduleClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpScheduleClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpScheduleClause() {
        return stringify::E_SgOmpScheduleClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 360
namespace stringify {
    const char* E_SgOmpWhenClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpWhenClause_user_condition";
            case 1L: return "SgOmpWhenClause_user_condition_score";
            case 2L: return "SgOmpWhenClause_device_arch";
            case 3L: return "SgOmpWhenClause_device_isa";
            case 4L: return "SgOmpWhenClause_implementation_user_defined";
            case 5L: return "SgOmpWhenClause_implementation_extension";
            case 6L: return "SgOmpWhenClause_variant_directive";
            default: return "";
        }
    }

    std::string E_SgOmpWhenClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpWhenClause(i);
        if (s.empty())
            s = "(E_SgOmpWhenClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpWhenClause() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpWhenClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpWhenClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpWhenClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpWhenClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpWhenClause() {
        return stringify::E_SgOmpWhenClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 363
namespace stringify {
    const char* E_SgUntypedUnaryOperator(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedUnaryOperator_operand";
            default: return "";
        }
    }

    std::string E_SgUntypedUnaryOperator(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedUnaryOperator(i);
        if (s.empty())
            s = "(E_SgUntypedUnaryOperator)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedUnaryOperator() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedUnaryOperator(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedUnaryOperator(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedUnaryOperator)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedUnaryOperator::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedUnaryOperator() {
        return stringify::E_SgUntypedUnaryOperator();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 366
namespace stringify {
    const char* E_SgUntypedBinaryOperator(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedBinaryOperator_lhs_operand";
            case 1L: return "SgUntypedBinaryOperator_rhs_operand";
            default: return "";
        }
    }

    std::string E_SgUntypedBinaryOperator(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedBinaryOperator(i);
        if (s.empty())
            s = "(E_SgUntypedBinaryOperator)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedBinaryOperator() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedBinaryOperator(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedBinaryOperator(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedBinaryOperator)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedBinaryOperator::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedBinaryOperator() {
        return stringify::E_SgUntypedBinaryOperator();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 369
namespace stringify {
    const char* E_SgUntypedExprListExpression(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedExprListExpression_expressions";
            default: return "";
        }
    }

    std::string E_SgUntypedExprListExpression(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedExprListExpression(i);
        if (s.empty())
            s = "(E_SgUntypedExprListExpression)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedExprListExpression() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedExprListExpression(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedExprListExpression(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedExprListExpression)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedExprListExpression::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedExprListExpression() {
        return stringify::E_SgUntypedExprListExpression();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 372
namespace stringify {
    const char* E_SgUntypedArrayReferenceExpression(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedArrayReferenceExpression_array_subscripts";
            case 1L: return "SgUntypedArrayReferenceExpression_coarray_subscripts";
            default: return "";
        }
    }

    std::string E_SgUntypedArrayReferenceExpression(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedArrayReferenceExpression(i);
        if (s.empty())
            s = "(E_SgUntypedArrayReferenceExpression)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedArrayReferenceExpression() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedArrayReferenceExpression(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedArrayReferenceExpression(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedArrayReferenceExpression)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedArrayReferenceExpression::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedArrayReferenceExpression() {
        return stringify::E_SgUntypedArrayReferenceExpression();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 375
namespace stringify {
    const char* E_SgUntypedSubscriptExpression(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedSubscriptExpression_lower_bound";
            case 1L: return "SgUntypedSubscriptExpression_upper_bound";
            case 2L: return "SgUntypedSubscriptExpression_stride";
            default: return "";
        }
    }

    std::string E_SgUntypedSubscriptExpression(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedSubscriptExpression(i);
        if (s.empty())
            s = "(E_SgUntypedSubscriptExpression)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedSubscriptExpression() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedSubscriptExpression(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedSubscriptExpression(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedSubscriptExpression)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedSubscriptExpression::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedSubscriptExpression() {
        return stringify::E_SgUntypedSubscriptExpression();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 378
namespace stringify {
    const char* E_SgUntypedNamedExpression(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedNamedExpression_expression";
            default: return "";
        }
    }

    std::string E_SgUntypedNamedExpression(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedNamedExpression(i);
        if (s.empty())
            s = "(E_SgUntypedNamedExpression)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedNamedExpression() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedNamedExpression(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedNamedExpression(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedNamedExpression)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedNamedExpression::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedNamedExpression() {
        return stringify::E_SgUntypedNamedExpression();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 381
namespace stringify {
    const char* E_SgUntypedNameListDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedNameListDeclaration_names";
            default: return "";
        }
    }

    std::string E_SgUntypedNameListDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedNameListDeclaration(i);
        if (s.empty())
            s = "(E_SgUntypedNameListDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedNameListDeclaration() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedNameListDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedNameListDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedNameListDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedNameListDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedNameListDeclaration() {
        return stringify::E_SgUntypedNameListDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 384
namespace stringify {
    const char* E_SgUntypedUseStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedUseStatement_rename_list";
            default: return "";
        }
    }

    std::string E_SgUntypedUseStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedUseStatement(i);
        if (s.empty())
            s = "(E_SgUntypedUseStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedUseStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedUseStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedUseStatement(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedUseStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedUseStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedUseStatement() {
        return stringify::E_SgUntypedUseStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 387
namespace stringify {
    const char* E_SgUntypedVariableDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedVariableDeclaration_base_type_declaration";
            case 1L: return "SgUntypedVariableDeclaration_variables";
            default: return "";
        }
    }

    std::string E_SgUntypedVariableDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedVariableDeclaration(i);
        if (s.empty())
            s = "(E_SgUntypedVariableDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedVariableDeclaration() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedVariableDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedVariableDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedVariableDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedVariableDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedVariableDeclaration() {
        return stringify::E_SgUntypedVariableDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 390
namespace stringify {
    const char* E_SgUntypedProgramHeaderDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedProgramHeaderDeclaration_parameters";
            case 1L: return "SgUntypedProgramHeaderDeclaration_scope";
            case 2L: return "SgUntypedProgramHeaderDeclaration_modifiers";
            case 3L: return "SgUntypedProgramHeaderDeclaration_end_statement";
            default: return "";
        }
    }

    std::string E_SgUntypedProgramHeaderDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedProgramHeaderDeclaration(i);
        if (s.empty())
            s = "(E_SgUntypedProgramHeaderDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedProgramHeaderDeclaration() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedProgramHeaderDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedProgramHeaderDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedProgramHeaderDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedProgramHeaderDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedProgramHeaderDeclaration() {
        return stringify::E_SgUntypedProgramHeaderDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 393
namespace stringify {
    const char* E_SgUntypedSubroutineDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedSubroutineDeclaration_parameters";
            case 1L: return "SgUntypedSubroutineDeclaration_scope";
            case 2L: return "SgUntypedSubroutineDeclaration_modifiers";
            case 3L: return "SgUntypedSubroutineDeclaration_end_statement";
            default: return "";
        }
    }

    std::string E_SgUntypedSubroutineDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedSubroutineDeclaration(i);
        if (s.empty())
            s = "(E_SgUntypedSubroutineDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedSubroutineDeclaration() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedSubroutineDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedSubroutineDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedSubroutineDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedSubroutineDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedSubroutineDeclaration() {
        return stringify::E_SgUntypedSubroutineDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 396
namespace stringify {
    const char* E_SgUntypedInterfaceDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedInterfaceDeclaration_parameters";
            case 1L: return "SgUntypedInterfaceDeclaration_scope";
            case 2L: return "SgUntypedInterfaceDeclaration_modifiers";
            case 3L: return "SgUntypedInterfaceDeclaration_end_statement";
            default: return "";
        }
    }

    std::string E_SgUntypedInterfaceDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedInterfaceDeclaration(i);
        if (s.empty())
            s = "(E_SgUntypedInterfaceDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedInterfaceDeclaration() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedInterfaceDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedInterfaceDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedInterfaceDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedInterfaceDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedInterfaceDeclaration() {
        return stringify::E_SgUntypedInterfaceDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 399
namespace stringify {
    const char* E_SgUntypedFunctionDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedFunctionDeclaration_parameters";
            case 1L: return "SgUntypedFunctionDeclaration_scope";
            case 2L: return "SgUntypedFunctionDeclaration_modifiers";
            case 3L: return "SgUntypedFunctionDeclaration_end_statement";
            default: return "";
        }
    }

    std::string E_SgUntypedFunctionDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedFunctionDeclaration(i);
        if (s.empty())
            s = "(E_SgUntypedFunctionDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedFunctionDeclaration() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedFunctionDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedFunctionDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedFunctionDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedFunctionDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedFunctionDeclaration() {
        return stringify::E_SgUntypedFunctionDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 402
namespace stringify {
    const char* E_SgUntypedModuleDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedModuleDeclaration_scope";
            case 1L: return "SgUntypedModuleDeclaration_end_statement";
            default: return "";
        }
    }

    std::string E_SgUntypedModuleDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedModuleDeclaration(i);
        if (s.empty())
            s = "(E_SgUntypedModuleDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedModuleDeclaration() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedModuleDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedModuleDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedModuleDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedModuleDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedModuleDeclaration() {
        return stringify::E_SgUntypedModuleDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 405
namespace stringify {
    const char* E_SgUntypedSubmoduleDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedSubmoduleDeclaration_scope";
            case 1L: return "SgUntypedSubmoduleDeclaration_end_statement";
            default: return "";
        }
    }

    std::string E_SgUntypedSubmoduleDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedSubmoduleDeclaration(i);
        if (s.empty())
            s = "(E_SgUntypedSubmoduleDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedSubmoduleDeclaration() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedSubmoduleDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedSubmoduleDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedSubmoduleDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedSubmoduleDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedSubmoduleDeclaration() {
        return stringify::E_SgUntypedSubmoduleDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 408
namespace stringify {
    const char* E_SgUntypedBlockDataDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedBlockDataDeclaration_declaration_list";
            case 1L: return "SgUntypedBlockDataDeclaration_end_statement";
            default: return "";
        }
    }

    std::string E_SgUntypedBlockDataDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedBlockDataDeclaration(i);
        if (s.empty())
            s = "(E_SgUntypedBlockDataDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedBlockDataDeclaration() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedBlockDataDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedBlockDataDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedBlockDataDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedBlockDataDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedBlockDataDeclaration() {
        return stringify::E_SgUntypedBlockDataDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 411
namespace stringify {
    const char* E_SgUntypedPackageDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedPackageDeclaration_scope";
            default: return "";
        }
    }

    std::string E_SgUntypedPackageDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedPackageDeclaration(i);
        if (s.empty())
            s = "(E_SgUntypedPackageDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedPackageDeclaration() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedPackageDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedPackageDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedPackageDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedPackageDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedPackageDeclaration() {
        return stringify::E_SgUntypedPackageDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 414
namespace stringify {
    const char* E_SgUntypedStructureDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedStructureDeclaration_definition";
            default: return "";
        }
    }

    std::string E_SgUntypedStructureDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedStructureDeclaration(i);
        if (s.empty())
            s = "(E_SgUntypedStructureDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedStructureDeclaration() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedStructureDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedStructureDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedStructureDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedStructureDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedStructureDeclaration() {
        return stringify::E_SgUntypedStructureDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 417
namespace stringify {
    const char* E_SgUntypedExceptionHandlerDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedExceptionHandlerDeclaration_statement";
            default: return "";
        }
    }

    std::string E_SgUntypedExceptionHandlerDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedExceptionHandlerDeclaration(i);
        if (s.empty())
            s = "(E_SgUntypedExceptionHandlerDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedExceptionHandlerDeclaration() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedExceptionHandlerDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedExceptionHandlerDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedExceptionHandlerDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedExceptionHandlerDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedExceptionHandlerDeclaration() {
        return stringify::E_SgUntypedExceptionHandlerDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 420
namespace stringify {
    const char* E_SgUntypedExceptionDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedExceptionDeclaration_statement";
            default: return "";
        }
    }

    std::string E_SgUntypedExceptionDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedExceptionDeclaration(i);
        if (s.empty())
            s = "(E_SgUntypedExceptionDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedExceptionDeclaration() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedExceptionDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedExceptionDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedExceptionDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedExceptionDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedExceptionDeclaration() {
        return stringify::E_SgUntypedExceptionDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 423
namespace stringify {
    const char* E_SgUntypedTaskDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedTaskDeclaration_scope";
            default: return "";
        }
    }

    std::string E_SgUntypedTaskDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedTaskDeclaration(i);
        if (s.empty())
            s = "(E_SgUntypedTaskDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedTaskDeclaration() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedTaskDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedTaskDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedTaskDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedTaskDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedTaskDeclaration() {
        return stringify::E_SgUntypedTaskDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 426
namespace stringify {
    const char* E_SgUntypedUnitDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedUnitDeclaration_scope";
            default: return "";
        }
    }

    std::string E_SgUntypedUnitDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedUnitDeclaration(i);
        if (s.empty())
            s = "(E_SgUntypedUnitDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedUnitDeclaration() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedUnitDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedUnitDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedUnitDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedUnitDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedUnitDeclaration() {
        return stringify::E_SgUntypedUnitDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 429
namespace stringify {
    const char* E_SgUntypedEnumDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedEnumDeclaration_enumerators";
            default: return "";
        }
    }

    std::string E_SgUntypedEnumDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedEnumDeclaration(i);
        if (s.empty())
            s = "(E_SgUntypedEnumDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedEnumDeclaration() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedEnumDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedEnumDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedEnumDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedEnumDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedEnumDeclaration() {
        return stringify::E_SgUntypedEnumDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 432
namespace stringify {
    const char* E_SgUntypedInitializedNameListDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedInitializedNameListDeclaration_variables";
            default: return "";
        }
    }

    std::string E_SgUntypedInitializedNameListDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedInitializedNameListDeclaration(i);
        if (s.empty())
            s = "(E_SgUntypedInitializedNameListDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedInitializedNameListDeclaration() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedInitializedNameListDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedInitializedNameListDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedInitializedNameListDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedInitializedNameListDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedInitializedNameListDeclaration() {
        return stringify::E_SgUntypedInitializedNameListDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 435
namespace stringify {
    const char* E_SgUntypedAssignmentStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedAssignmentStatement_lhs_operand";
            case 1L: return "SgUntypedAssignmentStatement_rhs_operand";
            default: return "";
        }
    }

    std::string E_SgUntypedAssignmentStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedAssignmentStatement(i);
        if (s.empty())
            s = "(E_SgUntypedAssignmentStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedAssignmentStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedAssignmentStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedAssignmentStatement(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedAssignmentStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedAssignmentStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedAssignmentStatement() {
        return stringify::E_SgUntypedAssignmentStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 438
namespace stringify {
    const char* E_SgUntypedBlockStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedBlockStatement_scope";
            default: return "";
        }
    }

    std::string E_SgUntypedBlockStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedBlockStatement(i);
        if (s.empty())
            s = "(E_SgUntypedBlockStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedBlockStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedBlockStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedBlockStatement(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedBlockStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedBlockStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedBlockStatement() {
        return stringify::E_SgUntypedBlockStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 441
namespace stringify {
    const char* E_SgUntypedExpressionStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedExpressionStatement_statement_expression";
            default: return "";
        }
    }

    std::string E_SgUntypedExpressionStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedExpressionStatement(i);
        if (s.empty())
            s = "(E_SgUntypedExpressionStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedExpressionStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedExpressionStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedExpressionStatement(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedExpressionStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedExpressionStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedExpressionStatement() {
        return stringify::E_SgUntypedExpressionStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 444
namespace stringify {
    const char* E_SgUntypedFunctionCallStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedFunctionCallStatement_function";
            case 1L: return "SgUntypedFunctionCallStatement_args";
            default: return "";
        }
    }

    std::string E_SgUntypedFunctionCallStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedFunctionCallStatement(i);
        if (s.empty())
            s = "(E_SgUntypedFunctionCallStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedFunctionCallStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedFunctionCallStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedFunctionCallStatement(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedFunctionCallStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedFunctionCallStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedFunctionCallStatement() {
        return stringify::E_SgUntypedFunctionCallStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 447
namespace stringify {
    const char* E_SgUntypedImageControlStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedImageControlStatement_variable";
            case 1L: return "SgUntypedImageControlStatement_expression";
            case 2L: return "SgUntypedImageControlStatement_status_list";
            default: return "";
        }
    }

    std::string E_SgUntypedImageControlStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedImageControlStatement(i);
        if (s.empty())
            s = "(E_SgUntypedImageControlStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedImageControlStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedImageControlStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedImageControlStatement(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedImageControlStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedImageControlStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedImageControlStatement() {
        return stringify::E_SgUntypedImageControlStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 450
namespace stringify {
    const char* E_SgUntypedFunctionScope(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedFunctionScope_declaration_list";
            case 1L: return "SgUntypedFunctionScope_statement_list";
            case 2L: return "SgUntypedFunctionScope_function_list";
            default: return "";
        }
    }

    std::string E_SgUntypedFunctionScope(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedFunctionScope(i);
        if (s.empty())
            s = "(E_SgUntypedFunctionScope)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedFunctionScope() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedFunctionScope(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedFunctionScope(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedFunctionScope)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedFunctionScope::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedFunctionScope() {
        return stringify::E_SgUntypedFunctionScope();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 453
namespace stringify {
    const char* E_SgUntypedModuleScope(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedModuleScope_declaration_list";
            case 1L: return "SgUntypedModuleScope_statement_list";
            case 2L: return "SgUntypedModuleScope_function_list";
            default: return "";
        }
    }

    std::string E_SgUntypedModuleScope(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedModuleScope(i);
        if (s.empty())
            s = "(E_SgUntypedModuleScope)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedModuleScope() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedModuleScope(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedModuleScope(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedModuleScope)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedModuleScope::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedModuleScope() {
        return stringify::E_SgUntypedModuleScope();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 456
namespace stringify {
    const char* E_SgUntypedGlobalScope(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedGlobalScope_declaration_list";
            case 1L: return "SgUntypedGlobalScope_statement_list";
            case 2L: return "SgUntypedGlobalScope_function_list";
            default: return "";
        }
    }

    std::string E_SgUntypedGlobalScope(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedGlobalScope(i);
        if (s.empty())
            s = "(E_SgUntypedGlobalScope)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedGlobalScope() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedGlobalScope(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedGlobalScope(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedGlobalScope)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedGlobalScope::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedGlobalScope() {
        return stringify::E_SgUntypedGlobalScope();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 459
namespace stringify {
    const char* E_SgUntypedStructureDefinition(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedStructureDefinition_declaration_list";
            case 1L: return "SgUntypedStructureDefinition_statement_list";
            case 2L: return "SgUntypedStructureDefinition_function_list";
            case 3L: return "SgUntypedStructureDefinition_scope";
            default: return "";
        }
    }

    std::string E_SgUntypedStructureDefinition(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedStructureDefinition(i);
        if (s.empty())
            s = "(E_SgUntypedStructureDefinition)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedStructureDefinition() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedStructureDefinition(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedStructureDefinition(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedStructureDefinition)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedStructureDefinition::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedStructureDefinition() {
        return stringify::E_SgUntypedStructureDefinition();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 462
namespace stringify {
    const char* E_SgUntypedScope(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedScope_declaration_list";
            case 1L: return "SgUntypedScope_statement_list";
            case 2L: return "SgUntypedScope_function_list";
            default: return "";
        }
    }

    std::string E_SgUntypedScope(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedScope(i);
        if (s.empty())
            s = "(E_SgUntypedScope)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedScope() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedScope(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedScope(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedScope)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedScope::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedScope() {
        return stringify::E_SgUntypedScope();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 465
namespace stringify {
    const char* E_SgUntypedIfStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedIfStatement_conditional";
            case 1L: return "SgUntypedIfStatement_true_body";
            case 2L: return "SgUntypedIfStatement_false_body";
            default: return "";
        }
    }

    std::string E_SgUntypedIfStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedIfStatement(i);
        if (s.empty())
            s = "(E_SgUntypedIfStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedIfStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedIfStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedIfStatement(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedIfStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedIfStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedIfStatement() {
        return stringify::E_SgUntypedIfStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 468
namespace stringify {
    const char* E_SgUntypedCaseStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedCaseStatement_expression";
            case 1L: return "SgUntypedCaseStatement_body";
            default: return "";
        }
    }

    std::string E_SgUntypedCaseStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedCaseStatement(i);
        if (s.empty())
            s = "(E_SgUntypedCaseStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedCaseStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedCaseStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedCaseStatement(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedCaseStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedCaseStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedCaseStatement() {
        return stringify::E_SgUntypedCaseStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 471
namespace stringify {
    const char* E_SgUntypedLabelStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedLabelStatement_statement";
            default: return "";
        }
    }

    std::string E_SgUntypedLabelStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedLabelStatement(i);
        if (s.empty())
            s = "(E_SgUntypedLabelStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedLabelStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedLabelStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedLabelStatement(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedLabelStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedLabelStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedLabelStatement() {
        return stringify::E_SgUntypedLabelStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 474
namespace stringify {
    const char* E_SgUntypedWhileStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedWhileStatement_condition";
            case 1L: return "SgUntypedWhileStatement_body";
            default: return "";
        }
    }

    std::string E_SgUntypedWhileStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedWhileStatement(i);
        if (s.empty())
            s = "(E_SgUntypedWhileStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedWhileStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedWhileStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedWhileStatement(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedWhileStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedWhileStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedWhileStatement() {
        return stringify::E_SgUntypedWhileStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 477
namespace stringify {
    const char* E_SgUntypedForStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedForStatement_initialization";
            case 1L: return "SgUntypedForStatement_bound";
            case 2L: return "SgUntypedForStatement_increment";
            case 3L: return "SgUntypedForStatement_body";
            default: return "";
        }
    }

    std::string E_SgUntypedForStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedForStatement(i);
        if (s.empty())
            s = "(E_SgUntypedForStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedForStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedForStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedForStatement(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedForStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedForStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedForStatement() {
        return stringify::E_SgUntypedForStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 480
namespace stringify {
    const char* E_SgUntypedReturnStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedReturnStatement_expression";
            default: return "";
        }
    }

    std::string E_SgUntypedReturnStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedReturnStatement(i);
        if (s.empty())
            s = "(E_SgUntypedReturnStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedReturnStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedReturnStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedReturnStatement(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedReturnStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedReturnStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedReturnStatement() {
        return stringify::E_SgUntypedReturnStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 483
namespace stringify {
    const char* E_SgUntypedStopStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedStopStatement_expression";
            default: return "";
        }
    }

    std::string E_SgUntypedStopStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedStopStatement(i);
        if (s.empty())
            s = "(E_SgUntypedStopStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedStopStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedStopStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedStopStatement(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedStopStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedStopStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedStopStatement() {
        return stringify::E_SgUntypedStopStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 486
namespace stringify {
    const char* E_SgUntypedForAllStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedForAllStatement_iterates";
            case 1L: return "SgUntypedForAllStatement_local";
            case 2L: return "SgUntypedForAllStatement_mask";
            default: return "";
        }
    }

    std::string E_SgUntypedForAllStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedForAllStatement(i);
        if (s.empty())
            s = "(E_SgUntypedForAllStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedForAllStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedForAllStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedForAllStatement(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedForAllStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedForAllStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedForAllStatement() {
        return stringify::E_SgUntypedForAllStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 489
namespace stringify {
    const char* E_SgUntypedArrayType(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedArrayType_type_kind";
            case 1L: return "SgUntypedArrayType_modifiers";
            case 2L: return "SgUntypedArrayType_dim_info";
            default: return "";
        }
    }

    std::string E_SgUntypedArrayType(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedArrayType(i);
        if (s.empty())
            s = "(E_SgUntypedArrayType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedArrayType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedArrayType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedArrayType(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedArrayType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedArrayType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedArrayType() {
        return stringify::E_SgUntypedArrayType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 492
namespace stringify {
    const char* E_SgUntypedTableType(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedTableType_type_kind";
            case 1L: return "SgUntypedTableType_modifiers";
            case 2L: return "SgUntypedTableType_dim_info";
            default: return "";
        }
    }

    std::string E_SgUntypedTableType(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedTableType(i);
        if (s.empty())
            s = "(E_SgUntypedTableType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedTableType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedTableType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedTableType(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedTableType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedTableType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedTableType() {
        return stringify::E_SgUntypedTableType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 495
namespace stringify {
    const char* E_SgUntypedType(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedType_type_kind";
            case 1L: return "SgUntypedType_modifiers";
            default: return "";
        }
    }

    std::string E_SgUntypedType(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedType(i);
        if (s.empty())
            s = "(E_SgUntypedType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedType() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedType(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedType() {
        return stringify::E_SgUntypedType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 498
namespace stringify {
    const char* E_SgUntypedFile(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedFile_scope";
            default: return "";
        }
    }

    std::string E_SgUntypedFile(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedFile(i);
        if (s.empty())
            s = "(E_SgUntypedFile)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedFile() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedFile(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedFile(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedFile)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedFile::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedFile() {
        return stringify::E_SgUntypedFile();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 501
namespace stringify {
    const char* E_SgUntypedStatementList(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedStatementList_stmt_list";
            default: return "";
        }
    }

    std::string E_SgUntypedStatementList(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedStatementList(i);
        if (s.empty())
            s = "(E_SgUntypedStatementList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedStatementList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedStatementList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedStatementList(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedStatementList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedStatementList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedStatementList() {
        return stringify::E_SgUntypedStatementList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 504
namespace stringify {
    const char* E_SgUntypedDeclarationStatementList(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedDeclarationStatementList_decl_list";
            default: return "";
        }
    }

    std::string E_SgUntypedDeclarationStatementList(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedDeclarationStatementList(i);
        if (s.empty())
            s = "(E_SgUntypedDeclarationStatementList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedDeclarationStatementList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedDeclarationStatementList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedDeclarationStatementList(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedDeclarationStatementList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedDeclarationStatementList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedDeclarationStatementList() {
        return stringify::E_SgUntypedDeclarationStatementList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 507
namespace stringify {
    const char* E_SgUntypedFunctionDeclarationList(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedFunctionDeclarationList_func_list";
            default: return "";
        }
    }

    std::string E_SgUntypedFunctionDeclarationList(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedFunctionDeclarationList(i);
        if (s.empty())
            s = "(E_SgUntypedFunctionDeclarationList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedFunctionDeclarationList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedFunctionDeclarationList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedFunctionDeclarationList(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedFunctionDeclarationList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedFunctionDeclarationList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedFunctionDeclarationList() {
        return stringify::E_SgUntypedFunctionDeclarationList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 510
namespace stringify {
    const char* E_SgUntypedInitializedNameList(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedInitializedNameList_name_list";
            default: return "";
        }
    }

    std::string E_SgUntypedInitializedNameList(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedInitializedNameList(i);
        if (s.empty())
            s = "(E_SgUntypedInitializedNameList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedInitializedNameList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedInitializedNameList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedInitializedNameList(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedInitializedNameList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedInitializedNameList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedInitializedNameList() {
        return stringify::E_SgUntypedInitializedNameList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 513
namespace stringify {
    const char* E_SgUntypedNameList(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedNameList_name_list";
            default: return "";
        }
    }

    std::string E_SgUntypedNameList(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedNameList(i);
        if (s.empty())
            s = "(E_SgUntypedNameList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedNameList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedNameList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedNameList(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedNameList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedNameList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedNameList() {
        return stringify::E_SgUntypedNameList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 516
namespace stringify {
    const char* E_SgUntypedTokenList(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedTokenList_token_list";
            default: return "";
        }
    }

    std::string E_SgUntypedTokenList(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedTokenList(i);
        if (s.empty())
            s = "(E_SgUntypedTokenList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedTokenList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedTokenList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedTokenList(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedTokenList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedTokenList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedTokenList() {
        return stringify::E_SgUntypedTokenList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 519
namespace stringify {
    const char* E_SgUntypedTokenPairList(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedTokenPairList_token_pair_list";
            default: return "";
        }
    }

    std::string E_SgUntypedTokenPairList(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedTokenPairList(i);
        if (s.empty())
            s = "(E_SgUntypedTokenPairList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedTokenPairList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedTokenPairList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedTokenPairList(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedTokenPairList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedTokenPairList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedTokenPairList() {
        return stringify::E_SgUntypedTokenPairList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 522
namespace stringify {
    const char* E_SgLambdaCapture(int64_t i) {
        switch (i) {
            case 0L: return "SgLambdaCapture_capture_variable";
            case 1L: return "SgLambdaCapture_source_closure_variable";
            case 2L: return "SgLambdaCapture_closure_variable";
            default: return "";
        }
    }

    std::string E_SgLambdaCapture(int64_t i, const std::string &strip) {
        std::string s = E_SgLambdaCapture(i);
        if (s.empty())
            s = "(E_SgLambdaCapture)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgLambdaCapture() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgLambdaCapture(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgLambdaCapture(i);
        if (retval.empty()) {
            retval = "(E_SgLambdaCapture)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgLambdaCapture::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgLambdaCapture() {
        return stringify::E_SgLambdaCapture();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 525
namespace stringify {
    const char* E_SgLambdaCaptureList(int64_t i) {
        switch (i) {
            case 0L: return "SgLambdaCaptureList_capture_list";
            default: return "";
        }
    }

    std::string E_SgLambdaCaptureList(int64_t i, const std::string &strip) {
        std::string s = E_SgLambdaCaptureList(i);
        if (s.empty())
            s = "(E_SgLambdaCaptureList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgLambdaCaptureList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgLambdaCaptureList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgLambdaCaptureList(i);
        if (retval.empty()) {
            retval = "(E_SgLambdaCaptureList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgLambdaCaptureList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgLambdaCaptureList() {
        return stringify::E_SgLambdaCaptureList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 528
namespace stringify {
    const char* E_SgGlobal(int64_t i) {
        switch (i) {
            case 0L: return "SgGlobal_declarations";
            default: return "";
        }
    }

    std::string E_SgGlobal(int64_t i, const std::string &strip) {
        std::string s = E_SgGlobal(i);
        if (s.empty())
            s = "(E_SgGlobal)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgGlobal() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgGlobal(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgGlobal(i);
        if (retval.empty()) {
            retval = "(E_SgGlobal)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgGlobal::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgGlobal() {
        return stringify::E_SgGlobal();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 531
namespace stringify {
    const char* E_SgBasicBlock(int64_t i) {
        switch (i) {
            case 0L: return "SgBasicBlock_statements";
            default: return "";
        }
    }

    std::string E_SgBasicBlock(int64_t i, const std::string &strip) {
        std::string s = E_SgBasicBlock(i);
        if (s.empty())
            s = "(E_SgBasicBlock)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgBasicBlock() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgBasicBlock(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgBasicBlock(i);
        if (retval.empty()) {
            retval = "(E_SgBasicBlock)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgBasicBlock::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgBasicBlock() {
        return stringify::E_SgBasicBlock();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 534
namespace stringify {
    const char* E_SgIfStmt(int64_t i) {
        switch (i) {
            case 0L: return "SgIfStmt_conditional";
            case 1L: return "SgIfStmt_true_body";
            case 2L: return "SgIfStmt_false_body";
            default: return "";
        }
    }

    std::string E_SgIfStmt(int64_t i, const std::string &strip) {
        std::string s = E_SgIfStmt(i);
        if (s.empty())
            s = "(E_SgIfStmt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgIfStmt() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgIfStmt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgIfStmt(i);
        if (retval.empty()) {
            retval = "(E_SgIfStmt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgIfStmt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgIfStmt() {
        return stringify::E_SgIfStmt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 537
namespace stringify {
    const char* E_SgForStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgForStatement_for_init_stmt";
            case 1L: return "SgForStatement_test";
            case 2L: return "SgForStatement_increment";
            case 3L: return "SgForStatement_loop_body";
            case 4L: return "SgForStatement_else_body";
            default: return "";
        }
    }

    std::string E_SgForStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgForStatement(i);
        if (s.empty())
            s = "(E_SgForStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgForStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgForStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgForStatement(i);
        if (retval.empty()) {
            retval = "(E_SgForStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgForStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgForStatement() {
        return stringify::E_SgForStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 540
namespace stringify {
    const char* E_SgTemplateFunctionDefinition(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateFunctionDefinition_body";
            default: return "";
        }
    }

    std::string E_SgTemplateFunctionDefinition(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateFunctionDefinition(i);
        if (s.empty())
            s = "(E_SgTemplateFunctionDefinition)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateFunctionDefinition() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateFunctionDefinition(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateFunctionDefinition(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateFunctionDefinition)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateFunctionDefinition::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateFunctionDefinition() {
        return stringify::E_SgTemplateFunctionDefinition();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 543
namespace stringify {
    const char* E_SgFunctionDefinition(int64_t i) {
        switch (i) {
            case 0L: return "SgFunctionDefinition_body";
            default: return "";
        }
    }

    std::string E_SgFunctionDefinition(int64_t i, const std::string &strip) {
        std::string s = E_SgFunctionDefinition(i);
        if (s.empty())
            s = "(E_SgFunctionDefinition)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgFunctionDefinition() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgFunctionDefinition(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgFunctionDefinition(i);
        if (retval.empty()) {
            retval = "(E_SgFunctionDefinition)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgFunctionDefinition::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgFunctionDefinition() {
        return stringify::E_SgFunctionDefinition();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 546
namespace stringify {
    const char* E_SgTemplateInstantiationDefn(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateInstantiationDefn_members";
            default: return "";
        }
    }

    std::string E_SgTemplateInstantiationDefn(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateInstantiationDefn(i);
        if (s.empty())
            s = "(E_SgTemplateInstantiationDefn)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateInstantiationDefn() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateInstantiationDefn(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateInstantiationDefn(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateInstantiationDefn)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateInstantiationDefn::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateInstantiationDefn() {
        return stringify::E_SgTemplateInstantiationDefn();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 549
namespace stringify {
    const char* E_SgTemplateClassDefinition(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateClassDefinition_members";
            default: return "";
        }
    }

    std::string E_SgTemplateClassDefinition(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateClassDefinition(i);
        if (s.empty())
            s = "(E_SgTemplateClassDefinition)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateClassDefinition() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateClassDefinition(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateClassDefinition(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateClassDefinition)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateClassDefinition::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateClassDefinition() {
        return stringify::E_SgTemplateClassDefinition();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 552
namespace stringify {
    const char* E_SgClassDefinition(int64_t i) {
        switch (i) {
            case 0L: return "SgClassDefinition_members";
            default: return "";
        }
    }

    std::string E_SgClassDefinition(int64_t i, const std::string &strip) {
        std::string s = E_SgClassDefinition(i);
        if (s.empty())
            s = "(E_SgClassDefinition)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgClassDefinition() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgClassDefinition(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgClassDefinition(i);
        if (retval.empty()) {
            retval = "(E_SgClassDefinition)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgClassDefinition::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgClassDefinition() {
        return stringify::E_SgClassDefinition();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 555
namespace stringify {
    const char* E_SgWhileStmt(int64_t i) {
        switch (i) {
            case 0L: return "SgWhileStmt_condition";
            case 1L: return "SgWhileStmt_body";
            case 2L: return "SgWhileStmt_else_body";
            default: return "";
        }
    }

    std::string E_SgWhileStmt(int64_t i, const std::string &strip) {
        std::string s = E_SgWhileStmt(i);
        if (s.empty())
            s = "(E_SgWhileStmt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgWhileStmt() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgWhileStmt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgWhileStmt(i);
        if (retval.empty()) {
            retval = "(E_SgWhileStmt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgWhileStmt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgWhileStmt() {
        return stringify::E_SgWhileStmt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 558
namespace stringify {
    const char* E_SgDoWhileStmt(int64_t i) {
        switch (i) {
            case 0L: return "SgDoWhileStmt_body";
            case 1L: return "SgDoWhileStmt_condition";
            default: return "";
        }
    }

    std::string E_SgDoWhileStmt(int64_t i, const std::string &strip) {
        std::string s = E_SgDoWhileStmt(i);
        if (s.empty())
            s = "(E_SgDoWhileStmt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgDoWhileStmt() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgDoWhileStmt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgDoWhileStmt(i);
        if (retval.empty()) {
            retval = "(E_SgDoWhileStmt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgDoWhileStmt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgDoWhileStmt() {
        return stringify::E_SgDoWhileStmt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 561
namespace stringify {
    const char* E_SgSwitchStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgSwitchStatement_item_selector";
            case 1L: return "SgSwitchStatement_body";
            default: return "";
        }
    }

    std::string E_SgSwitchStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgSwitchStatement(i);
        if (s.empty())
            s = "(E_SgSwitchStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgSwitchStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgSwitchStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgSwitchStatement(i);
        if (retval.empty()) {
            retval = "(E_SgSwitchStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgSwitchStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgSwitchStatement() {
        return stringify::E_SgSwitchStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 564
namespace stringify {
    const char* E_SgCatchOptionStmt(int64_t i) {
        switch (i) {
            case 0L: return "SgCatchOptionStmt_condition";
            case 1L: return "SgCatchOptionStmt_body";
            default: return "";
        }
    }

    std::string E_SgCatchOptionStmt(int64_t i, const std::string &strip) {
        std::string s = E_SgCatchOptionStmt(i);
        if (s.empty())
            s = "(E_SgCatchOptionStmt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgCatchOptionStmt() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgCatchOptionStmt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgCatchOptionStmt(i);
        if (retval.empty()) {
            retval = "(E_SgCatchOptionStmt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgCatchOptionStmt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgCatchOptionStmt() {
        return stringify::E_SgCatchOptionStmt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 567
namespace stringify {
    const char* E_SgNamespaceDefinitionStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgNamespaceDefinitionStatement_declarations";
            default: return "";
        }
    }

    std::string E_SgNamespaceDefinitionStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgNamespaceDefinitionStatement(i);
        if (s.empty())
            s = "(E_SgNamespaceDefinitionStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgNamespaceDefinitionStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgNamespaceDefinitionStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgNamespaceDefinitionStatement(i);
        if (retval.empty()) {
            retval = "(E_SgNamespaceDefinitionStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgNamespaceDefinitionStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgNamespaceDefinitionStatement() {
        return stringify::E_SgNamespaceDefinitionStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 570
namespace stringify {
    const char* E_SgAssociateStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgAssociateStatement_body";
            default: return "";
        }
    }

    std::string E_SgAssociateStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgAssociateStatement(i);
        if (s.empty())
            s = "(E_SgAssociateStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAssociateStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAssociateStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAssociateStatement(i);
        if (retval.empty()) {
            retval = "(E_SgAssociateStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAssociateStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAssociateStatement() {
        return stringify::E_SgAssociateStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 573
namespace stringify {
    const char* E_SgFortranNonblockedDo(int64_t i) {
        switch (i) {
            case 0L: return "SgFortranNonblockedDo_initialization";
            case 1L: return "SgFortranNonblockedDo_bound";
            case 2L: return "SgFortranNonblockedDo_increment";
            case 3L: return "SgFortranNonblockedDo_body";
            default: return "";
        }
    }

    std::string E_SgFortranNonblockedDo(int64_t i, const std::string &strip) {
        std::string s = E_SgFortranNonblockedDo(i);
        if (s.empty())
            s = "(E_SgFortranNonblockedDo)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgFortranNonblockedDo() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgFortranNonblockedDo(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgFortranNonblockedDo(i);
        if (retval.empty()) {
            retval = "(E_SgFortranNonblockedDo)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgFortranNonblockedDo::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgFortranNonblockedDo() {
        return stringify::E_SgFortranNonblockedDo();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 576
namespace stringify {
    const char* E_SgFortranDo(int64_t i) {
        switch (i) {
            case 0L: return "SgFortranDo_initialization";
            case 1L: return "SgFortranDo_bound";
            case 2L: return "SgFortranDo_increment";
            case 3L: return "SgFortranDo_body";
            default: return "";
        }
    }

    std::string E_SgFortranDo(int64_t i, const std::string &strip) {
        std::string s = E_SgFortranDo(i);
        if (s.empty())
            s = "(E_SgFortranDo)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgFortranDo() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgFortranDo(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgFortranDo(i);
        if (retval.empty()) {
            retval = "(E_SgFortranDo)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgFortranDo::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgFortranDo() {
        return stringify::E_SgFortranDo();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 579
namespace stringify {
    const char* E_SgForAllStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgForAllStatement_forall_header";
            case 1L: return "SgForAllStatement_body";
            default: return "";
        }
    }

    std::string E_SgForAllStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgForAllStatement(i);
        if (s.empty())
            s = "(E_SgForAllStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgForAllStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgForAllStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgForAllStatement(i);
        if (retval.empty()) {
            retval = "(E_SgForAllStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgForAllStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgForAllStatement() {
        return stringify::E_SgForAllStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 582
namespace stringify {
    const char* E_SgUpcForAllStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgUpcForAllStatement_for_init_stmt";
            case 1L: return "SgUpcForAllStatement_test";
            case 2L: return "SgUpcForAllStatement_increment";
            case 3L: return "SgUpcForAllStatement_affinity";
            case 4L: return "SgUpcForAllStatement_loop_body";
            default: return "";
        }
    }

    std::string E_SgUpcForAllStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgUpcForAllStatement(i);
        if (s.empty())
            s = "(E_SgUpcForAllStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUpcForAllStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUpcForAllStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUpcForAllStatement(i);
        if (retval.empty()) {
            retval = "(E_SgUpcForAllStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUpcForAllStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUpcForAllStatement() {
        return stringify::E_SgUpcForAllStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 585
namespace stringify {
    const char* E_SgCAFWithTeamStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgCAFWithTeamStatement_body";
            default: return "";
        }
    }

    std::string E_SgCAFWithTeamStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgCAFWithTeamStatement(i);
        if (s.empty())
            s = "(E_SgCAFWithTeamStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgCAFWithTeamStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgCAFWithTeamStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgCAFWithTeamStatement(i);
        if (retval.empty()) {
            retval = "(E_SgCAFWithTeamStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgCAFWithTeamStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgCAFWithTeamStatement() {
        return stringify::E_SgCAFWithTeamStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 588
namespace stringify {
    const char* E_SgFunctionParameterScope(int64_t i) {
        switch (i) {
            case 0L: return "SgFunctionParameterScope_declarations";
            default: return "";
        }
    }

    std::string E_SgFunctionParameterScope(int64_t i, const std::string &strip) {
        std::string s = E_SgFunctionParameterScope(i);
        if (s.empty())
            s = "(E_SgFunctionParameterScope)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgFunctionParameterScope() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgFunctionParameterScope(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgFunctionParameterScope(i);
        if (retval.empty()) {
            retval = "(E_SgFunctionParameterScope)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgFunctionParameterScope::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgFunctionParameterScope() {
        return stringify::E_SgFunctionParameterScope();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 591
namespace stringify {
    const char* E_SgRangeBasedForStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgRangeBasedForStatement_iterator_declaration";
            case 1L: return "SgRangeBasedForStatement_range_declaration";
            case 2L: return "SgRangeBasedForStatement_begin_declaration";
            case 3L: return "SgRangeBasedForStatement_end_declaration";
            case 4L: return "SgRangeBasedForStatement_not_equal_expression";
            case 5L: return "SgRangeBasedForStatement_increment_expression";
            case 6L: return "SgRangeBasedForStatement_loop_body";
            default: return "";
        }
    }

    std::string E_SgRangeBasedForStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgRangeBasedForStatement(i);
        if (s.empty())
            s = "(E_SgRangeBasedForStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgRangeBasedForStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgRangeBasedForStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgRangeBasedForStatement(i);
        if (retval.empty()) {
            retval = "(E_SgRangeBasedForStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgRangeBasedForStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgRangeBasedForStatement() {
        return stringify::E_SgRangeBasedForStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 594
namespace stringify {
    const char* E_SgFunctionParameterList(int64_t i) {
        switch (i) {
            case 0L: return "SgFunctionParameterList_args";
            default: return "";
        }
    }

    std::string E_SgFunctionParameterList(int64_t i, const std::string &strip) {
        std::string s = E_SgFunctionParameterList(i);
        if (s.empty())
            s = "(E_SgFunctionParameterList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgFunctionParameterList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgFunctionParameterList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgFunctionParameterList(i);
        if (retval.empty()) {
            retval = "(E_SgFunctionParameterList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgFunctionParameterList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgFunctionParameterList() {
        return stringify::E_SgFunctionParameterList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 597
namespace stringify {
    const char* E_SgTemplateVariableDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateVariableDeclaration_baseTypeDefiningDeclaration";
            case 1L: return "SgTemplateVariableDeclaration_variables";
            default: return "";
        }
    }

    std::string E_SgTemplateVariableDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateVariableDeclaration(i);
        if (s.empty())
            s = "(E_SgTemplateVariableDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateVariableDeclaration() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateVariableDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateVariableDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateVariableDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateVariableDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateVariableDeclaration() {
        return stringify::E_SgTemplateVariableDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 600
namespace stringify {
    const char* E_SgVariableDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgVariableDeclaration_baseTypeDefiningDeclaration";
            case 1L: return "SgVariableDeclaration_variables";
            default: return "";
        }
    }

    std::string E_SgVariableDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgVariableDeclaration(i);
        if (s.empty())
            s = "(E_SgVariableDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgVariableDeclaration() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgVariableDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgVariableDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgVariableDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgVariableDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgVariableDeclaration() {
        return stringify::E_SgVariableDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 603
namespace stringify {
    const char* E_SgVariableDefinition(int64_t i) {
        switch (i) {
            case 0L: return "SgVariableDefinition_vardefn";
            case 1L: return "SgVariableDefinition_bitfield";
            default: return "";
        }
    }

    std::string E_SgVariableDefinition(int64_t i, const std::string &strip) {
        std::string s = E_SgVariableDefinition(i);
        if (s.empty())
            s = "(E_SgVariableDefinition)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgVariableDefinition() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgVariableDefinition(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgVariableDefinition(i);
        if (retval.empty()) {
            retval = "(E_SgVariableDefinition)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgVariableDefinition::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgVariableDefinition() {
        return stringify::E_SgVariableDefinition();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 606
namespace stringify {
    const char* E_SgEnumDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgEnumDeclaration_enumerators";
            default: return "";
        }
    }

    std::string E_SgEnumDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgEnumDeclaration(i);
        if (s.empty())
            s = "(E_SgEnumDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgEnumDeclaration() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgEnumDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgEnumDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgEnumDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgEnumDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgEnumDeclaration() {
        return stringify::E_SgEnumDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 609
namespace stringify {
    const char* E_SgAsmStmt(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmStmt_operands";
            default: return "";
        }
    }

    std::string E_SgAsmStmt(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmStmt(i);
        if (s.empty())
            s = "(E_SgAsmStmt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmStmt() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmStmt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmStmt(i);
        if (retval.empty()) {
            retval = "(E_SgAsmStmt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmStmt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmStmt() {
        return stringify::E_SgAsmStmt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 612
namespace stringify {
    const char* E_SgTemplateInstantiationDirectiveStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateInstantiationDirectiveStatement_declaration";
            default: return "";
        }
    }

    std::string E_SgTemplateInstantiationDirectiveStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateInstantiationDirectiveStatement(i);
        if (s.empty())
            s = "(E_SgTemplateInstantiationDirectiveStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateInstantiationDirectiveStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateInstantiationDirectiveStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateInstantiationDirectiveStatement(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateInstantiationDirectiveStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateInstantiationDirectiveStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateInstantiationDirectiveStatement() {
        return stringify::E_SgTemplateInstantiationDirectiveStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 615
namespace stringify {
    const char* E_SgUseStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgUseStatement_rename_list";
            default: return "";
        }
    }

    std::string E_SgUseStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgUseStatement(i);
        if (s.empty())
            s = "(E_SgUseStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUseStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUseStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUseStatement(i);
        if (retval.empty()) {
            retval = "(E_SgUseStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUseStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUseStatement() {
        return stringify::E_SgUseStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 618
namespace stringify {
    const char* E_SgNamespaceDeclarationStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgNamespaceDeclarationStatement_definition";
            default: return "";
        }
    }

    std::string E_SgNamespaceDeclarationStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgNamespaceDeclarationStatement(i);
        if (s.empty())
            s = "(E_SgNamespaceDeclarationStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgNamespaceDeclarationStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgNamespaceDeclarationStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgNamespaceDeclarationStatement(i);
        if (retval.empty()) {
            retval = "(E_SgNamespaceDeclarationStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgNamespaceDeclarationStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgNamespaceDeclarationStatement() {
        return stringify::E_SgNamespaceDeclarationStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 621
namespace stringify {
    const char* E_SgInterfaceStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgInterfaceStatement_interface_body_list";
            default: return "";
        }
    }

    std::string E_SgInterfaceStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgInterfaceStatement(i);
        if (s.empty())
            s = "(E_SgInterfaceStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgInterfaceStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgInterfaceStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgInterfaceStatement(i);
        if (retval.empty()) {
            retval = "(E_SgInterfaceStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgInterfaceStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgInterfaceStatement() {
        return stringify::E_SgInterfaceStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 624
namespace stringify {
    const char* E_SgCommonBlock(int64_t i) {
        switch (i) {
            case 0L: return "SgCommonBlock_block_list";
            default: return "";
        }
    }

    std::string E_SgCommonBlock(int64_t i, const std::string &strip) {
        std::string s = E_SgCommonBlock(i);
        if (s.empty())
            s = "(E_SgCommonBlock)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgCommonBlock() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgCommonBlock(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgCommonBlock(i);
        if (retval.empty()) {
            retval = "(E_SgCommonBlock)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgCommonBlock::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgCommonBlock() {
        return stringify::E_SgCommonBlock();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 627
namespace stringify {
    const char* E_SgTemplateTypedefDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateTypedefDeclaration_declaration";
            default: return "";
        }
    }

    std::string E_SgTemplateTypedefDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateTypedefDeclaration(i);
        if (s.empty())
            s = "(E_SgTemplateTypedefDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateTypedefDeclaration() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateTypedefDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateTypedefDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateTypedefDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateTypedefDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateTypedefDeclaration() {
        return stringify::E_SgTemplateTypedefDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 630
namespace stringify {
    const char* E_SgTemplateInstantiationTypedefDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateInstantiationTypedefDeclaration_declaration";
            default: return "";
        }
    }

    std::string E_SgTemplateInstantiationTypedefDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateInstantiationTypedefDeclaration(i);
        if (s.empty())
            s = "(E_SgTemplateInstantiationTypedefDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateInstantiationTypedefDeclaration() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateInstantiationTypedefDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateInstantiationTypedefDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateInstantiationTypedefDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateInstantiationTypedefDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateInstantiationTypedefDeclaration() {
        return stringify::E_SgTemplateInstantiationTypedefDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 633
namespace stringify {
    const char* E_SgTypedefDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgTypedefDeclaration_declaration";
            default: return "";
        }
    }

    std::string E_SgTypedefDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgTypedefDeclaration(i);
        if (s.empty())
            s = "(E_SgTypedefDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypedefDeclaration() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypedefDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypedefDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgTypedefDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypedefDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypedefDeclaration() {
        return stringify::E_SgTypedefDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 636
namespace stringify {
    const char* E_SgStatementFunctionStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgStatementFunctionStatement_function";
            case 1L: return "SgStatementFunctionStatement_expression";
            default: return "";
        }
    }

    std::string E_SgStatementFunctionStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgStatementFunctionStatement(i);
        if (s.empty())
            s = "(E_SgStatementFunctionStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgStatementFunctionStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgStatementFunctionStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgStatementFunctionStatement(i);
        if (retval.empty()) {
            retval = "(E_SgStatementFunctionStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgStatementFunctionStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgStatementFunctionStatement() {
        return stringify::E_SgStatementFunctionStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 639
namespace stringify {
    const char* E_SgCtorInitializerList(int64_t i) {
        switch (i) {
            case 0L: return "SgCtorInitializerList_ctors";
            default: return "";
        }
    }

    std::string E_SgCtorInitializerList(int64_t i, const std::string &strip) {
        std::string s = E_SgCtorInitializerList(i);
        if (s.empty())
            s = "(E_SgCtorInitializerList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgCtorInitializerList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgCtorInitializerList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgCtorInitializerList(i);
        if (retval.empty()) {
            retval = "(E_SgCtorInitializerList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgCtorInitializerList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgCtorInitializerList() {
        return stringify::E_SgCtorInitializerList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 642
namespace stringify {
    const char* E_SgPragmaDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgPragmaDeclaration_pragma";
            default: return "";
        }
    }

    std::string E_SgPragmaDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgPragmaDeclaration(i);
        if (s.empty())
            s = "(E_SgPragmaDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgPragmaDeclaration() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgPragmaDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgPragmaDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgPragmaDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgPragmaDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgPragmaDeclaration() {
        return stringify::E_SgPragmaDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 645
namespace stringify {
    const char* E_SgTemplateClassDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateClassDeclaration_definition";
            case 1L: return "SgTemplateClassDeclaration_decoratorList";
            default: return "";
        }
    }

    std::string E_SgTemplateClassDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateClassDeclaration(i);
        if (s.empty())
            s = "(E_SgTemplateClassDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateClassDeclaration() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateClassDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateClassDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateClassDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateClassDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateClassDeclaration() {
        return stringify::E_SgTemplateClassDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 648
namespace stringify {
    const char* E_SgTemplateInstantiationDecl(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateInstantiationDecl_definition";
            case 1L: return "SgTemplateInstantiationDecl_decoratorList";
            default: return "";
        }
    }

    std::string E_SgTemplateInstantiationDecl(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateInstantiationDecl(i);
        if (s.empty())
            s = "(E_SgTemplateInstantiationDecl)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateInstantiationDecl() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateInstantiationDecl(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateInstantiationDecl(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateInstantiationDecl)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateInstantiationDecl::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateInstantiationDecl() {
        return stringify::E_SgTemplateInstantiationDecl();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 651
namespace stringify {
    const char* E_SgDerivedTypeStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgDerivedTypeStatement_definition";
            case 1L: return "SgDerivedTypeStatement_decoratorList";
            default: return "";
        }
    }

    std::string E_SgDerivedTypeStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgDerivedTypeStatement(i);
        if (s.empty())
            s = "(E_SgDerivedTypeStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgDerivedTypeStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgDerivedTypeStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgDerivedTypeStatement(i);
        if (retval.empty()) {
            retval = "(E_SgDerivedTypeStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgDerivedTypeStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgDerivedTypeStatement() {
        return stringify::E_SgDerivedTypeStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 654
namespace stringify {
    const char* E_SgModuleStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgModuleStatement_definition";
            case 1L: return "SgModuleStatement_decoratorList";
            default: return "";
        }
    }

    std::string E_SgModuleStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgModuleStatement(i);
        if (s.empty())
            s = "(E_SgModuleStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgModuleStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgModuleStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgModuleStatement(i);
        if (retval.empty()) {
            retval = "(E_SgModuleStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgModuleStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgModuleStatement() {
        return stringify::E_SgModuleStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 657
namespace stringify {
    const char* E_SgClassDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgClassDeclaration_definition";
            case 1L: return "SgClassDeclaration_decoratorList";
            default: return "";
        }
    }

    std::string E_SgClassDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgClassDeclaration(i);
        if (s.empty())
            s = "(E_SgClassDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgClassDeclaration() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgClassDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgClassDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgClassDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgClassDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgClassDeclaration() {
        return stringify::E_SgClassDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 660
namespace stringify {
    const char* E_SgImplicitStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgImplicitStatement_variables";
            default: return "";
        }
    }

    std::string E_SgImplicitStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgImplicitStatement(i);
        if (s.empty())
            s = "(E_SgImplicitStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgImplicitStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgImplicitStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgImplicitStatement(i);
        if (retval.empty()) {
            retval = "(E_SgImplicitStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgImplicitStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgImplicitStatement() {
        return stringify::E_SgImplicitStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 663
namespace stringify {
    const char* E_SgTemplateFunctionDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateFunctionDeclaration_parameterList";
            case 1L: return "SgTemplateFunctionDeclaration_decoratorList";
            case 2L: return "SgTemplateFunctionDeclaration_definition";
            default: return "";
        }
    }

    std::string E_SgTemplateFunctionDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateFunctionDeclaration(i);
        if (s.empty())
            s = "(E_SgTemplateFunctionDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateFunctionDeclaration() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateFunctionDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateFunctionDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateFunctionDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateFunctionDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateFunctionDeclaration() {
        return stringify::E_SgTemplateFunctionDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 666
namespace stringify {
    const char* E_SgTemplateMemberFunctionDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateMemberFunctionDeclaration_parameterList";
            case 1L: return "SgTemplateMemberFunctionDeclaration_decoratorList";
            case 2L: return "SgTemplateMemberFunctionDeclaration_definition";
            case 3L: return "SgTemplateMemberFunctionDeclaration_CtorInitializerList";
            default: return "";
        }
    }

    std::string E_SgTemplateMemberFunctionDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateMemberFunctionDeclaration(i);
        if (s.empty())
            s = "(E_SgTemplateMemberFunctionDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateMemberFunctionDeclaration() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateMemberFunctionDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateMemberFunctionDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateMemberFunctionDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateMemberFunctionDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateMemberFunctionDeclaration() {
        return stringify::E_SgTemplateMemberFunctionDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 669
namespace stringify {
    const char* E_SgTemplateInstantiationMemberFunctionDecl(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateInstantiationMemberFunctionDecl_parameterList";
            case 1L: return "SgTemplateInstantiationMemberFunctionDecl_decoratorList";
            case 2L: return "SgTemplateInstantiationMemberFunctionDecl_definition";
            case 3L: return "SgTemplateInstantiationMemberFunctionDecl_CtorInitializerList";
            default: return "";
        }
    }

    std::string E_SgTemplateInstantiationMemberFunctionDecl(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateInstantiationMemberFunctionDecl(i);
        if (s.empty())
            s = "(E_SgTemplateInstantiationMemberFunctionDecl)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateInstantiationMemberFunctionDecl() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateInstantiationMemberFunctionDecl(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateInstantiationMemberFunctionDecl(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateInstantiationMemberFunctionDecl)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateInstantiationMemberFunctionDecl::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateInstantiationMemberFunctionDecl() {
        return stringify::E_SgTemplateInstantiationMemberFunctionDecl();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 672
namespace stringify {
    const char* E_SgMemberFunctionDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgMemberFunctionDeclaration_parameterList";
            case 1L: return "SgMemberFunctionDeclaration_decoratorList";
            case 2L: return "SgMemberFunctionDeclaration_definition";
            case 3L: return "SgMemberFunctionDeclaration_CtorInitializerList";
            default: return "";
        }
    }

    std::string E_SgMemberFunctionDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgMemberFunctionDeclaration(i);
        if (s.empty())
            s = "(E_SgMemberFunctionDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgMemberFunctionDeclaration() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgMemberFunctionDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgMemberFunctionDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgMemberFunctionDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgMemberFunctionDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgMemberFunctionDeclaration() {
        return stringify::E_SgMemberFunctionDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 675
namespace stringify {
    const char* E_SgTemplateInstantiationFunctionDecl(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateInstantiationFunctionDecl_parameterList";
            case 1L: return "SgTemplateInstantiationFunctionDecl_decoratorList";
            case 2L: return "SgTemplateInstantiationFunctionDecl_definition";
            default: return "";
        }
    }

    std::string E_SgTemplateInstantiationFunctionDecl(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateInstantiationFunctionDecl(i);
        if (s.empty())
            s = "(E_SgTemplateInstantiationFunctionDecl)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateInstantiationFunctionDecl() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateInstantiationFunctionDecl(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateInstantiationFunctionDecl(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateInstantiationFunctionDecl)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateInstantiationFunctionDecl::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateInstantiationFunctionDecl() {
        return stringify::E_SgTemplateInstantiationFunctionDecl();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 678
namespace stringify {
    const char* E_SgProgramHeaderStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgProgramHeaderStatement_parameterList";
            case 1L: return "SgProgramHeaderStatement_decoratorList";
            case 2L: return "SgProgramHeaderStatement_definition";
            default: return "";
        }
    }

    std::string E_SgProgramHeaderStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgProgramHeaderStatement(i);
        if (s.empty())
            s = "(E_SgProgramHeaderStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgProgramHeaderStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgProgramHeaderStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgProgramHeaderStatement(i);
        if (retval.empty()) {
            retval = "(E_SgProgramHeaderStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgProgramHeaderStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgProgramHeaderStatement() {
        return stringify::E_SgProgramHeaderStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 681
namespace stringify {
    const char* E_SgProcedureHeaderStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgProcedureHeaderStatement_parameterList";
            case 1L: return "SgProcedureHeaderStatement_decoratorList";
            case 2L: return "SgProcedureHeaderStatement_definition";
            case 3L: return "SgProcedureHeaderStatement_result_name";
            default: return "";
        }
    }

    std::string E_SgProcedureHeaderStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgProcedureHeaderStatement(i);
        if (s.empty())
            s = "(E_SgProcedureHeaderStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgProcedureHeaderStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgProcedureHeaderStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgProcedureHeaderStatement(i);
        if (retval.empty()) {
            retval = "(E_SgProcedureHeaderStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgProcedureHeaderStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgProcedureHeaderStatement() {
        return stringify::E_SgProcedureHeaderStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 684
namespace stringify {
    const char* E_SgEntryStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgEntryStatement_parameterList";
            case 1L: return "SgEntryStatement_decoratorList";
            case 2L: return "SgEntryStatement_definition";
            case 3L: return "SgEntryStatement_result_name";
            default: return "";
        }
    }

    std::string E_SgEntryStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgEntryStatement(i);
        if (s.empty())
            s = "(E_SgEntryStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgEntryStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgEntryStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgEntryStatement(i);
        if (retval.empty()) {
            retval = "(E_SgEntryStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgEntryStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgEntryStatement() {
        return stringify::E_SgEntryStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 687
namespace stringify {
    const char* E_SgFunctionDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgFunctionDeclaration_parameterList";
            case 1L: return "SgFunctionDeclaration_decoratorList";
            case 2L: return "SgFunctionDeclaration_definition";
            default: return "";
        }
    }

    std::string E_SgFunctionDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgFunctionDeclaration(i);
        if (s.empty())
            s = "(E_SgFunctionDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgFunctionDeclaration() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgFunctionDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgFunctionDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgFunctionDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgFunctionDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgFunctionDeclaration() {
        return stringify::E_SgFunctionDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 690
namespace stringify {
    const char* E_SgIncludeDirectiveStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgIncludeDirectiveStatement_headerFileBody";
            default: return "";
        }
    }

    std::string E_SgIncludeDirectiveStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgIncludeDirectiveStatement(i);
        if (s.empty())
            s = "(E_SgIncludeDirectiveStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgIncludeDirectiveStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgIncludeDirectiveStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgIncludeDirectiveStatement(i);
        if (retval.empty()) {
            retval = "(E_SgIncludeDirectiveStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgIncludeDirectiveStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgIncludeDirectiveStatement() {
        return stringify::E_SgIncludeDirectiveStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 693
namespace stringify {
    const char* E_SgOmpThreadprivateStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpThreadprivateStatement_variables";
            default: return "";
        }
    }

    std::string E_SgOmpThreadprivateStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpThreadprivateStatement(i);
        if (s.empty())
            s = "(E_SgOmpThreadprivateStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpThreadprivateStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpThreadprivateStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpThreadprivateStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpThreadprivateStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpThreadprivateStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpThreadprivateStatement() {
        return stringify::E_SgOmpThreadprivateStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 696
namespace stringify {
    const char* E_SgStmtDeclarationStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgStmtDeclarationStatement_statement";
            default: return "";
        }
    }

    std::string E_SgStmtDeclarationStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgStmtDeclarationStatement(i);
        if (s.empty())
            s = "(E_SgStmtDeclarationStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgStmtDeclarationStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgStmtDeclarationStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgStmtDeclarationStatement(i);
        if (retval.empty()) {
            retval = "(E_SgStmtDeclarationStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgStmtDeclarationStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgStmtDeclarationStatement() {
        return stringify::E_SgStmtDeclarationStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 699
namespace stringify {
    const char* E_SgStaticAssertionDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgStaticAssertionDeclaration_condition";
            default: return "";
        }
    }

    std::string E_SgStaticAssertionDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgStaticAssertionDeclaration(i);
        if (s.empty())
            s = "(E_SgStaticAssertionDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgStaticAssertionDeclaration() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgStaticAssertionDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgStaticAssertionDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgStaticAssertionDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgStaticAssertionDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgStaticAssertionDeclaration() {
        return stringify::E_SgStaticAssertionDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 702
namespace stringify {
    const char* E_SgOmpDeclareSimdStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpDeclareSimdStatement_clauses";
            default: return "";
        }
    }

    std::string E_SgOmpDeclareSimdStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpDeclareSimdStatement(i);
        if (s.empty())
            s = "(E_SgOmpDeclareSimdStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpDeclareSimdStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpDeclareSimdStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpDeclareSimdStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpDeclareSimdStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpDeclareSimdStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpDeclareSimdStatement() {
        return stringify::E_SgOmpDeclareSimdStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 705
namespace stringify {
    const char* E_SgExprStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgExprStatement_expression";
            default: return "";
        }
    }

    std::string E_SgExprStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgExprStatement(i);
        if (s.empty())
            s = "(E_SgExprStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgExprStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgExprStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgExprStatement(i);
        if (retval.empty()) {
            retval = "(E_SgExprStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgExprStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgExprStatement() {
        return stringify::E_SgExprStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 708
namespace stringify {
    const char* E_SgLabelStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgLabelStatement_statement";
            default: return "";
        }
    }

    std::string E_SgLabelStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgLabelStatement(i);
        if (s.empty())
            s = "(E_SgLabelStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgLabelStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgLabelStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgLabelStatement(i);
        if (retval.empty()) {
            retval = "(E_SgLabelStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgLabelStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgLabelStatement() {
        return stringify::E_SgLabelStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 711
namespace stringify {
    const char* E_SgCaseOptionStmt(int64_t i) {
        switch (i) {
            case 0L: return "SgCaseOptionStmt_key";
            case 1L: return "SgCaseOptionStmt_body";
            case 2L: return "SgCaseOptionStmt_key_range_end";
            default: return "";
        }
    }

    std::string E_SgCaseOptionStmt(int64_t i, const std::string &strip) {
        std::string s = E_SgCaseOptionStmt(i);
        if (s.empty())
            s = "(E_SgCaseOptionStmt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgCaseOptionStmt() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgCaseOptionStmt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgCaseOptionStmt(i);
        if (retval.empty()) {
            retval = "(E_SgCaseOptionStmt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgCaseOptionStmt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgCaseOptionStmt() {
        return stringify::E_SgCaseOptionStmt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 714
namespace stringify {
    const char* E_SgTryStmt(int64_t i) {
        switch (i) {
            case 0L: return "SgTryStmt_body";
            case 1L: return "SgTryStmt_catch_statement_seq_root";
            case 2L: return "SgTryStmt_else_body";
            case 3L: return "SgTryStmt_finally_body";
            default: return "";
        }
    }

    std::string E_SgTryStmt(int64_t i, const std::string &strip) {
        std::string s = E_SgTryStmt(i);
        if (s.empty())
            s = "(E_SgTryStmt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTryStmt() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTryStmt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTryStmt(i);
        if (retval.empty()) {
            retval = "(E_SgTryStmt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTryStmt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTryStmt() {
        return stringify::E_SgTryStmt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 717
namespace stringify {
    const char* E_SgDefaultOptionStmt(int64_t i) {
        switch (i) {
            case 0L: return "SgDefaultOptionStmt_body";
            default: return "";
        }
    }

    std::string E_SgDefaultOptionStmt(int64_t i, const std::string &strip) {
        std::string s = E_SgDefaultOptionStmt(i);
        if (s.empty())
            s = "(E_SgDefaultOptionStmt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgDefaultOptionStmt() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgDefaultOptionStmt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgDefaultOptionStmt(i);
        if (retval.empty()) {
            retval = "(E_SgDefaultOptionStmt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgDefaultOptionStmt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgDefaultOptionStmt() {
        return stringify::E_SgDefaultOptionStmt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 720
namespace stringify {
    const char* E_SgReturnStmt(int64_t i) {
        switch (i) {
            case 0L: return "SgReturnStmt_expression";
            default: return "";
        }
    }

    std::string E_SgReturnStmt(int64_t i, const std::string &strip) {
        std::string s = E_SgReturnStmt(i);
        if (s.empty())
            s = "(E_SgReturnStmt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgReturnStmt() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgReturnStmt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgReturnStmt(i);
        if (retval.empty()) {
            retval = "(E_SgReturnStmt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgReturnStmt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgReturnStmt() {
        return stringify::E_SgReturnStmt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 723
namespace stringify {
    const char* E_SgSpawnStmt(int64_t i) {
        switch (i) {
            case 0L: return "SgSpawnStmt_the_func";
            default: return "";
        }
    }

    std::string E_SgSpawnStmt(int64_t i, const std::string &strip) {
        std::string s = E_SgSpawnStmt(i);
        if (s.empty())
            s = "(E_SgSpawnStmt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgSpawnStmt() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgSpawnStmt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgSpawnStmt(i);
        if (retval.empty()) {
            retval = "(E_SgSpawnStmt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgSpawnStmt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgSpawnStmt() {
        return stringify::E_SgSpawnStmt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 726
namespace stringify {
    const char* E_SgForInitStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgForInitStatement_init_stmt";
            default: return "";
        }
    }

    std::string E_SgForInitStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgForInitStatement(i);
        if (s.empty())
            s = "(E_SgForInitStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgForInitStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgForInitStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgForInitStatement(i);
        if (retval.empty()) {
            retval = "(E_SgForInitStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgForInitStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgForInitStatement() {
        return stringify::E_SgForInitStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 729
namespace stringify {
    const char* E_SgCatchStatementSeq(int64_t i) {
        switch (i) {
            case 0L: return "SgCatchStatementSeq_catch_statement_seq";
            default: return "";
        }
    }

    std::string E_SgCatchStatementSeq(int64_t i, const std::string &strip) {
        std::string s = E_SgCatchStatementSeq(i);
        if (s.empty())
            s = "(E_SgCatchStatementSeq)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgCatchStatementSeq() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgCatchStatementSeq(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgCatchStatementSeq(i);
        if (retval.empty()) {
            retval = "(E_SgCatchStatementSeq)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgCatchStatementSeq::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgCatchStatementSeq() {
        return stringify::E_SgCatchStatementSeq();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 732
namespace stringify {
    const char* E_SgProcessControlStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgProcessControlStatement_code";
            case 1L: return "SgProcessControlStatement_quiet";
            default: return "";
        }
    }

    std::string E_SgProcessControlStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgProcessControlStatement(i);
        if (s.empty())
            s = "(E_SgProcessControlStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgProcessControlStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgProcessControlStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgProcessControlStatement(i);
        if (retval.empty()) {
            retval = "(E_SgProcessControlStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgProcessControlStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgProcessControlStatement() {
        return stringify::E_SgProcessControlStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 735
namespace stringify {
    const char* E_SgPrintStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgPrintStatement_io_stmt_list";
            case 1L: return "SgPrintStatement_unit";
            case 2L: return "SgPrintStatement_iostat";
            case 3L: return "SgPrintStatement_err";
            case 4L: return "SgPrintStatement_iomsg";
            case 5L: return "SgPrintStatement_format";
            default: return "";
        }
    }

    std::string E_SgPrintStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgPrintStatement(i);
        if (s.empty())
            s = "(E_SgPrintStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgPrintStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgPrintStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgPrintStatement(i);
        if (retval.empty()) {
            retval = "(E_SgPrintStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgPrintStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgPrintStatement() {
        return stringify::E_SgPrintStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 738
namespace stringify {
    const char* E_SgReadStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgReadStatement_io_stmt_list";
            case 1L: return "SgReadStatement_unit";
            case 2L: return "SgReadStatement_iostat";
            case 3L: return "SgReadStatement_err";
            case 4L: return "SgReadStatement_iomsg";
            case 5L: return "SgReadStatement_format";
            case 6L: return "SgReadStatement_namelist";
            case 7L: return "SgReadStatement_advance";
            case 8L: return "SgReadStatement_asynchronous";
            case 9L: return "SgReadStatement_blank";
            case 10L: return "SgReadStatement_decimal";
            case 11L: return "SgReadStatement_delim";
            case 12L: return "SgReadStatement_end";
            case 13L: return "SgReadStatement_eor";
            case 14L: return "SgReadStatement_id";
            case 15L: return "SgReadStatement_pad";
            case 16L: return "SgReadStatement_pos";
            case 17L: return "SgReadStatement_rec";
            case 18L: return "SgReadStatement_round";
            case 19L: return "SgReadStatement_sign";
            case 20L: return "SgReadStatement_size";
            default: return "";
        }
    }

    std::string E_SgReadStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgReadStatement(i);
        if (s.empty())
            s = "(E_SgReadStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgReadStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L
        };
        static const std::vector<int64_t> retval(values, values + 21);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgReadStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgReadStatement(i);
        if (retval.empty()) {
            retval = "(E_SgReadStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgReadStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgReadStatement() {
        return stringify::E_SgReadStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 741
namespace stringify {
    const char* E_SgWriteStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgWriteStatement_io_stmt_list";
            case 1L: return "SgWriteStatement_unit";
            case 2L: return "SgWriteStatement_iostat";
            case 3L: return "SgWriteStatement_err";
            case 4L: return "SgWriteStatement_iomsg";
            case 5L: return "SgWriteStatement_format";
            case 6L: return "SgWriteStatement_namelist";
            case 7L: return "SgWriteStatement_advance";
            case 8L: return "SgWriteStatement_asynchronous";
            case 9L: return "SgWriteStatement_blank";
            case 10L: return "SgWriteStatement_decimal";
            case 11L: return "SgWriteStatement_delim";
            case 12L: return "SgWriteStatement_end";
            case 13L: return "SgWriteStatement_eor";
            case 14L: return "SgWriteStatement_id";
            case 15L: return "SgWriteStatement_pad";
            case 16L: return "SgWriteStatement_pos";
            case 17L: return "SgWriteStatement_rec";
            case 18L: return "SgWriteStatement_round";
            case 19L: return "SgWriteStatement_sign";
            case 20L: return "SgWriteStatement_size";
            default: return "";
        }
    }

    std::string E_SgWriteStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgWriteStatement(i);
        if (s.empty())
            s = "(E_SgWriteStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgWriteStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L
        };
        static const std::vector<int64_t> retval(values, values + 21);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgWriteStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgWriteStatement(i);
        if (retval.empty()) {
            retval = "(E_SgWriteStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgWriteStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgWriteStatement() {
        return stringify::E_SgWriteStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 744
namespace stringify {
    const char* E_SgOpenStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOpenStatement_io_stmt_list";
            case 1L: return "SgOpenStatement_unit";
            case 2L: return "SgOpenStatement_iostat";
            case 3L: return "SgOpenStatement_err";
            case 4L: return "SgOpenStatement_iomsg";
            case 5L: return "SgOpenStatement_file";
            case 6L: return "SgOpenStatement_status";
            case 7L: return "SgOpenStatement_access";
            case 8L: return "SgOpenStatement_form";
            case 9L: return "SgOpenStatement_recl";
            case 10L: return "SgOpenStatement_blank";
            case 11L: return "SgOpenStatement_position";
            case 12L: return "SgOpenStatement_action";
            case 13L: return "SgOpenStatement_delim";
            case 14L: return "SgOpenStatement_pad";
            case 15L: return "SgOpenStatement_round";
            case 16L: return "SgOpenStatement_sign";
            case 17L: return "SgOpenStatement_asynchronous";
            default: return "";
        }
    }

    std::string E_SgOpenStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOpenStatement(i);
        if (s.empty())
            s = "(E_SgOpenStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOpenStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L
        };
        static const std::vector<int64_t> retval(values, values + 18);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOpenStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOpenStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOpenStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOpenStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOpenStatement() {
        return stringify::E_SgOpenStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 747
namespace stringify {
    const char* E_SgCloseStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgCloseStatement_io_stmt_list";
            case 1L: return "SgCloseStatement_unit";
            case 2L: return "SgCloseStatement_iostat";
            case 3L: return "SgCloseStatement_err";
            case 4L: return "SgCloseStatement_iomsg";
            case 5L: return "SgCloseStatement_status";
            default: return "";
        }
    }

    std::string E_SgCloseStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgCloseStatement(i);
        if (s.empty())
            s = "(E_SgCloseStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgCloseStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgCloseStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgCloseStatement(i);
        if (retval.empty()) {
            retval = "(E_SgCloseStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgCloseStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgCloseStatement() {
        return stringify::E_SgCloseStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 750
namespace stringify {
    const char* E_SgInquireStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgInquireStatement_io_stmt_list";
            case 1L: return "SgInquireStatement_unit";
            case 2L: return "SgInquireStatement_iostat";
            case 3L: return "SgInquireStatement_err";
            case 4L: return "SgInquireStatement_iomsg";
            default: return "";
        }
    }

    std::string E_SgInquireStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgInquireStatement(i);
        if (s.empty())
            s = "(E_SgInquireStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgInquireStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgInquireStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgInquireStatement(i);
        if (retval.empty()) {
            retval = "(E_SgInquireStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgInquireStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgInquireStatement() {
        return stringify::E_SgInquireStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 753
namespace stringify {
    const char* E_SgFlushStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgFlushStatement_io_stmt_list";
            case 1L: return "SgFlushStatement_unit";
            case 2L: return "SgFlushStatement_iostat";
            case 3L: return "SgFlushStatement_err";
            case 4L: return "SgFlushStatement_iomsg";
            default: return "";
        }
    }

    std::string E_SgFlushStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgFlushStatement(i);
        if (s.empty())
            s = "(E_SgFlushStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgFlushStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgFlushStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgFlushStatement(i);
        if (retval.empty()) {
            retval = "(E_SgFlushStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgFlushStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgFlushStatement() {
        return stringify::E_SgFlushStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 756
namespace stringify {
    const char* E_SgBackspaceStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgBackspaceStatement_io_stmt_list";
            case 1L: return "SgBackspaceStatement_unit";
            case 2L: return "SgBackspaceStatement_iostat";
            case 3L: return "SgBackspaceStatement_err";
            case 4L: return "SgBackspaceStatement_iomsg";
            default: return "";
        }
    }

    std::string E_SgBackspaceStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgBackspaceStatement(i);
        if (s.empty())
            s = "(E_SgBackspaceStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgBackspaceStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgBackspaceStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgBackspaceStatement(i);
        if (retval.empty()) {
            retval = "(E_SgBackspaceStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgBackspaceStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgBackspaceStatement() {
        return stringify::E_SgBackspaceStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 759
namespace stringify {
    const char* E_SgRewindStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgRewindStatement_io_stmt_list";
            case 1L: return "SgRewindStatement_unit";
            case 2L: return "SgRewindStatement_iostat";
            case 3L: return "SgRewindStatement_err";
            case 4L: return "SgRewindStatement_iomsg";
            default: return "";
        }
    }

    std::string E_SgRewindStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgRewindStatement(i);
        if (s.empty())
            s = "(E_SgRewindStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgRewindStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgRewindStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgRewindStatement(i);
        if (retval.empty()) {
            retval = "(E_SgRewindStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgRewindStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgRewindStatement() {
        return stringify::E_SgRewindStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 762
namespace stringify {
    const char* E_SgEndfileStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgEndfileStatement_io_stmt_list";
            case 1L: return "SgEndfileStatement_unit";
            case 2L: return "SgEndfileStatement_iostat";
            case 3L: return "SgEndfileStatement_err";
            case 4L: return "SgEndfileStatement_iomsg";
            default: return "";
        }
    }

    std::string E_SgEndfileStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgEndfileStatement(i);
        if (s.empty())
            s = "(E_SgEndfileStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgEndfileStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgEndfileStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgEndfileStatement(i);
        if (retval.empty()) {
            retval = "(E_SgEndfileStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgEndfileStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgEndfileStatement() {
        return stringify::E_SgEndfileStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 765
namespace stringify {
    const char* E_SgWaitStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgWaitStatement_io_stmt_list";
            case 1L: return "SgWaitStatement_unit";
            case 2L: return "SgWaitStatement_iostat";
            case 3L: return "SgWaitStatement_err";
            case 4L: return "SgWaitStatement_iomsg";
            default: return "";
        }
    }

    std::string E_SgWaitStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgWaitStatement(i);
        if (s.empty())
            s = "(E_SgWaitStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgWaitStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgWaitStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgWaitStatement(i);
        if (retval.empty()) {
            retval = "(E_SgWaitStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgWaitStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgWaitStatement() {
        return stringify::E_SgWaitStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 768
namespace stringify {
    const char* E_SgIOStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgIOStatement_io_stmt_list";
            case 1L: return "SgIOStatement_unit";
            case 2L: return "SgIOStatement_iostat";
            case 3L: return "SgIOStatement_err";
            case 4L: return "SgIOStatement_iomsg";
            default: return "";
        }
    }

    std::string E_SgIOStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgIOStatement(i);
        if (s.empty())
            s = "(E_SgIOStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgIOStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgIOStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgIOStatement(i);
        if (retval.empty()) {
            retval = "(E_SgIOStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgIOStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgIOStatement() {
        return stringify::E_SgIOStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 771
namespace stringify {
    const char* E_SgWhereStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgWhereStatement_condition";
            case 1L: return "SgWhereStatement_body";
            case 2L: return "SgWhereStatement_elsewhere";
            default: return "";
        }
    }

    std::string E_SgWhereStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgWhereStatement(i);
        if (s.empty())
            s = "(E_SgWhereStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgWhereStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgWhereStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgWhereStatement(i);
        if (retval.empty()) {
            retval = "(E_SgWhereStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgWhereStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgWhereStatement() {
        return stringify::E_SgWhereStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 774
namespace stringify {
    const char* E_SgElseWhereStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgElseWhereStatement_condition";
            case 1L: return "SgElseWhereStatement_body";
            case 2L: return "SgElseWhereStatement_elsewhere";
            default: return "";
        }
    }

    std::string E_SgElseWhereStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgElseWhereStatement(i);
        if (s.empty())
            s = "(E_SgElseWhereStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgElseWhereStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgElseWhereStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgElseWhereStatement(i);
        if (retval.empty()) {
            retval = "(E_SgElseWhereStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgElseWhereStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgElseWhereStatement() {
        return stringify::E_SgElseWhereStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 777
namespace stringify {
    const char* E_SgNullifyStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgNullifyStatement_pointer_list";
            default: return "";
        }
    }

    std::string E_SgNullifyStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgNullifyStatement(i);
        if (s.empty())
            s = "(E_SgNullifyStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgNullifyStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgNullifyStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgNullifyStatement(i);
        if (retval.empty()) {
            retval = "(E_SgNullifyStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgNullifyStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgNullifyStatement() {
        return stringify::E_SgNullifyStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 780
namespace stringify {
    const char* E_SgArithmeticIfStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgArithmeticIfStatement_conditional";
            default: return "";
        }
    }

    std::string E_SgArithmeticIfStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgArithmeticIfStatement(i);
        if (s.empty())
            s = "(E_SgArithmeticIfStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgArithmeticIfStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgArithmeticIfStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgArithmeticIfStatement(i);
        if (retval.empty()) {
            retval = "(E_SgArithmeticIfStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgArithmeticIfStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgArithmeticIfStatement() {
        return stringify::E_SgArithmeticIfStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 783
namespace stringify {
    const char* E_SgAssignStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgAssignStatement_value";
            default: return "";
        }
    }

    std::string E_SgAssignStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgAssignStatement(i);
        if (s.empty())
            s = "(E_SgAssignStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAssignStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAssignStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAssignStatement(i);
        if (retval.empty()) {
            retval = "(E_SgAssignStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAssignStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAssignStatement() {
        return stringify::E_SgAssignStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 786
namespace stringify {
    const char* E_SgComputedGotoStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgComputedGotoStatement_labelList";
            case 1L: return "SgComputedGotoStatement_label_index";
            default: return "";
        }
    }

    std::string E_SgComputedGotoStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgComputedGotoStatement(i);
        if (s.empty())
            s = "(E_SgComputedGotoStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgComputedGotoStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgComputedGotoStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgComputedGotoStatement(i);
        if (retval.empty()) {
            retval = "(E_SgComputedGotoStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgComputedGotoStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgComputedGotoStatement() {
        return stringify::E_SgComputedGotoStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 789
namespace stringify {
    const char* E_SgAssignedGotoStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgAssignedGotoStatement_targets";
            default: return "";
        }
    }

    std::string E_SgAssignedGotoStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgAssignedGotoStatement(i);
        if (s.empty())
            s = "(E_SgAssignedGotoStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAssignedGotoStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAssignedGotoStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAssignedGotoStatement(i);
        if (retval.empty()) {
            retval = "(E_SgAssignedGotoStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAssignedGotoStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAssignedGotoStatement() {
        return stringify::E_SgAssignedGotoStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 792
namespace stringify {
    const char* E_SgAllocateStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgAllocateStatement_expr_list";
            case 1L: return "SgAllocateStatement_stat_expression";
            case 2L: return "SgAllocateStatement_errmsg_expression";
            case 3L: return "SgAllocateStatement_source_expression";
            default: return "";
        }
    }

    std::string E_SgAllocateStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgAllocateStatement(i);
        if (s.empty())
            s = "(E_SgAllocateStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAllocateStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAllocateStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAllocateStatement(i);
        if (retval.empty()) {
            retval = "(E_SgAllocateStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAllocateStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAllocateStatement() {
        return stringify::E_SgAllocateStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 795
namespace stringify {
    const char* E_SgDeallocateStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgDeallocateStatement_expr_list";
            case 1L: return "SgDeallocateStatement_stat_expression";
            case 2L: return "SgDeallocateStatement_errmsg_expression";
            default: return "";
        }
    }

    std::string E_SgDeallocateStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgDeallocateStatement(i);
        if (s.empty())
            s = "(E_SgDeallocateStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgDeallocateStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgDeallocateStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgDeallocateStatement(i);
        if (retval.empty()) {
            retval = "(E_SgDeallocateStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgDeallocateStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgDeallocateStatement() {
        return stringify::E_SgDeallocateStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 798
namespace stringify {
    const char* E_SgUpcNotifyStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgUpcNotifyStatement_notify_expression";
            default: return "";
        }
    }

    std::string E_SgUpcNotifyStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgUpcNotifyStatement(i);
        if (s.empty())
            s = "(E_SgUpcNotifyStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUpcNotifyStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUpcNotifyStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUpcNotifyStatement(i);
        if (retval.empty()) {
            retval = "(E_SgUpcNotifyStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUpcNotifyStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUpcNotifyStatement() {
        return stringify::E_SgUpcNotifyStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 801
namespace stringify {
    const char* E_SgUpcWaitStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgUpcWaitStatement_wait_expression";
            default: return "";
        }
    }

    std::string E_SgUpcWaitStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgUpcWaitStatement(i);
        if (s.empty())
            s = "(E_SgUpcWaitStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUpcWaitStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUpcWaitStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUpcWaitStatement(i);
        if (retval.empty()) {
            retval = "(E_SgUpcWaitStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUpcWaitStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUpcWaitStatement() {
        return stringify::E_SgUpcWaitStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 804
namespace stringify {
    const char* E_SgUpcBarrierStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgUpcBarrierStatement_barrier_expression";
            default: return "";
        }
    }

    std::string E_SgUpcBarrierStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgUpcBarrierStatement(i);
        if (s.empty())
            s = "(E_SgUpcBarrierStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUpcBarrierStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUpcBarrierStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUpcBarrierStatement(i);
        if (retval.empty()) {
            retval = "(E_SgUpcBarrierStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUpcBarrierStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUpcBarrierStatement() {
        return stringify::E_SgUpcBarrierStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 807
namespace stringify {
    const char* E_SgOmpFlushStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpFlushStatement_variables";
            default: return "";
        }
    }

    std::string E_SgOmpFlushStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpFlushStatement(i);
        if (s.empty())
            s = "(E_SgOmpFlushStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpFlushStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpFlushStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpFlushStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpFlushStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpFlushStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpFlushStatement() {
        return stringify::E_SgOmpFlushStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 810
namespace stringify {
    const char* E_SgOmpMasterStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpMasterStatement_body";
            default: return "";
        }
    }

    std::string E_SgOmpMasterStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpMasterStatement(i);
        if (s.empty())
            s = "(E_SgOmpMasterStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpMasterStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpMasterStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpMasterStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpMasterStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpMasterStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpMasterStatement() {
        return stringify::E_SgOmpMasterStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 813
namespace stringify {
    const char* E_SgOmpOrderedStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpOrderedStatement_body";
            default: return "";
        }
    }

    std::string E_SgOmpOrderedStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpOrderedStatement(i);
        if (s.empty())
            s = "(E_SgOmpOrderedStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpOrderedStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpOrderedStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpOrderedStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpOrderedStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpOrderedStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpOrderedStatement() {
        return stringify::E_SgOmpOrderedStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 816
namespace stringify {
    const char* E_SgOmpSectionStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpSectionStatement_body";
            default: return "";
        }
    }

    std::string E_SgOmpSectionStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpSectionStatement(i);
        if (s.empty())
            s = "(E_SgOmpSectionStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpSectionStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpSectionStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpSectionStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpSectionStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpSectionStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpSectionStatement() {
        return stringify::E_SgOmpSectionStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 819
namespace stringify {
    const char* E_SgOmpWorkshareStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpWorkshareStatement_body";
            default: return "";
        }
    }

    std::string E_SgOmpWorkshareStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpWorkshareStatement(i);
        if (s.empty())
            s = "(E_SgOmpWorkshareStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpWorkshareStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpWorkshareStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpWorkshareStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpWorkshareStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpWorkshareStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpWorkshareStatement() {
        return stringify::E_SgOmpWorkshareStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 822
namespace stringify {
    const char* E_SgOmpParallelStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpParallelStatement_body";
            case 1L: return "SgOmpParallelStatement_clauses";
            default: return "";
        }
    }

    std::string E_SgOmpParallelStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpParallelStatement(i);
        if (s.empty())
            s = "(E_SgOmpParallelStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpParallelStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpParallelStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpParallelStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpParallelStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpParallelStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpParallelStatement() {
        return stringify::E_SgOmpParallelStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 825
namespace stringify {
    const char* E_SgOmpTeamsStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpTeamsStatement_body";
            case 1L: return "SgOmpTeamsStatement_clauses";
            default: return "";
        }
    }

    std::string E_SgOmpTeamsStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpTeamsStatement(i);
        if (s.empty())
            s = "(E_SgOmpTeamsStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpTeamsStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpTeamsStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpTeamsStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpTeamsStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpTeamsStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpTeamsStatement() {
        return stringify::E_SgOmpTeamsStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 828
namespace stringify {
    const char* E_SgOmpSingleStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpSingleStatement_body";
            case 1L: return "SgOmpSingleStatement_clauses";
            default: return "";
        }
    }

    std::string E_SgOmpSingleStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpSingleStatement(i);
        if (s.empty())
            s = "(E_SgOmpSingleStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpSingleStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpSingleStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpSingleStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpSingleStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpSingleStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpSingleStatement() {
        return stringify::E_SgOmpSingleStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 831
namespace stringify {
    const char* E_SgOmpAtomicStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpAtomicStatement_body";
            case 1L: return "SgOmpAtomicStatement_clauses";
            default: return "";
        }
    }

    std::string E_SgOmpAtomicStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpAtomicStatement(i);
        if (s.empty())
            s = "(E_SgOmpAtomicStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpAtomicStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpAtomicStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpAtomicStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpAtomicStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpAtomicStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpAtomicStatement() {
        return stringify::E_SgOmpAtomicStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 834
namespace stringify {
    const char* E_SgOmpScanStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpScanStatement_body";
            case 1L: return "SgOmpScanStatement_clauses";
            default: return "";
        }
    }

    std::string E_SgOmpScanStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpScanStatement(i);
        if (s.empty())
            s = "(E_SgOmpScanStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpScanStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpScanStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpScanStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpScanStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpScanStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpScanStatement() {
        return stringify::E_SgOmpScanStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 837
namespace stringify {
    const char* E_SgOmpMetadirectiveStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpMetadirectiveStatement_body";
            case 1L: return "SgOmpMetadirectiveStatement_clauses";
            default: return "";
        }
    }

    std::string E_SgOmpMetadirectiveStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpMetadirectiveStatement(i);
        if (s.empty())
            s = "(E_SgOmpMetadirectiveStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpMetadirectiveStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpMetadirectiveStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpMetadirectiveStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpMetadirectiveStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpMetadirectiveStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpMetadirectiveStatement() {
        return stringify::E_SgOmpMetadirectiveStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 840
namespace stringify {
    const char* E_SgOmpLoopStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpLoopStatement_body";
            case 1L: return "SgOmpLoopStatement_clauses";
            default: return "";
        }
    }

    std::string E_SgOmpLoopStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpLoopStatement(i);
        if (s.empty())
            s = "(E_SgOmpLoopStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpLoopStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpLoopStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpLoopStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpLoopStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpLoopStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpLoopStatement() {
        return stringify::E_SgOmpLoopStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 843
namespace stringify {
    const char* E_SgOmpTaskgroupStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpTaskgroupStatement_body";
            case 1L: return "SgOmpTaskgroupStatement_clauses";
            default: return "";
        }
    }

    std::string E_SgOmpTaskgroupStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpTaskgroupStatement(i);
        if (s.empty())
            s = "(E_SgOmpTaskgroupStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpTaskgroupStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpTaskgroupStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpTaskgroupStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpTaskgroupStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpTaskgroupStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpTaskgroupStatement() {
        return stringify::E_SgOmpTaskgroupStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 846
namespace stringify {
    const char* E_SgOmpTaskloopStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpTaskloopStatement_body";
            case 1L: return "SgOmpTaskloopStatement_clauses";
            default: return "";
        }
    }

    std::string E_SgOmpTaskloopStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpTaskloopStatement(i);
        if (s.empty())
            s = "(E_SgOmpTaskloopStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpTaskloopStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpTaskloopStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpTaskloopStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpTaskloopStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpTaskloopStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpTaskloopStatement() {
        return stringify::E_SgOmpTaskloopStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 849
namespace stringify {
    const char* E_SgOmpDepobjStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpDepobjStatement_body";
            case 1L: return "SgOmpDepobjStatement_clauses";
            default: return "";
        }
    }

    std::string E_SgOmpDepobjStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpDepobjStatement(i);
        if (s.empty())
            s = "(E_SgOmpDepobjStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpDepobjStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpDepobjStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpDepobjStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpDepobjStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpDepobjStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpDepobjStatement() {
        return stringify::E_SgOmpDepobjStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 852
namespace stringify {
    const char* E_SgOmpTargetEnterDataStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpTargetEnterDataStatement_body";
            case 1L: return "SgOmpTargetEnterDataStatement_clauses";
            default: return "";
        }
    }

    std::string E_SgOmpTargetEnterDataStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpTargetEnterDataStatement(i);
        if (s.empty())
            s = "(E_SgOmpTargetEnterDataStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpTargetEnterDataStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpTargetEnterDataStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpTargetEnterDataStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpTargetEnterDataStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpTargetEnterDataStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpTargetEnterDataStatement() {
        return stringify::E_SgOmpTargetEnterDataStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 855
namespace stringify {
    const char* E_SgOmpTargetExitDataStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpTargetExitDataStatement_body";
            case 1L: return "SgOmpTargetExitDataStatement_clauses";
            default: return "";
        }
    }

    std::string E_SgOmpTargetExitDataStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpTargetExitDataStatement(i);
        if (s.empty())
            s = "(E_SgOmpTargetExitDataStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpTargetExitDataStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpTargetExitDataStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpTargetExitDataStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpTargetExitDataStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpTargetExitDataStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpTargetExitDataStatement() {
        return stringify::E_SgOmpTargetExitDataStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 858
namespace stringify {
    const char* E_SgOmpTaskStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpTaskStatement_body";
            case 1L: return "SgOmpTaskStatement_clauses";
            default: return "";
        }
    }

    std::string E_SgOmpTaskStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpTaskStatement(i);
        if (s.empty())
            s = "(E_SgOmpTaskStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpTaskStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpTaskStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpTaskStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpTaskStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpTaskStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpTaskStatement() {
        return stringify::E_SgOmpTaskStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 861
namespace stringify {
    const char* E_SgOmpForStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpForStatement_body";
            case 1L: return "SgOmpForStatement_clauses";
            default: return "";
        }
    }

    std::string E_SgOmpForStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpForStatement(i);
        if (s.empty())
            s = "(E_SgOmpForStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpForStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpForStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpForStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpForStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpForStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpForStatement() {
        return stringify::E_SgOmpForStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 864
namespace stringify {
    const char* E_SgOmpDoStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpDoStatement_body";
            case 1L: return "SgOmpDoStatement_clauses";
            default: return "";
        }
    }

    std::string E_SgOmpDoStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpDoStatement(i);
        if (s.empty())
            s = "(E_SgOmpDoStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpDoStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpDoStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpDoStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpDoStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpDoStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpDoStatement() {
        return stringify::E_SgOmpDoStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 867
namespace stringify {
    const char* E_SgOmpSectionsStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpSectionsStatement_body";
            case 1L: return "SgOmpSectionsStatement_clauses";
            default: return "";
        }
    }

    std::string E_SgOmpSectionsStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpSectionsStatement(i);
        if (s.empty())
            s = "(E_SgOmpSectionsStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpSectionsStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpSectionsStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpSectionsStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpSectionsStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpSectionsStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpSectionsStatement() {
        return stringify::E_SgOmpSectionsStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 870
namespace stringify {
    const char* E_SgOmpTargetStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpTargetStatement_body";
            case 1L: return "SgOmpTargetStatement_clauses";
            default: return "";
        }
    }

    std::string E_SgOmpTargetStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpTargetStatement(i);
        if (s.empty())
            s = "(E_SgOmpTargetStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpTargetStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpTargetStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpTargetStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpTargetStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpTargetStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpTargetStatement() {
        return stringify::E_SgOmpTargetStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 873
namespace stringify {
    const char* E_SgOmpTargetDataStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpTargetDataStatement_body";
            case 1L: return "SgOmpTargetDataStatement_clauses";
            default: return "";
        }
    }

    std::string E_SgOmpTargetDataStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpTargetDataStatement(i);
        if (s.empty())
            s = "(E_SgOmpTargetDataStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpTargetDataStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpTargetDataStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpTargetDataStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpTargetDataStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpTargetDataStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpTargetDataStatement() {
        return stringify::E_SgOmpTargetDataStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 876
namespace stringify {
    const char* E_SgOmpTargetParallelForStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpTargetParallelForStatement_body";
            case 1L: return "SgOmpTargetParallelForStatement_clauses";
            default: return "";
        }
    }

    std::string E_SgOmpTargetParallelForStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpTargetParallelForStatement(i);
        if (s.empty())
            s = "(E_SgOmpTargetParallelForStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpTargetParallelForStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpTargetParallelForStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpTargetParallelForStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpTargetParallelForStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpTargetParallelForStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpTargetParallelForStatement() {
        return stringify::E_SgOmpTargetParallelForStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 879
namespace stringify {
    const char* E_SgOmpSimdStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpSimdStatement_body";
            case 1L: return "SgOmpSimdStatement_clauses";
            default: return "";
        }
    }

    std::string E_SgOmpSimdStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpSimdStatement(i);
        if (s.empty())
            s = "(E_SgOmpSimdStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpSimdStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpSimdStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpSimdStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpSimdStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpSimdStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpSimdStatement() {
        return stringify::E_SgOmpSimdStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 882
namespace stringify {
    const char* E_SgOmpForSimdStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpForSimdStatement_body";
            case 1L: return "SgOmpForSimdStatement_clauses";
            default: return "";
        }
    }

    std::string E_SgOmpForSimdStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpForSimdStatement(i);
        if (s.empty())
            s = "(E_SgOmpForSimdStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpForSimdStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpForSimdStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpForSimdStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpForSimdStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpForSimdStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpForSimdStatement() {
        return stringify::E_SgOmpForSimdStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 885
namespace stringify {
    const char* E_SgOmpCriticalStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpCriticalStatement_body";
            case 1L: return "SgOmpCriticalStatement_clauses";
            default: return "";
        }
    }

    std::string E_SgOmpCriticalStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpCriticalStatement(i);
        if (s.empty())
            s = "(E_SgOmpCriticalStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpCriticalStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpCriticalStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpCriticalStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpCriticalStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpCriticalStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpCriticalStatement() {
        return stringify::E_SgOmpCriticalStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 888
namespace stringify {
    const char* E_SgOmpDistributeStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpDistributeStatement_body";
            case 1L: return "SgOmpDistributeStatement_clauses";
            default: return "";
        }
    }

    std::string E_SgOmpDistributeStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpDistributeStatement(i);
        if (s.empty())
            s = "(E_SgOmpDistributeStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpDistributeStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpDistributeStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpDistributeStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpDistributeStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpDistributeStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpDistributeStatement() {
        return stringify::E_SgOmpDistributeStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 891
namespace stringify {
    const char* E_SgOmpTaskwaitStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpTaskwaitStatement_body";
            case 1L: return "SgOmpTaskwaitStatement_clauses";
            default: return "";
        }
    }

    std::string E_SgOmpTaskwaitStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpTaskwaitStatement(i);
        if (s.empty())
            s = "(E_SgOmpTaskwaitStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpTaskwaitStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpTaskwaitStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpTaskwaitStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpTaskwaitStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpTaskwaitStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpTaskwaitStatement() {
        return stringify::E_SgOmpTaskwaitStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 894
namespace stringify {
    const char* E_SgOmpClauseBodyStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpClauseBodyStatement_body";
            case 1L: return "SgOmpClauseBodyStatement_clauses";
            default: return "";
        }
    }

    std::string E_SgOmpClauseBodyStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpClauseBodyStatement(i);
        if (s.empty())
            s = "(E_SgOmpClauseBodyStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpClauseBodyStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpClauseBodyStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpClauseBodyStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpClauseBodyStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpClauseBodyStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpClauseBodyStatement() {
        return stringify::E_SgOmpClauseBodyStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 897
namespace stringify {
    const char* E_SgOmpBodyStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpBodyStatement_body";
            default: return "";
        }
    }

    std::string E_SgOmpBodyStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpBodyStatement(i);
        if (s.empty())
            s = "(E_SgOmpBodyStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpBodyStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpBodyStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpBodyStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpBodyStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpBodyStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpBodyStatement() {
        return stringify::E_SgOmpBodyStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 900
namespace stringify {
    const char* E_SgWithStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgWithStatement_expression";
            case 1L: return "SgWithStatement_body";
            default: return "";
        }
    }

    std::string E_SgWithStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgWithStatement(i);
        if (s.empty())
            s = "(E_SgWithStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgWithStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgWithStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgWithStatement(i);
        if (retval.empty()) {
            retval = "(E_SgWithStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgWithStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgWithStatement() {
        return stringify::E_SgWithStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 903
namespace stringify {
    const char* E_SgAssertStmt(int64_t i) {
        switch (i) {
            case 0L: return "SgAssertStmt_test";
            case 1L: return "SgAssertStmt_exception_argument";
            default: return "";
        }
    }

    std::string E_SgAssertStmt(int64_t i, const std::string &strip) {
        std::string s = E_SgAssertStmt(i);
        if (s.empty())
            s = "(E_SgAssertStmt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAssertStmt() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAssertStmt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAssertStmt(i);
        if (retval.empty()) {
            retval = "(E_SgAssertStmt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAssertStmt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAssertStmt() {
        return stringify::E_SgAssertStmt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 906
namespace stringify {
    const char* E_SgExecStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgExecStatement_executable";
            case 1L: return "SgExecStatement_globals";
            case 2L: return "SgExecStatement_locals";
            default: return "";
        }
    }

    std::string E_SgExecStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgExecStatement(i);
        if (s.empty())
            s = "(E_SgExecStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgExecStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgExecStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgExecStatement(i);
        if (retval.empty()) {
            retval = "(E_SgExecStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgExecStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgExecStatement() {
        return stringify::E_SgExecStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 909
namespace stringify {
    const char* E_SgSyncAllStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgSyncAllStatement_stat";
            case 1L: return "SgSyncAllStatement_err_msg";
            case 2L: return "SgSyncAllStatement_acquired_lock";
            default: return "";
        }
    }

    std::string E_SgSyncAllStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgSyncAllStatement(i);
        if (s.empty())
            s = "(E_SgSyncAllStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgSyncAllStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgSyncAllStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgSyncAllStatement(i);
        if (retval.empty()) {
            retval = "(E_SgSyncAllStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgSyncAllStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgSyncAllStatement() {
        return stringify::E_SgSyncAllStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 912
namespace stringify {
    const char* E_SgSyncImagesStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgSyncImagesStatement_stat";
            case 1L: return "SgSyncImagesStatement_err_msg";
            case 2L: return "SgSyncImagesStatement_acquired_lock";
            case 3L: return "SgSyncImagesStatement_image_set";
            default: return "";
        }
    }

    std::string E_SgSyncImagesStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgSyncImagesStatement(i);
        if (s.empty())
            s = "(E_SgSyncImagesStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgSyncImagesStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgSyncImagesStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgSyncImagesStatement(i);
        if (retval.empty()) {
            retval = "(E_SgSyncImagesStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgSyncImagesStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgSyncImagesStatement() {
        return stringify::E_SgSyncImagesStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 915
namespace stringify {
    const char* E_SgSyncMemoryStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgSyncMemoryStatement_stat";
            case 1L: return "SgSyncMemoryStatement_err_msg";
            case 2L: return "SgSyncMemoryStatement_acquired_lock";
            default: return "";
        }
    }

    std::string E_SgSyncMemoryStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgSyncMemoryStatement(i);
        if (s.empty())
            s = "(E_SgSyncMemoryStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgSyncMemoryStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgSyncMemoryStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgSyncMemoryStatement(i);
        if (retval.empty()) {
            retval = "(E_SgSyncMemoryStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgSyncMemoryStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgSyncMemoryStatement() {
        return stringify::E_SgSyncMemoryStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 918
namespace stringify {
    const char* E_SgSyncTeamStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgSyncTeamStatement_stat";
            case 1L: return "SgSyncTeamStatement_err_msg";
            case 2L: return "SgSyncTeamStatement_acquired_lock";
            case 3L: return "SgSyncTeamStatement_team_value";
            default: return "";
        }
    }

    std::string E_SgSyncTeamStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgSyncTeamStatement(i);
        if (s.empty())
            s = "(E_SgSyncTeamStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgSyncTeamStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgSyncTeamStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgSyncTeamStatement(i);
        if (retval.empty()) {
            retval = "(E_SgSyncTeamStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgSyncTeamStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgSyncTeamStatement() {
        return stringify::E_SgSyncTeamStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 921
namespace stringify {
    const char* E_SgLockStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgLockStatement_stat";
            case 1L: return "SgLockStatement_err_msg";
            case 2L: return "SgLockStatement_acquired_lock";
            case 3L: return "SgLockStatement_lock_variable";
            default: return "";
        }
    }

    std::string E_SgLockStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgLockStatement(i);
        if (s.empty())
            s = "(E_SgLockStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgLockStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgLockStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgLockStatement(i);
        if (retval.empty()) {
            retval = "(E_SgLockStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgLockStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgLockStatement() {
        return stringify::E_SgLockStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 924
namespace stringify {
    const char* E_SgUnlockStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgUnlockStatement_stat";
            case 1L: return "SgUnlockStatement_err_msg";
            case 2L: return "SgUnlockStatement_acquired_lock";
            case 3L: return "SgUnlockStatement_lock_variable";
            default: return "";
        }
    }

    std::string E_SgUnlockStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgUnlockStatement(i);
        if (s.empty())
            s = "(E_SgUnlockStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUnlockStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUnlockStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUnlockStatement(i);
        if (retval.empty()) {
            retval = "(E_SgUnlockStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUnlockStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUnlockStatement() {
        return stringify::E_SgUnlockStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 927
namespace stringify {
    const char* E_SgImageControlStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgImageControlStatement_stat";
            case 1L: return "SgImageControlStatement_err_msg";
            case 2L: return "SgImageControlStatement_acquired_lock";
            default: return "";
        }
    }

    std::string E_SgImageControlStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgImageControlStatement(i);
        if (s.empty())
            s = "(E_SgImageControlStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgImageControlStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgImageControlStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgImageControlStatement(i);
        if (retval.empty()) {
            retval = "(E_SgImageControlStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgImageControlStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgImageControlStatement() {
        return stringify::E_SgImageControlStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 930
namespace stringify {
    const char* E_SgExpressionRoot(int64_t i) {
        switch (i) {
            case 0L: return "SgExpressionRoot_operand_i";
            default: return "";
        }
    }

    std::string E_SgExpressionRoot(int64_t i, const std::string &strip) {
        std::string s = E_SgExpressionRoot(i);
        if (s.empty())
            s = "(E_SgExpressionRoot)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgExpressionRoot() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgExpressionRoot(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgExpressionRoot(i);
        if (retval.empty()) {
            retval = "(E_SgExpressionRoot)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgExpressionRoot::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgExpressionRoot() {
        return stringify::E_SgExpressionRoot();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 933
namespace stringify {
    const char* E_SgMinusOp(int64_t i) {
        switch (i) {
            case 0L: return "SgMinusOp_operand_i";
            default: return "";
        }
    }

    std::string E_SgMinusOp(int64_t i, const std::string &strip) {
        std::string s = E_SgMinusOp(i);
        if (s.empty())
            s = "(E_SgMinusOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgMinusOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgMinusOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgMinusOp(i);
        if (retval.empty()) {
            retval = "(E_SgMinusOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgMinusOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgMinusOp() {
        return stringify::E_SgMinusOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 936
namespace stringify {
    const char* E_SgUnaryAddOp(int64_t i) {
        switch (i) {
            case 0L: return "SgUnaryAddOp_operand_i";
            default: return "";
        }
    }

    std::string E_SgUnaryAddOp(int64_t i, const std::string &strip) {
        std::string s = E_SgUnaryAddOp(i);
        if (s.empty())
            s = "(E_SgUnaryAddOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUnaryAddOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUnaryAddOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUnaryAddOp(i);
        if (retval.empty()) {
            retval = "(E_SgUnaryAddOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUnaryAddOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUnaryAddOp() {
        return stringify::E_SgUnaryAddOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 939
namespace stringify {
    const char* E_SgNotOp(int64_t i) {
        switch (i) {
            case 0L: return "SgNotOp_operand_i";
            default: return "";
        }
    }

    std::string E_SgNotOp(int64_t i, const std::string &strip) {
        std::string s = E_SgNotOp(i);
        if (s.empty())
            s = "(E_SgNotOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgNotOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgNotOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgNotOp(i);
        if (retval.empty()) {
            retval = "(E_SgNotOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgNotOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgNotOp() {
        return stringify::E_SgNotOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 942
namespace stringify {
    const char* E_SgPointerDerefExp(int64_t i) {
        switch (i) {
            case 0L: return "SgPointerDerefExp_operand_i";
            default: return "";
        }
    }

    std::string E_SgPointerDerefExp(int64_t i, const std::string &strip) {
        std::string s = E_SgPointerDerefExp(i);
        if (s.empty())
            s = "(E_SgPointerDerefExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgPointerDerefExp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgPointerDerefExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgPointerDerefExp(i);
        if (retval.empty()) {
            retval = "(E_SgPointerDerefExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgPointerDerefExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgPointerDerefExp() {
        return stringify::E_SgPointerDerefExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 945
namespace stringify {
    const char* E_SgAddressOfOp(int64_t i) {
        switch (i) {
            case 0L: return "SgAddressOfOp_operand_i";
            default: return "";
        }
    }

    std::string E_SgAddressOfOp(int64_t i, const std::string &strip) {
        std::string s = E_SgAddressOfOp(i);
        if (s.empty())
            s = "(E_SgAddressOfOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAddressOfOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAddressOfOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAddressOfOp(i);
        if (retval.empty()) {
            retval = "(E_SgAddressOfOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAddressOfOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAddressOfOp() {
        return stringify::E_SgAddressOfOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 948
namespace stringify {
    const char* E_SgMinusMinusOp(int64_t i) {
        switch (i) {
            case 0L: return "SgMinusMinusOp_operand_i";
            default: return "";
        }
    }

    std::string E_SgMinusMinusOp(int64_t i, const std::string &strip) {
        std::string s = E_SgMinusMinusOp(i);
        if (s.empty())
            s = "(E_SgMinusMinusOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgMinusMinusOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgMinusMinusOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgMinusMinusOp(i);
        if (retval.empty()) {
            retval = "(E_SgMinusMinusOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgMinusMinusOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgMinusMinusOp() {
        return stringify::E_SgMinusMinusOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 951
namespace stringify {
    const char* E_SgPlusPlusOp(int64_t i) {
        switch (i) {
            case 0L: return "SgPlusPlusOp_operand_i";
            default: return "";
        }
    }

    std::string E_SgPlusPlusOp(int64_t i, const std::string &strip) {
        std::string s = E_SgPlusPlusOp(i);
        if (s.empty())
            s = "(E_SgPlusPlusOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgPlusPlusOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgPlusPlusOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgPlusPlusOp(i);
        if (retval.empty()) {
            retval = "(E_SgPlusPlusOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgPlusPlusOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgPlusPlusOp() {
        return stringify::E_SgPlusPlusOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 954
namespace stringify {
    const char* E_SgBitComplementOp(int64_t i) {
        switch (i) {
            case 0L: return "SgBitComplementOp_operand_i";
            default: return "";
        }
    }

    std::string E_SgBitComplementOp(int64_t i, const std::string &strip) {
        std::string s = E_SgBitComplementOp(i);
        if (s.empty())
            s = "(E_SgBitComplementOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgBitComplementOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgBitComplementOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgBitComplementOp(i);
        if (retval.empty()) {
            retval = "(E_SgBitComplementOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgBitComplementOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgBitComplementOp() {
        return stringify::E_SgBitComplementOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 957
namespace stringify {
    const char* E_SgCastExp(int64_t i) {
        switch (i) {
            case 0L: return "SgCastExp_operand_i";
            default: return "";
        }
    }

    std::string E_SgCastExp(int64_t i, const std::string &strip) {
        std::string s = E_SgCastExp(i);
        if (s.empty())
            s = "(E_SgCastExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgCastExp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgCastExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgCastExp(i);
        if (retval.empty()) {
            retval = "(E_SgCastExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgCastExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgCastExp() {
        return stringify::E_SgCastExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 960
namespace stringify {
    const char* E_SgThrowOp(int64_t i) {
        switch (i) {
            case 0L: return "SgThrowOp_operand_i";
            default: return "";
        }
    }

    std::string E_SgThrowOp(int64_t i, const std::string &strip) {
        std::string s = E_SgThrowOp(i);
        if (s.empty())
            s = "(E_SgThrowOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgThrowOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgThrowOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgThrowOp(i);
        if (retval.empty()) {
            retval = "(E_SgThrowOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgThrowOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgThrowOp() {
        return stringify::E_SgThrowOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 963
namespace stringify {
    const char* E_SgRealPartOp(int64_t i) {
        switch (i) {
            case 0L: return "SgRealPartOp_operand_i";
            default: return "";
        }
    }

    std::string E_SgRealPartOp(int64_t i, const std::string &strip) {
        std::string s = E_SgRealPartOp(i);
        if (s.empty())
            s = "(E_SgRealPartOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgRealPartOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgRealPartOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgRealPartOp(i);
        if (retval.empty()) {
            retval = "(E_SgRealPartOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgRealPartOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgRealPartOp() {
        return stringify::E_SgRealPartOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 966
namespace stringify {
    const char* E_SgImagPartOp(int64_t i) {
        switch (i) {
            case 0L: return "SgImagPartOp_operand_i";
            default: return "";
        }
    }

    std::string E_SgImagPartOp(int64_t i, const std::string &strip) {
        std::string s = E_SgImagPartOp(i);
        if (s.empty())
            s = "(E_SgImagPartOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgImagPartOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgImagPartOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgImagPartOp(i);
        if (retval.empty()) {
            retval = "(E_SgImagPartOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgImagPartOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgImagPartOp() {
        return stringify::E_SgImagPartOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 969
namespace stringify {
    const char* E_SgConjugateOp(int64_t i) {
        switch (i) {
            case 0L: return "SgConjugateOp_operand_i";
            default: return "";
        }
    }

    std::string E_SgConjugateOp(int64_t i, const std::string &strip) {
        std::string s = E_SgConjugateOp(i);
        if (s.empty())
            s = "(E_SgConjugateOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgConjugateOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgConjugateOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgConjugateOp(i);
        if (retval.empty()) {
            retval = "(E_SgConjugateOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgConjugateOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgConjugateOp() {
        return stringify::E_SgConjugateOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 972
namespace stringify {
    const char* E_SgUserDefinedUnaryOp(int64_t i) {
        switch (i) {
            case 0L: return "SgUserDefinedUnaryOp_operand_i";
            default: return "";
        }
    }

    std::string E_SgUserDefinedUnaryOp(int64_t i, const std::string &strip) {
        std::string s = E_SgUserDefinedUnaryOp(i);
        if (s.empty())
            s = "(E_SgUserDefinedUnaryOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUserDefinedUnaryOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUserDefinedUnaryOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUserDefinedUnaryOp(i);
        if (retval.empty()) {
            retval = "(E_SgUserDefinedUnaryOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUserDefinedUnaryOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUserDefinedUnaryOp() {
        return stringify::E_SgUserDefinedUnaryOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 975
namespace stringify {
    const char* E_SgMatrixTransposeOp(int64_t i) {
        switch (i) {
            case 0L: return "SgMatrixTransposeOp_operand_i";
            default: return "";
        }
    }

    std::string E_SgMatrixTransposeOp(int64_t i, const std::string &strip) {
        std::string s = E_SgMatrixTransposeOp(i);
        if (s.empty())
            s = "(E_SgMatrixTransposeOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgMatrixTransposeOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgMatrixTransposeOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgMatrixTransposeOp(i);
        if (retval.empty()) {
            retval = "(E_SgMatrixTransposeOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgMatrixTransposeOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgMatrixTransposeOp() {
        return stringify::E_SgMatrixTransposeOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 978
namespace stringify {
    const char* E_SgUnaryOp(int64_t i) {
        switch (i) {
            case 0L: return "SgUnaryOp_operand_i";
            default: return "";
        }
    }

    std::string E_SgUnaryOp(int64_t i, const std::string &strip) {
        std::string s = E_SgUnaryOp(i);
        if (s.empty())
            s = "(E_SgUnaryOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUnaryOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUnaryOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUnaryOp(i);
        if (retval.empty()) {
            retval = "(E_SgUnaryOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUnaryOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUnaryOp() {
        return stringify::E_SgUnaryOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 981
namespace stringify {
    const char* E_SgArrowExp(int64_t i) {
        switch (i) {
            case 0L: return "SgArrowExp_lhs_operand_i";
            case 1L: return "SgArrowExp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgArrowExp(int64_t i, const std::string &strip) {
        std::string s = E_SgArrowExp(i);
        if (s.empty())
            s = "(E_SgArrowExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgArrowExp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgArrowExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgArrowExp(i);
        if (retval.empty()) {
            retval = "(E_SgArrowExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgArrowExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgArrowExp() {
        return stringify::E_SgArrowExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 984
namespace stringify {
    const char* E_SgDotExp(int64_t i) {
        switch (i) {
            case 0L: return "SgDotExp_lhs_operand_i";
            case 1L: return "SgDotExp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgDotExp(int64_t i, const std::string &strip) {
        std::string s = E_SgDotExp(i);
        if (s.empty())
            s = "(E_SgDotExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgDotExp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgDotExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgDotExp(i);
        if (retval.empty()) {
            retval = "(E_SgDotExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgDotExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgDotExp() {
        return stringify::E_SgDotExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 987
namespace stringify {
    const char* E_SgDotStarOp(int64_t i) {
        switch (i) {
            case 0L: return "SgDotStarOp_lhs_operand_i";
            case 1L: return "SgDotStarOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgDotStarOp(int64_t i, const std::string &strip) {
        std::string s = E_SgDotStarOp(i);
        if (s.empty())
            s = "(E_SgDotStarOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgDotStarOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgDotStarOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgDotStarOp(i);
        if (retval.empty()) {
            retval = "(E_SgDotStarOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgDotStarOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgDotStarOp() {
        return stringify::E_SgDotStarOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 990
namespace stringify {
    const char* E_SgArrowStarOp(int64_t i) {
        switch (i) {
            case 0L: return "SgArrowStarOp_lhs_operand_i";
            case 1L: return "SgArrowStarOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgArrowStarOp(int64_t i, const std::string &strip) {
        std::string s = E_SgArrowStarOp(i);
        if (s.empty())
            s = "(E_SgArrowStarOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgArrowStarOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgArrowStarOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgArrowStarOp(i);
        if (retval.empty()) {
            retval = "(E_SgArrowStarOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgArrowStarOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgArrowStarOp() {
        return stringify::E_SgArrowStarOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 993
namespace stringify {
    const char* E_SgEqualityOp(int64_t i) {
        switch (i) {
            case 0L: return "SgEqualityOp_lhs_operand_i";
            case 1L: return "SgEqualityOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgEqualityOp(int64_t i, const std::string &strip) {
        std::string s = E_SgEqualityOp(i);
        if (s.empty())
            s = "(E_SgEqualityOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgEqualityOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgEqualityOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgEqualityOp(i);
        if (retval.empty()) {
            retval = "(E_SgEqualityOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgEqualityOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgEqualityOp() {
        return stringify::E_SgEqualityOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 996
namespace stringify {
    const char* E_SgLessThanOp(int64_t i) {
        switch (i) {
            case 0L: return "SgLessThanOp_lhs_operand_i";
            case 1L: return "SgLessThanOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgLessThanOp(int64_t i, const std::string &strip) {
        std::string s = E_SgLessThanOp(i);
        if (s.empty())
            s = "(E_SgLessThanOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgLessThanOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgLessThanOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgLessThanOp(i);
        if (retval.empty()) {
            retval = "(E_SgLessThanOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgLessThanOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgLessThanOp() {
        return stringify::E_SgLessThanOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 999
namespace stringify {
    const char* E_SgGreaterThanOp(int64_t i) {
        switch (i) {
            case 0L: return "SgGreaterThanOp_lhs_operand_i";
            case 1L: return "SgGreaterThanOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgGreaterThanOp(int64_t i, const std::string &strip) {
        std::string s = E_SgGreaterThanOp(i);
        if (s.empty())
            s = "(E_SgGreaterThanOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgGreaterThanOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgGreaterThanOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgGreaterThanOp(i);
        if (retval.empty()) {
            retval = "(E_SgGreaterThanOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgGreaterThanOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgGreaterThanOp() {
        return stringify::E_SgGreaterThanOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1002
namespace stringify {
    const char* E_SgNotEqualOp(int64_t i) {
        switch (i) {
            case 0L: return "SgNotEqualOp_lhs_operand_i";
            case 1L: return "SgNotEqualOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgNotEqualOp(int64_t i, const std::string &strip) {
        std::string s = E_SgNotEqualOp(i);
        if (s.empty())
            s = "(E_SgNotEqualOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgNotEqualOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgNotEqualOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgNotEqualOp(i);
        if (retval.empty()) {
            retval = "(E_SgNotEqualOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgNotEqualOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgNotEqualOp() {
        return stringify::E_SgNotEqualOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1005
namespace stringify {
    const char* E_SgLessOrEqualOp(int64_t i) {
        switch (i) {
            case 0L: return "SgLessOrEqualOp_lhs_operand_i";
            case 1L: return "SgLessOrEqualOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgLessOrEqualOp(int64_t i, const std::string &strip) {
        std::string s = E_SgLessOrEqualOp(i);
        if (s.empty())
            s = "(E_SgLessOrEqualOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgLessOrEqualOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgLessOrEqualOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgLessOrEqualOp(i);
        if (retval.empty()) {
            retval = "(E_SgLessOrEqualOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgLessOrEqualOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgLessOrEqualOp() {
        return stringify::E_SgLessOrEqualOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1008
namespace stringify {
    const char* E_SgGreaterOrEqualOp(int64_t i) {
        switch (i) {
            case 0L: return "SgGreaterOrEqualOp_lhs_operand_i";
            case 1L: return "SgGreaterOrEqualOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgGreaterOrEqualOp(int64_t i, const std::string &strip) {
        std::string s = E_SgGreaterOrEqualOp(i);
        if (s.empty())
            s = "(E_SgGreaterOrEqualOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgGreaterOrEqualOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgGreaterOrEqualOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgGreaterOrEqualOp(i);
        if (retval.empty()) {
            retval = "(E_SgGreaterOrEqualOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgGreaterOrEqualOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgGreaterOrEqualOp() {
        return stringify::E_SgGreaterOrEqualOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1011
namespace stringify {
    const char* E_SgAddOp(int64_t i) {
        switch (i) {
            case 0L: return "SgAddOp_lhs_operand_i";
            case 1L: return "SgAddOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgAddOp(int64_t i, const std::string &strip) {
        std::string s = E_SgAddOp(i);
        if (s.empty())
            s = "(E_SgAddOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAddOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAddOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAddOp(i);
        if (retval.empty()) {
            retval = "(E_SgAddOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAddOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAddOp() {
        return stringify::E_SgAddOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1014
namespace stringify {
    const char* E_SgSubtractOp(int64_t i) {
        switch (i) {
            case 0L: return "SgSubtractOp_lhs_operand_i";
            case 1L: return "SgSubtractOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgSubtractOp(int64_t i, const std::string &strip) {
        std::string s = E_SgSubtractOp(i);
        if (s.empty())
            s = "(E_SgSubtractOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgSubtractOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgSubtractOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgSubtractOp(i);
        if (retval.empty()) {
            retval = "(E_SgSubtractOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgSubtractOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgSubtractOp() {
        return stringify::E_SgSubtractOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1017
namespace stringify {
    const char* E_SgMultiplyOp(int64_t i) {
        switch (i) {
            case 0L: return "SgMultiplyOp_lhs_operand_i";
            case 1L: return "SgMultiplyOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgMultiplyOp(int64_t i, const std::string &strip) {
        std::string s = E_SgMultiplyOp(i);
        if (s.empty())
            s = "(E_SgMultiplyOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgMultiplyOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgMultiplyOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgMultiplyOp(i);
        if (retval.empty()) {
            retval = "(E_SgMultiplyOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgMultiplyOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgMultiplyOp() {
        return stringify::E_SgMultiplyOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1020
namespace stringify {
    const char* E_SgDivideOp(int64_t i) {
        switch (i) {
            case 0L: return "SgDivideOp_lhs_operand_i";
            case 1L: return "SgDivideOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgDivideOp(int64_t i, const std::string &strip) {
        std::string s = E_SgDivideOp(i);
        if (s.empty())
            s = "(E_SgDivideOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgDivideOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgDivideOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgDivideOp(i);
        if (retval.empty()) {
            retval = "(E_SgDivideOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgDivideOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgDivideOp() {
        return stringify::E_SgDivideOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1023
namespace stringify {
    const char* E_SgIntegerDivideOp(int64_t i) {
        switch (i) {
            case 0L: return "SgIntegerDivideOp_lhs_operand_i";
            case 1L: return "SgIntegerDivideOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgIntegerDivideOp(int64_t i, const std::string &strip) {
        std::string s = E_SgIntegerDivideOp(i);
        if (s.empty())
            s = "(E_SgIntegerDivideOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgIntegerDivideOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgIntegerDivideOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgIntegerDivideOp(i);
        if (retval.empty()) {
            retval = "(E_SgIntegerDivideOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgIntegerDivideOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgIntegerDivideOp() {
        return stringify::E_SgIntegerDivideOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1026
namespace stringify {
    const char* E_SgModOp(int64_t i) {
        switch (i) {
            case 0L: return "SgModOp_lhs_operand_i";
            case 1L: return "SgModOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgModOp(int64_t i, const std::string &strip) {
        std::string s = E_SgModOp(i);
        if (s.empty())
            s = "(E_SgModOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgModOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgModOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgModOp(i);
        if (retval.empty()) {
            retval = "(E_SgModOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgModOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgModOp() {
        return stringify::E_SgModOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1029
namespace stringify {
    const char* E_SgAndOp(int64_t i) {
        switch (i) {
            case 0L: return "SgAndOp_lhs_operand_i";
            case 1L: return "SgAndOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgAndOp(int64_t i, const std::string &strip) {
        std::string s = E_SgAndOp(i);
        if (s.empty())
            s = "(E_SgAndOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAndOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAndOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAndOp(i);
        if (retval.empty()) {
            retval = "(E_SgAndOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAndOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAndOp() {
        return stringify::E_SgAndOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1032
namespace stringify {
    const char* E_SgOrOp(int64_t i) {
        switch (i) {
            case 0L: return "SgOrOp_lhs_operand_i";
            case 1L: return "SgOrOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgOrOp(int64_t i, const std::string &strip) {
        std::string s = E_SgOrOp(i);
        if (s.empty())
            s = "(E_SgOrOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOrOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOrOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOrOp(i);
        if (retval.empty()) {
            retval = "(E_SgOrOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOrOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOrOp() {
        return stringify::E_SgOrOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1035
namespace stringify {
    const char* E_SgBitXorOp(int64_t i) {
        switch (i) {
            case 0L: return "SgBitXorOp_lhs_operand_i";
            case 1L: return "SgBitXorOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgBitXorOp(int64_t i, const std::string &strip) {
        std::string s = E_SgBitXorOp(i);
        if (s.empty())
            s = "(E_SgBitXorOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgBitXorOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgBitXorOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgBitXorOp(i);
        if (retval.empty()) {
            retval = "(E_SgBitXorOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgBitXorOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgBitXorOp() {
        return stringify::E_SgBitXorOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1038
namespace stringify {
    const char* E_SgBitAndOp(int64_t i) {
        switch (i) {
            case 0L: return "SgBitAndOp_lhs_operand_i";
            case 1L: return "SgBitAndOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgBitAndOp(int64_t i, const std::string &strip) {
        std::string s = E_SgBitAndOp(i);
        if (s.empty())
            s = "(E_SgBitAndOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgBitAndOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgBitAndOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgBitAndOp(i);
        if (retval.empty()) {
            retval = "(E_SgBitAndOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgBitAndOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgBitAndOp() {
        return stringify::E_SgBitAndOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1041
namespace stringify {
    const char* E_SgBitOrOp(int64_t i) {
        switch (i) {
            case 0L: return "SgBitOrOp_lhs_operand_i";
            case 1L: return "SgBitOrOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgBitOrOp(int64_t i, const std::string &strip) {
        std::string s = E_SgBitOrOp(i);
        if (s.empty())
            s = "(E_SgBitOrOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgBitOrOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgBitOrOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgBitOrOp(i);
        if (retval.empty()) {
            retval = "(E_SgBitOrOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgBitOrOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgBitOrOp() {
        return stringify::E_SgBitOrOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1044
namespace stringify {
    const char* E_SgBitEqvOp(int64_t i) {
        switch (i) {
            case 0L: return "SgBitEqvOp_lhs_operand_i";
            case 1L: return "SgBitEqvOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgBitEqvOp(int64_t i, const std::string &strip) {
        std::string s = E_SgBitEqvOp(i);
        if (s.empty())
            s = "(E_SgBitEqvOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgBitEqvOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgBitEqvOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgBitEqvOp(i);
        if (retval.empty()) {
            retval = "(E_SgBitEqvOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgBitEqvOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgBitEqvOp() {
        return stringify::E_SgBitEqvOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1047
namespace stringify {
    const char* E_SgCommaOpExp(int64_t i) {
        switch (i) {
            case 0L: return "SgCommaOpExp_lhs_operand_i";
            case 1L: return "SgCommaOpExp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgCommaOpExp(int64_t i, const std::string &strip) {
        std::string s = E_SgCommaOpExp(i);
        if (s.empty())
            s = "(E_SgCommaOpExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgCommaOpExp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgCommaOpExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgCommaOpExp(i);
        if (retval.empty()) {
            retval = "(E_SgCommaOpExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgCommaOpExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgCommaOpExp() {
        return stringify::E_SgCommaOpExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1050
namespace stringify {
    const char* E_SgLshiftOp(int64_t i) {
        switch (i) {
            case 0L: return "SgLshiftOp_lhs_operand_i";
            case 1L: return "SgLshiftOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgLshiftOp(int64_t i, const std::string &strip) {
        std::string s = E_SgLshiftOp(i);
        if (s.empty())
            s = "(E_SgLshiftOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgLshiftOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgLshiftOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgLshiftOp(i);
        if (retval.empty()) {
            retval = "(E_SgLshiftOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgLshiftOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgLshiftOp() {
        return stringify::E_SgLshiftOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1053
namespace stringify {
    const char* E_SgRshiftOp(int64_t i) {
        switch (i) {
            case 0L: return "SgRshiftOp_lhs_operand_i";
            case 1L: return "SgRshiftOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgRshiftOp(int64_t i, const std::string &strip) {
        std::string s = E_SgRshiftOp(i);
        if (s.empty())
            s = "(E_SgRshiftOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgRshiftOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgRshiftOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgRshiftOp(i);
        if (retval.empty()) {
            retval = "(E_SgRshiftOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgRshiftOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgRshiftOp() {
        return stringify::E_SgRshiftOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1056
namespace stringify {
    const char* E_SgPntrArrRefExp(int64_t i) {
        switch (i) {
            case 0L: return "SgPntrArrRefExp_lhs_operand_i";
            case 1L: return "SgPntrArrRefExp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgPntrArrRefExp(int64_t i, const std::string &strip) {
        std::string s = E_SgPntrArrRefExp(i);
        if (s.empty())
            s = "(E_SgPntrArrRefExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgPntrArrRefExp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgPntrArrRefExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgPntrArrRefExp(i);
        if (retval.empty()) {
            retval = "(E_SgPntrArrRefExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgPntrArrRefExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgPntrArrRefExp() {
        return stringify::E_SgPntrArrRefExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1059
namespace stringify {
    const char* E_SgScopeOp(int64_t i) {
        switch (i) {
            case 0L: return "SgScopeOp_lhs_operand_i";
            case 1L: return "SgScopeOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgScopeOp(int64_t i, const std::string &strip) {
        std::string s = E_SgScopeOp(i);
        if (s.empty())
            s = "(E_SgScopeOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgScopeOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgScopeOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgScopeOp(i);
        if (retval.empty()) {
            retval = "(E_SgScopeOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgScopeOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgScopeOp() {
        return stringify::E_SgScopeOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1062
namespace stringify {
    const char* E_SgAssignOp(int64_t i) {
        switch (i) {
            case 0L: return "SgAssignOp_lhs_operand_i";
            case 1L: return "SgAssignOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgAssignOp(int64_t i, const std::string &strip) {
        std::string s = E_SgAssignOp(i);
        if (s.empty())
            s = "(E_SgAssignOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAssignOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAssignOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAssignOp(i);
        if (retval.empty()) {
            retval = "(E_SgAssignOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAssignOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAssignOp() {
        return stringify::E_SgAssignOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1065
namespace stringify {
    const char* E_SgExponentiationOp(int64_t i) {
        switch (i) {
            case 0L: return "SgExponentiationOp_lhs_operand_i";
            case 1L: return "SgExponentiationOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgExponentiationOp(int64_t i, const std::string &strip) {
        std::string s = E_SgExponentiationOp(i);
        if (s.empty())
            s = "(E_SgExponentiationOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgExponentiationOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgExponentiationOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgExponentiationOp(i);
        if (retval.empty()) {
            retval = "(E_SgExponentiationOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgExponentiationOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgExponentiationOp() {
        return stringify::E_SgExponentiationOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1068
namespace stringify {
    const char* E_SgConcatenationOp(int64_t i) {
        switch (i) {
            case 0L: return "SgConcatenationOp_lhs_operand_i";
            case 1L: return "SgConcatenationOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgConcatenationOp(int64_t i, const std::string &strip) {
        std::string s = E_SgConcatenationOp(i);
        if (s.empty())
            s = "(E_SgConcatenationOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgConcatenationOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgConcatenationOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgConcatenationOp(i);
        if (retval.empty()) {
            retval = "(E_SgConcatenationOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgConcatenationOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgConcatenationOp() {
        return stringify::E_SgConcatenationOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1071
namespace stringify {
    const char* E_SgPointerAssignOp(int64_t i) {
        switch (i) {
            case 0L: return "SgPointerAssignOp_lhs_operand_i";
            case 1L: return "SgPointerAssignOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgPointerAssignOp(int64_t i, const std::string &strip) {
        std::string s = E_SgPointerAssignOp(i);
        if (s.empty())
            s = "(E_SgPointerAssignOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgPointerAssignOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgPointerAssignOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgPointerAssignOp(i);
        if (retval.empty()) {
            retval = "(E_SgPointerAssignOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgPointerAssignOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgPointerAssignOp() {
        return stringify::E_SgPointerAssignOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1074
namespace stringify {
    const char* E_SgUserDefinedBinaryOp(int64_t i) {
        switch (i) {
            case 0L: return "SgUserDefinedBinaryOp_lhs_operand_i";
            case 1L: return "SgUserDefinedBinaryOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgUserDefinedBinaryOp(int64_t i, const std::string &strip) {
        std::string s = E_SgUserDefinedBinaryOp(i);
        if (s.empty())
            s = "(E_SgUserDefinedBinaryOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUserDefinedBinaryOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUserDefinedBinaryOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUserDefinedBinaryOp(i);
        if (retval.empty()) {
            retval = "(E_SgUserDefinedBinaryOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUserDefinedBinaryOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUserDefinedBinaryOp() {
        return stringify::E_SgUserDefinedBinaryOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1077
namespace stringify {
    const char* E_SgPlusAssignOp(int64_t i) {
        switch (i) {
            case 0L: return "SgPlusAssignOp_lhs_operand_i";
            case 1L: return "SgPlusAssignOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgPlusAssignOp(int64_t i, const std::string &strip) {
        std::string s = E_SgPlusAssignOp(i);
        if (s.empty())
            s = "(E_SgPlusAssignOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgPlusAssignOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgPlusAssignOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgPlusAssignOp(i);
        if (retval.empty()) {
            retval = "(E_SgPlusAssignOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgPlusAssignOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgPlusAssignOp() {
        return stringify::E_SgPlusAssignOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1080
namespace stringify {
    const char* E_SgMinusAssignOp(int64_t i) {
        switch (i) {
            case 0L: return "SgMinusAssignOp_lhs_operand_i";
            case 1L: return "SgMinusAssignOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgMinusAssignOp(int64_t i, const std::string &strip) {
        std::string s = E_SgMinusAssignOp(i);
        if (s.empty())
            s = "(E_SgMinusAssignOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgMinusAssignOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgMinusAssignOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgMinusAssignOp(i);
        if (retval.empty()) {
            retval = "(E_SgMinusAssignOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgMinusAssignOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgMinusAssignOp() {
        return stringify::E_SgMinusAssignOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1083
namespace stringify {
    const char* E_SgAndAssignOp(int64_t i) {
        switch (i) {
            case 0L: return "SgAndAssignOp_lhs_operand_i";
            case 1L: return "SgAndAssignOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgAndAssignOp(int64_t i, const std::string &strip) {
        std::string s = E_SgAndAssignOp(i);
        if (s.empty())
            s = "(E_SgAndAssignOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAndAssignOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAndAssignOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAndAssignOp(i);
        if (retval.empty()) {
            retval = "(E_SgAndAssignOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAndAssignOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAndAssignOp() {
        return stringify::E_SgAndAssignOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1086
namespace stringify {
    const char* E_SgIorAssignOp(int64_t i) {
        switch (i) {
            case 0L: return "SgIorAssignOp_lhs_operand_i";
            case 1L: return "SgIorAssignOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgIorAssignOp(int64_t i, const std::string &strip) {
        std::string s = E_SgIorAssignOp(i);
        if (s.empty())
            s = "(E_SgIorAssignOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgIorAssignOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgIorAssignOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgIorAssignOp(i);
        if (retval.empty()) {
            retval = "(E_SgIorAssignOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgIorAssignOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgIorAssignOp() {
        return stringify::E_SgIorAssignOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1089
namespace stringify {
    const char* E_SgMultAssignOp(int64_t i) {
        switch (i) {
            case 0L: return "SgMultAssignOp_lhs_operand_i";
            case 1L: return "SgMultAssignOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgMultAssignOp(int64_t i, const std::string &strip) {
        std::string s = E_SgMultAssignOp(i);
        if (s.empty())
            s = "(E_SgMultAssignOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgMultAssignOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgMultAssignOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgMultAssignOp(i);
        if (retval.empty()) {
            retval = "(E_SgMultAssignOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgMultAssignOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgMultAssignOp() {
        return stringify::E_SgMultAssignOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1092
namespace stringify {
    const char* E_SgDivAssignOp(int64_t i) {
        switch (i) {
            case 0L: return "SgDivAssignOp_lhs_operand_i";
            case 1L: return "SgDivAssignOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgDivAssignOp(int64_t i, const std::string &strip) {
        std::string s = E_SgDivAssignOp(i);
        if (s.empty())
            s = "(E_SgDivAssignOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgDivAssignOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgDivAssignOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgDivAssignOp(i);
        if (retval.empty()) {
            retval = "(E_SgDivAssignOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgDivAssignOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgDivAssignOp() {
        return stringify::E_SgDivAssignOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1095
namespace stringify {
    const char* E_SgModAssignOp(int64_t i) {
        switch (i) {
            case 0L: return "SgModAssignOp_lhs_operand_i";
            case 1L: return "SgModAssignOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgModAssignOp(int64_t i, const std::string &strip) {
        std::string s = E_SgModAssignOp(i);
        if (s.empty())
            s = "(E_SgModAssignOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgModAssignOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgModAssignOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgModAssignOp(i);
        if (retval.empty()) {
            retval = "(E_SgModAssignOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgModAssignOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgModAssignOp() {
        return stringify::E_SgModAssignOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1098
namespace stringify {
    const char* E_SgXorAssignOp(int64_t i) {
        switch (i) {
            case 0L: return "SgXorAssignOp_lhs_operand_i";
            case 1L: return "SgXorAssignOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgXorAssignOp(int64_t i, const std::string &strip) {
        std::string s = E_SgXorAssignOp(i);
        if (s.empty())
            s = "(E_SgXorAssignOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgXorAssignOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgXorAssignOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgXorAssignOp(i);
        if (retval.empty()) {
            retval = "(E_SgXorAssignOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgXorAssignOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgXorAssignOp() {
        return stringify::E_SgXorAssignOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1101
namespace stringify {
    const char* E_SgLshiftAssignOp(int64_t i) {
        switch (i) {
            case 0L: return "SgLshiftAssignOp_lhs_operand_i";
            case 1L: return "SgLshiftAssignOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgLshiftAssignOp(int64_t i, const std::string &strip) {
        std::string s = E_SgLshiftAssignOp(i);
        if (s.empty())
            s = "(E_SgLshiftAssignOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgLshiftAssignOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgLshiftAssignOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgLshiftAssignOp(i);
        if (retval.empty()) {
            retval = "(E_SgLshiftAssignOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgLshiftAssignOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgLshiftAssignOp() {
        return stringify::E_SgLshiftAssignOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1104
namespace stringify {
    const char* E_SgRshiftAssignOp(int64_t i) {
        switch (i) {
            case 0L: return "SgRshiftAssignOp_lhs_operand_i";
            case 1L: return "SgRshiftAssignOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgRshiftAssignOp(int64_t i, const std::string &strip) {
        std::string s = E_SgRshiftAssignOp(i);
        if (s.empty())
            s = "(E_SgRshiftAssignOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgRshiftAssignOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgRshiftAssignOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgRshiftAssignOp(i);
        if (retval.empty()) {
            retval = "(E_SgRshiftAssignOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgRshiftAssignOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgRshiftAssignOp() {
        return stringify::E_SgRshiftAssignOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1107
namespace stringify {
    const char* E_SgIntegerDivideAssignOp(int64_t i) {
        switch (i) {
            case 0L: return "SgIntegerDivideAssignOp_lhs_operand_i";
            case 1L: return "SgIntegerDivideAssignOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgIntegerDivideAssignOp(int64_t i, const std::string &strip) {
        std::string s = E_SgIntegerDivideAssignOp(i);
        if (s.empty())
            s = "(E_SgIntegerDivideAssignOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgIntegerDivideAssignOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgIntegerDivideAssignOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgIntegerDivideAssignOp(i);
        if (retval.empty()) {
            retval = "(E_SgIntegerDivideAssignOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgIntegerDivideAssignOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgIntegerDivideAssignOp() {
        return stringify::E_SgIntegerDivideAssignOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1110
namespace stringify {
    const char* E_SgExponentiationAssignOp(int64_t i) {
        switch (i) {
            case 0L: return "SgExponentiationAssignOp_lhs_operand_i";
            case 1L: return "SgExponentiationAssignOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgExponentiationAssignOp(int64_t i, const std::string &strip) {
        std::string s = E_SgExponentiationAssignOp(i);
        if (s.empty())
            s = "(E_SgExponentiationAssignOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgExponentiationAssignOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgExponentiationAssignOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgExponentiationAssignOp(i);
        if (retval.empty()) {
            retval = "(E_SgExponentiationAssignOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgExponentiationAssignOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgExponentiationAssignOp() {
        return stringify::E_SgExponentiationAssignOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1113
namespace stringify {
    const char* E_SgCompoundAssignOp(int64_t i) {
        switch (i) {
            case 0L: return "SgCompoundAssignOp_lhs_operand_i";
            case 1L: return "SgCompoundAssignOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgCompoundAssignOp(int64_t i, const std::string &strip) {
        std::string s = E_SgCompoundAssignOp(i);
        if (s.empty())
            s = "(E_SgCompoundAssignOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgCompoundAssignOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgCompoundAssignOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgCompoundAssignOp(i);
        if (retval.empty()) {
            retval = "(E_SgCompoundAssignOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgCompoundAssignOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgCompoundAssignOp() {
        return stringify::E_SgCompoundAssignOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1116
namespace stringify {
    const char* E_SgMembershipOp(int64_t i) {
        switch (i) {
            case 0L: return "SgMembershipOp_lhs_operand_i";
            case 1L: return "SgMembershipOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgMembershipOp(int64_t i, const std::string &strip) {
        std::string s = E_SgMembershipOp(i);
        if (s.empty())
            s = "(E_SgMembershipOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgMembershipOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgMembershipOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgMembershipOp(i);
        if (retval.empty()) {
            retval = "(E_SgMembershipOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgMembershipOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgMembershipOp() {
        return stringify::E_SgMembershipOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1119
namespace stringify {
    const char* E_SgSpaceshipOp(int64_t i) {
        switch (i) {
            case 0L: return "SgSpaceshipOp_lhs_operand_i";
            case 1L: return "SgSpaceshipOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgSpaceshipOp(int64_t i, const std::string &strip) {
        std::string s = E_SgSpaceshipOp(i);
        if (s.empty())
            s = "(E_SgSpaceshipOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgSpaceshipOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgSpaceshipOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgSpaceshipOp(i);
        if (retval.empty()) {
            retval = "(E_SgSpaceshipOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgSpaceshipOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgSpaceshipOp() {
        return stringify::E_SgSpaceshipOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1122
namespace stringify {
    const char* E_SgNonMembershipOp(int64_t i) {
        switch (i) {
            case 0L: return "SgNonMembershipOp_lhs_operand_i";
            case 1L: return "SgNonMembershipOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgNonMembershipOp(int64_t i, const std::string &strip) {
        std::string s = E_SgNonMembershipOp(i);
        if (s.empty())
            s = "(E_SgNonMembershipOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgNonMembershipOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgNonMembershipOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgNonMembershipOp(i);
        if (retval.empty()) {
            retval = "(E_SgNonMembershipOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgNonMembershipOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgNonMembershipOp() {
        return stringify::E_SgNonMembershipOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1125
namespace stringify {
    const char* E_SgIsOp(int64_t i) {
        switch (i) {
            case 0L: return "SgIsOp_lhs_operand_i";
            case 1L: return "SgIsOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgIsOp(int64_t i, const std::string &strip) {
        std::string s = E_SgIsOp(i);
        if (s.empty())
            s = "(E_SgIsOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgIsOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgIsOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgIsOp(i);
        if (retval.empty()) {
            retval = "(E_SgIsOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgIsOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgIsOp() {
        return stringify::E_SgIsOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1128
namespace stringify {
    const char* E_SgIsNotOp(int64_t i) {
        switch (i) {
            case 0L: return "SgIsNotOp_lhs_operand_i";
            case 1L: return "SgIsNotOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgIsNotOp(int64_t i, const std::string &strip) {
        std::string s = E_SgIsNotOp(i);
        if (s.empty())
            s = "(E_SgIsNotOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgIsNotOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgIsNotOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgIsNotOp(i);
        if (retval.empty()) {
            retval = "(E_SgIsNotOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgIsNotOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgIsNotOp() {
        return stringify::E_SgIsNotOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1131
namespace stringify {
    const char* E_SgElementwiseMultiplyOp(int64_t i) {
        switch (i) {
            case 0L: return "SgElementwiseMultiplyOp_lhs_operand_i";
            case 1L: return "SgElementwiseMultiplyOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgElementwiseMultiplyOp(int64_t i, const std::string &strip) {
        std::string s = E_SgElementwiseMultiplyOp(i);
        if (s.empty())
            s = "(E_SgElementwiseMultiplyOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgElementwiseMultiplyOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgElementwiseMultiplyOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgElementwiseMultiplyOp(i);
        if (retval.empty()) {
            retval = "(E_SgElementwiseMultiplyOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgElementwiseMultiplyOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgElementwiseMultiplyOp() {
        return stringify::E_SgElementwiseMultiplyOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1134
namespace stringify {
    const char* E_SgElementwisePowerOp(int64_t i) {
        switch (i) {
            case 0L: return "SgElementwisePowerOp_lhs_operand_i";
            case 1L: return "SgElementwisePowerOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgElementwisePowerOp(int64_t i, const std::string &strip) {
        std::string s = E_SgElementwisePowerOp(i);
        if (s.empty())
            s = "(E_SgElementwisePowerOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgElementwisePowerOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgElementwisePowerOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgElementwisePowerOp(i);
        if (retval.empty()) {
            retval = "(E_SgElementwisePowerOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgElementwisePowerOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgElementwisePowerOp() {
        return stringify::E_SgElementwisePowerOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1137
namespace stringify {
    const char* E_SgElementwiseLeftDivideOp(int64_t i) {
        switch (i) {
            case 0L: return "SgElementwiseLeftDivideOp_lhs_operand_i";
            case 1L: return "SgElementwiseLeftDivideOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgElementwiseLeftDivideOp(int64_t i, const std::string &strip) {
        std::string s = E_SgElementwiseLeftDivideOp(i);
        if (s.empty())
            s = "(E_SgElementwiseLeftDivideOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgElementwiseLeftDivideOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgElementwiseLeftDivideOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgElementwiseLeftDivideOp(i);
        if (retval.empty()) {
            retval = "(E_SgElementwiseLeftDivideOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgElementwiseLeftDivideOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgElementwiseLeftDivideOp() {
        return stringify::E_SgElementwiseLeftDivideOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1140
namespace stringify {
    const char* E_SgElementwiseDivideOp(int64_t i) {
        switch (i) {
            case 0L: return "SgElementwiseDivideOp_lhs_operand_i";
            case 1L: return "SgElementwiseDivideOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgElementwiseDivideOp(int64_t i, const std::string &strip) {
        std::string s = E_SgElementwiseDivideOp(i);
        if (s.empty())
            s = "(E_SgElementwiseDivideOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgElementwiseDivideOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgElementwiseDivideOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgElementwiseDivideOp(i);
        if (retval.empty()) {
            retval = "(E_SgElementwiseDivideOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgElementwiseDivideOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgElementwiseDivideOp() {
        return stringify::E_SgElementwiseDivideOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1143
namespace stringify {
    const char* E_SgElementwiseAddOp(int64_t i) {
        switch (i) {
            case 0L: return "SgElementwiseAddOp_lhs_operand_i";
            case 1L: return "SgElementwiseAddOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgElementwiseAddOp(int64_t i, const std::string &strip) {
        std::string s = E_SgElementwiseAddOp(i);
        if (s.empty())
            s = "(E_SgElementwiseAddOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgElementwiseAddOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgElementwiseAddOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgElementwiseAddOp(i);
        if (retval.empty()) {
            retval = "(E_SgElementwiseAddOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgElementwiseAddOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgElementwiseAddOp() {
        return stringify::E_SgElementwiseAddOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1146
namespace stringify {
    const char* E_SgElementwiseSubtractOp(int64_t i) {
        switch (i) {
            case 0L: return "SgElementwiseSubtractOp_lhs_operand_i";
            case 1L: return "SgElementwiseSubtractOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgElementwiseSubtractOp(int64_t i, const std::string &strip) {
        std::string s = E_SgElementwiseSubtractOp(i);
        if (s.empty())
            s = "(E_SgElementwiseSubtractOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgElementwiseSubtractOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgElementwiseSubtractOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgElementwiseSubtractOp(i);
        if (retval.empty()) {
            retval = "(E_SgElementwiseSubtractOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgElementwiseSubtractOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgElementwiseSubtractOp() {
        return stringify::E_SgElementwiseSubtractOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1149
namespace stringify {
    const char* E_SgElementwiseOp(int64_t i) {
        switch (i) {
            case 0L: return "SgElementwiseOp_lhs_operand_i";
            case 1L: return "SgElementwiseOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgElementwiseOp(int64_t i, const std::string &strip) {
        std::string s = E_SgElementwiseOp(i);
        if (s.empty())
            s = "(E_SgElementwiseOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgElementwiseOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgElementwiseOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgElementwiseOp(i);
        if (retval.empty()) {
            retval = "(E_SgElementwiseOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgElementwiseOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgElementwiseOp() {
        return stringify::E_SgElementwiseOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1152
namespace stringify {
    const char* E_SgPowerOp(int64_t i) {
        switch (i) {
            case 0L: return "SgPowerOp_lhs_operand_i";
            case 1L: return "SgPowerOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgPowerOp(int64_t i, const std::string &strip) {
        std::string s = E_SgPowerOp(i);
        if (s.empty())
            s = "(E_SgPowerOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgPowerOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgPowerOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgPowerOp(i);
        if (retval.empty()) {
            retval = "(E_SgPowerOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgPowerOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgPowerOp() {
        return stringify::E_SgPowerOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1155
namespace stringify {
    const char* E_SgLeftDivideOp(int64_t i) {
        switch (i) {
            case 0L: return "SgLeftDivideOp_lhs_operand_i";
            case 1L: return "SgLeftDivideOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgLeftDivideOp(int64_t i, const std::string &strip) {
        std::string s = E_SgLeftDivideOp(i);
        if (s.empty())
            s = "(E_SgLeftDivideOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgLeftDivideOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgLeftDivideOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgLeftDivideOp(i);
        if (retval.empty()) {
            retval = "(E_SgLeftDivideOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgLeftDivideOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgLeftDivideOp() {
        return stringify::E_SgLeftDivideOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1158
namespace stringify {
    const char* E_SgSIMDAddOp(int64_t i) {
        switch (i) {
            case 0L: return "SgSIMDAddOp_lhs_operand_i";
            case 1L: return "SgSIMDAddOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgSIMDAddOp(int64_t i, const std::string &strip) {
        std::string s = E_SgSIMDAddOp(i);
        if (s.empty())
            s = "(E_SgSIMDAddOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgSIMDAddOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgSIMDAddOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgSIMDAddOp(i);
        if (retval.empty()) {
            retval = "(E_SgSIMDAddOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgSIMDAddOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgSIMDAddOp() {
        return stringify::E_SgSIMDAddOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1161
namespace stringify {
    const char* E_SgSIMDSubOp(int64_t i) {
        switch (i) {
            case 0L: return "SgSIMDSubOp_lhs_operand_i";
            case 1L: return "SgSIMDSubOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgSIMDSubOp(int64_t i, const std::string &strip) {
        std::string s = E_SgSIMDSubOp(i);
        if (s.empty())
            s = "(E_SgSIMDSubOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgSIMDSubOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgSIMDSubOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgSIMDSubOp(i);
        if (retval.empty()) {
            retval = "(E_SgSIMDSubOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgSIMDSubOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgSIMDSubOp() {
        return stringify::E_SgSIMDSubOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1164
namespace stringify {
    const char* E_SgSIMDMulOp(int64_t i) {
        switch (i) {
            case 0L: return "SgSIMDMulOp_lhs_operand_i";
            case 1L: return "SgSIMDMulOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgSIMDMulOp(int64_t i, const std::string &strip) {
        std::string s = E_SgSIMDMulOp(i);
        if (s.empty())
            s = "(E_SgSIMDMulOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgSIMDMulOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgSIMDMulOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgSIMDMulOp(i);
        if (retval.empty()) {
            retval = "(E_SgSIMDMulOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgSIMDMulOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgSIMDMulOp() {
        return stringify::E_SgSIMDMulOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1167
namespace stringify {
    const char* E_SgSIMDDivOp(int64_t i) {
        switch (i) {
            case 0L: return "SgSIMDDivOp_lhs_operand_i";
            case 1L: return "SgSIMDDivOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgSIMDDivOp(int64_t i, const std::string &strip) {
        std::string s = E_SgSIMDDivOp(i);
        if (s.empty())
            s = "(E_SgSIMDDivOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgSIMDDivOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgSIMDDivOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgSIMDDivOp(i);
        if (retval.empty()) {
            retval = "(E_SgSIMDDivOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgSIMDDivOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgSIMDDivOp() {
        return stringify::E_SgSIMDDivOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1170
namespace stringify {
    const char* E_SgSIMDFmaOp(int64_t i) {
        switch (i) {
            case 0L: return "SgSIMDFmaOp_lhs_operand_i";
            case 1L: return "SgSIMDFmaOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgSIMDFmaOp(int64_t i, const std::string &strip) {
        std::string s = E_SgSIMDFmaOp(i);
        if (s.empty())
            s = "(E_SgSIMDFmaOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgSIMDFmaOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgSIMDFmaOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgSIMDFmaOp(i);
        if (retval.empty()) {
            retval = "(E_SgSIMDFmaOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgSIMDFmaOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgSIMDFmaOp() {
        return stringify::E_SgSIMDFmaOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1173
namespace stringify {
    const char* E_SgSIMDBinaryOp(int64_t i) {
        switch (i) {
            case 0L: return "SgSIMDBinaryOp_lhs_operand_i";
            case 1L: return "SgSIMDBinaryOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgSIMDBinaryOp(int64_t i, const std::string &strip) {
        std::string s = E_SgSIMDBinaryOp(i);
        if (s.empty())
            s = "(E_SgSIMDBinaryOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgSIMDBinaryOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgSIMDBinaryOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgSIMDBinaryOp(i);
        if (retval.empty()) {
            retval = "(E_SgSIMDBinaryOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgSIMDBinaryOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgSIMDBinaryOp() {
        return stringify::E_SgSIMDBinaryOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1176
namespace stringify {
    const char* E_SgSIMDLoad(int64_t i) {
        switch (i) {
            case 0L: return "SgSIMDLoad_lhs_operand_i";
            case 1L: return "SgSIMDLoad_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgSIMDLoad(int64_t i, const std::string &strip) {
        std::string s = E_SgSIMDLoad(i);
        if (s.empty())
            s = "(E_SgSIMDLoad)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgSIMDLoad() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgSIMDLoad(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgSIMDLoad(i);
        if (retval.empty()) {
            retval = "(E_SgSIMDLoad)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgSIMDLoad::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgSIMDLoad() {
        return stringify::E_SgSIMDLoad();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1179
namespace stringify {
    const char* E_SgSIMDBroadcast(int64_t i) {
        switch (i) {
            case 0L: return "SgSIMDBroadcast_lhs_operand_i";
            case 1L: return "SgSIMDBroadcast_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgSIMDBroadcast(int64_t i, const std::string &strip) {
        std::string s = E_SgSIMDBroadcast(i);
        if (s.empty())
            s = "(E_SgSIMDBroadcast)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgSIMDBroadcast() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgSIMDBroadcast(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgSIMDBroadcast(i);
        if (retval.empty()) {
            retval = "(E_SgSIMDBroadcast)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgSIMDBroadcast::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgSIMDBroadcast() {
        return stringify::E_SgSIMDBroadcast();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1182
namespace stringify {
    const char* E_SgSIMDStore(int64_t i) {
        switch (i) {
            case 0L: return "SgSIMDStore_lhs_operand_i";
            case 1L: return "SgSIMDStore_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgSIMDStore(int64_t i, const std::string &strip) {
        std::string s = E_SgSIMDStore(i);
        if (s.empty())
            s = "(E_SgSIMDStore)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgSIMDStore() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgSIMDStore(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgSIMDStore(i);
        if (retval.empty()) {
            retval = "(E_SgSIMDStore)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgSIMDStore::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgSIMDStore() {
        return stringify::E_SgSIMDStore();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1185
namespace stringify {
    const char* E_SgSIMDPartialStore(int64_t i) {
        switch (i) {
            case 0L: return "SgSIMDPartialStore_lhs_operand_i";
            case 1L: return "SgSIMDPartialStore_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgSIMDPartialStore(int64_t i, const std::string &strip) {
        std::string s = E_SgSIMDPartialStore(i);
        if (s.empty())
            s = "(E_SgSIMDPartialStore)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgSIMDPartialStore() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgSIMDPartialStore(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgSIMDPartialStore(i);
        if (retval.empty()) {
            retval = "(E_SgSIMDPartialStore)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgSIMDPartialStore::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgSIMDPartialStore() {
        return stringify::E_SgSIMDPartialStore();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1188
namespace stringify {
    const char* E_SgSIMDScalarStore(int64_t i) {
        switch (i) {
            case 0L: return "SgSIMDScalarStore_lhs_operand_i";
            case 1L: return "SgSIMDScalarStore_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgSIMDScalarStore(int64_t i, const std::string &strip) {
        std::string s = E_SgSIMDScalarStore(i);
        if (s.empty())
            s = "(E_SgSIMDScalarStore)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgSIMDScalarStore() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgSIMDScalarStore(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgSIMDScalarStore(i);
        if (retval.empty()) {
            retval = "(E_SgSIMDScalarStore)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgSIMDScalarStore::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgSIMDScalarStore() {
        return stringify::E_SgSIMDScalarStore();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1191
namespace stringify {
    const char* E_SgSIMDGather(int64_t i) {
        switch (i) {
            case 0L: return "SgSIMDGather_lhs_operand_i";
            case 1L: return "SgSIMDGather_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgSIMDGather(int64_t i, const std::string &strip) {
        std::string s = E_SgSIMDGather(i);
        if (s.empty())
            s = "(E_SgSIMDGather)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgSIMDGather() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgSIMDGather(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgSIMDGather(i);
        if (retval.empty()) {
            retval = "(E_SgSIMDGather)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgSIMDGather::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgSIMDGather() {
        return stringify::E_SgSIMDGather();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1194
namespace stringify {
    const char* E_SgSIMDScatter(int64_t i) {
        switch (i) {
            case 0L: return "SgSIMDScatter_lhs_operand_i";
            case 1L: return "SgSIMDScatter_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgSIMDScatter(int64_t i, const std::string &strip) {
        std::string s = E_SgSIMDScatter(i);
        if (s.empty())
            s = "(E_SgSIMDScatter)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgSIMDScatter() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgSIMDScatter(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgSIMDScatter(i);
        if (retval.empty()) {
            retval = "(E_SgSIMDScatter)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgSIMDScatter::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgSIMDScatter() {
        return stringify::E_SgSIMDScatter();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1197
namespace stringify {
    const char* E_SgBinaryOp(int64_t i) {
        switch (i) {
            case 0L: return "SgBinaryOp_lhs_operand_i";
            case 1L: return "SgBinaryOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgBinaryOp(int64_t i, const std::string &strip) {
        std::string s = E_SgBinaryOp(i);
        if (s.empty())
            s = "(E_SgBinaryOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgBinaryOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgBinaryOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgBinaryOp(i);
        if (retval.empty()) {
            retval = "(E_SgBinaryOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgBinaryOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgBinaryOp() {
        return stringify::E_SgBinaryOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1200
namespace stringify {
    const char* E_SgListExp(int64_t i) {
        switch (i) {
            case 0L: return "SgListExp_expressions";
            default: return "";
        }
    }

    std::string E_SgListExp(int64_t i, const std::string &strip) {
        std::string s = E_SgListExp(i);
        if (s.empty())
            s = "(E_SgListExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgListExp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgListExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgListExp(i);
        if (retval.empty()) {
            retval = "(E_SgListExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgListExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgListExp() {
        return stringify::E_SgListExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1203
namespace stringify {
    const char* E_SgTupleExp(int64_t i) {
        switch (i) {
            case 0L: return "SgTupleExp_expressions";
            default: return "";
        }
    }

    std::string E_SgTupleExp(int64_t i, const std::string &strip) {
        std::string s = E_SgTupleExp(i);
        if (s.empty())
            s = "(E_SgTupleExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTupleExp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTupleExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTupleExp(i);
        if (retval.empty()) {
            retval = "(E_SgTupleExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTupleExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTupleExp() {
        return stringify::E_SgTupleExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1206
namespace stringify {
    const char* E_SgMatrixExp(int64_t i) {
        switch (i) {
            case 0L: return "SgMatrixExp_expressions";
            default: return "";
        }
    }

    std::string E_SgMatrixExp(int64_t i, const std::string &strip) {
        std::string s = E_SgMatrixExp(i);
        if (s.empty())
            s = "(E_SgMatrixExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgMatrixExp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgMatrixExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgMatrixExp(i);
        if (retval.empty()) {
            retval = "(E_SgMatrixExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgMatrixExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgMatrixExp() {
        return stringify::E_SgMatrixExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1209
namespace stringify {
    const char* E_SgExprListExp(int64_t i) {
        switch (i) {
            case 0L: return "SgExprListExp_expressions";
            default: return "";
        }
    }

    std::string E_SgExprListExp(int64_t i, const std::string &strip) {
        std::string s = E_SgExprListExp(i);
        if (s.empty())
            s = "(E_SgExprListExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgExprListExp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgExprListExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgExprListExp(i);
        if (retval.empty()) {
            retval = "(E_SgExprListExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgExprListExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgExprListExp() {
        return stringify::E_SgExprListExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1212
namespace stringify {
    const char* E_SgComplexVal(int64_t i) {
        switch (i) {
            case 0L: return "SgComplexVal_real_value";
            case 1L: return "SgComplexVal_imaginary_value";
            default: return "";
        }
    }

    std::string E_SgComplexVal(int64_t i, const std::string &strip) {
        std::string s = E_SgComplexVal(i);
        if (s.empty())
            s = "(E_SgComplexVal)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgComplexVal() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgComplexVal(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgComplexVal(i);
        if (retval.empty()) {
            retval = "(E_SgComplexVal)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgComplexVal::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgComplexVal() {
        return stringify::E_SgComplexVal();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1215
namespace stringify {
    const char* E_SgCudaKernelCallExp(int64_t i) {
        switch (i) {
            case 0L: return "SgCudaKernelCallExp_function";
            case 1L: return "SgCudaKernelCallExp_args";
            case 2L: return "SgCudaKernelCallExp_exec_config";
            default: return "";
        }
    }

    std::string E_SgCudaKernelCallExp(int64_t i, const std::string &strip) {
        std::string s = E_SgCudaKernelCallExp(i);
        if (s.empty())
            s = "(E_SgCudaKernelCallExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgCudaKernelCallExp() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgCudaKernelCallExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgCudaKernelCallExp(i);
        if (retval.empty()) {
            retval = "(E_SgCudaKernelCallExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgCudaKernelCallExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgCudaKernelCallExp() {
        return stringify::E_SgCudaKernelCallExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1218
namespace stringify {
    const char* E_SgFunctionCallExp(int64_t i) {
        switch (i) {
            case 0L: return "SgFunctionCallExp_function";
            case 1L: return "SgFunctionCallExp_args";
            default: return "";
        }
    }

    std::string E_SgFunctionCallExp(int64_t i, const std::string &strip) {
        std::string s = E_SgFunctionCallExp(i);
        if (s.empty())
            s = "(E_SgFunctionCallExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgFunctionCallExp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgFunctionCallExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgFunctionCallExp(i);
        if (retval.empty()) {
            retval = "(E_SgFunctionCallExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgFunctionCallExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgFunctionCallExp() {
        return stringify::E_SgFunctionCallExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1221
namespace stringify {
    const char* E_SgCallExpression(int64_t i) {
        switch (i) {
            case 0L: return "SgCallExpression_function";
            case 1L: return "SgCallExpression_args";
            default: return "";
        }
    }

    std::string E_SgCallExpression(int64_t i, const std::string &strip) {
        std::string s = E_SgCallExpression(i);
        if (s.empty())
            s = "(E_SgCallExpression)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgCallExpression() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgCallExpression(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgCallExpression(i);
        if (retval.empty()) {
            retval = "(E_SgCallExpression)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgCallExpression::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgCallExpression() {
        return stringify::E_SgCallExpression();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1224
namespace stringify {
    const char* E_SgSizeOfOp(int64_t i) {
        switch (i) {
            case 0L: return "SgSizeOfOp_operand_expr";
            default: return "";
        }
    }

    std::string E_SgSizeOfOp(int64_t i, const std::string &strip) {
        std::string s = E_SgSizeOfOp(i);
        if (s.empty())
            s = "(E_SgSizeOfOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgSizeOfOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgSizeOfOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgSizeOfOp(i);
        if (retval.empty()) {
            retval = "(E_SgSizeOfOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgSizeOfOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgSizeOfOp() {
        return stringify::E_SgSizeOfOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1227
namespace stringify {
    const char* E_SgUpcLocalsizeofExpression(int64_t i) {
        switch (i) {
            case 0L: return "SgUpcLocalsizeofExpression_expression";
            default: return "";
        }
    }

    std::string E_SgUpcLocalsizeofExpression(int64_t i, const std::string &strip) {
        std::string s = E_SgUpcLocalsizeofExpression(i);
        if (s.empty())
            s = "(E_SgUpcLocalsizeofExpression)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUpcLocalsizeofExpression() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUpcLocalsizeofExpression(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUpcLocalsizeofExpression(i);
        if (retval.empty()) {
            retval = "(E_SgUpcLocalsizeofExpression)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUpcLocalsizeofExpression::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUpcLocalsizeofExpression() {
        return stringify::E_SgUpcLocalsizeofExpression();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1230
namespace stringify {
    const char* E_SgUpcBlocksizeofExpression(int64_t i) {
        switch (i) {
            case 0L: return "SgUpcBlocksizeofExpression_expression";
            default: return "";
        }
    }

    std::string E_SgUpcBlocksizeofExpression(int64_t i, const std::string &strip) {
        std::string s = E_SgUpcBlocksizeofExpression(i);
        if (s.empty())
            s = "(E_SgUpcBlocksizeofExpression)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUpcBlocksizeofExpression() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUpcBlocksizeofExpression(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUpcBlocksizeofExpression(i);
        if (retval.empty()) {
            retval = "(E_SgUpcBlocksizeofExpression)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUpcBlocksizeofExpression::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUpcBlocksizeofExpression() {
        return stringify::E_SgUpcBlocksizeofExpression();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1233
namespace stringify {
    const char* E_SgUpcElemsizeofExpression(int64_t i) {
        switch (i) {
            case 0L: return "SgUpcElemsizeofExpression_expression";
            default: return "";
        }
    }

    std::string E_SgUpcElemsizeofExpression(int64_t i, const std::string &strip) {
        std::string s = E_SgUpcElemsizeofExpression(i);
        if (s.empty())
            s = "(E_SgUpcElemsizeofExpression)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUpcElemsizeofExpression() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUpcElemsizeofExpression(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUpcElemsizeofExpression(i);
        if (retval.empty()) {
            retval = "(E_SgUpcElemsizeofExpression)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUpcElemsizeofExpression::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUpcElemsizeofExpression() {
        return stringify::E_SgUpcElemsizeofExpression();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1236
namespace stringify {
    const char* E_SgTypeIdOp(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeIdOp_operand_expr";
            default: return "";
        }
    }

    std::string E_SgTypeIdOp(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeIdOp(i);
        if (s.empty())
            s = "(E_SgTypeIdOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeIdOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeIdOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeIdOp(i);
        if (retval.empty()) {
            retval = "(E_SgTypeIdOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeIdOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeIdOp() {
        return stringify::E_SgTypeIdOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1239
namespace stringify {
    const char* E_SgConditionalExp(int64_t i) {
        switch (i) {
            case 0L: return "SgConditionalExp_conditional_exp";
            case 1L: return "SgConditionalExp_true_exp";
            case 2L: return "SgConditionalExp_false_exp";
            default: return "";
        }
    }

    std::string E_SgConditionalExp(int64_t i, const std::string &strip) {
        std::string s = E_SgConditionalExp(i);
        if (s.empty())
            s = "(E_SgConditionalExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgConditionalExp() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgConditionalExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgConditionalExp(i);
        if (retval.empty()) {
            retval = "(E_SgConditionalExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgConditionalExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgConditionalExp() {
        return stringify::E_SgConditionalExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1242
namespace stringify {
    const char* E_SgNewExp(int64_t i) {
        switch (i) {
            case 0L: return "SgNewExp_placement_args";
            case 1L: return "SgNewExp_constructor_args";
            case 2L: return "SgNewExp_builtin_args";
            default: return "";
        }
    }

    std::string E_SgNewExp(int64_t i, const std::string &strip) {
        std::string s = E_SgNewExp(i);
        if (s.empty())
            s = "(E_SgNewExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgNewExp() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgNewExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgNewExp(i);
        if (retval.empty()) {
            retval = "(E_SgNewExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgNewExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgNewExp() {
        return stringify::E_SgNewExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1245
namespace stringify {
    const char* E_SgDeleteExp(int64_t i) {
        switch (i) {
            case 0L: return "SgDeleteExp_variable";
            default: return "";
        }
    }

    std::string E_SgDeleteExp(int64_t i, const std::string &strip) {
        std::string s = E_SgDeleteExp(i);
        if (s.empty())
            s = "(E_SgDeleteExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgDeleteExp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgDeleteExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgDeleteExp(i);
        if (retval.empty()) {
            retval = "(E_SgDeleteExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgDeleteExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgDeleteExp() {
        return stringify::E_SgDeleteExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1248
namespace stringify {
    const char* E_SgAggregateInitializer(int64_t i) {
        switch (i) {
            case 0L: return "SgAggregateInitializer_initializers";
            default: return "";
        }
    }

    std::string E_SgAggregateInitializer(int64_t i, const std::string &strip) {
        std::string s = E_SgAggregateInitializer(i);
        if (s.empty())
            s = "(E_SgAggregateInitializer)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAggregateInitializer() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAggregateInitializer(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAggregateInitializer(i);
        if (retval.empty()) {
            retval = "(E_SgAggregateInitializer)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAggregateInitializer::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAggregateInitializer() {
        return stringify::E_SgAggregateInitializer();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1251
namespace stringify {
    const char* E_SgCompoundInitializer(int64_t i) {
        switch (i) {
            case 0L: return "SgCompoundInitializer_initializers";
            default: return "";
        }
    }

    std::string E_SgCompoundInitializer(int64_t i, const std::string &strip) {
        std::string s = E_SgCompoundInitializer(i);
        if (s.empty())
            s = "(E_SgCompoundInitializer)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgCompoundInitializer() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgCompoundInitializer(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgCompoundInitializer(i);
        if (retval.empty()) {
            retval = "(E_SgCompoundInitializer)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgCompoundInitializer::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgCompoundInitializer() {
        return stringify::E_SgCompoundInitializer();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1254
namespace stringify {
    const char* E_SgConstructorInitializer(int64_t i) {
        switch (i) {
            case 0L: return "SgConstructorInitializer_args";
            default: return "";
        }
    }

    std::string E_SgConstructorInitializer(int64_t i, const std::string &strip) {
        std::string s = E_SgConstructorInitializer(i);
        if (s.empty())
            s = "(E_SgConstructorInitializer)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgConstructorInitializer() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgConstructorInitializer(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgConstructorInitializer(i);
        if (retval.empty()) {
            retval = "(E_SgConstructorInitializer)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgConstructorInitializer::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgConstructorInitializer() {
        return stringify::E_SgConstructorInitializer();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1257
namespace stringify {
    const char* E_SgAssignInitializer(int64_t i) {
        switch (i) {
            case 0L: return "SgAssignInitializer_operand_i";
            default: return "";
        }
    }

    std::string E_SgAssignInitializer(int64_t i, const std::string &strip) {
        std::string s = E_SgAssignInitializer(i);
        if (s.empty())
            s = "(E_SgAssignInitializer)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAssignInitializer() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAssignInitializer(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAssignInitializer(i);
        if (retval.empty()) {
            retval = "(E_SgAssignInitializer)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAssignInitializer::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAssignInitializer() {
        return stringify::E_SgAssignInitializer();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1260
namespace stringify {
    const char* E_SgDesignatedInitializer(int64_t i) {
        switch (i) {
            case 0L: return "SgDesignatedInitializer_designatorList";
            case 1L: return "SgDesignatedInitializer_memberInit";
            default: return "";
        }
    }

    std::string E_SgDesignatedInitializer(int64_t i, const std::string &strip) {
        std::string s = E_SgDesignatedInitializer(i);
        if (s.empty())
            s = "(E_SgDesignatedInitializer)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgDesignatedInitializer() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgDesignatedInitializer(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgDesignatedInitializer(i);
        if (retval.empty()) {
            retval = "(E_SgDesignatedInitializer)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgDesignatedInitializer::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgDesignatedInitializer() {
        return stringify::E_SgDesignatedInitializer();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1263
namespace stringify {
    const char* E_SgBracedInitializer(int64_t i) {
        switch (i) {
            case 0L: return "SgBracedInitializer_initializers";
            default: return "";
        }
    }

    std::string E_SgBracedInitializer(int64_t i, const std::string &strip) {
        std::string s = E_SgBracedInitializer(i);
        if (s.empty())
            s = "(E_SgBracedInitializer)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgBracedInitializer() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgBracedInitializer(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgBracedInitializer(i);
        if (retval.empty()) {
            retval = "(E_SgBracedInitializer)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgBracedInitializer::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgBracedInitializer() {
        return stringify::E_SgBracedInitializer();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1266
namespace stringify {
    const char* E_SgVarArgStartOp(int64_t i) {
        switch (i) {
            case 0L: return "SgVarArgStartOp_lhs_operand";
            case 1L: return "SgVarArgStartOp_rhs_operand";
            default: return "";
        }
    }

    std::string E_SgVarArgStartOp(int64_t i, const std::string &strip) {
        std::string s = E_SgVarArgStartOp(i);
        if (s.empty())
            s = "(E_SgVarArgStartOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgVarArgStartOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgVarArgStartOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgVarArgStartOp(i);
        if (retval.empty()) {
            retval = "(E_SgVarArgStartOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgVarArgStartOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgVarArgStartOp() {
        return stringify::E_SgVarArgStartOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1269
namespace stringify {
    const char* E_SgVarArgOp(int64_t i) {
        switch (i) {
            case 0L: return "SgVarArgOp_operand_expr";
            default: return "";
        }
    }

    std::string E_SgVarArgOp(int64_t i, const std::string &strip) {
        std::string s = E_SgVarArgOp(i);
        if (s.empty())
            s = "(E_SgVarArgOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgVarArgOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgVarArgOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgVarArgOp(i);
        if (retval.empty()) {
            retval = "(E_SgVarArgOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgVarArgOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgVarArgOp() {
        return stringify::E_SgVarArgOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1272
namespace stringify {
    const char* E_SgVarArgEndOp(int64_t i) {
        switch (i) {
            case 0L: return "SgVarArgEndOp_operand_expr";
            default: return "";
        }
    }

    std::string E_SgVarArgEndOp(int64_t i, const std::string &strip) {
        std::string s = E_SgVarArgEndOp(i);
        if (s.empty())
            s = "(E_SgVarArgEndOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgVarArgEndOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgVarArgEndOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgVarArgEndOp(i);
        if (retval.empty()) {
            retval = "(E_SgVarArgEndOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgVarArgEndOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgVarArgEndOp() {
        return stringify::E_SgVarArgEndOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1275
namespace stringify {
    const char* E_SgVarArgCopyOp(int64_t i) {
        switch (i) {
            case 0L: return "SgVarArgCopyOp_lhs_operand";
            case 1L: return "SgVarArgCopyOp_rhs_operand";
            default: return "";
        }
    }

    std::string E_SgVarArgCopyOp(int64_t i, const std::string &strip) {
        std::string s = E_SgVarArgCopyOp(i);
        if (s.empty())
            s = "(E_SgVarArgCopyOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgVarArgCopyOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgVarArgCopyOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgVarArgCopyOp(i);
        if (retval.empty()) {
            retval = "(E_SgVarArgCopyOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgVarArgCopyOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgVarArgCopyOp() {
        return stringify::E_SgVarArgCopyOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1278
namespace stringify {
    const char* E_SgVarArgStartOneOperandOp(int64_t i) {
        switch (i) {
            case 0L: return "SgVarArgStartOneOperandOp_operand_expr";
            default: return "";
        }
    }

    std::string E_SgVarArgStartOneOperandOp(int64_t i, const std::string &strip) {
        std::string s = E_SgVarArgStartOneOperandOp(i);
        if (s.empty())
            s = "(E_SgVarArgStartOneOperandOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgVarArgStartOneOperandOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgVarArgStartOneOperandOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgVarArgStartOneOperandOp(i);
        if (retval.empty()) {
            retval = "(E_SgVarArgStartOneOperandOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgVarArgStartOneOperandOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgVarArgStartOneOperandOp() {
        return stringify::E_SgVarArgStartOneOperandOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1281
namespace stringify {
    const char* E_SgSubscriptExpression(int64_t i) {
        switch (i) {
            case 0L: return "SgSubscriptExpression_lowerBound";
            case 1L: return "SgSubscriptExpression_upperBound";
            case 2L: return "SgSubscriptExpression_stride";
            default: return "";
        }
    }

    std::string E_SgSubscriptExpression(int64_t i, const std::string &strip) {
        std::string s = E_SgSubscriptExpression(i);
        if (s.empty())
            s = "(E_SgSubscriptExpression)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgSubscriptExpression() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgSubscriptExpression(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgSubscriptExpression(i);
        if (retval.empty()) {
            retval = "(E_SgSubscriptExpression)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgSubscriptExpression::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgSubscriptExpression() {
        return stringify::E_SgSubscriptExpression();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1284
namespace stringify {
    const char* E_SgImpliedDo(int64_t i) {
        switch (i) {
            case 0L: return "SgImpliedDo_do_var_initialization";
            case 1L: return "SgImpliedDo_last_val";
            case 2L: return "SgImpliedDo_increment";
            case 3L: return "SgImpliedDo_object_list";
            default: return "";
        }
    }

    std::string E_SgImpliedDo(int64_t i, const std::string &strip) {
        std::string s = E_SgImpliedDo(i);
        if (s.empty())
            s = "(E_SgImpliedDo)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgImpliedDo() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgImpliedDo(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgImpliedDo(i);
        if (retval.empty()) {
            retval = "(E_SgImpliedDo)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgImpliedDo::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgImpliedDo() {
        return stringify::E_SgImpliedDo();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1287
namespace stringify {
    const char* E_SgIOItemExpression(int64_t i) {
        switch (i) {
            case 0L: return "SgIOItemExpression_io_item";
            default: return "";
        }
    }

    std::string E_SgIOItemExpression(int64_t i, const std::string &strip) {
        std::string s = E_SgIOItemExpression(i);
        if (s.empty())
            s = "(E_SgIOItemExpression)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgIOItemExpression() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgIOItemExpression(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgIOItemExpression(i);
        if (retval.empty()) {
            retval = "(E_SgIOItemExpression)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgIOItemExpression::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgIOItemExpression() {
        return stringify::E_SgIOItemExpression();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1290
namespace stringify {
    const char* E_SgStatementExpression(int64_t i) {
        switch (i) {
            case 0L: return "SgStatementExpression_statement";
            default: return "";
        }
    }

    std::string E_SgStatementExpression(int64_t i, const std::string &strip) {
        std::string s = E_SgStatementExpression(i);
        if (s.empty())
            s = "(E_SgStatementExpression)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgStatementExpression() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgStatementExpression(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgStatementExpression(i);
        if (retval.empty()) {
            retval = "(E_SgStatementExpression)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgStatementExpression::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgStatementExpression() {
        return stringify::E_SgStatementExpression();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1293
namespace stringify {
    const char* E_SgAsmOp(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmOp_expression";
            default: return "";
        }
    }

    std::string E_SgAsmOp(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmOp(i);
        if (s.empty())
            s = "(E_SgAsmOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmOp(i);
        if (retval.empty()) {
            retval = "(E_SgAsmOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmOp() {
        return stringify::E_SgAsmOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1296
namespace stringify {
    const char* E_SgActualArgumentExpression(int64_t i) {
        switch (i) {
            case 0L: return "SgActualArgumentExpression_expression";
            default: return "";
        }
    }

    std::string E_SgActualArgumentExpression(int64_t i, const std::string &strip) {
        std::string s = E_SgActualArgumentExpression(i);
        if (s.empty())
            s = "(E_SgActualArgumentExpression)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgActualArgumentExpression() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgActualArgumentExpression(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgActualArgumentExpression(i);
        if (retval.empty()) {
            retval = "(E_SgActualArgumentExpression)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgActualArgumentExpression::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgActualArgumentExpression() {
        return stringify::E_SgActualArgumentExpression();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1299
namespace stringify {
    const char* E_SgUnknownArrayOrFunctionReference(int64_t i) {
        switch (i) {
            case 0L: return "SgUnknownArrayOrFunctionReference_named_reference";
            case 1L: return "SgUnknownArrayOrFunctionReference_expression_list";
            default: return "";
        }
    }

    std::string E_SgUnknownArrayOrFunctionReference(int64_t i, const std::string &strip) {
        std::string s = E_SgUnknownArrayOrFunctionReference(i);
        if (s.empty())
            s = "(E_SgUnknownArrayOrFunctionReference)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUnknownArrayOrFunctionReference() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUnknownArrayOrFunctionReference(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUnknownArrayOrFunctionReference(i);
        if (retval.empty()) {
            retval = "(E_SgUnknownArrayOrFunctionReference)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUnknownArrayOrFunctionReference::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUnknownArrayOrFunctionReference() {
        return stringify::E_SgUnknownArrayOrFunctionReference();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1302
namespace stringify {
    const char* E_SgCAFCoExpression(int64_t i) {
        switch (i) {
            case 0L: return "SgCAFCoExpression_referData";
            default: return "";
        }
    }

    std::string E_SgCAFCoExpression(int64_t i, const std::string &strip) {
        std::string s = E_SgCAFCoExpression(i);
        if (s.empty())
            s = "(E_SgCAFCoExpression)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgCAFCoExpression() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgCAFCoExpression(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgCAFCoExpression(i);
        if (retval.empty()) {
            retval = "(E_SgCAFCoExpression)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgCAFCoExpression::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgCAFCoExpression() {
        return stringify::E_SgCAFCoExpression();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1305
namespace stringify {
    const char* E_SgCudaKernelExecConfig(int64_t i) {
        switch (i) {
            case 0L: return "SgCudaKernelExecConfig_grid";
            case 1L: return "SgCudaKernelExecConfig_blocks";
            case 2L: return "SgCudaKernelExecConfig_shared";
            case 3L: return "SgCudaKernelExecConfig_stream";
            default: return "";
        }
    }

    std::string E_SgCudaKernelExecConfig(int64_t i, const std::string &strip) {
        std::string s = E_SgCudaKernelExecConfig(i);
        if (s.empty())
            s = "(E_SgCudaKernelExecConfig)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgCudaKernelExecConfig() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgCudaKernelExecConfig(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgCudaKernelExecConfig(i);
        if (retval.empty()) {
            retval = "(E_SgCudaKernelExecConfig)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgCudaKernelExecConfig::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgCudaKernelExecConfig() {
        return stringify::E_SgCudaKernelExecConfig();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1308
namespace stringify {
    const char* E_SgLambdaRefExp(int64_t i) {
        switch (i) {
            case 0L: return "SgLambdaRefExp_functionDeclaration";
            default: return "";
        }
    }

    std::string E_SgLambdaRefExp(int64_t i, const std::string &strip) {
        std::string s = E_SgLambdaRefExp(i);
        if (s.empty())
            s = "(E_SgLambdaRefExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgLambdaRefExp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgLambdaRefExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgLambdaRefExp(i);
        if (retval.empty()) {
            retval = "(E_SgLambdaRefExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgLambdaRefExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgLambdaRefExp() {
        return stringify::E_SgLambdaRefExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1311
namespace stringify {
    const char* E_SgDictionaryExp(int64_t i) {
        switch (i) {
            case 0L: return "SgDictionaryExp_key_datum_pairs";
            default: return "";
        }
    }

    std::string E_SgDictionaryExp(int64_t i, const std::string &strip) {
        std::string s = E_SgDictionaryExp(i);
        if (s.empty())
            s = "(E_SgDictionaryExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgDictionaryExp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgDictionaryExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgDictionaryExp(i);
        if (retval.empty()) {
            retval = "(E_SgDictionaryExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgDictionaryExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgDictionaryExp() {
        return stringify::E_SgDictionaryExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1314
namespace stringify {
    const char* E_SgKeyDatumPair(int64_t i) {
        switch (i) {
            case 0L: return "SgKeyDatumPair_key";
            case 1L: return "SgKeyDatumPair_datum";
            default: return "";
        }
    }

    std::string E_SgKeyDatumPair(int64_t i, const std::string &strip) {
        std::string s = E_SgKeyDatumPair(i);
        if (s.empty())
            s = "(E_SgKeyDatumPair)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgKeyDatumPair() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgKeyDatumPair(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgKeyDatumPair(i);
        if (retval.empty()) {
            retval = "(E_SgKeyDatumPair)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgKeyDatumPair::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgKeyDatumPair() {
        return stringify::E_SgKeyDatumPair();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1317
namespace stringify {
    const char* E_SgComprehension(int64_t i) {
        switch (i) {
            case 0L: return "SgComprehension_target";
            case 1L: return "SgComprehension_iter";
            case 2L: return "SgComprehension_filters";
            default: return "";
        }
    }

    std::string E_SgComprehension(int64_t i, const std::string &strip) {
        std::string s = E_SgComprehension(i);
        if (s.empty())
            s = "(E_SgComprehension)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgComprehension() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgComprehension(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgComprehension(i);
        if (retval.empty()) {
            retval = "(E_SgComprehension)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgComprehension::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgComprehension() {
        return stringify::E_SgComprehension();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1320
namespace stringify {
    const char* E_SgListComprehension(int64_t i) {
        switch (i) {
            case 0L: return "SgListComprehension_element";
            case 1L: return "SgListComprehension_generators";
            default: return "";
        }
    }

    std::string E_SgListComprehension(int64_t i, const std::string &strip) {
        std::string s = E_SgListComprehension(i);
        if (s.empty())
            s = "(E_SgListComprehension)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgListComprehension() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgListComprehension(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgListComprehension(i);
        if (retval.empty()) {
            retval = "(E_SgListComprehension)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgListComprehension::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgListComprehension() {
        return stringify::E_SgListComprehension();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1323
namespace stringify {
    const char* E_SgSetComprehension(int64_t i) {
        switch (i) {
            case 0L: return "SgSetComprehension_element";
            case 1L: return "SgSetComprehension_generators";
            default: return "";
        }
    }

    std::string E_SgSetComprehension(int64_t i, const std::string &strip) {
        std::string s = E_SgSetComprehension(i);
        if (s.empty())
            s = "(E_SgSetComprehension)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgSetComprehension() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgSetComprehension(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgSetComprehension(i);
        if (retval.empty()) {
            retval = "(E_SgSetComprehension)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgSetComprehension::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgSetComprehension() {
        return stringify::E_SgSetComprehension();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1326
namespace stringify {
    const char* E_SgDictionaryComprehension(int64_t i) {
        switch (i) {
            case 0L: return "SgDictionaryComprehension_element";
            case 1L: return "SgDictionaryComprehension_generators";
            default: return "";
        }
    }

    std::string E_SgDictionaryComprehension(int64_t i, const std::string &strip) {
        std::string s = E_SgDictionaryComprehension(i);
        if (s.empty())
            s = "(E_SgDictionaryComprehension)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgDictionaryComprehension() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgDictionaryComprehension(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgDictionaryComprehension(i);
        if (retval.empty()) {
            retval = "(E_SgDictionaryComprehension)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgDictionaryComprehension::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgDictionaryComprehension() {
        return stringify::E_SgDictionaryComprehension();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1329
namespace stringify {
    const char* E_SgNaryBooleanOp(int64_t i) {
        switch (i) {
            case 0L: return "SgNaryBooleanOp_operands";
            default: return "";
        }
    }

    std::string E_SgNaryBooleanOp(int64_t i, const std::string &strip) {
        std::string s = E_SgNaryBooleanOp(i);
        if (s.empty())
            s = "(E_SgNaryBooleanOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgNaryBooleanOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgNaryBooleanOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgNaryBooleanOp(i);
        if (retval.empty()) {
            retval = "(E_SgNaryBooleanOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgNaryBooleanOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgNaryBooleanOp() {
        return stringify::E_SgNaryBooleanOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1332
namespace stringify {
    const char* E_SgNaryComparisonOp(int64_t i) {
        switch (i) {
            case 0L: return "SgNaryComparisonOp_operands";
            default: return "";
        }
    }

    std::string E_SgNaryComparisonOp(int64_t i, const std::string &strip) {
        std::string s = E_SgNaryComparisonOp(i);
        if (s.empty())
            s = "(E_SgNaryComparisonOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgNaryComparisonOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgNaryComparisonOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgNaryComparisonOp(i);
        if (retval.empty()) {
            retval = "(E_SgNaryComparisonOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgNaryComparisonOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgNaryComparisonOp() {
        return stringify::E_SgNaryComparisonOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1335
namespace stringify {
    const char* E_SgNaryOp(int64_t i) {
        switch (i) {
            case 0L: return "SgNaryOp_operands";
            default: return "";
        }
    }

    std::string E_SgNaryOp(int64_t i, const std::string &strip) {
        std::string s = E_SgNaryOp(i);
        if (s.empty())
            s = "(E_SgNaryOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgNaryOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgNaryOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgNaryOp(i);
        if (retval.empty()) {
            retval = "(E_SgNaryOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgNaryOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgNaryOp() {
        return stringify::E_SgNaryOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1338
namespace stringify {
    const char* E_SgStringConversion(int64_t i) {
        switch (i) {
            case 0L: return "SgStringConversion_expression";
            default: return "";
        }
    }

    std::string E_SgStringConversion(int64_t i, const std::string &strip) {
        std::string s = E_SgStringConversion(i);
        if (s.empty())
            s = "(E_SgStringConversion)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgStringConversion() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgStringConversion(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgStringConversion(i);
        if (retval.empty()) {
            retval = "(E_SgStringConversion)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgStringConversion::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgStringConversion() {
        return stringify::E_SgStringConversion();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1341
namespace stringify {
    const char* E_SgYieldExpression(int64_t i) {
        switch (i) {
            case 0L: return "SgYieldExpression_value";
            default: return "";
        }
    }

    std::string E_SgYieldExpression(int64_t i, const std::string &strip) {
        std::string s = E_SgYieldExpression(i);
        if (s.empty())
            s = "(E_SgYieldExpression)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgYieldExpression() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgYieldExpression(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgYieldExpression(i);
        if (retval.empty()) {
            retval = "(E_SgYieldExpression)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgYieldExpression::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgYieldExpression() {
        return stringify::E_SgYieldExpression();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1344
namespace stringify {
    const char* E_SgAlignOfOp(int64_t i) {
        switch (i) {
            case 0L: return "SgAlignOfOp_operand_expr";
            default: return "";
        }
    }

    std::string E_SgAlignOfOp(int64_t i, const std::string &strip) {
        std::string s = E_SgAlignOfOp(i);
        if (s.empty())
            s = "(E_SgAlignOfOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAlignOfOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAlignOfOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAlignOfOp(i);
        if (retval.empty()) {
            retval = "(E_SgAlignOfOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAlignOfOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAlignOfOp() {
        return stringify::E_SgAlignOfOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1347
namespace stringify {
    const char* E_SgRangeExp(int64_t i) {
        switch (i) {
            case 0L: return "SgRangeExp_start";
            case 1L: return "SgRangeExp_end";
            case 2L: return "SgRangeExp_stride";
            default: return "";
        }
    }

    std::string E_SgRangeExp(int64_t i, const std::string &strip) {
        std::string s = E_SgRangeExp(i);
        if (s.empty())
            s = "(E_SgRangeExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgRangeExp() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgRangeExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgRangeExp(i);
        if (retval.empty()) {
            retval = "(E_SgRangeExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgRangeExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgRangeExp() {
        return stringify::E_SgRangeExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1350
namespace stringify {
    const char* E_SgFunctionParameterRefExp(int64_t i) {
        switch (i) {
            case 0L: return "SgFunctionParameterRefExp_parameter_expression";
            default: return "";
        }
    }

    std::string E_SgFunctionParameterRefExp(int64_t i, const std::string &strip) {
        std::string s = E_SgFunctionParameterRefExp(i);
        if (s.empty())
            s = "(E_SgFunctionParameterRefExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgFunctionParameterRefExp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgFunctionParameterRefExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgFunctionParameterRefExp(i);
        if (retval.empty()) {
            retval = "(E_SgFunctionParameterRefExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgFunctionParameterRefExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgFunctionParameterRefExp() {
        return stringify::E_SgFunctionParameterRefExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1353
namespace stringify {
    const char* E_SgLambdaExp(int64_t i) {
        switch (i) {
            case 0L: return "SgLambdaExp_lambda_capture_list";
            case 1L: return "SgLambdaExp_lambda_closure_class";
            case 2L: return "SgLambdaExp_lambda_function";
            default: return "";
        }
    }

    std::string E_SgLambdaExp(int64_t i, const std::string &strip) {
        std::string s = E_SgLambdaExp(i);
        if (s.empty())
            s = "(E_SgLambdaExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgLambdaExp() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgLambdaExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgLambdaExp(i);
        if (retval.empty()) {
            retval = "(E_SgLambdaExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgLambdaExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgLambdaExp() {
        return stringify::E_SgLambdaExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1356
namespace stringify {
    const char* E_SgNoexceptOp(int64_t i) {
        switch (i) {
            case 0L: return "SgNoexceptOp_operand_expr";
            default: return "";
        }
    }

    std::string E_SgNoexceptOp(int64_t i, const std::string &strip) {
        std::string s = E_SgNoexceptOp(i);
        if (s.empty())
            s = "(E_SgNoexceptOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgNoexceptOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgNoexceptOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgNoexceptOp(i);
        if (retval.empty()) {
            retval = "(E_SgNoexceptOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgNoexceptOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgNoexceptOp() {
        return stringify::E_SgNoexceptOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1359
namespace stringify {
    const char* E_SgFoldExpression(int64_t i) {
        switch (i) {
            case 0L: return "SgFoldExpression_operands";
            default: return "";
        }
    }

    std::string E_SgFoldExpression(int64_t i, const std::string &strip) {
        std::string s = E_SgFoldExpression(i);
        if (s.empty())
            s = "(E_SgFoldExpression)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgFoldExpression() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgFoldExpression(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgFoldExpression(i);
        if (retval.empty()) {
            retval = "(E_SgFoldExpression)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgFoldExpression::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgFoldExpression() {
        return stringify::E_SgFoldExpression();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1362
namespace stringify {
    const char* E_SgAwaitExpression(int64_t i) {
        switch (i) {
            case 0L: return "SgAwaitExpression_value";
            default: return "";
        }
    }

    std::string E_SgAwaitExpression(int64_t i, const std::string &strip) {
        std::string s = E_SgAwaitExpression(i);
        if (s.empty())
            s = "(E_SgAwaitExpression)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAwaitExpression() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAwaitExpression(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAwaitExpression(i);
        if (retval.empty()) {
            retval = "(E_SgAwaitExpression)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAwaitExpression::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAwaitExpression() {
        return stringify::E_SgAwaitExpression();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1365
namespace stringify {
    const char* E_SgChooseExpression(int64_t i) {
        switch (i) {
            case 0L: return "SgChooseExpression_value";
            default: return "";
        }
    }

    std::string E_SgChooseExpression(int64_t i, const std::string &strip) {
        std::string s = E_SgChooseExpression(i);
        if (s.empty())
            s = "(E_SgChooseExpression)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgChooseExpression() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgChooseExpression(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgChooseExpression(i);
        if (retval.empty()) {
            retval = "(E_SgChooseExpression)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgChooseExpression::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgChooseExpression() {
        return stringify::E_SgChooseExpression();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1368
namespace stringify {
    const char* E_SgNonrealSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgNonrealSymbol_declaration";
            default: return "";
        }
    }

    std::string E_SgNonrealSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgNonrealSymbol(i);
        if (s.empty())
            s = "(E_SgNonrealSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgNonrealSymbol() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgNonrealSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgNonrealSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgNonrealSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgNonrealSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgNonrealSymbol() {
        return stringify::E_SgNonrealSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1371
namespace stringify {
    const char* E_SgTemplateMemberFunctionSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateMemberFunctionSymbol_declaration";
            default: return "";
        }
    }

    std::string E_SgTemplateMemberFunctionSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateMemberFunctionSymbol(i);
        if (s.empty())
            s = "(E_SgTemplateMemberFunctionSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateMemberFunctionSymbol() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateMemberFunctionSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateMemberFunctionSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateMemberFunctionSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateMemberFunctionSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateMemberFunctionSymbol() {
        return stringify::E_SgTemplateMemberFunctionSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1374
namespace stringify {
    const char* E_SgMemberFunctionSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgMemberFunctionSymbol_declaration";
            default: return "";
        }
    }

    std::string E_SgMemberFunctionSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgMemberFunctionSymbol(i);
        if (s.empty())
            s = "(E_SgMemberFunctionSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgMemberFunctionSymbol() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgMemberFunctionSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgMemberFunctionSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgMemberFunctionSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgMemberFunctionSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgMemberFunctionSymbol() {
        return stringify::E_SgMemberFunctionSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1377
namespace stringify {
    const char* E_SgTemplateFunctionSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateFunctionSymbol_declaration";
            default: return "";
        }
    }

    std::string E_SgTemplateFunctionSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateFunctionSymbol(i);
        if (s.empty())
            s = "(E_SgTemplateFunctionSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateFunctionSymbol() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateFunctionSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateFunctionSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateFunctionSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateFunctionSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateFunctionSymbol() {
        return stringify::E_SgTemplateFunctionSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1380
namespace stringify {
    const char* E_SgRenameSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgRenameSymbol_declaration";
            case 1L: return "SgRenameSymbol_original_symbol";
            default: return "";
        }
    }

    std::string E_SgRenameSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgRenameSymbol(i);
        if (s.empty())
            s = "(E_SgRenameSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgRenameSymbol() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgRenameSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgRenameSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgRenameSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgRenameSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgRenameSymbol() {
        return stringify::E_SgRenameSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1383
namespace stringify {
    const char* E_SgFunctionSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgFunctionSymbol_declaration";
            default: return "";
        }
    }

    std::string E_SgFunctionSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgFunctionSymbol(i);
        if (s.empty())
            s = "(E_SgFunctionSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgFunctionSymbol() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgFunctionSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgFunctionSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgFunctionSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgFunctionSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgFunctionSymbol() {
        return stringify::E_SgFunctionSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1386
namespace stringify {
    const char* E_SgTemplateClassSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateClassSymbol_declaration";
            default: return "";
        }
    }

    std::string E_SgTemplateClassSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateClassSymbol(i);
        if (s.empty())
            s = "(E_SgTemplateClassSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateClassSymbol() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateClassSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateClassSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateClassSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateClassSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateClassSymbol() {
        return stringify::E_SgTemplateClassSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1389
namespace stringify {
    const char* E_SgClassSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgClassSymbol_declaration";
            default: return "";
        }
    }

    std::string E_SgClassSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgClassSymbol(i);
        if (s.empty())
            s = "(E_SgClassSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgClassSymbol() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgClassSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgClassSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgClassSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgClassSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgClassSymbol() {
        return stringify::E_SgClassSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1392
namespace stringify {
    const char* E_SgTemplateSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateSymbol_declaration";
            default: return "";
        }
    }

    std::string E_SgTemplateSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateSymbol(i);
        if (s.empty())
            s = "(E_SgTemplateSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateSymbol() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateSymbol() {
        return stringify::E_SgTemplateSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1395
namespace stringify {
    const char* E_SgEnumSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgEnumSymbol_declaration";
            default: return "";
        }
    }

    std::string E_SgEnumSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgEnumSymbol(i);
        if (s.empty())
            s = "(E_SgEnumSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgEnumSymbol() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgEnumSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgEnumSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgEnumSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgEnumSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgEnumSymbol() {
        return stringify::E_SgEnumSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1398
namespace stringify {
    const char* E_SgTemplateTypedefSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateTypedefSymbol_declaration";
            default: return "";
        }
    }

    std::string E_SgTemplateTypedefSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateTypedefSymbol(i);
        if (s.empty())
            s = "(E_SgTemplateTypedefSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateTypedefSymbol() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateTypedefSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateTypedefSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateTypedefSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateTypedefSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateTypedefSymbol() {
        return stringify::E_SgTemplateTypedefSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1401
namespace stringify {
    const char* E_SgTypedefSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgTypedefSymbol_declaration";
            default: return "";
        }
    }

    std::string E_SgTypedefSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgTypedefSymbol(i);
        if (s.empty())
            s = "(E_SgTypedefSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypedefSymbol() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypedefSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypedefSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgTypedefSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypedefSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypedefSymbol() {
        return stringify::E_SgTypedefSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1404
namespace stringify {
    const char* E_SgLabelSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgLabelSymbol_declaration";
            default: return "";
        }
    }

    std::string E_SgLabelSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgLabelSymbol(i);
        if (s.empty())
            s = "(E_SgLabelSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgLabelSymbol() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgLabelSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgLabelSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgLabelSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgLabelSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgLabelSymbol() {
        return stringify::E_SgLabelSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1407
namespace stringify {
    const char* E_SgNamespaceSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgNamespaceSymbol_declaration";
            case 1L: return "SgNamespaceSymbol_aliasDeclaration";
            default: return "";
        }
    }

    std::string E_SgNamespaceSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgNamespaceSymbol(i);
        if (s.empty())
            s = "(E_SgNamespaceSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgNamespaceSymbol() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgNamespaceSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgNamespaceSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgNamespaceSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgNamespaceSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgNamespaceSymbol() {
        return stringify::E_SgNamespaceSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1410
namespace stringify {
    const char* E_SgModuleSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgModuleSymbol_declaration";
            default: return "";
        }
    }

    std::string E_SgModuleSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgModuleSymbol(i);
        if (s.empty())
            s = "(E_SgModuleSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgModuleSymbol() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgModuleSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgModuleSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgModuleSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgModuleSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgModuleSymbol() {
        return stringify::E_SgModuleSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// -build/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1413
namespace stringify {
    const char* E_SgAliasSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgAliasSymbol_alias";
            default: return "";
        }
    }

    std::string E_SgAliasSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgAliasSymbol(i);
        if (s.empty())
            s = "(E_SgAliasSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAliasSymbol() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAliasSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAliasSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgAliasSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAliasSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAliasSymbol() {
        return stringify::E_SgAliasSymbol();
    }
}

