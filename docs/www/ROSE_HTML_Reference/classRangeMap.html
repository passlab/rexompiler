<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROSE: RangeMap&lt; R, T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="ROSE"/>
<link href="roseDoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ROSE
   &#160;<span id="projectnumber">0.11.96.11</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,true,'search.html','Search');
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classRangeMap-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">RangeMap&lt; R, T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><h3>template&lt;class R, class T = RangeMapVoid&lt;R&gt;&gt;<br />
class RangeMap&lt; R, T &gt;</h3>

<p>A container of ranges, somewhat like a set. </p>
<p>The container is able to hold non-overlapping ranges, each of which has some associated value attached to it. Arbitrary ranges can be inserted and erased from the <a class="el" href="classRangeMap.html" title="A container of ranges, somewhat like a set.">RangeMap</a> without regard to the ranges that are present in the map, since this class can merge and split values (through methods defined on the value) as necessary in order to maintain the non-overlapping invariant. Every attempt was made to optimize this class for storage and execution efficiency and usability. The interface is similar to the std::map interface.</p>
<p>In the simple case, when no data is attached to the ranges in the map, the <a class="el" href="classRangeMap.html" title="A container of ranges, somewhat like a set.">RangeMap</a> acts somewhat like an std::set with the following differences: </p><ul>
<li>
The iterator points to a pair whose <code>first</code> member is a <a class="el" href="classRange.html" title="A contiguous range of values.">Range</a> (the second member is a <a class="el" href="classRangeMapVoid.html" title="Value type for a RangeMap with no useful data attached to the ranges.">RangeMapVoid</a> instance with no useful data). </li>
<li>
The <a class="el" href="classRangeMap.html" title="A container of ranges, somewhat like a set.">RangeMap</a> uses much less memory than an std::set when the members are mostly contiguous. </li>
<li>
The <a class="el" href="classRangeMap.html#a3fd9ee5ddde9ab9a00270a47ac2a6055" title="Find the range containing specified value.">find()</a> method is faster when members are mostly contiguous. Both are O(log N) but N is much smaller for a <a class="el" href="classRangeMap.html" title="A container of ranges, somewhat like a set.">RangeMap</a> than an std::set due to the compression factor. </li>
</ul>
<p>Here's an example of using the <a class="el" href="classRangeMap.html" title="A container of ranges, somewhat like a set.">RangeMap</a> as a set. For every CPU instruction in a binary specimen, it adds the addresses of the instruction to the set. In some architectures, such as x86, the instructions might overlap; this approach correctly handles that.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>InstructionAddresses: <span class="keyword">public</span> <a class="code" href="classAstSimpleProcessing.html">AstSimpleProcessing</a> {</div>
<div class="line">    <span class="keyword">typedef</span> <a class="code" href="classRange.html">Range&lt;rose_addr_t&gt;</a> AddressRange;</div>
<div class="line">    <a class="code" href="classRangeMap.html">RangeMap&lt;AddressRange&gt;</a> <a class="code" href="namespaceSawyer_1_1Container_1_1BitVectorSupport.html#a6a1434bde1bc4974b3224a9856a352b0">set</a>;</div>
<div class="line">    <span class="keywordtype">void</span> visit(<a class="code" href="classSgNode.html">SgNode</a> *node) {</div>
<div class="line">        SgAsmInstruction *insn = isSgAsmInstruction(node);</div>
<div class="line">        <span class="keywordflow">if</span> (insn!=NULL) {</div>
<div class="line">            rose_addr_t start = insn-&gt;get_address();</div>
<div class="line">            <span class="keywordtype">size_t</span> <a class="code" href="classRangeMap.html#a45427e339290e450ce2ae77c971c9095">size</a> = insn-&gt;get_size();</div>
<div class="line">            <a class="code" href="namespaceSawyer_1_1Container_1_1BitVectorSupport.html#a6a1434bde1bc4974b3224a9856a352b0">set</a>.insert(AddressRange(start, <a class="code" href="classRangeMap.html#a45427e339290e450ce2ae77c971c9095">size</a>));</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">} instruction_addresses;</div>
<div class="line">instruction_addresses.traverse(project, preorder);</div>
<div class="line">std::cout &lt;&lt;<span class="stringliteral">&quot;Instructions occupy &quot;</span> &lt;&lt;instruction_addresses.set.size() &lt;&lt;<span class="stringliteral">&quot; bytes:\n&quot;</span></div>
<div class="line">          &lt;&lt;instruction_addresses.set;</div>
</div><!-- fragment --><p>A more complex example is using a <a class="el" href="classRangeMap.html" title="A container of ranges, somewhat like a set.">RangeMap</a> to store a value with each range. A simple example follows, where we want to build a <a class="el" href="classRangeMap.html" title="A container of ranges, somewhat like a set.">RangeMap</a> that associates any address with the function that owns that address, even when functions are discontiguous in the address space. The first step is to define the value type for the <a class="el" href="classRangeMap.html" title="A container of ranges, somewhat like a set.">RangeMap</a> we'll be using to store this:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="classRange.html">Range&lt;rose_addr_t&gt;</a> AddressRange;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>FunctionRangeMapValue: <span class="keyword">public</span> <a class="code" href="classRangeMapValue.html">RangeMapValue</a>&lt;AddressRange, SgAsmFunction*&gt; {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    FunctionRangeMapValue(): public <a class="code" href="classRangeMapValue.html">RangeMapValue</a>&lt;AddressRange, SgAsmFunction*&gt;(NULL) {}</div>
<div class="line">    FunctionRangeMapValue(<a class="code" href="classFunction.html">Function</a> *f): public <a class="code" href="classRangeMapValue.html">RangeMapValue</a>&lt;AddressRange, SgAsmFunction*&gt;(f) {}</div>
<div class="line"> </div>
<div class="line">    FunctionRangeMapValue <a class="code" href="namespaceRose_1_1StringUtility.html#abeb29cbfa6cea9b3c9cd3c1481a5c79a">split</a>(<span class="keyword">const</span> AddressRange&amp;, <span class="keyword">const</span> AddressRange::Value&amp;) {</div>
<div class="line">        <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="classRangeMap.html#af54fdd767a5bcbbba97ebcba8b40ef0d">print</a>(std::ostream &amp;o)<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordflow">if</span> (NULL==value) {</div>
<div class="line">            o &lt;&lt;<span class="stringliteral">&quot;(null)&quot;</span>;</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            o &lt;&lt;<span class="stringliteral">&quot;F&quot;</span> &lt;&lt;StringUtility::addrToString(<a class="code" href="namespaceSawyer_1_1Container_1_1BitVectorSupport.html#a98b33c1888d241c1ef777bcef0eacc3c">get</a>()-&gt;entry_va);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classRangeMap.html">RangeMap&lt;AddressRange, FunctionRangeMapValue&gt;</a> FunctionRangeMap; </div>
</div><!-- fragment --><p>Define an AST traversal add each instruction to the <a class="el" href="classRangeMap.html" title="A container of ranges, somewhat like a set.">RangeMap</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>FindInstructions: <span class="keyword">public</span> <a class="code" href="classAstSimpleProcessing.html">AstSimpleProcessing</a> {</div>
<div class="line">    FunctionRangeMap ranges;</div>
<div class="line">    <span class="keywordtype">void</span> visit(<a class="code" href="classSgNode.html">SgNode</a> *node) {</div>
<div class="line">        SgAsmInstruction *insn = isSgAsmInstruction(node);</div>
<div class="line">        SgAsmFunction *func = SageInterface::getEnclosingNode&lt;SgAsmFunction&gt;(insn);</div>
<div class="line">        <span class="keywordflow">if</span> (insn &amp;&amp; func) {</div>
<div class="line">            rose_addr_t start = insn-&gt;get_address();</div>
<div class="line">            <span class="keywordtype">size_t</span> <a class="code" href="classRangeMap.html#a45427e339290e450ce2ae77c971c9095">size</a> = insn-&gt;get_size();</div>
<div class="line">            ranges.insert(AddressRange(start, <a class="code" href="classRangeMap.html#a45427e339290e450ce2ae77c971c9095">size</a>), func);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p>Finally, traverse the AST and print the result. Because <a class="el" href="classRangeMap.html" title="A container of ranges, somewhat like a set.">RangeMap</a> merges adjacent ranges when possible, the output will contain the fewest number of ranges needed to describe the entire address space that's assigned to functions. Note that it's possible for two or more functions to "own" the same part of the address space if their instructions overlap, but since we defined our <a class="el" href="classRangeMap.html" title="A container of ranges, somewhat like a set.">RangeMap</a> to hold only one function pointer per address we'll see only the function that was added last for overlapping ranges.</p>
<div class="fragment"><div class="line">FindInstructions insn_finder;</div>
<div class="line">insn_finder.traverse(interpretation, preorder);</div>
<div class="line">o &lt;&lt;insn_finder.ranges;</div>
</div><!-- fragment --><p>The <a class="el" href="classRangeMap.html" title="A container of ranges, somewhat like a set.">RangeMap</a> class template can also be specialized to hold more complex values. The value type defines how ranges can be merged and split. <a class="el" href="classRangeMap.html" title="A container of ranges, somewhat like a set.">RangeMap</a> value types must implement the interface described for <a class="el" href="classRangeMapVoid.html" title="Value type for a RangeMap with no useful data attached to the ranges.">RangeMapVoid</a>. Another example of a value type is <a class="el" href="classRangeMapValue.html" title="Scalar value type for a RangeMap.">RangeMapValue</a>, that holds a simple scalar value and determines "mergeabiliy" and "splitability" based on the equality operator. Eventually, MemoryMap might also be rewritten in terms of <a class="el" href="classRangeMap.html" title="A container of ranges, somewhat like a set.">RangeMap</a>, and will have much more complex rules for merging, splitting, truncating, and removing. </p>

<p class="definition">Definition at line <a class="el" href="rangemap_8h_source.html#l00852">852</a> of file <a class="el" href="rangemap_8h_source.html">rangemap.h</a>.</p>
</div>
<p><code>#include &lt;<a class="el" href="rangemap_8h_source.html">roseSupport/rangemap.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for RangeMap&lt; R, T &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classRangeMap__coll__graph.png" border="0" usemap="#RangeMap_3_01R_00_01T_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="RangeMap_3_01R_00_01T_01_4_coll__map" id="RangeMap_3_01R_00_01T_01_4_coll__map">
<area shape="rect" title="A container of ranges, somewhat like a set." alt="" coords="21,109,156,136"/>
<area shape="rect" title=" " alt="" coords="5,5,172,47"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRangeMap_1_1RangeCompare.html">RangeCompare</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value attached to each range in this <a class="el" href="classRangeMap.html" title="A container of ranges, somewhat like a set.">RangeMap</a>.  <a href="structRangeMap_1_1RangeCompare.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:acdbc3a9ee1147e598215bda2ac6f5dd8"><td class="memItemLeft" align="right" valign="top"><a id="acdbc3a9ee1147e598215bda2ac6f5dd8"></a>
typedef R&#160;</td><td class="memItemRight" valign="bottom"><b>Range</b></td></tr>
<tr class="separator:acdbc3a9ee1147e598215bda2ac6f5dd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aa4e3a3e0446c73b2dabd85385fa17c"><td class="memItemLeft" align="right" valign="top"><a id="a8aa4e3a3e0446c73b2dabd85385fa17c"></a>
typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#a8aa4e3a3e0446c73b2dabd85385fa17c">Value</a></td></tr>
<tr class="memdesc:a8aa4e3a3e0446c73b2dabd85385fa17c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type having the <a class="el" href="classRange.html" title="A contiguous range of values.">Range</a> interface, used as keys in the underlying std::map. <br /></td></tr>
<tr class="separator:a8aa4e3a3e0446c73b2dabd85385fa17c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff5cb1527b5c0906f1696aecab58c8d2"><td class="memItemLeft" align="right" valign="top"><a id="aff5cb1527b5c0906f1696aecab58c8d2"></a>
typedef Map::iterator&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b></td></tr>
<tr class="separator:aff5cb1527b5c0906f1696aecab58c8d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5c65ae6400776a38fe42e05b7b411cd"><td class="memItemLeft" align="right" valign="top"><a id="ab5c65ae6400776a38fe42e05b7b411cd"></a>
typedef Map::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b></td></tr>
<tr class="separator:ab5c65ae6400776a38fe42e05b7b411cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8074a1b4f0b2bba0cf371d996a1e5dd6"><td class="memItemLeft" align="right" valign="top"><a id="a8074a1b4f0b2bba0cf371d996a1e5dd6"></a>
typedef Map::reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>reverse_iterator</b></td></tr>
<tr class="separator:a8074a1b4f0b2bba0cf371d996a1e5dd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39b1f3d923e2f3da32c75b2b63329331"><td class="memItemLeft" align="right" valign="top"><a id="a39b1f3d923e2f3da32c75b2b63329331"></a>
typedef Map::const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>const_reverse_iterator</b></td></tr>
<tr class="separator:a39b1f3d923e2f3da32c75b2b63329331"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9a99920c98384a02f34d69ec99f73377"><td class="memItemLeft" align="right" valign="top"><a id="a9a99920c98384a02f34d69ec99f73377"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#a9a99920c98384a02f34d69ec99f73377">RangeMap</a> ()</td></tr>
<tr class="memdesc:a9a99920c98384a02f34d69ec99f73377"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new, empty map. <br /></td></tr>
<tr class="separator:a9a99920c98384a02f34d69ec99f73377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a534241f7d718ca8ea0e091a0af805325"><td class="memTemplParams" colspan="2"><a id="a534241f7d718ca8ea0e091a0af805325"></a>
template&lt;class Other &gt; </td></tr>
<tr class="memitem:a534241f7d718ca8ea0e091a0af805325"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRangeMap.html#a534241f7d718ca8ea0e091a0af805325">RangeMap</a> (const Other &amp;other)</td></tr>
<tr class="memdesc:a534241f7d718ca8ea0e091a0af805325"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new map from an existing map. <br /></td></tr>
<tr class="separator:a534241f7d718ca8ea0e091a0af805325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac80015b8083d7b290f3a6c1e6839135"><td class="memItemLeft" align="right" valign="top"><a id="aac80015b8083d7b290f3a6c1e6839135"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#aac80015b8083d7b290f3a6c1e6839135">empty</a> () const</td></tr>
<tr class="memdesc:aac80015b8083d7b290f3a6c1e6839135"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this <a class="el" href="classRangeMap.html" title="A container of ranges, somewhat like a set.">RangeMap</a> is empty. <br /></td></tr>
<tr class="separator:aac80015b8083d7b290f3a6c1e6839135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ce37682085862d5d22c9d812d903ac3"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#a8ce37682085862d5d22c9d812d903ac3">nranges</a> () const</td></tr>
<tr class="memdesc:a8ce37682085862d5d22c9d812d903ac3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of ranges in the range map.  <a href="classRangeMap.html#a8ce37682085862d5d22c9d812d903ac3">More...</a><br /></td></tr>
<tr class="separator:a8ce37682085862d5d22c9d812d903ac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45427e339290e450ce2ae77c971c9095"><td class="memItemLeft" align="right" valign="top">Range::Value&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#a45427e339290e450ce2ae77c971c9095">size</a> () const</td></tr>
<tr class="memdesc:a45427e339290e450ce2ae77c971c9095"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of values represented by this <a class="el" href="classRangeMap.html" title="A container of ranges, somewhat like a set.">RangeMap</a>.  <a href="classRangeMap.html#a45427e339290e450ce2ae77c971c9095">More...</a><br /></td></tr>
<tr class="separator:a45427e339290e450ce2ae77c971c9095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12ec46067f0bc2c0c99e7136be693aa2"><td class="memItemLeft" align="right" valign="top">Range::Value&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#a12ec46067f0bc2c0c99e7136be693aa2">min</a> () const</td></tr>
<tr class="memdesc:a12ec46067f0bc2c0c99e7136be693aa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimum value in an extent map.  <a href="classRangeMap.html#a12ec46067f0bc2c0c99e7136be693aa2">More...</a><br /></td></tr>
<tr class="separator:a12ec46067f0bc2c0c99e7136be693aa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a108e7b5c66aafb7357f1396b4b175dc5"><td class="memItemLeft" align="right" valign="top">Range::Value&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#a108e7b5c66aafb7357f1396b4b175dc5">max</a> () const</td></tr>
<tr class="memdesc:a108e7b5c66aafb7357f1396b4b175dc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum value in an extent map.  <a href="classRangeMap.html#a108e7b5c66aafb7357f1396b4b175dc5">More...</a><br /></td></tr>
<tr class="separator:a108e7b5c66aafb7357f1396b4b175dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea1225f51698714469175851cb73f732"><td class="memItemLeft" align="right" valign="top"><a id="aea1225f51698714469175851cb73f732"></a>
<a class="el" href="classRange.html">Range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#aea1225f51698714469175851cb73f732">minmax</a> () const</td></tr>
<tr class="memdesc:aea1225f51698714469175851cb73f732"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the range of values in this map. <br /></td></tr>
<tr class="separator:aea1225f51698714469175851cb73f732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa952ec5cec6a9fce073e336109fd5f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#aaa952ec5cec6a9fce073e336109fd5f7">clear</a> (bool notify=true)</td></tr>
<tr class="memdesc:aaa952ec5cec6a9fce073e336109fd5f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the map.  <a href="classRangeMap.html#aaa952ec5cec6a9fce073e336109fd5f7">More...</a><br /></td></tr>
<tr class="separator:aaa952ec5cec6a9fce073e336109fd5f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa601374137845507fa80c404308ac426"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#aa601374137845507fa80c404308ac426">erase</a> (const <a class="el" href="classRange.html">Range</a> &amp;erase_range)</td></tr>
<tr class="memdesc:aa601374137845507fa80c404308ac426"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases the specified range from this map.  <a href="classRangeMap.html#aa601374137845507fa80c404308ac426">More...</a><br /></td></tr>
<tr class="separator:aa601374137845507fa80c404308ac426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acad631371ff7910cad9e86b7ea47981b"><td class="memTemplParams" colspan="2">template&lt;class OtherMap &gt; </td></tr>
<tr class="memitem:acad631371ff7910cad9e86b7ea47981b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRangeMap.html#acad631371ff7910cad9e86b7ea47981b">erase_ranges</a> (const OtherMap &amp;other)</td></tr>
<tr class="memdesc:acad631371ff7910cad9e86b7ea47981b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase ranges from this map.  <a href="classRangeMap.html#acad631371ff7910cad9e86b7ea47981b">More...</a><br /></td></tr>
<tr class="separator:acad631371ff7910cad9e86b7ea47981b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf8ef8a1ea1d08b513487c6043ec0d8d"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#adf8ef8a1ea1d08b513487c6043ec0d8d">insert</a> (<a class="el" href="classRange.html">Range</a> new_range, <a class="el" href="classRangeMap.html#a8aa4e3a3e0446c73b2dabd85385fa17c">Value</a> new_value=<a class="el" href="classRangeMap.html#a8aa4e3a3e0446c73b2dabd85385fa17c">Value</a>(), bool make_hole=true)</td></tr>
<tr class="memdesc:adf8ef8a1ea1d08b513487c6043ec0d8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a range/value pair into the map.  <a href="classRangeMap.html#adf8ef8a1ea1d08b513487c6043ec0d8d">More...</a><br /></td></tr>
<tr class="separator:adf8ef8a1ea1d08b513487c6043ec0d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a297d504b27078eb077ba93d24f257637"><td class="memItemLeft" align="right" valign="top"><a id="a297d504b27078eb077ba93d24f257637"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#a297d504b27078eb077ba93d24f257637">insert_ranges</a> (const <a class="el" href="classRangeMap.html">RangeMap</a> &amp;x, bool make_hole=true)</td></tr>
<tr class="memdesc:a297d504b27078eb077ba93d24f257637"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert one rangemap into another. <br /></td></tr>
<tr class="separator:a297d504b27078eb077ba93d24f257637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a342bf072f0b42f5b807cdd07982e0219"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#a342bf072f0b42f5b807cdd07982e0219">insert_ranges</a> (const_iterator start, const_iterator stop, bool make_hole=true)</td></tr>
<tr class="memdesc:a342bf072f0b42f5b807cdd07982e0219"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert part of one rangemap into another.  <a href="classRangeMap.html#a342bf072f0b42f5b807cdd07982e0219">More...</a><br /></td></tr>
<tr class="separator:a342bf072f0b42f5b807cdd07982e0219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a453c2b54be4eb93f207db7366fbe1140"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#a453c2b54be4eb93f207db7366fbe1140">overlaps</a> (const <a class="el" href="classRangeMap.html">RangeMap</a> &amp;x) const</td></tr>
<tr class="memdesc:a453c2b54be4eb93f207db7366fbe1140"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if two range maps overlap.  <a href="classRangeMap.html#a453c2b54be4eb93f207db7366fbe1140">More...</a><br /></td></tr>
<tr class="separator:a453c2b54be4eb93f207db7366fbe1140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e1510feb29b1e41876573bd8df266dc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#a5e1510feb29b1e41876573bd8df266dc">overlaps</a> (const <a class="el" href="classRange.html">Range</a> &amp;r) const</td></tr>
<tr class="memdesc:a5e1510feb29b1e41876573bd8df266dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a range map overlaps with a specified range.  <a href="classRangeMap.html#a5e1510feb29b1e41876573bd8df266dc">More...</a><br /></td></tr>
<tr class="separator:a5e1510feb29b1e41876573bd8df266dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a052ebdb5df092e62a83c48683c5ea57e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#a052ebdb5df092e62a83c48683c5ea57e">distinct</a> (const <a class="el" href="classRange.html">Range</a> &amp;r) const</td></tr>
<tr class="memdesc:a052ebdb5df092e62a83c48683c5ea57e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a range map does not contain any part of the specified range.  <a href="classRangeMap.html#a052ebdb5df092e62a83c48683c5ea57e">More...</a><br /></td></tr>
<tr class="separator:a052ebdb5df092e62a83c48683c5ea57e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5928d00e3801efa4a52d67b1d0bb0cf3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#a5928d00e3801efa4a52d67b1d0bb0cf3">distinct</a> (const <a class="el" href="classRangeMap.html">RangeMap</a> &amp;x) const</td></tr>
<tr class="memdesc:a5928d00e3801efa4a52d67b1d0bb0cf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if two range maps are distinct.  <a href="classRangeMap.html#a5928d00e3801efa4a52d67b1d0bb0cf3">More...</a><br /></td></tr>
<tr class="separator:a5928d00e3801efa4a52d67b1d0bb0cf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc14fa23934560b6506a0f114eee9499"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#afc14fa23934560b6506a0f114eee9499">contains</a> (<a class="el" href="classRange.html">Range</a> need) const</td></tr>
<tr class="memdesc:afc14fa23934560b6506a0f114eee9499"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this range map contains all of the specified range.  <a href="classRangeMap.html#afc14fa23934560b6506a0f114eee9499">More...</a><br /></td></tr>
<tr class="separator:afc14fa23934560b6506a0f114eee9499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add1f69fe5b5651878815cfd8adbd0702"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#add1f69fe5b5651878815cfd8adbd0702">contains</a> (const <a class="el" href="classRangeMap.html">RangeMap</a> &amp;x) const</td></tr>
<tr class="memdesc:add1f69fe5b5651878815cfd8adbd0702"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determins if this range map contains all of some other range map.  <a href="classRangeMap.html#add1f69fe5b5651878815cfd8adbd0702">More...</a><br /></td></tr>
<tr class="separator:add1f69fe5b5651878815cfd8adbd0702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a294a50f1d84fd638c0fd43c29ff520f6"><td class="memTemplParams" colspan="2">template&lt;class ResultMap &gt; </td></tr>
<tr class="memitem:a294a50f1d84fd638c0fd43c29ff520f6"><td class="memTemplItemLeft" align="right" valign="top">ResultMap&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRangeMap.html#a294a50f1d84fd638c0fd43c29ff520f6">invert</a> () const</td></tr>
<tr class="memdesc:a294a50f1d84fd638c0fd43c29ff520f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an inverse of a range map.  <a href="classRangeMap.html#a294a50f1d84fd638c0fd43c29ff520f6">More...</a><br /></td></tr>
<tr class="separator:a294a50f1d84fd638c0fd43c29ff520f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a97944c25e824155320715afd71bc3c"><td class="memTemplParams" colspan="2">template&lt;class ResultMap &gt; </td></tr>
<tr class="memitem:a1a97944c25e824155320715afd71bc3c"><td class="memTemplItemLeft" align="right" valign="top">ResultMap&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRangeMap.html#a1a97944c25e824155320715afd71bc3c">invert_within</a> (const <a class="el" href="classRange.html">Range</a> &amp;limits) const</td></tr>
<tr class="memdesc:a1a97944c25e824155320715afd71bc3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a range map that's the inverse of some other map.  <a href="classRangeMap.html#a1a97944c25e824155320715afd71bc3c">More...</a><br /></td></tr>
<tr class="separator:a1a97944c25e824155320715afd71bc3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7c14322b9300e0460723c753e886aa5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRangeMap.html">RangeMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#ab7c14322b9300e0460723c753e886aa5">select_overlapping_ranges</a> (const <a class="el" href="classRange.html">Range</a> &amp;selector) const</td></tr>
<tr class="memdesc:ab7c14322b9300e0460723c753e886aa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select ranges overlapping selector range.  <a href="classRangeMap.html#ab7c14322b9300e0460723c753e886aa5">More...</a><br /></td></tr>
<tr class="separator:ab7c14322b9300e0460723c753e886aa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd75dcf2a45b97eb4e6e8891dbc4f0f4"><td class="memItemLeft" align="right" valign="top"><a id="afd75dcf2a45b97eb4e6e8891dbc4f0f4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>check</b> () const</td></tr>
<tr class="separator:afd75dcf2a45b97eb4e6e8891dbc4f0f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af54fdd767a5bcbbba97ebcba8b40ef0d"><td class="memItemLeft" align="right" valign="top"><a id="af54fdd767a5bcbbba97ebcba8b40ef0d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#af54fdd767a5bcbbba97ebcba8b40ef0d">print</a> (std::ostream &amp;o) const</td></tr>
<tr class="memdesc:af54fdd767a5bcbbba97ebcba8b40ef0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints unformatted <a class="el" href="classRangeMap.html" title="A container of ranges, somewhat like a set.">RangeMap</a> on a single line. <br /></td></tr>
<tr class="separator:af54fdd767a5bcbbba97ebcba8b40ef0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a09ef36a75655f2a1cbb74e60e34df930"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#a09ef36a75655f2a1cbb74e60e34df930">begin</a> ()</td></tr>
<tr class="memdesc:a09ef36a75655f2a1cbb74e60e34df930"><td class="mdescLeft">&#160;</td><td class="mdescRight">First-item iterator.  <a href="classRangeMap.html#a09ef36a75655f2a1cbb74e60e34df930">More...</a><br /></td></tr>
<tr class="separator:a09ef36a75655f2a1cbb74e60e34df930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6bcbe2f2b19d80c7e305e2a98dc5bc4"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#af6bcbe2f2b19d80c7e305e2a98dc5bc4">begin</a> () const</td></tr>
<tr class="memdesc:af6bcbe2f2b19d80c7e305e2a98dc5bc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">First-item iterator.  <a href="classRangeMap.html#af6bcbe2f2b19d80c7e305e2a98dc5bc4">More...</a><br /></td></tr>
<tr class="separator:af6bcbe2f2b19d80c7e305e2a98dc5bc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:adb1c2cb143b8d68961dbaf7debbf84e5"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#adb1c2cb143b8d68961dbaf7debbf84e5">end</a> ()</td></tr>
<tr class="memdesc:adb1c2cb143b8d68961dbaf7debbf84e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">End-item iterator.  <a href="classRangeMap.html#adb1c2cb143b8d68961dbaf7debbf84e5">More...</a><br /></td></tr>
<tr class="separator:adb1c2cb143b8d68961dbaf7debbf84e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec44644447614f844c39588bc17ae6f4"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#aec44644447614f844c39588bc17ae6f4">end</a> () const</td></tr>
<tr class="memdesc:aec44644447614f844c39588bc17ae6f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">End-item iterator.  <a href="classRangeMap.html#aec44644447614f844c39588bc17ae6f4">More...</a><br /></td></tr>
<tr class="separator:aec44644447614f844c39588bc17ae6f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ad3f7082969c7967d38c06b2ba6f19197"><td class="memItemLeft" align="right" valign="top">reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#ad3f7082969c7967d38c06b2ba6f19197">rbegin</a> ()</td></tr>
<tr class="memdesc:ad3f7082969c7967d38c06b2ba6f19197"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator referring to the last item of the map, the <a class="el" href="classRangeMap.html#a7838b1858fc9221aa675227020b71cc2" title="Returns a reverse iterator referring to the element right before the first element in the map,...">rend()</a> iterator if the <a class="el" href="classRangeMap.html" title="A container of ranges, somewhat like a set.">RangeMap</a> is empty.  <a href="classRangeMap.html#ad3f7082969c7967d38c06b2ba6f19197">More...</a><br /></td></tr>
<tr class="separator:ad3f7082969c7967d38c06b2ba6f19197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a353c25703578b5d81591395813bcb13e"><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#a353c25703578b5d81591395813bcb13e">rbegin</a> () const</td></tr>
<tr class="memdesc:a353c25703578b5d81591395813bcb13e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator referring to the last item of the map, the <a class="el" href="classRangeMap.html#a7838b1858fc9221aa675227020b71cc2" title="Returns a reverse iterator referring to the element right before the first element in the map,...">rend()</a> iterator if the <a class="el" href="classRangeMap.html" title="A container of ranges, somewhat like a set.">RangeMap</a> is empty.  <a href="classRangeMap.html#a353c25703578b5d81591395813bcb13e">More...</a><br /></td></tr>
<tr class="separator:a353c25703578b5d81591395813bcb13e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a7838b1858fc9221aa675227020b71cc2"><td class="memItemLeft" align="right" valign="top">reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#a7838b1858fc9221aa675227020b71cc2">rend</a> ()</td></tr>
<tr class="memdesc:a7838b1858fc9221aa675227020b71cc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator referring to the element right before the first element in the map, which is considered its reverse end.  <a href="classRangeMap.html#a7838b1858fc9221aa675227020b71cc2">More...</a><br /></td></tr>
<tr class="separator:a7838b1858fc9221aa675227020b71cc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbd4a318bd3865f8a473df1aa2ef89da"><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#afbd4a318bd3865f8a473df1aa2ef89da">rend</a> () const</td></tr>
<tr class="memdesc:afbd4a318bd3865f8a473df1aa2ef89da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator referring to the element right before the first element in the map, which is considered its reverse end.  <a href="classRangeMap.html#afbd4a318bd3865f8a473df1aa2ef89da">More...</a><br /></td></tr>
<tr class="separator:afbd4a318bd3865f8a473df1aa2ef89da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a3fd9ee5ddde9ab9a00270a47ac2a6055"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#a3fd9ee5ddde9ab9a00270a47ac2a6055">find</a> (const typename Range::Value &amp;addr)</td></tr>
<tr class="memdesc:a3fd9ee5ddde9ab9a00270a47ac2a6055"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the range containing specified value.  <a href="classRangeMap.html#a3fd9ee5ddde9ab9a00270a47ac2a6055">More...</a><br /></td></tr>
<tr class="separator:a3fd9ee5ddde9ab9a00270a47ac2a6055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aa115ca85815e55b717fb603bb6f3b7"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#a9aa115ca85815e55b717fb603bb6f3b7">find</a> (const typename Range::Value &amp;addr) const</td></tr>
<tr class="memdesc:a9aa115ca85815e55b717fb603bb6f3b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the range containing specified value.  <a href="classRangeMap.html#a9aa115ca85815e55b717fb603bb6f3b7">More...</a><br /></td></tr>
<tr class="separator:a9aa115ca85815e55b717fb603bb6f3b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ad59ac92205fde7c48fb73e6a28ff62c3"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#ad59ac92205fde7c48fb73e6a28ff62c3">lower_bound</a> (const typename Range::Value &amp;addr)</td></tr>
<tr class="memdesc:ad59ac92205fde7c48fb73e6a28ff62c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first range ending above the specified value.  <a href="classRangeMap.html#ad59ac92205fde7c48fb73e6a28ff62c3">More...</a><br /></td></tr>
<tr class="separator:ad59ac92205fde7c48fb73e6a28ff62c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb5a181edaf1be53978abc67baf716dc"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#afb5a181edaf1be53978abc67baf716dc">lower_bound</a> (const typename Range::Value &amp;addr) const</td></tr>
<tr class="memdesc:afb5a181edaf1be53978abc67baf716dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first range ending above the specified value.  <a href="classRangeMap.html#afb5a181edaf1be53978abc67baf716dc">More...</a><br /></td></tr>
<tr class="separator:afb5a181edaf1be53978abc67baf716dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a0b5025ec1244eeec2619e2cc02cd8868"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#a0b5025ec1244eeec2619e2cc02cd8868">find_prior</a> (const typename Range::Value &amp;addr)</td></tr>
<tr class="memdesc:a0b5025ec1244eeec2619e2cc02cd8868"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last range starting at or below the specified value.  <a href="classRangeMap.html#a0b5025ec1244eeec2619e2cc02cd8868">More...</a><br /></td></tr>
<tr class="separator:a0b5025ec1244eeec2619e2cc02cd8868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a673b68b230109741eb4bd33ed9f0fd49"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#a673b68b230109741eb4bd33ed9f0fd49">find_prior</a> (const typename Range::Value &amp;addr) const</td></tr>
<tr class="memdesc:a673b68b230109741eb4bd33ed9f0fd49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last range starting at or below the specified value.  <a href="classRangeMap.html#a673b68b230109741eb4bd33ed9f0fd49">More...</a><br /></td></tr>
<tr class="separator:a673b68b230109741eb4bd33ed9f0fd49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ac8ed4543f00dadebcf0bfc1fcce33d9c"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#ac8ed4543f00dadebcf0bfc1fcce33d9c">best_fit</a> (const typename Range::Value &amp;<a class="el" href="classRangeMap.html#a45427e339290e450ce2ae77c971c9095">size</a>, iterator start)</td></tr>
<tr class="memdesc:ac8ed4543f00dadebcf0bfc1fcce33d9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find range with closest size.  <a href="classRangeMap.html#ac8ed4543f00dadebcf0bfc1fcce33d9c">More...</a><br /></td></tr>
<tr class="separator:ac8ed4543f00dadebcf0bfc1fcce33d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a234d13cee728650cb1afdaf61147a291"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#a234d13cee728650cb1afdaf61147a291">best_fit</a> (const typename Range::Value &amp;<a class="el" href="classRangeMap.html#a45427e339290e450ce2ae77c971c9095">size</a>, const_iterator start) const</td></tr>
<tr class="memdesc:a234d13cee728650cb1afdaf61147a291"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find range with closest size.  <a href="classRangeMap.html#a234d13cee728650cb1afdaf61147a291">More...</a><br /></td></tr>
<tr class="separator:a234d13cee728650cb1afdaf61147a291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a3ffec229fe572ffe252e98b49597d616"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#a3ffec229fe572ffe252e98b49597d616">first_fit</a> (const typename Range::Value &amp;<a class="el" href="classRangeMap.html#a45427e339290e450ce2ae77c971c9095">size</a>, iterator start)</td></tr>
<tr class="memdesc:a3ffec229fe572ffe252e98b49597d616"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find first range of larger size.  <a href="classRangeMap.html#a3ffec229fe572ffe252e98b49597d616">More...</a><br /></td></tr>
<tr class="separator:a3ffec229fe572ffe252e98b49597d616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe8568e50454d9f13be779c11750323f"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#abe8568e50454d9f13be779c11750323f">first_fit</a> (const typename Range::Value &amp;<a class="el" href="classRangeMap.html#a45427e339290e450ce2ae77c971c9095">size</a>, const_iterator start)</td></tr>
<tr class="memdesc:abe8568e50454d9f13be779c11750323f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find first range of larger size.  <a href="classRangeMap.html#abe8568e50454d9f13be779c11750323f">More...</a><br /></td></tr>
<tr class="separator:abe8568e50454d9f13be779c11750323f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a3a9c931d12bab254da6386263ab0d4ca"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#a3a9c931d12bab254da6386263ab0d4ca">find_overlap</a> (const <a class="el" href="classRangeMap.html">RangeMap</a> &amp;x)</td></tr>
<tr class="memdesc:a3a9c931d12bab254da6386263ab0d4ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first overlap between two <a class="el" href="classRangeMap.html" title="A container of ranges, somewhat like a set.">RangeMap</a> objects.  <a href="classRangeMap.html#a3a9c931d12bab254da6386263ab0d4ca">More...</a><br /></td></tr>
<tr class="separator:a3a9c931d12bab254da6386263ab0d4ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7e4a2295b0d12549d809e5fca8099dd"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#ae7e4a2295b0d12549d809e5fca8099dd">first_overlap</a> (const <a class="el" href="classRangeMap.html">RangeMap</a> &amp;x) const</td></tr>
<tr class="memdesc:ae7e4a2295b0d12549d809e5fca8099dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first overlap between two <a class="el" href="classRangeMap.html" title="A container of ranges, somewhat like a set.">RangeMap</a> objects.  <a href="classRangeMap.html#ae7e4a2295b0d12549d809e5fca8099dd">More...</a><br /></td></tr>
<tr class="separator:ae7e4a2295b0d12549d809e5fca8099dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ac4c758a7003cbc5600237ac715c63613"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#ac4c758a7003cbc5600237ac715c63613">find_overlap</a> (iterator start, iterator stop, const <a class="el" href="classRangeMap.html">RangeMap</a> &amp;x)</td></tr>
<tr class="memdesc:ac4c758a7003cbc5600237ac715c63613"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find an overlap between two <a class="el" href="classRangeMap.html" title="A container of ranges, somewhat like a set.">RangeMap</a> objects.  <a href="classRangeMap.html#ac4c758a7003cbc5600237ac715c63613">More...</a><br /></td></tr>
<tr class="separator:ac4c758a7003cbc5600237ac715c63613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92902e81a30f4f77c71dd7a49c93df25"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#a92902e81a30f4f77c71dd7a49c93df25">find_overlap</a> (const_iterator start, const_iterator stop, const <a class="el" href="classRangeMap.html">RangeMap</a> &amp;x) const</td></tr>
<tr class="memdesc:a92902e81a30f4f77c71dd7a49c93df25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find an overlap between two <a class="el" href="classRangeMap.html" title="A container of ranges, somewhat like a set.">RangeMap</a> objects.  <a href="classRangeMap.html#a92902e81a30f4f77c71dd7a49c93df25">More...</a><br /></td></tr>
<tr class="separator:a92902e81a30f4f77c71dd7a49c93df25"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:a7609ee38a7e78ea97f3aa4ca15651d06"><td class="memItemLeft" align="right" valign="top"><a id="a7609ee38a7e78ea97f3aa4ca15651d06"></a>
typedef std::pair&lt; <a class="el" href="classRange.html">Range</a>, <a class="el" href="classRange.html">Range</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>RangePair</b></td></tr>
<tr class="separator:a7609ee38a7e78ea97f3aa4ca15651d06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a354b969b7a2e2df03c2bc0b4c20bf543"><td class="memItemLeft" align="right" valign="top"><a id="a354b969b7a2e2df03c2bc0b4c20bf543"></a>
typedef std::pair&lt; <a class="el" href="classRange.html">Range</a>, <a class="el" href="classRangeMap.html#a8aa4e3a3e0446c73b2dabd85385fa17c">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>MapPair</b></td></tr>
<tr class="separator:a354b969b7a2e2df03c2bc0b4c20bf543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8159c5dc84db3157927164f3662e4430"><td class="memItemLeft" align="right" valign="top"><a id="a8159c5dc84db3157927164f3662e4430"></a>
typedef std::map&lt; <a class="el" href="classRange.html">Range</a>, <a class="el" href="classRangeMap.html#a8aa4e3a3e0446c73b2dabd85385fa17c">Value</a>, <a class="el" href="structRangeMap_1_1RangeCompare.html">RangeCompare</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Map</b></td></tr>
<tr class="separator:a8159c5dc84db3157927164f3662e4430"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:acfab0d67fb25a1a64304cb8c4a202c75"><td class="memItemLeft" align="right" valign="top"><a id="acfab0d67fb25a1a64304cb8c4a202c75"></a>
<a class="el" href="classMap.html">Map</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ranges</b></td></tr>
<tr class="separator:acfab0d67fb25a1a64304cb8c4a202c75"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a09ef36a75655f2a1cbb74e60e34df930"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09ef36a75655f2a1cbb74e60e34df930">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class T  = RangeMapVoid&lt;R&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>First-item iterator. </p>
<p>Returns an iterator for the first item, or the end iterator if the <a class="el" href="classRangeMap.html" title="A container of ranges, somewhat like a set.">RangeMap</a> is empty. The iterator is valid until any operation that changes the <a class="el" href="classRangeMap.html" title="A container of ranges, somewhat like a set.">RangeMap</a>, such as an insert or erase. </p>

<p class="definition">Definition at line <a class="el" href="rangemap_8h_source.html#l00907">907</a> of file <a class="el" href="rangemap_8h_source.html">rangemap.h</a>.</p>

</div>
</div>
<a id="af6bcbe2f2b19d80c7e305e2a98dc5bc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6bcbe2f2b19d80c7e305e2a98dc5bc4">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class T  = RangeMapVoid&lt;R&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>First-item iterator. </p>
<p>Returns an iterator for the first item, or the end iterator if the <a class="el" href="classRangeMap.html" title="A container of ranges, somewhat like a set.">RangeMap</a> is empty. The iterator is valid until any operation that changes the <a class="el" href="classRangeMap.html" title="A container of ranges, somewhat like a set.">RangeMap</a>, such as an insert or erase. </p>

<p class="definition">Definition at line <a class="el" href="rangemap_8h_source.html#l00910">910</a> of file <a class="el" href="rangemap_8h_source.html">rangemap.h</a>.</p>

</div>
</div>
<a id="adb1c2cb143b8d68961dbaf7debbf84e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb1c2cb143b8d68961dbaf7debbf84e5">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class T  = RangeMapVoid&lt;R&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>End-item iterator. </p>
<p>Returns an iterator to the one-past-last item of the <a class="el" href="classRangeMap.html" title="A container of ranges, somewhat like a set.">RangeMap</a>, regardless of whether the range map is empty. The iterator is valid until any operation that changes the <a class="el" href="classRangeMap.html" title="A container of ranges, somewhat like a set.">RangeMap</a>, such as an insert or erase. </p>

<p class="definition">Definition at line <a class="el" href="rangemap_8h_source.html#l00919">919</a> of file <a class="el" href="rangemap_8h_source.html">rangemap.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="rangemap_8h_source.html#l01390">RangeMap&lt; R, T &gt;::select_overlapping_ranges()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classRangeMap_adb1c2cb143b8d68961dbaf7debbf84e5_icgraph.png" border="0" usemap="#classRangeMap_adb1c2cb143b8d68961dbaf7debbf84e5_icgraph" alt=""/></div>
<map name="classRangeMap_adb1c2cb143b8d68961dbaf7debbf84e5_icgraph" id="classRangeMap_adb1c2cb143b8d68961dbaf7debbf84e5_icgraph">
<area shape="rect" title="End&#45;item iterator." alt="" coords="255,13,369,39"/>
<area shape="rect" href="classRangeMap.html#ab7c14322b9300e0460723c753e886aa5" title="Select ranges overlapping selector range." alt="" coords="5,5,207,47"/>
</map>
</div>

</div>
</div>
<a id="aec44644447614f844c39588bc17ae6f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec44644447614f844c39588bc17ae6f4">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class T  = RangeMapVoid&lt;R&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>End-item iterator. </p>
<p>Returns an iterator to the one-past-last item of the <a class="el" href="classRangeMap.html" title="A container of ranges, somewhat like a set.">RangeMap</a>, regardless of whether the range map is empty. The iterator is valid until any operation that changes the <a class="el" href="classRangeMap.html" title="A container of ranges, somewhat like a set.">RangeMap</a>, such as an insert or erase. </p>

<p class="definition">Definition at line <a class="el" href="rangemap_8h_source.html#l00922">922</a> of file <a class="el" href="rangemap_8h_source.html">rangemap.h</a>.</p>

</div>
</div>
<a id="ad3f7082969c7967d38c06b2ba6f19197"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3f7082969c7967d38c06b2ba6f19197">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class T  = RangeMapVoid&lt;R&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reverse_iterator <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator referring to the last item of the map, the <a class="el" href="classRangeMap.html#a7838b1858fc9221aa675227020b71cc2" title="Returns a reverse iterator referring to the element right before the first element in the map,...">rend()</a> iterator if the <a class="el" href="classRangeMap.html" title="A container of ranges, somewhat like a set.">RangeMap</a> is empty. </p>
<p>The iterator is valid until any operation that changes the <a class="el" href="classRangeMap.html" title="A container of ranges, somewhat like a set.">RangeMap</a>, such as an insert or erase. </p>

<p class="definition">Definition at line <a class="el" href="rangemap_8h_source.html#l00931">931</a> of file <a class="el" href="rangemap_8h_source.html">rangemap.h</a>.</p>

</div>
</div>
<a id="a353c25703578b5d81591395813bcb13e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a353c25703578b5d81591395813bcb13e">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class T  = RangeMapVoid&lt;R&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator referring to the last item of the map, the <a class="el" href="classRangeMap.html#a7838b1858fc9221aa675227020b71cc2" title="Returns a reverse iterator referring to the element right before the first element in the map,...">rend()</a> iterator if the <a class="el" href="classRangeMap.html" title="A container of ranges, somewhat like a set.">RangeMap</a> is empty. </p>
<p>The iterator is valid until any operation that changes the <a class="el" href="classRangeMap.html" title="A container of ranges, somewhat like a set.">RangeMap</a>, such as an insert or erase. </p>

<p class="definition">Definition at line <a class="el" href="rangemap_8h_source.html#l00934">934</a> of file <a class="el" href="rangemap_8h_source.html">rangemap.h</a>.</p>

</div>
</div>
<a id="a7838b1858fc9221aa675227020b71cc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7838b1858fc9221aa675227020b71cc2">&#9670;&nbsp;</a></span>rend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class T  = RangeMapVoid&lt;R&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reverse_iterator <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator referring to the element right before the first element in the map, which is considered its reverse end. </p>
<p>Notice that <a class="el" href="classRangeMap.html#a7838b1858fc9221aa675227020b71cc2" title="Returns a reverse iterator referring to the element right before the first element in the map,...">rend()</a> does not refer to the same element as <a class="el" href="classRangeMap.html#a09ef36a75655f2a1cbb74e60e34df930" title="First-item iterator.">begin()</a>, but to the element right before it. The iterator is valid until any operation that changes the <a class="el" href="classRangeMap.html" title="A container of ranges, somewhat like a set.">RangeMap</a>, such as an insert or erase. </p>

<p class="definition">Definition at line <a class="el" href="rangemap_8h_source.html#l00944">944</a> of file <a class="el" href="rangemap_8h_source.html">rangemap.h</a>.</p>

</div>
</div>
<a id="afbd4a318bd3865f8a473df1aa2ef89da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbd4a318bd3865f8a473df1aa2ef89da">&#9670;&nbsp;</a></span>rend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class T  = RangeMapVoid&lt;R&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator referring to the element right before the first element in the map, which is considered its reverse end. </p>
<p>Notice that <a class="el" href="classRangeMap.html#a7838b1858fc9221aa675227020b71cc2" title="Returns a reverse iterator referring to the element right before the first element in the map,...">rend()</a> does not refer to the same element as <a class="el" href="classRangeMap.html#a09ef36a75655f2a1cbb74e60e34df930" title="First-item iterator.">begin()</a>, but to the element right before it. The iterator is valid until any operation that changes the <a class="el" href="classRangeMap.html" title="A container of ranges, somewhat like a set.">RangeMap</a>, such as an insert or erase. </p>

<p class="definition">Definition at line <a class="el" href="rangemap_8h_source.html#l00947">947</a> of file <a class="el" href="rangemap_8h_source.html">rangemap.h</a>.</p>

</div>
</div>
<a id="a3fd9ee5ddde9ab9a00270a47ac2a6055"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fd9ee5ddde9ab9a00270a47ac2a6055">&#9670;&nbsp;</a></span>find() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class T  = RangeMapVoid&lt;R&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const typename Range::Value &amp;&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the range containing specified value. </p>
<p>Returns an iterator to the <a class="el" href="classRange.html" title="A contiguous range of values.">Range</a> containing the specified value, or the <a class="el" href="classRangeMap.html#adb1c2cb143b8d68961dbaf7debbf84e5" title="End-item iterator.">end()</a> iterator if no such range exists. </p>

<p class="definition">Definition at line <a class="el" href="rangemap_8h_source.html#l00956">956</a> of file <a class="el" href="rangemap_8h_source.html">rangemap.h</a>.</p>

</div>
</div>
<a id="a9aa115ca85815e55b717fb603bb6f3b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aa115ca85815e55b717fb603bb6f3b7">&#9670;&nbsp;</a></span>find() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class T  = RangeMapVoid&lt;R&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const typename Range::Value &amp;&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the range containing specified value. </p>
<p>Returns an iterator to the <a class="el" href="classRange.html" title="A contiguous range of values.">Range</a> containing the specified value, or the <a class="el" href="classRangeMap.html#adb1c2cb143b8d68961dbaf7debbf84e5" title="End-item iterator.">end()</a> iterator if no such range exists. </p>

<p class="definition">Definition at line <a class="el" href="rangemap_8h_source.html#l00962">962</a> of file <a class="el" href="rangemap_8h_source.html">rangemap.h</a>.</p>

</div>
</div>
<a id="ad59ac92205fde7c48fb73e6a28ff62c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad59ac92205fde7c48fb73e6a28ff62c3">&#9670;&nbsp;</a></span>lower_bound() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class T  = RangeMapVoid&lt;R&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::lower_bound </td>
          <td>(</td>
          <td class="paramtype">const typename Range::Value &amp;&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first range ending above the specified value. </p>
<p>This is similar to the <a class="el" href="classRangeMap.html#a3fd9ee5ddde9ab9a00270a47ac2a6055" title="Find the range containing specified value.">find()</a> method, except it does not return the <a class="el" href="classRangeMap.html#adb1c2cb143b8d68961dbaf7debbf84e5" title="End-item iterator.">end()</a> iterator if a range exists above the specified value. </p>

<p class="definition">Definition at line <a class="el" href="rangemap_8h_source.html#l00974">974</a> of file <a class="el" href="rangemap_8h_source.html">rangemap.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="rangemap_8h_source.html#l01390">RangeMap&lt; R, T &gt;::select_overlapping_ranges()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classRangeMap_ad59ac92205fde7c48fb73e6a28ff62c3_icgraph.png" border="0" usemap="#classRangeMap_ad59ac92205fde7c48fb73e6a28ff62c3_icgraph" alt=""/></div>
<map name="classRangeMap_ad59ac92205fde7c48fb73e6a28ff62c3_icgraph" id="classRangeMap_ad59ac92205fde7c48fb73e6a28ff62c3_icgraph">
<area shape="rect" title="Finds the first range ending above the specified value." alt="" coords="255,13,421,39"/>
<area shape="rect" href="classRangeMap.html#ab7c14322b9300e0460723c753e886aa5" title="Select ranges overlapping selector range." alt="" coords="5,5,207,47"/>
</map>
</div>

</div>
</div>
<a id="afb5a181edaf1be53978abc67baf716dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb5a181edaf1be53978abc67baf716dc">&#9670;&nbsp;</a></span>lower_bound() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class T  = RangeMapVoid&lt;R&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::lower_bound </td>
          <td>(</td>
          <td class="paramtype">const typename Range::Value &amp;&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first range ending above the specified value. </p>
<p>This is similar to the <a class="el" href="classRangeMap.html#a3fd9ee5ddde9ab9a00270a47ac2a6055" title="Find the range containing specified value.">find()</a> method, except it does not return the <a class="el" href="classRangeMap.html#adb1c2cb143b8d68961dbaf7debbf84e5" title="End-item iterator.">end()</a> iterator if a range exists above the specified value. </p>

<p class="definition">Definition at line <a class="el" href="rangemap_8h_source.html#l00977">977</a> of file <a class="el" href="rangemap_8h_source.html">rangemap.h</a>.</p>

</div>
</div>
<a id="a0b5025ec1244eeec2619e2cc02cd8868"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b5025ec1244eeec2619e2cc02cd8868">&#9670;&nbsp;</a></span>find_prior() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class T  = RangeMapVoid&lt;R&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::find_prior </td>
          <td>(</td>
          <td class="paramtype">const typename Range::Value &amp;&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last range starting at or below the specified value. </p>
<p>Returns the end iterator if there is no range containing a value less than or equal to the specified value. </p>

<p class="definition">Definition at line <a class="el" href="rangemap_8h_source.html#l00985">985</a> of file <a class="el" href="rangemap_8h_source.html">rangemap.h</a>.</p>

</div>
</div>
<a id="a673b68b230109741eb4bd33ed9f0fd49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a673b68b230109741eb4bd33ed9f0fd49">&#9670;&nbsp;</a></span>find_prior() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class T  = RangeMapVoid&lt;R&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::find_prior </td>
          <td>(</td>
          <td class="paramtype">const typename Range::Value &amp;&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last range starting at or below the specified value. </p>
<p>Returns the end iterator if there is no range containing a value less than or equal to the specified value. </p>

<p class="definition">Definition at line <a class="el" href="rangemap_8h_source.html#l00995">995</a> of file <a class="el" href="rangemap_8h_source.html">rangemap.h</a>.</p>

</div>
</div>
<a id="ac8ed4543f00dadebcf0bfc1fcce33d9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8ed4543f00dadebcf0bfc1fcce33d9c">&#9670;&nbsp;</a></span>best_fit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class T  = RangeMapVoid&lt;R&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::best_fit </td>
          <td>(</td>
          <td class="paramtype">const typename Range::Value &amp;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterator&#160;</td>
          <td class="paramname"><em>start</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find range with closest size. </p>
<p>Returns an iterator pointing to the first range at or after the specified <code>start</code> iterator whose size is at least as large as the specified size. Returns the end iterator if no such range exists. Note that this is an O(N) algorithm. </p>

<p class="definition">Definition at line <a class="el" href="rangemap_8h_source.html#l01012">1012</a> of file <a class="el" href="rangemap_8h_source.html">rangemap.h</a>.</p>

</div>
</div>
<a id="a234d13cee728650cb1afdaf61147a291"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a234d13cee728650cb1afdaf61147a291">&#9670;&nbsp;</a></span>best_fit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class T  = RangeMapVoid&lt;R&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::best_fit </td>
          <td>(</td>
          <td class="paramtype">const typename Range::Value &amp;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>start</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find range with closest size. </p>
<p>Returns an iterator pointing to the first range at or after the specified <code>start</code> iterator whose size is at least as large as the specified size. Returns the end iterator if no such range exists. Note that this is an O(N) algorithm. </p>

<p class="definition">Definition at line <a class="el" href="rangemap_8h_source.html#l01022">1022</a> of file <a class="el" href="rangemap_8h_source.html">rangemap.h</a>.</p>

</div>
</div>
<a id="a3ffec229fe572ffe252e98b49597d616"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ffec229fe572ffe252e98b49597d616">&#9670;&nbsp;</a></span>first_fit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class T  = RangeMapVoid&lt;R&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::first_fit </td>
          <td>(</td>
          <td class="paramtype">const typename Range::Value &amp;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterator&#160;</td>
          <td class="paramname"><em>start</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find first range of larger size. </p>
<p>Returns an iterator to the first range at least as large as the specified <code>size</code> and at or after <code>start</code>. Returns the end iterator if no range is found. Note that this is an O(N) algorithm. </p>

<p class="definition">Definition at line <a class="el" href="rangemap_8h_source.html#l01038">1038</a> of file <a class="el" href="rangemap_8h_source.html">rangemap.h</a>.</p>

</div>
</div>
<a id="abe8568e50454d9f13be779c11750323f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe8568e50454d9f13be779c11750323f">&#9670;&nbsp;</a></span>first_fit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class T  = RangeMapVoid&lt;R&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::first_fit </td>
          <td>(</td>
          <td class="paramtype">const typename Range::Value &amp;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>start</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find first range of larger size. </p>
<p>Returns an iterator to the first range at least as large as the specified <code>size</code> and at or after <code>start</code>. Returns the end iterator if no range is found. Note that this is an O(N) algorithm. </p>

<p class="definition">Definition at line <a class="el" href="rangemap_8h_source.html#l01045">1045</a> of file <a class="el" href="rangemap_8h_source.html">rangemap.h</a>.</p>

</div>
</div>
<a id="a8ce37682085862d5d22c9d812d903ac3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ce37682085862d5d22c9d812d903ac3">&#9670;&nbsp;</a></span>nranges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class T  = RangeMapVoid&lt;R&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::nranges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of ranges in the range map. </p>
<p>This is the number of <a class="el" href="classRange.html" title="A contiguous range of values.">Range</a> objects one would encounter if they iterate over this <a class="el" href="classRangeMap.html" title="A container of ranges, somewhat like a set.">RangeMap</a> from <a class="el" href="classRangeMap.html#a09ef36a75655f2a1cbb74e60e34df930" title="First-item iterator.">begin()</a> to <a class="el" href="classRangeMap.html#adb1c2cb143b8d68961dbaf7debbf84e5" title="End-item iterator.">end()</a>. </p>

<p class="definition">Definition at line <a class="el" href="rangemap_8h_source.html#l01066">1066</a> of file <a class="el" href="rangemap_8h_source.html">rangemap.h</a>.</p>

</div>
</div>
<a id="a45427e339290e450ce2ae77c971c9095"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45427e339290e450ce2ae77c971c9095">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class T  = RangeMapVoid&lt;R&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Range::Value <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of values represented by this <a class="el" href="classRangeMap.html" title="A container of ranges, somewhat like a set.">RangeMap</a>. </p>
<p>The number of values does not typically correlate with the amount of memory used by the <a class="el" href="classRangeMap.html" title="A container of ranges, somewhat like a set.">RangeMap</a> since each element of the underlying std::map represents an arbitrary number of values. Note that if the range occupies the entire possible set of values then the size might be returned as zero due to overflow, and it will be necessary to call <a class="el" href="classRangeMap.html#aac80015b8083d7b290f3a6c1e6839135" title="Returns true if this RangeMap is empty.">empty()</a> to make the determination. </p>

<p class="definition">Definition at line <a class="el" href="rangemap_8h_source.html#l01074">1074</a> of file <a class="el" href="rangemap_8h_source.html">rangemap.h</a>.</p>

</div>
</div>
<a id="a12ec46067f0bc2c0c99e7136be693aa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12ec46067f0bc2c0c99e7136be693aa2">&#9670;&nbsp;</a></span>min()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class T  = RangeMapVoid&lt;R&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Range::Value <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::min </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the minimum value in an extent map. </p>
<p>The extent map must not be empty. </p>

<p class="definition">Definition at line <a class="el" href="rangemap_8h_source.html#l01082">1082</a> of file <a class="el" href="rangemap_8h_source.html">rangemap.h</a>.</p>

</div>
</div>
<a id="a108e7b5c66aafb7357f1396b4b175dc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a108e7b5c66aafb7357f1396b4b175dc5">&#9670;&nbsp;</a></span>max()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class T  = RangeMapVoid&lt;R&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Range::Value <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::max </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum value in an extent map. </p>
<p>The extent map must not be empty. </p>

<p class="definition">Definition at line <a class="el" href="rangemap_8h_source.html#l01088">1088</a> of file <a class="el" href="rangemap_8h_source.html">rangemap.h</a>.</p>

</div>
</div>
<a id="aaa952ec5cec6a9fce073e336109fd5f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa952ec5cec6a9fce073e336109fd5f7">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class T  = RangeMapVoid&lt;R&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::clear </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>notify</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the map. </p>
<p>Removes all entries from the map. If <code>notify</code> is true then also call the removing() method of each value. </p>

<p class="definition">Definition at line <a class="el" href="rangemap_8h_source.html#l01111">1111</a> of file <a class="el" href="rangemap_8h_source.html">rangemap.h</a>.</p>

</div>
</div>
<a id="aa601374137845507fa80c404308ac426"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa601374137845507fa80c404308ac426">&#9670;&nbsp;</a></span>erase()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class T  = RangeMapVoid&lt;R&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRange.html">Range</a> &amp;&#160;</td>
          <td class="paramname"><em>erase_range</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases the specified range from this map. </p>
<p>The range to remove can span multiple existing ranges and/or parts of ranges, or no ranges at all. It would be nice to be able to return an iterator to the next item since we have that in hand. Unfortunately, limitations of std::map make this impractical. If you need an iterator, just make another call to <a class="el" href="classRangeMap.html#ad59ac92205fde7c48fb73e6a28ff62c3" title="Finds the first range ending above the specified value.">lower_bound()</a>. </p>

<p class="definition">Definition at line <a class="el" href="rangemap_8h_source.html#l01123">1123</a> of file <a class="el" href="rangemap_8h_source.html">rangemap.h</a>.</p>

</div>
</div>
<a id="acad631371ff7910cad9e86b7ea47981b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acad631371ff7910cad9e86b7ea47981b">&#9670;&nbsp;</a></span>erase_ranges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class T  = RangeMapVoid&lt;R&gt;&gt; </div>
<div class="memtemplate">
template&lt;class OtherMap &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::erase_ranges </td>
          <td>(</td>
          <td class="paramtype">const OtherMap &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase ranges from this map. </p>
<p>Every range in the <code>other</code> map is erased from this map. The maps need not be the same type as long as their ranges are the same type. The values of the <code>other</code> map are not used&ndash;only its ranges. </p>

<p class="definition">Definition at line <a class="el" href="rangemap_8h_source.html#l01183">1183</a> of file <a class="el" href="rangemap_8h_source.html">rangemap.h</a>.</p>

</div>
</div>
<a id="adf8ef8a1ea1d08b513487c6043ec0d8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf8ef8a1ea1d08b513487c6043ec0d8d">&#9670;&nbsp;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class T  = RangeMapVoid&lt;R&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRange.html">Range</a>&#160;</td>
          <td class="paramname"><em>new_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRangeMap.html#a8aa4e3a3e0446c73b2dabd85385fa17c">Value</a>&#160;</td>
          <td class="paramname"><em>new_value</em> = <code><a class="el" href="classRangeMap.html#a8aa4e3a3e0446c73b2dabd85385fa17c">Value</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>make_hole</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a range/value pair into the map. </p>
<p>If <code>make_hole</code> is true then the new range is allowed to replace existing ranges (or parts thereof), otherwise if the new range conflicts with eixsting ranges the new extent is not inserted and no change is made to the map. If <code>merge</code> is true then we attempt to merge the new range into adjacent ranges. Returns an iterator to the new map element, or if merged, to the element that contains the new value. Returns the end iterator if the range was not inserted. </p>

<p class="definition">Definition at line <a class="el" href="rangemap_8h_source.html#l01194">1194</a> of file <a class="el" href="rangemap_8h_source.html">rangemap.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="rangemap_8h_source.html#l01390">RangeMap&lt; R, T &gt;::select_overlapping_ranges()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classRangeMap_adf8ef8a1ea1d08b513487c6043ec0d8d_icgraph.png" border="0" usemap="#classRangeMap_adf8ef8a1ea1d08b513487c6043ec0d8d_icgraph" alt=""/></div>
<map name="classRangeMap_adf8ef8a1ea1d08b513487c6043ec0d8d_icgraph" id="classRangeMap_adf8ef8a1ea1d08b513487c6043ec0d8d_icgraph">
<area shape="rect" title="Insert a range/value pair into the map." alt="" coords="255,13,380,39"/>
<area shape="rect" href="classRangeMap.html#ab7c14322b9300e0460723c753e886aa5" title="Select ranges overlapping selector range." alt="" coords="5,5,207,47"/>
</map>
</div>

</div>
</div>
<a id="a342bf072f0b42f5b807cdd07982e0219"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a342bf072f0b42f5b807cdd07982e0219">&#9670;&nbsp;</a></span>insert_ranges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class T  = RangeMapVoid&lt;R&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::insert_ranges </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>stop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>make_hole</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert part of one rangemap into another. </p>
<p>The ranges from <code>start</code> (inclusive) to <code>stop</code> (exclusive) are inserted into this range map. The <code>start</code> and <code>stop</code> iterators should not be iterators of this map, but some other. </p>

<p class="definition">Definition at line <a class="el" href="rangemap_8h_source.html#l01233">1233</a> of file <a class="el" href="rangemap_8h_source.html">rangemap.h</a>.</p>

</div>
</div>
<a id="a453c2b54be4eb93f207db7366fbe1140"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a453c2b54be4eb93f207db7366fbe1140">&#9670;&nbsp;</a></span>overlaps() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class T  = RangeMapVoid&lt;R&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::overlaps </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if two range maps overlap. </p>
<p>Returns true iff any ranges of this map overlap with any ranges of map <code>x</code>. </p>

<p class="definition">Definition at line <a class="el" href="rangemap_8h_source.html#l01244">1244</a> of file <a class="el" href="rangemap_8h_source.html">rangemap.h</a>.</p>

</div>
</div>
<a id="a5e1510feb29b1e41876573bd8df266dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e1510feb29b1e41876573bd8df266dc">&#9670;&nbsp;</a></span>overlaps() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class T  = RangeMapVoid&lt;R&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::overlaps </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRange.html">Range</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if a range map overlaps with a specified range. </p>
<p>Returns true iff any part of the range <code>r</code> is present in the map. A <a class="el" href="classRangeMap.html" title="A container of ranges, somewhat like a set.">RangeMap</a> never overlaps with an empty range. </p>

<p class="definition">Definition at line <a class="el" href="rangemap_8h_source.html#l01250">1250</a> of file <a class="el" href="rangemap_8h_source.html">rangemap.h</a>.</p>

</div>
</div>
<a id="a052ebdb5df092e62a83c48683c5ea57e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a052ebdb5df092e62a83c48683c5ea57e">&#9670;&nbsp;</a></span>distinct() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class T  = RangeMapVoid&lt;R&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::distinct </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRange.html">Range</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if a range map does not contain any part of the specified range. </p>
<p>Returns false if any part of the range <code>r</code> is present in the map. An empty range is always distinct from the map. </p>

<p class="definition">Definition at line <a class="el" href="rangemap_8h_source.html#l01259">1259</a> of file <a class="el" href="rangemap_8h_source.html">rangemap.h</a>.</p>

</div>
</div>
<a id="a5928d00e3801efa4a52d67b1d0bb0cf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5928d00e3801efa4a52d67b1d0bb0cf3">&#9670;&nbsp;</a></span>distinct() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class T  = RangeMapVoid&lt;R&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::distinct </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if two range maps are distinct. </p>
<p>Returns true iff there is no range in this map that overlaps with any range of map <code>x</code>. </p>

<p class="definition">Definition at line <a class="el" href="rangemap_8h_source.html#l01265">1265</a> of file <a class="el" href="rangemap_8h_source.html">rangemap.h</a>.</p>

</div>
</div>
<a id="afc14fa23934560b6506a0f114eee9499"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc14fa23934560b6506a0f114eee9499">&#9670;&nbsp;</a></span>contains() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class T  = RangeMapVoid&lt;R&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::contains </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRange.html">Range</a>&#160;</td>
          <td class="paramname"><em>need</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this range map contains all of the specified range. </p>
<p>If the specified range is empty then this function returns true: the map contains all empty ranges. </p>

<p class="definition">Definition at line <a class="el" href="rangemap_8h_source.html#l01271">1271</a> of file <a class="el" href="rangemap_8h_source.html">rangemap.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="rangemap_8h_source.html#l01292">RangeMap&lt; R, T &gt;::contains()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classRangeMap_afc14fa23934560b6506a0f114eee9499_icgraph.png" border="0" usemap="#classRangeMap_afc14fa23934560b6506a0f114eee9499_icgraph" alt=""/></div>
<map name="classRangeMap_afc14fa23934560b6506a0f114eee9499_icgraph" id="classRangeMap_afc14fa23934560b6506a0f114eee9499_icgraph">
<area shape="rect" title="Determines if this range map contains all of the specified range." alt="" coords="196,5,339,32"/>
<area shape="rect" href="classRangeMap.html#add1f69fe5b5651878815cfd8adbd0702" title="Determins if this range map contains all of some other range map." alt="" coords="5,5,148,32"/>
</map>
</div>

</div>
</div>
<a id="add1f69fe5b5651878815cfd8adbd0702"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add1f69fe5b5651878815cfd8adbd0702">&#9670;&nbsp;</a></span>contains() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class T  = RangeMapVoid&lt;R&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determins if this range map contains all of some other range map. </p>
<p>Returns true iff each range in <code>x</code> is contained in some range of this map. If <code>x</code> is empty this function returns true: a <a class="el" href="classRangeMap.html" title="A container of ranges, somewhat like a set.">RangeMap</a> contains all empty ranges. </p>

<p class="definition">Definition at line <a class="el" href="rangemap_8h_source.html#l01292">1292</a> of file <a class="el" href="rangemap_8h_source.html">rangemap.h</a>.</p>

<p class="reference">References <a class="el" href="rangemap_8h_source.html#l01271">RangeMap&lt; R, T &gt;::contains()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classRangeMap_add1f69fe5b5651878815cfd8adbd0702_cgraph.png" border="0" usemap="#classRangeMap_add1f69fe5b5651878815cfd8adbd0702_cgraph" alt=""/></div>
<map name="classRangeMap_add1f69fe5b5651878815cfd8adbd0702_cgraph" id="classRangeMap_add1f69fe5b5651878815cfd8adbd0702_cgraph">
<area shape="rect" title="Determins if this range map contains all of some other range map." alt="" coords="5,5,148,32"/>
<area shape="rect" href="classRangeMap.html#afc14fa23934560b6506a0f114eee9499" title="Determines if this range map contains all of the specified range." alt="" coords="196,5,339,32"/>
</map>
</div>

</div>
</div>
<a id="a3a9c931d12bab254da6386263ab0d4ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a9c931d12bab254da6386263ab0d4ca">&#9670;&nbsp;</a></span>find_overlap() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class T  = RangeMapVoid&lt;R&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::find_overlap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the first overlap between two <a class="el" href="classRangeMap.html" title="A container of ranges, somewhat like a set.">RangeMap</a> objects. </p>
<p>Returns an iterator for this map that points to the first range that overlaps with some range in the other map, <code>x</code>. Returns the end iterator if no overlap is found. </p>

<p class="definition">Definition at line <a class="el" href="rangemap_8h_source.html#l01311">1311</a> of file <a class="el" href="rangemap_8h_source.html">rangemap.h</a>.</p>

</div>
</div>
<a id="ae7e4a2295b0d12549d809e5fca8099dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7e4a2295b0d12549d809e5fca8099dd">&#9670;&nbsp;</a></span>first_overlap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class T  = RangeMapVoid&lt;R&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::first_overlap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the first overlap between two <a class="el" href="classRangeMap.html" title="A container of ranges, somewhat like a set.">RangeMap</a> objects. </p>
<p>Returns an iterator for this map that points to the first range that overlaps with some range in the other map, <code>x</code>. Returns the end iterator if no overlap is found. </p>

<p class="definition">Definition at line <a class="el" href="rangemap_8h_source.html#l01314">1314</a> of file <a class="el" href="rangemap_8h_source.html">rangemap.h</a>.</p>

</div>
</div>
<a id="ac4c758a7003cbc5600237ac715c63613"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4c758a7003cbc5600237ac715c63613">&#9670;&nbsp;</a></span>find_overlap() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class T  = RangeMapVoid&lt;R&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::find_overlap </td>
          <td>(</td>
          <td class="paramtype">iterator&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterator&#160;</td>
          <td class="paramname"><em>stop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find an overlap between two <a class="el" href="classRangeMap.html" title="A container of ranges, somewhat like a set.">RangeMap</a> objects. </p>
<p>Returns an iterator for this map that points to the first range that overlaps with some range in the other map, <code>x</code>. The returned iterator will be between <code>start</code> (inclusive) and <code>stop</code> (exclusive), which must obviously be iterators for this <a class="el" href="classRangeMap.html" title="A container of ranges, somewhat like a set.">RangeMap</a>, not <code>x</code>. Returns the end iterator if there is no overlap within the restricted ranges. </p>

<p class="definition">Definition at line <a class="el" href="rangemap_8h_source.html#l01325">1325</a> of file <a class="el" href="rangemap_8h_source.html">rangemap.h</a>.</p>

</div>
</div>
<a id="a92902e81a30f4f77c71dd7a49c93df25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92902e81a30f4f77c71dd7a49c93df25">&#9670;&nbsp;</a></span>find_overlap() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class T  = RangeMapVoid&lt;R&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::find_overlap </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>stop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find an overlap between two <a class="el" href="classRangeMap.html" title="A container of ranges, somewhat like a set.">RangeMap</a> objects. </p>
<p>Returns an iterator for this map that points to the first range that overlaps with some range in the other map, <code>x</code>. The returned iterator will be between <code>start</code> (inclusive) and <code>stop</code> (exclusive), which must obviously be iterators for this <a class="el" href="classRangeMap.html" title="A container of ranges, somewhat like a set.">RangeMap</a>, not <code>x</code>. Returns the end iterator if there is no overlap within the restricted ranges. </p>

<p class="definition">Definition at line <a class="el" href="rangemap_8h_source.html#l01340">1340</a> of file <a class="el" href="rangemap_8h_source.html">rangemap.h</a>.</p>

</div>
</div>
<a id="a294a50f1d84fd638c0fd43c29ff520f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a294a50f1d84fd638c0fd43c29ff520f6">&#9670;&nbsp;</a></span>invert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class T  = RangeMapVoid&lt;R&gt;&gt; </div>
<div class="memtemplate">
template&lt;class ResultMap &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ResultMap <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::invert </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an inverse of a range map. </p>
<p>The values of the result are default constructed. </p>

<p class="definition">Definition at line <a class="el" href="rangemap_8h_source.html#l01364">1364</a> of file <a class="el" href="rangemap_8h_source.html">rangemap.h</a>.</p>

</div>
</div>
<a id="a1a97944c25e824155320715afd71bc3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a97944c25e824155320715afd71bc3c">&#9670;&nbsp;</a></span>invert_within()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class T  = RangeMapVoid&lt;R&gt;&gt; </div>
<div class="memtemplate">
template&lt;class ResultMap &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ResultMap <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::invert_within </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRange.html">Range</a> &amp;&#160;</td>
          <td class="paramname"><em>limits</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a range map that's the inverse of some other map. </p>
<p>The returned map's ranges will be limited according to the specified <code>limits</code>. The values of the result are default constructed. </p>

<p class="definition">Definition at line <a class="el" href="rangemap_8h_source.html#l01371">1371</a> of file <a class="el" href="rangemap_8h_source.html">rangemap.h</a>.</p>

<p class="reference">References <a class="el" href="rangemap_8h_source.html#l00094">Range&lt; T &gt;::inin()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classRangeMap_a1a97944c25e824155320715afd71bc3c_cgraph.png" border="0" usemap="#classRangeMap_a1a97944c25e824155320715afd71bc3c_cgraph" alt=""/></div>
<map name="classRangeMap_a1a97944c25e824155320715afd71bc3c_cgraph" id="classRangeMap_a1a97944c25e824155320715afd71bc3c_cgraph">
<area shape="rect" title="Create a range map that&#39;s the inverse of some other map." alt="" coords="5,5,172,32"/>
<area shape="rect" href="classRange.html#a785281ce194b217cf86c35a4d6f42c98" title="Create a new range by giving the first (inclusive) and last value (inclusive)." alt="" coords="220,5,308,32"/>
</map>
</div>

</div>
</div>
<a id="ab7c14322b9300e0460723c753e886aa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7c14322b9300e0460723c753e886aa5">&#9670;&nbsp;</a></span>select_overlapping_ranges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class T  = RangeMapVoid&lt;R&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRangeMap.html">RangeMap</a> <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::select_overlapping_ranges </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRange.html">Range</a> &amp;&#160;</td>
          <td class="paramname"><em>selector</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Select ranges overlapping selector range. </p>
<p>Returns a new range map whose ranges are those ranges of this map that overlap with the specified <code>selector</code> range. </p>

<p class="definition">Definition at line <a class="el" href="rangemap_8h_source.html#l01390">1390</a> of file <a class="el" href="rangemap_8h_source.html">rangemap.h</a>.</p>

<p class="reference">References <a class="el" href="rangemap_8h_source.html#l00919">RangeMap&lt; R, T &gt;::end()</a>, <a class="el" href="rangemap_8h_source.html#l01194">RangeMap&lt; R, T &gt;::insert()</a>, <a class="el" href="rangemap_8h_source.html#l00358">Range&lt; T &gt;::left_of()</a>, <a class="el" href="rangemap_8h_source.html#l00974">RangeMap&lt; R, T &gt;::lower_bound()</a>, and <a class="el" href="rangemap_8h_source.html#l00377">Range&lt; T &gt;::overlaps()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classRangeMap_ab7c14322b9300e0460723c753e886aa5_cgraph.png" border="0" usemap="#classRangeMap_ab7c14322b9300e0460723c753e886aa5_cgraph" alt=""/></div>
<map name="classRangeMap_ab7c14322b9300e0460723c753e886aa5_cgraph" id="classRangeMap_ab7c14322b9300e0460723c753e886aa5_cgraph">
<area shape="rect" title="Select ranges overlapping selector range." alt="" coords="5,99,207,141"/>
<area shape="rect" href="classRangeMap.html#adb1c2cb143b8d68961dbaf7debbf84e5" title="End&#45;item iterator." alt="" coords="281,5,395,32"/>
<area shape="rect" href="classRangeMap.html#adf8ef8a1ea1d08b513487c6043ec0d8d" title="Insert a range/value pair into the map." alt="" coords="275,56,401,83"/>
<area shape="rect" href="classRange.html#a8235f297331f655a89d44c3930cc6ec5" title="Is this range left of the argument range?" alt="" coords="286,107,390,133"/>
<area shape="rect" href="classRangeMap.html#ad59ac92205fde7c48fb73e6a28ff62c3" title="Finds the first range ending above the specified value." alt="" coords="255,157,421,184"/>
<area shape="rect" href="classRange.html#acf652e7f98ecb33841f68933837b74fd" title="Does this range overlap with the argument range?" alt="" coords="279,208,397,235"/>
</map>
</div>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="rangemap_8h_source.html">rangemap.h</a></li>
</ul>
</div><!-- contents -->
<div class="ttc" id="anamespaceSawyer_1_1Container_1_1BitVectorSupport_html_a98b33c1888d241c1ef777bcef0eacc3c"><div class="ttname"><a href="namespaceSawyer_1_1Container_1_1BitVectorSupport.html#a98b33c1888d241c1ef777bcef0eacc3c">Sawyer::Container::BitVectorSupport::get</a></div><div class="ttdeci">bool get(const Word *words, size_t idx)</div><div class="ttdoc">Return a single bit.</div><div class="ttdef"><b>Definition:</b> <a href="BitVectorSupport_8h_source.html#l00384">BitVectorSupport.h:384</a></div></div>
<div class="ttc" id="anamespaceRose_1_1StringUtility_html_abeb29cbfa6cea9b3c9cd3c1481a5c79a"><div class="ttname"><a href="namespaceRose_1_1StringUtility.html#abeb29cbfa6cea9b3c9cd3c1481a5c79a">Rose::StringUtility::split</a></div><div class="ttdeci">ROSE_UTIL_API std::vector&lt; std::string &gt; split(const std::string &amp;separator, const std::string &amp;str, size_t maxparts=UNLIMITED, bool trim_white_space=false)</div><div class="ttdoc">Splits strings into parts.</div></div>
<div class="ttc" id="aclassRangeMapValue_html"><div class="ttname"><a href="classRangeMapValue.html">RangeMapValue</a></div><div class="ttdoc">Scalar value type for a RangeMap.</div><div class="ttdef"><b>Definition:</b> <a href="rangemap_8h_source.html#l00678">rangemap.h:678</a></div></div>
<div class="ttc" id="aclassRangeMap_html"><div class="ttname"><a href="classRangeMap.html">RangeMap</a></div><div class="ttdoc">A container of ranges, somewhat like a set.</div><div class="ttdef"><b>Definition:</b> <a href="rangemap_8h_source.html#l00852">rangemap.h:852</a></div></div>
<div class="ttc" id="aclassAstSimpleProcessing_html"><div class="ttname"><a href="classAstSimpleProcessing.html">AstSimpleProcessing</a></div><div class="ttdoc">Class for traversing the AST.</div><div class="ttdef"><b>Definition:</b> <a href="AstSimpleProcessing_8h_source.html#l00059">AstSimpleProcessing.h:59</a></div></div>
<div class="ttc" id="aclassRangeMap_html_a45427e339290e450ce2ae77c971c9095"><div class="ttname"><a href="classRangeMap.html#a45427e339290e450ce2ae77c971c9095">RangeMap::size</a></div><div class="ttdeci">Range::Value size() const</div><div class="ttdoc">Returns the number of values represented by this RangeMap.</div><div class="ttdef"><b>Definition:</b> <a href="rangemap_8h_source.html#l01074">rangemap.h:1074</a></div></div>
<div class="ttc" id="aclassSgNode_html"><div class="ttname"><a href="classSgNode.html">SgNode</a></div><div class="ttdoc">This class represents the base class for all IR nodes within Sage III.</div><div class="ttdef"><b>Definition:</b> <a href="Cxx__Grammar_8h_source.html#l06739">Cxx_Grammar.h:6739</a></div></div>
<div class="ttc" id="anamespaceSawyer_1_1Container_1_1BitVectorSupport_html_a6a1434bde1bc4974b3224a9856a352b0"><div class="ttname"><a href="namespaceSawyer_1_1Container_1_1BitVectorSupport.html#a6a1434bde1bc4974b3224a9856a352b0">Sawyer::Container::BitVectorSupport::set</a></div><div class="ttdeci">void set(Word *words, const BitRange &amp;where)</div><div class="ttdoc">Set some bits.</div><div class="ttdef"><b>Definition:</b> <a href="BitVectorSupport_8h_source.html#l00417">BitVectorSupport.h:417</a></div></div>
<div class="ttc" id="aclassRange_html"><div class="ttname"><a href="classRange.html">Range</a></div><div class="ttdoc">A contiguous range of values.</div><div class="ttdef"><b>Definition:</b> <a href="rangemap_8h_source.html#l00050">rangemap.h:50</a></div></div>
<div class="ttc" id="aclassFunction_html"><div class="ttname"><a href="classFunction.html">Function</a></div><div class="ttdef"><b>Definition:</b> <a href="CallGraphTraverse_8h_source.html#l00020">CallGraphTraverse.h:20</a></div></div>
<div class="ttc" id="aclassRangeMap_html_af54fdd767a5bcbbba97ebcba8b40ef0d"><div class="ttname"><a href="classRangeMap.html#af54fdd767a5bcbbba97ebcba8b40ef0d">RangeMap::print</a></div><div class="ttdeci">void print(std::ostream &amp;o) const</div><div class="ttdoc">Prints unformatted RangeMap on a single line.</div><div class="ttdef"><b>Definition:</b> <a href="rangemap_8h_source.html#l01486">rangemap.h:1486</a></div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Dec 8 2022 21:18:18 for ROSE by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
