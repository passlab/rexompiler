<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROSE: Sawyer::Container::Algorithm Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="ROSE"/>
<link href="roseDoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ROSE
   &#160;<span id="projectnumber">0.11.96.11</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,true,'search.html','Search');
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceSawyer.html">Sawyer</a></li><li class="navelem"><a class="el" href="namespaceSawyer_1_1Container.html">Container</a></li><li class="navelem"><a class="el" href="namespaceSawyer_1_1Container_1_1Algorithm.html">Algorithm</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Sawyer::Container::Algorithm Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>Algorithms that operate on container classes. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1BreadthFirstForwardEdgeTraversal.html">BreadthFirstForwardEdgeTraversal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Breadth-first, forward traversal for edges.  <a href="classSawyer_1_1Container_1_1Algorithm_1_1BreadthFirstForwardEdgeTraversal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1BreadthFirstForwardGraphTraversal.html">BreadthFirstForwardGraphTraversal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Breadth-first, forward traversal for all event types.  <a href="classSawyer_1_1Container_1_1Algorithm_1_1BreadthFirstForwardGraphTraversal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1BreadthFirstForwardVertexTraversal.html">BreadthFirstForwardVertexTraversal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Breadth-first, forward traversal for vertices.  <a href="classSawyer_1_1Container_1_1Algorithm_1_1BreadthFirstForwardVertexTraversal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1BreadthFirstReverseEdgeTraversal.html">BreadthFirstReverseEdgeTraversal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Breadth-first, reverse traversal for edges.  <a href="classSawyer_1_1Container_1_1Algorithm_1_1BreadthFirstReverseEdgeTraversal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1BreadthFirstReverseGraphTraversal.html">BreadthFirstReverseGraphTraversal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Breadth-first, reverse traversal for all event types.  <a href="classSawyer_1_1Container_1_1Algorithm_1_1BreadthFirstReverseGraphTraversal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1BreadthFirstReverseVertexTraversal.html">BreadthFirstReverseVertexTraversal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Breadth-first, reverse traversal for vertices.  <a href="classSawyer_1_1Container_1_1Algorithm_1_1BreadthFirstReverseVertexTraversal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1BreadthFirstTraversalTag.html">BreadthFirstTraversalTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Order tag for breadth-first traversals.  <a href="classSawyer_1_1Container_1_1Algorithm_1_1BreadthFirstTraversalTag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html">CommonSubgraphIsomorphism</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common subgraph isomorphism solver.  <a href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1CsiEquivalence.html">CsiEquivalence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structVertex.html">Vertex</a> equivalence for common subgraph isomorphism.  <a href="classSawyer_1_1Container_1_1Algorithm_1_1CsiEquivalence.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1CsiShowSolution.html">CsiShowSolution</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor called for each common subgraph isomorphism solution.  <a href="classSawyer_1_1Container_1_1Algorithm_1_1CsiShowSolution.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1DepthFirstForwardEdgeTraversal.html">DepthFirstForwardEdgeTraversal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Depth-first, forward traversal for edges.  <a href="classSawyer_1_1Container_1_1Algorithm_1_1DepthFirstForwardEdgeTraversal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1DepthFirstForwardGraphTraversal.html">DepthFirstForwardGraphTraversal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Depth-first, forward traversal for all event types.  <a href="classSawyer_1_1Container_1_1Algorithm_1_1DepthFirstForwardGraphTraversal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1DepthFirstForwardVertexTraversal.html">DepthFirstForwardVertexTraversal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Depth-first, forward traversal for vertices.  <a href="classSawyer_1_1Container_1_1Algorithm_1_1DepthFirstForwardVertexTraversal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1DepthFirstReverseEdgeTraversal.html">DepthFirstReverseEdgeTraversal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Depth-first, reverse traversal for edges.  <a href="classSawyer_1_1Container_1_1Algorithm_1_1DepthFirstReverseEdgeTraversal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1DepthFirstReverseGraphTraversal.html">DepthFirstReverseGraphTraversal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Depth-first, reverse traversal for all event types.  <a href="classSawyer_1_1Container_1_1Algorithm_1_1DepthFirstReverseGraphTraversal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1DepthFirstReverseVertexTraversal.html">DepthFirstReverseVertexTraversal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Depth-first, reverse traversal for vertices.  <a href="classSawyer_1_1Container_1_1Algorithm_1_1DepthFirstReverseVertexTraversal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1DepthFirstTraversalTag.html">DepthFirstTraversalTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Order tag for depth-first traversals.  <a href="classSawyer_1_1Container_1_1Algorithm_1_1DepthFirstTraversalTag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1FirstIsomorphicSubgraph.html">FirstIsomorphicSubgraph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1ForwardTraversalTag.html">ForwardTraversalTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direction tag for forward traversals.  <a href="classSawyer_1_1Container_1_1Algorithm_1_1ForwardTraversalTag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1GraphEdgeTraversal.html">GraphEdgeTraversal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for graph edge traversals.  <a href="classSawyer_1_1Container_1_1Algorithm_1_1GraphEdgeTraversal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1GraphTraversal.html">GraphTraversal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for graph traversals.  <a href="classSawyer_1_1Container_1_1Algorithm_1_1GraphTraversal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1GraphVertexTraversal.html">GraphVertexTraversal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for graph vertex traversals.  <a href="classSawyer_1_1Container_1_1Algorithm_1_1GraphVertexTraversal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1IdAccumulator.html">IdAccumulator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accumulates vertex or edge IDs.  <a href="classSawyer_1_1Container_1_1Algorithm_1_1IdAccumulator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1MaximumIsomorphicSubgraphs.html">MaximumIsomorphicSubgraphs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1ReverseTraversalTag.html">ReverseTraversalTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direction tag for reverse traversals.  <a href="classSawyer_1_1Container_1_1Algorithm_1_1ReverseTraversalTag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ad6fc5c4b7ff7dd31ed0a2903a37228ae"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1Algorithm.html#ad6fc5c4b7ff7dd31ed0a2903a37228ae">CsiNextAction</a> { <br />
&#160;&#160;<a class="el" href="namespaceSawyer_1_1Container_1_1Algorithm.html#ad6fc5c4b7ff7dd31ed0a2903a37228aea6b096a1316b38af50d73ff9160fd9ac2">CSI_CONTINUE</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceSawyer_1_1Container_1_1Algorithm.html#ad6fc5c4b7ff7dd31ed0a2903a37228aea63a70d8f1a4b90cd6b3214ece248534f">CSI_ABORT</a>
<br />
 }</td></tr>
<tr class="memdesc:ad6fc5c4b7ff7dd31ed0a2903a37228ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">How the CSI algorith should proceed.  <a href="namespaceSawyer_1_1Container_1_1Algorithm.html#ad6fc5c4b7ff7dd31ed0a2903a37228ae">More...</a><br /></td></tr>
<tr class="separator:ad6fc5c4b7ff7dd31ed0a2903a37228ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a563d6bb47e082bbe1e40bcc59e1f59"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1Algorithm.html#a4a563d6bb47e082bbe1e40bcc59e1f59">TraversalEvent</a> { <br />
&#160;&#160;<a class="el" href="namespaceSawyer_1_1Container_1_1Algorithm.html#a4a563d6bb47e082bbe1e40bcc59e1f59ae9794d1fb49c789316f2ae2e99f8ce49">NO_EVENT</a> = 0, 
<br />
&#160;&#160;<a class="el" href="namespaceSawyer_1_1Container_1_1Algorithm.html#a4a563d6bb47e082bbe1e40bcc59e1f59a269618ed6163d346e3fdfbb93a40e1a8">ENTER_VERTEX</a> = 0x0001, 
<br />
&#160;&#160;<a class="el" href="namespaceSawyer_1_1Container_1_1Algorithm.html#a4a563d6bb47e082bbe1e40bcc59e1f59a0959fa465db7d4309420127156f68225">ENTER_EDGE</a> = 0x0002, 
<br />
&#160;&#160;<a class="el" href="namespaceSawyer_1_1Container_1_1Algorithm.html#a4a563d6bb47e082bbe1e40bcc59e1f59a1b53649c377c76f14ac8e5156632f62d">DISCOVER_VERTEX</a> = 0x0004, 
<br />
&#160;&#160;<a class="el" href="namespaceSawyer_1_1Container_1_1Algorithm.html#a4a563d6bb47e082bbe1e40bcc59e1f59adb18b0b96348768b913b308524c6774c">LEAVE_EDGE</a> = 0x0008, 
<br />
&#160;&#160;<a class="el" href="namespaceSawyer_1_1Container_1_1Algorithm.html#a4a563d6bb47e082bbe1e40bcc59e1f59ad8fee8f41676c2bb90dba24f2193dda0">LEAVE_VERTEX</a> = 0x0010, 
<br />
&#160;&#160;<b>FOLLOW_EDGE</b> = 0x0020
<br />
 }</td></tr>
<tr class="memdesc:a4a563d6bb47e082bbe1e40bcc59e1f59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Events returned by a graph traversal.  <a href="namespaceSawyer_1_1Container_1_1Algorithm.html#a4a563d6bb47e082bbe1e40bcc59e1f59">More...</a><br /></td></tr>
<tr class="separator:a4a563d6bb47e082bbe1e40bcc59e1f59"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac20b52b7f490c205c8ed14614f9f001f"><td class="memTemplParams" colspan="2">template&lt;class Graph &gt; </td></tr>
<tr class="memitem:ac20b52b7f490c205c8ed14614f9f001f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1Algorithm.html#ac20b52b7f490c205c8ed14614f9f001f">graphContainsCycle</a> (const <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Graph</a> &amp;g)</td></tr>
<tr class="memdesc:ac20b52b7f490c205c8ed14614f9f001f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the any edges of a graph form a cycle.  <a href="namespaceSawyer_1_1Container_1_1Algorithm.html#ac20b52b7f490c205c8ed14614f9f001f">More...</a><br /></td></tr>
<tr class="separator:ac20b52b7f490c205c8ed14614f9f001f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf5f70a934f1b002f6ae5087334d1692"><td class="memTemplParams" colspan="2">template&lt;class Graph &gt; </td></tr>
<tr class="memitem:abf5f70a934f1b002f6ae5087334d1692"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1Algorithm.html#abf5f70a934f1b002f6ae5087334d1692">graphBreakCycles</a> (<a class="el" href="classSawyer_1_1Container_1_1Graph.html">Graph</a> &amp;g)</td></tr>
<tr class="memdesc:abf5f70a934f1b002f6ae5087334d1692"><td class="mdescLeft">&#160;</td><td class="mdescRight">Break cycles of a graph arbitrarily.  <a href="namespaceSawyer_1_1Container_1_1Algorithm.html#abf5f70a934f1b002f6ae5087334d1692">More...</a><br /></td></tr>
<tr class="separator:abf5f70a934f1b002f6ae5087334d1692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61fe8c4aaae390361068b47d7be07ce6"><td class="memTemplParams" colspan="2">template&lt;class Graph &gt; </td></tr>
<tr class="memitem:a61fe8c4aaae390361068b47d7be07ce6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1Algorithm.html#a61fe8c4aaae390361068b47d7be07ce6">graphIsConnected</a> (const <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Graph</a> &amp;g)</td></tr>
<tr class="memdesc:a61fe8c4aaae390361068b47d7be07ce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether a graph is connected.  <a href="namespaceSawyer_1_1Container_1_1Algorithm.html#a61fe8c4aaae390361068b47d7be07ce6">More...</a><br /></td></tr>
<tr class="separator:a61fe8c4aaae390361068b47d7be07ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a004e957c997090ef76a78a40bf27b3ea"><td class="memTemplParams" colspan="2">template&lt;class Graph &gt; </td></tr>
<tr class="memitem:a004e957c997090ef76a78a40bf27b3ea"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1Algorithm.html#a004e957c997090ef76a78a40bf27b3ea">graphFindConnectedComponents</a> (const <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Graph</a> &amp;g, std::vector&lt; size_t &gt; &amp;components)</td></tr>
<tr class="memdesc:a004e957c997090ef76a78a40bf27b3ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all connected components of a graph.  <a href="namespaceSawyer_1_1Container_1_1Algorithm.html#a004e957c997090ef76a78a40bf27b3ea">More...</a><br /></td></tr>
<tr class="separator:a004e957c997090ef76a78a40bf27b3ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec93e4ec85b0e53249e4a71fbdf60976"><td class="memTemplParams" colspan="2">template&lt;class Graph &gt; </td></tr>
<tr class="memitem:aec93e4ec85b0e53249e4a71fbdf60976"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1Graph.html">Graph</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1Algorithm.html#aec93e4ec85b0e53249e4a71fbdf60976">graphCopySubgraph</a> (const <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Graph</a> &amp;g, const std::vector&lt; size_t &gt; &amp;vertexIdVector)</td></tr>
<tr class="memdesc:aec93e4ec85b0e53249e4a71fbdf60976"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a subgraph.  <a href="namespaceSawyer_1_1Container_1_1Algorithm.html#aec93e4ec85b0e53249e4a71fbdf60976">More...</a><br /></td></tr>
<tr class="separator:aec93e4ec85b0e53249e4a71fbdf60976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a161193a07d366622dfefaa55cb6eb940"><td class="memTemplParams" colspan="2">template&lt;class Graph &gt; </td></tr>
<tr class="memitem:a161193a07d366622dfefaa55cb6eb940"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1Algorithm.html#a161193a07d366622dfefaa55cb6eb940">graphEraseParallelEdges</a> (<a class="el" href="classSawyer_1_1Container_1_1Graph.html">Graph</a> &amp;g)</td></tr>
<tr class="memdesc:a161193a07d366622dfefaa55cb6eb940"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase parallel edges.  <a href="namespaceSawyer_1_1Container_1_1Algorithm.html#a161193a07d366622dfefaa55cb6eb940">More...</a><br /></td></tr>
<tr class="separator:a161193a07d366622dfefaa55cb6eb940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dccfa1551c6fa2bfbe2aa891e9fc35c"><td class="memTemplParams" colspan="2">template&lt;class Graph &gt; </td></tr>
<tr class="memitem:a7dccfa1551c6fa2bfbe2aa891e9fc35c"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; size_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1Algorithm.html#a7dccfa1551c6fa2bfbe2aa891e9fc35c">graphDependentOrder</a> (<a class="el" href="classSawyer_1_1Container_1_1Graph.html">Graph</a> &amp;g)</td></tr>
<tr class="memdesc:a7dccfa1551c6fa2bfbe2aa891e9fc35c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number vertices according to their height from the leaves.  <a href="namespaceSawyer_1_1Container_1_1Algorithm.html#a7dccfa1551c6fa2bfbe2aa891e9fc35c">More...</a><br /></td></tr>
<tr class="separator:a7dccfa1551c6fa2bfbe2aa891e9fc35c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b60b61ef69fc5f908ea7c6a80cf8394"><td class="memTemplParams" colspan="2">template&lt;class Direction , class Graph &gt; </td></tr>
<tr class="memitem:a1b60b61ef69fc5f908ea7c6a80cf8394"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename <a class="el" href="structSawyer_1_1Container_1_1GraphTraits.html">GraphTraits</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Graph</a> &gt;::VertexIterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1Algorithm.html#a1b60b61ef69fc5f908ea7c6a80cf8394">graphDirectedDominators</a> (<a class="el" href="classSawyer_1_1Container_1_1Graph.html">Graph</a> &amp;g, typename <a class="el" href="structSawyer_1_1Container_1_1GraphTraits.html">GraphTraits</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Graph</a> &gt;::VertexIterator root)</td></tr>
<tr class="memdesc:a1b60b61ef69fc5f908ea7c6a80cf8394"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find immediate pre- or post-dominators.  <a href="namespaceSawyer_1_1Container_1_1Algorithm.html#a1b60b61ef69fc5f908ea7c6a80cf8394">More...</a><br /></td></tr>
<tr class="separator:a1b60b61ef69fc5f908ea7c6a80cf8394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69be98b48ce918b766a572e38bf8b5a4"><td class="memTemplParams" colspan="2">template&lt;class Graph &gt; </td></tr>
<tr class="memitem:a69be98b48ce918b766a572e38bf8b5a4"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename <a class="el" href="structSawyer_1_1Container_1_1GraphTraits.html">GraphTraits</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Graph</a> &gt;::VertexIterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1Algorithm.html#a69be98b48ce918b766a572e38bf8b5a4">graphDominators</a> (<a class="el" href="classSawyer_1_1Container_1_1Graph.html">Graph</a> &amp;g, typename <a class="el" href="structSawyer_1_1Container_1_1GraphTraits.html">GraphTraits</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Graph</a> &gt;::VertexIterator root)</td></tr>
<tr class="memdesc:a69be98b48ce918b766a572e38bf8b5a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find immediate pre-dominators.  <a href="namespaceSawyer_1_1Container_1_1Algorithm.html#a69be98b48ce918b766a572e38bf8b5a4">More...</a><br /></td></tr>
<tr class="separator:a69be98b48ce918b766a572e38bf8b5a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aa402d88848560750c563af1142ccc6"><td class="memTemplParams" colspan="2">template&lt;class Graph &gt; </td></tr>
<tr class="memitem:a0aa402d88848560750c563af1142ccc6"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename <a class="el" href="structSawyer_1_1Container_1_1GraphTraits.html">GraphTraits</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Graph</a> &gt;::VertexIterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1Algorithm.html#a0aa402d88848560750c563af1142ccc6">graphPostDominators</a> (<a class="el" href="classSawyer_1_1Container_1_1Graph.html">Graph</a> &amp;g, typename <a class="el" href="structSawyer_1_1Container_1_1GraphTraits.html">GraphTraits</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Graph</a> &gt;::VertexIterator root)</td></tr>
<tr class="memdesc:a0aa402d88848560750c563af1142ccc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find immediate post-dominators.  <a href="namespaceSawyer_1_1Container_1_1Algorithm.html#a0aa402d88848560750c563af1142ccc6">More...</a><br /></td></tr>
<tr class="separator:a0aa402d88848560750c563af1142ccc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77b4c867570c75d5df3839f0d7f066f3"><td class="memItemLeft" align="right" valign="top"><a id="a77b4c867570c75d5df3839f0d7f066f3"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1Algorithm.html#a77b4c867570c75d5df3839f0d7f066f3">traversalEventName</a> (<a class="el" href="namespaceSawyer_1_1Container_1_1Algorithm.html#a4a563d6bb47e082bbe1e40bcc59e1f59">TraversalEvent</a>)</td></tr>
<tr class="memdesc:a77b4c867570c75d5df3839f0d7f066f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event name from constant. <br /></td></tr>
<tr class="separator:a77b4c867570c75d5df3839f0d7f066f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a617753cc017ccac11b19da2d650c8423"><td class="memTemplParams" colspan="2">template&lt;class Traversal &gt; </td></tr>
<tr class="memitem:a617753cc017ccac11b19da2d650c8423"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; size_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1Algorithm.html#a617753cc017ccac11b19da2d650c8423">graphReachableVertices</a> (Traversal t)</td></tr>
<tr class="memdesc:a617753cc017ccac11b19da2d650c8423"><td class="mdescLeft">&#160;</td><td class="mdescRight">IDs of vertices reachable from root.  <a href="namespaceSawyer_1_1Container_1_1Algorithm.html#a617753cc017ccac11b19da2d650c8423">More...</a><br /></td></tr>
<tr class="separator:a617753cc017ccac11b19da2d650c8423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa70b47812a00752e613b169b229011b0"><td class="memTemplParams" colspan="2">template&lt;class Traversal &gt; </td></tr>
<tr class="memitem:aa70b47812a00752e613b169b229011b0"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; size_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1Algorithm.html#aa70b47812a00752e613b169b229011b0">graphReachableEdges</a> (Traversal t)</td></tr>
<tr class="memdesc:aa70b47812a00752e613b169b229011b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">IDs of edges reachable from root.  <a href="namespaceSawyer_1_1Container_1_1Algorithm.html#aa70b47812a00752e613b169b229011b0">More...</a><br /></td></tr>
<tr class="separator:aa70b47812a00752e613b169b229011b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15cdd0bcba0a605f526ce25c976c417a"><td class="memTemplParams" colspan="2">template&lt;class Traversal , class Graph &gt; </td></tr>
<tr class="memitem:a15cdd0bcba0a605f526ce25c976c417a"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; size_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1Algorithm.html#a15cdd0bcba0a605f526ce25c976c417a">graphAllVertices</a> (<a class="el" href="classSawyer_1_1Container_1_1Graph.html">Graph</a> &amp;graph)</td></tr>
<tr class="memdesc:a15cdd0bcba0a605f526ce25c976c417a"><td class="mdescLeft">&#160;</td><td class="mdescRight">IDs of all vertices.  <a href="namespaceSawyer_1_1Container_1_1Algorithm.html#a15cdd0bcba0a605f526ce25c976c417a">More...</a><br /></td></tr>
<tr class="separator:a15cdd0bcba0a605f526ce25c976c417a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac379b7e16d94b797e46721fee801ec3"><td class="memTemplParams" colspan="2">template&lt;class Traversal , class Graph &gt; </td></tr>
<tr class="memitem:aac379b7e16d94b797e46721fee801ec3"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; size_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1Algorithm.html#aac379b7e16d94b797e46721fee801ec3">graphAllEdges</a> (<a class="el" href="classSawyer_1_1Container_1_1Graph.html">Graph</a> &amp;graph)</td></tr>
<tr class="memdesc:aac379b7e16d94b797e46721fee801ec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">IDs of all edges.  <a href="namespaceSawyer_1_1Container_1_1Algorithm.html#aac379b7e16d94b797e46721fee801ec3">More...</a><br /></td></tr>
<tr class="separator:aac379b7e16d94b797e46721fee801ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ad6fc5c4b7ff7dd31ed0a2903a37228ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6fc5c4b7ff7dd31ed0a2903a37228ae">&#9670;&nbsp;</a></span>CsiNextAction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceSawyer_1_1Container_1_1Algorithm.html#ad6fc5c4b7ff7dd31ed0a2903a37228ae">Sawyer::Container::Algorithm::CsiNextAction</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>How the CSI algorith should proceed. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad6fc5c4b7ff7dd31ed0a2903a37228aea6b096a1316b38af50d73ff9160fd9ac2"></a>CSI_CONTINUE&#160;</td><td class="fielddoc"><p>Continue searching for more solutions. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad6fc5c4b7ff7dd31ed0a2903a37228aea63a70d8f1a4b90cd6b3214ece248534f"></a>CSI_ABORT&#160;</td><td class="fielddoc"><p>Return to caller without further searching. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="GraphAlgorithm_8h_source.html#l00374">374</a> of file <a class="el" href="GraphAlgorithm_8h_source.html">GraphAlgorithm.h</a>.</p>

</div>
</div>
<a id="a4a563d6bb47e082bbe1e40bcc59e1f59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a563d6bb47e082bbe1e40bcc59e1f59">&#9670;&nbsp;</a></span>TraversalEvent</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceSawyer_1_1Container_1_1Algorithm.html#a4a563d6bb47e082bbe1e40bcc59e1f59">Sawyer::Container::Algorithm::TraversalEvent</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Events returned by a graph traversal. </p>
<p>The graph traversal <a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1GraphTraversal.html#a574c3e3db87c283066fd908ef4ab0863">advance</a> method single steps through a traversal and returns control to the caller whenever a desired stopping point is reached. The stopping points are specified by a bit mask of these event type constants.</p>
<p>Besides the enumerated constants, the following <code>unsigned</code> bit masks are also defined:</p>
<ul>
<li><code>VERTEX_EVENTS:</code> all events related to vertices, namley <a class="el" href="namespaceSawyer_1_1Container_1_1Algorithm.html#a4a563d6bb47e082bbe1e40bcc59e1f59a269618ed6163d346e3fdfbb93a40e1a8">ENTER_VERTEX</a>, <a class="el" href="namespaceSawyer_1_1Container_1_1Algorithm.html#a4a563d6bb47e082bbe1e40bcc59e1f59ad8fee8f41676c2bb90dba24f2193dda0">LEAVE_VERTEX</a>, and <a class="el" href="namespaceSawyer_1_1Container_1_1Algorithm.html#a4a563d6bb47e082bbe1e40bcc59e1f59a1b53649c377c76f14ac8e5156632f62d">DISCOVER_VERTEX</a>. </li>
<li><code>EDGE_EVENTS:</code> all events related to edges, namely <a class="el" href="namespaceSawyer_1_1Container_1_1Algorithm.html#a4a563d6bb47e082bbe1e40bcc59e1f59a0959fa465db7d4309420127156f68225">ENTER_EDGE</a> and <a class="el" href="namespaceSawyer_1_1Container_1_1Algorithm.html#a4a563d6bb47e082bbe1e40bcc59e1f59adb18b0b96348768b913b308524c6774c">LEAVE_EDGE</a>. </li>
<li><code>ENTER_EVENTS:</code> all events for entering a node, namely <a class="el" href="namespaceSawyer_1_1Container_1_1Algorithm.html#a4a563d6bb47e082bbe1e40bcc59e1f59a269618ed6163d346e3fdfbb93a40e1a8">ENTER_VERTEX</a> and <a class="el" href="namespaceSawyer_1_1Container_1_1Algorithm.html#a4a563d6bb47e082bbe1e40bcc59e1f59a0959fa465db7d4309420127156f68225">ENTER_EDGE</a>. </li>
<li><code>LEAVE_EVENTS:</code> all events for leaving a node, namely <a class="el" href="namespaceSawyer_1_1Container_1_1Algorithm.html#a4a563d6bb47e082bbe1e40bcc59e1f59ad8fee8f41676c2bb90dba24f2193dda0">LEAVE_VERTEX</a> and <a class="el" href="namespaceSawyer_1_1Container_1_1Algorithm.html#a4a563d6bb47e082bbe1e40bcc59e1f59adb18b0b96348768b913b308524c6774c">LEAVE_EDGE</a>. </li>
<li><code>ENTER_LEAVE_EVENTS:</code> the union of <code>ENTER_EVENTS</code> and <code>LEAVE_EVENTS</code>. </li>
<li><code>ALL_EVENTS:</code> just like it sounds. </li>
</ul>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a4a563d6bb47e082bbe1e40bcc59e1f59ae9794d1fb49c789316f2ae2e99f8ce49"></a>NO_EVENT&#160;</td><td class="fielddoc"><p>No event. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4a563d6bb47e082bbe1e40bcc59e1f59a269618ed6163d346e3fdfbb93a40e1a8"></a>ENTER_VERTEX&#160;</td><td class="fielddoc"><p><a class="el" href="structVertex.html">Vertex</a> entered for first time. </p>
<p>The traversal will return the vertex just entered and the edge by which it was entered. If the vertex was entered due to being set explicitly as the current vertex, then the edge will be an end iterator. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4a563d6bb47e082bbe1e40bcc59e1f59a0959fa465db7d4309420127156f68225"></a>ENTER_EDGE&#160;</td><td class="fielddoc"><p><a class="el" href="structEdge.html">Edge</a> is entered. </p>
<p>Edges are entered after their originating vertex is entered and possibly before discovering the vertex at the far end of the edge. We use terms "originating" and "far end" because traversals can flow in the natural direction of the edge (from source to target) or in reverse (from target to source). When stopped at this event, the traversal will return the entered edge along with the vertex from which it was entered. If the edge was set explicitly as a traversal position then the vertex will be an end iterator. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4a563d6bb47e082bbe1e40bcc59e1f59a1b53649c377c76f14ac8e5156632f62d"></a>DISCOVER_VERTEX&#160;</td><td class="fielddoc"><p>Neighboring vertex discovered for the first time. </p>
<p><a class="el" href="structVertex.html">Vertex</a> discover happens after an edge is entered. When stopped at this event, the traversal will return the vertex that is being discovered and the edge by which it was discovered. If the vertex was explicitly set as the traversal's current position then the edge will be an end iterator. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4a563d6bb47e082bbe1e40bcc59e1f59adb18b0b96348768b913b308524c6774c"></a>LEAVE_EDGE&#160;</td><td class="fielddoc"><p>Leaving edge. </p>
<p>The traversal eventually leaves all edges that were entered. In a breadth-first search the traversal leaves an entered edge before entering any other edge, while in a depth-first traversal the stack of entered edges may become quite deep. A traversal stopped at this event returns the edge which is being left and the vertex from which the edge was originally entered. If the edge was set explicitly then the vertex will be an end iterator. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4a563d6bb47e082bbe1e40bcc59e1f59ad8fee8f41676c2bb90dba24f2193dda0"></a>LEAVE_VERTEX&#160;</td><td class="fielddoc"><p>Leaving vertex. </p>
<p>The traversal eventually leaves all vertices that were entered. A vertex is left after entering and leaving all the edges that originate (for the purpose of traversal) from the vertex. In a breadth-first search the traversal leaves an entered vertex before entering any other vertex, while in a depth-first search the stack of entered vertices may become quite deep. A traversal stopped at this event returns the vertex which is being left and the edge by which the vertex was originally entered. If the vertex was set as an explicit traversal position then the edge will be an end iterator. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="GraphTraversal_8h_source.html#l00039">39</a> of file <a class="el" href="GraphTraversal_8h_source.html">GraphTraversal.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ac20b52b7f490c205c8ed14614f9f001f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac20b52b7f490c205c8ed14614f9f001f">&#9670;&nbsp;</a></span>graphContainsCycle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Sawyer::Container::Algorithm::graphContainsCycle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if the any edges of a graph form a cycle. </p>
<p>Returns true if any cycle is found, false if the graph contains no cycles. </p>

<p class="definition">Definition at line <a class="el" href="GraphAlgorithm_8h_source.html#l00048">48</a> of file <a class="el" href="GraphAlgorithm_8h_source.html">GraphAlgorithm.h</a>.</p>

<p class="reference">References <a class="el" href="GraphTraversal_8h_source.html#l00044">ENTER_EDGE</a>, <a class="el" href="Graph_8h_source.html#l01507">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::findVertex()</a>, <a class="el" href="GraphTraversal_8h_source.html#l00054">LEAVE_EDGE</a>, and <a class="el" href="Graph_8h_source.html#l01676">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::nVertices()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceSawyer_1_1Container_1_1Algorithm_ac20b52b7f490c205c8ed14614f9f001f_cgraph.png" border="0" usemap="#namespaceSawyer_1_1Container_1_1Algorithm_ac20b52b7f490c205c8ed14614f9f001f_cgraph" alt=""/></div>
<map name="namespaceSawyer_1_1Container_1_1Algorithm_ac20b52b7f490c205c8ed14614f9f001f_cgraph" id="namespaceSawyer_1_1Container_1_1Algorithm_ac20b52b7f490c205c8ed14614f9f001f_cgraph">
<area shape="rect" title="Determines if the any edges of a graph form a cycle." alt="" coords="5,39,208,80"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Graph.html#a3f256b70a465482d53478b84941dc8b5" title="Finds the vertex with specified ID number." alt="" coords="256,5,395,47"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Graph.html#a4c5244b7dddd1f511a0a9350fc79e182" title="Total number of vertices." alt="" coords="256,71,395,112"/>
</map>
</div>

</div>
</div>
<a id="abf5f70a934f1b002f6ae5087334d1692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf5f70a934f1b002f6ae5087334d1692">&#9670;&nbsp;</a></span>graphBreakCycles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t Sawyer::Container::Algorithm::graphBreakCycles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1Container_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Break cycles of a graph arbitrarily. </p>
<p>Modifies the argument in place to remove edges that cause cycles. Edges are not removed in any particular order. Returns the number of edges that were removed. </p>

<p class="definition">Definition at line <a class="el" href="GraphAlgorithm_8h_source.html#l00086">86</a> of file <a class="el" href="GraphAlgorithm_8h_source.html">GraphAlgorithm.h</a>.</p>

<p class="reference">References <a class="el" href="GraphTraversal_8h_source.html#l00044">ENTER_EDGE</a>, <a class="el" href="Graph_8h_source.html#l01802">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::eraseEdge()</a>, <a class="el" href="Graph_8h_source.html#l01507">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::findVertex()</a>, <a class="el" href="Sawyer_2Map_8h_source.html#l00603">Sawyer::Container::Map&lt; K, T, Cmp, Alloc &gt;::insert()</a>, <a class="el" href="GraphTraversal_8h_source.html#l00054">LEAVE_EDGE</a>, <a class="el" href="Graph_8h_source.html#l01676">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::nVertices()</a>, <a class="el" href="Sawyer_2Map_8h_source.html#l00395">Sawyer::Container::Map&lt; K, T, Cmp, Alloc &gt;::size()</a>, and <a class="el" href="Sawyer_2Map_8h_source.html#l00371">Sawyer::Container::Map&lt; K, T, Cmp, Alloc &gt;::values()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceSawyer_1_1Container_1_1Algorithm_abf5f70a934f1b002f6ae5087334d1692_cgraph.png" border="0" usemap="#namespaceSawyer_1_1Container_1_1Algorithm_abf5f70a934f1b002f6ae5087334d1692_cgraph" alt=""/></div>
<map name="namespaceSawyer_1_1Container_1_1Algorithm_abf5f70a934f1b002f6ae5087334d1692_cgraph" id="namespaceSawyer_1_1Container_1_1Algorithm_abf5f70a934f1b002f6ae5087334d1692_cgraph">
<area shape="rect" title="Break cycles of a graph arbitrarily." alt="" coords="5,169,197,211"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Graph.html#a5126c672c46a466ea78d7a2bd05b366d" title="Erases an edge." alt="" coords="245,5,384,47"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Graph.html#a3f256b70a465482d53478b84941dc8b5" title="Finds the vertex with specified ID number." alt="" coords="245,71,384,112"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Map.html#aa966f345ed4157539fdb8d5dfdd8cd0b" title="Insert or update a key/value pair." alt="" coords="245,136,384,177"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Graph.html#a4c5244b7dddd1f511a0a9350fc79e182" title="Total number of vertices." alt="" coords="245,201,384,243"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Map.html#a7976fcd86256ca6543e2ebff0b145898" title="Number of nodes, keys, or values in this container." alt="" coords="245,267,384,308"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Map.html#a44476737dd7087388c0bffbfd0526af9" title="Iterators for container values." alt="" coords="245,332,384,373"/>
</map>
</div>

</div>
</div>
<a id="a61fe8c4aaae390361068b47d7be07ce6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61fe8c4aaae390361068b47d7be07ce6">&#9670;&nbsp;</a></span>graphIsConnected()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Sawyer::Container::Algorithm::graphIsConnected </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test whether a graph is connected. </p>
<p>Returns true if a graph is connected and false if not. This is a special case of findConnectedComponents but is faster for graphs that are not connected since this algorithm only needs to find one connected component instead of all connected components.</p>
<p>Time complexity is O(|V|+|E|).</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceSawyer_1_1Container_1_1Algorithm.html#a004e957c997090ef76a78a40bf27b3ea" title="Find all connected components of a graph.">graphFindConnectedComponents</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="GraphAlgorithm_8h_source.html#l00136">136</a> of file <a class="el" href="GraphAlgorithm_8h_source.html">GraphAlgorithm.h</a>.</p>

<p class="reference">References <a class="el" href="DenseIntegerSet_8h_source.html#l00439">Sawyer::Container::DenseIntegerSet&lt; T &gt;::erase()</a>, <a class="el" href="Graph_8h_source.html#l01507">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::findVertex()</a>, <a class="el" href="Graph_8h_source.html#l01208">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::Vertex::id()</a>, <a class="el" href="Graph_8h_source.html#l01219">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::Vertex::inEdges()</a>, <a class="el" href="DenseIntegerSet_8h_source.html#l00366">Sawyer::Container::DenseIntegerSet&lt; T &gt;::insert()</a>, <a class="el" href="DenseIntegerSet_8h_source.html#l00266">Sawyer::Container::DenseIntegerSet&lt; T &gt;::isEmpty()</a>, <a class="el" href="Graph_8h_source.html#l01695">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::isEmpty()</a>, <a class="el" href="Graph_8h_source.html#l01676">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::nVertices()</a>, <a class="el" href="Graph_8h_source.html#l01240">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::Vertex::outEdges()</a>, <a class="el" href="Graph_8h_source.html#l01145">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::Edge::source()</a>, <a class="el" href="Graph_8h_source.html#l01157">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::Edge::target()</a>, and <a class="el" href="DenseIntegerSet_8h_source.html#l00255">Sawyer::Container::DenseIntegerSet&lt; T &gt;::values()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceSawyer_1_1Container_1_1Algorithm_a61fe8c4aaae390361068b47d7be07ce6_cgraph.png" border="0" usemap="#namespaceSawyer_1_1Container_1_1Algorithm_a61fe8c4aaae390361068b47d7be07ce6_cgraph" alt=""/></div>
<map name="namespaceSawyer_1_1Container_1_1Algorithm_a61fe8c4aaae390361068b47d7be07ce6_cgraph" id="namespaceSawyer_1_1Container_1_1Algorithm_a61fe8c4aaae390361068b47d7be07ce6_cgraph">
<area shape="rect" title="Test whether a graph is connected." alt="" coords="5,365,196,407"/>
<area shape="rect" href="classSawyer_1_1Container_1_1DenseIntegerSet.html#a185b1a0060ccc17acde9bde3ddc6affc" title="Erase a value." alt="" coords="252,5,412,47"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Graph.html#a3f256b70a465482d53478b84941dc8b5" title="Finds the vertex with specified ID number." alt="" coords="263,71,401,112"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Graph_1_1Vertex.html#af8439ff325ea20ab17e0418268546fbf" title="Unique vertex ID number." alt="" coords="263,136,401,177"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Graph_1_1Vertex.html#a307bb5288a8fe69f61f2321ab27c4659" title="List of incoming edges." alt="" coords="253,201,411,243"/>
<area shape="rect" href="classSawyer_1_1Container_1_1DenseIntegerSet.html#a01b3e62c997d3058451373b8cf95dae8" title="Insert a value." alt="" coords="252,267,412,308"/>
<area shape="rect" href="classSawyer_1_1Container_1_1DenseIntegerSet.html#a773de8cceec7e9e94206e0d98cf5a510" title="Whether the set is empty." alt="" coords="244,332,420,373"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Graph.html#a8d56d6c421b427eea9c7e29d3f1963ee" title="True if graph is empty." alt="" coords="263,397,401,439"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Graph.html#a4c5244b7dddd1f511a0a9350fc79e182" title="Total number of vertices." alt="" coords="263,463,401,504"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Graph_1_1Vertex.html#a3df407366de5c601d55c7ee4e8b32558" title="List of outgoing edges." alt="" coords="249,528,415,569"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Graph_1_1Edge.html#a27950beb3dd2e15e557ed12923ca85b7" title="Source vertex." alt="" coords="261,593,403,635"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Graph_1_1Edge.html#acad205ee0450a9915b7e193b442f33b8" title="Target vertex." alt="" coords="263,659,401,700"/>
<area shape="rect" href="classSawyer_1_1Container_1_1DenseIntegerSet.html#a2ba067ab2f996d56cc0b7ac704d9e840" title="Iterator range for set members." alt="" coords="249,724,415,765"/>
</map>
</div>

</div>
</div>
<a id="a004e957c997090ef76a78a40bf27b3ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a004e957c997090ef76a78a40bf27b3ea">&#9670;&nbsp;</a></span>graphFindConnectedComponents()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t Sawyer::Container::Algorithm::graphFindConnectedComponents </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>components</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find all connected components of a graph. </p>
<p>Finds all connected components of a graph and numbers them starting at zero. The provided vector is initialized to hold the results with the vector serving as a map from vertex ID number to connected component number. Returns the number of conencted components.</p>
<p>Time complexity is O(|V|+|E|).</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceSawyer_1_1Container_1_1Algorithm.html#a61fe8c4aaae390361068b47d7be07ce6">graphIsConnected</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="GraphAlgorithm_8h_source.html#l00176">176</a> of file <a class="el" href="GraphAlgorithm_8h_source.html">GraphAlgorithm.h</a>.</p>

<p class="reference">References <a class="el" href="DenseIntegerSet_8h_source.html#l00439">Sawyer::Container::DenseIntegerSet&lt; T &gt;::erase()</a>, <a class="el" href="Graph_8h_source.html#l01507">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::findVertex()</a>, <a class="el" href="Graph_8h_source.html#l01208">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::Vertex::id()</a>, <a class="el" href="Graph_8h_source.html#l01219">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::Vertex::inEdges()</a>, <a class="el" href="DenseIntegerSet_8h_source.html#l00366">Sawyer::Container::DenseIntegerSet&lt; T &gt;::insert()</a>, <a class="el" href="DenseIntegerSet_8h_source.html#l00266">Sawyer::Container::DenseIntegerSet&lt; T &gt;::isEmpty()</a>, <a class="el" href="Graph_8h_source.html#l01676">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::nVertices()</a>, <a class="el" href="Graph_8h_source.html#l01240">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::Vertex::outEdges()</a>, <a class="el" href="Graph_8h_source.html#l01145">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::Edge::source()</a>, <a class="el" href="Graph_8h_source.html#l01157">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::Edge::target()</a>, and <a class="el" href="DenseIntegerSet_8h_source.html#l00255">Sawyer::Container::DenseIntegerSet&lt; T &gt;::values()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceSawyer_1_1Container_1_1Algorithm_a004e957c997090ef76a78a40bf27b3ea_cgraph.png" border="0" usemap="#namespaceSawyer_1_1Container_1_1Algorithm_a004e957c997090ef76a78a40bf27b3ea_cgraph" alt=""/></div>
<map name="namespaceSawyer_1_1Container_1_1Algorithm_a004e957c997090ef76a78a40bf27b3ea_cgraph" id="namespaceSawyer_1_1Container_1_1Algorithm_a004e957c997090ef76a78a40bf27b3ea_cgraph">
<area shape="rect" title="Find all connected components of a graph." alt="" coords="5,325,211,381"/>
<area shape="rect" href="classSawyer_1_1Container_1_1DenseIntegerSet.html#a185b1a0060ccc17acde9bde3ddc6affc" title="Erase a value." alt="" coords="267,5,427,47"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Graph.html#a3f256b70a465482d53478b84941dc8b5" title="Finds the vertex with specified ID number." alt="" coords="277,71,416,112"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Graph_1_1Vertex.html#af8439ff325ea20ab17e0418268546fbf" title="Unique vertex ID number." alt="" coords="277,136,416,177"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Graph_1_1Vertex.html#a307bb5288a8fe69f61f2321ab27c4659" title="List of incoming edges." alt="" coords="267,201,426,243"/>
<area shape="rect" href="classSawyer_1_1Container_1_1DenseIntegerSet.html#a01b3e62c997d3058451373b8cf95dae8" title="Insert a value." alt="" coords="267,267,427,308"/>
<area shape="rect" href="classSawyer_1_1Container_1_1DenseIntegerSet.html#a773de8cceec7e9e94206e0d98cf5a510" title="Whether the set is empty." alt="" coords="259,332,435,373"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Graph.html#a4c5244b7dddd1f511a0a9350fc79e182" title="Total number of vertices." alt="" coords="277,397,416,439"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Graph_1_1Vertex.html#a3df407366de5c601d55c7ee4e8b32558" title="List of outgoing edges." alt="" coords="263,463,430,504"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Graph_1_1Edge.html#a27950beb3dd2e15e557ed12923ca85b7" title="Source vertex." alt="" coords="275,528,418,569"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Graph_1_1Edge.html#acad205ee0450a9915b7e193b442f33b8" title="Target vertex." alt="" coords="277,593,416,635"/>
<area shape="rect" href="classSawyer_1_1Container_1_1DenseIntegerSet.html#a2ba067ab2f996d56cc0b7ac704d9e840" title="Iterator range for set members." alt="" coords="263,659,430,700"/>
</map>
</div>

</div>
</div>
<a id="aec93e4ec85b0e53249e4a71fbdf60976"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec93e4ec85b0e53249e4a71fbdf60976">&#9670;&nbsp;</a></span>graphCopySubgraph()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1Graph.html">Graph</a> Sawyer::Container::Algorithm::graphCopySubgraph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertexIdVector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a subgraph. </p>
<p>Creates a new graph by copying an existing graph, but copying only those vertices whose ID numbers are specified. All edges between the specified vertices are copied. The <code>vertexIdVector</code> should have vertex IDs that are part of graph <code>g</code> and no ID number should occur more than once in that vector.</p>
<p>The ID numbers of the vertices in the returned subgraph are equal to the corresponding index into the <code>vertexIdVector</code> for the super-graph. </p>

<p class="definition">Definition at line <a class="el" href="GraphAlgorithm_8h_source.html#l00221">221</a> of file <a class="el" href="GraphAlgorithm_8h_source.html">GraphAlgorithm.h</a>.</p>

<p class="reference">References <a class="el" href="Graph_8h_source.html#l01507">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::findVertex()</a>, <a class="el" href="Graph_8h_source.html#l01208">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::Vertex::id()</a>, <a class="el" href="Graph_8h_source.html#l01742">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::insertEdge()</a>, <a class="el" href="Graph_8h_source.html#l01712">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::insertVertex()</a>, <a class="el" href="Graph_8h_source.html#l01240">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::Vertex::outEdges()</a>, <a class="el" href="Graph_8h_source.html#l01157">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::Edge::target()</a>, <a class="el" href="Graph_8h_source.html#l01171">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::Edge::value()</a>, <a class="el" href="Graph_8h_source.html#l01284">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::Vertex::value()</a>, and <a class="el" href="Graph_8h_source.html#l01460">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::vertices()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceSawyer_1_1Container_1_1Algorithm_aec93e4ec85b0e53249e4a71fbdf60976_cgraph.png" border="0" usemap="#namespaceSawyer_1_1Container_1_1Algorithm_aec93e4ec85b0e53249e4a71fbdf60976_cgraph" alt=""/></div>
<map name="namespaceSawyer_1_1Container_1_1Algorithm_aec93e4ec85b0e53249e4a71fbdf60976_cgraph" id="namespaceSawyer_1_1Container_1_1Algorithm_aec93e4ec85b0e53249e4a71fbdf60976_cgraph">
<area shape="rect" title="Create a subgraph." alt="" coords="5,267,208,308"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Graph.html#a3f256b70a465482d53478b84941dc8b5" title="Finds the vertex with specified ID number." alt="" coords="270,5,409,47"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Graph_1_1Vertex.html#af8439ff325ea20ab17e0418268546fbf" title="Unique vertex ID number." alt="" coords="270,71,409,112"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Graph.html#a0c3a2fe3c55de1001e0ae8e7508a86f0" title="Insert a new edge." alt="" coords="270,136,409,177"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Graph.html#a5b2a6067898bbf9bdb5f8fc6936d79ff" title="Insert a new vertex." alt="" coords="270,201,409,243"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Graph_1_1Vertex.html#a3df407366de5c601d55c7ee4e8b32558" title="List of outgoing edges." alt="" coords="256,267,423,308"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Graph_1_1Edge.html#acad205ee0450a9915b7e193b442f33b8" title="Target vertex." alt="" coords="270,332,409,373"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Graph_1_1Edge.html#a12c981de3360f2ead8f331a8b7d34fbb" title="User&#45;defined value." alt="" coords="270,397,409,439"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Graph_1_1Vertex.html#a1d1b4b333f58035d8985a90238342b7c" title="User&#45;defined value." alt="" coords="268,463,411,504"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Graph.html#a9aa5860369a9316640518c1eb3894de0" title="Iterators for all vertices." alt="" coords="270,528,409,569"/>
</map>
</div>

</div>
</div>
<a id="a161193a07d366622dfefaa55cb6eb940"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a161193a07d366622dfefaa55cb6eb940">&#9670;&nbsp;</a></span>graphEraseParallelEdges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Sawyer::Container::Algorithm::graphEraseParallelEdges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1Container_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase parallel edges. </p>
<p>Given a graph, erase all but one parallel edge between any two vertices. Parallel edges are defined as any two edges where both have the same source vertex, and both have the same target vertex, and both have equal values. <a class="el" href="structEdge.html">Edge</a> values must be equality comparable but need not be less-than comparable. </p>

<p class="definition">Definition at line <a class="el" href="GraphAlgorithm_8h_source.html#l00255">255</a> of file <a class="el" href="GraphAlgorithm_8h_source.html">GraphAlgorithm.h</a>.</p>

<p class="reference">References <a class="el" href="Graph_8h_source.html#l01802">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::eraseEdge()</a>, <a class="el" href="Graph_8h_source.html#l01262">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::Vertex::nOutEdges()</a>, <a class="el" href="Graph_8h_source.html#l01240">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::Vertex::outEdges()</a>, <a class="el" href="Graph_8h_source.html#l01157">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::Edge::target()</a>, <a class="el" href="Graph_8h_source.html#l01171">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::Edge::value()</a>, and <a class="el" href="Graph_8h_source.html#l01460">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::vertices()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceSawyer_1_1Container_1_1Algorithm_a161193a07d366622dfefaa55cb6eb940_cgraph.png" border="0" usemap="#namespaceSawyer_1_1Container_1_1Algorithm_a161193a07d366622dfefaa55cb6eb940_cgraph" alt=""/></div>
<map name="namespaceSawyer_1_1Container_1_1Algorithm_a161193a07d366622dfefaa55cb6eb940_cgraph" id="namespaceSawyer_1_1Container_1_1Algorithm_a161193a07d366622dfefaa55cb6eb940_cgraph">
<area shape="rect" title="Erase parallel edges." alt="" coords="5,149,200,205"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Graph.html#a5126c672c46a466ea78d7a2bd05b366d" title="Erases an edge." alt="" coords="267,5,405,47"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Graph_1_1Edge.html#a12c981de3360f2ead8f331a8b7d34fbb" title="User&#45;defined value." alt="" coords="472,35,611,76"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Graph_1_1Vertex.html#abd7c5527e63eb3cbc37f81139325740e" title="Number of outgoing edges." alt="" coords="248,123,424,164"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Graph_1_1Vertex.html#a3df407366de5c601d55c7ee4e8b32558" title="List of outgoing edges." alt="" coords="253,188,419,229"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Graph_1_1Edge.html#acad205ee0450a9915b7e193b442f33b8" title="Target vertex." alt="" coords="267,253,405,295"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Graph.html#a9aa5860369a9316640518c1eb3894de0" title="Iterators for all vertices." alt="" coords="267,319,405,360"/>
</map>
</div>

</div>
</div>
<a id="a7dccfa1551c6fa2bfbe2aa891e9fc35c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dccfa1551c6fa2bfbe2aa891e9fc35c">&#9670;&nbsp;</a></span>graphDependentOrder()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;size_t&gt; Sawyer::Container::Algorithm::graphDependentOrder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1Container_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number vertices according to their height from the leaves. </p>
<p>This function treats the input graph as a dependency graph where an edge from vertex V1 to V2 means that V1 depends on V2. It then numbers the vertices (after breaking cycles arbitrarily) giving each vertex a distinct number based on its height in the tree. The caller will then typically processes the vertices according to increasing vertex numbers in order to minimize the number of dependencies during the processing. </p>

<p class="definition">Definition at line <a class="el" href="GraphAlgorithm_8h_source.html#l00286">286</a> of file <a class="el" href="GraphAlgorithm_8h_source.html">GraphAlgorithm.h</a>.</p>

<p class="reference">References <a class="el" href="Graph_8h_source.html#l01507">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::findVertex()</a>, <a class="el" href="Graph_8h_source.html#l01208">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::Vertex::id()</a>, <a class="el" href="Graph_8h_source.html#l01676">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::nVertices()</a>, <a class="el" href="Graph_8h_source.html#l01240">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::Vertex::outEdges()</a>, and <a class="el" href="Graph_8h_source.html#l01157">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::Edge::target()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceSawyer_1_1Container_1_1Algorithm_a7dccfa1551c6fa2bfbe2aa891e9fc35c_cgraph.png" border="0" usemap="#namespaceSawyer_1_1Container_1_1Algorithm_a7dccfa1551c6fa2bfbe2aa891e9fc35c_cgraph" alt=""/></div>
<map name="namespaceSawyer_1_1Container_1_1Algorithm_a7dccfa1551c6fa2bfbe2aa891e9fc35c_cgraph" id="namespaceSawyer_1_1Container_1_1Algorithm_a7dccfa1551c6fa2bfbe2aa891e9fc35c_cgraph">
<area shape="rect" title="Number vertices according to their height from the leaves." alt="" coords="5,136,217,177"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Graph.html#a3f256b70a465482d53478b84941dc8b5" title="Finds the vertex with specified ID number." alt="" coords="279,5,418,47"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Graph_1_1Vertex.html#af8439ff325ea20ab17e0418268546fbf" title="Unique vertex ID number." alt="" coords="279,71,418,112"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Graph.html#a4c5244b7dddd1f511a0a9350fc79e182" title="Total number of vertices." alt="" coords="279,136,418,177"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Graph_1_1Vertex.html#a3df407366de5c601d55c7ee4e8b32558" title="List of outgoing edges." alt="" coords="265,201,432,243"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Graph_1_1Edge.html#acad205ee0450a9915b7e193b442f33b8" title="Target vertex." alt="" coords="279,267,418,308"/>
</map>
</div>

</div>
</div>
<a id="a125e6d3b75c1f45be000702427b39a0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a125e6d3b75c1f45be000702427b39a0f">&#9670;&nbsp;</a></span>findCommonIsomorphicSubgraphs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GraphA , class GraphB , class SolutionProcessor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Sawyer::Container::Algorithm::findCommonIsomorphicSubgraphs </td>
          <td>(</td>
          <td class="paramtype">const GraphA &amp;&#160;</td>
          <td class="paramname"><em>g1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GraphB &amp;&#160;</td>
          <td class="paramname"><em>g2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SolutionProcessor&#160;</td>
          <td class="paramname"><em>solutionProcessor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find common isomorphic subgraphs. </p>
<p>Given two graphs find subgraphs of each that are isomorphic to each other.</p>
<p>Each solution causes an invocation of the <code>solutionProcessor</code>, which is a functor that takes four arguments: a const reference to the first graph, a const vector of <code>size_t</code> which is the ID numbers of the first graph's vertices selected to be in the subgraph, and the same two arguments for the second graph. Regardless of the graph sizes, the two vectors are always parallel&ndash;they contain the matching pairs of vertices. The solutions are processed in no particular order.</p>
<p>The <code>equivalenceP</code> is an optional predicate to determine when a pair of vertices, one from each graph, can be isomorphic. The subgraph solutions given by the two parallel vectors passed to the solution processor callback will contain only pairs of vertices for which this predicate returns true.</p>
<p>This function is only a convenient wrapper around the <a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html">CommonSubgraphIsomorphism</a> class.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html">CommonSubgraphIsomorphism</a>, <a class="el" href="namespaceSawyer_1_1Container_1_1Algorithm.html#abdfddcc3c0de62ffb90d868264b20483">findIsomorphicSubgraphs</a>, <a class="el" href="namespaceSawyer_1_1Container_1_1Algorithm.html#af893c884305001ca91a0ef56a6c2f1b6">findMaximumCommonIsomorphicSubgraphs</a>.</dd></dl>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="comment">// Example how to use graph isomorphism</span></div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="preprocessor">#include &lt;Sawyer/Graph.h&gt;</span></div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="preprocessor">#include &lt;Sawyer/GraphAlgorithm.h&gt;</span></div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="preprocessor">#include &lt;boost/foreach.hpp&gt;</span></div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160; </div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<span class="keyword">using namespace </span><a class="code" href="namespaceSawyer_1_1Container_1_1Algorithm.html">Sawyer::Container::Algorithm</a>;</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160; </div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;<span class="comment">// A graph with no user data, only connectivity info.</span></div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;<span class="keyword">typedef</span> <a class="code" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph&lt;&gt;</a> MyGraph;</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160; </div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;<span class="keyword">static</span> <a class="code" href="namespaceSawyer_1_1Container_1_1Algorithm.html#ad6fc5c4b7ff7dd31ed0a2903a37228ae">CsiNextAction</a></div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;printSolution(<span class="keyword">const</span> MyGraph &amp;g1, <span class="keyword">const</span> std::vector&lt;size_t&gt; &amp;g1VertIds,</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;              <span class="keyword">const</span> MyGraph &amp;g2, <span class="keyword">const</span> std::vector&lt;size_t&gt; &amp;g2VertIds) {</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;    std::cout &lt;&lt;<span class="stringliteral">&quot;  solution graph has &quot;</span> &lt;&lt;g1.<a class="code" href="classSawyer_1_1Container_1_1Graph.html#a4c5244b7dddd1f511a0a9350fc79e182">nVertices</a>() &lt;&lt;<span class="stringliteral">&quot; vertices\n&quot;</span>;</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;    std::cout &lt;&lt;<span class="stringliteral">&quot;    vertex pairs:&quot;</span>;</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i&lt;g1VertIds.size(); ++i)</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;        std::cout &lt;&lt;<span class="stringliteral">&quot; (&quot;</span> &lt;&lt;g1VertIds[i] &lt;&lt;<span class="stringliteral">&quot;,&quot;</span> &lt;&lt;g2VertIds[i] &lt;&lt;<span class="stringliteral">&quot;)&quot;</span>;</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;    std::cout &lt;&lt;<span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160; </div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;    <span class="comment">// We can also turn the vertex vector representation into a true graph</span></div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;    <span class="comment">// so we can more easily operate on it.</span></div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;    MyGraph subgraph2 = <a class="code" href="namespaceSawyer_1_1Container_1_1Algorithm.html#aec93e4ec85b0e53249e4a71fbdf60976">graphCopySubgraph</a>(g2, g2VertIds);</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;    std::cout &lt;&lt;<span class="stringliteral">&quot;    subgraph2 has &quot;</span> &lt;&lt;subgraph2.nEdges() &lt;&lt;<span class="stringliteral">&quot; edges&quot;</span></div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;              &lt;&lt;<span class="stringliteral">&quot; and is &quot;</span> &lt;&lt;(<a class="code" href="namespaceSawyer_1_1Container_1_1Algorithm.html#a61fe8c4aaae390361068b47d7be07ce6">graphIsConnected</a>(subgraph2) ? <span class="stringliteral">&quot;&quot;</span> : <span class="stringliteral">&quot;not &quot;</span>) &lt;&lt;<span class="stringliteral">&quot;connected\n&quot;</span>;</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160; </div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespaceSawyer_1_1Container_1_1Algorithm.html#ad6fc5c4b7ff7dd31ed0a2903a37228aea6b096a1316b38af50d73ff9160fd9ac2">CSI_CONTINUE</a>;                                <span class="comment">// find more solutions</span></div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;}</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160; </div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;<span class="keywordtype">int</span> main() {</div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;    <span class="comment">// Ensure diagnostics are initialized</span></div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;    <a class="code" href="namespaceSawyer.html#a960dd0d2f8743b072c88e4232ea2698e">Sawyer::initializeLibrary</a>();</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160; </div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;    <span class="comment">// Create a couple graphs by inserting vertices and connecting them with edges.</span></div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;    <span class="comment">// This is just one of many ways to do this.</span></div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;    MyGraph g1;</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i&lt;5; ++i)</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;        g1.insertVertex();</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;    g1.insertEdge(g1.findVertex(0), g1.findVertex(1));</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;    g1.insertEdge(g1.findVertex(1), g1.findVertex(2));</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;    g1.insertEdge(g1.findVertex(1), g1.findVertex(3));</div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;    g1.insertEdge(g1.findVertex(2), g1.findVertex(3));</div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;    g1.insertEdge(g1.findVertex(3), g1.findVertex(4));</div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160; </div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;    MyGraph g2;</div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i&lt;7; ++i)</div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;        g2.insertVertex();</div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;    g2.insertEdge(g2.findVertex(0), g2.findVertex(1));</div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;    g2.insertEdge(g2.findVertex(1), g2.findVertex(2));</div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;    g2.insertEdge(g2.findVertex(1), g2.findVertex(3));</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;    g2.insertEdge(g2.findVertex(3), g2.findVertex(2));</div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;    g2.insertEdge(g2.findVertex(2), g2.findVertex(4));</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;    g2.insertEdge(g2.findVertex(4), g2.findVertex(5));</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;    g2.insertEdge(g2.findVertex(4), g2.findVertex(6));</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;    g2.insertEdge(g2.findVertex(6), g2.findVertex(5));</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160; </div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;    <span class="comment">// Do some operations</span></div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160; </div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;    std::cout &lt;&lt;<span class="stringliteral">&quot;Subgraphs of g2 that are isomorphic to g1\n&quot;</span>;</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;    <a class="code" href="namespaceSawyer_1_1Container_1_1Algorithm.html#abdfddcc3c0de62ffb90d868264b20483">findIsomorphicSubgraphs</a>(g1, g2, printSolution);</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160; </div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;    std::cout &lt;&lt;<span class="stringliteral">&quot;Subgraphs of both g1 and g2 that are isomorphic to each other\n&quot;</span>;</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;    <a class="code" href="namespaceSawyer_1_1Container_1_1Algorithm.html#a125e6d3b75c1f45be000702427b39a0f">findCommonIsomorphicSubgraphs</a>(g1, g2, printSolution);</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160; </div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;    std::cout &lt;&lt;<span class="stringliteral">&quot;Largest subgraphs of both g1 and g2 that are isomorphic\n&quot;</span>;</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;    <span class="keyword">typedef</span> std::vector&lt;size_t&gt; VertexIds;</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;    <span class="keyword">typedef</span> std::pair&lt;VertexIds, VertexIds&gt; Solution;</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;    <span class="keyword">typedef</span> std::vector&lt;Solution&gt; Solutions;</div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;    Solutions solns = <a class="code" href="namespaceSawyer_1_1Container_1_1Algorithm.html#af893c884305001ca91a0ef56a6c2f1b6">findMaximumCommonIsomorphicSubgraphs</a>(g1, g2);</div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;    BOOST_FOREACH (<span class="keyword">const</span> Solution &amp;soln, solns)</div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;        printSolution(g1, soln.first, g2, soln.second);</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;}</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="GraphAlgorithm_8h_source.html#l00966">966</a> of file <a class="el" href="GraphAlgorithm_8h_source.html">GraphAlgorithm.h</a>.</p>

<p class="reference">References <a class="el" href="GraphAlgorithm_8h_source.html#l00727">Sawyer::Container::Algorithm::CommonSubgraphIsomorphism&lt; GraphA, GraphB, SolutionProcessor, EquivalenceP &gt;::run()</a>, and <a class="el" href="GraphAlgorithm_8h_source.html#l00681">Sawyer::Container::Algorithm::CommonSubgraphIsomorphism&lt; GraphA, GraphB, SolutionProcessor, EquivalenceP &gt;::solutionProcessor()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceSawyer_1_1Container_1_1Algorithm_a125e6d3b75c1f45be000702427b39a0f_cgraph.png" border="0" usemap="#namespaceSawyer_1_1Container_1_1Algorithm_a125e6d3b75c1f45be000702427b39a0f_cgraph" alt=""/></div>
<map name="namespaceSawyer_1_1Container_1_1Algorithm_a125e6d3b75c1f45be000702427b39a0f_cgraph" id="namespaceSawyer_1_1Container_1_1Algorithm_a125e6d3b75c1f45be000702427b39a0f_cgraph">
<area shape="rect" title="Find common isomorphic subgraphs." alt="" coords="5,35,228,91"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html#a795c5207d979a168d4f95814ce62f380" title="Perform the common subgraph isomorphism analysis." alt="" coords="276,5,571,47"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html#abfe2af18d37f66365a12764777912f7a" title="Property: reference to the solution callback." alt="" coords="289,71,557,127"/>
</map>
</div>

</div>
</div>
<a id="ad2540c4e2de32ca00224f9afc56c725f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2540c4e2de32ca00224f9afc56c725f">&#9670;&nbsp;</a></span>findCommonIsomorphicSubgraphs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GraphA , class GraphB , class SolutionProcessor , class EquivalenceP &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Sawyer::Container::Algorithm::findCommonIsomorphicSubgraphs </td>
          <td>(</td>
          <td class="paramtype">const GraphA &amp;&#160;</td>
          <td class="paramname"><em>g1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GraphB &amp;&#160;</td>
          <td class="paramname"><em>g2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SolutionProcessor&#160;</td>
          <td class="paramname"><em>solutionProcessor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EquivalenceP&#160;</td>
          <td class="paramname"><em>equivalenceP</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find common isomorphic subgraphs. </p>
<p>Given two graphs find subgraphs of each that are isomorphic to each other.</p>
<p>Each solution causes an invocation of the <code>solutionProcessor</code>, which is a functor that takes four arguments: a const reference to the first graph, a const vector of <code>size_t</code> which is the ID numbers of the first graph's vertices selected to be in the subgraph, and the same two arguments for the second graph. Regardless of the graph sizes, the two vectors are always parallel&ndash;they contain the matching pairs of vertices. The solutions are processed in no particular order.</p>
<p>The <code>equivalenceP</code> is an optional predicate to determine when a pair of vertices, one from each graph, can be isomorphic. The subgraph solutions given by the two parallel vectors passed to the solution processor callback will contain only pairs of vertices for which this predicate returns true.</p>
<p>This function is only a convenient wrapper around the <a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html">CommonSubgraphIsomorphism</a> class.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html">CommonSubgraphIsomorphism</a>, <a class="el" href="namespaceSawyer_1_1Container_1_1Algorithm.html#abdfddcc3c0de62ffb90d868264b20483">findIsomorphicSubgraphs</a>, <a class="el" href="namespaceSawyer_1_1Container_1_1Algorithm.html#af893c884305001ca91a0ef56a6c2f1b6">findMaximumCommonIsomorphicSubgraphs</a>.</dd></dl>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="comment">// Example how to use graph isomorphism</span></div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="preprocessor">#include &lt;Sawyer/Graph.h&gt;</span></div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="preprocessor">#include &lt;Sawyer/GraphAlgorithm.h&gt;</span></div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="preprocessor">#include &lt;boost/foreach.hpp&gt;</span></div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160; </div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<span class="keyword">using namespace </span><a class="code" href="namespaceSawyer_1_1Container_1_1Algorithm.html">Sawyer::Container::Algorithm</a>;</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160; </div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;<span class="comment">// A graph with no user data, only connectivity info.</span></div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;<span class="keyword">typedef</span> <a class="code" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph&lt;&gt;</a> MyGraph;</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160; </div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;<span class="keyword">static</span> <a class="code" href="namespaceSawyer_1_1Container_1_1Algorithm.html#ad6fc5c4b7ff7dd31ed0a2903a37228ae">CsiNextAction</a></div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;printSolution(<span class="keyword">const</span> MyGraph &amp;g1, <span class="keyword">const</span> std::vector&lt;size_t&gt; &amp;g1VertIds,</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;              <span class="keyword">const</span> MyGraph &amp;g2, <span class="keyword">const</span> std::vector&lt;size_t&gt; &amp;g2VertIds) {</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;    std::cout &lt;&lt;<span class="stringliteral">&quot;  solution graph has &quot;</span> &lt;&lt;g1.<a class="code" href="classSawyer_1_1Container_1_1Graph.html#a4c5244b7dddd1f511a0a9350fc79e182">nVertices</a>() &lt;&lt;<span class="stringliteral">&quot; vertices\n&quot;</span>;</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;    std::cout &lt;&lt;<span class="stringliteral">&quot;    vertex pairs:&quot;</span>;</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i&lt;g1VertIds.size(); ++i)</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;        std::cout &lt;&lt;<span class="stringliteral">&quot; (&quot;</span> &lt;&lt;g1VertIds[i] &lt;&lt;<span class="stringliteral">&quot;,&quot;</span> &lt;&lt;g2VertIds[i] &lt;&lt;<span class="stringliteral">&quot;)&quot;</span>;</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;    std::cout &lt;&lt;<span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160; </div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;    <span class="comment">// We can also turn the vertex vector representation into a true graph</span></div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;    <span class="comment">// so we can more easily operate on it.</span></div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;    MyGraph subgraph2 = <a class="code" href="namespaceSawyer_1_1Container_1_1Algorithm.html#aec93e4ec85b0e53249e4a71fbdf60976">graphCopySubgraph</a>(g2, g2VertIds);</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;    std::cout &lt;&lt;<span class="stringliteral">&quot;    subgraph2 has &quot;</span> &lt;&lt;subgraph2.nEdges() &lt;&lt;<span class="stringliteral">&quot; edges&quot;</span></div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;              &lt;&lt;<span class="stringliteral">&quot; and is &quot;</span> &lt;&lt;(<a class="code" href="namespaceSawyer_1_1Container_1_1Algorithm.html#a61fe8c4aaae390361068b47d7be07ce6">graphIsConnected</a>(subgraph2) ? <span class="stringliteral">&quot;&quot;</span> : <span class="stringliteral">&quot;not &quot;</span>) &lt;&lt;<span class="stringliteral">&quot;connected\n&quot;</span>;</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160; </div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespaceSawyer_1_1Container_1_1Algorithm.html#ad6fc5c4b7ff7dd31ed0a2903a37228aea6b096a1316b38af50d73ff9160fd9ac2">CSI_CONTINUE</a>;                                <span class="comment">// find more solutions</span></div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;}</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160; </div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;<span class="keywordtype">int</span> main() {</div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;    <span class="comment">// Ensure diagnostics are initialized</span></div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;    <a class="code" href="namespaceSawyer.html#a960dd0d2f8743b072c88e4232ea2698e">Sawyer::initializeLibrary</a>();</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160; </div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;    <span class="comment">// Create a couple graphs by inserting vertices and connecting them with edges.</span></div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;    <span class="comment">// This is just one of many ways to do this.</span></div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;    MyGraph g1;</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i&lt;5; ++i)</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;        g1.insertVertex();</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;    g1.insertEdge(g1.findVertex(0), g1.findVertex(1));</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;    g1.insertEdge(g1.findVertex(1), g1.findVertex(2));</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;    g1.insertEdge(g1.findVertex(1), g1.findVertex(3));</div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;    g1.insertEdge(g1.findVertex(2), g1.findVertex(3));</div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;    g1.insertEdge(g1.findVertex(3), g1.findVertex(4));</div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160; </div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;    MyGraph g2;</div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i&lt;7; ++i)</div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;        g2.insertVertex();</div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;    g2.insertEdge(g2.findVertex(0), g2.findVertex(1));</div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;    g2.insertEdge(g2.findVertex(1), g2.findVertex(2));</div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;    g2.insertEdge(g2.findVertex(1), g2.findVertex(3));</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;    g2.insertEdge(g2.findVertex(3), g2.findVertex(2));</div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;    g2.insertEdge(g2.findVertex(2), g2.findVertex(4));</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;    g2.insertEdge(g2.findVertex(4), g2.findVertex(5));</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;    g2.insertEdge(g2.findVertex(4), g2.findVertex(6));</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;    g2.insertEdge(g2.findVertex(6), g2.findVertex(5));</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160; </div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;    <span class="comment">// Do some operations</span></div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160; </div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;    std::cout &lt;&lt;<span class="stringliteral">&quot;Subgraphs of g2 that are isomorphic to g1\n&quot;</span>;</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;    <a class="code" href="namespaceSawyer_1_1Container_1_1Algorithm.html#abdfddcc3c0de62ffb90d868264b20483">findIsomorphicSubgraphs</a>(g1, g2, printSolution);</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160; </div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;    std::cout &lt;&lt;<span class="stringliteral">&quot;Subgraphs of both g1 and g2 that are isomorphic to each other\n&quot;</span>;</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;    <a class="code" href="namespaceSawyer_1_1Container_1_1Algorithm.html#a125e6d3b75c1f45be000702427b39a0f">findCommonIsomorphicSubgraphs</a>(g1, g2, printSolution);</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160; </div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;    std::cout &lt;&lt;<span class="stringliteral">&quot;Largest subgraphs of both g1 and g2 that are isomorphic\n&quot;</span>;</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;    <span class="keyword">typedef</span> std::vector&lt;size_t&gt; VertexIds;</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;    <span class="keyword">typedef</span> std::pair&lt;VertexIds, VertexIds&gt; Solution;</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;    <span class="keyword">typedef</span> std::vector&lt;Solution&gt; Solutions;</div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;    Solutions solns = <a class="code" href="namespaceSawyer_1_1Container_1_1Algorithm.html#af893c884305001ca91a0ef56a6c2f1b6">findMaximumCommonIsomorphicSubgraphs</a>(g1, g2);</div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;    BOOST_FOREACH (<span class="keyword">const</span> Solution &amp;soln, solns)</div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;        printSolution(g1, soln.first, g2, soln.second);</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;}</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="GraphAlgorithm_8h_source.html#l00972">972</a> of file <a class="el" href="GraphAlgorithm_8h_source.html">GraphAlgorithm.h</a>.</p>

<p class="reference">References <a class="el" href="GraphAlgorithm_8h_source.html#l00727">Sawyer::Container::Algorithm::CommonSubgraphIsomorphism&lt; GraphA, GraphB, SolutionProcessor, EquivalenceP &gt;::run()</a>, and <a class="el" href="GraphAlgorithm_8h_source.html#l00681">Sawyer::Container::Algorithm::CommonSubgraphIsomorphism&lt; GraphA, GraphB, SolutionProcessor, EquivalenceP &gt;::solutionProcessor()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceSawyer_1_1Container_1_1Algorithm_ad2540c4e2de32ca00224f9afc56c725f_cgraph.png" border="0" usemap="#namespaceSawyer_1_1Container_1_1Algorithm_ad2540c4e2de32ca00224f9afc56c725f_cgraph" alt=""/></div>
<map name="namespaceSawyer_1_1Container_1_1Algorithm_ad2540c4e2de32ca00224f9afc56c725f_cgraph" id="namespaceSawyer_1_1Container_1_1Algorithm_ad2540c4e2de32ca00224f9afc56c725f_cgraph">
<area shape="rect" title="Find common isomorphic subgraphs." alt="" coords="5,35,228,91"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html#a795c5207d979a168d4f95814ce62f380" title="Perform the common subgraph isomorphism analysis." alt="" coords="276,5,571,47"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html#abfe2af18d37f66365a12764777912f7a" title="Property: reference to the solution callback." alt="" coords="289,71,557,127"/>
</map>
</div>

</div>
</div>
<a id="a79f3b4db6da4e57a5a1d5ff7ff39b3f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79f3b4db6da4e57a5a1d5ff7ff39b3f7">&#9670;&nbsp;</a></span>findFirstCommonIsomorphicSubgraph() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GraphA , class GraphB &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;std::vector&lt;size_t&gt;, std::vector&lt;size_t&gt; &gt; Sawyer::Container::Algorithm::findFirstCommonIsomorphicSubgraph </td>
          <td>(</td>
          <td class="paramtype">const GraphA &amp;&#160;</td>
          <td class="paramname"><em>g1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GraphB &amp;&#160;</td>
          <td class="paramname"><em>g2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>minimumSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine whether a common subgraph exists. </p>
<p>Given two graphs, try to find any common isomorphic subgraph which is at least the specified size and return as soon as one is found. The return value is a pair of parallel vectors of vertex id numbers that relate the two subgraphs. The return value is empty if no common isomorphic subgraph could be found. </p>

<p class="definition">Definition at line <a class="el" href="GraphAlgorithm_8h_source.html#l01004">1004</a> of file <a class="el" href="GraphAlgorithm_8h_source.html">GraphAlgorithm.h</a>.</p>

<p class="reference">References <a class="el" href="GraphAlgorithm_8h_source.html#l00659">Sawyer::Container::Algorithm::CommonSubgraphIsomorphism&lt; GraphA, GraphB, SolutionProcessor, EquivalenceP &gt;::maximumSolutionSize()</a>, <a class="el" href="GraphAlgorithm_8h_source.html#l00641">Sawyer::Container::Algorithm::CommonSubgraphIsomorphism&lt; GraphA, GraphB, SolutionProcessor, EquivalenceP &gt;::minimumSolutionSize()</a>, <a class="el" href="GraphAlgorithm_8h_source.html#l00727">Sawyer::Container::Algorithm::CommonSubgraphIsomorphism&lt; GraphA, GraphB, SolutionProcessor, EquivalenceP &gt;::run()</a>, and <a class="el" href="GraphAlgorithm_8h_source.html#l00681">Sawyer::Container::Algorithm::CommonSubgraphIsomorphism&lt; GraphA, GraphB, SolutionProcessor, EquivalenceP &gt;::solutionProcessor()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceSawyer_1_1Container_1_1Algorithm_a79f3b4db6da4e57a5a1d5ff7ff39b3f7_cgraph.png" border="0" usemap="#namespaceSawyer_1_1Container_1_1Algorithm_a79f3b4db6da4e57a5a1d5ff7ff39b3f7_cgraph" alt=""/></div>
<map name="namespaceSawyer_1_1Container_1_1Algorithm_a79f3b4db6da4e57a5a1d5ff7ff39b3f7_cgraph" id="namespaceSawyer_1_1Container_1_1Algorithm_a79f3b4db6da4e57a5a1d5ff7ff39b3f7_cgraph">
<area shape="rect" title="Determine whether a common subgraph exists." alt="" coords="5,123,191,179"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html#ab2fcf9fbbfd7a370c3fce69df4583226" title="Property: maximum allowed solution size." alt="" coords="252,5,520,61"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html#aaecdf4256eb655f03557ba236dcb9b40" title="Property: minimum allowed solution size." alt="" coords="252,85,520,141"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html#a795c5207d979a168d4f95814ce62f380" title="Perform the common subgraph isomorphism analysis." alt="" coords="239,166,533,207"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html#abfe2af18d37f66365a12764777912f7a" title="Property: reference to the solution callback." alt="" coords="252,232,520,288"/>
</map>
</div>

</div>
</div>
<a id="ae726a9becd10e60ee1369d2f4e72145a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae726a9becd10e60ee1369d2f4e72145a">&#9670;&nbsp;</a></span>findFirstCommonIsomorphicSubgraph() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GraphA , class GraphB , class EquivalenceP &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;std::vector&lt;size_t&gt;, std::vector&lt;size_t&gt; &gt; Sawyer::Container::Algorithm::findFirstCommonIsomorphicSubgraph </td>
          <td>(</td>
          <td class="paramtype">const GraphA &amp;&#160;</td>
          <td class="paramname"><em>g1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GraphB &amp;&#160;</td>
          <td class="paramname"><em>g2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>minimumSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EquivalenceP&#160;</td>
          <td class="paramname"><em>equivalenceP</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine whether a common subgraph exists. </p>
<p>Given two graphs, try to find any common isomorphic subgraph which is at least the specified size and return as soon as one is found. The return value is a pair of parallel vectors of vertex id numbers that relate the two subgraphs. The return value is empty if no common isomorphic subgraph could be found. </p>

<p class="definition">Definition at line <a class="el" href="GraphAlgorithm_8h_source.html#l01015">1015</a> of file <a class="el" href="GraphAlgorithm_8h_source.html">GraphAlgorithm.h</a>.</p>

<p class="reference">References <a class="el" href="GraphAlgorithm_8h_source.html#l00659">Sawyer::Container::Algorithm::CommonSubgraphIsomorphism&lt; GraphA, GraphB, SolutionProcessor, EquivalenceP &gt;::maximumSolutionSize()</a>, <a class="el" href="GraphAlgorithm_8h_source.html#l00641">Sawyer::Container::Algorithm::CommonSubgraphIsomorphism&lt; GraphA, GraphB, SolutionProcessor, EquivalenceP &gt;::minimumSolutionSize()</a>, <a class="el" href="GraphAlgorithm_8h_source.html#l00727">Sawyer::Container::Algorithm::CommonSubgraphIsomorphism&lt; GraphA, GraphB, SolutionProcessor, EquivalenceP &gt;::run()</a>, and <a class="el" href="GraphAlgorithm_8h_source.html#l00681">Sawyer::Container::Algorithm::CommonSubgraphIsomorphism&lt; GraphA, GraphB, SolutionProcessor, EquivalenceP &gt;::solutionProcessor()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceSawyer_1_1Container_1_1Algorithm_ae726a9becd10e60ee1369d2f4e72145a_cgraph.png" border="0" usemap="#namespaceSawyer_1_1Container_1_1Algorithm_ae726a9becd10e60ee1369d2f4e72145a_cgraph" alt=""/></div>
<map name="namespaceSawyer_1_1Container_1_1Algorithm_ae726a9becd10e60ee1369d2f4e72145a_cgraph" id="namespaceSawyer_1_1Container_1_1Algorithm_ae726a9becd10e60ee1369d2f4e72145a_cgraph">
<area shape="rect" title="Determine whether a common subgraph exists." alt="" coords="5,123,191,179"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html#ab2fcf9fbbfd7a370c3fce69df4583226" title="Property: maximum allowed solution size." alt="" coords="252,5,520,61"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html#aaecdf4256eb655f03557ba236dcb9b40" title="Property: minimum allowed solution size." alt="" coords="252,85,520,141"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html#a795c5207d979a168d4f95814ce62f380" title="Perform the common subgraph isomorphism analysis." alt="" coords="239,166,533,207"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html#abfe2af18d37f66365a12764777912f7a" title="Property: reference to the solution callback." alt="" coords="252,232,520,288"/>
</map>
</div>

</div>
</div>
<a id="abdfddcc3c0de62ffb90d868264b20483"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdfddcc3c0de62ffb90d868264b20483">&#9670;&nbsp;</a></span>findIsomorphicSubgraphs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GraphA , class GraphB , class SolutionProcessor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Sawyer::Container::Algorithm::findIsomorphicSubgraphs </td>
          <td>(</td>
          <td class="paramtype">const GraphA &amp;&#160;</td>
          <td class="paramname"><em>g1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GraphB &amp;&#160;</td>
          <td class="paramname"><em>g2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SolutionProcessor&#160;</td>
          <td class="paramname"><em>solutionProcessor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find an isomorphic subgraph. </p>
<p>Given a smaller graph, <code>g1</code>, and a larger graph, <code>g2</code>, find all subgraphs of the larger graph that are isomorphic to the smaller graph. If the <code>g1</code> is larger than <code>g2</code> then no solutions will be found since no subgraph of <code>g2</code> can have enough vertices to be isomorphic to <code>g1</code>.</p>
<p>This function's behavior is identical to <a class="el" href="namespaceSawyer_1_1Container_1_1Algorithm.html#a125e6d3b75c1f45be000702427b39a0f">findCommonIsomorphicSubgraphs</a> except in one regard: the size of the vertex ID vectors passed to the solution processor will always be the same size as the number of vertices in <code>g1</code>.</p>
<p>This function is only a convenient wrapper around the <a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html">CommonSubgraphIsomorphism</a> class.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html">CommonSubgraphIsomorphism</a>, <a class="el" href="namespaceSawyer_1_1Container_1_1Algorithm.html#a125e6d3b75c1f45be000702427b39a0f">findCommonIsomorphicSubgraphs</a>, <a class="el" href="namespaceSawyer_1_1Container_1_1Algorithm.html#af893c884305001ca91a0ef56a6c2f1b6">findMaximumCommonIsomorphicSubgraphs</a>.</dd></dl>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="comment">// Example how to use graph isomorphism</span></div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="preprocessor">#include &lt;Sawyer/Graph.h&gt;</span></div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="preprocessor">#include &lt;Sawyer/GraphAlgorithm.h&gt;</span></div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="preprocessor">#include &lt;boost/foreach.hpp&gt;</span></div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160; </div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<span class="keyword">using namespace </span><a class="code" href="namespaceSawyer_1_1Container_1_1Algorithm.html">Sawyer::Container::Algorithm</a>;</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160; </div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;<span class="comment">// A graph with no user data, only connectivity info.</span></div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;<span class="keyword">typedef</span> <a class="code" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph&lt;&gt;</a> MyGraph;</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160; </div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;<span class="keyword">static</span> <a class="code" href="namespaceSawyer_1_1Container_1_1Algorithm.html#ad6fc5c4b7ff7dd31ed0a2903a37228ae">CsiNextAction</a></div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;printSolution(<span class="keyword">const</span> MyGraph &amp;g1, <span class="keyword">const</span> std::vector&lt;size_t&gt; &amp;g1VertIds,</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;              <span class="keyword">const</span> MyGraph &amp;g2, <span class="keyword">const</span> std::vector&lt;size_t&gt; &amp;g2VertIds) {</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;    std::cout &lt;&lt;<span class="stringliteral">&quot;  solution graph has &quot;</span> &lt;&lt;g1.<a class="code" href="classSawyer_1_1Container_1_1Graph.html#a4c5244b7dddd1f511a0a9350fc79e182">nVertices</a>() &lt;&lt;<span class="stringliteral">&quot; vertices\n&quot;</span>;</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;    std::cout &lt;&lt;<span class="stringliteral">&quot;    vertex pairs:&quot;</span>;</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i&lt;g1VertIds.size(); ++i)</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;        std::cout &lt;&lt;<span class="stringliteral">&quot; (&quot;</span> &lt;&lt;g1VertIds[i] &lt;&lt;<span class="stringliteral">&quot;,&quot;</span> &lt;&lt;g2VertIds[i] &lt;&lt;<span class="stringliteral">&quot;)&quot;</span>;</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;    std::cout &lt;&lt;<span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160; </div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;    <span class="comment">// We can also turn the vertex vector representation into a true graph</span></div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;    <span class="comment">// so we can more easily operate on it.</span></div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;    MyGraph subgraph2 = <a class="code" href="namespaceSawyer_1_1Container_1_1Algorithm.html#aec93e4ec85b0e53249e4a71fbdf60976">graphCopySubgraph</a>(g2, g2VertIds);</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;    std::cout &lt;&lt;<span class="stringliteral">&quot;    subgraph2 has &quot;</span> &lt;&lt;subgraph2.nEdges() &lt;&lt;<span class="stringliteral">&quot; edges&quot;</span></div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;              &lt;&lt;<span class="stringliteral">&quot; and is &quot;</span> &lt;&lt;(<a class="code" href="namespaceSawyer_1_1Container_1_1Algorithm.html#a61fe8c4aaae390361068b47d7be07ce6">graphIsConnected</a>(subgraph2) ? <span class="stringliteral">&quot;&quot;</span> : <span class="stringliteral">&quot;not &quot;</span>) &lt;&lt;<span class="stringliteral">&quot;connected\n&quot;</span>;</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160; </div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespaceSawyer_1_1Container_1_1Algorithm.html#ad6fc5c4b7ff7dd31ed0a2903a37228aea6b096a1316b38af50d73ff9160fd9ac2">CSI_CONTINUE</a>;                                <span class="comment">// find more solutions</span></div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;}</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160; </div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;<span class="keywordtype">int</span> main() {</div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;    <span class="comment">// Ensure diagnostics are initialized</span></div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;    <a class="code" href="namespaceSawyer.html#a960dd0d2f8743b072c88e4232ea2698e">Sawyer::initializeLibrary</a>();</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160; </div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;    <span class="comment">// Create a couple graphs by inserting vertices and connecting them with edges.</span></div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;    <span class="comment">// This is just one of many ways to do this.</span></div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;    MyGraph g1;</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i&lt;5; ++i)</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;        g1.insertVertex();</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;    g1.insertEdge(g1.findVertex(0), g1.findVertex(1));</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;    g1.insertEdge(g1.findVertex(1), g1.findVertex(2));</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;    g1.insertEdge(g1.findVertex(1), g1.findVertex(3));</div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;    g1.insertEdge(g1.findVertex(2), g1.findVertex(3));</div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;    g1.insertEdge(g1.findVertex(3), g1.findVertex(4));</div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160; </div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;    MyGraph g2;</div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i&lt;7; ++i)</div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;        g2.insertVertex();</div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;    g2.insertEdge(g2.findVertex(0), g2.findVertex(1));</div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;    g2.insertEdge(g2.findVertex(1), g2.findVertex(2));</div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;    g2.insertEdge(g2.findVertex(1), g2.findVertex(3));</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;    g2.insertEdge(g2.findVertex(3), g2.findVertex(2));</div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;    g2.insertEdge(g2.findVertex(2), g2.findVertex(4));</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;    g2.insertEdge(g2.findVertex(4), g2.findVertex(5));</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;    g2.insertEdge(g2.findVertex(4), g2.findVertex(6));</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;    g2.insertEdge(g2.findVertex(6), g2.findVertex(5));</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160; </div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;    <span class="comment">// Do some operations</span></div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160; </div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;    std::cout &lt;&lt;<span class="stringliteral">&quot;Subgraphs of g2 that are isomorphic to g1\n&quot;</span>;</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;    <a class="code" href="namespaceSawyer_1_1Container_1_1Algorithm.html#abdfddcc3c0de62ffb90d868264b20483">findIsomorphicSubgraphs</a>(g1, g2, printSolution);</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160; </div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;    std::cout &lt;&lt;<span class="stringliteral">&quot;Subgraphs of both g1 and g2 that are isomorphic to each other\n&quot;</span>;</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;    <a class="code" href="namespaceSawyer_1_1Container_1_1Algorithm.html#a125e6d3b75c1f45be000702427b39a0f">findCommonIsomorphicSubgraphs</a>(g1, g2, printSolution);</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160; </div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;    std::cout &lt;&lt;<span class="stringliteral">&quot;Largest subgraphs of both g1 and g2 that are isomorphic\n&quot;</span>;</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;    <span class="keyword">typedef</span> std::vector&lt;size_t&gt; VertexIds;</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;    <span class="keyword">typedef</span> std::pair&lt;VertexIds, VertexIds&gt; Solution;</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;    <span class="keyword">typedef</span> std::vector&lt;Solution&gt; Solutions;</div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;    Solutions solns = <a class="code" href="namespaceSawyer_1_1Container_1_1Algorithm.html#af893c884305001ca91a0ef56a6c2f1b6">findMaximumCommonIsomorphicSubgraphs</a>(g1, g2);</div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;    BOOST_FOREACH (<span class="keyword">const</span> Solution &amp;soln, solns)</div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;        printSolution(g1, soln.first, g2, soln.second);</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;}</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="GraphAlgorithm_8h_source.html#l01043">1043</a> of file <a class="el" href="GraphAlgorithm_8h_source.html">GraphAlgorithm.h</a>.</p>

<p class="reference">References <a class="el" href="GraphAlgorithm_8h_source.html#l00708">Sawyer::Container::Algorithm::CommonSubgraphIsomorphism&lt; GraphA, GraphB, SolutionProcessor, EquivalenceP &gt;::findingCommonSubgraphs()</a>, <a class="el" href="GraphAlgorithm_8h_source.html#l00727">Sawyer::Container::Algorithm::CommonSubgraphIsomorphism&lt; GraphA, GraphB, SolutionProcessor, EquivalenceP &gt;::run()</a>, and <a class="el" href="GraphAlgorithm_8h_source.html#l00681">Sawyer::Container::Algorithm::CommonSubgraphIsomorphism&lt; GraphA, GraphB, SolutionProcessor, EquivalenceP &gt;::solutionProcessor()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceSawyer_1_1Container_1_1Algorithm_abdfddcc3c0de62ffb90d868264b20483_cgraph.png" border="0" usemap="#namespaceSawyer_1_1Container_1_1Algorithm_abdfddcc3c0de62ffb90d868264b20483_cgraph" alt=""/></div>
<map name="namespaceSawyer_1_1Container_1_1Algorithm_abdfddcc3c0de62ffb90d868264b20483_cgraph" id="namespaceSawyer_1_1Container_1_1Algorithm_abdfddcc3c0de62ffb90d868264b20483_cgraph">
<area shape="rect" title="Find an isomorphic subgraph." alt="" coords="5,86,237,127"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html#a7670d6ffa227c87a23b17aa30ca0c495" title="Property: find common subgraphs." alt="" coords="299,5,567,61"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html#a795c5207d979a168d4f95814ce62f380" title="Perform the common subgraph isomorphism analysis." alt="" coords="285,86,580,127"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html#abfe2af18d37f66365a12764777912f7a" title="Property: reference to the solution callback." alt="" coords="299,152,567,208"/>
</map>
</div>

</div>
</div>
<a id="a3bc5fa26c7f42bb7e6d86dff23bb7c7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bc5fa26c7f42bb7e6d86dff23bb7c7f">&#9670;&nbsp;</a></span>findIsomorphicSubgraphs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GraphA , class GraphB , class SolutionProcessor , class EquivalenceP &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Sawyer::Container::Algorithm::findIsomorphicSubgraphs </td>
          <td>(</td>
          <td class="paramtype">const GraphA &amp;&#160;</td>
          <td class="paramname"><em>g1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GraphB &amp;&#160;</td>
          <td class="paramname"><em>g2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SolutionProcessor&#160;</td>
          <td class="paramname"><em>solutionProcessor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EquivalenceP&#160;</td>
          <td class="paramname"><em>equivalenceP</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find an isomorphic subgraph. </p>
<p>Given a smaller graph, <code>g1</code>, and a larger graph, <code>g2</code>, find all subgraphs of the larger graph that are isomorphic to the smaller graph. If the <code>g1</code> is larger than <code>g2</code> then no solutions will be found since no subgraph of <code>g2</code> can have enough vertices to be isomorphic to <code>g1</code>.</p>
<p>This function's behavior is identical to <a class="el" href="namespaceSawyer_1_1Container_1_1Algorithm.html#a125e6d3b75c1f45be000702427b39a0f">findCommonIsomorphicSubgraphs</a> except in one regard: the size of the vertex ID vectors passed to the solution processor will always be the same size as the number of vertices in <code>g1</code>.</p>
<p>This function is only a convenient wrapper around the <a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html">CommonSubgraphIsomorphism</a> class.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html">CommonSubgraphIsomorphism</a>, <a class="el" href="namespaceSawyer_1_1Container_1_1Algorithm.html#a125e6d3b75c1f45be000702427b39a0f">findCommonIsomorphicSubgraphs</a>, <a class="el" href="namespaceSawyer_1_1Container_1_1Algorithm.html#af893c884305001ca91a0ef56a6c2f1b6">findMaximumCommonIsomorphicSubgraphs</a>.</dd></dl>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="comment">// Example how to use graph isomorphism</span></div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="preprocessor">#include &lt;Sawyer/Graph.h&gt;</span></div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="preprocessor">#include &lt;Sawyer/GraphAlgorithm.h&gt;</span></div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="preprocessor">#include &lt;boost/foreach.hpp&gt;</span></div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160; </div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<span class="keyword">using namespace </span><a class="code" href="namespaceSawyer_1_1Container_1_1Algorithm.html">Sawyer::Container::Algorithm</a>;</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160; </div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;<span class="comment">// A graph with no user data, only connectivity info.</span></div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;<span class="keyword">typedef</span> <a class="code" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph&lt;&gt;</a> MyGraph;</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160; </div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;<span class="keyword">static</span> <a class="code" href="namespaceSawyer_1_1Container_1_1Algorithm.html#ad6fc5c4b7ff7dd31ed0a2903a37228ae">CsiNextAction</a></div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;printSolution(<span class="keyword">const</span> MyGraph &amp;g1, <span class="keyword">const</span> std::vector&lt;size_t&gt; &amp;g1VertIds,</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;              <span class="keyword">const</span> MyGraph &amp;g2, <span class="keyword">const</span> std::vector&lt;size_t&gt; &amp;g2VertIds) {</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;    std::cout &lt;&lt;<span class="stringliteral">&quot;  solution graph has &quot;</span> &lt;&lt;g1.<a class="code" href="classSawyer_1_1Container_1_1Graph.html#a4c5244b7dddd1f511a0a9350fc79e182">nVertices</a>() &lt;&lt;<span class="stringliteral">&quot; vertices\n&quot;</span>;</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;    std::cout &lt;&lt;<span class="stringliteral">&quot;    vertex pairs:&quot;</span>;</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i&lt;g1VertIds.size(); ++i)</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;        std::cout &lt;&lt;<span class="stringliteral">&quot; (&quot;</span> &lt;&lt;g1VertIds[i] &lt;&lt;<span class="stringliteral">&quot;,&quot;</span> &lt;&lt;g2VertIds[i] &lt;&lt;<span class="stringliteral">&quot;)&quot;</span>;</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;    std::cout &lt;&lt;<span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160; </div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;    <span class="comment">// We can also turn the vertex vector representation into a true graph</span></div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;    <span class="comment">// so we can more easily operate on it.</span></div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;    MyGraph subgraph2 = <a class="code" href="namespaceSawyer_1_1Container_1_1Algorithm.html#aec93e4ec85b0e53249e4a71fbdf60976">graphCopySubgraph</a>(g2, g2VertIds);</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;    std::cout &lt;&lt;<span class="stringliteral">&quot;    subgraph2 has &quot;</span> &lt;&lt;subgraph2.nEdges() &lt;&lt;<span class="stringliteral">&quot; edges&quot;</span></div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;              &lt;&lt;<span class="stringliteral">&quot; and is &quot;</span> &lt;&lt;(<a class="code" href="namespaceSawyer_1_1Container_1_1Algorithm.html#a61fe8c4aaae390361068b47d7be07ce6">graphIsConnected</a>(subgraph2) ? <span class="stringliteral">&quot;&quot;</span> : <span class="stringliteral">&quot;not &quot;</span>) &lt;&lt;<span class="stringliteral">&quot;connected\n&quot;</span>;</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160; </div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespaceSawyer_1_1Container_1_1Algorithm.html#ad6fc5c4b7ff7dd31ed0a2903a37228aea6b096a1316b38af50d73ff9160fd9ac2">CSI_CONTINUE</a>;                                <span class="comment">// find more solutions</span></div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;}</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160; </div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;<span class="keywordtype">int</span> main() {</div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;    <span class="comment">// Ensure diagnostics are initialized</span></div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;    <a class="code" href="namespaceSawyer.html#a960dd0d2f8743b072c88e4232ea2698e">Sawyer::initializeLibrary</a>();</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160; </div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;    <span class="comment">// Create a couple graphs by inserting vertices and connecting them with edges.</span></div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;    <span class="comment">// This is just one of many ways to do this.</span></div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;    MyGraph g1;</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i&lt;5; ++i)</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;        g1.insertVertex();</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;    g1.insertEdge(g1.findVertex(0), g1.findVertex(1));</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;    g1.insertEdge(g1.findVertex(1), g1.findVertex(2));</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;    g1.insertEdge(g1.findVertex(1), g1.findVertex(3));</div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;    g1.insertEdge(g1.findVertex(2), g1.findVertex(3));</div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;    g1.insertEdge(g1.findVertex(3), g1.findVertex(4));</div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160; </div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;    MyGraph g2;</div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i&lt;7; ++i)</div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;        g2.insertVertex();</div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;    g2.insertEdge(g2.findVertex(0), g2.findVertex(1));</div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;    g2.insertEdge(g2.findVertex(1), g2.findVertex(2));</div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;    g2.insertEdge(g2.findVertex(1), g2.findVertex(3));</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;    g2.insertEdge(g2.findVertex(3), g2.findVertex(2));</div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;    g2.insertEdge(g2.findVertex(2), g2.findVertex(4));</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;    g2.insertEdge(g2.findVertex(4), g2.findVertex(5));</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;    g2.insertEdge(g2.findVertex(4), g2.findVertex(6));</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;    g2.insertEdge(g2.findVertex(6), g2.findVertex(5));</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160; </div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;    <span class="comment">// Do some operations</span></div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160; </div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;    std::cout &lt;&lt;<span class="stringliteral">&quot;Subgraphs of g2 that are isomorphic to g1\n&quot;</span>;</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;    <a class="code" href="namespaceSawyer_1_1Container_1_1Algorithm.html#abdfddcc3c0de62ffb90d868264b20483">findIsomorphicSubgraphs</a>(g1, g2, printSolution);</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160; </div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;    std::cout &lt;&lt;<span class="stringliteral">&quot;Subgraphs of both g1 and g2 that are isomorphic to each other\n&quot;</span>;</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;    <a class="code" href="namespaceSawyer_1_1Container_1_1Algorithm.html#a125e6d3b75c1f45be000702427b39a0f">findCommonIsomorphicSubgraphs</a>(g1, g2, printSolution);</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160; </div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;    std::cout &lt;&lt;<span class="stringliteral">&quot;Largest subgraphs of both g1 and g2 that are isomorphic\n&quot;</span>;</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;    <span class="keyword">typedef</span> std::vector&lt;size_t&gt; VertexIds;</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;    <span class="keyword">typedef</span> std::pair&lt;VertexIds, VertexIds&gt; Solution;</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;    <span class="keyword">typedef</span> std::vector&lt;Solution&gt; Solutions;</div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;    Solutions solns = <a class="code" href="namespaceSawyer_1_1Container_1_1Algorithm.html#af893c884305001ca91a0ef56a6c2f1b6">findMaximumCommonIsomorphicSubgraphs</a>(g1, g2);</div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;    BOOST_FOREACH (<span class="keyword">const</span> Solution &amp;soln, solns)</div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;        printSolution(g1, soln.first, g2, soln.second);</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;}</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="GraphAlgorithm_8h_source.html#l01050">1050</a> of file <a class="el" href="GraphAlgorithm_8h_source.html">GraphAlgorithm.h</a>.</p>

<p class="reference">References <a class="el" href="GraphAlgorithm_8h_source.html#l00708">Sawyer::Container::Algorithm::CommonSubgraphIsomorphism&lt; GraphA, GraphB, SolutionProcessor, EquivalenceP &gt;::findingCommonSubgraphs()</a>, <a class="el" href="GraphAlgorithm_8h_source.html#l00727">Sawyer::Container::Algorithm::CommonSubgraphIsomorphism&lt; GraphA, GraphB, SolutionProcessor, EquivalenceP &gt;::run()</a>, and <a class="el" href="GraphAlgorithm_8h_source.html#l00681">Sawyer::Container::Algorithm::CommonSubgraphIsomorphism&lt; GraphA, GraphB, SolutionProcessor, EquivalenceP &gt;::solutionProcessor()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceSawyer_1_1Container_1_1Algorithm_a3bc5fa26c7f42bb7e6d86dff23bb7c7f_cgraph.png" border="0" usemap="#namespaceSawyer_1_1Container_1_1Algorithm_a3bc5fa26c7f42bb7e6d86dff23bb7c7f_cgraph" alt=""/></div>
<map name="namespaceSawyer_1_1Container_1_1Algorithm_a3bc5fa26c7f42bb7e6d86dff23bb7c7f_cgraph" id="namespaceSawyer_1_1Container_1_1Algorithm_a3bc5fa26c7f42bb7e6d86dff23bb7c7f_cgraph">
<area shape="rect" title="Find an isomorphic subgraph." alt="" coords="5,86,237,127"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html#a7670d6ffa227c87a23b17aa30ca0c495" title="Property: find common subgraphs." alt="" coords="299,5,567,61"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html#a795c5207d979a168d4f95814ce62f380" title="Perform the common subgraph isomorphism analysis." alt="" coords="285,86,580,127"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html#abfe2af18d37f66365a12764777912f7a" title="Property: reference to the solution callback." alt="" coords="299,152,567,208"/>
</map>
</div>

</div>
</div>
<a id="af893c884305001ca91a0ef56a6c2f1b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af893c884305001ca91a0ef56a6c2f1b6">&#9670;&nbsp;</a></span>findMaximumCommonIsomorphicSubgraphs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GraphA , class GraphB &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::pair&lt;std::vector&lt;size_t&gt;, std::vector&lt;size_t&gt; &gt; &gt; Sawyer::Container::Algorithm::findMaximumCommonIsomorphicSubgraphs </td>
          <td>(</td>
          <td class="paramtype">const GraphA &amp;&#160;</td>
          <td class="paramname"><em>g1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GraphB &amp;&#160;</td>
          <td class="paramname"><em>g2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find maximum common isomorphic subgraphs. </p>
<p>Given two graphs, find the largest possible isomorphic subgraph of those two graphs. The return value is a vector of pairs of vectors with each pair of vectors representing one solution. For any pair of vectors, the first vector contains the IDs of vertices selected to be in a subgraph of the first graph, and the second vector contains the ID numbers of vertices selected to be in a subgraph of the second graph. These two vectors are parallel and represent isomorphic pairs of vertices. The length of the vector-of-pairs is the number of solutions found; the lengths of all other vectors are equal to each other and represent the size of the (maximum) subgraph.</p>
<p>The <code>equivalenceP</code> is an optional predicate to determine when a pair of vertices, one from each graph, can be isomorphic. The subgraph solutions returned as pairs of parallel vectors will contain only pairs of vertices for which this predicate returns true.</p>
<p>This function is only a convenient wrapper around the <a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html">CommonSubgraphIsomorphism</a> class.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html">CommonSubgraphIsomorphism</a>, <a class="el" href="namespaceSawyer_1_1Container_1_1Algorithm.html#a125e6d3b75c1f45be000702427b39a0f">findCommonIsomorphicSubgraphs</a>, <a class="el" href="namespaceSawyer_1_1Container_1_1Algorithm.html#abdfddcc3c0de62ffb90d868264b20483">findIsomorphicSubgraphs</a>.</dd></dl>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="comment">// Example how to use graph isomorphism</span></div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="preprocessor">#include &lt;Sawyer/Graph.h&gt;</span></div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="preprocessor">#include &lt;Sawyer/GraphAlgorithm.h&gt;</span></div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="preprocessor">#include &lt;boost/foreach.hpp&gt;</span></div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160; </div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<span class="keyword">using namespace </span><a class="code" href="namespaceSawyer_1_1Container_1_1Algorithm.html">Sawyer::Container::Algorithm</a>;</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160; </div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;<span class="comment">// A graph with no user data, only connectivity info.</span></div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;<span class="keyword">typedef</span> <a class="code" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph&lt;&gt;</a> MyGraph;</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160; </div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;<span class="keyword">static</span> <a class="code" href="namespaceSawyer_1_1Container_1_1Algorithm.html#ad6fc5c4b7ff7dd31ed0a2903a37228ae">CsiNextAction</a></div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;printSolution(<span class="keyword">const</span> MyGraph &amp;g1, <span class="keyword">const</span> std::vector&lt;size_t&gt; &amp;g1VertIds,</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;              <span class="keyword">const</span> MyGraph &amp;g2, <span class="keyword">const</span> std::vector&lt;size_t&gt; &amp;g2VertIds) {</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;    std::cout &lt;&lt;<span class="stringliteral">&quot;  solution graph has &quot;</span> &lt;&lt;g1.<a class="code" href="classSawyer_1_1Container_1_1Graph.html#a4c5244b7dddd1f511a0a9350fc79e182">nVertices</a>() &lt;&lt;<span class="stringliteral">&quot; vertices\n&quot;</span>;</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;    std::cout &lt;&lt;<span class="stringliteral">&quot;    vertex pairs:&quot;</span>;</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i&lt;g1VertIds.size(); ++i)</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;        std::cout &lt;&lt;<span class="stringliteral">&quot; (&quot;</span> &lt;&lt;g1VertIds[i] &lt;&lt;<span class="stringliteral">&quot;,&quot;</span> &lt;&lt;g2VertIds[i] &lt;&lt;<span class="stringliteral">&quot;)&quot;</span>;</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;    std::cout &lt;&lt;<span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160; </div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;    <span class="comment">// We can also turn the vertex vector representation into a true graph</span></div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;    <span class="comment">// so we can more easily operate on it.</span></div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;    MyGraph subgraph2 = <a class="code" href="namespaceSawyer_1_1Container_1_1Algorithm.html#aec93e4ec85b0e53249e4a71fbdf60976">graphCopySubgraph</a>(g2, g2VertIds);</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;    std::cout &lt;&lt;<span class="stringliteral">&quot;    subgraph2 has &quot;</span> &lt;&lt;subgraph2.nEdges() &lt;&lt;<span class="stringliteral">&quot; edges&quot;</span></div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;              &lt;&lt;<span class="stringliteral">&quot; and is &quot;</span> &lt;&lt;(<a class="code" href="namespaceSawyer_1_1Container_1_1Algorithm.html#a61fe8c4aaae390361068b47d7be07ce6">graphIsConnected</a>(subgraph2) ? <span class="stringliteral">&quot;&quot;</span> : <span class="stringliteral">&quot;not &quot;</span>) &lt;&lt;<span class="stringliteral">&quot;connected\n&quot;</span>;</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160; </div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespaceSawyer_1_1Container_1_1Algorithm.html#ad6fc5c4b7ff7dd31ed0a2903a37228aea6b096a1316b38af50d73ff9160fd9ac2">CSI_CONTINUE</a>;                                <span class="comment">// find more solutions</span></div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;}</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160; </div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;<span class="keywordtype">int</span> main() {</div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;    <span class="comment">// Ensure diagnostics are initialized</span></div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;    <a class="code" href="namespaceSawyer.html#a960dd0d2f8743b072c88e4232ea2698e">Sawyer::initializeLibrary</a>();</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160; </div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;    <span class="comment">// Create a couple graphs by inserting vertices and connecting them with edges.</span></div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;    <span class="comment">// This is just one of many ways to do this.</span></div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;    MyGraph g1;</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i&lt;5; ++i)</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;        g1.insertVertex();</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;    g1.insertEdge(g1.findVertex(0), g1.findVertex(1));</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;    g1.insertEdge(g1.findVertex(1), g1.findVertex(2));</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;    g1.insertEdge(g1.findVertex(1), g1.findVertex(3));</div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;    g1.insertEdge(g1.findVertex(2), g1.findVertex(3));</div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;    g1.insertEdge(g1.findVertex(3), g1.findVertex(4));</div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160; </div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;    MyGraph g2;</div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i&lt;7; ++i)</div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;        g2.insertVertex();</div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;    g2.insertEdge(g2.findVertex(0), g2.findVertex(1));</div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;    g2.insertEdge(g2.findVertex(1), g2.findVertex(2));</div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;    g2.insertEdge(g2.findVertex(1), g2.findVertex(3));</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;    g2.insertEdge(g2.findVertex(3), g2.findVertex(2));</div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;    g2.insertEdge(g2.findVertex(2), g2.findVertex(4));</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;    g2.insertEdge(g2.findVertex(4), g2.findVertex(5));</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;    g2.insertEdge(g2.findVertex(4), g2.findVertex(6));</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;    g2.insertEdge(g2.findVertex(6), g2.findVertex(5));</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160; </div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;    <span class="comment">// Do some operations</span></div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160; </div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;    std::cout &lt;&lt;<span class="stringliteral">&quot;Subgraphs of g2 that are isomorphic to g1\n&quot;</span>;</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;    <a class="code" href="namespaceSawyer_1_1Container_1_1Algorithm.html#abdfddcc3c0de62ffb90d868264b20483">findIsomorphicSubgraphs</a>(g1, g2, printSolution);</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160; </div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;    std::cout &lt;&lt;<span class="stringliteral">&quot;Subgraphs of both g1 and g2 that are isomorphic to each other\n&quot;</span>;</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;    <a class="code" href="namespaceSawyer_1_1Container_1_1Algorithm.html#a125e6d3b75c1f45be000702427b39a0f">findCommonIsomorphicSubgraphs</a>(g1, g2, printSolution);</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160; </div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;    std::cout &lt;&lt;<span class="stringliteral">&quot;Largest subgraphs of both g1 and g2 that are isomorphic\n&quot;</span>;</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;    <span class="keyword">typedef</span> std::vector&lt;size_t&gt; VertexIds;</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;    <span class="keyword">typedef</span> std::pair&lt;VertexIds, VertexIds&gt; Solution;</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;    <span class="keyword">typedef</span> std::vector&lt;Solution&gt; Solutions;</div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;    Solutions solns = <a class="code" href="namespaceSawyer_1_1Container_1_1Algorithm.html#af893c884305001ca91a0ef56a6c2f1b6">findMaximumCommonIsomorphicSubgraphs</a>(g1, g2);</div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;    BOOST_FOREACH (<span class="keyword">const</span> Solution &amp;soln, solns)</div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;        printSolution(g1, soln.first, g2, soln.second);</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;}</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="GraphAlgorithm_8h_source.html#l01098">1098</a> of file <a class="el" href="GraphAlgorithm_8h_source.html">GraphAlgorithm.h</a>.</p>

<p class="reference">References <a class="el" href="GraphAlgorithm_8h_source.html#l00671">Sawyer::Container::Algorithm::CommonSubgraphIsomorphism&lt; GraphA, GraphB, SolutionProcessor, EquivalenceP &gt;::monotonicallyIncreasing()</a>, <a class="el" href="GraphAlgorithm_8h_source.html#l00727">Sawyer::Container::Algorithm::CommonSubgraphIsomorphism&lt; GraphA, GraphB, SolutionProcessor, EquivalenceP &gt;::run()</a>, and <a class="el" href="GraphAlgorithm_8h_source.html#l00681">Sawyer::Container::Algorithm::CommonSubgraphIsomorphism&lt; GraphA, GraphB, SolutionProcessor, EquivalenceP &gt;::solutionProcessor()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceSawyer_1_1Container_1_1Algorithm_af893c884305001ca91a0ef56a6c2f1b6_cgraph.png" border="0" usemap="#namespaceSawyer_1_1Container_1_1Algorithm_af893c884305001ca91a0ef56a6c2f1b6_cgraph" alt=""/></div>
<map name="namespaceSawyer_1_1Container_1_1Algorithm_af893c884305001ca91a0ef56a6c2f1b6_cgraph" id="namespaceSawyer_1_1Container_1_1Algorithm_af893c884305001ca91a0ef56a6c2f1b6_cgraph">
<area shape="rect" title="Find maximum common isomorphic subgraphs." alt="" coords="5,79,221,135"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html#aeb984b8ea962c1be738a7d094a38fbd4" title="Property: monotonically increasing solution size." alt="" coords="283,5,551,61"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html#a795c5207d979a168d4f95814ce62f380" title="Perform the common subgraph isomorphism analysis." alt="" coords="269,86,564,127"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html#abfe2af18d37f66365a12764777912f7a" title="Property: reference to the solution callback." alt="" coords="283,152,551,208"/>
</map>
</div>

</div>
</div>
<a id="a4b6268dc90fe956302b41090fd6d5874"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b6268dc90fe956302b41090fd6d5874">&#9670;&nbsp;</a></span>findMaximumCommonIsomorphicSubgraphs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GraphA , class GraphB , class EquivalenceP &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::pair&lt;std::vector&lt;size_t&gt;, std::vector&lt;size_t&gt; &gt; &gt; Sawyer::Container::Algorithm::findMaximumCommonIsomorphicSubgraphs </td>
          <td>(</td>
          <td class="paramtype">const GraphA &amp;&#160;</td>
          <td class="paramname"><em>g1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GraphB &amp;&#160;</td>
          <td class="paramname"><em>g2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EquivalenceP&#160;</td>
          <td class="paramname"><em>equivalenceP</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find maximum common isomorphic subgraphs. </p>
<p>Given two graphs, find the largest possible isomorphic subgraph of those two graphs. The return value is a vector of pairs of vectors with each pair of vectors representing one solution. For any pair of vectors, the first vector contains the IDs of vertices selected to be in a subgraph of the first graph, and the second vector contains the ID numbers of vertices selected to be in a subgraph of the second graph. These two vectors are parallel and represent isomorphic pairs of vertices. The length of the vector-of-pairs is the number of solutions found; the lengths of all other vectors are equal to each other and represent the size of the (maximum) subgraph.</p>
<p>The <code>equivalenceP</code> is an optional predicate to determine when a pair of vertices, one from each graph, can be isomorphic. The subgraph solutions returned as pairs of parallel vectors will contain only pairs of vertices for which this predicate returns true.</p>
<p>This function is only a convenient wrapper around the <a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html">CommonSubgraphIsomorphism</a> class.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html">CommonSubgraphIsomorphism</a>, <a class="el" href="namespaceSawyer_1_1Container_1_1Algorithm.html#a125e6d3b75c1f45be000702427b39a0f">findCommonIsomorphicSubgraphs</a>, <a class="el" href="namespaceSawyer_1_1Container_1_1Algorithm.html#abdfddcc3c0de62ffb90d868264b20483">findIsomorphicSubgraphs</a>.</dd></dl>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="comment">// Example how to use graph isomorphism</span></div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="preprocessor">#include &lt;Sawyer/Graph.h&gt;</span></div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="preprocessor">#include &lt;Sawyer/GraphAlgorithm.h&gt;</span></div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="preprocessor">#include &lt;boost/foreach.hpp&gt;</span></div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160; </div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<span class="keyword">using namespace </span><a class="code" href="namespaceSawyer_1_1Container_1_1Algorithm.html">Sawyer::Container::Algorithm</a>;</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160; </div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;<span class="comment">// A graph with no user data, only connectivity info.</span></div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;<span class="keyword">typedef</span> <a class="code" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph&lt;&gt;</a> MyGraph;</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160; </div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;<span class="keyword">static</span> <a class="code" href="namespaceSawyer_1_1Container_1_1Algorithm.html#ad6fc5c4b7ff7dd31ed0a2903a37228ae">CsiNextAction</a></div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;printSolution(<span class="keyword">const</span> MyGraph &amp;g1, <span class="keyword">const</span> std::vector&lt;size_t&gt; &amp;g1VertIds,</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;              <span class="keyword">const</span> MyGraph &amp;g2, <span class="keyword">const</span> std::vector&lt;size_t&gt; &amp;g2VertIds) {</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;    std::cout &lt;&lt;<span class="stringliteral">&quot;  solution graph has &quot;</span> &lt;&lt;g1.<a class="code" href="classSawyer_1_1Container_1_1Graph.html#a4c5244b7dddd1f511a0a9350fc79e182">nVertices</a>() &lt;&lt;<span class="stringliteral">&quot; vertices\n&quot;</span>;</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;    std::cout &lt;&lt;<span class="stringliteral">&quot;    vertex pairs:&quot;</span>;</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i&lt;g1VertIds.size(); ++i)</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;        std::cout &lt;&lt;<span class="stringliteral">&quot; (&quot;</span> &lt;&lt;g1VertIds[i] &lt;&lt;<span class="stringliteral">&quot;,&quot;</span> &lt;&lt;g2VertIds[i] &lt;&lt;<span class="stringliteral">&quot;)&quot;</span>;</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;    std::cout &lt;&lt;<span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160; </div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;    <span class="comment">// We can also turn the vertex vector representation into a true graph</span></div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;    <span class="comment">// so we can more easily operate on it.</span></div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;    MyGraph subgraph2 = <a class="code" href="namespaceSawyer_1_1Container_1_1Algorithm.html#aec93e4ec85b0e53249e4a71fbdf60976">graphCopySubgraph</a>(g2, g2VertIds);</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;    std::cout &lt;&lt;<span class="stringliteral">&quot;    subgraph2 has &quot;</span> &lt;&lt;subgraph2.nEdges() &lt;&lt;<span class="stringliteral">&quot; edges&quot;</span></div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;              &lt;&lt;<span class="stringliteral">&quot; and is &quot;</span> &lt;&lt;(<a class="code" href="namespaceSawyer_1_1Container_1_1Algorithm.html#a61fe8c4aaae390361068b47d7be07ce6">graphIsConnected</a>(subgraph2) ? <span class="stringliteral">&quot;&quot;</span> : <span class="stringliteral">&quot;not &quot;</span>) &lt;&lt;<span class="stringliteral">&quot;connected\n&quot;</span>;</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160; </div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespaceSawyer_1_1Container_1_1Algorithm.html#ad6fc5c4b7ff7dd31ed0a2903a37228aea6b096a1316b38af50d73ff9160fd9ac2">CSI_CONTINUE</a>;                                <span class="comment">// find more solutions</span></div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;}</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160; </div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;<span class="keywordtype">int</span> main() {</div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;    <span class="comment">// Ensure diagnostics are initialized</span></div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;    <a class="code" href="namespaceSawyer.html#a960dd0d2f8743b072c88e4232ea2698e">Sawyer::initializeLibrary</a>();</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160; </div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;    <span class="comment">// Create a couple graphs by inserting vertices and connecting them with edges.</span></div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;    <span class="comment">// This is just one of many ways to do this.</span></div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;    MyGraph g1;</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i&lt;5; ++i)</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;        g1.insertVertex();</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;    g1.insertEdge(g1.findVertex(0), g1.findVertex(1));</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;    g1.insertEdge(g1.findVertex(1), g1.findVertex(2));</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;    g1.insertEdge(g1.findVertex(1), g1.findVertex(3));</div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;    g1.insertEdge(g1.findVertex(2), g1.findVertex(3));</div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;    g1.insertEdge(g1.findVertex(3), g1.findVertex(4));</div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160; </div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;    MyGraph g2;</div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i&lt;7; ++i)</div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;        g2.insertVertex();</div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;    g2.insertEdge(g2.findVertex(0), g2.findVertex(1));</div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;    g2.insertEdge(g2.findVertex(1), g2.findVertex(2));</div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;    g2.insertEdge(g2.findVertex(1), g2.findVertex(3));</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;    g2.insertEdge(g2.findVertex(3), g2.findVertex(2));</div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;    g2.insertEdge(g2.findVertex(2), g2.findVertex(4));</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;    g2.insertEdge(g2.findVertex(4), g2.findVertex(5));</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;    g2.insertEdge(g2.findVertex(4), g2.findVertex(6));</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;    g2.insertEdge(g2.findVertex(6), g2.findVertex(5));</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160; </div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;    <span class="comment">// Do some operations</span></div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160; </div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;    std::cout &lt;&lt;<span class="stringliteral">&quot;Subgraphs of g2 that are isomorphic to g1\n&quot;</span>;</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;    <a class="code" href="namespaceSawyer_1_1Container_1_1Algorithm.html#abdfddcc3c0de62ffb90d868264b20483">findIsomorphicSubgraphs</a>(g1, g2, printSolution);</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160; </div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;    std::cout &lt;&lt;<span class="stringliteral">&quot;Subgraphs of both g1 and g2 that are isomorphic to each other\n&quot;</span>;</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;    <a class="code" href="namespaceSawyer_1_1Container_1_1Algorithm.html#a125e6d3b75c1f45be000702427b39a0f">findCommonIsomorphicSubgraphs</a>(g1, g2, printSolution);</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160; </div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;    std::cout &lt;&lt;<span class="stringliteral">&quot;Largest subgraphs of both g1 and g2 that are isomorphic\n&quot;</span>;</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;    <span class="keyword">typedef</span> std::vector&lt;size_t&gt; VertexIds;</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;    <span class="keyword">typedef</span> std::pair&lt;VertexIds, VertexIds&gt; Solution;</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;    <span class="keyword">typedef</span> std::vector&lt;Solution&gt; Solutions;</div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;    Solutions solns = <a class="code" href="namespaceSawyer_1_1Container_1_1Algorithm.html#af893c884305001ca91a0ef56a6c2f1b6">findMaximumCommonIsomorphicSubgraphs</a>(g1, g2);</div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;    BOOST_FOREACH (<span class="keyword">const</span> Solution &amp;soln, solns)</div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;        printSolution(g1, soln.first, g2, soln.second);</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;}</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="GraphAlgorithm_8h_source.html#l01107">1107</a> of file <a class="el" href="GraphAlgorithm_8h_source.html">GraphAlgorithm.h</a>.</p>

<p class="reference">References <a class="el" href="GraphAlgorithm_8h_source.html#l00671">Sawyer::Container::Algorithm::CommonSubgraphIsomorphism&lt; GraphA, GraphB, SolutionProcessor, EquivalenceP &gt;::monotonicallyIncreasing()</a>, <a class="el" href="GraphAlgorithm_8h_source.html#l00727">Sawyer::Container::Algorithm::CommonSubgraphIsomorphism&lt; GraphA, GraphB, SolutionProcessor, EquivalenceP &gt;::run()</a>, and <a class="el" href="GraphAlgorithm_8h_source.html#l00681">Sawyer::Container::Algorithm::CommonSubgraphIsomorphism&lt; GraphA, GraphB, SolutionProcessor, EquivalenceP &gt;::solutionProcessor()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceSawyer_1_1Container_1_1Algorithm_a4b6268dc90fe956302b41090fd6d5874_cgraph.png" border="0" usemap="#namespaceSawyer_1_1Container_1_1Algorithm_a4b6268dc90fe956302b41090fd6d5874_cgraph" alt=""/></div>
<map name="namespaceSawyer_1_1Container_1_1Algorithm_a4b6268dc90fe956302b41090fd6d5874_cgraph" id="namespaceSawyer_1_1Container_1_1Algorithm_a4b6268dc90fe956302b41090fd6d5874_cgraph">
<area shape="rect" title="Find maximum common isomorphic subgraphs." alt="" coords="5,79,221,135"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html#aeb984b8ea962c1be738a7d094a38fbd4" title="Property: monotonically increasing solution size." alt="" coords="283,5,551,61"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html#a795c5207d979a168d4f95814ce62f380" title="Perform the common subgraph isomorphism analysis." alt="" coords="269,86,564,127"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html#abfe2af18d37f66365a12764777912f7a" title="Property: reference to the solution callback." alt="" coords="283,152,551,208"/>
</map>
</div>

</div>
</div>
<a id="a1b60b61ef69fc5f908ea7c6a80cf8394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b60b61ef69fc5f908ea7c6a80cf8394">&#9670;&nbsp;</a></span>graphDirectedDominators()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Direction , class Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;typename <a class="el" href="structSawyer_1_1Container_1_1GraphTraits.html">GraphTraits</a>&lt;<a class="el" href="classSawyer_1_1Container_1_1Graph.html">Graph</a>&gt;::VertexIterator&gt; Sawyer::Container::Algorithm::graphDirectedDominators </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1Container_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structSawyer_1_1Container_1_1GraphTraits.html">GraphTraits</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Graph</a> &gt;::VertexIterator&#160;</td>
          <td class="paramname"><em>root</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find immediate pre- or post-dominators. </p>
<p>Given a graph, find the immediate pre- or post-dominator of each vertex, if any, and return them as a vector. The vector, indexed by vertex ID, contains either a pointer (vertex iterator) to the dominator vertex, or no pointer (end vertex iterator) if the vertex has no dominator.</p>
<p>The algorithm employed here is loosely based on an algorithm from Rice University known to be O(n^2) where n is the number of vertices in the control flow subgraph connected to the start vertex. According to the Rice paper, their algorithm outperforms Lengauer-Tarjan on typicall control flow graphs even though asymptotically, Lengauer-Tarjan is better. The Rice algorithm is also much simpler.</p>
<p>I've added a few minor optimizations: </p><ul>
<li>Reverse post-order depth-first search is calculated once rather than each time through the loop. Rice's analysis indicates that they also made this optimization, although their listed algorithm does not show it. </li>
<li>The first processed predecessor of the vertex under consideration is determined in the same loop that processes the other predecessors, while in the listed algorithm this was a separate operation. </li>
<li>Self loops in the control flow graph are not processed, since they don't contribute to the dominance relation. </li>
<li>Undefined state for <code>idom(x)</code> is represented by <code>idom(x)==x</code>. </li>
<li>Nodes are labeled in reverse order from Rice, but traversed in the same order. This simplifies the code a bit because the vertices are traversed according to the "flowlist" vector, and the index into the "flowlist" vector can serve as the node label. </li>
<li>Back edges in the flowlist are ignored since their dominator must be along a forward edge.</li>
</ul>
<p>The set of dominators of vertex <em>v</em>, namely <em>dom(v)</em>, is represented as a linked list stored as an array indexed by vertex number. That is</p>
<div class="fragment"><div class="line">dom(v) = { v, idom(v), idom(idom(v)), ..., start }</div>
</div><!-- fragment --><p>is stored in the <code>idom</code> array as:</p>
<div class="fragment"><div class="line">dom(v) = { v, idom[v], idom[idom[v]], ..., start }</div>
</div><!-- fragment --><p>This representation, combined with the fact that: <em>a ELEMENT_OF dom(v) implies dom(a) SUBSET_OF dom(v)</em></p>
<p>allows us to perform intersection by simply walking the two sorted lists until we find an element in common, and including that element an all subsequent elements in the intersection result. The <code>idom</code> array uses the flow-list vertex numbering produced by a post-order visitor of a depth-first search, and the nodes are processed from highest to lowest. </p>

<p class="definition">Definition at line <a class="el" href="GraphAlgorithm_8h_source.html#l01159">1159</a> of file <a class="el" href="GraphAlgorithm_8h_source.html">GraphAlgorithm.h</a>.</p>

<p class="reference">References <a class="el" href="Graph_8h_source.html#l01507">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::findVertex()</a>, <a class="el" href="GraphTraversal_8h_source.html#l01427">graphReachableVertices()</a>, <a class="el" href="Graph_8h_source.html#l01557">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::isValidVertex()</a>, <a class="el" href="GraphTraversal_8h_source.html#l00060">LEAVE_VERTEX</a>, <a class="el" href="Graph_8h_source.html#l01676">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::nVertices()</a>, <a class="el" href="GraphTraversal_8h_source.html#l00474">Sawyer::Container::Algorithm::GraphTraversal&lt; G, Order, Direction &gt;::start()</a>, and <a class="el" href="Graph_8h_source.html#l01460">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::vertices()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceSawyer_1_1Container_1_1Algorithm_a1b60b61ef69fc5f908ea7c6a80cf8394_cgraph.png" border="0" usemap="#namespaceSawyer_1_1Container_1_1Algorithm_a1b60b61ef69fc5f908ea7c6a80cf8394_cgraph" alt=""/></div>
<map name="namespaceSawyer_1_1Container_1_1Algorithm_a1b60b61ef69fc5f908ea7c6a80cf8394_cgraph" id="namespaceSawyer_1_1Container_1_1Algorithm_a1b60b61ef69fc5f908ea7c6a80cf8394_cgraph">
<area shape="rect" title="Find immediate pre&#45; or post&#45;dominators." alt="" coords="5,143,239,184"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Graph.html#a3f256b70a465482d53478b84941dc8b5" title="Finds the vertex with specified ID number." alt="" coords="561,5,700,47"/>
<area shape="rect" href="namespaceSawyer_1_1Container_1_1Algorithm.html#a617753cc017ccac11b19da2d650c8423" title="IDs of vertices reachable from root." alt="" coords="287,227,513,268"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Graph.html#a7f5c8eef7ec4d3399518437f5dd22b68" title="Determines whether the vertex iterator is valid." alt="" coords="329,59,471,100"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Graph.html#a4c5244b7dddd1f511a0a9350fc79e182" title="Total number of vertices." alt="" coords="561,75,700,116"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Graph.html#a9aa5860369a9316640518c1eb3894de0" title="Iterators for all vertices." alt="" coords="561,149,700,191"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Algorithm_1_1GraphTraversal.html#a1025261c9abbd3c93ecdbedddeb670f7" title="Restart the traversal at the specified vertex." alt="" coords="313,293,487,349"/>
</map>
</div>

</div>
</div>
<a id="a69be98b48ce918b766a572e38bf8b5a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69be98b48ce918b766a572e38bf8b5a4">&#9670;&nbsp;</a></span>graphDominators()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;typename <a class="el" href="structSawyer_1_1Container_1_1GraphTraits.html">GraphTraits</a>&lt;<a class="el" href="classSawyer_1_1Container_1_1Graph.html">Graph</a>&gt;::VertexIterator&gt; Sawyer::Container::Algorithm::graphDominators </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1Container_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structSawyer_1_1Container_1_1GraphTraits.html">GraphTraits</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Graph</a> &gt;::VertexIterator&#160;</td>
          <td class="paramname"><em>root</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find immediate pre-dominators. </p>
<p>Given a graph, find the immediate pre-dominator of each vertex, if any, and return them as a vector. The vector, indexed by vertex ID, contains either a pointer (vertex iterator) to the dominator vertex, or no pointer (end vertex iterator) if the vertex has no dominator.</p>
<p>See also, <a class="el" href="namespaceSawyer_1_1Container_1_1Algorithm.html#a0aa402d88848560750c563af1142ccc6">graphPostDominators</a> and <a class="el" href="namespaceSawyer_1_1Container_1_1Algorithm.html#a1b60b61ef69fc5f908ea7c6a80cf8394">graphDirectedDominators</a>. </p>

<p class="definition">Definition at line <a class="el" href="GraphAlgorithm_8h_source.html#l01258">1258</a> of file <a class="el" href="GraphAlgorithm_8h_source.html">GraphAlgorithm.h</a>.</p>

</div>
</div>
<a id="a0aa402d88848560750c563af1142ccc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0aa402d88848560750c563af1142ccc6">&#9670;&nbsp;</a></span>graphPostDominators()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;typename <a class="el" href="structSawyer_1_1Container_1_1GraphTraits.html">GraphTraits</a>&lt;<a class="el" href="classSawyer_1_1Container_1_1Graph.html">Graph</a>&gt;::VertexIterator&gt; Sawyer::Container::Algorithm::graphPostDominators </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1Container_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structSawyer_1_1Container_1_1GraphTraits.html">GraphTraits</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Graph</a> &gt;::VertexIterator&#160;</td>
          <td class="paramname"><em>root</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find immediate post-dominators. </p>
<p>Given a graph, find the immediate post-dominator of each vertex, if any, and return them as a vector. The vector, indexed by vertex ID, contains either a pointer (vertex iterator) to the dominator vertex, or no pointer (end vertex iterator) if the vertex has no dominator.</p>
<p>See also, <a class="el" href="namespaceSawyer_1_1Container_1_1Algorithm.html#a69be98b48ce918b766a572e38bf8b5a4">graphDominators</a> and <a class="el" href="namespaceSawyer_1_1Container_1_1Algorithm.html#a1b60b61ef69fc5f908ea7c6a80cf8394">graphDirectedDominators</a>. </p>

<p class="definition">Definition at line <a class="el" href="GraphAlgorithm_8h_source.html#l01271">1271</a> of file <a class="el" href="GraphAlgorithm_8h_source.html">GraphAlgorithm.h</a>.</p>

</div>
</div>
<a id="a92b28e675d521eb8579df8d72e92fbbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92b28e675d521eb8579df8d72e92fbbd">&#9670;&nbsp;</a></span>nextVertex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VertexIterator , class EdgeIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">VertexIterator Sawyer::Container::Algorithm::nextVertex </td>
          <td>(</td>
          <td class="paramtype">EdgeIterator&#160;</td>
          <td class="paramname"><em>edge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1ForwardTraversalTag.html">ForwardTraversalTag</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Next vertex in traversal order. </p>
<p>Returns the next vertex in traversal order when given an edge. Forward-flowing traversal will return <code>edge-&gt;target()</code> and reverse-flowing traversals will return <code>edge-&gt;source()</code>. </p>

<p class="definition">Definition at line <a class="el" href="GraphTraversal_8h_source.html#l00101">101</a> of file <a class="el" href="GraphTraversal_8h_source.html">GraphTraversal.h</a>.</p>

</div>
</div>
<a id="a768297ef959c455f075fa8a92f172aa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a768297ef959c455f075fa8a92f172aa6">&#9670;&nbsp;</a></span>nextVertex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VertexIterator , class EdgeIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">VertexIterator Sawyer::Container::Algorithm::nextVertex </td>
          <td>(</td>
          <td class="paramtype">EdgeIterator&#160;</td>
          <td class="paramname"><em>edge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1ReverseTraversalTag.html">ReverseTraversalTag</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Next vertex in traversal order. </p>
<p>Returns the next vertex in traversal order when given an edge. Forward-flowing traversal will return <code>edge-&gt;target()</code> and reverse-flowing traversals will return <code>edge-&gt;source()</code>. </p>

<p class="definition">Definition at line <a class="el" href="GraphTraversal_8h_source.html#l00107">107</a> of file <a class="el" href="GraphTraversal_8h_source.html">GraphTraversal.h</a>.</p>

</div>
</div>
<a id="abe5f3b49013164c9cf93aa1e569fbe9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe5f3b49013164c9cf93aa1e569fbe9b">&#9670;&nbsp;</a></span>previousVertex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VertexIterator , class EdgeIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">VertexIterator Sawyer::Container::Algorithm::previousVertex </td>
          <td>(</td>
          <td class="paramtype">EdgeIterator&#160;</td>
          <td class="paramname"><em>edge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1ForwardTraversalTag.html">ForwardTraversalTag</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Previous vertex in traversal order. </p>
<p>Returns the previous vertex in traversal order when given an edge. Forward-flowing traversals will return <code>edge-&gt;source()</code> and reverse-flowing traversals will return <code>edge-&gt;target()</code>. </p>

<p class="definition">Definition at line <a class="el" href="GraphTraversal_8h_source.html#l00120">120</a> of file <a class="el" href="GraphTraversal_8h_source.html">GraphTraversal.h</a>.</p>

</div>
</div>
<a id="a1c02892dc1232c1135dfb0387b69acbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c02892dc1232c1135dfb0387b69acbe">&#9670;&nbsp;</a></span>previousVertex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VertexIterator , class EdgeIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">VertexIterator Sawyer::Container::Algorithm::previousVertex </td>
          <td>(</td>
          <td class="paramtype">EdgeIterator&#160;</td>
          <td class="paramname"><em>edge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1ReverseTraversalTag.html">ReverseTraversalTag</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Previous vertex in traversal order. </p>
<p>Returns the previous vertex in traversal order when given an edge. Forward-flowing traversals will return <code>edge-&gt;source()</code> and reverse-flowing traversals will return <code>edge-&gt;target()</code>. </p>

<p class="definition">Definition at line <a class="el" href="GraphTraversal_8h_source.html#l00126">126</a> of file <a class="el" href="GraphTraversal_8h_source.html">GraphTraversal.h</a>.</p>

</div>
</div>
<a id="a2be47d24b258103a45db7454dd7eb0e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2be47d24b258103a45db7454dd7eb0e4">&#9670;&nbsp;</a></span>nextEdges() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class EdgeIterator , class VertexIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::iterator_range&lt;EdgeIterator&gt; Sawyer::Container::Algorithm::nextEdges </td>
          <td>(</td>
          <td class="paramtype">VertexIterator&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1ForwardTraversalTag.html">ForwardTraversalTag</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Next edges in traversal order. </p>
<p>Returns edges that leave a vertex for the purpose of traversal. Forward-flowing traversals will return <code>vertex-&gt;outEdges()</code> and reverse-flowing traversals will return <code>vertex-&gt;inEdges()</code>. </p>

<p class="definition">Definition at line <a class="el" href="GraphTraversal_8h_source.html#l00139">139</a> of file <a class="el" href="GraphTraversal_8h_source.html">GraphTraversal.h</a>.</p>

</div>
</div>
<a id="a95f47ef955fcd8187c37060bebfb16af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95f47ef955fcd8187c37060bebfb16af">&#9670;&nbsp;</a></span>nextEdges() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class EdgeIterator , class VertexIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::iterator_range&lt;EdgeIterator&gt; Sawyer::Container::Algorithm::nextEdges </td>
          <td>(</td>
          <td class="paramtype">VertexIterator&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1ReverseTraversalTag.html">ReverseTraversalTag</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Next edges in traversal order. </p>
<p>Returns edges that leave a vertex for the purpose of traversal. Forward-flowing traversals will return <code>vertex-&gt;outEdges()</code> and reverse-flowing traversals will return <code>vertex-&gt;inEdges()</code>. </p>

<p class="definition">Definition at line <a class="el" href="GraphTraversal_8h_source.html#l00145">145</a> of file <a class="el" href="GraphTraversal_8h_source.html">GraphTraversal.h</a>.</p>

</div>
</div>
<a id="a699f335f6c39402a29aa9d3a90b4df75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a699f335f6c39402a29aa9d3a90b4df75">&#9670;&nbsp;</a></span>previousEdges() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class EdgeIterator , class VertexIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::iterator_range&lt;EdgeIterator&gt; Sawyer::Container::Algorithm::previousEdges </td>
          <td>(</td>
          <td class="paramtype">VertexIterator&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1ForwardTraversalTag.html">ForwardTraversalTag</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Previous edges in traversal order. </p>
<p>Returns edges that enter a vertex for the purpose of traversal. Forward-flowing traversals will return <code>vertex-&gt;inEdges()</code> and reverse-flowing traversals will return <code>vertex-&gt;outEdges()</code>. </p>

<p class="definition">Definition at line <a class="el" href="GraphTraversal_8h_source.html#l00158">158</a> of file <a class="el" href="GraphTraversal_8h_source.html">GraphTraversal.h</a>.</p>

</div>
</div>
<a id="ac4ee0fb5133524665af34d965fede3aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4ee0fb5133524665af34d965fede3aa">&#9670;&nbsp;</a></span>previousEdges() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class EdgeIterator , class VertexIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::iterator_range&lt;EdgeIterator&gt; Sawyer::Container::Algorithm::previousEdges </td>
          <td>(</td>
          <td class="paramtype">VertexIterator&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1ReverseTraversalTag.html">ReverseTraversalTag</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Previous edges in traversal order. </p>
<p>Returns edges that enter a vertex for the purpose of traversal. Forward-flowing traversals will return <code>vertex-&gt;inEdges()</code> and reverse-flowing traversals will return <code>vertex-&gt;outEdges()</code>. </p>

<p class="definition">Definition at line <a class="el" href="GraphTraversal_8h_source.html#l00164">164</a> of file <a class="el" href="GraphTraversal_8h_source.html">GraphTraversal.h</a>.</p>

</div>
</div>
<a id="a6cd4a9eb01c733ee9e5eee143c86daf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cd4a9eb01c733ee9e5eee143c86daf0">&#9670;&nbsp;</a></span>graphTraverseAllVertices() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Traversal , class Functor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Sawyer::Container::Algorithm::graphTraverseAllVertices </td>
          <td>(</td>
          <td class="paramtype">Traversal&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Visit all vertices of a graph. </p>
<p>This function operates as follows: First it uses the specified traversal and at each step determines if the current vertex has already been processed. If not, then the functor is called with two arguments (described below) and the vertex is marked as having been processed. If it was already processed, and the traversal is in an <code>ENTER_VERTEX</code> or <code>ENTER_EDGE</code> state, then its <a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1GraphTraversal.html#a6366dbafc7f0cb91be8433fad44e3148">skipChildren</a> method is invoked. When the traversal has been exhausted, the graph vertices are scanned in order of increasing IDs to find one that hasn't been processed, and the traversal is restarted at that vertex.</p>
<p>The functor is always invoked with two arguments: the current vertex, and the root of the traversal. Both are passed as vertex iterators. </p>

<p class="definition">Definition at line <a class="el" href="GraphTraversal_8h_source.html#l01293">1293</a> of file <a class="el" href="GraphTraversal_8h_source.html">GraphTraversal.h</a>.</p>

<p class="reference">References <a class="el" href="GraphTraversal_8h_source.html#l00044">ENTER_EDGE</a>, and <a class="el" href="GraphTraversal_8h_source.html#l00041">ENTER_VERTEX</a>.</p>

<p class="reference">Referenced by <a class="el" href="GraphTraversal_8h_source.html#l01449">graphAllVertices()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceSawyer_1_1Container_1_1Algorithm_a6cd4a9eb01c733ee9e5eee143c86daf0_icgraph.png" border="0" usemap="#namespaceSawyer_1_1Container_1_1Algorithm_a6cd4a9eb01c733ee9e5eee143c86daf0_icgraph" alt=""/></div>
<map name="namespaceSawyer_1_1Container_1_1Algorithm_a6cd4a9eb01c733ee9e5eee143c86daf0_icgraph" id="namespaceSawyer_1_1Container_1_1Algorithm_a6cd4a9eb01c733ee9e5eee143c86daf0_icgraph">
<area shape="rect" title="Visit all vertices of a graph." alt="" coords="233,5,416,61"/>
<area shape="rect" href="namespaceSawyer_1_1Container_1_1Algorithm.html#a15cdd0bcba0a605f526ce25c976c417a" title="IDs of all vertices." alt="" coords="5,13,185,54"/>
</map>
</div>

</div>
</div>
<a id="a1a4c1e4e9b266da03a3433037538e3d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a4c1e4e9b266da03a3433037538e3d9">&#9670;&nbsp;</a></span>graphTraverseAllVertices() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Traversal , class Functor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Sawyer::Container::Algorithm::graphTraverseAllVertices </td>
          <td>(</td>
          <td class="paramtype">Traversal&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Functor &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Visit all vertices of a graph. </p>
<p>This function operates as follows: First it uses the specified traversal and at each step determines if the current vertex has already been processed. If not, then the functor is called with two arguments (described below) and the vertex is marked as having been processed. If it was already processed, and the traversal is in an <code>ENTER_VERTEX</code> or <code>ENTER_EDGE</code> state, then its <a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1GraphTraversal.html#a6366dbafc7f0cb91be8433fad44e3148">skipChildren</a> method is invoked. When the traversal has been exhausted, the graph vertices are scanned in order of increasing IDs to find one that hasn't been processed, and the traversal is restarted at that vertex.</p>
<p>The functor is always invoked with two arguments: the current vertex, and the root of the traversal. Both are passed as vertex iterators. </p>

<p class="definition">Definition at line <a class="el" href="GraphTraversal_8h_source.html#l01315">1315</a> of file <a class="el" href="GraphTraversal_8h_source.html">GraphTraversal.h</a>.</p>

<p class="reference">References <a class="el" href="GraphTraversal_8h_source.html#l00044">ENTER_EDGE</a>, and <a class="el" href="GraphTraversal_8h_source.html#l00041">ENTER_VERTEX</a>.</p>

</div>
</div>
<a id="a2dd72b2ccebcd2af6f9e27bb21edfe39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dd72b2ccebcd2af6f9e27bb21edfe39">&#9670;&nbsp;</a></span>graphTraverseAllEdges() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Traversal , class Functor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Sawyer::Container::Algorithm::graphTraverseAllEdges </td>
          <td>(</td>
          <td class="paramtype">Traversal&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Visit all edges of a graph. </p>
<p>This function operates as follows: First it uses the specified traversal and at each step determines if the current edge has already been processed. If not, then the functor is called with two arguments (described below) and the edge is marked as having been processed. If it was already processed, and the traversal is in an <code>ENTER_VERTEX</code> or <code>ENTER_EDGE</code> state, then its <a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1GraphTraversal.html#a6366dbafc7f0cb91be8433fad44e3148">skipChildren</a> method is invoked. When the traversal has been exhausted, the graph edges are scanned in order of increasing IDs to find one that hasn't been processed, and the traversal is restarted at that edge.</p>
<p>The functor is always invoked with two arguments: the current edge, and the root of the traversal. Both are passed as edge iterators. </p>

<p class="definition">Definition at line <a class="el" href="GraphTraversal_8h_source.html#l01352">1352</a> of file <a class="el" href="GraphTraversal_8h_source.html">GraphTraversal.h</a>.</p>

<p class="reference">References <a class="el" href="GraphTraversal_8h_source.html#l00044">ENTER_EDGE</a>, and <a class="el" href="GraphTraversal_8h_source.html#l00041">ENTER_VERTEX</a>.</p>

<p class="reference">Referenced by <a class="el" href="GraphTraversal_8h_source.html#l01461">graphAllEdges()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceSawyer_1_1Container_1_1Algorithm_a2dd72b2ccebcd2af6f9e27bb21edfe39_icgraph.png" border="0" usemap="#namespaceSawyer_1_1Container_1_1Algorithm_a2dd72b2ccebcd2af6f9e27bb21edfe39_icgraph" alt=""/></div>
<map name="namespaceSawyer_1_1Container_1_1Algorithm_a2dd72b2ccebcd2af6f9e27bb21edfe39_icgraph" id="namespaceSawyer_1_1Container_1_1Algorithm_a2dd72b2ccebcd2af6f9e27bb21edfe39_icgraph">
<area shape="rect" title="Visit all edges of a graph." alt="" coords="223,5,405,61"/>
<area shape="rect" href="namespaceSawyer_1_1Container_1_1Algorithm.html#aac379b7e16d94b797e46721fee801ec3" title="IDs of all edges." alt="" coords="5,13,175,54"/>
</map>
</div>

</div>
</div>
<a id="a265f40d32ade7ecf73946a6b89cd095f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a265f40d32ade7ecf73946a6b89cd095f">&#9670;&nbsp;</a></span>graphTraverseAllEdges() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Traversal , class Functor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Sawyer::Container::Algorithm::graphTraverseAllEdges </td>
          <td>(</td>
          <td class="paramtype">Traversal&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Functor &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Visit all edges of a graph. </p>
<p>This function operates as follows: First it uses the specified traversal and at each step determines if the current edge has already been processed. If not, then the functor is called with two arguments (described below) and the edge is marked as having been processed. If it was already processed, and the traversal is in an <code>ENTER_VERTEX</code> or <code>ENTER_EDGE</code> state, then its <a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1GraphTraversal.html#a6366dbafc7f0cb91be8433fad44e3148">skipChildren</a> method is invoked. When the traversal has been exhausted, the graph edges are scanned in order of increasing IDs to find one that hasn't been processed, and the traversal is restarted at that edge.</p>
<p>The functor is always invoked with two arguments: the current edge, and the root of the traversal. Both are passed as edge iterators. </p>

<p class="definition">Definition at line <a class="el" href="GraphTraversal_8h_source.html#l01374">1374</a> of file <a class="el" href="GraphTraversal_8h_source.html">GraphTraversal.h</a>.</p>

<p class="reference">References <a class="el" href="GraphTraversal_8h_source.html#l00044">ENTER_EDGE</a>, and <a class="el" href="GraphTraversal_8h_source.html#l00041">ENTER_VERTEX</a>.</p>

</div>
</div>
<a id="a617753cc017ccac11b19da2d650c8423"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a617753cc017ccac11b19da2d650c8423">&#9670;&nbsp;</a></span>graphReachableVertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Traversal &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;size_t&gt; Sawyer::Container::Algorithm::graphReachableVertices </td>
          <td>(</td>
          <td class="paramtype">Traversal&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>IDs of vertices reachable from root. </p>
<p>Returns a vector of vertex IDs that are reachable from <code>root</code> in the order specified by the traversal template argument. </p>

<p class="definition">Definition at line <a class="el" href="GraphTraversal_8h_source.html#l01427">1427</a> of file <a class="el" href="GraphTraversal_8h_source.html">GraphTraversal.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="GraphAlgorithm_8h_source.html#l01159">graphDirectedDominators()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceSawyer_1_1Container_1_1Algorithm_a617753cc017ccac11b19da2d650c8423_icgraph.png" border="0" usemap="#namespaceSawyer_1_1Container_1_1Algorithm_a617753cc017ccac11b19da2d650c8423_icgraph" alt=""/></div>
<map name="namespaceSawyer_1_1Container_1_1Algorithm_a617753cc017ccac11b19da2d650c8423_icgraph" id="namespaceSawyer_1_1Container_1_1Algorithm_a617753cc017ccac11b19da2d650c8423_icgraph">
<area shape="rect" title="IDs of vertices reachable from root." alt="" coords="287,5,513,47"/>
<area shape="rect" href="namespaceSawyer_1_1Container_1_1Algorithm.html#a1b60b61ef69fc5f908ea7c6a80cf8394" title="Find immediate pre&#45; or post&#45;dominators." alt="" coords="5,5,239,47"/>
</map>
</div>

</div>
</div>
<a id="aa70b47812a00752e613b169b229011b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa70b47812a00752e613b169b229011b0">&#9670;&nbsp;</a></span>graphReachableEdges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Traversal &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;size_t&gt; Sawyer::Container::Algorithm::graphReachableEdges </td>
          <td>(</td>
          <td class="paramtype">Traversal&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>IDs of edges reachable from root. </p>
<p>Returns a vector of edge IDs that are reachable from <code>root</code> in the order specified by the traversal template argument. </p>

<p class="definition">Definition at line <a class="el" href="GraphTraversal_8h_source.html#l01437">1437</a> of file <a class="el" href="GraphTraversal_8h_source.html">GraphTraversal.h</a>.</p>

</div>
</div>
<a id="a15cdd0bcba0a605f526ce25c976c417a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15cdd0bcba0a605f526ce25c976c417a">&#9670;&nbsp;</a></span>graphAllVertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Traversal , class Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;size_t&gt; Sawyer::Container::Algorithm::graphAllVertices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1Container_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>IDs of all vertices. </p>
<p>Returns the IDs for all vertices in the order specified by the traversal. All IDs appear in the returned vector, which is created by choosing the lowest ID that isn't in the vector and running the specified traversal with that ID as the root, and repeating until all vertices are processed. </p>

<p class="definition">Definition at line <a class="el" href="GraphTraversal_8h_source.html#l01449">1449</a> of file <a class="el" href="GraphTraversal_8h_source.html">GraphTraversal.h</a>.</p>

<p class="reference">References <a class="el" href="GraphTraversal_8h_source.html#l01293">graphTraverseAllVertices()</a>, <a class="el" href="Graph_8h_source.html#l01676">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::nVertices()</a>, and <a class="el" href="Graph_8h_source.html#l01460">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::vertices()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceSawyer_1_1Container_1_1Algorithm_a15cdd0bcba0a605f526ce25c976c417a_cgraph.png" border="0" usemap="#namespaceSawyer_1_1Container_1_1Algorithm_a15cdd0bcba0a605f526ce25c976c417a_cgraph" alt=""/></div>
<map name="namespaceSawyer_1_1Container_1_1Algorithm_a15cdd0bcba0a605f526ce25c976c417a_cgraph" id="namespaceSawyer_1_1Container_1_1Algorithm_a15cdd0bcba0a605f526ce25c976c417a_cgraph">
<area shape="rect" title="IDs of all vertices." alt="" coords="5,86,185,127"/>
<area shape="rect" href="namespaceSawyer_1_1Container_1_1Algorithm.html#a6cd4a9eb01c733ee9e5eee143c86daf0" title="Visit all vertices of a graph." alt="" coords="233,5,416,61"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Graph.html#a4c5244b7dddd1f511a0a9350fc79e182" title="Total number of vertices." alt="" coords="255,86,394,127"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Graph.html#a9aa5860369a9316640518c1eb3894de0" title="Iterators for all vertices." alt="" coords="255,151,394,193"/>
</map>
</div>

</div>
</div>
<a id="aac379b7e16d94b797e46721fee801ec3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac379b7e16d94b797e46721fee801ec3">&#9670;&nbsp;</a></span>graphAllEdges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Traversal , class Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;size_t&gt; Sawyer::Container::Algorithm::graphAllEdges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1Container_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>IDs of all edges. </p>
<p>Returns the IDs for all edges in the order specified by the traversal. All IDs appear in the returned vector, which is created by choosing the lowest ID that isn't in the vector and running the specified traversal with that ID as the root, and repeating until all edges are processed. </p>

<p class="definition">Definition at line <a class="el" href="GraphTraversal_8h_source.html#l01461">1461</a> of file <a class="el" href="GraphTraversal_8h_source.html">GraphTraversal.h</a>.</p>

<p class="reference">References <a class="el" href="Graph_8h_source.html#l01569">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::edges()</a>, <a class="el" href="GraphTraversal_8h_source.html#l01352">graphTraverseAllEdges()</a>, and <a class="el" href="Graph_8h_source.html#l01686">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::nEdges()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceSawyer_1_1Container_1_1Algorithm_aac379b7e16d94b797e46721fee801ec3_cgraph.png" border="0" usemap="#namespaceSawyer_1_1Container_1_1Algorithm_aac379b7e16d94b797e46721fee801ec3_cgraph" alt=""/></div>
<map name="namespaceSawyer_1_1Container_1_1Algorithm_aac379b7e16d94b797e46721fee801ec3_cgraph" id="namespaceSawyer_1_1Container_1_1Algorithm_aac379b7e16d94b797e46721fee801ec3_cgraph">
<area shape="rect" title="IDs of all edges." alt="" coords="5,79,175,120"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Graph.html#a0c04596aa16ca7b324bceed8859f08f4" title="Iterators for all edges." alt="" coords="245,5,383,47"/>
<area shape="rect" href="namespaceSawyer_1_1Container_1_1Algorithm.html#a2dd72b2ccebcd2af6f9e27bb21edfe39" title="Visit all edges of a graph." alt="" coords="223,71,405,127"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Graph.html#ae324cd7b2cc9b5d100d5d9b3960a931b" title="Total number of edges." alt="" coords="245,152,383,193"/>
</map>
</div>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="anamespaceSawyer_1_1Container_1_1Algorithm_html_a125e6d3b75c1f45be000702427b39a0f"><div class="ttname"><a href="namespaceSawyer_1_1Container_1_1Algorithm.html#a125e6d3b75c1f45be000702427b39a0f">Sawyer::Container::Algorithm::findCommonIsomorphicSubgraphs</a></div><div class="ttdeci">void findCommonIsomorphicSubgraphs(const GraphA &amp;g1, const GraphB &amp;g2, SolutionProcessor solutionProcessor)</div><div class="ttdoc">Find common isomorphic subgraphs.</div><div class="ttdef"><b>Definition:</b> <a href="GraphAlgorithm_8h_source.html#l00966">GraphAlgorithm.h:966</a></div></div>
<div class="ttc" id="aclassSawyer_1_1Container_1_1Graph_html"><div class="ttname"><a href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a></div><div class="ttdoc">Graph containing user-defined vertices and edges.</div><div class="ttdef"><b>Definition:</b> <a href="Graph_8h_source.html#l00625">Graph.h:625</a></div></div>
<div class="ttc" id="aclassSawyer_1_1Container_1_1Graph_html_a4c5244b7dddd1f511a0a9350fc79e182"><div class="ttname"><a href="classSawyer_1_1Container_1_1Graph.html#a4c5244b7dddd1f511a0a9350fc79e182">Sawyer::Container::Graph::nVertices</a></div><div class="ttdeci">size_t nVertices() const</div><div class="ttdoc">Total number of vertices.</div><div class="ttdef"><b>Definition:</b> <a href="Graph_8h_source.html#l01676">Graph.h:1676</a></div></div>
<div class="ttc" id="anamespaceSawyer_1_1Container_1_1Algorithm_html_ad6fc5c4b7ff7dd31ed0a2903a37228aea6b096a1316b38af50d73ff9160fd9ac2"><div class="ttname"><a href="namespaceSawyer_1_1Container_1_1Algorithm.html#ad6fc5c4b7ff7dd31ed0a2903a37228aea6b096a1316b38af50d73ff9160fd9ac2">Sawyer::Container::Algorithm::CSI_CONTINUE</a></div><div class="ttdeci">@ CSI_CONTINUE</div><div class="ttdoc">Continue searching for more solutions.</div><div class="ttdef"><b>Definition:</b> <a href="GraphAlgorithm_8h_source.html#l00375">GraphAlgorithm.h:375</a></div></div>
<div class="ttc" id="anamespaceSawyer_1_1Container_1_1Algorithm_html_a61fe8c4aaae390361068b47d7be07ce6"><div class="ttname"><a href="namespaceSawyer_1_1Container_1_1Algorithm.html#a61fe8c4aaae390361068b47d7be07ce6">Sawyer::Container::Algorithm::graphIsConnected</a></div><div class="ttdeci">bool graphIsConnected(const Graph &amp;g)</div><div class="ttdoc">Test whether a graph is connected.</div><div class="ttdef"><b>Definition:</b> <a href="GraphAlgorithm_8h_source.html#l00136">GraphAlgorithm.h:136</a></div></div>
<div class="ttc" id="anamespaceSawyer_1_1Container_1_1Algorithm_html"><div class="ttname"><a href="namespaceSawyer_1_1Container_1_1Algorithm.html">Sawyer::Container::Algorithm</a></div><div class="ttdoc">Algorithms that operate on container classes.</div><div class="ttdef"><b>Definition:</b> <a href="GraphAlgorithm_8h_source.html#l00041">GraphAlgorithm.h:41</a></div></div>
<div class="ttc" id="anamespaceSawyer_1_1Container_1_1Algorithm_html_aec93e4ec85b0e53249e4a71fbdf60976"><div class="ttname"><a href="namespaceSawyer_1_1Container_1_1Algorithm.html#aec93e4ec85b0e53249e4a71fbdf60976">Sawyer::Container::Algorithm::graphCopySubgraph</a></div><div class="ttdeci">Graph graphCopySubgraph(const Graph &amp;g, const std::vector&lt; size_t &gt; &amp;vertexIdVector)</div><div class="ttdoc">Create a subgraph.</div><div class="ttdef"><b>Definition:</b> <a href="GraphAlgorithm_8h_source.html#l00221">GraphAlgorithm.h:221</a></div></div>
<div class="ttc" id="anamespaceSawyer_1_1Container_1_1Algorithm_html_af893c884305001ca91a0ef56a6c2f1b6"><div class="ttname"><a href="namespaceSawyer_1_1Container_1_1Algorithm.html#af893c884305001ca91a0ef56a6c2f1b6">Sawyer::Container::Algorithm::findMaximumCommonIsomorphicSubgraphs</a></div><div class="ttdeci">std::vector&lt; std::pair&lt; std::vector&lt; size_t &gt;, std::vector&lt; size_t &gt; &gt; &gt; findMaximumCommonIsomorphicSubgraphs(const GraphA &amp;g1, const GraphB &amp;g2)</div><div class="ttdoc">Find maximum common isomorphic subgraphs.</div><div class="ttdef"><b>Definition:</b> <a href="GraphAlgorithm_8h_source.html#l01098">GraphAlgorithm.h:1098</a></div></div>
<div class="ttc" id="anamespaceSawyer_1_1Container_1_1Algorithm_html_abdfddcc3c0de62ffb90d868264b20483"><div class="ttname"><a href="namespaceSawyer_1_1Container_1_1Algorithm.html#abdfddcc3c0de62ffb90d868264b20483">Sawyer::Container::Algorithm::findIsomorphicSubgraphs</a></div><div class="ttdeci">void findIsomorphicSubgraphs(const GraphA &amp;g1, const GraphB &amp;g2, SolutionProcessor solutionProcessor)</div><div class="ttdoc">Find an isomorphic subgraph.</div><div class="ttdef"><b>Definition:</b> <a href="GraphAlgorithm_8h_source.html#l01043">GraphAlgorithm.h:1043</a></div></div>
<div class="ttc" id="anamespaceSawyer_html_a960dd0d2f8743b072c88e4232ea2698e"><div class="ttname"><a href="namespaceSawyer.html#a960dd0d2f8743b072c88e4232ea2698e">Sawyer::initializeLibrary</a></div><div class="ttdeci">bool initializeLibrary(size_t vmajor=0, size_t vminor=1, size_t vpatch=0, bool withThreads=0)</div><div class="ttdoc">Explicitly initialize the library.</div></div>
<div class="ttc" id="anamespaceSawyer_1_1Container_1_1Algorithm_html_ad6fc5c4b7ff7dd31ed0a2903a37228ae"><div class="ttname"><a href="namespaceSawyer_1_1Container_1_1Algorithm.html#ad6fc5c4b7ff7dd31ed0a2903a37228ae">Sawyer::Container::Algorithm::CsiNextAction</a></div><div class="ttdeci">CsiNextAction</div><div class="ttdoc">How the CSI algorith should proceed.</div><div class="ttdef"><b>Definition:</b> <a href="GraphAlgorithm_8h_source.html#l00374">GraphAlgorithm.h:374</a></div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Dec 19 2022 23:40:27 for ROSE by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
