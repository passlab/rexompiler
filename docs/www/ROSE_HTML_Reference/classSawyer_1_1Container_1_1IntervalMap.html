<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROSE: Sawyer::Container::IntervalMap&lt; I, T, Policy &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="ROSE"/>
<link href="roseDoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ROSE
   &#160;<span id="projectnumber">0.11.96.11</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,true,'search.html','Search');
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceSawyer.html">Sawyer</a></li><li class="navelem"><a class="el" href="namespaceSawyer_1_1Container.html">Container</a></li><li class="navelem"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classSawyer_1_1Container_1_1IntervalMap-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Sawyer::Container::IntervalMap&lt; I, T, Policy &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><h3>template&lt;typename I, typename T, class Policy = MergePolicy&lt;I, T&gt;&gt;<br />
class Sawyer::Container::IntervalMap&lt; I, T, Policy &gt;</h3>

<p>An associative container whose keys are non-overlapping intervals. </p>
<p>This container is somewhat like an STL <code>std::map</code> in that it stores key/value pairs. However, it is optimized for the case when many consecutive keys are the same or related. The values may be any type; the keys are any interval type that follows the API and semantics of <a class="el" href="classSawyer_1_1Container_1_1Interval.html" title="Range of values delimited by endpoints.">Sawyer::Container::Interval</a>, namely a closed interval with members <code>least</code> and <code>greatest</code> demarcating the inclusive end points, and a few other methods.</p>
<p>The interval/value pair nodes that are stored in this container are managed by the container, automatically joining adjacent nodes when they are inserted, if possible and permitted, and automatically spliting nodes if necessary when something is erased. For the most part, the user can think of this container as associating scalar keys with values, and almost forget that the container uses intervals as an optimization.</p>
<p>When two neighboring interval/value nodes are inserted, the container will possibly join them into a single interval/value node. Normally, the merging of two nodes happens if the two values are equal, but this can be influenced by a policy class provided as an argument of the container's constructor. See <a class="el" href="classSawyer_1_1Container_1_1MergePolicy.html">MergePolicy</a> for details. Similarly, when part of an interval is erased, the container might need to split the affected node into two nodes, which is also handled by the policy.</p>
<p>The following examples demonstrates some aspects of the interface:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="classSawyer_1_1Container_1_1Interval.html">Sawyer::Container::Interval&lt;unsigned&gt;</a> <a class="code" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>; <span class="comment">// integral types work best</span></div>
<div class="line"><span class="keyword">class </span>Stats {...} stats1=..., stats2=...; <span class="comment">// needs at least a copy c&#39;tor, assignment, and equality predicate.</span></div>
<div class="line"><span class="keyword">typedef</span> IntervalMap&lt;Interval, Stats&gt; <a class="code" href="classSawyer_1_1Container_1_1IntervalMap.html#ae27b32aea90cdef93228cd5c978c00ef">Map</a>;</div>
<div class="line"><a class="code" href="classMap.html">Map</a> map;</div>
<div class="line">map.insert(<a class="code" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>(1,5), stats1);</div>
<div class="line">map.insert(6, stats2);</div>
</div><!-- fragment --><p>If the policy allows the two "stats" objects to be merged (the default policy allows them to merge only if they are equal), then the container will end up having one node, the pair ([1,6], merge(stats1,stats2)), otherwise it will have two nodes.</p>
<div class="fragment"><div class="line">map.erase(<a class="code" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>(2,3));</div>
</div><!-- fragment --><p>Erasing keys 2 and 3 causes the affected node to split into two discontiguous nodes and a new copy of the node's value. Assuming we started with the two nodes { ([1,5], stats1), (6, stats2) }, then after erasing [2,3] the container will hold three nodes: { (1, stats1), ([4,5], stats1), (6, stats2) }.</p>
<p>Iteration over the container returns references to the nodes as <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad3da8180167b02f750f8138e21fea1b8">Node</a> object that has <code>key</code> and <code>value</code> methods to access the interval key and user-defined value parts of each storage node. For example, here's one way to print the contents of the container, assuming the interval itself doesn't already have a printing function:</p>
<div class="fragment"><div class="line">std::cout &lt;&lt;<span class="stringliteral">&quot;{&quot;</span>;</div>
<div class="line"><span class="keywordflow">for</span> (Map::ConstNodeIterator iter=map.nodes().begin(); iter!=map.nodes().end(); ++iter) {</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a> &amp;interval = iter-&gt;key();</div>
<div class="line">    <span class="keyword">const</span> Stats &amp;stats = iter-&gt;value();</div>
<div class="line">    std::cout &lt;&lt;<span class="stringliteral">&quot; (&quot;</span>;</div>
<div class="line">    <span class="keywordflow">if</span> (interval.isSingleton())</div>
<div class="line">        std::cout &lt;&lt;interval.least() &lt;&lt;<span class="stringliteral">&quot;, &quot;</span>;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        std::cout &lt;&lt;<span class="stringliteral">&quot;[&quot;</span> &lt;&lt;interval.least() &lt;&lt;<span class="stringliteral">&quot;,&quot;</span> &lt;&lt;interval.greatest() &lt;&lt;<span class="stringliteral">&quot;], &quot;</span>;</div>
<div class="line">    }</div>
<div class="line">    std::cout &lt;&lt;stats &lt;&lt;<span class="stringliteral">&quot;)&quot;</span>;</div>
<div class="line">}</div>
<div class="line">std::cout &lt;&lt;<span class="stringliteral">&quot; }&quot;</span>;</div>
</div><!-- fragment --><p>Here's another way:</p>
<div class="fragment"><div class="line">BOOST_FOREACH (<span class="keyword">const</span> Map::Node &amp;node, map.nodes()) {</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a> &amp;interval = node.key();</div>
<div class="line">    <span class="keyword">const</span> Stats &amp;stats = node.value();</div>
<div class="line">    ...</div>
<div class="line">}</div>
</div><!-- fragment --><p>Besides <code><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a4bcd6255a35955db90ec2d0f939086e2" title="Iterators for traversing nodes.">nodes()</a></code>, there's also <code><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#afe92a3a1fed8440a506b3cde7891a665" title="Iterators for traversing values.">values()</a></code> and <code><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ae4ba034340ba48ff172b39cc80f3dc6e" title="Iterators for traversing keys.">intervals()</a></code> that return bidirectional iterators over the user-defined values or the intervals when dereferenced.</p>
<p>This class uses CamelCase for all its methods and inner types in conformance with the naming convention for the rest of the library. This includes iterator names (we don't use <code>iterator</code>, <code>const_iterator</code>, etc).</p>
<dl class="section see"><dt>See also</dt><dd></dd></dl>
<p>See <a class="el" href="classSawyer_1_1Container_1_1IntervalSetMap.html">IntervalSetMap</a> for a similar container that stores sets of values per interval. </p>

<p class="definition">Definition at line <a class="el" href="IntervalMap_8h_source.html#l00171">171</a> of file <a class="el" href="IntervalMap_8h_source.html">IntervalMap.h</a>.</p>
</div>
<p><code>#include &lt;<a class="el" href="IntervalMap_8h_source.html">IntervalMap.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Sawyer::Container::IntervalMap&lt; I, T, Policy &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1IntervalMap__inherit__graph.png" border="0" usemap="#Sawyer_1_1Container_1_1IntervalMap_3_01I_00_01T_00_01Policy_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="Sawyer_1_1Container_1_1IntervalMap_3_01I_00_01T_00_01Policy_01_4_inherit__map" id="Sawyer_1_1Container_1_1IntervalMap_3_01I_00_01T_00_01Policy_01_4_inherit__map">
<area shape="rect" title="An associative container whose keys are non&#45;overlapping intervals." alt="" coords="5,148,181,189"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalMap.html" title=" " alt="" coords="512,5,652,47"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalMap.html" title=" " alt="" coords="455,71,709,171"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalMap.html" title=" " alt="" coords="513,195,651,236"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalMap.html" title=" " alt="" coords="507,261,657,317"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a664961032974fd71f132d8931edd68de"><td class="memItemLeft" align="right" valign="top"><a id="a664961032974fd71f132d8931edd68de"></a>
typedef I&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a></td></tr>
<tr class="memdesc:a664961032974fd71f132d8931edd68de"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classSawyer_1_1Container_1_1Interval.html" title="Range of values delimited by endpoints.">Interval</a> type. <br /></td></tr>
<tr class="separator:a664961032974fd71f132d8931edd68de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c7ef387287aa01aa632dfeafc121e95"><td class="memItemLeft" align="right" valign="top"><a id="a7c7ef387287aa01aa632dfeafc121e95"></a>
typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a7c7ef387287aa01aa632dfeafc121e95">Value</a></td></tr>
<tr class="memdesc:a7c7ef387287aa01aa632dfeafc121e95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value type. <br /></td></tr>
<tr class="separator:a7c7ef387287aa01aa632dfeafc121e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae27b32aea90cdef93228cd5c978c00ef"><td class="memItemLeft" align="right" valign="top"><a id="ae27b32aea90cdef93228cd5c978c00ef"></a>
typedef <a class="el" href="classSawyer_1_1Container_1_1Map.html">Container::Map</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a7c7ef387287aa01aa632dfeafc121e95">Value</a>, IntervalCompare &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ae27b32aea90cdef93228cd5c978c00ef">Map</a></td></tr>
<tr class="memdesc:ae27b32aea90cdef93228cd5c978c00ef"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceSawyer_1_1Type.html" title="Data types.">Type</a> of the underlying map. <br /></td></tr>
<tr class="separator:ae27b32aea90cdef93228cd5c978c00ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3da8180167b02f750f8138e21fea1b8"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSawyer_1_1Container_1_1Map_1_1Node.html">Map::Node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad3da8180167b02f750f8138e21fea1b8">Node</a></td></tr>
<tr class="memdesc:ad3da8180167b02f750f8138e21fea1b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage node.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#ad3da8180167b02f750f8138e21fea1b8">More...</a><br /></td></tr>
<tr class="separator:ad3da8180167b02f750f8138e21fea1b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5130ce1b0e59f7bddd6b68f02da3b2e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSawyer_1_1Container_1_1Map_1_1ConstKeyIterator.html">Map::ConstKeyIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ae5130ce1b0e59f7bddd6b68f02da3b2e">ConstIntervalIterator</a></td></tr>
<tr class="memdesc:ae5130ce1b0e59f7bddd6b68f02da3b2e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classSawyer_1_1Container_1_1Interval.html" title="Range of values delimited by endpoints.">Interval</a> iterator.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#ae5130ce1b0e59f7bddd6b68f02da3b2e">More...</a><br /></td></tr>
<tr class="separator:ae5130ce1b0e59f7bddd6b68f02da3b2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ae50e191b16e240244fb48af0232e88ac"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSawyer_1_1Container_1_1Map_1_1ValueIterator.html">Map::ValueIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ae50e191b16e240244fb48af0232e88ac">ValueIterator</a></td></tr>
<tr class="memdesc:ae50e191b16e240244fb48af0232e88ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value iterator.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#ae50e191b16e240244fb48af0232e88ac">More...</a><br /></td></tr>
<tr class="separator:ae50e191b16e240244fb48af0232e88ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a050e4ca3dcf0d65fba2d65b20e9730d9"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSawyer_1_1Container_1_1Map_1_1ConstValueIterator.html">Map::ConstValueIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a050e4ca3dcf0d65fba2d65b20e9730d9">ConstValueIterator</a></td></tr>
<tr class="memdesc:a050e4ca3dcf0d65fba2d65b20e9730d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value iterator.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#a050e4ca3dcf0d65fba2d65b20e9730d9">More...</a><br /></td></tr>
<tr class="separator:a050e4ca3dcf0d65fba2d65b20e9730d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a643bf7e3b1413a950b3e66bd7244dacb"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSawyer_1_1Container_1_1Map_1_1NodeIterator.html">Map::NodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a></td></tr>
<tr class="memdesc:a643bf7e3b1413a950b3e66bd7244dacb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node iterator.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">More...</a><br /></td></tr>
<tr class="separator:a643bf7e3b1413a950b3e66bd7244dacb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad28df1a69755b5534a2ddb68bd447e61"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSawyer_1_1Container_1_1Map_1_1ConstNodeIterator.html">Map::ConstNodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a></td></tr>
<tr class="memdesc:ad28df1a69755b5534a2ddb68bd447e61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node iterator.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">More...</a><br /></td></tr>
<tr class="separator:ad28df1a69755b5534a2ddb68bd447e61"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0c5f60fb7032334c08cf77fa731aeb26"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a0c5f60fb7032334c08cf77fa731aeb26">IntervalMap</a> ()</td></tr>
<tr class="memdesc:a0c5f60fb7032334c08cf77fa731aeb26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#a0c5f60fb7032334c08cf77fa731aeb26">More...</a><br /></td></tr>
<tr class="separator:a0c5f60fb7032334c08cf77fa731aeb26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eec51514347acfef76b9b4a65654bcc"><td class="memTemplParams" colspan="2">template&lt;class Interval2 , class T2 , class Policy2 &gt; </td></tr>
<tr class="memitem:a5eec51514347acfef76b9b4a65654bcc"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a5eec51514347acfef76b9b4a65654bcc">IntervalMap</a> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; Interval2, T2, Policy2 &gt; &amp;other)</td></tr>
<tr class="memdesc:a5eec51514347acfef76b9b4a65654bcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#a5eec51514347acfef76b9b4a65654bcc">More...</a><br /></td></tr>
<tr class="separator:a5eec51514347acfef76b9b4a65654bcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86104e9747b2afce6b47d1fa30ffa5df"><td class="memTemplParams" colspan="2">template&lt;class Interval2 , class T2 , class Policy2 &gt; </td></tr>
<tr class="memitem:a86104e9747b2afce6b47d1fa30ffa5df"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a86104e9747b2afce6b47d1fa30ffa5df">operator=</a> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; Interval2, T2, Policy2 &gt; &amp;other)</td></tr>
<tr class="memdesc:a86104e9747b2afce6b47d1fa30ffa5df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#a86104e9747b2afce6b47d1fa30ffa5df">More...</a><br /></td></tr>
<tr class="separator:a86104e9747b2afce6b47d1fa30ffa5df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4ba034340ba48ff172b39cc80f3dc6e"><td class="memItemLeft" align="right" valign="top">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ae5130ce1b0e59f7bddd6b68f02da3b2e">ConstIntervalIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ae4ba034340ba48ff172b39cc80f3dc6e">intervals</a> () const</td></tr>
<tr class="memdesc:ae4ba034340ba48ff172b39cc80f3dc6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterators for traversing keys.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#ae4ba034340ba48ff172b39cc80f3dc6e">More...</a><br /></td></tr>
<tr class="separator:ae4ba034340ba48ff172b39cc80f3dc6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25feb127b25f2d5f7616003a010abdca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a25feb127b25f2d5f7616003a010abdca">firstUnmapped</a> (typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> minAddr) const</td></tr>
<tr class="memdesc:a25feb127b25f2d5f7616003a010abdca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first unmapped region.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#a25feb127b25f2d5f7616003a010abdca">More...</a><br /></td></tr>
<tr class="separator:a25feb127b25f2d5f7616003a010abdca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53ebe1dc48e4f3ef5051c97fb8d44c07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a53ebe1dc48e4f3ef5051c97fb8d44c07">lastUnmapped</a> (typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> maxAddr) const</td></tr>
<tr class="memdesc:a53ebe1dc48e4f3ef5051c97fb8d44c07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the last unmapped region.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#a53ebe1dc48e4f3ef5051c97fb8d44c07">More...</a><br /></td></tr>
<tr class="separator:a53ebe1dc48e4f3ef5051c97fb8d44c07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8da2cba60c620a2c9d4e60f57fe7a530"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a8da2cba60c620a2c9d4e60f57fe7a530">exists</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#adbf9f66a08580ead37de8f0dd96d575e">size</a>) const</td></tr>
<tr class="memdesc:a8da2cba60c620a2c9d4e60f57fe7a530"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if element exists.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#a8da2cba60c620a2c9d4e60f57fe7a530">More...</a><br /></td></tr>
<tr class="separator:a8da2cba60c620a2c9d4e60f57fe7a530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaad485b90e17980663b8ba6df88b3c5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a7c7ef387287aa01aa632dfeafc121e95">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#aaad485b90e17980663b8ba6df88b3c5c">getOptional</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;scalar) const</td></tr>
<tr class="memdesc:aaad485b90e17980663b8ba6df88b3c5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup and return a value or nothing.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#aaad485b90e17980663b8ba6df88b3c5c">More...</a><br /></td></tr>
<tr class="separator:aaad485b90e17980663b8ba6df88b3c5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20b99d95c8c627e166be33a780349195"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a7c7ef387287aa01aa632dfeafc121e95">Value</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a20b99d95c8c627e166be33a780349195">getOrDefault</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;scalar) const</td></tr>
<tr class="memdesc:a20b99d95c8c627e166be33a780349195"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup and return a value or a default.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#a20b99d95c8c627e166be33a780349195">More...</a><br /></td></tr>
<tr class="separator:a20b99d95c8c627e166be33a780349195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb61e91bac6aa82b6a5193726799bdf9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#acb61e91bac6aa82b6a5193726799bdf9">isEmpty</a> () const</td></tr>
<tr class="memdesc:acb61e91bac6aa82b6a5193726799bdf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the container is empty.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#acb61e91bac6aa82b6a5193726799bdf9">More...</a><br /></td></tr>
<tr class="separator:acb61e91bac6aa82b6a5193726799bdf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a017216edaa9c3064857c75fc63c07217"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a017216edaa9c3064857c75fc63c07217">nIntervals</a> () const</td></tr>
<tr class="memdesc:a017216edaa9c3064857c75fc63c07217"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of nodes in the container.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#a017216edaa9c3064857c75fc63c07217">More...</a><br /></td></tr>
<tr class="separator:a017216edaa9c3064857c75fc63c07217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbf9f66a08580ead37de8f0dd96d575e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#adbf9f66a08580ead37de8f0dd96d575e">size</a> () const</td></tr>
<tr class="memdesc:adbf9f66a08580ead37de8f0dd96d575e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of values represented by this container.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#adbf9f66a08580ead37de8f0dd96d575e">More...</a><br /></td></tr>
<tr class="separator:adbf9f66a08580ead37de8f0dd96d575e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e7d3909845b1efa5c5849f60faa3192"><td class="memItemLeft" align="right" valign="top"><a id="a6e7d3909845b1efa5c5849f60faa3192"></a>
<a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a6e7d3909845b1efa5c5849f60faa3192">least</a> () const</td></tr>
<tr class="memdesc:a6e7d3909845b1efa5c5849f60faa3192"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimum scalar key. <br /></td></tr>
<tr class="separator:a6e7d3909845b1efa5c5849f60faa3192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a385bbee53b2f1ba14ad34af9211f067d"><td class="memItemLeft" align="right" valign="top"><a id="a385bbee53b2f1ba14ad34af9211f067d"></a>
<a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a385bbee53b2f1ba14ad34af9211f067d">greatest</a> () const</td></tr>
<tr class="memdesc:a385bbee53b2f1ba14ad34af9211f067d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum scalar key. <br /></td></tr>
<tr class="separator:a385bbee53b2f1ba14ad34af9211f067d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e15275d860b2da7e0de9a57fd3bd795"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt; typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a1e15275d860b2da7e0de9a57fd3bd795">least</a> (typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> lowerLimit) const</td></tr>
<tr class="memdesc:a1e15275d860b2da7e0de9a57fd3bd795"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the limited-minimum scalar key.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#a1e15275d860b2da7e0de9a57fd3bd795">More...</a><br /></td></tr>
<tr class="separator:a1e15275d860b2da7e0de9a57fd3bd795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a7779da0f740c936fdb562087d91152"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt; typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a0a7779da0f740c936fdb562087d91152">greatest</a> (typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> upperLimit) const</td></tr>
<tr class="memdesc:a0a7779da0f740c936fdb562087d91152"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the limited-maximum scalar key.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#a0a7779da0f740c936fdb562087d91152">More...</a><br /></td></tr>
<tr class="separator:a0a7779da0f740c936fdb562087d91152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d679a902269aaa699bcf8a4999c17c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt; typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a0d679a902269aaa699bcf8a4999c17c3">leastUnmapped</a> (typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> lowerLimit) const</td></tr>
<tr class="memdesc:a0d679a902269aaa699bcf8a4999c17c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the limited-minimum unmapped scalar key.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#a0d679a902269aaa699bcf8a4999c17c3">More...</a><br /></td></tr>
<tr class="separator:a0d679a902269aaa699bcf8a4999c17c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7059f415687b5e7caec66dd7f4b133a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt; typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a7059f415687b5e7caec66dd7f4b133a2">greatestUnmapped</a> (typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> upperLimit) const</td></tr>
<tr class="memdesc:a7059f415687b5e7caec66dd7f4b133a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the limited-maximum unmapped scalar key.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#a7059f415687b5e7caec66dd7f4b133a2">More...</a><br /></td></tr>
<tr class="separator:a7059f415687b5e7caec66dd7f4b133a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4734abf74cda51aa6252ecfc38342e93"><td class="memItemLeft" align="right" valign="top"><a id="a4734abf74cda51aa6252ecfc38342e93"></a>
<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a4734abf74cda51aa6252ecfc38342e93">hull</a> () const</td></tr>
<tr class="memdesc:a4734abf74cda51aa6252ecfc38342e93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the range of values in this map. <br /></td></tr>
<tr class="separator:a4734abf74cda51aa6252ecfc38342e93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fd736a589e045f795c917a9d16c33d2"><td class="memItemLeft" align="right" valign="top"><a id="a2fd736a589e045f795c917a9d16c33d2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a2fd736a589e045f795c917a9d16c33d2">clear</a> ()</td></tr>
<tr class="memdesc:a2fd736a589e045f795c917a9d16c33d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empties the container. <br /></td></tr>
<tr class="separator:a2fd736a589e045f795c917a9d16c33d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a797f0a6bd63f8debdcd0ccb2fcecf0f3"><td class="memItemLeft" align="right" valign="top"><a id="a797f0a6bd63f8debdcd0ccb2fcecf0f3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a797f0a6bd63f8debdcd0ccb2fcecf0f3">erase</a> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a> &amp;erasure)</td></tr>
<tr class="memdesc:a797f0a6bd63f8debdcd0ccb2fcecf0f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase the specified interval. <br /></td></tr>
<tr class="separator:a797f0a6bd63f8debdcd0ccb2fcecf0f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e96516680b59244ef196a9e885ac0ca"><td class="memTemplParams" colspan="2">template&lt;typename T2 , class Policy2 &gt; </td></tr>
<tr class="memitem:a3e96516680b59244ef196a9e885ac0ca"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a3e96516680b59244ef196a9e885ac0ca">eraseMultiple</a> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, T2, Policy2 &gt; &amp;other)</td></tr>
<tr class="memdesc:a3e96516680b59244ef196a9e885ac0ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase intervals specified in another <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html" title="An associative container whose keys are non-overlapping intervals.">IntervalMap</a>.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#a3e96516680b59244ef196a9e885ac0ca">More...</a><br /></td></tr>
<tr class="separator:a3e96516680b59244ef196a9e885ac0ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1effdf10ccfb80ed11cc999e850ab2bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a1effdf10ccfb80ed11cc999e850ab2bd">insert</a> (<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a> key, <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a7c7ef387287aa01aa632dfeafc121e95">Value</a> value, bool makeHole=true)</td></tr>
<tr class="memdesc:a1effdf10ccfb80ed11cc999e850ab2bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a key/value pair.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#a1effdf10ccfb80ed11cc999e850ab2bd">More...</a><br /></td></tr>
<tr class="separator:a1effdf10ccfb80ed11cc999e850ab2bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af596a5898489cd4c86320bd5a1aa4307"><td class="memTemplParams" colspan="2">template&lt;typename T2 , class Policy2 &gt; </td></tr>
<tr class="memitem:af596a5898489cd4c86320bd5a1aa4307"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#af596a5898489cd4c86320bd5a1aa4307">insertMultiple</a> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, T2, Policy2 &gt; &amp;other, bool makeHole=true)</td></tr>
<tr class="memdesc:af596a5898489cd4c86320bd5a1aa4307"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert values from another container.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#af596a5898489cd4c86320bd5a1aa4307">More...</a><br /></td></tr>
<tr class="separator:af596a5898489cd4c86320bd5a1aa4307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11a77bbaa8abcabd5f21e3fafd19dafd"><td class="memItemLeft" align="right" valign="top"><a id="a11a77bbaa8abcabd5f21e3fafd19dafd"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isOverlapping</b> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a> &amp;interval) const</td></tr>
<tr class="separator:a11a77bbaa8abcabd5f21e3fafd19dafd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedc79f844559a4d50a71073d40f3c495"><td class="memTemplParams" colspan="2"><a id="aedc79f844559a4d50a71073d40f3c495"></a>
template&lt;typename T2 , class Policy2 &gt; </td></tr>
<tr class="memitem:aedc79f844559a4d50a71073d40f3c495"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>isOverlapping</b> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, T2, Policy2 &gt; &amp;other) const</td></tr>
<tr class="separator:aedc79f844559a4d50a71073d40f3c495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28ed971cc7c018a24e1bad32b6a3cd3d"><td class="memItemLeft" align="right" valign="top"><a id="a28ed971cc7c018a24e1bad32b6a3cd3d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isDistinct</b> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a> &amp;interval) const</td></tr>
<tr class="separator:a28ed971cc7c018a24e1bad32b6a3cd3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac040de688b66d2fd0f96e9e8da36ccb3"><td class="memTemplParams" colspan="2"><a id="ac040de688b66d2fd0f96e9e8da36ccb3"></a>
template&lt;typename T2 , class Policy2 &gt; </td></tr>
<tr class="memitem:ac040de688b66d2fd0f96e9e8da36ccb3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>isDistinct</b> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, T2, Policy2 &gt; &amp;other) const</td></tr>
<tr class="separator:ac040de688b66d2fd0f96e9e8da36ccb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a968496e5f3ddf732369084e3b9405fb6"><td class="memItemLeft" align="right" valign="top"><a id="a968496e5f3ddf732369084e3b9405fb6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>contains</b> (<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a> key) const</td></tr>
<tr class="separator:a968496e5f3ddf732369084e3b9405fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12776c478c6a1448865aa083fac5a2a4"><td class="memTemplParams" colspan="2"><a id="a12776c478c6a1448865aa083fac5a2a4"></a>
template&lt;typename T2 , class Policy2 &gt; </td></tr>
<tr class="memitem:a12776c478c6a1448865aa083fac5a2a4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>contains</b> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, T2, Policy2 &gt; &amp;other) const</td></tr>
<tr class="separator:a12776c478c6a1448865aa083fac5a2a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a4bcd6255a35955db90ec2d0f939086e2"><td class="memItemLeft" align="right" valign="top">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a4bcd6255a35955db90ec2d0f939086e2">nodes</a> ()</td></tr>
<tr class="memdesc:a4bcd6255a35955db90ec2d0f939086e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterators for traversing nodes.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#a4bcd6255a35955db90ec2d0f939086e2">More...</a><br /></td></tr>
<tr class="separator:a4bcd6255a35955db90ec2d0f939086e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d22ef3d4fc38b0ac068481e01211cb8"><td class="memItemLeft" align="right" valign="top">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a3d22ef3d4fc38b0ac068481e01211cb8">nodes</a> () const</td></tr>
<tr class="memdesc:a3d22ef3d4fc38b0ac068481e01211cb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterators for traversing nodes.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#a3d22ef3d4fc38b0ac068481e01211cb8">More...</a><br /></td></tr>
<tr class="separator:a3d22ef3d4fc38b0ac068481e01211cb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:afe92a3a1fed8440a506b3cde7891a665"><td class="memItemLeft" align="right" valign="top">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ae50e191b16e240244fb48af0232e88ac">ValueIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#afe92a3a1fed8440a506b3cde7891a665">values</a> ()</td></tr>
<tr class="memdesc:afe92a3a1fed8440a506b3cde7891a665"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterators for traversing values.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#afe92a3a1fed8440a506b3cde7891a665">More...</a><br /></td></tr>
<tr class="separator:afe92a3a1fed8440a506b3cde7891a665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabafbf1a1a5177d6b21006309e73c1c2"><td class="memItemLeft" align="right" valign="top">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a050e4ca3dcf0d65fba2d65b20e9730d9">ConstValueIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#aabafbf1a1a5177d6b21006309e73c1c2">values</a> () const</td></tr>
<tr class="memdesc:aabafbf1a1a5177d6b21006309e73c1c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterators for traversing values.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#aabafbf1a1a5177d6b21006309e73c1c2">More...</a><br /></td></tr>
<tr class="separator:aabafbf1a1a5177d6b21006309e73c1c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a87170e7d06eb8710211a65fb9bc052c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a87170e7d06eb8710211a65fb9bc052c6">lowerBound</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;scalar)</td></tr>
<tr class="memdesc:a87170e7d06eb8710211a65fb9bc052c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first node whose interval ends at or above the specified scalar key.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#a87170e7d06eb8710211a65fb9bc052c6">More...</a><br /></td></tr>
<tr class="separator:a87170e7d06eb8710211a65fb9bc052c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cdf5d3be3c2b27013876e65f69acd5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a4cdf5d3be3c2b27013876e65f69acd5d">lowerBound</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;scalar) const</td></tr>
<tr class="memdesc:a4cdf5d3be3c2b27013876e65f69acd5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first node whose interval ends at or above the specified scalar key.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#a4cdf5d3be3c2b27013876e65f69acd5d">More...</a><br /></td></tr>
<tr class="separator:a4cdf5d3be3c2b27013876e65f69acd5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a56a00171503e761f08e789d07692187e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a56a00171503e761f08e789d07692187e">upperBound</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;scalar)</td></tr>
<tr class="memdesc:a56a00171503e761f08e789d07692187e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first node whose interval begins above the specified scalar key.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#a56a00171503e761f08e789d07692187e">More...</a><br /></td></tr>
<tr class="separator:a56a00171503e761f08e789d07692187e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f52b31510a0edd7a3a6b99848d66df7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a1f52b31510a0edd7a3a6b99848d66df7">upperBound</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;scalar) const</td></tr>
<tr class="memdesc:a1f52b31510a0edd7a3a6b99848d66df7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first node whose interval begins above the specified scalar key.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#a1f52b31510a0edd7a3a6b99848d66df7">More...</a><br /></td></tr>
<tr class="separator:a1f52b31510a0edd7a3a6b99848d66df7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ae26fe590db1a0db229019c39ce9a63c4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a7c7ef387287aa01aa632dfeafc121e95">Value</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ae26fe590db1a0db229019c39ce9a63c4">operator[]</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;scalar) const</td></tr>
<tr class="memdesc:ae26fe590db1a0db229019c39ce9a63c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to an existing value.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#ae26fe590db1a0db229019c39ce9a63c4">More...</a><br /></td></tr>
<tr class="separator:ae26fe590db1a0db229019c39ce9a63c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a698c1549cbf43028b6cb07721d449405"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a7c7ef387287aa01aa632dfeafc121e95">Value</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a698c1549cbf43028b6cb07721d449405">get</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;scalar) const</td></tr>
<tr class="memdesc:a698c1549cbf43028b6cb07721d449405"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to an existing value.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#a698c1549cbf43028b6cb07721d449405">More...</a><br /></td></tr>
<tr class="separator:a698c1549cbf43028b6cb07721d449405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a9784567bd34e5bba82aaab13e0fd5934"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a7c7ef387287aa01aa632dfeafc121e95">Value</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a9784567bd34e5bba82aaab13e0fd5934">getOrElse</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;scalar, <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a7c7ef387287aa01aa632dfeafc121e95">Value</a> &amp;dflt)</td></tr>
<tr class="memdesc:a9784567bd34e5bba82aaab13e0fd5934"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup and return a value or something else.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#a9784567bd34e5bba82aaab13e0fd5934">More...</a><br /></td></tr>
<tr class="separator:a9784567bd34e5bba82aaab13e0fd5934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa3f2968268e558b2f5c3088b419103e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a7c7ef387287aa01aa632dfeafc121e95">Value</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#aaa3f2968268e558b2f5c3088b419103e">getOrElse</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;scalar, const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a7c7ef387287aa01aa632dfeafc121e95">Value</a> &amp;dflt) const</td></tr>
<tr class="memdesc:aaa3f2968268e558b2f5c3088b419103e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup and return a value or something else.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#aaa3f2968268e558b2f5c3088b419103e">More...</a><br /></td></tr>
<tr class="separator:aaa3f2968268e558b2f5c3088b419103e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad53242671f18d795f3b040bdd0d7e49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#aad53242671f18d795f3b040bdd0d7e49">findPrior</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;scalar)</td></tr>
<tr class="memdesc:aad53242671f18d795f3b040bdd0d7e49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the last node whose interval starts at or below the specified scalar key.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#aad53242671f18d795f3b040bdd0d7e49">More...</a><br /></td></tr>
<tr class="separator:aad53242671f18d795f3b040bdd0d7e49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab59f19099179c53ab74984bf74855aaa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ab59f19099179c53ab74984bf74855aaa">findPrior</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;scalar) const</td></tr>
<tr class="memdesc:ab59f19099179c53ab74984bf74855aaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the last node whose interval starts at or below the specified scalar key.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#ab59f19099179c53ab74984bf74855aaa">More...</a><br /></td></tr>
<tr class="separator:ab59f19099179c53ab74984bf74855aaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a328f4caeb3ed341e6f7fd6530a14d70a"><td class="memTemplParams" colspan="2">template&lt;class IMap &gt; </td></tr>
<tr class="memitem:a328f4caeb3ed341e6f7fd6530a14d70a"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="structSawyer_1_1Container_1_1IntervalMapTraits.html">IntervalMapTraits</a>&lt; IMap &gt;::<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a328f4caeb3ed341e6f7fd6530a14d70a">findPriorImpl</a> (IMap &amp;imap, const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;scalar)</td></tr>
<tr class="memdesc:a328f4caeb3ed341e6f7fd6530a14d70a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the last node whose interval starts at or below the specified scalar key.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#a328f4caeb3ed341e6f7fd6530a14d70a">More...</a><br /></td></tr>
<tr class="separator:a328f4caeb3ed341e6f7fd6530a14d70a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d4a318aba4a2a8af2a6a6e3570279a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a9d4a318aba4a2a8af2a6a6e3570279a8">find</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;scalar)</td></tr>
<tr class="memdesc:a9d4a318aba4a2a8af2a6a6e3570279a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the node containing the specified scalar key.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#a9d4a318aba4a2a8af2a6a6e3570279a8">More...</a><br /></td></tr>
<tr class="separator:a9d4a318aba4a2a8af2a6a6e3570279a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6675861f9feb70004fe397d1600d466f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a6675861f9feb70004fe397d1600d466f">find</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;scalar) const</td></tr>
<tr class="memdesc:a6675861f9feb70004fe397d1600d466f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the node containing the specified scalar key.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#a6675861f9feb70004fe397d1600d466f">More...</a><br /></td></tr>
<tr class="separator:a6675861f9feb70004fe397d1600d466f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca75670b38521c5be0453d2c7d5221e6"><td class="memTemplParams" colspan="2">template&lt;class IMap &gt; </td></tr>
<tr class="memitem:aca75670b38521c5be0453d2c7d5221e6"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="structSawyer_1_1Container_1_1IntervalMapTraits.html">IntervalMapTraits</a>&lt; IMap &gt;::<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#aca75670b38521c5be0453d2c7d5221e6">findImpl</a> (IMap &amp;imap, const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;scalar)</td></tr>
<tr class="memdesc:aca75670b38521c5be0453d2c7d5221e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the node containing the specified scalar key.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#aca75670b38521c5be0453d2c7d5221e6">More...</a><br /></td></tr>
<tr class="separator:aca75670b38521c5be0453d2c7d5221e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd6f088274649e06edc5911fa74c3379"><td class="memItemLeft" align="right" valign="top">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#acd6f088274649e06edc5911fa74c3379">findAll</a> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a> &amp;interval)</td></tr>
<tr class="memdesc:acd6f088274649e06edc5911fa74c3379"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds all nodes overlapping the specified interval.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#acd6f088274649e06edc5911fa74c3379">More...</a><br /></td></tr>
<tr class="separator:acd6f088274649e06edc5911fa74c3379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbc578d55f2c30733f592cf534535d83"><td class="memItemLeft" align="right" valign="top">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#abbc578d55f2c30733f592cf534535d83">findAll</a> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a> &amp;interval) const</td></tr>
<tr class="memdesc:abbc578d55f2c30733f592cf534535d83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds all nodes overlapping the specified interval.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#abbc578d55f2c30733f592cf534535d83">More...</a><br /></td></tr>
<tr class="separator:abbc578d55f2c30733f592cf534535d83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7316ec22a4b76bad014ab7f4b0b5146"><td class="memTemplParams" colspan="2">template&lt;class IMap &gt; </td></tr>
<tr class="memitem:ac7316ec22a4b76bad014ab7f4b0b5146"><td class="memTemplItemLeft" align="right" valign="top">static boost::iterator_range&lt; typename <a class="el" href="structSawyer_1_1Container_1_1IntervalMapTraits.html">IntervalMapTraits</a>&lt; IMap &gt;::<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ac7316ec22a4b76bad014ab7f4b0b5146">findAllImpl</a> (IMap &amp;imap, const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a> &amp;interval)</td></tr>
<tr class="memdesc:ac7316ec22a4b76bad014ab7f4b0b5146"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds all nodes overlapping the specified interval.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#ac7316ec22a4b76bad014ab7f4b0b5146">More...</a><br /></td></tr>
<tr class="separator:ac7316ec22a4b76bad014ab7f4b0b5146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5a821909b63dedab54193fbd4a747c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ab5a821909b63dedab54193fbd4a747c5">findFirstOverlap</a> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a> &amp;interval)</td></tr>
<tr class="memdesc:ab5a821909b63dedab54193fbd4a747c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find first interval that overlaps with the specified interval.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#ab5a821909b63dedab54193fbd4a747c5">More...</a><br /></td></tr>
<tr class="separator:ab5a821909b63dedab54193fbd4a747c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48ef3aaccd8a7cb97c33359be83ca883"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a48ef3aaccd8a7cb97c33359be83ca883">findFirstOverlap</a> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a> &amp;interval) const</td></tr>
<tr class="memdesc:a48ef3aaccd8a7cb97c33359be83ca883"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find first interval that overlaps with the specified interval.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#a48ef3aaccd8a7cb97c33359be83ca883">More...</a><br /></td></tr>
<tr class="separator:a48ef3aaccd8a7cb97c33359be83ca883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6137a2a3d9544e3ed550d409ec36a25"><td class="memTemplParams" colspan="2">template&lt;class IMap &gt; </td></tr>
<tr class="memitem:ac6137a2a3d9544e3ed550d409ec36a25"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="structSawyer_1_1Container_1_1IntervalMapTraits.html">IntervalMapTraits</a>&lt; IMap &gt;::<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ac6137a2a3d9544e3ed550d409ec36a25">findFirstOverlapImpl</a> (IMap &amp;imap, const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a> &amp;interval)</td></tr>
<tr class="memdesc:ac6137a2a3d9544e3ed550d409ec36a25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find first interval that overlaps with the specified interval.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#ac6137a2a3d9544e3ed550d409ec36a25">More...</a><br /></td></tr>
<tr class="separator:ac6137a2a3d9544e3ed550d409ec36a25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a8408ce80dfcf266dc6c8443cdf01bc"><td class="memTemplParams" colspan="2">template&lt;typename T2 , class Policy2 &gt; </td></tr>
<tr class="memitem:a2a8408ce80dfcf266dc6c8443cdf01bc"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a>, typename <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, T2, Policy2 &gt;::<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a2a8408ce80dfcf266dc6c8443cdf01bc">findFirstOverlap</a> (typename <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">IntervalMap::NodeIterator</a> thisIter, const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, T2, Policy2 &gt; &amp;other, typename <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, T2, Policy2 &gt;::<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a> otherIter)</td></tr>
<tr class="memdesc:a2a8408ce80dfcf266dc6c8443cdf01bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find first interval that overlaps with any in another container.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#a2a8408ce80dfcf266dc6c8443cdf01bc">More...</a><br /></td></tr>
<tr class="separator:a2a8408ce80dfcf266dc6c8443cdf01bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a191694b0521c2f5e1eabcdc948dd5d67"><td class="memTemplParams" colspan="2">template&lt;typename T2 , class Policy2 &gt; </td></tr>
<tr class="memitem:a191694b0521c2f5e1eabcdc948dd5d67"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a>, typename <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, T2, Policy2 &gt;::<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a191694b0521c2f5e1eabcdc948dd5d67">findFirstOverlap</a> (typename <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">IntervalMap::ConstNodeIterator</a> thisIter, const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, T2, Policy2 &gt; &amp;other, typename <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, T2, Policy2 &gt;::<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a> otherIter) const</td></tr>
<tr class="memdesc:a191694b0521c2f5e1eabcdc948dd5d67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find first interval that overlaps with any in another container.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#a191694b0521c2f5e1eabcdc948dd5d67">More...</a><br /></td></tr>
<tr class="separator:a191694b0521c2f5e1eabcdc948dd5d67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f0c498977ab94415ab40fe46e717d2f"><td class="memTemplParams" colspan="2">template&lt;class IMap , typename T2 , class Policy2 &gt; </td></tr>
<tr class="memitem:a2f0c498977ab94415ab40fe46e717d2f"><td class="memTemplItemLeft" align="right" valign="top">static std::pair&lt; typename <a class="el" href="structSawyer_1_1Container_1_1IntervalMapTraits.html">IntervalMapTraits</a>&lt; IMap &gt;::<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a>, typename <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, T2, Policy2 &gt;::<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a2f0c498977ab94415ab40fe46e717d2f">findFirstOverlapImpl</a> (IMap &amp;imap, typename <a class="el" href="structSawyer_1_1Container_1_1IntervalMapTraits.html">IntervalMapTraits</a>&lt; IMap &gt;::<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a> thisIter, const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, T2, Policy2 &gt; &amp;other, typename <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, T2, Policy2 &gt;::<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a> otherIter)</td></tr>
<tr class="memdesc:a2f0c498977ab94415ab40fe46e717d2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find first interval that overlaps with any in another container.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#a2f0c498977ab94415ab40fe46e717d2f">More...</a><br /></td></tr>
<tr class="separator:a2f0c498977ab94415ab40fe46e717d2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f05fe11220a1d2c1e75e2fcde5a573d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a6f05fe11220a1d2c1e75e2fcde5a573d">firstFit</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#adbf9f66a08580ead37de8f0dd96d575e">size</a>, <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a> start)</td></tr>
<tr class="memdesc:a6f05fe11220a1d2c1e75e2fcde5a573d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first fit node at or after a starting point.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#a6f05fe11220a1d2c1e75e2fcde5a573d">More...</a><br /></td></tr>
<tr class="separator:a6f05fe11220a1d2c1e75e2fcde5a573d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3710d6445b86359fc16236d2bb54a8a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a3710d6445b86359fc16236d2bb54a8a1">firstFit</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#adbf9f66a08580ead37de8f0dd96d575e">size</a>, <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a> start) const</td></tr>
<tr class="memdesc:a3710d6445b86359fc16236d2bb54a8a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first fit node at or after a starting point.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#a3710d6445b86359fc16236d2bb54a8a1">More...</a><br /></td></tr>
<tr class="separator:a3710d6445b86359fc16236d2bb54a8a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab0a866bb43163a34bd4ea8924117ae3"><td class="memTemplParams" colspan="2">template&lt;class IMap &gt; </td></tr>
<tr class="memitem:aab0a866bb43163a34bd4ea8924117ae3"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="structSawyer_1_1Container_1_1IntervalMapTraits.html">IntervalMapTraits</a>&lt; IMap &gt;::<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#aab0a866bb43163a34bd4ea8924117ae3">firstFitImpl</a> (IMap &amp;imap, const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#adbf9f66a08580ead37de8f0dd96d575e">size</a>, typename <a class="el" href="structSawyer_1_1Container_1_1IntervalMapTraits.html">IntervalMapTraits</a>&lt; IMap &gt;::<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a> start)</td></tr>
<tr class="memdesc:aab0a866bb43163a34bd4ea8924117ae3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first fit node at or after a starting point.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#aab0a866bb43163a34bd4ea8924117ae3">More...</a><br /></td></tr>
<tr class="separator:aab0a866bb43163a34bd4ea8924117ae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa299225e9e0576bc9944dde4b29d569"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#afa299225e9e0576bc9944dde4b29d569">bestFit</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#adbf9f66a08580ead37de8f0dd96d575e">size</a>, <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a> start)</td></tr>
<tr class="memdesc:afa299225e9e0576bc9944dde4b29d569"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the best fit node at or after a starting point.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#afa299225e9e0576bc9944dde4b29d569">More...</a><br /></td></tr>
<tr class="separator:afa299225e9e0576bc9944dde4b29d569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a747ae7350949b0c59e9d40db1c62286f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a747ae7350949b0c59e9d40db1c62286f">bestFit</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#adbf9f66a08580ead37de8f0dd96d575e">size</a>, <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a> start) const</td></tr>
<tr class="memdesc:a747ae7350949b0c59e9d40db1c62286f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the best fit node at or after a starting point.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#a747ae7350949b0c59e9d40db1c62286f">More...</a><br /></td></tr>
<tr class="separator:a747ae7350949b0c59e9d40db1c62286f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6279404d9a97574a538b3d6a18c7001d"><td class="memTemplParams" colspan="2">template&lt;class IMap &gt; </td></tr>
<tr class="memitem:a6279404d9a97574a538b3d6a18c7001d"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="structSawyer_1_1Container_1_1IntervalMapTraits.html">IntervalMapTraits</a>&lt; IMap &gt;::<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a6279404d9a97574a538b3d6a18c7001d">bestFitImpl</a> (IMap &amp;imap, const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#adbf9f66a08580ead37de8f0dd96d575e">size</a>, typename <a class="el" href="structSawyer_1_1Container_1_1IntervalMapTraits.html">IntervalMapTraits</a>&lt; IMap &gt;::<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a> start)</td></tr>
<tr class="memdesc:a6279404d9a97574a538b3d6a18c7001d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the best fit node at or after a starting point.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#a6279404d9a97574a538b3d6a18c7001d">More...</a><br /></td></tr>
<tr class="separator:a6279404d9a97574a538b3d6a18c7001d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ad3da8180167b02f750f8138e21fea1b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3da8180167b02f750f8138e21fea1b8">&#9670;&nbsp;</a></span>Node</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename T , class Policy  = MergePolicy&lt;I, T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSawyer_1_1Container_1_1Map_1_1Node.html">Map::Node</a> <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">Sawyer::Container::IntervalMap</a>&lt; I, T, Policy &gt;::<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad3da8180167b02f750f8138e21fea1b8">Node</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Storage node. </p>
<p>An interval/value pair with methods <code>key</code> and <code>value</code> for accessing the interval key and its associated user-defined value. </p>

<p class="definition">Definition at line <a class="el" href="IntervalMap_8h_source.html#l00196">196</a> of file <a class="el" href="IntervalMap_8h_source.html">IntervalMap.h</a>.</p>

</div>
</div>
<a id="ae5130ce1b0e59f7bddd6b68f02da3b2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5130ce1b0e59f7bddd6b68f02da3b2e">&#9670;&nbsp;</a></span>ConstIntervalIterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename T , class Policy  = MergePolicy&lt;I, T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSawyer_1_1Container_1_1Map_1_1ConstKeyIterator.html">Map::ConstKeyIterator</a> <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">Sawyer::Container::IntervalMap</a>&lt; I, T, Policy &gt;::<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ae5130ce1b0e59f7bddd6b68f02da3b2e">ConstIntervalIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classSawyer_1_1Container_1_1Interval.html" title="Range of values delimited by endpoints.">Interval</a> iterator. </p>
<p>This iterator visits the intervals of the container. Dereferencing the iterator returns a reference to a const interval. </p>

<p class="definition">Definition at line <a class="el" href="IntervalMap_8h_source.html#l00202">202</a> of file <a class="el" href="IntervalMap_8h_source.html">IntervalMap.h</a>.</p>

</div>
</div>
<a id="ae50e191b16e240244fb48af0232e88ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae50e191b16e240244fb48af0232e88ac">&#9670;&nbsp;</a></span>ValueIterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename T , class Policy  = MergePolicy&lt;I, T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSawyer_1_1Container_1_1Map_1_1ValueIterator.html">Map::ValueIterator</a> <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">Sawyer::Container::IntervalMap</a>&lt; I, T, Policy &gt;::<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ae50e191b16e240244fb48af0232e88ac">ValueIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Value iterator. </p>
<p>This iterator visits the values of the container. Dereferencing the iterator returns a reference (const or mutable, depending on the iterator) to a user-defined value. </p>

<p class="definition">Definition at line <a class="el" href="IntervalMap_8h_source.html#l00210">210</a> of file <a class="el" href="IntervalMap_8h_source.html">IntervalMap.h</a>.</p>

</div>
</div>
<a id="a050e4ca3dcf0d65fba2d65b20e9730d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a050e4ca3dcf0d65fba2d65b20e9730d9">&#9670;&nbsp;</a></span>ConstValueIterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename T , class Policy  = MergePolicy&lt;I, T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSawyer_1_1Container_1_1Map_1_1ConstValueIterator.html">Map::ConstValueIterator</a> <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">Sawyer::Container::IntervalMap</a>&lt; I, T, Policy &gt;::<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a050e4ca3dcf0d65fba2d65b20e9730d9">ConstValueIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Value iterator. </p>
<p>This iterator visits the values of the container. Dereferencing the iterator returns a reference (const or mutable, depending on the iterator) to a user-defined value. </p>

<p class="definition">Definition at line <a class="el" href="IntervalMap_8h_source.html#l00211">211</a> of file <a class="el" href="IntervalMap_8h_source.html">IntervalMap.h</a>.</p>

</div>
</div>
<a id="a643bf7e3b1413a950b3e66bd7244dacb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a643bf7e3b1413a950b3e66bd7244dacb">&#9670;&nbsp;</a></span>NodeIterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename T , class Policy  = MergePolicy&lt;I, T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSawyer_1_1Container_1_1Map_1_1NodeIterator.html">Map::NodeIterator</a> <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">Sawyer::Container::IntervalMap</a>&lt; I, T, Policy &gt;::<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Node iterator. </p>
<p>This iterator visits the nodes of the container. Dereferencing the iterator returns a <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad3da8180167b02f750f8138e21fea1b8">Node</a> reference (const or mutable depending on the iterator), from which the interval key and user-define value can be obtained. </p>

<p class="definition">Definition at line <a class="el" href="IntervalMap_8h_source.html#l00220">220</a> of file <a class="el" href="IntervalMap_8h_source.html">IntervalMap.h</a>.</p>

</div>
</div>
<a id="ad28df1a69755b5534a2ddb68bd447e61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad28df1a69755b5534a2ddb68bd447e61">&#9670;&nbsp;</a></span>ConstNodeIterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename T , class Policy  = MergePolicy&lt;I, T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSawyer_1_1Container_1_1Map_1_1ConstNodeIterator.html">Map::ConstNodeIterator</a> <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">Sawyer::Container::IntervalMap</a>&lt; I, T, Policy &gt;::<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Node iterator. </p>
<p>This iterator visits the nodes of the container. Dereferencing the iterator returns a <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad3da8180167b02f750f8138e21fea1b8">Node</a> reference (const or mutable depending on the iterator), from which the interval key and user-define value can be obtained. </p>

<p class="definition">Definition at line <a class="el" href="IntervalMap_8h_source.html#l00221">221</a> of file <a class="el" href="IntervalMap_8h_source.html">IntervalMap.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a0c5f60fb7032334c08cf77fa731aeb26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c5f60fb7032334c08cf77fa731aeb26">&#9670;&nbsp;</a></span>IntervalMap() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename T , class Policy  = MergePolicy&lt;I, T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">Sawyer::Container::IntervalMap</a>&lt; I, T, Policy &gt;::<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>Creates an empty container. </p>

<p class="definition">Definition at line <a class="el" href="IntervalMap_8h_source.html#l00246">246</a> of file <a class="el" href="IntervalMap_8h_source.html">IntervalMap.h</a>.</p>

</div>
</div>
<a id="a5eec51514347acfef76b9b4a65654bcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eec51514347acfef76b9b4a65654bcc">&#9670;&nbsp;</a></span>IntervalMap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename T , class Policy  = MergePolicy&lt;I, T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Interval2 , class T2 , class Policy2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">Sawyer::Container::IntervalMap</a>&lt; I, T, Policy &gt;::<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; Interval2, T2, Policy2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p>Initialize this container by copying all nodes from the <code>other</code> container. This constructor has <em>O(n)</em> complexity, where <em>n</em> is the number of nodes in the container. </p>

<p class="definition">Definition at line <a class="el" href="IntervalMap_8h_source.html#l00253">253</a> of file <a class="el" href="IntervalMap_8h_source.html">IntervalMap.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a86104e9747b2afce6b47d1fa30ffa5df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86104e9747b2afce6b47d1fa30ffa5df">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename T , class Policy  = MergePolicy&lt;I, T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Interval2 , class T2 , class Policy2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&amp; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">Sawyer::Container::IntervalMap</a>&lt; I, T, Policy &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; Interval2, T2, Policy2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator. </p>
<p>Makes this container look like the <code>other</code> container by clearing this container and then copying all nodes from the other container. </p>

<p class="definition">Definition at line <a class="el" href="IntervalMap_8h_source.html#l00264">264</a> of file <a class="el" href="IntervalMap_8h_source.html">IntervalMap.h</a>.</p>

</div>
</div>
<a id="a4bcd6255a35955db90ec2d0f939086e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bcd6255a35955db90ec2d0f939086e2">&#9670;&nbsp;</a></span>nodes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename T , class Policy  = MergePolicy&lt;I, T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::iterator_range&lt;<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a>&gt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">Sawyer::Container::IntervalMap</a>&lt; I, T, Policy &gt;::nodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterators for traversing nodes. </p>
<p>Returns a range of iterators that traverse storage nodes (key/value pairs) for all nodes of this container. The nodes are traversed in key order. </p>

<p class="definition">Definition at line <a class="el" href="IntervalMap_8h_source.html#l00283">283</a> of file <a class="el" href="IntervalMap_8h_source.html">IntervalMap.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="IntervalMap_8h_source.html#l00770">Sawyer::Container::IntervalMap&lt; Interval, int &gt;::erase()</a>, <a class="el" href="IntervalMap_8h_source.html#l00827">Sawyer::Container::IntervalMap&lt; Interval, int &gt;::eraseMultiple()</a>, <a class="el" href="IntervalMap_8h_source.html#l00579">Sawyer::Container::IntervalMap&lt; Interval, int &gt;::exists()</a>, <a class="el" href="IntervalMap_8h_source.html#l00458">Sawyer::Container::IntervalMap&lt; Interval, int &gt;::findFirstOverlapImpl()</a>, <a class="el" href="IntervalMap_8h_source.html#l00546">Sawyer::Container::IntervalMap&lt; Interval, int &gt;::firstUnmapped()</a>, <a class="el" href="IntervalMap_8h_source.html#l00604">Sawyer::Container::IntervalMap&lt; Interval, int &gt;::get()</a>, <a class="el" href="IntervalMap_8h_source.html#l00625">Sawyer::Container::IntervalMap&lt; Interval, int &gt;::getOptional()</a>, <a class="el" href="IntervalMap_8h_source.html#l00651">Sawyer::Container::IntervalMap&lt; Interval, int &gt;::getOrDefault()</a>, <a class="el" href="IntervalMap_8h_source.html#l00637">Sawyer::Container::IntervalMap&lt; Interval, int &gt;::getOrElse()</a>, <a class="el" href="IntervalMap_8h_source.html#l00713">Sawyer::Container::IntervalMap&lt; Interval, int &gt;::greatest()</a>, <a class="el" href="IntervalMap_8h_source.html#l00739">Sawyer::Container::IntervalMap&lt; Interval, int &gt;::greatestUnmapped()</a>, <a class="el" href="IntervalMap_8h_source.html#l00838">Sawyer::Container::IntervalMap&lt; Interval, int &gt;::insert()</a>, <a class="el" href="IntervalMap_8h_source.html#l00883">Sawyer::Container::IntervalMap&lt; Interval, int &gt;::insertMultiple()</a>, <a class="el" href="IntervalMap_8h_source.html#l00253">Sawyer::Container::IntervalMap&lt; Interval, int &gt;::IntervalMap()</a>, <a class="el" href="IntervalSet_8h_source.html#l00225">Sawyer::Container::IntervalSet&lt; Interval &gt;::intervals()</a>, <a class="el" href="IntervalSet_8h_source.html#l00164">Sawyer::Container::IntervalSet&lt; Interval &gt;::IntervalSet()</a>, <a class="el" href="IntervalMap_8h_source.html#l00564">Sawyer::Container::IntervalMap&lt; Interval, int &gt;::lastUnmapped()</a>, <a class="el" href="IntervalMap_8h_source.html#l00702">Sawyer::Container::IntervalMap&lt; Interval, int &gt;::least()</a>, <a class="el" href="IntervalMap_8h_source.html#l00724">Sawyer::Container::IntervalMap&lt; Interval, int &gt;::leastUnmapped()</a>, <a class="el" href="AddressMap_8h_source.html#l01394">Sawyer::Container::AddressMap&lt; A, T &gt;::nodes()</a>, <a class="el" href="IntervalSet_8h_source.html#l00200">Sawyer::Container::IntervalSet&lt; Interval &gt;::operator=()</a>, <a class="el" href="IntervalMap_8h_source.html#l00264">Sawyer::Container::IntervalMap&lt; Interval, int &gt;::operator=()</a>, and <a class="el" href="IntervalMap_8h_source.html#l00597">Sawyer::Container::IntervalMap&lt; Interval, int &gt;::operator[]()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1IntervalMap_a4bcd6255a35955db90ec2d0f939086e2_icgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1IntervalMap_a4bcd6255a35955db90ec2d0f939086e2_icgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1IntervalMap_a4bcd6255a35955db90ec2d0f939086e2_icgraph" id="classSawyer_1_1Container_1_1IntervalMap_a4bcd6255a35955db90ec2d0f939086e2_icgraph">
<area shape="rect" title="Iterators for traversing nodes." alt="" coords="231,893,369,934"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalMap.html#a797f0a6bd63f8debdcd0ccb2fcecf0f3" title="Erase the specified interval." alt="" coords="19,5,169,61"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalMap.html#a3e96516680b59244ef196a9e885ac0ca" title="Erase intervals specified in another IntervalMap." alt="" coords="19,85,169,141"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalMap.html#a8da2cba60c620a2c9d4e60f57fe7a530" title="Returns true if element exists." alt="" coords="19,165,169,221"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalMap.html#a2f0c498977ab94415ab40fe46e717d2f" title=" " alt="" coords="5,245,183,301"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalMap.html#a25feb127b25f2d5f7616003a010abdca" title="Find the first unmapped region." alt="" coords="19,325,169,381"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalMap.html#a698c1549cbf43028b6cb07721d449405" title=" " alt="" coords="19,405,169,461"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalMap.html#aaad485b90e17980663b8ba6df88b3c5c" title="Lookup and return a value or nothing." alt="" coords="19,485,169,541"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalMap.html#a20b99d95c8c627e166be33a780349195" title="Lookup and return a value or a default." alt="" coords="19,565,169,621"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalMap.html#a9784567bd34e5bba82aaab13e0fd5934" title="Lookup and return a value or something else." alt="" coords="19,645,169,701"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalMap.html#a0a7779da0f740c936fdb562087d91152" title="Returns the limited&#45;maximum scalar key." alt="" coords="19,725,169,781"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalMap.html#a7059f415687b5e7caec66dd7f4b133a2" title="Returns the limited&#45;maximum unmapped scalar key." alt="" coords="9,805,179,861"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalMap.html#a1effdf10ccfb80ed11cc999e850ab2bd" title="Insert a key/value pair." alt="" coords="19,885,169,941"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalMap.html#af596a5898489cd4c86320bd5a1aa4307" title="Insert values from another container." alt="" coords="19,965,169,1021"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalMap.html#a5eec51514347acfef76b9b4a65654bcc" title="Copy constructor." alt="" coords="19,1045,169,1101"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalSet.html#a0e226046a0d838309882964ee0fe315c" title="Iterator range for all intervals actually stored by this set." alt="" coords="24,1125,164,1181"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalSet.html#afdbeaa4024429a9bde6e2d1d58324d0a" title="Construct from an IntervalMap." alt="" coords="24,1205,164,1261"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalMap.html#a53ebe1dc48e4f3ef5051c97fb8d44c07" title="Find the last unmapped region." alt="" coords="19,1285,169,1341"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalMap.html#a1e15275d860b2da7e0de9a57fd3bd795" title="Returns the limited&#45;minimum scalar key." alt="" coords="19,1365,169,1421"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalMap.html#a0d679a902269aaa699bcf8a4999c17c3" title="Returns the limited&#45;minimum unmapped scalar key." alt="" coords="19,1445,169,1501"/>
<area shape="rect" href="classSawyer_1_1Container_1_1AddressMap.html#a000ced173d57eb4990dea1b45f0339e0" title="Iterator range for nodes." alt="" coords="25,1526,163,1567"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalSet.html#ae9a475b394cde16402d7f7328a656764" title="Assignment from an IntervalMap." alt="" coords="24,1592,164,1648"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalMap.html#a86104e9747b2afce6b47d1fa30ffa5df" title="Assignment operator." alt="" coords="19,1672,169,1728"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalMap.html#ae26fe590db1a0db229019c39ce9a63c4" title="Returns a reference to an existing value." alt="" coords="19,1752,169,1808"/>
</map>
</div>

</div>
</div>
<a id="a3d22ef3d4fc38b0ac068481e01211cb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d22ef3d4fc38b0ac068481e01211cb8">&#9670;&nbsp;</a></span>nodes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename T , class Policy  = MergePolicy&lt;I, T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::iterator_range&lt;<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a>&gt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">Sawyer::Container::IntervalMap</a>&lt; I, T, Policy &gt;::nodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterators for traversing nodes. </p>
<p>Returns a range of iterators that traverse storage nodes (key/value pairs) for all nodes of this container. The nodes are traversed in key order. </p>

<p class="definition">Definition at line <a class="el" href="IntervalMap_8h_source.html#l00284">284</a> of file <a class="el" href="IntervalMap_8h_source.html">IntervalMap.h</a>.</p>

</div>
</div>
<a id="ae4ba034340ba48ff172b39cc80f3dc6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4ba034340ba48ff172b39cc80f3dc6e">&#9670;&nbsp;</a></span>intervals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename T , class Policy  = MergePolicy&lt;I, T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::iterator_range&lt;<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ae5130ce1b0e59f7bddd6b68f02da3b2e">ConstIntervalIterator</a>&gt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">Sawyer::Container::IntervalMap</a>&lt; I, T, Policy &gt;::intervals </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterators for traversing keys. </p>
<p>Returns a range of iteratores that traverse all keys (non-overlapping intervals) of this container according to the order of the intervals. </p>

<p class="definition">Definition at line <a class="el" href="IntervalMap_8h_source.html#l00291">291</a> of file <a class="el" href="IntervalMap_8h_source.html">IntervalMap.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="IntervalSet_8h_source.html#l00571">Sawyer::Container::IntervalSet&lt; Interval &gt;::eraseMultiple()</a>, <a class="el" href="IntervalSet_8h_source.html#l00544">Sawyer::Container::IntervalSet&lt; Interval &gt;::insertMultiple()</a>, and <a class="el" href="IntervalSet_8h_source.html#l00501">Sawyer::Container::IntervalSet&lt; Interval &gt;::invert()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1IntervalMap_ae4ba034340ba48ff172b39cc80f3dc6e_icgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1IntervalMap_ae4ba034340ba48ff172b39cc80f3dc6e_icgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1IntervalMap_ae4ba034340ba48ff172b39cc80f3dc6e_icgraph" id="classSawyer_1_1Container_1_1IntervalMap_ae4ba034340ba48ff172b39cc80f3dc6e_icgraph">
<area shape="rect" title="Iterators for traversing keys." alt="" coords="193,93,340,134"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalSet.html#a25a34da2500f077b7137406ce6541cb4" title=" " alt="" coords="5,5,145,61"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalSet.html#a775bb28a31b7a50838d9601ae7751b87" title=" " alt="" coords="5,85,145,141"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalSet.html#ad401d6914370bca3ca442cc590493297" title="Invert and intersect." alt="" coords="5,165,145,221"/>
</map>
</div>

</div>
</div>
<a id="afe92a3a1fed8440a506b3cde7891a665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe92a3a1fed8440a506b3cde7891a665">&#9670;&nbsp;</a></span>values() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename T , class Policy  = MergePolicy&lt;I, T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::iterator_range&lt;<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ae50e191b16e240244fb48af0232e88ac">ValueIterator</a>&gt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">Sawyer::Container::IntervalMap</a>&lt; I, T, Policy &gt;::values </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterators for traversing values. </p>
<p>Returns a range of iterators that traverse the values (user-defined type) of this container. The values are traversed in the order of their associated keys. </p>

<p class="definition">Definition at line <a class="el" href="IntervalMap_8h_source.html#l00299">299</a> of file <a class="el" href="IntervalMap_8h_source.html">IntervalMap.h</a>.</p>

</div>
</div>
<a id="aabafbf1a1a5177d6b21006309e73c1c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabafbf1a1a5177d6b21006309e73c1c2">&#9670;&nbsp;</a></span>values() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename T , class Policy  = MergePolicy&lt;I, T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::iterator_range&lt;<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a050e4ca3dcf0d65fba2d65b20e9730d9">ConstValueIterator</a>&gt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">Sawyer::Container::IntervalMap</a>&lt; I, T, Policy &gt;::values </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterators for traversing values. </p>
<p>Returns a range of iterators that traverse the values (user-defined type) of this container. The values are traversed in the order of their associated keys. </p>

<p class="definition">Definition at line <a class="el" href="IntervalMap_8h_source.html#l00300">300</a> of file <a class="el" href="IntervalMap_8h_source.html">IntervalMap.h</a>.</p>

</div>
</div>
<a id="a87170e7d06eb8710211a65fb9bc052c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87170e7d06eb8710211a65fb9bc052c6">&#9670;&nbsp;</a></span>lowerBound() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename T , class Policy  = MergePolicy&lt;I, T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a> <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">Sawyer::Container::IntervalMap</a>&lt; I, T, Policy &gt;::lowerBound </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the first node whose interval ends at or above the specified scalar key. </p>
<p>Returns an iterator to the node, or the end iterator if no such node exists. </p>

<p class="definition">Definition at line <a class="el" href="IntervalMap_8h_source.html#l00308">308</a> of file <a class="el" href="IntervalMap_8h_source.html">IntervalMap.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="IntervalMap_8h_source.html#l00770">Sawyer::Container::IntervalMap&lt; Interval, int &gt;::erase()</a>, <a class="el" href="IntervalMap_8h_source.html#l00546">Sawyer::Container::IntervalMap&lt; Interval, int &gt;::firstUnmapped()</a>, <a class="el" href="IntervalMap_8h_source.html#l00838">Sawyer::Container::IntervalMap&lt; Interval, int &gt;::insert()</a>, <a class="el" href="IntervalSet_8h_source.html#l00501">Sawyer::Container::IntervalSet&lt; Interval &gt;::invert()</a>, <a class="el" href="IntervalMap_8h_source.html#l00702">Sawyer::Container::IntervalMap&lt; Interval, int &gt;::least()</a>, <a class="el" href="IntervalMap_8h_source.html#l00724">Sawyer::Container::IntervalMap&lt; Interval, int &gt;::leastUnmapped()</a>, and <a class="el" href="IntervalSet_8h_source.html#l00239">Sawyer::Container::IntervalSet&lt; Interval &gt;::lowerBound()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1IntervalMap_a87170e7d06eb8710211a65fb9bc052c6_icgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1IntervalMap_a87170e7d06eb8710211a65fb9bc052c6_icgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1IntervalMap_a87170e7d06eb8710211a65fb9bc052c6_icgraph" id="classSawyer_1_1Container_1_1IntervalMap_a87170e7d06eb8710211a65fb9bc052c6_icgraph">
<area shape="rect" title="Find the first node whose interval ends at or above the specified scalar key." alt="" coords="204,253,371,294"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalMap.html#a797f0a6bd63f8debdcd0ccb2fcecf0f3" title="Erase the specified interval." alt="" coords="6,5,155,61"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalMap.html#a25feb127b25f2d5f7616003a010abdca" title="Find the first unmapped region." alt="" coords="6,85,155,141"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalMap.html#a1effdf10ccfb80ed11cc999e850ab2bd" title="Insert a key/value pair." alt="" coords="6,165,155,221"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalSet.html#ad401d6914370bca3ca442cc590493297" title="Invert and intersect." alt="" coords="11,245,151,301"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalMap.html#a1e15275d860b2da7e0de9a57fd3bd795" title="Returns the limited&#45;minimum scalar key." alt="" coords="6,325,155,381"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalMap.html#a0d679a902269aaa699bcf8a4999c17c3" title="Returns the limited&#45;minimum unmapped scalar key." alt="" coords="5,405,156,461"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalSet.html#a7d9d6d2b2a36413d1ffff2d20a9636e9" title="Find the first node whose interval ends at or above the specified scalar key." alt="" coords="11,485,151,541"/>
</map>
</div>

</div>
</div>
<a id="a4cdf5d3be3c2b27013876e65f69acd5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cdf5d3be3c2b27013876e65f69acd5d">&#9670;&nbsp;</a></span>lowerBound() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename T , class Policy  = MergePolicy&lt;I, T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a> <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">Sawyer::Container::IntervalMap</a>&lt; I, T, Policy &gt;::lowerBound </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the first node whose interval ends at or above the specified scalar key. </p>
<p>Returns an iterator to the node, or the end iterator if no such node exists. </p>

<p class="definition">Definition at line <a class="el" href="IntervalMap_8h_source.html#l00311">311</a> of file <a class="el" href="IntervalMap_8h_source.html">IntervalMap.h</a>.</p>

</div>
</div>
<a id="a56a00171503e761f08e789d07692187e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56a00171503e761f08e789d07692187e">&#9670;&nbsp;</a></span>upperBound() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename T , class Policy  = MergePolicy&lt;I, T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a> <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">Sawyer::Container::IntervalMap</a>&lt; I, T, Policy &gt;::upperBound </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the first node whose interval begins above the specified scalar key. </p>
<p>Returns an iterator to the node, or the end iterator if no such node exists. </p>

<p class="definition">Definition at line <a class="el" href="IntervalMap_8h_source.html#l00321">321</a> of file <a class="el" href="IntervalMap_8h_source.html">IntervalMap.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="IntervalSet_8h_source.html#l00246">Sawyer::Container::IntervalSet&lt; Interval &gt;::upperBound()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1IntervalMap_a56a00171503e761f08e789d07692187e_icgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1IntervalMap_a56a00171503e761f08e789d07692187e_icgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1IntervalMap_a56a00171503e761f08e789d07692187e_icgraph" id="classSawyer_1_1Container_1_1IntervalMap_a56a00171503e761f08e789d07692187e_icgraph">
<area shape="rect" title="Find the first node whose interval begins above the specified scalar key." alt="" coords="193,13,360,54"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalSet.html#a1ee9ae8f0d8dc426e32a776bd2fda5de" title="Find the first node whose interval begins above the specified scalar key." alt="" coords="5,5,145,61"/>
</map>
</div>

</div>
</div>
<a id="a1f52b31510a0edd7a3a6b99848d66df7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f52b31510a0edd7a3a6b99848d66df7">&#9670;&nbsp;</a></span>upperBound() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename T , class Policy  = MergePolicy&lt;I, T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a> <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">Sawyer::Container::IntervalMap</a>&lt; I, T, Policy &gt;::upperBound </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the first node whose interval begins above the specified scalar key. </p>
<p>Returns an iterator to the node, or the end iterator if no such node exists. </p>

<p class="definition">Definition at line <a class="el" href="IntervalMap_8h_source.html#l00327">327</a> of file <a class="el" href="IntervalMap_8h_source.html">IntervalMap.h</a>.</p>

</div>
</div>
<a id="aad53242671f18d795f3b040bdd0d7e49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad53242671f18d795f3b040bdd0d7e49">&#9670;&nbsp;</a></span>findPrior() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename T , class Policy  = MergePolicy&lt;I, T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a> <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">Sawyer::Container::IntervalMap</a>&lt; I, T, Policy &gt;::findPrior </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the last node whose interval starts at or below the specified scalar key. </p>
<p>Returns an iterator to the node, or the end iterator if no such node exists. </p>

<p class="definition">Definition at line <a class="el" href="IntervalMap_8h_source.html#l00340">340</a> of file <a class="el" href="IntervalMap_8h_source.html">IntervalMap.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="IntervalSet_8h_source.html#l00253">Sawyer::Container::IntervalSet&lt; Interval &gt;::findPrior()</a>, <a class="el" href="IntervalMap_8h_source.html#l00713">Sawyer::Container::IntervalMap&lt; Interval, int &gt;::greatest()</a>, <a class="el" href="IntervalMap_8h_source.html#l00739">Sawyer::Container::IntervalMap&lt; Interval, int &gt;::greatestUnmapped()</a>, and <a class="el" href="IntervalMap_8h_source.html#l00564">Sawyer::Container::IntervalMap&lt; Interval, int &gt;::lastUnmapped()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1IntervalMap_aad53242671f18d795f3b040bdd0d7e49_icgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1IntervalMap_aad53242671f18d795f3b040bdd0d7e49_icgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1IntervalMap_aad53242671f18d795f3b040bdd0d7e49_icgraph" id="classSawyer_1_1Container_1_1IntervalMap_aad53242671f18d795f3b040bdd0d7e49_icgraph">
<area shape="rect" title="Find the last node whose interval starts at or below the specified scalar key." alt="" coords="224,133,371,174"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalSet.html#a30f04a39feea29ff4662732e17985708" title="Find the last node whose interval starts at or below the specified scalar key." alt="" coords="21,5,161,61"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalMap.html#a0a7779da0f740c936fdb562087d91152" title="Returns the limited&#45;maximum scalar key." alt="" coords="16,85,165,141"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalMap.html#a7059f415687b5e7caec66dd7f4b133a2" title="Returns the limited&#45;maximum unmapped scalar key." alt="" coords="5,165,176,221"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalMap.html#a53ebe1dc48e4f3ef5051c97fb8d44c07" title="Find the last unmapped region." alt="" coords="16,245,165,301"/>
</map>
</div>

</div>
</div>
<a id="ab59f19099179c53ab74984bf74855aaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab59f19099179c53ab74984bf74855aaa">&#9670;&nbsp;</a></span>findPrior() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename T , class Policy  = MergePolicy&lt;I, T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a> <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">Sawyer::Container::IntervalMap</a>&lt; I, T, Policy &gt;::findPrior </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the last node whose interval starts at or below the specified scalar key. </p>
<p>Returns an iterator to the node, or the end iterator if no such node exists. </p>

<p class="definition">Definition at line <a class="el" href="IntervalMap_8h_source.html#l00343">343</a> of file <a class="el" href="IntervalMap_8h_source.html">IntervalMap.h</a>.</p>

</div>
</div>
<a id="a328f4caeb3ed341e6f7fd6530a14d70a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a328f4caeb3ed341e6f7fd6530a14d70a">&#9670;&nbsp;</a></span>findPriorImpl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename T , class Policy  = MergePolicy&lt;I, T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class IMap &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structSawyer_1_1Container_1_1IntervalMapTraits.html">IntervalMapTraits</a>&lt;IMap&gt;::<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a> <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">Sawyer::Container::IntervalMap</a>&lt; I, T, Policy &gt;::findPriorImpl </td>
          <td>(</td>
          <td class="paramtype">IMap &amp;&#160;</td>
          <td class="paramname"><em>imap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the last node whose interval starts at or below the specified scalar key. </p>
<p>Returns an iterator to the node, or the end iterator if no such node exists. </p>

<p class="definition">Definition at line <a class="el" href="IntervalMap_8h_source.html#l00349">349</a> of file <a class="el" href="IntervalMap_8h_source.html">IntervalMap.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="IntervalMap_8h_source.html#l00340">Sawyer::Container::IntervalMap&lt; Interval, int &gt;::findPrior()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1IntervalMap_a328f4caeb3ed341e6f7fd6530a14d70a_icgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1IntervalMap_a328f4caeb3ed341e6f7fd6530a14d70a_icgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1IntervalMap_a328f4caeb3ed341e6f7fd6530a14d70a_icgraph" id="classSawyer_1_1Container_1_1IntervalMap_a328f4caeb3ed341e6f7fd6530a14d70a_icgraph">
<area shape="rect" title="Find the last node whose interval starts at or below the specified scalar key." alt="" coords="203,13,373,54"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalMap.html#aad53242671f18d795f3b040bdd0d7e49" title="Find the last node whose interval starts at or below the specified scalar key." alt="" coords="5,5,155,61"/>
</map>
</div>

</div>
</div>
<a id="a9d4a318aba4a2a8af2a6a6e3570279a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d4a318aba4a2a8af2a6a6e3570279a8">&#9670;&nbsp;</a></span>find() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename T , class Policy  = MergePolicy&lt;I, T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a> <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">Sawyer::Container::IntervalMap</a>&lt; I, T, Policy &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the node containing the specified scalar key. </p>
<p>Returns an iterator to the matching node, or the end iterator if no such node exists. </p>

<p class="definition">Definition at line <a class="el" href="IntervalMap_8h_source.html#l00367">367</a> of file <a class="el" href="IntervalMap_8h_source.html">IntervalMap.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="IntervalMap_8h_source.html#l00579">Sawyer::Container::IntervalMap&lt; Interval, int &gt;::exists()</a>, <a class="el" href="IntervalSet_8h_source.html#l00260">Sawyer::Container::IntervalSet&lt; Interval &gt;::find()</a>, <a class="el" href="IntervalMap_8h_source.html#l00604">Sawyer::Container::IntervalMap&lt; Interval, int &gt;::get()</a>, <a class="el" href="IntervalMap_8h_source.html#l00625">Sawyer::Container::IntervalMap&lt; Interval, int &gt;::getOptional()</a>, <a class="el" href="IntervalMap_8h_source.html#l00651">Sawyer::Container::IntervalMap&lt; Interval, int &gt;::getOrDefault()</a>, <a class="el" href="IntervalMap_8h_source.html#l00637">Sawyer::Container::IntervalMap&lt; Interval, int &gt;::getOrElse()</a>, <a class="el" href="IntervalMap_8h_source.html#l00838">Sawyer::Container::IntervalMap&lt; Interval, int &gt;::insert()</a>, and <a class="el" href="IntervalMap_8h_source.html#l00597">Sawyer::Container::IntervalMap&lt; Interval, int &gt;::operator[]()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1IntervalMap_a9d4a318aba4a2a8af2a6a6e3570279a8_icgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1IntervalMap_a9d4a318aba4a2a8af2a6a6e3570279a8_icgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1IntervalMap_a9d4a318aba4a2a8af2a6a6e3570279a8_icgraph" id="classSawyer_1_1Container_1_1IntervalMap_a9d4a318aba4a2a8af2a6a6e3570279a8_icgraph">
<area shape="rect" title="Find the node containing the specified scalar key." alt="" coords="203,293,341,334"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalMap.html#a8da2cba60c620a2c9d4e60f57fe7a530" title="Returns true if element exists." alt="" coords="5,5,155,61"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalSet.html#aedc88e2714434f88a1919dfe93ea8135" title="Find the node containing the specified scalar key." alt="" coords="10,85,150,141"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalMap.html#a698c1549cbf43028b6cb07721d449405" title=" " alt="" coords="5,165,155,221"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalMap.html#aaad485b90e17980663b8ba6df88b3c5c" title="Lookup and return a value or nothing." alt="" coords="5,245,155,301"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalMap.html#a20b99d95c8c627e166be33a780349195" title="Lookup and return a value or a default." alt="" coords="5,325,155,381"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalMap.html#a9784567bd34e5bba82aaab13e0fd5934" title="Lookup and return a value or something else." alt="" coords="5,405,155,461"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalMap.html#a1effdf10ccfb80ed11cc999e850ab2bd" title="Insert a key/value pair." alt="" coords="5,485,155,541"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalMap.html#ae26fe590db1a0db229019c39ce9a63c4" title="Returns a reference to an existing value." alt="" coords="5,565,155,621"/>
</map>
</div>

</div>
</div>
<a id="a6675861f9feb70004fe397d1600d466f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6675861f9feb70004fe397d1600d466f">&#9670;&nbsp;</a></span>find() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename T , class Policy  = MergePolicy&lt;I, T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a> <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">Sawyer::Container::IntervalMap</a>&lt; I, T, Policy &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the node containing the specified scalar key. </p>
<p>Returns an iterator to the matching node, or the end iterator if no such node exists. </p>

<p class="definition">Definition at line <a class="el" href="IntervalMap_8h_source.html#l00370">370</a> of file <a class="el" href="IntervalMap_8h_source.html">IntervalMap.h</a>.</p>

</div>
</div>
<a id="aca75670b38521c5be0453d2c7d5221e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca75670b38521c5be0453d2c7d5221e6">&#9670;&nbsp;</a></span>findImpl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename T , class Policy  = MergePolicy&lt;I, T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class IMap &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structSawyer_1_1Container_1_1IntervalMapTraits.html">IntervalMapTraits</a>&lt;IMap&gt;::<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a> <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">Sawyer::Container::IntervalMap</a>&lt; I, T, Policy &gt;::findImpl </td>
          <td>(</td>
          <td class="paramtype">IMap &amp;&#160;</td>
          <td class="paramname"><em>imap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the node containing the specified scalar key. </p>
<p>Returns an iterator to the matching node, or the end iterator if no such node exists. </p>

<p class="definition">Definition at line <a class="el" href="IntervalMap_8h_source.html#l00376">376</a> of file <a class="el" href="IntervalMap_8h_source.html">IntervalMap.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="IntervalMap_8h_source.html#l00367">Sawyer::Container::IntervalMap&lt; Interval, int &gt;::find()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1IntervalMap_aca75670b38521c5be0453d2c7d5221e6_icgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1IntervalMap_aca75670b38521c5be0453d2c7d5221e6_icgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1IntervalMap_aca75670b38521c5be0453d2c7d5221e6_icgraph" id="classSawyer_1_1Container_1_1IntervalMap_aca75670b38521c5be0453d2c7d5221e6_icgraph">
<area shape="rect" title="Find the node containing the specified scalar key." alt="" coords="203,13,347,54"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalMap.html#a9d4a318aba4a2a8af2a6a6e3570279a8" title="Find the node containing the specified scalar key." alt="" coords="5,5,155,61"/>
</map>
</div>

</div>
</div>
<a id="acd6f088274649e06edc5911fa74c3379"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd6f088274649e06edc5911fa74c3379">&#9670;&nbsp;</a></span>findAll() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename T , class Policy  = MergePolicy&lt;I, T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::iterator_range&lt;<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a>&gt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">Sawyer::Container::IntervalMap</a>&lt; I, T, Policy &gt;::findAll </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a> &amp;&#160;</td>
          <td class="paramname"><em>interval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds all nodes overlapping the specified interval. </p>
<p>Returns an iterator range that enumerates the nodes that overlap with the specified interval. </p>

<p class="definition">Definition at line <a class="el" href="IntervalMap_8h_source.html#l00390">390</a> of file <a class="el" href="IntervalMap_8h_source.html">IntervalMap.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="IntervalSet_8h_source.html#l00267">Sawyer::Container::IntervalSet&lt; Interval &gt;::findAll()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1IntervalMap_acd6f088274649e06edc5911fa74c3379_icgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1IntervalMap_acd6f088274649e06edc5911fa74c3379_icgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1IntervalMap_acd6f088274649e06edc5911fa74c3379_icgraph" id="classSawyer_1_1Container_1_1IntervalMap_acd6f088274649e06edc5911fa74c3379_icgraph">
<area shape="rect" title="Finds all nodes overlapping the specified interval." alt="" coords="193,13,332,54"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalSet.html#a0081cc687117a191d1f836bef5a6ad16" title="Finds all nodes overlapping the specified interval." alt="" coords="5,5,145,61"/>
</map>
</div>

</div>
</div>
<a id="abbc578d55f2c30733f592cf534535d83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbc578d55f2c30733f592cf534535d83">&#9670;&nbsp;</a></span>findAll() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename T , class Policy  = MergePolicy&lt;I, T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::iterator_range&lt;<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a>&gt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">Sawyer::Container::IntervalMap</a>&lt; I, T, Policy &gt;::findAll </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a> &amp;&#160;</td>
          <td class="paramname"><em>interval</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds all nodes overlapping the specified interval. </p>
<p>Returns an iterator range that enumerates the nodes that overlap with the specified interval. </p>

<p class="definition">Definition at line <a class="el" href="IntervalMap_8h_source.html#l00393">393</a> of file <a class="el" href="IntervalMap_8h_source.html">IntervalMap.h</a>.</p>

</div>
</div>
<a id="ac7316ec22a4b76bad014ab7f4b0b5146"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7316ec22a4b76bad014ab7f4b0b5146">&#9670;&nbsp;</a></span>findAllImpl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename T , class Policy  = MergePolicy&lt;I, T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class IMap &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static boost::iterator_range&lt;typename <a class="el" href="structSawyer_1_1Container_1_1IntervalMapTraits.html">IntervalMapTraits</a>&lt;IMap&gt;::<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a>&gt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">Sawyer::Container::IntervalMap</a>&lt; I, T, Policy &gt;::findAllImpl </td>
          <td>(</td>
          <td class="paramtype">IMap &amp;&#160;</td>
          <td class="paramname"><em>imap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a> &amp;&#160;</td>
          <td class="paramname"><em>interval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds all nodes overlapping the specified interval. </p>
<p>Returns an iterator range that enumerates the nodes that overlap with the specified interval. </p>

<p class="definition">Definition at line <a class="el" href="IntervalMap_8h_source.html#l00399">399</a> of file <a class="el" href="IntervalMap_8h_source.html">IntervalMap.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="IntervalMap_8h_source.html#l00390">Sawyer::Container::IntervalMap&lt; Interval, int &gt;::findAll()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1IntervalMap_ac7316ec22a4b76bad014ab7f4b0b5146_icgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1IntervalMap_ac7316ec22a4b76bad014ab7f4b0b5146_icgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1IntervalMap_ac7316ec22a4b76bad014ab7f4b0b5146_icgraph" id="classSawyer_1_1Container_1_1IntervalMap_ac7316ec22a4b76bad014ab7f4b0b5146_icgraph">
<area shape="rect" title="Finds all nodes overlapping the specified interval." alt="" coords="203,13,361,54"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalMap.html#acd6f088274649e06edc5911fa74c3379" title="Finds all nodes overlapping the specified interval." alt="" coords="5,5,155,61"/>
</map>
</div>

</div>
</div>
<a id="ab5a821909b63dedab54193fbd4a747c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5a821909b63dedab54193fbd4a747c5">&#9670;&nbsp;</a></span>findFirstOverlap() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename T , class Policy  = MergePolicy&lt;I, T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a> <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">Sawyer::Container::IntervalMap</a>&lt; I, T, Policy &gt;::findFirstOverlap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a> &amp;&#160;</td>
          <td class="paramname"><em>interval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find first interval that overlaps with the specified interval. </p>
<p>Returns an iterator to the matching node, or the end iterator if no such node exists. </p>

<p class="definition">Definition at line <a class="el" href="IntervalMap_8h_source.html#l00415">415</a> of file <a class="el" href="IntervalMap_8h_source.html">IntervalMap.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="IntervalSet_8h_source.html#l00276">Sawyer::Container::IntervalSet&lt; Interval &gt;::findFirstOverlap()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1IntervalMap_ab5a821909b63dedab54193fbd4a747c5_icgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1IntervalMap_ab5a821909b63dedab54193fbd4a747c5_icgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1IntervalMap_ab5a821909b63dedab54193fbd4a747c5_icgraph" id="classSawyer_1_1Container_1_1IntervalMap_ab5a821909b63dedab54193fbd4a747c5_icgraph">
<area shape="rect" title="Find first interval that overlaps with the specified interval." alt="" coords="193,13,384,54"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalSet.html#a235ba507fda34e464316e6778dbcb044" title="Finds first node that overlaps with the specified interval." alt="" coords="5,5,145,61"/>
</map>
</div>

</div>
</div>
<a id="a48ef3aaccd8a7cb97c33359be83ca883"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48ef3aaccd8a7cb97c33359be83ca883">&#9670;&nbsp;</a></span>findFirstOverlap() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename T , class Policy  = MergePolicy&lt;I, T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a> <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">Sawyer::Container::IntervalMap</a>&lt; I, T, Policy &gt;::findFirstOverlap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a> &amp;&#160;</td>
          <td class="paramname"><em>interval</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find first interval that overlaps with the specified interval. </p>
<p>Returns an iterator to the matching node, or the end iterator if no such node exists. </p>

<p class="definition">Definition at line <a class="el" href="IntervalMap_8h_source.html#l00418">418</a> of file <a class="el" href="IntervalMap_8h_source.html">IntervalMap.h</a>.</p>

</div>
</div>
<a id="ac6137a2a3d9544e3ed550d409ec36a25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6137a2a3d9544e3ed550d409ec36a25">&#9670;&nbsp;</a></span>findFirstOverlapImpl() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename T , class Policy  = MergePolicy&lt;I, T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class IMap &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structSawyer_1_1Container_1_1IntervalMapTraits.html">IntervalMapTraits</a>&lt;IMap&gt;::<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a> <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">Sawyer::Container::IntervalMap</a>&lt; I, T, Policy &gt;::findFirstOverlapImpl </td>
          <td>(</td>
          <td class="paramtype">IMap &amp;&#160;</td>
          <td class="paramname"><em>imap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a> &amp;&#160;</td>
          <td class="paramname"><em>interval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find first interval that overlaps with the specified interval. </p>
<p>Returns an iterator to the matching node, or the end iterator if no such node exists. </p>

<p class="definition">Definition at line <a class="el" href="IntervalMap_8h_source.html#l00424">424</a> of file <a class="el" href="IntervalMap_8h_source.html">IntervalMap.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="IntervalMap_8h_source.html#l00415">Sawyer::Container::IntervalMap&lt; Interval, int &gt;::findFirstOverlap()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1IntervalMap_ac6137a2a3d9544e3ed550d409ec36a25_icgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1IntervalMap_ac6137a2a3d9544e3ed550d409ec36a25_icgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1IntervalMap_ac6137a2a3d9544e3ed550d409ec36a25_icgraph" id="classSawyer_1_1Container_1_1IntervalMap_ac6137a2a3d9544e3ed550d409ec36a25_icgraph">
<area shape="rect" title="Find first interval that overlaps with the specified interval." alt="" coords="205,13,420,54"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalMap.html#ab5a821909b63dedab54193fbd4a747c5" title="Find first interval that overlaps with the specified interval." alt="" coords="5,5,157,61"/>
</map>
</div>

</div>
</div>
<a id="a2a8408ce80dfcf266dc6c8443cdf01bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a8408ce80dfcf266dc6c8443cdf01bc">&#9670;&nbsp;</a></span>findFirstOverlap() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename T , class Policy  = MergePolicy&lt;I, T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename T2 , class Policy2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a>, typename <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt;<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, T2, Policy2&gt;::<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a>&gt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">Sawyer::Container::IntervalMap</a>&lt; I, T, Policy &gt;::findFirstOverlap </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; I, T, Policy &gt;::<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a>&#160;</td>
          <td class="paramname"><em>thisIter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, T2, Policy2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, T2, Policy2 &gt;::<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a>&#160;</td>
          <td class="paramname"><em>otherIter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find first interval that overlaps with any in another container. </p>
<p>The <code>other</code> container must use the same interval type, but may have different values and merge policies. The search begins at the specified iterators and returns a pair of iterators pointing to the two nodes that overlap. The first member of the pair is an iterator to this container, and the second is an iterator for the <code>other</code> container. If no such nodes exist at or after the starting locations, then the return value will be a pair of end iterators for their respective containers. </p>

<p class="definition">Definition at line <a class="el" href="IntervalMap_8h_source.html#l00444">444</a> of file <a class="el" href="IntervalMap_8h_source.html">IntervalMap.h</a>.</p>

</div>
</div>
<a id="a191694b0521c2f5e1eabcdc948dd5d67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a191694b0521c2f5e1eabcdc948dd5d67">&#9670;&nbsp;</a></span>findFirstOverlap() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename T , class Policy  = MergePolicy&lt;I, T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename T2 , class Policy2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a>, typename <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt;<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, T2, Policy2&gt;::<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a>&gt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">Sawyer::Container::IntervalMap</a>&lt; I, T, Policy &gt;::findFirstOverlap </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; I, T, Policy &gt;::<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a>&#160;</td>
          <td class="paramname"><em>thisIter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, T2, Policy2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, T2, Policy2 &gt;::<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a>&#160;</td>
          <td class="paramname"><em>otherIter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find first interval that overlaps with any in another container. </p>
<p>The <code>other</code> container must use the same interval type, but may have different values and merge policies. The search begins at the specified iterators and returns a pair of iterators pointing to the two nodes that overlap. The first member of the pair is an iterator to this container, and the second is an iterator for the <code>other</code> container. If no such nodes exist at or after the starting locations, then the return value will be a pair of end iterators for their respective containers. </p>

<p class="definition">Definition at line <a class="el" href="IntervalMap_8h_source.html#l00450">450</a> of file <a class="el" href="IntervalMap_8h_source.html">IntervalMap.h</a>.</p>

</div>
</div>
<a id="a2f0c498977ab94415ab40fe46e717d2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f0c498977ab94415ab40fe46e717d2f">&#9670;&nbsp;</a></span>findFirstOverlapImpl() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename T , class Policy  = MergePolicy&lt;I, T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class IMap , typename T2 , class Policy2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::pair&lt;typename <a class="el" href="structSawyer_1_1Container_1_1IntervalMapTraits.html">IntervalMapTraits</a>&lt;IMap&gt;::<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a>, typename <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt;<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, T2, Policy2&gt;::<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a>&gt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">Sawyer::Container::IntervalMap</a>&lt; I, T, Policy &gt;::findFirstOverlapImpl </td>
          <td>(</td>
          <td class="paramtype">IMap &amp;&#160;</td>
          <td class="paramname"><em>imap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structSawyer_1_1Container_1_1IntervalMapTraits.html">IntervalMapTraits</a>&lt; IMap &gt;::<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a>&#160;</td>
          <td class="paramname"><em>thisIter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, T2, Policy2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, T2, Policy2 &gt;::<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a>&#160;</td>
          <td class="paramname"><em>otherIter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find first interval that overlaps with any in another container. </p>
<p>The <code>other</code> container must use the same interval type, but may have different values and merge policies. The search begins at the specified iterators and returns a pair of iterators pointing to the two nodes that overlap. The first member of the pair is an iterator to this container, and the second is an iterator for the <code>other</code> container. If no such nodes exist at or after the starting locations, then the return value will be a pair of end iterators for their respective containers. </p>

<p class="definition">Definition at line <a class="el" href="IntervalMap_8h_source.html#l00458">458</a> of file <a class="el" href="IntervalMap_8h_source.html">IntervalMap.h</a>.</p>

</div>
</div>
<a id="a6f05fe11220a1d2c1e75e2fcde5a573d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f05fe11220a1d2c1e75e2fcde5a573d">&#9670;&nbsp;</a></span>firstFit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename T , class Policy  = MergePolicy&lt;I, T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a> <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">Sawyer::Container::IntervalMap</a>&lt; I, T, Policy &gt;::firstFit </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a>&#160;</td>
          <td class="paramname"><em>start</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the first fit node at or after a starting point. </p>
<p>Finds the first node of contiguous values beginning at or after the specified starting iterator, <code>start</code>, and which is at least as large as the desired <code>size</code>. If there are no such nodes then the end iterator is returned.</p>
<p>Caveat emptor: The <code>size</code> argument has the name type as the interval end points. If the end points have a signed type, then it is entirely likely that the size will overflow. In fact, it is also possible that unsigned sizes overflow since, for example, an 8-bit unsigned size cannot hold the size of an interval representing the entire 8-bit space. Therefore, use this method with care. </p>

<p class="definition">Definition at line <a class="el" href="IntervalMap_8h_source.html#l00486">486</a> of file <a class="el" href="IntervalMap_8h_source.html">IntervalMap.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="IntervalSet_8h_source.html#l00460">Sawyer::Container::IntervalSet&lt; Interval &gt;::firstFit()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1IntervalMap_a6f05fe11220a1d2c1e75e2fcde5a573d_icgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1IntervalMap_a6f05fe11220a1d2c1e75e2fcde5a573d_icgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1IntervalMap_a6f05fe11220a1d2c1e75e2fcde5a573d_icgraph" id="classSawyer_1_1Container_1_1IntervalMap_a6f05fe11220a1d2c1e75e2fcde5a573d_icgraph">
<area shape="rect" title="Find the first fit node at or after a starting point." alt="" coords="193,13,332,54"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalSet.html#a74436215264062026824d3b7c50603e4" title="Find the first fit node at or after a starting point." alt="" coords="5,5,145,61"/>
</map>
</div>

</div>
</div>
<a id="a3710d6445b86359fc16236d2bb54a8a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3710d6445b86359fc16236d2bb54a8a1">&#9670;&nbsp;</a></span>firstFit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename T , class Policy  = MergePolicy&lt;I, T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a> <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">Sawyer::Container::IntervalMap</a>&lt; I, T, Policy &gt;::firstFit </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a>&#160;</td>
          <td class="paramname"><em>start</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the first fit node at or after a starting point. </p>
<p>Finds the first node of contiguous values beginning at or after the specified starting iterator, <code>start</code>, and which is at least as large as the desired <code>size</code>. If there are no such nodes then the end iterator is returned.</p>
<p>Caveat emptor: The <code>size</code> argument has the name type as the interval end points. If the end points have a signed type, then it is entirely likely that the size will overflow. In fact, it is also possible that unsigned sizes overflow since, for example, an 8-bit unsigned size cannot hold the size of an interval representing the entire 8-bit space. Therefore, use this method with care. </p>

<p class="definition">Definition at line <a class="el" href="IntervalMap_8h_source.html#l00489">489</a> of file <a class="el" href="IntervalMap_8h_source.html">IntervalMap.h</a>.</p>

</div>
</div>
<a id="aab0a866bb43163a34bd4ea8924117ae3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab0a866bb43163a34bd4ea8924117ae3">&#9670;&nbsp;</a></span>firstFitImpl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename T , class Policy  = MergePolicy&lt;I, T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class IMap &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structSawyer_1_1Container_1_1IntervalMapTraits.html">IntervalMapTraits</a>&lt;IMap&gt;::<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a> <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">Sawyer::Container::IntervalMap</a>&lt; I, T, Policy &gt;::firstFitImpl </td>
          <td>(</td>
          <td class="paramtype">IMap &amp;&#160;</td>
          <td class="paramname"><em>imap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structSawyer_1_1Container_1_1IntervalMapTraits.html">IntervalMapTraits</a>&lt; IMap &gt;::<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a>&#160;</td>
          <td class="paramname"><em>start</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the first fit node at or after a starting point. </p>
<p>Finds the first node of contiguous values beginning at or after the specified starting iterator, <code>start</code>, and which is at least as large as the desired <code>size</code>. If there are no such nodes then the end iterator is returned.</p>
<p>Caveat emptor: The <code>size</code> argument has the name type as the interval end points. If the end points have a signed type, then it is entirely likely that the size will overflow. In fact, it is also possible that unsigned sizes overflow since, for example, an 8-bit unsigned size cannot hold the size of an interval representing the entire 8-bit space. Therefore, use this method with care. </p>

<p class="definition">Definition at line <a class="el" href="IntervalMap_8h_source.html#l00495">495</a> of file <a class="el" href="IntervalMap_8h_source.html">IntervalMap.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="IntervalMap_8h_source.html#l00486">Sawyer::Container::IntervalMap&lt; Interval, int &gt;::firstFit()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1IntervalMap_aab0a866bb43163a34bd4ea8924117ae3_icgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1IntervalMap_aab0a866bb43163a34bd4ea8924117ae3_icgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1IntervalMap_aab0a866bb43163a34bd4ea8924117ae3_icgraph" id="classSawyer_1_1Container_1_1IntervalMap_aab0a866bb43163a34bd4ea8924117ae3_icgraph">
<area shape="rect" title="Find the first fit node at or after a starting point." alt="" coords="203,13,363,54"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalMap.html#a6f05fe11220a1d2c1e75e2fcde5a573d" title="Find the first fit node at or after a starting point." alt="" coords="5,5,155,61"/>
</map>
</div>

</div>
</div>
<a id="afa299225e9e0576bc9944dde4b29d569"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa299225e9e0576bc9944dde4b29d569">&#9670;&nbsp;</a></span>bestFit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename T , class Policy  = MergePolicy&lt;I, T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a> <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">Sawyer::Container::IntervalMap</a>&lt; I, T, Policy &gt;::bestFit </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a>&#160;</td>
          <td class="paramname"><em>start</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the best fit node at or after a starting point. </p>
<p>Finds a node of contiguous values beginning at or after the specified starting iterator, <code>start</code>, and which is at least as large as the desired <code>size</code>. If there is more than one such node, then the first smallest such node is returned. If there are no such nodes then the end iterator is returned.</p>
<p>Caveat emptor: The <code>size</code> argument has the name type as the interval end points. If the end points have a signed type, then it is entirely likely that the size will overflow. In fact, it is also possible that unsigned sizes overflow since, for example, an 8-bit unsigned size cannot hold the size of an interval representing the entire 8-bit space. Therefore, use this method with care. </p>

<p class="definition">Definition at line <a class="el" href="IntervalMap_8h_source.html#l00518">518</a> of file <a class="el" href="IntervalMap_8h_source.html">IntervalMap.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="IntervalSet_8h_source.html#l00474">Sawyer::Container::IntervalSet&lt; Interval &gt;::bestFit()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1IntervalMap_afa299225e9e0576bc9944dde4b29d569_icgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1IntervalMap_afa299225e9e0576bc9944dde4b29d569_icgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1IntervalMap_afa299225e9e0576bc9944dde4b29d569_icgraph" id="classSawyer_1_1Container_1_1IntervalMap_afa299225e9e0576bc9944dde4b29d569_icgraph">
<area shape="rect" title="Find the best fit node at or after a starting point." alt="" coords="193,13,332,54"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalSet.html#a017c45213aacb64ea018076d9a80dfb8" title="Find the best fit node at or after a starting point." alt="" coords="5,5,145,61"/>
</map>
</div>

</div>
</div>
<a id="a747ae7350949b0c59e9d40db1c62286f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a747ae7350949b0c59e9d40db1c62286f">&#9670;&nbsp;</a></span>bestFit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename T , class Policy  = MergePolicy&lt;I, T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a> <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">Sawyer::Container::IntervalMap</a>&lt; I, T, Policy &gt;::bestFit </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a>&#160;</td>
          <td class="paramname"><em>start</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the best fit node at or after a starting point. </p>
<p>Finds a node of contiguous values beginning at or after the specified starting iterator, <code>start</code>, and which is at least as large as the desired <code>size</code>. If there is more than one such node, then the first smallest such node is returned. If there are no such nodes then the end iterator is returned.</p>
<p>Caveat emptor: The <code>size</code> argument has the name type as the interval end points. If the end points have a signed type, then it is entirely likely that the size will overflow. In fact, it is also possible that unsigned sizes overflow since, for example, an 8-bit unsigned size cannot hold the size of an interval representing the entire 8-bit space. Therefore, use this method with care. </p>

<p class="definition">Definition at line <a class="el" href="IntervalMap_8h_source.html#l00521">521</a> of file <a class="el" href="IntervalMap_8h_source.html">IntervalMap.h</a>.</p>

</div>
</div>
<a id="a6279404d9a97574a538b3d6a18c7001d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6279404d9a97574a538b3d6a18c7001d">&#9670;&nbsp;</a></span>bestFitImpl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename T , class Policy  = MergePolicy&lt;I, T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class IMap &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structSawyer_1_1Container_1_1IntervalMapTraits.html">IntervalMapTraits</a>&lt;IMap&gt;::<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a> <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">Sawyer::Container::IntervalMap</a>&lt; I, T, Policy &gt;::bestFitImpl </td>
          <td>(</td>
          <td class="paramtype">IMap &amp;&#160;</td>
          <td class="paramname"><em>imap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structSawyer_1_1Container_1_1IntervalMapTraits.html">IntervalMapTraits</a>&lt; IMap &gt;::<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a>&#160;</td>
          <td class="paramname"><em>start</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the best fit node at or after a starting point. </p>
<p>Finds a node of contiguous values beginning at or after the specified starting iterator, <code>start</code>, and which is at least as large as the desired <code>size</code>. If there is more than one such node, then the first smallest such node is returned. If there are no such nodes then the end iterator is returned.</p>
<p>Caveat emptor: The <code>size</code> argument has the name type as the interval end points. If the end points have a signed type, then it is entirely likely that the size will overflow. In fact, it is also possible that unsigned sizes overflow since, for example, an 8-bit unsigned size cannot hold the size of an interval representing the entire 8-bit space. Therefore, use this method with care. </p>

<p class="definition">Definition at line <a class="el" href="IntervalMap_8h_source.html#l00527">527</a> of file <a class="el" href="IntervalMap_8h_source.html">IntervalMap.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="IntervalMap_8h_source.html#l00518">Sawyer::Container::IntervalMap&lt; Interval, int &gt;::bestFit()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1IntervalMap_a6279404d9a97574a538b3d6a18c7001d_icgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1IntervalMap_a6279404d9a97574a538b3d6a18c7001d_icgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1IntervalMap_a6279404d9a97574a538b3d6a18c7001d_icgraph" id="classSawyer_1_1Container_1_1IntervalMap_a6279404d9a97574a538b3d6a18c7001d_icgraph">
<area shape="rect" title="Find the best fit node at or after a starting point." alt="" coords="203,13,365,54"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalMap.html#afa299225e9e0576bc9944dde4b29d569" title="Find the best fit node at or after a starting point." alt="" coords="5,5,155,61"/>
</map>
</div>

</div>
</div>
<a id="a25feb127b25f2d5f7616003a010abdca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25feb127b25f2d5f7616003a010abdca">&#9670;&nbsp;</a></span>firstUnmapped()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename T , class Policy  = MergePolicy&lt;I, T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a> <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">Sawyer::Container::IntervalMap</a>&lt; I, T, Policy &gt;::firstUnmapped </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a>&#160;</td>
          <td class="paramname"><em>minAddr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the first unmapped region. </p>
<p>Returns an interval that describes the lowest unmapped interval that begins at or after the specified starting address and ends immediately prior to the mapped address that follows the unmapped interval, or the greatest possible address if there are no following mapped addresses. If <code>minAddr</code> is after the last unmapped address then an empty interval is returned. The returned interval will not include addresses less than <code>minAddr</code>. </p>

<p class="definition">Definition at line <a class="el" href="IntervalMap_8h_source.html#l00546">546</a> of file <a class="el" href="IntervalMap_8h_source.html">IntervalMap.h</a>.</p>

</div>
</div>
<a id="a53ebe1dc48e4f3ef5051c97fb8d44c07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53ebe1dc48e4f3ef5051c97fb8d44c07">&#9670;&nbsp;</a></span>lastUnmapped()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename T , class Policy  = MergePolicy&lt;I, T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a> <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">Sawyer::Container::IntervalMap</a>&lt; I, T, Policy &gt;::lastUnmapped </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a>&#160;</td>
          <td class="paramname"><em>maxAddr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the last unmapped region. </p>
<p>Returns an interval that describes the lowest unmapped interval that ends at or before the specified maximum address and starts immediately after the next lower mapped address, or the least possible address is no lower mapped address is present. If <code>maxAddr</code> is before the first unmapped address then an empty interval is returned. The returned interval will not include addresses greater than <code>maxAddr</code>. </p>

<p class="definition">Definition at line <a class="el" href="IntervalMap_8h_source.html#l00564">564</a> of file <a class="el" href="IntervalMap_8h_source.html">IntervalMap.h</a>.</p>

</div>
</div>
<a id="a8da2cba60c620a2c9d4e60f57fe7a530"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8da2cba60c620a2c9d4e60f57fe7a530">&#9670;&nbsp;</a></span>exists()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename T , class Policy  = MergePolicy&lt;I, T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">Sawyer::Container::IntervalMap</a>&lt; I, T, Policy &gt;::exists </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if element exists. </p>
<p>Returns true if and only if the specified key exists in the map. </p>

<p class="definition">Definition at line <a class="el" href="IntervalMap_8h_source.html#l00579">579</a> of file <a class="el" href="IntervalMap_8h_source.html">IntervalMap.h</a>.</p>

</div>
</div>
<a id="ae26fe590db1a0db229019c39ce9a63c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae26fe590db1a0db229019c39ce9a63c4">&#9670;&nbsp;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename T , class Policy  = MergePolicy&lt;I, T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a7c7ef387287aa01aa632dfeafc121e95">Value</a>&amp; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">Sawyer::Container::IntervalMap</a>&lt; I, T, Policy &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to an existing value. </p>
<p>Returns a reference to the value at the node with the specified <code>scalar</code>. Unlike <code>std::map</code>, this container does not instantiate a new value if the <code>scalar</code> key is not in the map's domain. In other words, the array operator for this class is more like an array operator on arrays or vectors&ndash;such objects are not automatically extended if dereferenced with an operand that is outside the domain.</p>
<p>If the <code>scalar</code> is not part of this map's domain then an <code>std:domain_error</code> is thrown. </p>

<p class="definition">Definition at line <a class="el" href="IntervalMap_8h_source.html#l00597">597</a> of file <a class="el" href="IntervalMap_8h_source.html">IntervalMap.h</a>.</p>

</div>
</div>
<a id="a698c1549cbf43028b6cb07721d449405"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a698c1549cbf43028b6cb07721d449405">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename T , class Policy  = MergePolicy&lt;I, T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a7c7ef387287aa01aa632dfeafc121e95">Value</a>&amp; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">Sawyer::Container::IntervalMap</a>&lt; I, T, Policy &gt;::get </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to an existing value. </p>
<p>Returns a reference to the value at the node with the specified <code>scalar</code>. Unlike <code>std::map</code>, this container does not instantiate a new value if the <code>scalar</code> key is not in the map's domain. In other words, the array operator for this class is more like an array operator on arrays or vectors&ndash;such objects are not automatically extended if dereferenced with an operand that is outside the domain.</p>
<p>If the <code>scalar</code> is not part of this map's domain then an <code>std:domain_error</code> is thrown. </p>

<p class="definition">Definition at line <a class="el" href="IntervalMap_8h_source.html#l00604">604</a> of file <a class="el" href="IntervalMap_8h_source.html">IntervalMap.h</a>.</p>

</div>
</div>
<a id="aaad485b90e17980663b8ba6df88b3c5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaad485b90e17980663b8ba6df88b3c5c">&#9670;&nbsp;</a></span>getOptional()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename T , class Policy  = MergePolicy&lt;I, T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt;<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a7c7ef387287aa01aa632dfeafc121e95">Value</a>&gt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">Sawyer::Container::IntervalMap</a>&lt; I, T, Policy &gt;::getOptional </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lookup and return a value or nothing. </p>
<p>Looks up the node with the specified <code>scalar</code> key and returns either a copy of its value, or nothing. This method executes in logorithmic time.</p>
<p>Here's an example of one convenient way to use this:</p>
<div class="fragment"><div class="line">IntervalMap&lt;AddressInterval, FileInfo&gt; files;</div>
<div class="line">...</div>
<div class="line">if (Optional&lt;FileInfo&gt; fileInfo = files.getOptional(address))</div>
<div class="line">    std::cout &lt;&lt;<span class="stringliteral">&quot;file info for &quot;</span> &lt;&lt;address &lt;&lt;<span class="stringliteral">&quot; is &quot;</span> &lt;&lt;*fileInfo &lt;&lt;<span class="stringliteral">&quot;\n&quot;</span>;</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="IntervalMap_8h_source.html#l00625">625</a> of file <a class="el" href="IntervalMap_8h_source.html">IntervalMap.h</a>.</p>

</div>
</div>
<a id="a9784567bd34e5bba82aaab13e0fd5934"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9784567bd34e5bba82aaab13e0fd5934">&#9670;&nbsp;</a></span>getOrElse() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename T , class Policy  = MergePolicy&lt;I, T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a7c7ef387287aa01aa632dfeafc121e95">Value</a>&amp; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">Sawyer::Container::IntervalMap</a>&lt; I, T, Policy &gt;::getOrElse </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a7c7ef387287aa01aa632dfeafc121e95">Value</a> &amp;&#160;</td>
          <td class="paramname"><em>dflt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lookup and return a value or something else. </p>
<p>This is similar to the <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#aaad485b90e17980663b8ba6df88b3c5c">getOptional</a> method, except a default can be provided. If a node with the specified <code>scalar</code> key is present in this container, then a reference to that node's value is returned, otherwise the (reference to) supplied default is returned. </p>

<p class="definition">Definition at line <a class="el" href="IntervalMap_8h_source.html#l00637">637</a> of file <a class="el" href="IntervalMap_8h_source.html">IntervalMap.h</a>.</p>

</div>
</div>
<a id="aaa3f2968268e558b2f5c3088b419103e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa3f2968268e558b2f5c3088b419103e">&#9670;&nbsp;</a></span>getOrElse() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename T , class Policy  = MergePolicy&lt;I, T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a7c7ef387287aa01aa632dfeafc121e95">Value</a>&amp; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">Sawyer::Container::IntervalMap</a>&lt; I, T, Policy &gt;::getOrElse </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a7c7ef387287aa01aa632dfeafc121e95">Value</a> &amp;&#160;</td>
          <td class="paramname"><em>dflt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lookup and return a value or something else. </p>
<p>This is similar to the <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#aaad485b90e17980663b8ba6df88b3c5c">getOptional</a> method, except a default can be provided. If a node with the specified <code>scalar</code> key is present in this container, then a reference to that node's value is returned, otherwise the (reference to) supplied default is returned. </p>

<p class="definition">Definition at line <a class="el" href="IntervalMap_8h_source.html#l00641">641</a> of file <a class="el" href="IntervalMap_8h_source.html">IntervalMap.h</a>.</p>

</div>
</div>
<a id="a20b99d95c8c627e166be33a780349195"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20b99d95c8c627e166be33a780349195">&#9670;&nbsp;</a></span>getOrDefault()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename T , class Policy  = MergePolicy&lt;I, T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a7c7ef387287aa01aa632dfeafc121e95">Value</a>&amp; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">Sawyer::Container::IntervalMap</a>&lt; I, T, Policy &gt;::getOrDefault </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lookup and return a value or a default. </p>
<p>This is similar to the <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a9784567bd34e5bba82aaab13e0fd5934">getOrElse</a> method except when the <code>scalar</code> key is not present in the map, a reference to a const, default-constructed value is returned. </p>

<p class="definition">Definition at line <a class="el" href="IntervalMap_8h_source.html#l00651">651</a> of file <a class="el" href="IntervalMap_8h_source.html">IntervalMap.h</a>.</p>

</div>
</div>
<a id="acb61e91bac6aa82b6a5193726799bdf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb61e91bac6aa82b6a5193726799bdf9">&#9670;&nbsp;</a></span>isEmpty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename T , class Policy  = MergePolicy&lt;I, T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">Sawyer::Container::IntervalMap</a>&lt; I, T, Policy &gt;::isEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if the container is empty. </p>
<p>Returns true if this container has no nodes. </p>

<p class="definition">Definition at line <a class="el" href="IntervalMap_8h_source.html#l00665">665</a> of file <a class="el" href="IntervalMap_8h_source.html">IntervalMap.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="IntervalMap_8h_source.html#l00692">Sawyer::Container::IntervalMap&lt; Interval, int &gt;::greatest()</a>, <a class="el" href="IntervalMap_8h_source.html#l00753">Sawyer::Container::IntervalMap&lt; Interval, int &gt;::hull()</a>, <a class="el" href="IntervalSet_8h_source.html#l00299">Sawyer::Container::IntervalSet&lt; Interval &gt;::isEmpty()</a>, and <a class="el" href="IntervalMap_8h_source.html#l00686">Sawyer::Container::IntervalMap&lt; Interval, int &gt;::least()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1IntervalMap_acb61e91bac6aa82b6a5193726799bdf9_icgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1IntervalMap_acb61e91bac6aa82b6a5193726799bdf9_icgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1IntervalMap_acb61e91bac6aa82b6a5193726799bdf9_icgraph" id="classSawyer_1_1Container_1_1IntervalMap_acb61e91bac6aa82b6a5193726799bdf9_icgraph">
<area shape="rect" title="Determine if the container is empty." alt="" coords="203,133,349,174"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalMap.html#a385bbee53b2f1ba14ad34af9211f067d" title="Returns the maximum scalar key." alt="" coords="5,5,155,61"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalMap.html#a4734abf74cda51aa6252ecfc38342e93" title="Returns the range of values in this map." alt="" coords="5,85,155,141"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalSet.html#a9a77b0d1f5b4b464a69c6e9afda0f893" title="Determine whether the container is empty." alt="" coords="10,165,150,221"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalMap.html#a6e7d3909845b1efa5c5849f60faa3192" title="Returns the minimum scalar key." alt="" coords="5,245,155,301"/>
</map>
</div>

</div>
</div>
<a id="a017216edaa9c3064857c75fc63c07217"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a017216edaa9c3064857c75fc63c07217">&#9670;&nbsp;</a></span>nIntervals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename T , class Policy  = MergePolicy&lt;I, T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">Sawyer::Container::IntervalMap</a>&lt; I, T, Policy &gt;::nIntervals </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of nodes in the container. </p>
<p>Each node is a pair consisting of an interval and a value. The container normally merges two juxtaposed intervals if their values can be combined. </p>

<p class="definition">Definition at line <a class="el" href="IntervalMap_8h_source.html#l00673">673</a> of file <a class="el" href="IntervalMap_8h_source.html">IntervalMap.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="IntervalSet_8h_source.html#l00316">Sawyer::Container::IntervalSet&lt; Interval &gt;::nIntervals()</a>, and <a class="el" href="IntervalSet_8h_source.html#l00620">Sawyer::Container::IntervalSet&lt; Interval &gt;::operator!=()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1IntervalMap_a017216edaa9c3064857c75fc63c07217_icgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1IntervalMap_a017216edaa9c3064857c75fc63c07217_icgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1IntervalMap_a017216edaa9c3064857c75fc63c07217_icgraph" id="classSawyer_1_1Container_1_1IntervalMap_a017216edaa9c3064857c75fc63c07217_icgraph">
<area shape="rect" title="Number of nodes in the container." alt="" coords="193,53,348,94"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalSet.html#a82c2f589322e056a47f219dee70e9976" title="Number of storage nodes." alt="" coords="5,5,145,61"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalSet.html#a2f64f9cb833e1adc81e1a7f8563e2c6b" title="Determines if two sets contain different elements." alt="" coords="5,85,145,141"/>
</map>
</div>

</div>
</div>
<a id="adbf9f66a08580ead37de8f0dd96d575e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbf9f66a08580ead37de8f0dd96d575e">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename T , class Policy  = MergePolicy&lt;I, T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">Sawyer::Container::IntervalMap</a>&lt; I, T, Policy &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of values represented by this container. </p>
<p>The number of values in a container is the sum of the widths of all the nodes. This can be calculated in constant time. </p>

<p class="definition">Definition at line <a class="el" href="IntervalMap_8h_source.html#l00681">681</a> of file <a class="el" href="IntervalMap_8h_source.html">IntervalMap.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="IntervalMap_8h_source.html#l00518">Sawyer::Container::IntervalMap&lt; Interval, int &gt;::bestFit()</a>, <a class="el" href="IntervalMap_8h_source.html#l00527">Sawyer::Container::IntervalMap&lt; Interval, int &gt;::bestFitImpl()</a>, <a class="el" href="IntervalMap_8h_source.html#l00579">Sawyer::Container::IntervalMap&lt; Interval, int &gt;::exists()</a>, <a class="el" href="IntervalMap_8h_source.html#l00486">Sawyer::Container::IntervalMap&lt; Interval, int &gt;::firstFit()</a>, <a class="el" href="IntervalMap_8h_source.html#l00495">Sawyer::Container::IntervalMap&lt; Interval, int &gt;::firstFitImpl()</a>, and <a class="el" href="IntervalSet_8h_source.html#l00308">Sawyer::Container::IntervalSet&lt; Interval &gt;::size()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1IntervalMap_adbf9f66a08580ead37de8f0dd96d575e_icgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1IntervalMap_adbf9f66a08580ead37de8f0dd96d575e_icgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1IntervalMap_adbf9f66a08580ead37de8f0dd96d575e_icgraph" id="classSawyer_1_1Container_1_1IntervalMap_adbf9f66a08580ead37de8f0dd96d575e_icgraph">
<area shape="rect" title="Returns the number of values represented by this container." alt="" coords="203,213,341,254"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalMap.html#afa299225e9e0576bc9944dde4b29d569" title="Find the best fit node at or after a starting point." alt="" coords="5,5,155,61"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalMap.html#a6279404d9a97574a538b3d6a18c7001d" title=" " alt="" coords="5,85,155,141"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalMap.html#a8da2cba60c620a2c9d4e60f57fe7a530" title="Returns true if element exists." alt="" coords="5,165,155,221"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalMap.html#a6f05fe11220a1d2c1e75e2fcde5a573d" title="Find the first fit node at or after a starting point." alt="" coords="5,245,155,301"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalMap.html#aab0a866bb43163a34bd4ea8924117ae3" title=" " alt="" coords="5,325,155,381"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalSet.html#a7878417b4debcb2a16313e9128e13f17" title="Number of scalar elements represented." alt="" coords="10,405,150,461"/>
</map>
</div>

</div>
</div>
<a id="a1e15275d860b2da7e0de9a57fd3bd795"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e15275d860b2da7e0de9a57fd3bd795">&#9670;&nbsp;</a></span>least()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename T , class Policy  = MergePolicy&lt;I, T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt;typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a>&gt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">Sawyer::Container::IntervalMap</a>&lt; I, T, Policy &gt;::least </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a>&#160;</td>
          <td class="paramname"><em>lowerLimit</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the limited-minimum scalar key. </p>
<p>Returns the minimum scalar key that exists in the map and which is greater than or equal to <code>lowerLimit</code>. If no such value exists then nothing is returned. </p>

<p class="definition">Definition at line <a class="el" href="IntervalMap_8h_source.html#l00702">702</a> of file <a class="el" href="IntervalMap_8h_source.html">IntervalMap.h</a>.</p>

</div>
</div>
<a id="a0a7779da0f740c936fdb562087d91152"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a7779da0f740c936fdb562087d91152">&#9670;&nbsp;</a></span>greatest()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename T , class Policy  = MergePolicy&lt;I, T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt;typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a>&gt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">Sawyer::Container::IntervalMap</a>&lt; I, T, Policy &gt;::greatest </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a>&#160;</td>
          <td class="paramname"><em>upperLimit</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the limited-maximum scalar key. </p>
<p>Returns the maximum scalar key that exists in the map and which is less than or equal to <code>upperLimit</code>. If no such value exists then nothing is returned. </p>

<p class="definition">Definition at line <a class="el" href="IntervalMap_8h_source.html#l00713">713</a> of file <a class="el" href="IntervalMap_8h_source.html">IntervalMap.h</a>.</p>

</div>
</div>
<a id="a0d679a902269aaa699bcf8a4999c17c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d679a902269aaa699bcf8a4999c17c3">&#9670;&nbsp;</a></span>leastUnmapped()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename T , class Policy  = MergePolicy&lt;I, T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt;typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a>&gt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">Sawyer::Container::IntervalMap</a>&lt; I, T, Policy &gt;::leastUnmapped </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a>&#160;</td>
          <td class="paramname"><em>lowerLimit</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the limited-minimum unmapped scalar key. </p>
<p>Returns the lowest unmapped scalar key equal to or greater than the <code>lowerLimit</code>. If no such value exists then nothing is returned. </p>

<p class="definition">Definition at line <a class="el" href="IntervalMap_8h_source.html#l00724">724</a> of file <a class="el" href="IntervalMap_8h_source.html">IntervalMap.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="IntervalSet_8h_source.html#l00439">Sawyer::Container::IntervalSet&lt; Interval &gt;::leastNonExistent()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1IntervalMap_a0d679a902269aaa699bcf8a4999c17c3_icgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1IntervalMap_a0d679a902269aaa699bcf8a4999c17c3_icgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1IntervalMap_a0d679a902269aaa699bcf8a4999c17c3_icgraph" id="classSawyer_1_1Container_1_1IntervalMap_a0d679a902269aaa699bcf8a4999c17c3_icgraph">
<area shape="rect" title="Returns the limited&#45;minimum unmapped scalar key." alt="" coords="196,13,385,54"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalSet.html#ae94588105e1a294bb196242f958afbd2" title="Returns the limited&#45;minimum scalar not contained in this set." alt="" coords="5,5,148,61"/>
</map>
</div>

</div>
</div>
<a id="a7059f415687b5e7caec66dd7f4b133a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7059f415687b5e7caec66dd7f4b133a2">&#9670;&nbsp;</a></span>greatestUnmapped()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename T , class Policy  = MergePolicy&lt;I, T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt;typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a>&gt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">Sawyer::Container::IntervalMap</a>&lt; I, T, Policy &gt;::greatestUnmapped </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a>&#160;</td>
          <td class="paramname"><em>upperLimit</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the limited-maximum unmapped scalar key. </p>
<p>Returns the maximum unmapped scalar key equal to or less than the <code>upperLimit</code>. If no such value exists then nothing is returned. </p>

<p class="definition">Definition at line <a class="el" href="IntervalMap_8h_source.html#l00739">739</a> of file <a class="el" href="IntervalMap_8h_source.html">IntervalMap.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="IntervalSet_8h_source.html#l00447">Sawyer::Container::IntervalSet&lt; Interval &gt;::greatestNonExistent()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1IntervalMap_a7059f415687b5e7caec66dd7f4b133a2_icgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1IntervalMap_a7059f415687b5e7caec66dd7f4b133a2_icgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1IntervalMap_a7059f415687b5e7caec66dd7f4b133a2_icgraph" id="classSawyer_1_1Container_1_1IntervalMap_a7059f415687b5e7caec66dd7f4b133a2_icgraph">
<area shape="rect" title="Returns the limited&#45;maximum unmapped scalar key." alt="" coords="215,13,423,54"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalSet.html#a9ea02f05d9c76508adadeb2ad836abc6" title="Returns the limited&#45;maximum scalar not contained in this set." alt="" coords="5,5,167,61"/>
</map>
</div>

</div>
</div>
<a id="a3e96516680b59244ef196a9e885ac0ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e96516680b59244ef196a9e885ac0ca">&#9670;&nbsp;</a></span>eraseMultiple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename T , class Policy  = MergePolicy&lt;I, T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename T2 , class Policy2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">Sawyer::Container::IntervalMap</a>&lt; I, T, Policy &gt;::eraseMultiple </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, T2, Policy2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase intervals specified in another <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html" title="An associative container whose keys are non-overlapping intervals.">IntervalMap</a>. </p>
<p>Every interval in <code>other</code> is erased from this container. </p>

<p class="definition">Definition at line <a class="el" href="IntervalMap_8h_source.html#l00827">827</a> of file <a class="el" href="IntervalMap_8h_source.html">IntervalMap.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="IntervalSet_8h_source.html#l00600">Sawyer::Container::IntervalSet&lt; Interval &gt;::intersect()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1IntervalMap_a3e96516680b59244ef196a9e885ac0ca_icgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1IntervalMap_a3e96516680b59244ef196a9e885ac0ca_icgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1IntervalMap_a3e96516680b59244ef196a9e885ac0ca_icgraph" id="classSawyer_1_1Container_1_1IntervalMap_a3e96516680b59244ef196a9e885ac0ca_icgraph">
<area shape="rect" title="Erase intervals specified in another IntervalMap." alt="" coords="193,13,368,54"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalSet.html#a8b3c2ce68a964257e503c092c31ad490" title=" " alt="" coords="5,5,145,61"/>
</map>
</div>

</div>
</div>
<a id="a1effdf10ccfb80ed11cc999e850ab2bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1effdf10ccfb80ed11cc999e850ab2bd">&#9670;&nbsp;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename T , class Policy  = MergePolicy&lt;I, T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">Sawyer::Container::IntervalMap</a>&lt; I, T, Policy &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a7c7ef387287aa01aa632dfeafc121e95">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>makeHole</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a key/value pair. </p>
<p>If <code>makeHole</code> is true then the interval being inserted is first erased; otherwise the insertion happens only if none of the interval being inserted already exists in the container. <br  />
 </p>

<p class="definition">Definition at line <a class="el" href="IntervalMap_8h_source.html#l00838">838</a> of file <a class="el" href="IntervalMap_8h_source.html">IntervalMap.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="IntervalSet_8h_source.html#l00532">Sawyer::Container::IntervalSet&lt; Interval &gt;::insert()</a>, <a class="el" href="IntervalSet_8h_source.html#l00537">Sawyer::Container::IntervalSet&lt; Interval &gt;::insertMultiple()</a>, <a class="el" href="IntervalMap_8h_source.html#l00883">Sawyer::Container::IntervalMap&lt; Interval, int &gt;::insertMultiple()</a>, <a class="el" href="IntervalMap_8h_source.html#l00253">Sawyer::Container::IntervalMap&lt; Interval, int &gt;::IntervalMap()</a>, and <a class="el" href="IntervalMap_8h_source.html#l00264">Sawyer::Container::IntervalMap&lt; Interval, int &gt;::operator=()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1IntervalMap_a1effdf10ccfb80ed11cc999e850ab2bd_icgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1IntervalMap_a1effdf10ccfb80ed11cc999e850ab2bd_icgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1IntervalMap_a1effdf10ccfb80ed11cc999e850ab2bd_icgraph" id="classSawyer_1_1Container_1_1IntervalMap_a1effdf10ccfb80ed11cc999e850ab2bd_icgraph">
<area shape="rect" title="Insert a key/value pair." alt="" coords="203,173,341,214"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalSet.html#a8ba417febcca9d50fc16258470d6d176" title="Insert specified values." alt="" coords="10,5,150,61"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalSet.html#ad824ae22039a8d85cfbd0c7592e39928" title=" " alt="" coords="10,85,150,141"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalMap.html#af596a5898489cd4c86320bd5a1aa4307" title="Insert values from another container." alt="" coords="5,165,155,221"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalMap.html#a5eec51514347acfef76b9b4a65654bcc" title="Copy constructor." alt="" coords="5,245,155,301"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalMap.html#a86104e9747b2afce6b47d1fa30ffa5df" title="Assignment operator." alt="" coords="5,325,155,381"/>
</map>
</div>

</div>
</div>
<a id="af596a5898489cd4c86320bd5a1aa4307"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af596a5898489cd4c86320bd5a1aa4307">&#9670;&nbsp;</a></span>insertMultiple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename T , class Policy  = MergePolicy&lt;I, T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename T2 , class Policy2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">Sawyer::Container::IntervalMap</a>&lt; I, T, Policy &gt;::insertMultiple </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, T2, Policy2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>makeHole</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert values from another container. </p>
<p>The values in the other container must be convertable to values of this container, and the intervals must be the same type. </p>

<p class="definition">Definition at line <a class="el" href="IntervalMap_8h_source.html#l00883">883</a> of file <a class="el" href="IntervalMap_8h_source.html">IntervalMap.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="IntervalMap_8h_source.html">IntervalMap.h</a></li>
</ul>
</div><!-- contents -->
<div class="ttc" id="aclassSawyer_1_1Container_1_1IntervalMap_html_a664961032974fd71f132d8931edd68de"><div class="ttname"><a href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Sawyer::Container::IntervalMap::Interval</a></div><div class="ttdeci">I Interval</div><div class="ttdoc">Interval type.</div><div class="ttdef"><b>Definition:</b> <a href="IntervalMap_8h_source.html#l00173">IntervalMap.h:173</a></div></div>
<div class="ttc" id="aclassSawyer_1_1Container_1_1IntervalMap_html_ae27b32aea90cdef93228cd5c978c00ef"><div class="ttname"><a href="classSawyer_1_1Container_1_1IntervalMap.html#ae27b32aea90cdef93228cd5c978c00ef">Sawyer::Container::IntervalMap::Map</a></div><div class="ttdeci">Container::Map&lt; Interval, Value, IntervalCompare &gt; Map</div><div class="ttdoc">Type of the underlying map.</div><div class="ttdef"><b>Definition:</b> <a href="IntervalMap_8h_source.html#l00190">IntervalMap.h:190</a></div></div>
<div class="ttc" id="aclassSawyer_1_1Container_1_1Interval_html"><div class="ttname"><a href="classSawyer_1_1Container_1_1Interval.html">Sawyer::Container::Interval</a></div><div class="ttdoc">Range of values delimited by endpoints.</div><div class="ttdef"><b>Definition:</b> <a href="Interval_8h_source.html#l00033">Interval.h:33</a></div></div>
<div class="ttc" id="aclassMap_html"><div class="ttname"><a href="classMap.html">Map</a></div><div class="ttdoc">Extends std::map with methods that return optional values.</div><div class="ttdef"><b>Definition:</b> <a href="Map_8h_source.html#l00010">Map.h:10</a></div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Dec 19 2022 23:40:27 for ROSE by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
