<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROSE: Sawyer::CommandLine::ParserResult Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="ROSE"/>
<link href="roseDoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ROSE
   &#160;<span id="projectnumber">0.11.96.11</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,true,'search.html','Search');
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceSawyer.html">Sawyer</a></li><li class="navelem"><a class="el" href="namespaceSawyer_1_1CommandLine.html">CommandLine</a></li><li class="navelem"><a class="el" href="classSawyer_1_1CommandLine_1_1ParserResult.html">ParserResult</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classSawyer_1_1CommandLine_1_1ParserResult-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Sawyer::CommandLine::ParserResult Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>The result from parsing a command line. </p>
<p>The <a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#acadfcac830d7855ae15b39ef9ce1aebb" title="Parse program arguments.">Parser::parse</a> methods parse a command line without causing any side effects, placing all results in a <a class="el" href="classSawyer_1_1CommandLine_1_1ParserResult.html" title="The result from parsing a command line.">ParserResult</a> return value. If parsing is successful, the user then queries the result (a "pull" paradigm) or applies the result (a "push" paradigm), or both. In fact, even when the user only needs the pull paradigm for its own switches, it should still call <a class="el" href="classSawyer_1_1CommandLine_1_1ParserResult.html#af75c7bf22bda158f25eeb38a42e8da3d">apply</a> anyway so that other software layers whose switch groups may have been included in the parser will receive values for their program variables and have their actions called.</p>
<div class="fragment"><div class="line">SwitchGroup switches;</div>
<div class="line">Parser <a class="code" href="classSawyer_1_1CommandLine_1_1ParserResult.html#a0c17a5fc45a2796e8174091e97cda2c6">parser</a>;</div>
<div class="line"><a class="code" href="classSawyer_1_1CommandLine_1_1ParserResult.html#a0c17a5fc45a2796e8174091e97cda2c6">parser</a>.insert(switches);</div>
<div class="line">ParserResult cmdline = <a class="code" href="classSawyer_1_1CommandLine_1_1ParserResult.html#a0c17a5fc45a2796e8174091e97cda2c6">parser</a>.<a class="code" href="classSawyer_1_1CommandLine_1_1Parser.html#acadfcac830d7855ae15b39ef9ce1aebb">parse</a>(argc, argv);</div>
<div class="line">cmdline.<a class="code" href="classSawyer_1_1CommandLine_1_1ParserResult.html#af75c7bf22bda158f25eeb38a42e8da3d">apply</a>();</div>
</div><!-- fragment --><p>In fact, if the user doesn't need to do any querying (they use only the push paradigm), there's no reason he even needs to keep the parser result (or even the parser) in a variable:</p>
<div class="fragment"><div class="line">SwitchGroup switches;</div>
<div class="line">Parser().with(switches).parse(argc, argv).apply();</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="util_2Sawyer_2CommandLine_8h_source.html#l03333">3333</a> of file <a class="el" href="util_2Sawyer_2CommandLine_8h_source.html">util/Sawyer/CommandLine.h</a>.</p>
</div>
<p><code>#include &lt;<a class="el" href="util_2Sawyer_2CommandLine_8h_source.html">CommandLine.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af75c7bf22bda158f25eeb38a42e8da3d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSawyer_1_1CommandLine_1_1ParserResult.html">ParserResult</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1ParserResult.html#af75c7bf22bda158f25eeb38a42e8da3d">apply</a> () const</td></tr>
<tr class="memdesc:af75c7bf22bda158f25eeb38a42e8da3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves parsed values in switch-specified locations.  <a href="classSawyer_1_1CommandLine_1_1ParserResult.html#af75c7bf22bda158f25eeb38a42e8da3d">More...</a><br /></td></tr>
<tr class="separator:af75c7bf22bda158f25eeb38a42e8da3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8e40b0fb2c6534c767221f869e785da"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1ParserResult.html#ad8e40b0fb2c6534c767221f869e785da">have</a> (const std::string &amp;switchKey) const</td></tr>
<tr class="memdesc:ad8e40b0fb2c6534c767221f869e785da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of values for the specified key.  <a href="classSawyer_1_1CommandLine_1_1ParserResult.html#ad8e40b0fb2c6534c767221f869e785da">More...</a><br /></td></tr>
<tr class="separator:ad8e40b0fb2c6534c767221f869e785da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50aa5cf81a257170f300cf1c7830a7e7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1ParserResult.html#a50aa5cf81a257170f300cf1c7830a7e7">skippedArgs</a> () const</td></tr>
<tr class="memdesc:a50aa5cf81a257170f300cf1c7830a7e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Program arguments that were skipped over during parsing.  <a href="classSawyer_1_1CommandLine_1_1ParserResult.html#a50aa5cf81a257170f300cf1c7830a7e7">More...</a><br /></td></tr>
<tr class="separator:a50aa5cf81a257170f300cf1c7830a7e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb12de01fb93e275271878c0ea18b471"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1ParserResult.html#abb12de01fb93e275271878c0ea18b471">unreachedArgs</a> () const</td></tr>
<tr class="memdesc:abb12de01fb93e275271878c0ea18b471"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns program arguments that were not reached during parsing.  <a href="classSawyer_1_1CommandLine_1_1ParserResult.html#abb12de01fb93e275271878c0ea18b471">More...</a><br /></td></tr>
<tr class="separator:abb12de01fb93e275271878c0ea18b471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5f91e35b29e051715344bee50539910"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1ParserResult.html#aa5f91e35b29e051715344bee50539910">unparsedArgs</a> (bool includeTerminators=false) const</td></tr>
<tr class="memdesc:aa5f91e35b29e051715344bee50539910"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns unparsed switches.  <a href="classSawyer_1_1CommandLine_1_1ParserResult.html#aa5f91e35b29e051715344bee50539910">More...</a><br /></td></tr>
<tr class="separator:aa5f91e35b29e051715344bee50539910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab34131f54e35489a11054084d6ca0aa"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1ParserResult.html#aab34131f54e35489a11054084d6ca0aa">parsedArgs</a> () const</td></tr>
<tr class="memdesc:aab34131f54e35489a11054084d6ca0aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the program arguments that were processed.  <a href="classSawyer_1_1CommandLine_1_1ParserResult.html#aab34131f54e35489a11054084d6ca0aa">More...</a><br /></td></tr>
<tr class="separator:aab34131f54e35489a11054084d6ca0aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98cfa6a7956828b6139c3b684085c86a"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1ParserResult.html#a98cfa6a7956828b6139c3b684085c86a">allArgs</a> () const</td></tr>
<tr class="memdesc:a98cfa6a7956828b6139c3b684085c86a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The original command line.  <a href="classSawyer_1_1CommandLine_1_1ParserResult.html#a98cfa6a7956828b6139c3b684085c86a">More...</a><br /></td></tr>
<tr class="separator:a98cfa6a7956828b6139c3b684085c86a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c17a5fc45a2796e8174091e97cda2c6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Parser</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1ParserResult.html#a0c17a5fc45a2796e8174091e97cda2c6">parser</a> () const</td></tr>
<tr class="memdesc:a0c17a5fc45a2796e8174091e97cda2c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">That parser that created this result.  <a href="classSawyer_1_1CommandLine_1_1ParserResult.html#a0c17a5fc45a2796e8174091e97cda2c6">More...</a><br /></td></tr>
<tr class="separator:a0c17a5fc45a2796e8174091e97cda2c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a9378bbcf0cdebf548ae82b7e145c9ef6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSawyer_1_1CommandLine_1_1ParsedValue.html">ParsedValue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1ParserResult.html#a9378bbcf0cdebf548ae82b7e145c9ef6">parsed</a> (const std::string &amp;switchKey, size_t idx) const</td></tr>
<tr class="memdesc:a9378bbcf0cdebf548ae82b7e145c9ef6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns values for a key.  <a href="classSawyer_1_1CommandLine_1_1ParserResult.html#a9378bbcf0cdebf548ae82b7e145c9ef6">More...</a><br /></td></tr>
<tr class="separator:a9378bbcf0cdebf548ae82b7e145c9ef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11bbca3228fe6667584bad73a8db6567"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSawyer_1_1CommandLine.html#a1498f834e8579914eaefcb96b0cf0d76">ParsedValues</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1ParserResult.html#a11bbca3228fe6667584bad73a8db6567">parsed</a> (const std::string &amp;switchKey) const</td></tr>
<tr class="memdesc:a11bbca3228fe6667584bad73a8db6567"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns values for a key.  <a href="classSawyer_1_1CommandLine_1_1ParserResult.html#a11bbca3228fe6667584bad73a8db6567">More...</a><br /></td></tr>
<tr class="separator:a11bbca3228fe6667584bad73a8db6567"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af75c7bf22bda158f25eeb38a42e8da3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af75c7bf22bda158f25eeb38a42e8da3d">&#9670;&nbsp;</a></span>apply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSawyer_1_1CommandLine_1_1ParserResult.html">ParserResult</a>&amp; Sawyer::CommandLine::ParserResult::apply </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Saves parsed values in switch-specified locations. </p>
<p>This method implements the <em>push</em> paradigm mentioned in the class documentation (see <a class="el" href="classSawyer_1_1CommandLine_1_1ParserResult.html">ParserResult</a>). </p>

<p class="reference">Referenced by <a class="el" href="CommandLineBoost_8h_source.html#l00128">Sawyer::CommandLine::Boost::command_line_parser::run()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1CommandLine_1_1ParserResult_af75c7bf22bda158f25eeb38a42e8da3d_icgraph.png" border="0" usemap="#classSawyer_1_1CommandLine_1_1ParserResult_af75c7bf22bda158f25eeb38a42e8da3d_icgraph" alt=""/></div>
<map name="classSawyer_1_1CommandLine_1_1ParserResult_af75c7bf22bda158f25eeb38a42e8da3d_icgraph" id="classSawyer_1_1CommandLine_1_1ParserResult_af75c7bf22bda158f25eeb38a42e8da3d_icgraph">
<area shape="rect" title="Saves parsed values in switch&#45;specified locations." alt="" coords="212,13,371,54"/>
<area shape="rect" href="structSawyer_1_1CommandLine_1_1Boost_1_1command__line__parser.html#a90a5bda4bc9ddf8583961d901687de11" title="Parse command&#45;line." alt="" coords="5,5,164,61"/>
</map>
</div>

</div>
</div>
<a id="ad8e40b0fb2c6534c767221f869e785da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8e40b0fb2c6534c767221f869e785da">&#9670;&nbsp;</a></span>have()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Sawyer::CommandLine::ParserResult::have </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>switchKey</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of values for the specified key. </p>
<p>This is the number of values actually stored for switches using this key, which might be fewer than the number of values parsed. See <a class="el" href="classSawyer_1_1CommandLine_1_1Switch.html#a4c8f89b25df14aeaef4309e477ff5baf" title="Property: how to handle multiple occurrences.">Switch::whichValue</a>. </p>

<p class="definition">Definition at line <a class="el" href="util_2Sawyer_2CommandLine_8h_source.html#l03375">3375</a> of file <a class="el" href="util_2Sawyer_2CommandLine_8h_source.html">util/Sawyer/CommandLine.h</a>.</p>

<p class="reference">References <a class="el" href="Sawyer_2Map_8h_source.html#l00586">Sawyer::Container::Map&lt; K, T, Cmp, Alloc &gt;::getOrDefault()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1CommandLine_1_1ParserResult_ad8e40b0fb2c6534c767221f869e785da_cgraph.png" border="0" usemap="#classSawyer_1_1CommandLine_1_1ParserResult_ad8e40b0fb2c6534c767221f869e785da_cgraph" alt=""/></div>
<map name="classSawyer_1_1CommandLine_1_1ParserResult_ad8e40b0fb2c6534c767221f869e785da_cgraph" id="classSawyer_1_1CommandLine_1_1ParserResult_ad8e40b0fb2c6534c767221f869e785da_cgraph">
<area shape="rect" title="Returns the number of values for the specified key." alt="" coords="5,5,164,47"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Map.html#af32b7718b7f403d39d6d23f7ff2a1cc6" title="Lookup and return a value or a default." alt="" coords="212,5,351,47"/>
</map>
</div>

</div>
</div>
<a id="a9378bbcf0cdebf548ae82b7e145c9ef6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9378bbcf0cdebf548ae82b7e145c9ef6">&#9670;&nbsp;</a></span>parsed() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSawyer_1_1CommandLine_1_1ParsedValue.html">ParsedValue</a>&amp; Sawyer::CommandLine::ParserResult::parsed </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>switchKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns values for a key. </p>
<p>This is the usual method for obtaining a value for a switch. During parsing, the arguments of the switch are converted to <a class="el" href="classSawyer_1_1CommandLine_1_1ParsedValue.html">ParsedValue</a> objects and stored according to the key of the switch that did the parsing. For example, if <code>--verbose</code> has an intrinsic value of 1, and <code>--quiet</code> has a value of 0, and both use a "verbosity" key to store their result, here's how one would obtain the value for the last occurrence of either of these switches:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> verbosity = cmdline.parsed(<span class="stringliteral">&quot;verbosity&quot;</span>).last().asInt();</div>
</div><!-- fragment --><p>If it is known that the switches both had a <a class="el" href="classSawyer_1_1CommandLine_1_1Switch.html#a4c8f89b25df14aeaef4309e477ff5baf" title="Property: how to handle multiple occurrences.">Switch::whichValue</a> property that was <a class="el" href="namespaceSawyer_1_1CommandLine.html#af899da0d7a5cac914ffe619bd68a6baba227809cd883545876cfa2aca82592ce6">SAVE_LAST</a> then the more efficient version of <code>parse</code> with an index can be used:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> verbosity = cmdline.parsed(<span class="stringliteral">&quot;verbosity&quot;</span>, 0).asInt();</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a11bbca3228fe6667584bad73a8db6567"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11bbca3228fe6667584bad73a8db6567">&#9670;&nbsp;</a></span>parsed() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSawyer_1_1CommandLine.html#a1498f834e8579914eaefcb96b0cf0d76">ParsedValues</a> Sawyer::CommandLine::ParserResult::parsed </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>switchKey</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns values for a key. </p>
<p>This is the usual method for obtaining a value for a switch. During parsing, the arguments of the switch are converted to <a class="el" href="classSawyer_1_1CommandLine_1_1ParsedValue.html">ParsedValue</a> objects and stored according to the key of the switch that did the parsing. For example, if <code>--verbose</code> has an intrinsic value of 1, and <code>--quiet</code> has a value of 0, and both use a "verbosity" key to store their result, here's how one would obtain the value for the last occurrence of either of these switches:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> verbosity = cmdline.parsed(<span class="stringliteral">&quot;verbosity&quot;</span>).last().asInt();</div>
</div><!-- fragment --><p>If it is known that the switches both had a <a class="el" href="classSawyer_1_1CommandLine_1_1Switch.html#a4c8f89b25df14aeaef4309e477ff5baf" title="Property: how to handle multiple occurrences.">Switch::whichValue</a> property that was <a class="el" href="namespaceSawyer_1_1CommandLine.html#af899da0d7a5cac914ffe619bd68a6baba227809cd883545876cfa2aca82592ce6">SAVE_LAST</a> then the more efficient version of <code>parse</code> with an index can be used:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> verbosity = cmdline.parsed(<span class="stringliteral">&quot;verbosity&quot;</span>, 0).asInt();</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a50aa5cf81a257170f300cf1c7830a7e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50aa5cf81a257170f300cf1c7830a7e7">&#9670;&nbsp;</a></span>skippedArgs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; Sawyer::CommandLine::ParserResult::skippedArgs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Program arguments that were skipped over during parsing. </p>
<p>If the <a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a2951ca435c212c2c9f07d09fc76ae49a" title="Whether to skip over unrecognized switches.">Parser::skippingUnknownSwitches</a> or <a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a38ff18e51b3dc070547777e9d8dd6181" title="Whether to skip over non-switch arguments when parsing.">Parser::skippingNonSwitches</a> properties are true, then this method returns those command-line arguments that the parser skipped. The library makes no distinction between these two classes of skipping because in general, it is impossible to be accurate about it (see <a class="el" href="classSawyer_1_1CommandLine_1_1SwitchGroup.html">SwitchGroup</a> for an example).</p>
<p>Program arguments inserted into the command line due to file inclusion will be returned in place of the file inclusion switch itself.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSawyer_1_1CommandLine_1_1ParserResult.html#aa5f91e35b29e051715344bee50539910" title="Returns unparsed switches.">unparsedArgs</a> </dd></dl>

</div>
</div>
<a id="abb12de01fb93e275271878c0ea18b471"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb12de01fb93e275271878c0ea18b471">&#9670;&nbsp;</a></span>unreachedArgs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; Sawyer::CommandLine::ParserResult::unreachedArgs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns program arguments that were not reached during parsing. </p>
<p>These are the arguments left over when the parser stopped. Program arguments inserted into the command line due to file inclusion will be returned in place of the file inclusion switch itself.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSawyer_1_1CommandLine_1_1ParserResult.html#aa5f91e35b29e051715344bee50539910" title="Returns unparsed switches.">unparsedArgs</a> </dd></dl>

</div>
</div>
<a id="aa5f91e35b29e051715344bee50539910"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5f91e35b29e051715344bee50539910">&#9670;&nbsp;</a></span>unparsedArgs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; Sawyer::CommandLine::ParserResult::unparsedArgs </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>includeTerminators</em> = <code>false</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns unparsed switches. </p>
<p>Unparsed switches are those returned by <a class="el" href="classSawyer_1_1CommandLine_1_1ParserResult.html#a50aa5cf81a257170f300cf1c7830a7e7">skippedArgs</a> and <a class="el" href="classSawyer_1_1CommandLine_1_1ParserResult.html#abb12de01fb93e275271878c0ea18b471">unreachedArgs</a>.</p>
<p>The returned list includes termination switches (like <code>--</code>) if <code>includeTerminators</code> is true even if those switches were parsed. This can be useful when the parser is being used to remove recognized switches from a command-line. If the original command line was <code>--theirs --mine -- --other</code> and the parser recognizes only <code>--mine</code> and the <code>--</code> terminator, then the caller would probably want to pass <code>--theirs -- --other</code> to the next software layer, which is exactly what this method returns when <code>includeTerminators</code> is true. <b>Beware:</b> removing command-line arguments that are recognized by a parser that has an incomplete picture of the entire language is not wise&ndash;see <a class="el" href="classSawyer_1_1CommandLine_1_1SwitchGroup.html">SwitchGroup</a> for an example that fails.</p>
<p>Program arguments inserted into the command-line due to file inclusion will be returned in place of the file inclusion switch itself. </p>

</div>
</div>
<a id="aab34131f54e35489a11054084d6ca0aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab34131f54e35489a11054084d6ca0aa">&#9670;&nbsp;</a></span>parsedArgs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; Sawyer::CommandLine::ParserResult::parsedArgs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the program arguments that were processed. </p>
<p>This includes terminator switches that were parsed.</p>
<p>Program arguments inserted into the command-line due to file inclusion will be returned in place of the file inclusion switch itself. </p>

</div>
</div>
<a id="a98cfa6a7956828b6139c3b684085c86a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98cfa6a7956828b6139c3b684085c86a">&#9670;&nbsp;</a></span>allArgs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;std::string&gt;&amp; Sawyer::CommandLine::ParserResult::allArgs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The original command line. </p>
<p>This returns the original command line except that program arguments inserted into the command-line due to file inclusion will be returned in place of the file inclusion switch itself. </p>

<p class="definition">Definition at line <a class="el" href="util_2Sawyer_2CommandLine_8h_source.html#l03447">3447</a> of file <a class="el" href="util_2Sawyer_2CommandLine_8h_source.html">util/Sawyer/CommandLine.h</a>.</p>

<p class="reference">References <a class="el" href="util_2Sawyer_2CommandLine_8h_source.html#l00273">Sawyer::CommandLine::Cursor::strings()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1CommandLine_1_1ParserResult_a98cfa6a7956828b6139c3b684085c86a_cgraph.png" border="0" usemap="#classSawyer_1_1CommandLine_1_1ParserResult_a98cfa6a7956828b6139c3b684085c86a_cgraph" alt=""/></div>
<map name="classSawyer_1_1CommandLine_1_1ParserResult_a98cfa6a7956828b6139c3b684085c86a_cgraph" id="classSawyer_1_1CommandLine_1_1ParserResult_a98cfa6a7956828b6139c3b684085c86a_cgraph">
<area shape="rect" title="The original command line." alt="" coords="5,5,164,47"/>
<area shape="rect" href="classSawyer_1_1CommandLine_1_1Cursor.html#a566079ae435a9210900dbbb3bd831237" title="All strings for the cursor." alt="" coords="212,5,371,47"/>
</map>
</div>

</div>
</div>
<a id="a0c17a5fc45a2796e8174091e97cda2c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c17a5fc45a2796e8174091e97cda2c6">&#9670;&nbsp;</a></span>parser()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Parser</a>&amp; Sawyer::CommandLine::ParserResult::parser </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>That parser that created this result. </p>
<p>This is a copy of the parser that was used to create this result. </p>

<p class="definition">Definition at line <a class="el" href="util_2Sawyer_2CommandLine_8h_source.html#l03450">3450</a> of file <a class="el" href="util_2Sawyer_2CommandLine_8h_source.html">util/Sawyer/CommandLine.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="util_2Sawyer_2CommandLine_8h_source.html">util/Sawyer/CommandLine.h</a></li>
</ul>
</div><!-- contents -->
<div class="ttc" id="aclassSawyer_1_1CommandLine_1_1ParserResult_html_af75c7bf22bda158f25eeb38a42e8da3d"><div class="ttname"><a href="classSawyer_1_1CommandLine_1_1ParserResult.html#af75c7bf22bda158f25eeb38a42e8da3d">Sawyer::CommandLine::ParserResult::apply</a></div><div class="ttdeci">const ParserResult &amp; apply() const</div><div class="ttdoc">Saves parsed values in switch-specified locations.</div></div>
<div class="ttc" id="aclassSawyer_1_1CommandLine_1_1ParserResult_html_a0c17a5fc45a2796e8174091e97cda2c6"><div class="ttname"><a href="classSawyer_1_1CommandLine_1_1ParserResult.html#a0c17a5fc45a2796e8174091e97cda2c6">Sawyer::CommandLine::ParserResult::parser</a></div><div class="ttdeci">const Parser &amp; parser() const</div><div class="ttdoc">That parser that created this result.</div><div class="ttdef"><b>Definition:</b> <a href="util_2Sawyer_2CommandLine_8h_source.html#l03450">util/Sawyer/CommandLine.h:3450</a></div></div>
<div class="ttc" id="aclassSawyer_1_1CommandLine_1_1Parser_html_acadfcac830d7855ae15b39ef9ce1aebb"><div class="ttname"><a href="classSawyer_1_1CommandLine_1_1Parser.html#acadfcac830d7855ae15b39ef9ce1aebb">Sawyer::CommandLine::Parser::parse</a></div><div class="ttdeci">ParserResult parse(int argc, char *argv[])</div><div class="ttdoc">Parse program arguments.</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Dec 19 2022 23:40:26 for ROSE by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
