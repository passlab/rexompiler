<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROSE: Rose::Progress Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="ROSE"/>
<link href="roseDoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ROSE
   &#160;<span id="projectnumber">0.11.96.11</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,true,'search.html','Search');
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceRose.html">Rose</a></li><li class="navelem"><a class="el" href="classRose_1_1Progress.html">Progress</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classRose_1_1Progress-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Rose::Progress Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>A general, thread-safe way to report progress made on some task. </p>
<p>Consider some long-running task that needs to be performed by some worker thread or collection of worker threads. There may be other unrelated listener threads that need to monitor the progress of the task, such as a GUI thread that updates a progress bar widget. This can be accomplished in a general way by having an intermediatey object to which workers can write progress reports and other threads can query those reports.</p>
<p>The intention is that each long-running task will have its own <a class="el" href="classRose_1_1Progress.html">Progress</a> object into which reports are written, and the report will be a floating point number between zero (work just started) and one (work is almost complete). When work on the task completes (either because the task was finished or it had an error), one of the workers calls <a class="el" href="classRose_1_1Progress.html#a50547f5d77a159087f1965a716333db2">finished</a> to let all the listeners know there will be nothing new to report.</p>
<p>Sometimes a task has multiple phases and it's hard to predict the total amount of work across all phases before earlier phases have completed. Therefore, progress reports have two parts: not only do they have a completion amount, they also have a phase name. When a <a class="el" href="classRose_1_1Progress.html">Progress</a> object is first created, its phase name is empty and the completion amount is zero. There is no intrinsic <a class="el" href="classRose_1_1Progress.html">Progress</a> requirement that phases occur in any particular order, or that the completion amount is monotonically increasing, or that the completion amount is in the interval [0..1] although listeners might be expecting certain things.</p>
<p>In order to support a hierarchy of reports, such as when one long running analysis calls other long-running analyses and they in turn also have multiple phases, the progress object has a stack of reports that is adjusted with <a class="el" href="classRose_1_1Progress.html#aa55171e954ec5fb3e1e46d0177f0dcb9">push</a> and <a class="el" href="classRose_1_1Progress.html#ac7696b5beb55b758f1eaee060a20b8fc">pop</a> methods. When progress is reported to a listener, the listener has a choice between getting the name of the top-most report or getting a name that is constructed by joining all the non-empty names in the stack. There's also a <a class="el" href="classRose_1_1ProgressTask.html">ProgressTask</a> class that does the push and pop using RAII.</p>
<p>Each <a class="el" href="classRose_1_1Progress.html">Progress</a> object is shared between worker threads and querying threads&ndash;it cannot be deleted when the last worker is finished because other threads might still be listening, and it cannot be deleted when nothing is listening because workers might still need to write progress reports to it. Therefore each <a class="el" href="classRose_1_1Progress.html">Progress</a> object is allocated on the heap and referenced through thread-safe, shared-ownership pointers. Allocation is done by the <a class="el" href="classRose_1_1Progress.html#a7942800cd0fb8e583ecbeb67935cd978">instance</a> factory and the object should not be explicitly deleted by the user.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// function that does lots of work and optionally reports its progress.</span></div>
<div class="line"><span class="keywordtype">void</span> worker(<a class="code" href="classRose_1_1Progress.html#af0404702f80eb9dc773a9c26b2f88d21">Progress::Ptr</a> progress) {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; 1000000; ++i) {</div>
<div class="line">        do_some_work();</div>
<div class="line">        <span class="keywordflow">if</span> (progress)</div>
<div class="line">            progress-&gt;update((<span class="keywordtype">double</span>)i/1000000);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (progress)</div>
<div class="line">        progress-&gt;finished(1.0);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Start a worker and provide a way for it to report its progress</span></div>
<div class="line"><a class="code" href="classRose_1_1Progress.html#af0404702f80eb9dc773a9c26b2f88d21">Progress::Ptr</a> progress = <a class="code" href="classRose_1_1Progress.html#a7942800cd0fb8e583ecbeb67935cd978">Progress::instance</a>();</div>
<div class="line">boost::thread_t worker(worker, progress);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Report progress on standard error each time it changes, but not more than once every 10 seconds</span></div>
<div class="line">progress-&gt;reportChanges(boost::chrono::seconds(10), [](<span class="keyword">const</span> Progress::Report &amp;rpt) -&gt; <span class="keywordtype">bool</span> {</div>
<div class="line">    std::cout &lt;&lt;rpt.phase &lt;&lt;<span class="stringliteral">&quot;: &quot;</span> &lt;&lt;(100*rpt.completion) &lt;&lt;<span class="stringliteral">&quot; percent completed\n&quot;</span>;</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>; <span class="comment">// keep listening until task is finished</span></div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Or report progress every 10 seconds whether it changed or not</span></div>
<div class="line">progress-&gt;reportRegularly(boost::chrono::seconds(10), [](<span class="keyword">const</span> Progress::Report &amp;rpt, <span class="keywordtype">double</span> age) -&gt; <span class="keywordtype">bool</span> {</div>
<div class="line">    std::cout &lt;&lt;rpt.phase &lt;&lt;<span class="stringliteral">&quot;: &quot;</span> &lt;&lt;(100*rpt.completion) &lt;&lt;<span class="stringliteral">&quot; percent completed\n&quot;</span>;</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>; <span class="comment">// keep listening until task is finished</span></div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Or query the progress in an event loop</span></div>
<div class="line"><span class="keywordflow">while</span> (!progress-&gt;isFinished()) {</div>
<div class="line">    Progress::Report rpt = progress-&gt;reportLatest().first;</div>
<div class="line">    std::cout &lt;&lt;rpt.phase &lt;&lt;<span class="stringliteral">&quot;: &quot;</span> &lt;&lt;(100*rpt.completion) &lt;&lt;<span class="stringliteral">&quot; percent completed\n&quot;</span>;</div>
<div class="line">    do_other_stuff();</div>
<div class="line">}</div>
</div><!-- fragment --><p>The following guidelines should be used when writing a long-running task, such as a ROSE analysis or transformation, that supports progress reporting. These guidelines assume that the task is encapsulated in a class (as most analyses and transformations should be) so that an application is able to have more than one instance of the task. A task that's implemented as a single function should take an argument of type <code>const <a class="el" href="classRose_1_1Progress.html#af0404702f80eb9dc773a9c26b2f88d21" title="Progress objects are reference counted.">Rose::Progress::Ptr</a>&amp;</code> (which may be a null progress object), and a task that's implemented in a namespace should try to provide an API similar to a class (the main difference will be that there's only once "instance" of the analysis).</p>
<ul>
<li>The task class should have a private data member to hold a <a class="el" href="classRose_1_1Progress.html#af0404702f80eb9dc773a9c26b2f88d21">Progress::Ptr</a>.</li>
</ul>
<ul>
<li>The class should initialize its progress reporter variable to a non-null value by calling <a class="el" href="classRose_1_1Progress.html#a7942800cd0fb8e583ecbeb67935cd978">Progress::instance</a> during construction. The user can reset this to null if he really doesn't want the task to spend any time updating progress reports.</li>
</ul>
<ul>
<li>The class should provide an API for users to query or change the progress report for any particular task. The preferred protyptes are "Rose::Progress::Ptr progress() const" and "void progress(const Rose::Progress::Ptr&amp;)" although you should use whatever scheme is consistent with the rest of your API.</li>
</ul>
<ul>
<li>The task should expect that the progress object could be null, in which case the user is saying that there's no need for the analyzer to spend time updating any progress reports because nobody will be listening for them.</li>
</ul>
<ul>
<li>The task should update the progress with a completion ratio between 0 and 1 without specifying a phase name (unless the analysis has multiple phases). I.e., use <code>update(double)</code> instead of <code>update(Report)</code>.</li>
</ul>
<ul>
<li>If the task creates an inner task object that's able to report progress, then the same progress object should be assigned to the inner task.</li>
</ul>
<ul>
<li>If the task calls an inner task that uses the same progress object as the outer task (see previous bullet) then the outer task should use the <a class="el" href="classRose_1_1ProgressTask.html">ProgressTask</a> RAII aproach by declaring a variable like this: <code><a class="el" href="classRose_1_1ProgressTask.html" title="RAII sub-task progress.">ProgressTask</a> pt(progress, "name_of_task", completion)</code>, where <code>completion</code> is the progress of the outer task after the inner task returns (either normally or by exception).</li>
</ul>
<ul>
<li>The task should call <a class="el" href="classRose_1_1Progress.html#a50547f5d77a159087f1965a716333db2">finished</a> when the analysis has completed if the progress object is non-null, even if the task has some other mechanism to notify listeners that it has completed.</li>
</ul>
<p>Here's an example analysis that uses these guidelines:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>OuterAnalyzer {</div>
<div class="line">    <a class="code" href="classSawyer_1_1SharedPointer.html">Rose::Progress::Ptr</a> progress_;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    OuterAnalyzer(): progress_(<a class="code" href="namespaceRose.html">Rose</a>::Progress::<a class="code" href="classRose_1_1Progress.html#a7942800cd0fb8e583ecbeb67935cd978">instance</a>()) {}</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classSawyer_1_1SharedPointer.html">Rose::Progress::Ptr</a> progress()<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordflow">return</span> progress_;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> progress(<span class="keyword">const</span> <a class="code" href="classSawyer_1_1SharedPointer.html">Rose::Progress::Ptr</a> &amp;p) {</div>
<div class="line">        progress_ = p;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> run() {</div>
<div class="line">        <span class="keywordtype">size_t</span> totalExpectedWork = 3 * nSteps;</div>
<div class="line">        <span class="keywordtype">size_t</span> workCompleted = 0;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> step = 0; step &lt; nSteps; ++step, workCompleted += 3) {</div>
<div class="line">            <span class="keywordflow">if</span> (progress_)</div>
<div class="line">                progress_-&gt;update((<span class="keywordtype">double</span>)workCompleted / totalExpectedWork);</div>
<div class="line"> </div>
<div class="line">            do_something();</div>
<div class="line">            <span class="keywordflow">if</span>(progress_)</div>
<div class="line">                progress_-&gt;update((<span class="keywordtype">double</span>)(workCompleted+1) / totalExpectedWork);</div>
<div class="line"> </div>
<div class="line">            <span class="comment">// Run an inner analysis. Assume InnerAnalysis has the same API as OuterAnalysis</span></div>
<div class="line">            {</div>
<div class="line">                ProgressTask pt(progress_, <span class="stringliteral">&quot;inner&quot;</span>, (<span class="keywordtype">double</span>)(workCompleted+2) / totalExpectedWork);</div>
<div class="line">                InnerAnalysis inner;</div>
<div class="line">                inner.progress(progress_);</div>
<div class="line">                inner.run();</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            <span class="comment">// progress was already emitted by ProgressTask destructor</span></div>
<div class="line">            do_something_more();</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (progress_)</div>
<div class="line">            progress_-&gt;finished(1.0);</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="Progress_8h_source.html#l00165">165</a> of file <a class="el" href="Progress_8h_source.html">Progress.h</a>.</p>
</div>
<p><code>#include &lt;<a class="el" href="Progress_8h_source.html">Rose/Progress.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Rose::Progress:</div>
<div class="dyncontent">
<div class="center"><img src="classRose_1_1Progress__inherit__graph.png" border="0" usemap="#Rose_1_1Progress_inherit__map" alt="Inheritance graph"/></div>
<map name="Rose_1_1Progress_inherit__map" id="Rose_1_1Progress_inherit__map">
<area shape="rect" title="A general, thread&#45;safe way to report progress made on some task." alt="" coords="25,80,139,107"/>
<area shape="rect" href="classSawyer_1_1SharedObject.html" title="Base class for reference counted objects." alt="" coords="5,5,159,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for Rose::Progress:</div>
<div class="dyncontent">
<div class="center"><img src="classRose_1_1Progress__coll__graph.png" border="0" usemap="#Rose_1_1Progress_coll__map" alt="Collaboration graph"/></div>
<map name="Rose_1_1Progress_coll__map" id="Rose_1_1Progress_coll__map">
<area shape="rect" title="A general, thread&#45;safe way to report progress made on some task." alt="" coords="25,80,139,107"/>
<area shape="rect" href="classSawyer_1_1SharedObject.html" title="Base class for reference counted objects." alt="" coords="5,5,159,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRose_1_1Progress_1_1Report.html">Report</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A single progress report.  <a href="structRose_1_1Progress_1_1Report.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:af0404702f80eb9dc773a9c26b2f88d21"><td class="memItemLeft" align="right" valign="top"><a id="af0404702f80eb9dc773a9c26b2f88d21"></a>
typedef <a class="el" href="classSawyer_1_1SharedPointer.html">Sawyer::SharedPointer</a>&lt; <a class="el" href="classRose_1_1Progress.html">Progress</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1Progress.html#af0404702f80eb9dc773a9c26b2f88d21">Ptr</a></td></tr>
<tr class="memdesc:af0404702f80eb9dc773a9c26b2f88d21"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1Progress.html" title="A general, thread-safe way to report progress made on some task.">Progress</a> objects are reference counted. <br /></td></tr>
<tr class="separator:af0404702f80eb9dc773a9c26b2f88d21"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad10c667ea7d3ff9685f0ff1ec0296746"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1Progress.html#ad10c667ea7d3ff9685f0ff1ec0296746">isFinished</a> () const</td></tr>
<tr class="memdesc:ad10c667ea7d3ff9685f0ff1ec0296746"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate indicating whether the task is finished.  <a href="classRose_1_1Progress.html#ad10c667ea7d3ff9685f0ff1ec0296746">More...</a><br /></td></tr>
<tr class="separator:ad10c667ea7d3ff9685f0ff1ec0296746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57b6c9195bfb5d0777012cc3699c202e"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="structRose_1_1Progress_1_1Report.html">Report</a>, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1Progress.html#a57b6c9195bfb5d0777012cc3699c202e">reportLatest</a> (const std::string &amp;nameSeparator=&quot;.&quot;) const</td></tr>
<tr class="memdesc:a57b6c9195bfb5d0777012cc3699c202e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Latest report and its age in seconds.  <a href="classRose_1_1Progress.html#a57b6c9195bfb5d0777012cc3699c202e">More...</a><br /></td></tr>
<tr class="separator:a57b6c9195bfb5d0777012cc3699c202e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43bc2d7d974fa2682c730c3078f00bc0"><td class="memTemplParams" colspan="2">template&lt;class Functor &gt; </td></tr>
<tr class="memitem:a43bc2d7d974fa2682c730c3078f00bc0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRose_1_1Progress.html#a43bc2d7d974fa2682c730c3078f00bc0">reportRegularly</a> (boost::chrono::milliseconds interval, Functor f, const std::string &amp;nameSeparator=&quot;.&quot;) const</td></tr>
<tr class="memdesc:a43bc2d7d974fa2682c730c3078f00bc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke the specified function at regular intervals.  <a href="classRose_1_1Progress.html#a43bc2d7d974fa2682c730c3078f00bc0">More...</a><br /></td></tr>
<tr class="separator:a43bc2d7d974fa2682c730c3078f00bc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a2ca5ccd599268592514b1b8a01de29"><td class="memTemplParams" colspan="2">template&lt;class Functor &gt; </td></tr>
<tr class="memitem:a8a2ca5ccd599268592514b1b8a01de29"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRose_1_1Progress.html#a8a2ca5ccd599268592514b1b8a01de29">reportChanges</a> (boost::chrono::milliseconds limit, Functor f, const std::string &amp;nameSeparator=&quot;.&quot;) const</td></tr>
<tr class="memdesc:a8a2ca5ccd599268592514b1b8a01de29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke the specified function each time the progress changes.  <a href="classRose_1_1Progress.html#a8a2ca5ccd599268592514b1b8a01de29">More...</a><br /></td></tr>
<tr class="separator:a8a2ca5ccd599268592514b1b8a01de29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:adfc28c369080b578f0ee5eaa4fbfdd55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1Progress.html#adfc28c369080b578f0ee5eaa4fbfdd55">update</a> (double completion, double maximum=1.0)</td></tr>
<tr class="memdesc:adfc28c369080b578f0ee5eaa4fbfdd55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a progress report.  <a href="classRose_1_1Progress.html#adfc28c369080b578f0ee5eaa4fbfdd55">More...</a><br /></td></tr>
<tr class="separator:adfc28c369080b578f0ee5eaa4fbfdd55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0adc353b6cf4d3d04e4306b6fe9655d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1Progress.html#a0adc353b6cf4d3d04e4306b6fe9655d0">update</a> (const <a class="el" href="structRose_1_1Progress_1_1Report.html">Report</a> &amp;)</td></tr>
<tr class="memdesc:a0adc353b6cf4d3d04e4306b6fe9655d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a progress report.  <a href="classRose_1_1Progress.html#a0adc353b6cf4d3d04e4306b6fe9655d0">More...</a><br /></td></tr>
<tr class="separator:a0adc353b6cf4d3d04e4306b6fe9655d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aa55171e954ec5fb3e1e46d0177f0dcb9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structRose_1_1Progress_1_1Report.html">Report</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1Progress.html#aa55171e954ec5fb3e1e46d0177f0dcb9">push</a> ()</td></tr>
<tr class="memdesc:aa55171e954ec5fb3e1e46d0177f0dcb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push a new progress phase onto the stack.  <a href="classRose_1_1Progress.html#aa55171e954ec5fb3e1e46d0177f0dcb9">More...</a><br /></td></tr>
<tr class="separator:aa55171e954ec5fb3e1e46d0177f0dcb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b24941d227b571af8cbadcd5c72b5c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structRose_1_1Progress_1_1Report.html">Report</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1Progress.html#a8b24941d227b571af8cbadcd5c72b5c6">push</a> (double completion, double maximum=1.0)</td></tr>
<tr class="memdesc:a8b24941d227b571af8cbadcd5c72b5c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push a new progress phase onto the stack.  <a href="classRose_1_1Progress.html#a8b24941d227b571af8cbadcd5c72b5c6">More...</a><br /></td></tr>
<tr class="separator:a8b24941d227b571af8cbadcd5c72b5c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2368394eb17ad96e67b9d30f80b00d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structRose_1_1Progress_1_1Report.html">Report</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1Progress.html#ae2368394eb17ad96e67b9d30f80b00d8">push</a> (const <a class="el" href="structRose_1_1Progress_1_1Report.html">Report</a> &amp;)</td></tr>
<tr class="memdesc:ae2368394eb17ad96e67b9d30f80b00d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push a new progress phase onto the stack.  <a href="classRose_1_1Progress.html#ae2368394eb17ad96e67b9d30f80b00d8">More...</a><br /></td></tr>
<tr class="separator:ae2368394eb17ad96e67b9d30f80b00d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ac7696b5beb55b758f1eaee060a20b8fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1Progress.html#ac7696b5beb55b758f1eaee060a20b8fc">pop</a> ()</td></tr>
<tr class="memdesc:ac7696b5beb55b758f1eaee060a20b8fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop the top progress phase from the stack.  <a href="classRose_1_1Progress.html#ac7696b5beb55b758f1eaee060a20b8fc">More...</a><br /></td></tr>
<tr class="separator:ac7696b5beb55b758f1eaee060a20b8fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae56a20cc6e2cbe673c7d71d60a1b7802"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1Progress.html#ae56a20cc6e2cbe673c7d71d60a1b7802">pop</a> (double completion, double maximum=1.0)</td></tr>
<tr class="memdesc:ae56a20cc6e2cbe673c7d71d60a1b7802"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop the top progress phase from the stack.  <a href="classRose_1_1Progress.html#ae56a20cc6e2cbe673c7d71d60a1b7802">More...</a><br /></td></tr>
<tr class="separator:ae56a20cc6e2cbe673c7d71d60a1b7802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad73a94558ac4220f296387a2fcbd40c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1Progress.html#ad73a94558ac4220f296387a2fcbd40c8">pop</a> (const <a class="el" href="structRose_1_1Progress_1_1Report.html">Report</a> &amp;)</td></tr>
<tr class="memdesc:ad73a94558ac4220f296387a2fcbd40c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop the top progress phase from the stack.  <a href="classRose_1_1Progress.html#ad73a94558ac4220f296387a2fcbd40c8">More...</a><br /></td></tr>
<tr class="separator:ad73a94558ac4220f296387a2fcbd40c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a50547f5d77a159087f1965a716333db2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1Progress.html#a50547f5d77a159087f1965a716333db2">finished</a> ()</td></tr>
<tr class="memdesc:a50547f5d77a159087f1965a716333db2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicate that the task is complete.  <a href="classRose_1_1Progress.html#a50547f5d77a159087f1965a716333db2">More...</a><br /></td></tr>
<tr class="separator:a50547f5d77a159087f1965a716333db2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af36ed9ab86338a1deab7e0b34c0e043f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1Progress.html#af36ed9ab86338a1deab7e0b34c0e043f">finished</a> (double completion, double maximum=1.0)</td></tr>
<tr class="memdesc:af36ed9ab86338a1deab7e0b34c0e043f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicate that the task is complete.  <a href="classRose_1_1Progress.html#af36ed9ab86338a1deab7e0b34c0e043f">More...</a><br /></td></tr>
<tr class="separator:af36ed9ab86338a1deab7e0b34c0e043f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84830dcb4bce1cce37792c1ccbee9685"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1Progress.html#a84830dcb4bce1cce37792c1ccbee9685">finished</a> (const <a class="el" href="structRose_1_1Progress_1_1Report.html">Report</a> &amp;)</td></tr>
<tr class="memdesc:a84830dcb4bce1cce37792c1ccbee9685"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicate that the task is complete.  <a href="classRose_1_1Progress.html#a84830dcb4bce1cce37792c1ccbee9685">More...</a><br /></td></tr>
<tr class="separator:a84830dcb4bce1cce37792c1ccbee9685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSawyer_1_1SharedObject"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSawyer_1_1SharedObject')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSawyer_1_1SharedObject.html">Sawyer::SharedObject</a></td></tr>
<tr class="memitem:af65fdccd9575d75238c9ce5615b102bb inherit pub_methods_classSawyer_1_1SharedObject"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1SharedObject.html#af65fdccd9575d75238c9ce5615b102bb">SharedObject</a> ()</td></tr>
<tr class="memdesc:af65fdccd9575d75238c9ce5615b102bb inherit pub_methods_classSawyer_1_1SharedObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="classSawyer_1_1SharedObject.html#af65fdccd9575d75238c9ce5615b102bb">More...</a><br /></td></tr>
<tr class="separator:af65fdccd9575d75238c9ce5615b102bb inherit pub_methods_classSawyer_1_1SharedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f1155ff49f2c62afd307c0168d6f84e inherit pub_methods_classSawyer_1_1SharedObject"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1SharedObject.html#a4f1155ff49f2c62afd307c0168d6f84e">SharedObject</a> (const <a class="el" href="classSawyer_1_1SharedObject.html">SharedObject</a> &amp;)</td></tr>
<tr class="memdesc:a4f1155ff49f2c62afd307c0168d6f84e inherit pub_methods_classSawyer_1_1SharedObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="classSawyer_1_1SharedObject.html#a4f1155ff49f2c62afd307c0168d6f84e">More...</a><br /></td></tr>
<tr class="separator:a4f1155ff49f2c62afd307c0168d6f84e inherit pub_methods_classSawyer_1_1SharedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a0ad0a0708358bb6a27191dd375b404 inherit pub_methods_classSawyer_1_1SharedObject"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1SharedObject.html#a5a0ad0a0708358bb6a27191dd375b404">~SharedObject</a> ()</td></tr>
<tr class="memdesc:a5a0ad0a0708358bb6a27191dd375b404 inherit pub_methods_classSawyer_1_1SharedObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual destructor.  <a href="classSawyer_1_1SharedObject.html#a5a0ad0a0708358bb6a27191dd375b404">More...</a><br /></td></tr>
<tr class="separator:a5a0ad0a0708358bb6a27191dd375b404 inherit pub_methods_classSawyer_1_1SharedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38be1291d4c8843e37a82087d05243bc inherit pub_methods_classSawyer_1_1SharedObject"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1SharedObject.html">SharedObject</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1SharedObject.html#a38be1291d4c8843e37a82087d05243bc">operator=</a> (const <a class="el" href="classSawyer_1_1SharedObject.html">SharedObject</a> &amp;)</td></tr>
<tr class="memdesc:a38be1291d4c8843e37a82087d05243bc inherit pub_methods_classSawyer_1_1SharedObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment.  <a href="classSawyer_1_1SharedObject.html#a38be1291d4c8843e37a82087d05243bc">More...</a><br /></td></tr>
<tr class="separator:a38be1291d4c8843e37a82087d05243bc inherit pub_methods_classSawyer_1_1SharedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a7942800cd0fb8e583ecbeb67935cd978"><td class="memItemLeft" align="right" valign="top"><a id="a7942800cd0fb8e583ecbeb67935cd978"></a>
static <a class="el" href="classRose_1_1Progress.html#af0404702f80eb9dc773a9c26b2f88d21">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1Progress.html#a7942800cd0fb8e583ecbeb67935cd978">instance</a> ()</td></tr>
<tr class="memdesc:a7942800cd0fb8e583ecbeb67935cd978"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory to create a new instance of this class. <br /></td></tr>
<tr class="separator:a7942800cd0fb8e583ecbeb67935cd978"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="adfc28c369080b578f0ee5eaa4fbfdd55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfc28c369080b578f0ee5eaa4fbfdd55">&#9670;&nbsp;</a></span>update() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::Progress::update </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>completion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>maximum</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a progress report. </p>
<p>This method is called by the threads that are doing the work in order to update the record of the amount of work they have completed.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> worker(<a class="code" href="classRose_1_1Progress.html#af0404702f80eb9dc773a9c26b2f88d21">Progress::Ptr</a> progress) {</div>
<div class="line">    <span class="keywordflow">for</span> (i = 0; i &lt; totalWork; ++i) {</div>
<div class="line">        doSomeWork();</div>
<div class="line">        <span class="keywordflow">if</span> (progress)</div>
<div class="line">            progress-&gt;update((<span class="keywordtype">double</span>)i / totalWork);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (progress)</div>
<div class="line">        progress-&gt;finished();</div>
<div class="line">}</div>
</div><!-- fragment --><p>This updates the progress report for the innermost (top-of-stack) phase when there are nested phases.</p>
<p>Thread safety: This method is thread safe. </p>

</div>
</div>
<a id="a0adc353b6cf4d3d04e4306b6fe9655d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0adc353b6cf4d3d04e4306b6fe9655d0">&#9670;&nbsp;</a></span>update() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::Progress::update </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structRose_1_1Progress_1_1Report.html">Report</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a progress report. </p>
<p>This method is called by the threads that are doing the work in order to update the record of the amount of work they have completed.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> worker(<a class="code" href="classRose_1_1Progress.html#af0404702f80eb9dc773a9c26b2f88d21">Progress::Ptr</a> progress) {</div>
<div class="line">    <span class="keywordflow">for</span> (i = 0; i &lt; totalWork; ++i) {</div>
<div class="line">        doSomeWork();</div>
<div class="line">        <span class="keywordflow">if</span> (progress)</div>
<div class="line">            progress-&gt;update((<span class="keywordtype">double</span>)i / totalWork);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (progress)</div>
<div class="line">        progress-&gt;finished();</div>
<div class="line">}</div>
</div><!-- fragment --><p>This updates the progress report for the innermost (top-of-stack) phase when there are nested phases.</p>
<p>Thread safety: This method is thread safe. </p>

</div>
</div>
<a id="aa55171e954ec5fb3e1e46d0177f0dcb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa55171e954ec5fb3e1e46d0177f0dcb9">&#9670;&nbsp;</a></span>push() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structRose_1_1Progress_1_1Report.html">Report</a> Rose::Progress::push </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Push a new progress phase onto the stack. </p>
<p>If some analysis needs to call another analysis and both want to report progress, the outer analysis may push a new phase onto the progress stack before calling the inner analysis. Once the inner analysis returns, the outer analysis should pop the inner phase from the stack.</p>
<p>Passing a completion ratio or report argument is the same as calling <a class="el" href="classRose_1_1Progress.html#adfc28c369080b578f0ee5eaa4fbfdd55">update</a> first, except the two operations are atomic. Pushing a new context (regardless of whether an argument was given) notifies listeners that the progress has changed.</p>
<p>Returns the previous report. The name for the previous report is always just the base name, not joined with any other levels in the stack. </p>

</div>
</div>
<a id="a8b24941d227b571af8cbadcd5c72b5c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b24941d227b571af8cbadcd5c72b5c6">&#9670;&nbsp;</a></span>push() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structRose_1_1Progress_1_1Report.html">Report</a> Rose::Progress::push </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>completion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>maximum</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Push a new progress phase onto the stack. </p>
<p>If some analysis needs to call another analysis and both want to report progress, the outer analysis may push a new phase onto the progress stack before calling the inner analysis. Once the inner analysis returns, the outer analysis should pop the inner phase from the stack.</p>
<p>Passing a completion ratio or report argument is the same as calling <a class="el" href="classRose_1_1Progress.html#adfc28c369080b578f0ee5eaa4fbfdd55">update</a> first, except the two operations are atomic. Pushing a new context (regardless of whether an argument was given) notifies listeners that the progress has changed.</p>
<p>Returns the previous report. The name for the previous report is always just the base name, not joined with any other levels in the stack. </p>

</div>
</div>
<a id="ae2368394eb17ad96e67b9d30f80b00d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2368394eb17ad96e67b9d30f80b00d8">&#9670;&nbsp;</a></span>push() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structRose_1_1Progress_1_1Report.html">Report</a> Rose::Progress::push </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structRose_1_1Progress_1_1Report.html">Report</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Push a new progress phase onto the stack. </p>
<p>If some analysis needs to call another analysis and both want to report progress, the outer analysis may push a new phase onto the progress stack before calling the inner analysis. Once the inner analysis returns, the outer analysis should pop the inner phase from the stack.</p>
<p>Passing a completion ratio or report argument is the same as calling <a class="el" href="classRose_1_1Progress.html#adfc28c369080b578f0ee5eaa4fbfdd55">update</a> first, except the two operations are atomic. Pushing a new context (regardless of whether an argument was given) notifies listeners that the progress has changed.</p>
<p>Returns the previous report. The name for the previous report is always just the base name, not joined with any other levels in the stack. </p>

</div>
</div>
<a id="ac7696b5beb55b758f1eaee060a20b8fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7696b5beb55b758f1eaee060a20b8fc">&#9670;&nbsp;</a></span>pop() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::Progress::pop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pop the top progress phase from the stack. </p>
<p>This is intended to be called after one analysis calls another and the other has returned. Before the outer analysis calls the inner analysis, it should push a new record onto the progress stack, and after the inner analysis returns the outer analysis should pop that record.</p>
<p>Attempting to pop the final item from the stack is the same as calling <a class="el" href="classRose_1_1Progress.html#a50547f5d77a159087f1965a716333db2">finished</a> (it doesn't actually pop the final item). Otherwise, popping the stack notifies listeners that the progress has changed.</p>
<p>Passing a completion ratio or report argument is the same as calling <a class="el" href="classRose_1_1Progress.html#adfc28c369080b578f0ee5eaa4fbfdd55">update</a> after popping, except the two operations are atomic. Popping a context (regardless of whether an argument was given) notifies listeners that the progress has changed. </p>

</div>
</div>
<a id="ae56a20cc6e2cbe673c7d71d60a1b7802"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae56a20cc6e2cbe673c7d71d60a1b7802">&#9670;&nbsp;</a></span>pop() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::Progress::pop </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>completion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>maximum</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pop the top progress phase from the stack. </p>
<p>This is intended to be called after one analysis calls another and the other has returned. Before the outer analysis calls the inner analysis, it should push a new record onto the progress stack, and after the inner analysis returns the outer analysis should pop that record.</p>
<p>Attempting to pop the final item from the stack is the same as calling <a class="el" href="classRose_1_1Progress.html#a50547f5d77a159087f1965a716333db2">finished</a> (it doesn't actually pop the final item). Otherwise, popping the stack notifies listeners that the progress has changed.</p>
<p>Passing a completion ratio or report argument is the same as calling <a class="el" href="classRose_1_1Progress.html#adfc28c369080b578f0ee5eaa4fbfdd55">update</a> after popping, except the two operations are atomic. Popping a context (regardless of whether an argument was given) notifies listeners that the progress has changed. </p>

</div>
</div>
<a id="ad73a94558ac4220f296387a2fcbd40c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad73a94558ac4220f296387a2fcbd40c8">&#9670;&nbsp;</a></span>pop() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::Progress::pop </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structRose_1_1Progress_1_1Report.html">Report</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pop the top progress phase from the stack. </p>
<p>This is intended to be called after one analysis calls another and the other has returned. Before the outer analysis calls the inner analysis, it should push a new record onto the progress stack, and after the inner analysis returns the outer analysis should pop that record.</p>
<p>Attempting to pop the final item from the stack is the same as calling <a class="el" href="classRose_1_1Progress.html#a50547f5d77a159087f1965a716333db2">finished</a> (it doesn't actually pop the final item). Otherwise, popping the stack notifies listeners that the progress has changed.</p>
<p>Passing a completion ratio or report argument is the same as calling <a class="el" href="classRose_1_1Progress.html#adfc28c369080b578f0ee5eaa4fbfdd55">update</a> after popping, except the two operations are atomic. Popping a context (regardless of whether an argument was given) notifies listeners that the progress has changed. </p>

</div>
</div>
<a id="a50547f5d77a159087f1965a716333db2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50547f5d77a159087f1965a716333db2">&#9670;&nbsp;</a></span>finished() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::Progress::finished </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicate that the task is complete. </p>
<p>This method is called by one (or more) of the threads doing the work in order to indicate that the work has been terminated, either because it was completed or there was an error, and that no more progress updates will be forthcoming. If this progress object is nested (i.e., the report stack has more than one element) then the <a class="el" href="classRose_1_1Progress.html#a50547f5d77a159087f1965a716333db2">finished</a> method doesn't actually do anything because outer phases can still potentially update their progress.</p>
<p>If no worker thread calls <a class="el" href="classRose_1_1Progress.html#a50547f5d77a159087f1965a716333db2">finished</a> then the listeners will not know that work has finished and they may continue listening for progress updates indefinitely. It is permissible to call <a class="el" href="classRose_1_1Progress.html#a50547f5d77a159087f1965a716333db2">finished</a> more than once.</p>
<p>Passing completion ratio or report argument has the same effect as calling <a class="el" href="classRose_1_1Progress.html#adfc28c369080b578f0ee5eaa4fbfdd55">update</a> first, except the two operations are atomic. Each call to this method (regardless of whether an argument was specified) notifies listeners that the progress changed.</p>
<p>The <a class="el" href="classRose_1_1Progress.html">Progress</a> API is not responsible for reporting task status (whether the workers were collectively successful or encountered an error). Status should be reported by the usual mechanisms, such as futures.</p>
<p>Thread safety: This method is thread safe. </p>

</div>
</div>
<a id="af36ed9ab86338a1deab7e0b34c0e043f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af36ed9ab86338a1deab7e0b34c0e043f">&#9670;&nbsp;</a></span>finished() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::Progress::finished </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>completion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>maximum</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicate that the task is complete. </p>
<p>This method is called by one (or more) of the threads doing the work in order to indicate that the work has been terminated, either because it was completed or there was an error, and that no more progress updates will be forthcoming. If this progress object is nested (i.e., the report stack has more than one element) then the <a class="el" href="classRose_1_1Progress.html#a50547f5d77a159087f1965a716333db2">finished</a> method doesn't actually do anything because outer phases can still potentially update their progress.</p>
<p>If no worker thread calls <a class="el" href="classRose_1_1Progress.html#a50547f5d77a159087f1965a716333db2">finished</a> then the listeners will not know that work has finished and they may continue listening for progress updates indefinitely. It is permissible to call <a class="el" href="classRose_1_1Progress.html#a50547f5d77a159087f1965a716333db2">finished</a> more than once.</p>
<p>Passing completion ratio or report argument has the same effect as calling <a class="el" href="classRose_1_1Progress.html#adfc28c369080b578f0ee5eaa4fbfdd55">update</a> first, except the two operations are atomic. Each call to this method (regardless of whether an argument was specified) notifies listeners that the progress changed.</p>
<p>The <a class="el" href="classRose_1_1Progress.html">Progress</a> API is not responsible for reporting task status (whether the workers were collectively successful or encountered an error). Status should be reported by the usual mechanisms, such as futures.</p>
<p>Thread safety: This method is thread safe. </p>

</div>
</div>
<a id="a84830dcb4bce1cce37792c1ccbee9685"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84830dcb4bce1cce37792c1ccbee9685">&#9670;&nbsp;</a></span>finished() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::Progress::finished </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structRose_1_1Progress_1_1Report.html">Report</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicate that the task is complete. </p>
<p>This method is called by one (or more) of the threads doing the work in order to indicate that the work has been terminated, either because it was completed or there was an error, and that no more progress updates will be forthcoming. If this progress object is nested (i.e., the report stack has more than one element) then the <a class="el" href="classRose_1_1Progress.html#a50547f5d77a159087f1965a716333db2">finished</a> method doesn't actually do anything because outer phases can still potentially update their progress.</p>
<p>If no worker thread calls <a class="el" href="classRose_1_1Progress.html#a50547f5d77a159087f1965a716333db2">finished</a> then the listeners will not know that work has finished and they may continue listening for progress updates indefinitely. It is permissible to call <a class="el" href="classRose_1_1Progress.html#a50547f5d77a159087f1965a716333db2">finished</a> more than once.</p>
<p>Passing completion ratio or report argument has the same effect as calling <a class="el" href="classRose_1_1Progress.html#adfc28c369080b578f0ee5eaa4fbfdd55">update</a> first, except the two operations are atomic. Each call to this method (regardless of whether an argument was specified) notifies listeners that the progress changed.</p>
<p>The <a class="el" href="classRose_1_1Progress.html">Progress</a> API is not responsible for reporting task status (whether the workers were collectively successful or encountered an error). Status should be reported by the usual mechanisms, such as futures.</p>
<p>Thread safety: This method is thread safe. </p>

</div>
</div>
<a id="ad10c667ea7d3ff9685f0ff1ec0296746"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad10c667ea7d3ff9685f0ff1ec0296746">&#9670;&nbsp;</a></span>isFinished()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::Progress::isFinished </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Predicate indicating whether the task is finished. </p>
<p>Returns true if the task which was being monitored has been terminated either because it finished or it had an error. If an inner phase calls <a class="el" href="classRose_1_1Progress.html#a50547f5d77a159087f1965a716333db2">finished</a>, it doesn't actually cause this phase object to be marked as finished because outer phases may continue to update their progress.</p>
<p>Thread safety: This method is thread safe. </p>

<p class="reference">Referenced by <a class="el" href="Progress_8h_source.html#l00349">reportRegularly()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classRose_1_1Progress_ad10c667ea7d3ff9685f0ff1ec0296746_icgraph.png" border="0" usemap="#classRose_1_1Progress_ad10c667ea7d3ff9685f0ff1ec0296746_icgraph" alt=""/></div>
<map name="classRose_1_1Progress_ad10c667ea7d3ff9685f0ff1ec0296746_icgraph" id="classRose_1_1Progress_ad10c667ea7d3ff9685f0ff1ec0296746_icgraph">
<area shape="rect" title="Predicate indicating whether the task is finished." alt="" coords="263,5,443,32"/>
<area shape="rect" href="classRose_1_1Progress.html#a43bc2d7d974fa2682c730c3078f00bc0" title="Invoke the specified function at regular intervals." alt="" coords="5,5,215,32"/>
</map>
</div>

</div>
</div>
<a id="a57b6c9195bfb5d0777012cc3699c202e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57b6c9195bfb5d0777012cc3699c202e">&#9670;&nbsp;</a></span>reportLatest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="structRose_1_1Progress_1_1Report.html">Report</a>, double &gt; Rose::Progress::reportLatest </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>nameSeparator</em> = <code>&quot;.&quot;</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Latest report and its age in seconds. </p>
<p>Returns the most recent report that has been received and how long it's been (in seconds) since the report was received. If no report has ever been received, then this returns a default-constructed report and the time since this <a class="el" href="classRose_1_1Progress.html" title="A general, thread-safe way to report progress made on some task.">Progress</a> object was created; such reports have completion of zero.</p>
<p>If <code>nameSeparator</code> is not empty, then the returned report name is formed by joining all phase names on the report stack with the specified separator.</p>
<p>Thread safety: This method is thread safe. </p>

<p class="reference">Referenced by <a class="el" href="Progress_8h_source.html#l00349">reportRegularly()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classRose_1_1Progress_a57b6c9195bfb5d0777012cc3699c202e_icgraph.png" border="0" usemap="#classRose_1_1Progress_a57b6c9195bfb5d0777012cc3699c202e_icgraph" alt=""/></div>
<map name="classRose_1_1Progress_a57b6c9195bfb5d0777012cc3699c202e_icgraph" id="classRose_1_1Progress_a57b6c9195bfb5d0777012cc3699c202e_icgraph">
<area shape="rect" title="Latest report and its age in seconds." alt="" coords="263,5,453,32"/>
<area shape="rect" href="classRose_1_1Progress.html#a43bc2d7d974fa2682c730c3078f00bc0" title="Invoke the specified function at regular intervals." alt="" coords="5,5,215,32"/>
</map>
</div>

</div>
</div>
<a id="a43bc2d7d974fa2682c730c3078f00bc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43bc2d7d974fa2682c730c3078f00bc0">&#9670;&nbsp;</a></span>reportRegularly()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Functor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::Progress::reportRegularly </td>
          <td>(</td>
          <td class="paramtype">boost::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>nameSeparator</em> = <code>&quot;.&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invoke the specified function at regular intervals. </p>
<p>The specified functor is invoked as soon as this method is called, and then every <code>interval</code> milliseconds thereafter until some thread calls <a class="el" href="classRose_1_1Progress.html#a50547f5d77a159087f1965a716333db2">finished</a> on this object or the functor returns false. The functor is invoked with two arguments: the last known progress report and the time in seconds since it was reported.</p>
<p>If <code>nameSeparator</code> is not empty, then the returned report name is formed by joining all phase names on the report stack with the specified separator.</p>
<p>Return value: Returns false if the functor returned false, true if the reporting ended because the task is finished.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> reportPerSecond(std::ostream &amp;output, Progress *progress) {</div>
<div class="line">    progress-&gt;reportRegularly(boost::chrono::seconds(1), [&amp;output](<span class="keyword">const</span> Report &amp;report, <span class="keywordtype">double</span> age) {</div>
<div class="line">        output &lt;&lt;(boost::format(<span class="stringliteral">&quot;%s %.0f%%\n&quot;</span>) % report.name % (100.0 * report.completion));</div>
<div class="line">    });</div>
<div class="line">}</div>
</div><!-- fragment --><p>Thread safety: This method is thread safe. </p>

<p class="definition">Definition at line <a class="el" href="Progress_8h_source.html#l00349">349</a> of file <a class="el" href="Progress_8h_source.html">Progress.h</a>.</p>

<p class="reference">References <a class="el" href="classRose_1_1Progress.html#ad10c667ea7d3ff9685f0ff1ec0296746">isFinished()</a>, and <a class="el" href="classRose_1_1Progress.html#a57b6c9195bfb5d0777012cc3699c202e">reportLatest()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classRose_1_1Progress_a43bc2d7d974fa2682c730c3078f00bc0_cgraph.png" border="0" usemap="#classRose_1_1Progress_a43bc2d7d974fa2682c730c3078f00bc0_cgraph" alt=""/></div>
<map name="classRose_1_1Progress_a43bc2d7d974fa2682c730c3078f00bc0_cgraph" id="classRose_1_1Progress_a43bc2d7d974fa2682c730c3078f00bc0_cgraph">
<area shape="rect" title="Invoke the specified function at regular intervals." alt="" coords="5,31,215,57"/>
<area shape="rect" href="classRose_1_1Progress.html#ad10c667ea7d3ff9685f0ff1ec0296746" title="Predicate indicating whether the task is finished." alt="" coords="268,5,448,32"/>
<area shape="rect" href="classRose_1_1Progress.html#a57b6c9195bfb5d0777012cc3699c202e" title="Latest report and its age in seconds." alt="" coords="263,56,453,83"/>
</map>
</div>

</div>
</div>
<a id="a8a2ca5ccd599268592514b1b8a01de29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a2ca5ccd599268592514b1b8a01de29">&#9670;&nbsp;</a></span>reportChanges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Functor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::Progress::reportChanges </td>
          <td>(</td>
          <td class="paramtype">boost::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>nameSeparator</em> = <code>&quot;.&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invoke the specified function each time the progress changes. </p>
<p>The specified functor is invoked each time a worker thread updates the progress, but not more than the specified period. The functor is called with one argument, the most recent progress report, and returns a Boolean. If the functor returns false then this function also immediately returns false, otherwise the functor is called until a worker thread indicates that the task is finished (either complete or had an error) by calling <a class="el" href="classRose_1_1Progress.html#a50547f5d77a159087f1965a716333db2">finished</a>.</p>
<p>If <code>nameSeparator</code> is not empty, then the returned report name is formed by joining all phase names on the report stack with the specified separator.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="classRose_1_1Progress.html#a8a2ca5ccd599268592514b1b8a01de29">reportChanges</a>(std::ostream &amp;output, Progress *progress) {</div>
<div class="line">    progress-&gt;reportChanges(boost::chrono::seconds(1), [&amp;output](<span class="keyword">const</span> Report &amp;report) {</div>
<div class="line">        output &lt;&lt;(boost::format(<span class="stringliteral">&quot;%s %.0f%%\n&quot;</span>) % report.name % (100.0 * report.completion));</div>
<div class="line">    });</div>
<div class="line">}</div>
</div><!-- fragment --><p>Thread safety: This method is thread safe. </p>

<p class="definition">Definition at line <a class="el" href="Progress_8h_source.html#l00386">386</a> of file <a class="el" href="Progress_8h_source.html">Progress.h</a>.</p>

<p class="reference">References <a class="el" href="Progress_8h_source.html#l00180">Rose::Progress::Report::name</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="Progress_8h_source.html">Progress.h</a></li>
</ul>
</div><!-- contents -->
<div class="ttc" id="aclassRose_1_1Progress_html_af0404702f80eb9dc773a9c26b2f88d21"><div class="ttname"><a href="classRose_1_1Progress.html#af0404702f80eb9dc773a9c26b2f88d21">Rose::Progress::Ptr</a></div><div class="ttdeci">Sawyer::SharedPointer&lt; Progress &gt; Ptr</div><div class="ttdoc">Progress objects are reference counted.</div><div class="ttdef"><b>Definition:</b> <a href="Progress_8h_source.html#l00168">Progress.h:168</a></div></div>
<div class="ttc" id="aclassSawyer_1_1SharedPointer_html"><div class="ttname"><a href="classSawyer_1_1SharedPointer.html">Sawyer::SharedPointer&lt; Progress &gt;</a></div></div>
<div class="ttc" id="anamespaceRose_html"><div class="ttname"><a href="namespaceRose.html">Rose</a></div><div class="ttdoc">Main namespace for the ROSE library.</div><div class="ttdef"><b>Definition:</b> <a href="BinaryTutorial_8dox_source.html#l00003">BinaryTutorial.dox:3</a></div></div>
<div class="ttc" id="aclassRose_1_1Progress_html_a8a2ca5ccd599268592514b1b8a01de29"><div class="ttname"><a href="classRose_1_1Progress.html#a8a2ca5ccd599268592514b1b8a01de29">Rose::Progress::reportChanges</a></div><div class="ttdeci">bool reportChanges(boost::chrono::milliseconds limit, Functor f, const std::string &amp;nameSeparator=&quot;.&quot;) const</div><div class="ttdoc">Invoke the specified function each time the progress changes.</div><div class="ttdef"><b>Definition:</b> <a href="Progress_8h_source.html#l00386">Progress.h:386</a></div></div>
<div class="ttc" id="aclassRose_1_1Progress_html_a7942800cd0fb8e583ecbeb67935cd978"><div class="ttname"><a href="classRose_1_1Progress.html#a7942800cd0fb8e583ecbeb67935cd978">Rose::Progress::instance</a></div><div class="ttdeci">static Ptr instance()</div><div class="ttdoc">Factory to create a new instance of this class.</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Dec 8 2022 21:18:48 for ROSE by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
