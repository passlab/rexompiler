<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROSE: Sawyer::Tree::ListNode&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="ROSE"/>
<link href="roseDoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ROSE
   &#160;<span id="projectnumber">0.11.96.11</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,true,'search.html','Search');
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceSawyer.html">Sawyer</a></li><li class="navelem"><a class="el" href="namespaceSawyer_1_1Tree.html">Tree</a></li><li class="navelem"><a class="el" href="classSawyer_1_1Tree_1_1ListNode.html">ListNode</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classSawyer_1_1Tree_1_1ListNode-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Sawyer::Tree::ListNode&lt; T &gt; Class Template Reference<span class="mlabels"><span class="mlabel">final</span></span></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><h3>template&lt;class T&gt;<br />
class Sawyer::Tree::ListNode&lt; T &gt;</h3>

<p>A node containing only a list of children. </p>
<p>This class is used for nodes whose sole purpose is to hold a list of child nodes. Rather than having any dedicated data members, it accesses the <code>children</code> member directly in order to store the ordered list of child pointers. New classes cannot be derived from this class since doing so would enable the derived class to have additional ChildPtr data members that would interfere with the <code>children</code> list.</p>
<p>Although the <code>children</code> data member provides a read-only API for accessing the children, we also need to provde an API that can modify that list. The entire <code>children</code> API is available also from this node directly so that the reading and writing APIs can be invoked consistently on this object.</p>
<p>A parent node that points to a node containing a list as well as nodes that are not lists is declared as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>ChildType1;    <span class="comment">// some user-defined type derived from Tree::Node</span></div>
<div class="line"><span class="keyword">class </span>ChildType2;    <span class="comment">// ditto</span></div>
<div class="line"><span class="keyword">class </span>ChildType3;    <span class="comment">// ditto</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>Parent: <span class="keyword">public</span> Tree::Node {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    Tree::ChildEdge&lt;ChildType1&gt; first;                <span class="comment">// a.k.a., children[0]</span></div>
<div class="line">    Tree::ChildEdge&lt;Tree::ListNode&lt;ChildType2&gt; list;  <span class="comment">// a.k.a., children[1]</span></div>
<div class="line">    Tree::ChildEdge&lt;ChildType3&gt; last;                 <span class="comment">// a.k.a., children[2] regardless of list&#39;s size</span></div>
<div class="line"> </div>
<div class="line">    Parent()</div>
<div class="line">        : first(this), list(this), last(this) {}</div>
<div class="line">}</div>
</div><!-- fragment --><p>A common practice when creating a <a class="el" href="classSawyer_1_1Tree_1_1ListNode.html">ListNode</a> is to allocate then node when the parent is constructed:</p>
<div class="fragment"><div class="line">Parent::Parent()</div>
<div class="line">    : first(this), list(this, std::make_shared&lt;Tree::ListNode&lt;ChildType2&gt; &gt;()), last(this) {}</div>
</div><!-- fragment --><p>If you follow the recommendation of always allocating <a class="el" href="classSawyer_1_1Tree_1_1ListNode.html">ListNode</a> data members, then the 10th child (index 9) of the parent node's list can be accessed without worrying about whether <code>parent-&gt;list</code> is a null pointer:</p>
<div class="fragment"><div class="line">std::shared_ptr&lt;Parent&gt; <a class="code" href="classSawyer_1_1Tree_1_1Node.html#a43c6e37a263bae722919e7820a913213">parent</a> = ...;</div>
<div class="line">std::shared_ptr&lt;ChildType2&gt; item = <a class="code" href="classSawyer_1_1Tree_1_1Node.html#a43c6e37a263bae722919e7820a913213">parent</a>-&gt;list-&gt;at(9);</div>
</div><!-- fragment --><p>Since a <a class="el" href="classSawyer_1_1Tree_1_1ListNode.html">ListNode</a> is a type of <a class="el" href="classSawyer_1_1Tree_1_1Node.html">Node</a>, it has a <code>children</code> data member of type <a class="el" href="classSawyer_1_1Tree_1_1Children.html">Children</a>. All the functions defined for <a class="el" href="classSawyer_1_1Tree_1_1Children.html">Children</a> are also defined in <a class="el" href="classSawyer_1_1Tree_1_1ListNode.html">ListNode</a> itself, plus <a class="el" href="classSawyer_1_1Tree_1_1ListNode.html">ListNode</a> has a number of additional member functions for inserting and removing children&ndash;something that's not possible with other <a class="el" href="classSawyer_1_1Tree_1_1Node.html">Node</a> types.</p>
<p>The <a class="el" href="classSawyer_1_1Tree_1_1ListNode.html">ListNode</a> type is final because if users could derive subclasses from it, then those subclasses could add <a class="el" href="classSawyer_1_1Tree_1_1ChildEdge.html">ChildEdge</a> data members that would interfere with the child node counting. </p>

<p class="definition">Definition at line <a class="el" href="Tree_8h_source.html#l00699">699</a> of file <a class="el" href="Tree_8h_source.html">Tree.h</a>.</p>
</div>
<p><code>#include &lt;<a class="el" href="Tree_8h_source.html">Tree.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Sawyer::Tree::ListNode&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Tree_1_1ListNode__inherit__graph.png" border="0" usemap="#Sawyer_1_1Tree_1_1ListNode_3_01T_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="Sawyer_1_1Tree_1_1ListNode_3_01T_01_4_inherit__map" id="Sawyer_1_1Tree_1_1ListNode_3_01T_01_4_inherit__map">
<area shape="rect" title="A node containing only a list of children." alt="" coords="5,80,197,107"/>
<area shape="rect" href="classSawyer_1_1Tree_1_1Node.html" title="Base class for Tree nodes." alt="" coords="32,5,171,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for Sawyer::Tree::ListNode&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Tree_1_1ListNode__coll__graph.png" border="0" usemap="#Sawyer_1_1Tree_1_1ListNode_3_01T_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="Sawyer_1_1Tree_1_1ListNode_3_01T_01_4_coll__map" id="Sawyer_1_1Tree_1_1ListNode_3_01T_01_4_coll__map">
<area shape="rect" title="A node containing only a list of children." alt="" coords="5,80,197,107"/>
<area shape="rect" href="classSawyer_1_1Tree_1_1Node.html" title="Base class for Tree nodes." alt="" coords="32,5,171,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4b6c1cf0f3e40da93740902fee2dc34b"><td class="memItemLeft" align="right" valign="top"><a id="a4b6c1cf0f3e40da93740902fee2dc34b"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1ListNode.html#a4b6c1cf0f3e40da93740902fee2dc34b">size</a> () const</td></tr>
<tr class="memdesc:a4b6c1cf0f3e40da93740902fee2dc34b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of children. <br /></td></tr>
<tr class="separator:a4b6c1cf0f3e40da93740902fee2dc34b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1529c49d635e58c6491ea5b865ce163"><td class="memItemLeft" align="right" valign="top"><a id="aa1529c49d635e58c6491ea5b865ce163"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1ListNode.html#aa1529c49d635e58c6491ea5b865ce163">max_size</a> () const</td></tr>
<tr class="memdesc:aa1529c49d635e58c6491ea5b865ce163"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum size. <br /></td></tr>
<tr class="separator:aa1529c49d635e58c6491ea5b865ce163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6612cf4cd09f1baf9fca44dda09b9f87"><td class="memItemLeft" align="right" valign="top"><a id="a6612cf4cd09f1baf9fca44dda09b9f87"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1ListNode.html#a6612cf4cd09f1baf9fca44dda09b9f87">capacity</a> () const</td></tr>
<tr class="memdesc:a6612cf4cd09f1baf9fca44dda09b9f87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Capacity. <br /></td></tr>
<tr class="separator:a6612cf4cd09f1baf9fca44dda09b9f87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89f0f4f766d2e3adad980e14dbbcdfee"><td class="memItemLeft" align="right" valign="top"><a id="a89f0f4f766d2e3adad980e14dbbcdfee"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1ListNode.html#a89f0f4f766d2e3adad980e14dbbcdfee">empty</a> () const</td></tr>
<tr class="memdesc:a89f0f4f766d2e3adad980e14dbbcdfee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty predicate. <br /></td></tr>
<tr class="separator:a89f0f4f766d2e3adad980e14dbbcdfee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a541507d60bd1ea803a619b24f6d7fb00"><td class="memItemLeft" align="right" valign="top"><a id="a541507d60bd1ea803a619b24f6d7fb00"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1ListNode.html#a541507d60bd1ea803a619b24f6d7fb00">reserve</a> (size_t n)</td></tr>
<tr class="memdesc:a541507d60bd1ea803a619b24f6d7fb00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserve space for more children. <br /></td></tr>
<tr class="separator:a541507d60bd1ea803a619b24f6d7fb00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10ea6e76755a9b88d9382c5506c04015"><td class="memItemLeft" align="right" valign="top"><a id="a10ea6e76755a9b88d9382c5506c04015"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1ListNode.html#a10ea6e76755a9b88d9382c5506c04015">shrink_to_fit</a> ()</td></tr>
<tr class="memdesc:a10ea6e76755a9b88d9382c5506c04015"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shrink reservation. <br /></td></tr>
<tr class="separator:a10ea6e76755a9b88d9382c5506c04015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73b87f68afd5294199d1740abf27440d"><td class="memItemLeft" align="right" valign="top"><a id="a73b87f68afd5294199d1740abf27440d"></a>
const std::shared_ptr&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1ListNode.html#a73b87f68afd5294199d1740abf27440d">at</a> (size_t i) const</td></tr>
<tr class="memdesc:a73b87f68afd5294199d1740abf27440d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Child at specified index. <br /></td></tr>
<tr class="separator:a73b87f68afd5294199d1740abf27440d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f376c3aae32590e578a9a2382c3080a"><td class="memItemLeft" align="right" valign="top"><a id="a8f376c3aae32590e578a9a2382c3080a"></a>
const std::shared_ptr&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1ListNode.html#a8f376c3aae32590e578a9a2382c3080a">operator[]</a> (size_t i) const</td></tr>
<tr class="memdesc:a8f376c3aae32590e578a9a2382c3080a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Child at specified index. <br /></td></tr>
<tr class="separator:a8f376c3aae32590e578a9a2382c3080a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46846baa7f27d87742ac727ca04ee964"><td class="memItemLeft" align="right" valign="top"><a id="a46846baa7f27d87742ac727ca04ee964"></a>
const std::shared_ptr&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1ListNode.html#a46846baa7f27d87742ac727ca04ee964">front</a> () const</td></tr>
<tr class="memdesc:a46846baa7f27d87742ac727ca04ee964"><td class="mdescLeft">&#160;</td><td class="mdescRight">First child, if any. <br /></td></tr>
<tr class="separator:a46846baa7f27d87742ac727ca04ee964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36f1d7e4209ea1a3a13dbac4388dca3c"><td class="memItemLeft" align="right" valign="top"><a id="a36f1d7e4209ea1a3a13dbac4388dca3c"></a>
const std::shared_ptr&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1ListNode.html#a36f1d7e4209ea1a3a13dbac4388dca3c">back</a> () const</td></tr>
<tr class="memdesc:a36f1d7e4209ea1a3a13dbac4388dca3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Last child, if any. <br /></td></tr>
<tr class="separator:a36f1d7e4209ea1a3a13dbac4388dca3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accafd34ae78610bd2b30a44b15d02272"><td class="memItemLeft" align="right" valign="top"><a id="accafd34ae78610bd2b30a44b15d02272"></a>
std::vector&lt; std::shared_ptr&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1ListNode.html#accafd34ae78610bd2b30a44b15d02272">elmts</a> () const</td></tr>
<tr class="memdesc:accafd34ae78610bd2b30a44b15d02272"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of all children. <br /></td></tr>
<tr class="separator:accafd34ae78610bd2b30a44b15d02272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab73ee60ce470911128667909198c1bd5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1ListNode.html#ab73ee60ce470911128667909198c1bd5">index</a> (const std::shared_ptr&lt; T &gt; &amp;node, size_t startAt=0) const</td></tr>
<tr class="memdesc:ab73ee60ce470911128667909198c1bd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the index for the specified node.  <a href="classSawyer_1_1Tree_1_1ListNode.html#ab73ee60ce470911128667909198c1bd5">More...</a><br /></td></tr>
<tr class="separator:ab73ee60ce470911128667909198c1bd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af609f1b317dfc8e9ea94c29e808deb2a"><td class="memItemLeft" align="right" valign="top"><a id="af609f1b317dfc8e9ea94c29e808deb2a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1ListNode.html#af609f1b317dfc8e9ea94c29e808deb2a">clear</a> ()</td></tr>
<tr class="memdesc:af609f1b317dfc8e9ea94c29e808deb2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all children. <br /></td></tr>
<tr class="separator:af609f1b317dfc8e9ea94c29e808deb2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfac776f90667c146d0b1bddfd05464c"><td class="memItemLeft" align="right" valign="top"><a id="acfac776f90667c146d0b1bddfd05464c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1ListNode.html#acfac776f90667c146d0b1bddfd05464c">push_back</a> (const std::shared_ptr&lt; T &gt; &amp;newChild)</td></tr>
<tr class="memdesc:acfac776f90667c146d0b1bddfd05464c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a child pointer. <br /></td></tr>
<tr class="separator:acfac776f90667c146d0b1bddfd05464c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8b86b1affea3a01274800998e817a79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1ListNode.html#ab8b86b1affea3a01274800998e817a79">insertAt</a> (size_t i, const std::shared_ptr&lt; T &gt; &amp;newChild)</td></tr>
<tr class="memdesc:ab8b86b1affea3a01274800998e817a79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert the node at the specified index.  <a href="classSawyer_1_1Tree_1_1ListNode.html#ab8b86b1affea3a01274800998e817a79">More...</a><br /></td></tr>
<tr class="separator:ab8b86b1affea3a01274800998e817a79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bb66d08fdfb61730dc20187ceccbb71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1ListNode.html#a1bb66d08fdfb61730dc20187ceccbb71">eraseAt</a> (size_t i)</td></tr>
<tr class="memdesc:a1bb66d08fdfb61730dc20187ceccbb71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase node at specified index.  <a href="classSawyer_1_1Tree_1_1ListNode.html#a1bb66d08fdfb61730dc20187ceccbb71">More...</a><br /></td></tr>
<tr class="separator:a1bb66d08fdfb61730dc20187ceccbb71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af67adbe42edc27ca8253a5ec7abf5abc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1ListNode.html#af67adbe42edc27ca8253a5ec7abf5abc">erase</a> (const std::shared_ptr&lt; T &gt; &amp;toErase, size_t startAt=0)</td></tr>
<tr class="memdesc:af67adbe42edc27ca8253a5ec7abf5abc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase the first occurrence of the specified child.  <a href="classSawyer_1_1Tree_1_1ListNode.html#af67adbe42edc27ca8253a5ec7abf5abc">More...</a><br /></td></tr>
<tr class="separator:af67adbe42edc27ca8253a5ec7abf5abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aa4898a980802aed664638390279b064f"><td class="memItemLeft" align="right" valign="top"><a id="aa4898a980802aed664638390279b064f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1ListNode.html#aa4898a980802aed664638390279b064f">setAt</a> (size_t i, const std::shared_ptr&lt; T &gt; &amp;child)</td></tr>
<tr class="memdesc:aa4898a980802aed664638390279b064f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make child edge point to a different child. <br /></td></tr>
<tr class="separator:aa4898a980802aed664638390279b064f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27b9a7105e1138dc2f0c1d39c25771f0"><td class="memItemLeft" align="right" valign="top"><a id="a27b9a7105e1138dc2f0c1d39c25771f0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1ListNode.html#a27b9a7105e1138dc2f0c1d39c25771f0">setAt</a> (size_t i, std::nullptr_t)</td></tr>
<tr class="memdesc:a27b9a7105e1138dc2f0c1d39c25771f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make child edge point to a different child. <br /></td></tr>
<tr class="separator:a27b9a7105e1138dc2f0c1d39c25771f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSawyer_1_1Tree_1_1Node"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSawyer_1_1Tree_1_1Node')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSawyer_1_1Tree_1_1Node.html">Sawyer::Tree::Node</a></td></tr>
<tr class="memitem:a8b77a92db50973f995d56a58493d5210 inherit pub_methods_classSawyer_1_1Tree_1_1Node"><td class="memItemLeft" align="right" valign="top"><a id="a8b77a92db50973f995d56a58493d5210"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1Node.html#a8b77a92db50973f995d56a58493d5210">Node</a> ()</td></tr>
<tr class="memdesc:a8b77a92db50973f995d56a58493d5210 inherit pub_methods_classSawyer_1_1Tree_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an empty node. <br /></td></tr>
<tr class="separator:a8b77a92db50973f995d56a58493d5210 inherit pub_methods_classSawyer_1_1Tree_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae31249ddaef7a54133fbf30e3e7c3114 inherit pub_methods_classSawyer_1_1Tree_1_1Node"><td class="memItemLeft" align="right" valign="top"><a id="ae31249ddaef7a54133fbf30e3e7c3114"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1Node.html#ae31249ddaef7a54133fbf30e3e7c3114">~Node</a> ()</td></tr>
<tr class="memdesc:ae31249ddaef7a54133fbf30e3e7c3114 inherit pub_methods_classSawyer_1_1Tree_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nodes are polymorphic. <br /></td></tr>
<tr class="separator:ae31249ddaef7a54133fbf30e3e7c3114 inherit pub_methods_classSawyer_1_1Tree_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc356dd9643c22dc1f8e81788ad8e061 inherit pub_methods_classSawyer_1_1Tree_1_1Node"><td class="memItemLeft" align="right" valign="top"><a id="adc356dd9643c22dc1f8e81788ad8e061"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Node</b> (const <a class="el" href="classSawyer_1_1Tree_1_1Node.html">Node</a> &amp;)=delete</td></tr>
<tr class="separator:adc356dd9643c22dc1f8e81788ad8e061 inherit pub_methods_classSawyer_1_1Tree_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42ec1a51b3cbaab1be010056d8267a58 inherit pub_methods_classSawyer_1_1Tree_1_1Node"><td class="memItemLeft" align="right" valign="top"><a id="a42ec1a51b3cbaab1be010056d8267a58"></a>
<a class="el" href="classSawyer_1_1Tree_1_1Node.html">Node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classSawyer_1_1Tree_1_1Node.html">Node</a> &amp;)=delete</td></tr>
<tr class="separator:a42ec1a51b3cbaab1be010056d8267a58 inherit pub_methods_classSawyer_1_1Tree_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12e22489ac094bb85f9254c955fd5e1a inherit pub_methods_classSawyer_1_1Tree_1_1Node"><td class="memTemplParams" colspan="2">template&lt;class Functor &gt; </td></tr>
<tr class="memitem:a12e22489ac094bb85f9254c955fd5e1a inherit pub_methods_classSawyer_1_1Tree_1_1Node"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceSawyer_1_1Tree.html#a704adef2b0317fd76cc589b14c11fa5d">TraversalAction</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1Node.html#a12e22489ac094bb85f9254c955fd5e1a">traverse</a> (Functor functor)</td></tr>
<tr class="memdesc:a12e22489ac094bb85f9254c955fd5e1a inherit pub_methods_classSawyer_1_1Tree_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse the tree starting at this node and following child pointers.  <a href="classSawyer_1_1Tree_1_1Node.html#a12e22489ac094bb85f9254c955fd5e1a">More...</a><br /></td></tr>
<tr class="separator:a12e22489ac094bb85f9254c955fd5e1a inherit pub_methods_classSawyer_1_1Tree_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8758a487d093026d1b70667910bb8f2 inherit pub_methods_classSawyer_1_1Tree_1_1Node"><td class="memTemplParams" colspan="2">template&lt;class Functor &gt; </td></tr>
<tr class="memitem:ab8758a487d093026d1b70667910bb8f2 inherit pub_methods_classSawyer_1_1Tree_1_1Node"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceSawyer_1_1Tree.html#a704adef2b0317fd76cc589b14c11fa5d">TraversalAction</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1Node.html#ab8758a487d093026d1b70667910bb8f2">traverse</a> (Functor functor) const</td></tr>
<tr class="memdesc:ab8758a487d093026d1b70667910bb8f2 inherit pub_methods_classSawyer_1_1Tree_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse the tree starting at this node and following child pointers.  <a href="classSawyer_1_1Tree_1_1Node.html#ab8758a487d093026d1b70667910bb8f2">More...</a><br /></td></tr>
<tr class="separator:ab8758a487d093026d1b70667910bb8f2 inherit pub_methods_classSawyer_1_1Tree_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55a0fa7a56899667f5258d5a29e39db9 inherit pub_methods_classSawyer_1_1Tree_1_1Node"><td class="memTemplParams" colspan="2">template&lt;class T , class Functor &gt; </td></tr>
<tr class="memitem:a55a0fa7a56899667f5258d5a29e39db9 inherit pub_methods_classSawyer_1_1Tree_1_1Node"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceSawyer_1_1Tree.html#a704adef2b0317fd76cc589b14c11fa5d">TraversalAction</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1Node.html#a55a0fa7a56899667f5258d5a29e39db9">traverseType</a> (Functor functor)</td></tr>
<tr class="memdesc:a55a0fa7a56899667f5258d5a29e39db9 inherit pub_methods_classSawyer_1_1Tree_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse the tree restricted by type.  <a href="classSawyer_1_1Tree_1_1Node.html#a55a0fa7a56899667f5258d5a29e39db9">More...</a><br /></td></tr>
<tr class="separator:a55a0fa7a56899667f5258d5a29e39db9 inherit pub_methods_classSawyer_1_1Tree_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ac56fde8f00e6fea77dfe2cba947347 inherit pub_methods_classSawyer_1_1Tree_1_1Node"><td class="memTemplParams" colspan="2">template&lt;class T , class Functor &gt; </td></tr>
<tr class="memitem:a8ac56fde8f00e6fea77dfe2cba947347 inherit pub_methods_classSawyer_1_1Tree_1_1Node"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceSawyer_1_1Tree.html#a704adef2b0317fd76cc589b14c11fa5d">TraversalAction</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1Node.html#a8ac56fde8f00e6fea77dfe2cba947347">traverseType</a> (Functor functor) const</td></tr>
<tr class="memdesc:a8ac56fde8f00e6fea77dfe2cba947347 inherit pub_methods_classSawyer_1_1Tree_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse the tree restricted by type.  <a href="classSawyer_1_1Tree_1_1Node.html#a8ac56fde8f00e6fea77dfe2cba947347">More...</a><br /></td></tr>
<tr class="separator:a8ac56fde8f00e6fea77dfe2cba947347 inherit pub_methods_classSawyer_1_1Tree_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfcb73b3bb170715837940ad4c9d44e5 inherit pub_methods_classSawyer_1_1Tree_1_1Node"><td class="memTemplParams" colspan="2">template&lt;class Functor &gt; </td></tr>
<tr class="memitem:acfcb73b3bb170715837940ad4c9d44e5 inherit pub_methods_classSawyer_1_1Tree_1_1Node"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceSawyer_1_1Tree.html#a704adef2b0317fd76cc589b14c11fa5d">TraversalAction</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1Node.html#acfcb73b3bb170715837940ad4c9d44e5">traverseParents</a> (Functor functor)</td></tr>
<tr class="memdesc:acfcb73b3bb170715837940ad4c9d44e5 inherit pub_methods_classSawyer_1_1Tree_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse the tree by following parent pointers.  <a href="classSawyer_1_1Tree_1_1Node.html#acfcb73b3bb170715837940ad4c9d44e5">More...</a><br /></td></tr>
<tr class="separator:acfcb73b3bb170715837940ad4c9d44e5 inherit pub_methods_classSawyer_1_1Tree_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af805d62626a1875c4ca56e9bb55f413f inherit pub_methods_classSawyer_1_1Tree_1_1Node"><td class="memTemplParams" colspan="2">template&lt;class Functor &gt; </td></tr>
<tr class="memitem:af805d62626a1875c4ca56e9bb55f413f inherit pub_methods_classSawyer_1_1Tree_1_1Node"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceSawyer_1_1Tree.html#a704adef2b0317fd76cc589b14c11fa5d">TraversalAction</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1Node.html#af805d62626a1875c4ca56e9bb55f413f">traverseParents</a> (Functor functor) const</td></tr>
<tr class="memdesc:af805d62626a1875c4ca56e9bb55f413f inherit pub_methods_classSawyer_1_1Tree_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse the tree by following parent pointers.  <a href="classSawyer_1_1Tree_1_1Node.html#af805d62626a1875c4ca56e9bb55f413f">More...</a><br /></td></tr>
<tr class="separator:af805d62626a1875c4ca56e9bb55f413f inherit pub_methods_classSawyer_1_1Tree_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8197da73d0542fbd68dbd7bdb0d08277 inherit pub_methods_classSawyer_1_1Tree_1_1Node"><td class="memTemplParams" colspan="2"><a id="a8197da73d0542fbd68dbd7bdb0d08277"></a>
template&lt;class Predicate &gt; </td></tr>
<tr class="memitem:a8197da73d0542fbd68dbd7bdb0d08277 inherit pub_methods_classSawyer_1_1Tree_1_1Node"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceSawyer_1_1Tree.html#af4a9b1ac7a4cb3e8585398905c9ebe5e">NodePtr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1Node.html#a8197da73d0542fbd68dbd7bdb0d08277">find</a> (Predicate predicate)</td></tr>
<tr class="memdesc:a8197da73d0542fbd68dbd7bdb0d08277 inherit pub_methods_classSawyer_1_1Tree_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse an tree to find the first node satisfying the predicate. <br /></td></tr>
<tr class="separator:a8197da73d0542fbd68dbd7bdb0d08277 inherit pub_methods_classSawyer_1_1Tree_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7254d0b0fbafe76e79ee15d072debef2 inherit pub_methods_classSawyer_1_1Tree_1_1Node"><td class="memTemplParams" colspan="2"><a id="a7254d0b0fbafe76e79ee15d072debef2"></a>
template&lt;class Predicate &gt; </td></tr>
<tr class="memitem:a7254d0b0fbafe76e79ee15d072debef2 inherit pub_methods_classSawyer_1_1Tree_1_1Node"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceSawyer_1_1Tree.html#af4a9b1ac7a4cb3e8585398905c9ebe5e">NodePtr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1Node.html#a7254d0b0fbafe76e79ee15d072debef2">find</a> (Predicate predicate) const</td></tr>
<tr class="memdesc:a7254d0b0fbafe76e79ee15d072debef2 inherit pub_methods_classSawyer_1_1Tree_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse an tree to find the first node satisfying the predicate. <br /></td></tr>
<tr class="separator:a7254d0b0fbafe76e79ee15d072debef2 inherit pub_methods_classSawyer_1_1Tree_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6103b7f7672831b655e70111c3f7bc25 inherit pub_methods_classSawyer_1_1Tree_1_1Node"><td class="memTemplParams" colspan="2"><a id="a6103b7f7672831b655e70111c3f7bc25"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a6103b7f7672831b655e70111c3f7bc25 inherit pub_methods_classSawyer_1_1Tree_1_1Node"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1Node.html#a6103b7f7672831b655e70111c3f7bc25">findType</a> ()</td></tr>
<tr class="memdesc:a6103b7f7672831b655e70111c3f7bc25 inherit pub_methods_classSawyer_1_1Tree_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find first child that's the specified type. <br /></td></tr>
<tr class="separator:a6103b7f7672831b655e70111c3f7bc25 inherit pub_methods_classSawyer_1_1Tree_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1561c564e286e64238f26b3f9f2992c5 inherit pub_methods_classSawyer_1_1Tree_1_1Node"><td class="memTemplParams" colspan="2"><a id="a1561c564e286e64238f26b3f9f2992c5"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a1561c564e286e64238f26b3f9f2992c5 inherit pub_methods_classSawyer_1_1Tree_1_1Node"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1Node.html#a1561c564e286e64238f26b3f9f2992c5">findType</a> () const</td></tr>
<tr class="memdesc:a1561c564e286e64238f26b3f9f2992c5 inherit pub_methods_classSawyer_1_1Tree_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find first child that's the specified type. <br /></td></tr>
<tr class="separator:a1561c564e286e64238f26b3f9f2992c5 inherit pub_methods_classSawyer_1_1Tree_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfaaf4cbba997f3d2ab5a62b782457e1 inherit pub_methods_classSawyer_1_1Tree_1_1Node"><td class="memTemplParams" colspan="2"><a id="acfaaf4cbba997f3d2ab5a62b782457e1"></a>
template&lt;class T , class Predicate &gt; </td></tr>
<tr class="memitem:acfaaf4cbba997f3d2ab5a62b782457e1 inherit pub_methods_classSawyer_1_1Tree_1_1Node"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1Node.html#acfaaf4cbba997f3d2ab5a62b782457e1">findType</a> (Predicate predicate)</td></tr>
<tr class="memdesc:acfaaf4cbba997f3d2ab5a62b782457e1 inherit pub_methods_classSawyer_1_1Tree_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find first child of specified type satisfying the predicate. <br /></td></tr>
<tr class="separator:acfaaf4cbba997f3d2ab5a62b782457e1 inherit pub_methods_classSawyer_1_1Tree_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20b890a3ab635375142453d094df9330 inherit pub_methods_classSawyer_1_1Tree_1_1Node"><td class="memTemplParams" colspan="2"><a id="a20b890a3ab635375142453d094df9330"></a>
template&lt;class T , class Predicate &gt; </td></tr>
<tr class="memitem:a20b890a3ab635375142453d094df9330 inherit pub_methods_classSawyer_1_1Tree_1_1Node"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1Node.html#a20b890a3ab635375142453d094df9330">findType</a> (Predicate predicate) const</td></tr>
<tr class="memdesc:a20b890a3ab635375142453d094df9330 inherit pub_methods_classSawyer_1_1Tree_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find first child of specified type satisfying the predicate. <br /></td></tr>
<tr class="separator:a20b890a3ab635375142453d094df9330 inherit pub_methods_classSawyer_1_1Tree_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b4ace5625e64e9f1265711cd6916513 inherit pub_methods_classSawyer_1_1Tree_1_1Node"><td class="memTemplParams" colspan="2"><a id="a6b4ace5625e64e9f1265711cd6916513"></a>
template&lt;class Predicate &gt; </td></tr>
<tr class="memitem:a6b4ace5625e64e9f1265711cd6916513 inherit pub_methods_classSawyer_1_1Tree_1_1Node"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceSawyer_1_1Tree.html#af4a9b1ac7a4cb3e8585398905c9ebe5e">NodePtr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1Node.html#a6b4ace5625e64e9f1265711cd6916513">findParent</a> (Predicate predicate)</td></tr>
<tr class="memdesc:a6b4ace5625e64e9f1265711cd6916513 inherit pub_methods_classSawyer_1_1Tree_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find closest ancestor that satifies the predicate. <br /></td></tr>
<tr class="separator:a6b4ace5625e64e9f1265711cd6916513 inherit pub_methods_classSawyer_1_1Tree_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a286ceb28a5f5f5db003b6626bd22dabd inherit pub_methods_classSawyer_1_1Tree_1_1Node"><td class="memTemplParams" colspan="2"><a id="a286ceb28a5f5f5db003b6626bd22dabd"></a>
template&lt;class Predicate &gt; </td></tr>
<tr class="memitem:a286ceb28a5f5f5db003b6626bd22dabd inherit pub_methods_classSawyer_1_1Tree_1_1Node"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceSawyer_1_1Tree.html#af4a9b1ac7a4cb3e8585398905c9ebe5e">NodePtr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1Node.html#a286ceb28a5f5f5db003b6626bd22dabd">findParent</a> (Predicate predicate) const</td></tr>
<tr class="memdesc:a286ceb28a5f5f5db003b6626bd22dabd inherit pub_methods_classSawyer_1_1Tree_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find closest ancestor that satifies the predicate. <br /></td></tr>
<tr class="separator:a286ceb28a5f5f5db003b6626bd22dabd inherit pub_methods_classSawyer_1_1Tree_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ded13ab780629960a759b2dd18cad1a inherit pub_methods_classSawyer_1_1Tree_1_1Node"><td class="memTemplParams" colspan="2"><a id="a3ded13ab780629960a759b2dd18cad1a"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a3ded13ab780629960a759b2dd18cad1a inherit pub_methods_classSawyer_1_1Tree_1_1Node"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1Node.html#a3ded13ab780629960a759b2dd18cad1a">findParentType</a> ()</td></tr>
<tr class="memdesc:a3ded13ab780629960a759b2dd18cad1a inherit pub_methods_classSawyer_1_1Tree_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find closest ancestor of specified type. <br /></td></tr>
<tr class="separator:a3ded13ab780629960a759b2dd18cad1a inherit pub_methods_classSawyer_1_1Tree_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6aca24c52a60231c78ff39899a4ed15 inherit pub_methods_classSawyer_1_1Tree_1_1Node"><td class="memTemplParams" colspan="2"><a id="ad6aca24c52a60231c78ff39899a4ed15"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ad6aca24c52a60231c78ff39899a4ed15 inherit pub_methods_classSawyer_1_1Tree_1_1Node"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1Node.html#ad6aca24c52a60231c78ff39899a4ed15">findParentType</a> () const</td></tr>
<tr class="memdesc:ad6aca24c52a60231c78ff39899a4ed15 inherit pub_methods_classSawyer_1_1Tree_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find closest ancestor of specified type. <br /></td></tr>
<tr class="separator:ad6aca24c52a60231c78ff39899a4ed15 inherit pub_methods_classSawyer_1_1Tree_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6711558f6fef04220551a0a3ec63d9d6 inherit pub_methods_classSawyer_1_1Tree_1_1Node"><td class="memTemplParams" colspan="2"><a id="a6711558f6fef04220551a0a3ec63d9d6"></a>
template&lt;class T , class Predicate &gt; </td></tr>
<tr class="memitem:a6711558f6fef04220551a0a3ec63d9d6 inherit pub_methods_classSawyer_1_1Tree_1_1Node"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1Node.html#a6711558f6fef04220551a0a3ec63d9d6">findParentType</a> (Predicate predicate)</td></tr>
<tr class="memdesc:a6711558f6fef04220551a0a3ec63d9d6 inherit pub_methods_classSawyer_1_1Tree_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find closest ancestor of specified type that satisfies the predicate. <br /></td></tr>
<tr class="separator:a6711558f6fef04220551a0a3ec63d9d6 inherit pub_methods_classSawyer_1_1Tree_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9900caa6c9417c05448a1fba7638b67 inherit pub_methods_classSawyer_1_1Tree_1_1Node"><td class="memTemplParams" colspan="2"><a id="aa9900caa6c9417c05448a1fba7638b67"></a>
template&lt;class T , class Predicate &gt; </td></tr>
<tr class="memitem:aa9900caa6c9417c05448a1fba7638b67 inherit pub_methods_classSawyer_1_1Tree_1_1Node"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1Node.html#aa9900caa6c9417c05448a1fba7638b67">findParentType</a> (Predicate predicate) const</td></tr>
<tr class="memdesc:aa9900caa6c9417c05448a1fba7638b67 inherit pub_methods_classSawyer_1_1Tree_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find closest ancestor of specified type that satisfies the predicate. <br /></td></tr>
<tr class="separator:aa9900caa6c9417c05448a1fba7638b67 inherit pub_methods_classSawyer_1_1Tree_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_attribs_classSawyer_1_1Tree_1_1Node"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classSawyer_1_1Tree_1_1Node')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classSawyer_1_1Tree_1_1Node.html">Sawyer::Tree::Node</a></td></tr>
<tr class="memitem:a43c6e37a263bae722919e7820a913213 inherit pub_attribs_classSawyer_1_1Tree_1_1Node"><td class="memItemLeft" align="right" valign="top"><a id="a43c6e37a263bae722919e7820a913213"></a>
<a class="el" href="classSawyer_1_1Tree_1_1ParentEdge.html">ParentEdge</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1Node.html#a43c6e37a263bae722919e7820a913213">parent</a></td></tr>
<tr class="memdesc:a43c6e37a263bae722919e7820a913213 inherit pub_attribs_classSawyer_1_1Tree_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the parent node, if any. <br /></td></tr>
<tr class="separator:a43c6e37a263bae722919e7820a913213 inherit pub_attribs_classSawyer_1_1Tree_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2de457adf4e432ea3f3f8c7bb2b4972 inherit pub_attribs_classSawyer_1_1Tree_1_1Node"><td class="memItemLeft" align="right" valign="top"><a id="ab2de457adf4e432ea3f3f8c7bb2b4972"></a>
<a class="el" href="classSawyer_1_1Tree_1_1Children.html">Children</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1Node.html#ab2de457adf4e432ea3f3f8c7bb2b4972">children</a></td></tr>
<tr class="memdesc:ab2de457adf4e432ea3f3f8c7bb2b4972 inherit pub_attribs_classSawyer_1_1Tree_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of pointers to children. <br /></td></tr>
<tr class="separator:ab2de457adf4e432ea3f3f8c7bb2b4972 inherit pub_attribs_classSawyer_1_1Tree_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab73ee60ce470911128667909198c1bd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab73ee60ce470911128667909198c1bd5">&#9670;&nbsp;</a></span>index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt; size_t &gt; <a class="el" href="classSawyer_1_1Tree_1_1ListNode.html">Sawyer::Tree::ListNode</a>&lt; T &gt;::index </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>startAt</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the index for the specified node. </p>
<p>Finds the index for the first child at or after <code>startAt</code> and returns its index. Returns nothing if the specified node is not found. </p>

<p class="definition">Definition at line <a class="el" href="Tree_8h_source.html#l01172">1172</a> of file <a class="el" href="Tree_8h_source.html">Tree.h</a>.</p>

</div>
</div>
<a id="ab8b86b1affea3a01274800998e817a79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8b86b1affea3a01274800998e817a79">&#9670;&nbsp;</a></span>insertAt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSawyer_1_1Tree_1_1ListNode.html">Sawyer::Tree::ListNode</a>&lt; T &gt;::insertAt </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>newChild</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert the node at the specified index. </p>
<p>The node must not already have a parent. The index must be greater than or equal to zero and less than or equal to the current number of nodes. Upon return, the node that was inserted will be found at index <code>i</code>. </p>

<p class="definition">Definition at line <a class="el" href="Tree_8h_source.html#l00794">794</a> of file <a class="el" href="Tree_8h_source.html">Tree.h</a>.</p>

<p class="reference">References <a class="el" href="Tree_8h_source.html#l00485">Sawyer::Tree::Node::children</a>.</p>

</div>
</div>
<a id="a1bb66d08fdfb61730dc20187ceccbb71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bb66d08fdfb61730dc20187ceccbb71">&#9670;&nbsp;</a></span>eraseAt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSawyer_1_1Tree_1_1ListNode.html">Sawyer::Tree::ListNode</a>&lt; T &gt;::eraseAt </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase node at specified index. </p>
<p>If the index is out of range then nothing happens. </p>

<p class="definition">Definition at line <a class="el" href="Tree_8h_source.html#l00801">801</a> of file <a class="el" href="Tree_8h_source.html">Tree.h</a>.</p>

<p class="reference">References <a class="el" href="Tree_8h_source.html#l00485">Sawyer::Tree::Node::children</a>.</p>

</div>
</div>
<a id="af67adbe42edc27ca8253a5ec7abf5abc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af67adbe42edc27ca8253a5ec7abf5abc">&#9670;&nbsp;</a></span>erase()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt; size_t &gt; <a class="el" href="classSawyer_1_1Tree_1_1ListNode.html">Sawyer::Tree::ListNode</a>&lt; T &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>toErase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>startAt</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase the first occurrence of the specified child. </p>
<p>Erases the first occurrence of the specified child at or after the starting index.</p>
<p>If a child was erased, then return the index of the erased child. </p>

<p class="definition">Definition at line <a class="el" href="Tree_8h_source.html#l01182">1182</a> of file <a class="el" href="Tree_8h_source.html">Tree.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="Tree_8h_source.html">Tree.h</a></li>
</ul>
</div><!-- contents -->
<div class="ttc" id="aclassSawyer_1_1Tree_1_1Node_html_a43c6e37a263bae722919e7820a913213"><div class="ttname"><a href="classSawyer_1_1Tree_1_1Node.html#a43c6e37a263bae722919e7820a913213">Sawyer::Tree::Node::parent</a></div><div class="ttdeci">ParentEdge parent</div><div class="ttdoc">Pointer to the parent node, if any.</div><div class="ttdef"><b>Definition:</b> <a href="Tree_8h_source.html#l00484">Tree.h:484</a></div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Dec 19 2022 23:40:28 for ROSE by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
