<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROSE: AstMatching Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="ROSE"/>
<link href="roseDoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ROSE
   &#160;<span id="projectnumber">0.11.96.11</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,true,'search.html','Search');
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classAstMatching-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">AstMatching Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>The <a class="el" href="classAstMatching.html" title="The AstMatching class allows to specify arbitrary large patterns to be matched on any subtree in the ...">AstMatching</a> class allows to specify arbitrary large patterns to be matched on any subtree in the AST. </p>
<p>The <a class="el" href="classAstMatching.html" title="The AstMatching class allows to specify arbitrary large patterns to be matched on any subtree in the ...">AstMatching</a> class comes with its own internal parser. The match expression is provided as a string and checked for syntax errors. Type names of AST nodes can be used to specify arbitrarily large AST patterns. Additionally variables and some operators are available to allow the specification of complex patterns and determine the address of AST nodes through values stored in variables. Subtrees can also be ignored in the matching by using '_'. The binary operator '|' allows to combine different matching subexpressions into one expression.</p>
<p>In the following example we match assignments with variables on both sides, such as x=y, and assign the pointer to the respective AST node to variable $R. This variable can then be accessed by name in a C++ map to obtain the pointer.</p>
<div class="fragment"><div class="line"><a class="code" href="classAstMatching.html">AstMatching</a> m;</div>
<div class="line">AstMatchingResult res=m.match(<span class="stringliteral">&quot;$R=AssignOp(SgVarRef,SgVarRef)&quot;</span>,astRoot);</div>
</div><!-- fragment --><p>The variable 'astRoot' is a pointer to some node in the AST. The matcher can be started at the root of the AST, but also at any other node of the AST.</p>
<p>In the above example all subtrees representing an assign operation with two variables as operands would be matched. The dollar sign denotes a variable. In the above example the pointers to the matched subtrees are assigned to the variable $R. The result with all matched assignments is stored in the variable res of type AstMatchingResult. The matching result is a set of maps where each map represents the results for one successful match and holds pairs of a variable name and a pointer to the respective AST subtree. For example, if there are n assignments in a program, then there will be n maps, and in each map varibale "$R" can be accessed to get the respective pointer to the matched assignment operator. A match expression can have arbitrary many variables, e.g. we could also use AssignOp($LHS=SgVarRef,$RHS=SgVarRef) to obtain all pairs of LHS and RHS pointers of above assignment operators with two variables. More generally, we can also use "$R=AssignOp($LHS,$RHS)", to obtain all three pointers for each match. The pointer values to the respective AST nodes can be accessed by the variable name in the result map (see Section <a class="el" href="classAstMatching.html#matchresults">Accessing matching results</a> for more details)</p>
<h1><a class="anchor" id="variables"></a>
Variables</h1>
<p>Variables are used to specify that pointers to matched subtrees are stored in the matching result. An arbitrary number of variables can be used and two forms of use are supported. A variable is denoted with a leading dollar sign an arbitrary number of letters and underscores (a single underscore is used as wildcard). A variable assignment notation can be used to assign the pointers of a specified pattern to a variable. For example, $R=<a class="el" href="classSgAssignOp.html">SgAssignOp(SgVarRef,_,_)</a> is matched with all assignments which have a variable on the left hand side and some expression on the right hand side. Alternatively we can also use $R=<a class="el" href="classSgAssignOp.html">SgAssignOp</a>($X=SgVarRef,$Y=_) - in this case we also store a pointer to the matched variable node and a pointer to the expression on the rhs in the match result. For the expression $Y=_ we can also simply write $Y as a shorthand, thus we can also use $R=<a class="el" href="classSgAssignOp.html">SgAssignOp</a>($X=SgVarRef,$Y) instead. The assignment of variables to variables, such as $Z=$Y, is not allowed.</p>
<h1><a class="anchor" id="nullvalues"></a>
Null-values</h1>
<p>Null values can be explicitely matched by using "null" in a match expression. For example $X=<a class="el" href="classSgForStatement.html" title="This class represents the concept of a for loop.">SgForStatement(_,_,_,_,null)</a> would match all SgForStatement-terms with the 5th argument being 0.</p>
<h1><a class="anchor" id="wildcard"></a>
Wildcard '_' for matching any subtree</h1>
<p>Wildcards for certain arguments allow for matching nodes with specific arity. For example, if we use <a class="el" href="classSgAssignOp.html">SgAssignOp</a>($LHS,_) we can match all assignment nodes in the AST, bind the left hand side to $LHS, but ignore the right hand side of the expression. In other words, '_' allows for any node or null pointer value to be present. Note, patterns in those subtrees are still matched in contrast to when using the '#' operator (see <a class="el" href="classAstMatching.html#hashop">Operator '#'</a>).</p>
<p>The wildcard can also be used for the node name. For example, "$A=_(_,_)" matches all binary nodes. Note that matches are only included in the matching result if at least one variable is bound.</p>
<h1><a class="anchor" id="ellipseop"></a>
Operator '..'</h1>
<p>This operator can be used in match expressions to specify that an arbitrary number of arguments can follow. For example we can use SgBlock($First,..) to match the very first statement in a SgBlock. Since SgBlocks can have arbitrary arity this is quite useful in this respect. The operator '..' can only be used at most once when specifying the arity of a node, but arbitrary often in a match pattern, e.g. SgBlock(<a class="el" href="classSgForStatement.html" title="This class represents the concept of a for loop.">SgForStatement</a>($Cond,..),..) is OK, but SgBlock(_,..,_,..) is not.</p>
<h1><a class="anchor" id="orop"></a>
Operator "|"</h1>
<p>This operator allows to combine multiple match expressions. For example "SgAddOp($L,$R)|SgSubOp($L,$R)" will match either a <a class="el" href="classSgAddOp.html">SgAddOp</a> and bind pointers to its two children to $L and $R, or it will match SgSubOp and bind $L and $R to the children of SgSubOp. Using the same variable multiple times allows to bind similar information in different nodes at different positions (e.g. the body in different loop constructs). The operator '|' performs a short-circuit evaluation, thus, matching is performed from left to right and the matching stops as soon as one of the patterns can be successfully matched.</p>
<h1><a class="anchor" id="hashop"></a>
Operator '#'</h1>
<p>Placement of operator '#' in a match expression allows to exclude arbitrary subtrees from applying the match operation in subsequent matches. I.e. the marked subtrees are not traversed. For example if we only want to match the for-statements at the outer most level, but no nested for statements, we can use:</p>
<div class="fragment"><div class="line">$FOR=<a class="code" href="classSgForStatement.html">SgForStatement</a>(_,_,_,#_)</div>
</div><!-- fragment --><p>This matches only the outer for-statements, as the body (4th argument) is excluded from applying the match operator. Without '#' we would also match the inner loops.</p>
<h1><a class="anchor" id="examples"></a>
Examples</h1>
<ol>
<li>
<p class="startli">match("$R=AssignOp(_,_)",astRoot);<br  />
 Match all assignment operators in an AST.</p>
<p class="endli"></p>
</li>
<li>
match("$R=<a class="el" href="classSgAssignOp.html">SgAssignOp(SgVarRefExp,SgIntVal)</a>,astRoot);<br  />
 Match all assignment operators with a variable on the lhs and an integer value on the rhs. </li>
<li>
<p class="startli">match("$FORROOT=SgForStatement(_,_,_,#_)",astRoot);<br  />
 Match all outer most for loops, but no nested for-loops. The operator '#' ensures that the match expression is not applied on the AST representing the body of the for-statement (4th argument). The pointer to the root of the AST representing the for-loop is bound to $FORROOT.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">match("$N=_(null)",astRoot);<br  />
 Match all nodes with arity 1 and a single null value. The main purpose for such match-expressions is to perform consistency checks in the AST.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">match("$N=SgInitializedName(null)",astRoot); // many of those exist in a default ROSE AST<br  />
 Specifically match all <a class="el" href="classSgInitializedName.html" title="This class represents the notion of a declared variable.">SgInitializedName</a> nodes with a null pointer.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">match("SgForStatement($LoopCond,_,_,_)|SgWhile($LoopCond,_)|SgDoWhile(_,$LoopCond)",astRoot);<br  />
 Match different Loop constructs and bind variable $LoopCond to the respective loop condition.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">match("SgAssignOp(SgVarRef,SgAddOp($X,$Y))",astRoot)<br  />
 Match assignments with a variable on the rhs and an add-operator on the rhs(root). The pointers to the sub-ASTs representing the lhs and rhs of the add-operator are bound to variables $X and $Y for each match in the AST:</p>
<p class="endli"></p>
</li>
<li>
match("$Func=SgFunctionCallExp($FuncRef,$Params)",astRoot)<br  />
 Match all function calls and bind variable $Func to the root of each such expression, bind $FuncRef to the <a class="el" href="classSgFunctionRefExp.html" title="This class represents the function being called and must be assembled in the SgFunctionCall with the ...">SgFunctionRefExp</a> (which can be used to obtain the name) and $Params to the AST representing the parameters: </li>
</ol>
<h1><a class="anchor" id="matchresults"></a>
Accessing matching results</h1>
<p>The results are collected in a std::list of std::maps. Each map represents on successful match at one location in the AST and contains all the bound variables. The variables can be accessed by name and using the random access operator. The number of elements (=maps) in the list corresponds to the number of matched patterns in the AST.</p>
<p>The pointers to matched patterns in the AST can be accessed as follows: e.g. </p><div class="fragment"><div class="line">1: <a class="code" href="classAstMatching.html">AstMatching</a> m;</div>
<div class="line">2: MatchResult res=m.<a class="code" href="classAstMatching.html#a62ae5f7b9cb3753f0fa86da65f8d8894">performMatching</a>(<span class="stringliteral">&quot;$R=SgInitalizedName($X)&quot;</span>,root);</div>
<div class="line">3: <a class="code" href="classSgNode.html">SgNode</a>* myRvariable=res[<span class="stringliteral">&quot;$R&quot;</span>];</div>
<div class="line">4: <a class="code" href="classSgNode.html">SgNode</a>* myXvariable=res[<span class="stringliteral">&quot;$X&quot;</span>];</div>
</div><!-- fragment --><p>In line 1 the <a class="el" href="classAstMatching.html" title="The AstMatching class allows to specify arbitrary large patterns to be matched on any subtree in the ...">AstMatching</a> object is created. In line 2 the match-expression and the root node of the AST is provided to the matching mechanism and the results are computed. In line 3 the variable $R (and in line 4 variable $X) is accessed. This pointer value refers to the node in the AST which was matched successfully in the match expression. The matching can be performed on any AST subtree of interest, by letting 'root' point to the respective AST subtree when the match operation is started.</p>
<p>The number of elements in the match result shows how often the match expression was successfully matched and at least one variable was bound. Consequently, res.size()==0 means that the pattern could not be matched anywhere.</p>
<h1><a class="anchor" id="howtowrite"></a>
How to get started writing match expressions</h1>
<p>Knowing the exact structure of an AST with all the names of nodes can be difficult. Therefore, an existing AST (or any of its subtrees) can be printed in the exact same format as the matcher expects as input.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;AstTerm.h&quot;</span></div>
<div class="line">...</div>
<div class="line">cout&lt;&lt;AstTerm::astTermWithNullValuesToString(root);</div>
</div><!-- fragment --><p>Prints on stdout for an AST with root node 'root' the entire AST in the exact same format as the function performMatching expects as first argument. The string can be refined with additional variables and operators. The namespace <a class="el" href="classAstTerm.html">AstTerm</a> contains some more functions to print the AST with number values, properly indented as a tree, with types, etc. </p>

<p class="definition">Definition at line <a class="el" href="AstMatching_8h_source.html#l00187">187</a> of file <a class="el" href="AstMatching_8h_source.html">AstMatching.h</a>.</p>
</div>
<p><code>#include &lt;<a class="el" href="AstMatching_8h_source.html">AstMatching.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a62ae5f7b9cb3753f0fa86da65f8d8894"><td class="memItemLeft" align="right" valign="top">MatchResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAstMatching.html#a62ae5f7b9cb3753f0fa86da65f8d8894">performMatching</a> (std::string matchExpression, <a class="el" href="classSgNode.html">SgNode</a> *root)</td></tr>
<tr class="memdesc:a62ae5f7b9cb3753f0fa86da65f8d8894"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the main function to be called for matching.  <a href="classAstMatching.html#a62ae5f7b9cb3753f0fa86da65f8d8894">More...</a><br /></td></tr>
<tr class="separator:a62ae5f7b9cb3753f0fa86da65f8d8894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5199a1b3c979dffc63877e26d3f17916"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAstMatching.html#a5199a1b3c979dffc63877e26d3f17916">AstMatching</a> (std::string matchExpression, <a class="el" href="classSgNode.html">SgNode</a> *root)</td></tr>
<tr class="memdesc:a5199a1b3c979dffc63877e26d3f17916"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor as a all-in-one solution.  <a href="classAstMatching.html#a5199a1b3c979dffc63877e26d3f17916">More...</a><br /></td></tr>
<tr class="separator:a5199a1b3c979dffc63877e26d3f17916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a805d9e2b097f7b1106c4541330f06a64"><td class="memItemLeft" align="right" valign="top">MatchResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAstMatching.html#a805d9e2b097f7b1106c4541330f06a64">getResult</a> ()</td></tr>
<tr class="memdesc:a805d9e2b097f7b1106c4541330f06a64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows to access the match result if the match expression was provided as an argument to the constructor.  <a href="classAstMatching.html#a805d9e2b097f7b1106c4541330f06a64">More...</a><br /></td></tr>
<tr class="separator:a805d9e2b097f7b1106c4541330f06a64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b62ec3b8ba7e8adef83aa9c4c61d985"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAstMatching.html#a0b62ec3b8ba7e8adef83aa9c4c61d985">printMatchOperationsSequence</a> ()</td></tr>
<tr class="memdesc:a0b62ec3b8ba7e8adef83aa9c4c61d985"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is only for information purposes.  <a href="classAstMatching.html#a0b62ec3b8ba7e8adef83aa9c4c61d985">More...</a><br /></td></tr>
<tr class="separator:a0b62ec3b8ba7e8adef83aa9c4c61d985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7659389f560af0eff9eef46a1e644221"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAstMatching.html#a7659389f560af0eff9eef46a1e644221">setKeepMarkedLocations</a> (bool keepMarked)</td></tr>
<tr class="memdesc:a7659389f560af0eff9eef46a1e644221"><td class="mdescLeft">&#160;</td><td class="mdescRight">This flag is useful when reusing the same matcher object for performing multiple matches.  <a href="classAstMatching.html#a7659389f560af0eff9eef46a1e644221">More...</a><br /></td></tr>
<tr class="separator:a7659389f560af0eff9eef46a1e644221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a392b74f99f9dbdb8c95616036250c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAstMatching.html#a2a392b74f99f9dbdb8c95616036250c6">printMarkedLocations</a> ()</td></tr>
<tr class="memdesc:a2a392b74f99f9dbdb8c95616036250c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is only for information purposes.  <a href="classAstMatching.html#a2a392b74f99f9dbdb8c95616036250c6">More...</a><br /></td></tr>
<tr class="separator:a2a392b74f99f9dbdb8c95616036250c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a5199a1b3c979dffc63877e26d3f17916"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5199a1b3c979dffc63877e26d3f17916">&#9670;&nbsp;</a></span>AstMatching()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AstMatching::AstMatching </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>matchExpression</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&#160;</td>
          <td class="paramname"><em>root</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor as a all-in-one solution. </p>
<p>It performs the matching and stores the result. This requires to use function <a class="el" href="classAstMatching.html#a805d9e2b097f7b1106c4541330f06a64" title="Allows to access the match result if the match expression was provided as an argument to the construc...">getResult()</a> to access the result. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a62ae5f7b9cb3753f0fa86da65f8d8894"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62ae5f7b9cb3753f0fa86da65f8d8894">&#9670;&nbsp;</a></span>performMatching()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MatchResult AstMatching::performMatching </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>matchExpression</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&#160;</td>
          <td class="paramname"><em>root</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the main function to be called for matching. </p>
<p>The match expression is provided as a string (which is being parsed and checked for syntax errors), and then the matching is performed. Any node in the AST can be used as a root node. The match result (a map) is returned. </p>

</div>
</div>
<a id="a805d9e2b097f7b1106c4541330f06a64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a805d9e2b097f7b1106c4541330f06a64">&#9670;&nbsp;</a></span>getResult()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MatchResult AstMatching::getResult </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows to access the match result if the match expression was provided as an argument to the constructor. </p>
<p>It can also be used to access results accumulated from multiple performed match operations. </p>

</div>
</div>
<a id="a0b62ec3b8ba7e8adef83aa9c4c61d985"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b62ec3b8ba7e8adef83aa9c4c61d985">&#9670;&nbsp;</a></span>printMatchOperationsSequence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AstMatching::printMatchOperationsSequence </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is only for information purposes. </p>
<p>It prints the sequence of internal instructions that are generated by the match expression frontend (invoked by performMatching). The instructions constitute its own small language. Internally, the instructions are inserted in a polymorphic list and by executing each instruction, the matching, binding of variables, and (possibly) skipping of substrees is performed. The list of instructions is provided in a human readable format. </p>

</div>
</div>
<a id="a7659389f560af0eff9eef46a1e644221"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7659389f560af0eff9eef46a1e644221">&#9670;&nbsp;</a></span>setKeepMarkedLocations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AstMatching::setKeepMarkedLocations </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>keepMarked</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This flag is useful when reusing the same matcher object for performing multiple matches. </p>
<p>It allows to keep record of all nodes that have been marked by a previous match using the '#' operator. The subtrees of those nodes are not traversed in the subsequent matches. </p>

</div>
</div>
<a id="a2a392b74f99f9dbdb8c95616036250c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a392b74f99f9dbdb8c95616036250c6">&#9670;&nbsp;</a></span>printMarkedLocations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AstMatching::printMarkedLocations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is only for information purposes. </p>
<p>It prints the set of all marked nodes (marked with the '#' operator). </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="AstMatching_8h_source.html">AstMatching.h</a></li>
</ul>
</div><!-- contents -->
<div class="ttc" id="aclassSgForStatement_html"><div class="ttname"><a href="classSgForStatement.html">SgForStatement</a></div><div class="ttdoc">This class represents the concept of a for loop.</div><div class="ttdef"><b>Definition:</b> <a href="Cxx__Grammar_8h_source.html#l125996">Cxx_Grammar.h:125996</a></div></div>
<div class="ttc" id="aclassAstMatching_html_a62ae5f7b9cb3753f0fa86da65f8d8894"><div class="ttname"><a href="classAstMatching.html#a62ae5f7b9cb3753f0fa86da65f8d8894">AstMatching::performMatching</a></div><div class="ttdeci">MatchResult performMatching(std::string matchExpression, SgNode *root)</div><div class="ttdoc">This is the main function to be called for matching.</div></div>
<div class="ttc" id="aclassAstMatching_html"><div class="ttname"><a href="classAstMatching.html">AstMatching</a></div><div class="ttdoc">The AstMatching class allows to specify arbitrary large patterns to be matched on any subtree in the ...</div><div class="ttdef"><b>Definition:</b> <a href="AstMatching_8h_source.html#l00187">AstMatching.h:187</a></div></div>
<div class="ttc" id="aclassSgNode_html"><div class="ttname"><a href="classSgNode.html">SgNode</a></div><div class="ttdoc">This class represents the base class for all IR nodes within Sage III.</div><div class="ttdef"><b>Definition:</b> <a href="Cxx__Grammar_8h_source.html#l06739">Cxx_Grammar.h:6739</a></div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Dec 19 2022 23:39:55 for ROSE by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
