<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROSE: OmpSupport Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="ROSE"/>
<link href="roseDoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ROSE
   &#160;<span id="projectnumber">0.11.96.11</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,true,'search.html','Search');
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">OmpSupport Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>Types and functions to support OpenMP. </p>
<p>OpenMP specific data types and functions are put into this namespace </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOmpSupport_1_1ComplexClause.html">ComplexClause</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOmpSupport_1_1SgVarRefExpVisitor.html">SgVarRefExpVisitor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOmpSupport_1_1translationDriver.html">translationDriver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A driver to traverse AST trees and invoke individual translators for OpenMP constructs, (not in use) Postorder is preferred.  <a href="classOmpSupport_1_1translationDriver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a517aeb9b0b29041f7d14636b9b643afb"><td class="memItemLeft" align="right" valign="top"><a id="a517aeb9b0b29041f7d14636b9b643afb"></a>
typedef std::map&lt; const <a class="el" href="classSgVariableSymbol.html">SgVariableSymbol</a> *, <a class="el" href="classSgVariableSymbol.html">SgVariableSymbol</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>VariableSymbolMap_t</b></td></tr>
<tr class="separator:a517aeb9b0b29041f7d14636b9b643afb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a9407f163895e6aef1aaac5155fb25ac9"><td class="memItemLeft" align="right" valign="top"><a id="a9407f163895e6aef1aaac5155fb25ac9"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>omp_construct_enum</b> { <br />
&#160;&#160;<b>e_unknown</b> = 0, 
<br />
&#160;&#160;<b>e_parallel</b>, 
<br />
&#160;&#160;<b>e_for</b>, 
<br />
&#160;&#160;<b>e_for_simd</b>, 
<br />
&#160;&#160;<b>e_do</b>, 
<br />
&#160;&#160;<b>e_workshare</b>, 
<br />
&#160;&#160;<b>e_sections</b>, 
<br />
&#160;&#160;<b>e_section</b>, 
<br />
&#160;&#160;<b>e_single</b>, 
<br />
&#160;&#160;<b>e_master</b>, 
<br />
&#160;&#160;<b>e_critical</b>, 
<br />
&#160;&#160;<b>e_barrier</b>, 
<br />
&#160;&#160;<b>e_atomic</b>, 
<br />
&#160;&#160;<b>e_flush</b>, 
<br />
&#160;&#160;<b>e_target</b>, 
<br />
&#160;&#160;<b>e_target_declare</b>, 
<br />
&#160;&#160;<b>e_target_data</b>, 
<br />
&#160;&#160;<b>e_target_update</b>, 
<br />
&#160;&#160;<b>e_map</b>, 
<br />
&#160;&#160;<b>e_device</b>, 
<br />
&#160;&#160;<b>e_begin</b>, 
<br />
&#160;&#160;<b>e_end</b>, 
<br />
&#160;&#160;<b>e_threadprivate</b>, 
<br />
&#160;&#160;<b>e_parallel_for</b>, 
<br />
&#160;&#160;<b>e_parallel_for_simd</b>, 
<br />
&#160;&#160;<b>e_parallel_do</b>, 
<br />
&#160;&#160;<b>e_parallel_sections</b>, 
<br />
&#160;&#160;<b>e_parallel_workshare</b>, 
<br />
&#160;&#160;<b>e_task</b>, 
<br />
&#160;&#160;<b>e_taskwait</b>, 
<br />
&#160;&#160;<b>e_ordered_directive</b>, 
<br />
&#160;&#160;<b>e_end_critical</b>, 
<br />
&#160;&#160;<b>e_end_do</b>, 
<br />
&#160;&#160;<b>e_end_master</b>, 
<br />
&#160;&#160;<b>e_end_ordered</b>, 
<br />
&#160;&#160;<b>e_end_parallel_do</b>, 
<br />
&#160;&#160;<b>e_end_parallel_sections</b>, 
<br />
&#160;&#160;<b>e_end_parallel_workshare</b>, 
<br />
&#160;&#160;<b>e_end_parallel</b>, 
<br />
&#160;&#160;<b>e_end_sections</b>, 
<br />
&#160;&#160;<b>e_end_single</b>, 
<br />
&#160;&#160;<b>e_end_task</b>, 
<br />
&#160;&#160;<b>e_end_workshare</b>, 
<br />
&#160;&#160;<b>e_default</b>, 
<br />
&#160;&#160;<b>e_shared</b>, 
<br />
&#160;&#160;<b>e_private</b>, 
<br />
&#160;&#160;<b>e_firstprivate</b>, 
<br />
&#160;&#160;<b>e_lastprivate</b>, 
<br />
&#160;&#160;<b>e_copyin</b>, 
<br />
&#160;&#160;<b>e_copyprivate</b>, 
<br />
&#160;&#160;<b>e_proc_bind</b>, 
<br />
&#160;&#160;<b>e_if</b>, 
<br />
&#160;&#160;<b>e_num_threads</b>, 
<br />
&#160;&#160;<b>e_nowait</b>, 
<br />
&#160;&#160;<b>e_ordered_clause</b>, 
<br />
&#160;&#160;<b>e_reduction</b>, 
<br />
&#160;&#160;<b>e_schedule</b>, 
<br />
&#160;&#160;<b>e_collapse</b>, 
<br />
&#160;&#160;<b>e_untied</b>, 
<br />
&#160;&#160;<b>e_mergeable</b>, 
<br />
&#160;&#160;<b>e_final</b>, 
<br />
&#160;&#160;<b>e_priority</b>, 
<br />
&#160;&#160;<b>e_atomic_clause</b>, 
<br />
&#160;&#160;<b>e_inbranch</b>, 
<br />
&#160;&#160;<b>e_notinbranch</b>, 
<br />
&#160;&#160;<b>e_depend</b>, 
<br />
&#160;&#160;<b>e_default_none</b>, 
<br />
&#160;&#160;<b>e_default_shared</b>, 
<br />
&#160;&#160;<b>e_default_private</b>, 
<br />
&#160;&#160;<b>e_default_firstprivate</b>, 
<br />
&#160;&#160;<b>e_proc_bind_master</b>, 
<br />
&#160;&#160;<b>e_proc_bind_close</b>, 
<br />
&#160;&#160;<b>e_proc_bind_spread</b>, 
<br />
&#160;&#160;<b>e_atomic_read</b>, 
<br />
&#160;&#160;<b>e_atomic_write</b>, 
<br />
&#160;&#160;<b>e_atomic_update</b>, 
<br />
&#160;&#160;<b>e_atomic_capture</b>, 
<br />
&#160;&#160;<b>e_in_reduction_identifier_plus</b>, 
<br />
&#160;&#160;<b>e_in_reduction_identifier_mul</b>, 
<br />
&#160;&#160;<b>e_in_reduction_identifier_minus</b>, 
<br />
&#160;&#160;<b>e_in_reduction_identifier_bitand</b>, 
<br />
&#160;&#160;<b>e_in_reduction_identifier_bitor</b>, 
<br />
&#160;&#160;<b>e_in_reduction_identifier_bitxor</b>, 
<br />
&#160;&#160;<b>e_in_reduction_identifier_logand</b>, 
<br />
&#160;&#160;<b>e_in_reduction_identifier_logor</b>, 
<br />
&#160;&#160;<b>e_in_reduction_identifier_and</b>, 
<br />
&#160;&#160;<b>e_in_reduction_identifier_or</b>, 
<br />
&#160;&#160;<b>e_in_reduction_identifier_eqv</b>, 
<br />
&#160;&#160;<b>e_in_reduction_identifier_neqv</b>, 
<br />
&#160;&#160;<b>e_in_reduction_identifier_max</b>, 
<br />
&#160;&#160;<b>e_in_reduction_identifier_min</b>, 
<br />
&#160;&#160;<b>e_in_reduction_identifier_iand</b>, 
<br />
&#160;&#160;<b>e_in_reduction_identifier_ior</b>, 
<br />
&#160;&#160;<b>e_in_reduction_identifier_ieor</b>, 
<br />
&#160;&#160;<b>e_task_reduction_identifier_plus</b>, 
<br />
&#160;&#160;<b>e_task_reduction_identifier_mul</b>, 
<br />
&#160;&#160;<b>e_task_reduction_identifier_minus</b>, 
<br />
&#160;&#160;<b>e_task_reduction_identifier_bitand</b>, 
<br />
&#160;&#160;<b>e_task_reduction_identifier_bitor</b>, 
<br />
&#160;&#160;<b>e_task_reduction_identifier_bitxor</b>, 
<br />
&#160;&#160;<b>e_task_reduction_identifier_logand</b>, 
<br />
&#160;&#160;<b>e_task_reduction_identifier_logor</b>, 
<br />
&#160;&#160;<b>e_task_reduction_identifier_and</b>, 
<br />
&#160;&#160;<b>e_task_reduction_identifier_or</b>, 
<br />
&#160;&#160;<b>e_task_reduction_identifier_eqv</b>, 
<br />
&#160;&#160;<b>e_task_reduction_identifier_neqv</b>, 
<br />
&#160;&#160;<b>e_task_reduction_identifier_max</b>, 
<br />
&#160;&#160;<b>e_task_reduction_identifier_min</b>, 
<br />
&#160;&#160;<b>e_task_reduction_identifier_iand</b>, 
<br />
&#160;&#160;<b>e_task_reduction_identifier_ior</b>, 
<br />
&#160;&#160;<b>e_task_reduction_identifier_ieor</b>, 
<br />
&#160;&#160;<b>e_reduction_plus</b>, 
<br />
&#160;&#160;<b>e_reduction_mul</b>, 
<br />
&#160;&#160;<b>e_reduction_minus</b>, 
<br />
&#160;&#160;<b>e_reduction_bitand</b>, 
<br />
&#160;&#160;<b>e_reduction_bitor</b>, 
<br />
&#160;&#160;<b>e_reduction_bitxor</b>, 
<br />
&#160;&#160;<b>e_reduction_logand</b>, 
<br />
&#160;&#160;<b>e_reduction_logor</b>, 
<br />
&#160;&#160;<b>e_reduction_and</b>, 
<br />
&#160;&#160;<b>e_reduction_or</b>, 
<br />
&#160;&#160;<b>e_reduction_eqv</b>, 
<br />
&#160;&#160;<b>e_reduction_neqv</b>, 
<br />
&#160;&#160;<b>e_reduction_max</b>, 
<br />
&#160;&#160;<b>e_reduction_min</b>, 
<br />
&#160;&#160;<b>e_reduction_iand</b>, 
<br />
&#160;&#160;<b>e_reduction_ior</b>, 
<br />
&#160;&#160;<b>e_reduction_ieor</b>, 
<br />
&#160;&#160;<b>e_reduction_inscan</b>, 
<br />
&#160;&#160;<b>e_reduction_task</b>, 
<br />
&#160;&#160;<b>e_reduction_default</b>, 
<br />
&#160;&#160;<b>e_lastprivate_conditional</b>, 
<br />
&#160;&#160;<b>e_device_ancestor</b>, 
<br />
&#160;&#160;<b>e_device_device_num</b>, 
<br />
&#160;&#160;<b>e_linear_ref</b>, 
<br />
&#160;&#160;<b>e_linear_val</b>, 
<br />
&#160;&#160;<b>e_linear_uval</b>, 
<br />
&#160;&#160;<b>e_user_defined_parameter</b>, 
<br />
&#160;&#160;<b>e_schedule_none</b>, 
<br />
&#160;&#160;<b>e_schedule_static</b>, 
<br />
&#160;&#160;<b>e_schedule_dynamic</b>, 
<br />
&#160;&#160;<b>e_schedule_guided</b>, 
<br />
&#160;&#160;<b>e_schedule_auto</b>, 
<br />
&#160;&#160;<b>e_schedule_runtime</b>, 
<br />
&#160;&#160;<b>e_map_alloc</b>, 
<br />
&#160;&#160;<b>e_map_to</b>, 
<br />
&#160;&#160;<b>e_map_from</b>, 
<br />
&#160;&#160;<b>e_map_tofrom</b>, 
<br />
&#160;&#160;<b>e_dist_data</b>, 
<br />
&#160;&#160;<b>e_duplicate</b>, 
<br />
&#160;&#160;<b>e_block</b>, 
<br />
&#160;&#160;<b>e_cyclic</b>, 
<br />
&#160;&#160;<b>e_simd</b>, 
<br />
&#160;&#160;<b>e_declare_simd</b>, 
<br />
&#160;&#160;<b>e_safelen</b>, 
<br />
&#160;&#160;<b>e_simdlen</b>, 
<br />
&#160;&#160;<b>e_uniform</b>, 
<br />
&#160;&#160;<b>e_aligned</b>, 
<br />
&#160;&#160;<b>e_linear</b>, 
<br />
&#160;&#160;<b>e_depend_in</b>, 
<br />
&#160;&#160;<b>e_depend_out</b>, 
<br />
&#160;&#160;<b>e_depend_inout</b>, 
<br />
&#160;&#160;<b>e_depend_mutexinoutset</b>, 
<br />
&#160;&#160;<b>e_depend_depobj</b>, 
<br />
&#160;&#160;<b>e_omp_depend_modifier_iterator</b>, 
<br />
&#160;&#160;<b>e_allocate</b>, 
<br />
&#160;&#160;<b>e_allocate_default_mem_alloc</b>, 
<br />
&#160;&#160;<b>e_allocate_large_cap_mem_alloc</b>, 
<br />
&#160;&#160;<b>e_allocate_const_mem_alloc</b>, 
<br />
&#160;&#160;<b>e_allocate_high_bw_mem_alloc</b>, 
<br />
&#160;&#160;<b>e_allocate_low_lat_mem_alloc</b>, 
<br />
&#160;&#160;<b>e_allocate_cgroup_mem_alloc</b>, 
<br />
&#160;&#160;<b>e_allocate_pteam_mem_alloc</b>, 
<br />
&#160;&#160;<b>e_allocate_thread_mem_alloc</b>, 
<br />
&#160;&#160;<b>e_not_omp</b>
<br />
 }</td></tr>
<tr class="separator:a9407f163895e6aef1aaac5155fb25ac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abffc7f08fd77ecfd382fe54fd641dc10"><td class="memItemLeft" align="right" valign="top"><a id="abffc7f08fd77ecfd382fe54fd641dc10"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#abffc7f08fd77ecfd382fe54fd641dc10">omp_rtl_enum</a> { <br />
&#160;&#160;<b>e_gomp</b>, 
<br />
&#160;&#160;<b>e_omni</b>, 
<br />
&#160;&#160;<b>e_last_rtl</b>
<br />
 }</td></tr>
<tr class="memdesc:abffc7f08fd77ecfd382fe54fd641dc10"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of target runtime libraries (not yet in use) <br /></td></tr>
<tr class="separator:abffc7f08fd77ecfd382fe54fd641dc10"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af61ca3e72cc3ce57c0a429fa3bb4a8fd"><td class="memItemLeft" align="right" valign="top"><a id="af61ca3e72cc3ce57c0a429fa3bb4a8fd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>processOpenMP</b> (<a class="el" href="classSgSourceFile.html">SgSourceFile</a> *sageFilePtr)</td></tr>
<tr class="separator:af61ca3e72cc3ce57c0a429fa3bb4a8fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25e4359fa76afb6e296b55180d4b3f82"><td class="memItemLeft" align="right" valign="top"><a id="a25e4359fa76afb6e296b55180d4b3f82"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>postParsingProcessing</b> (<a class="el" href="classSgSourceFile.html">SgSourceFile</a> *sageFilePtr)</td></tr>
<tr class="separator:a25e4359fa76afb6e296b55180d4b3f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd54e60feb0dcc01a470ef9bf0b514e1"><td class="memItemLeft" align="right" valign="top"><a id="abd54e60feb0dcc01a470ef9bf0b514e1"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#abd54e60feb0dcc01a470ef9bf0b514e1">toString</a> (omp_construct_enum omp_type)</td></tr>
<tr class="memdesc:abd54e60feb0dcc01a470ef9bf0b514e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output omp_construct_enum to a string: <br /></td></tr>
<tr class="separator:abd54e60feb0dcc01a470ef9bf0b514e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebf0de366aa8cc20c9055fd8878c357b"><td class="memItemLeft" align="right" valign="top"><a id="aebf0de366aa8cc20c9055fd8878c357b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#aebf0de366aa8cc20c9055fd8878c357b">isFortranEndDirective</a> (omp_construct_enum omp_type)</td></tr>
<tr class="memdesc:aebf0de366aa8cc20c9055fd8878c357b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the construct is a Fortran END ... directive. <br /></td></tr>
<tr class="separator:aebf0de366aa8cc20c9055fd8878c357b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a911371ad3052111b489a9e727d83cbe0"><td class="memItemLeft" align="right" valign="top"><a id="a911371ad3052111b489a9e727d83cbe0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#a911371ad3052111b489a9e727d83cbe0">isFortranBeginDirective</a> (omp_construct_enum omp_type)</td></tr>
<tr class="memdesc:a911371ad3052111b489a9e727d83cbe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the construct is a Fortran directive which can (optionally) have a corresponding END directive. <br /></td></tr>
<tr class="separator:a911371ad3052111b489a9e727d83cbe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a122a3e721998855c128409cca54c023f"><td class="memItemLeft" align="right" valign="top"><a id="a122a3e721998855c128409cca54c023f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#a122a3e721998855c128409cca54c023f">isDirective</a> (omp_construct_enum omp_type)</td></tr>
<tr class="memdesc:a122a3e721998855c128409cca54c023f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if an OpenMP construct is a directive. <br /></td></tr>
<tr class="separator:a122a3e721998855c128409cca54c023f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e9c316424f6f34cd6ba79344217fee7"><td class="memItemLeft" align="right" valign="top"><a id="a1e9c316424f6f34cd6ba79344217fee7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#a1e9c316424f6f34cd6ba79344217fee7">isDirectiveWithBody</a> (omp_construct_enum omp_type)</td></tr>
<tr class="memdesc:a1e9c316424f6f34cd6ba79344217fee7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if an OpenMP directive has a structured body. <br /></td></tr>
<tr class="separator:a1e9c316424f6f34cd6ba79344217fee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca5216695c28a37e6d3af469aeadb41"><td class="memItemLeft" align="right" valign="top"><a id="afca5216695c28a37e6d3af469aeadb41"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#afca5216695c28a37e6d3af469aeadb41">isClause</a> (omp_construct_enum omp_type)</td></tr>
<tr class="memdesc:afca5216695c28a37e6d3af469aeadb41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if an OpenMP construct is a clause. <br /></td></tr>
<tr class="separator:afca5216695c28a37e6d3af469aeadb41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6d2faaeee9244a3d3d6bc3c5eddc3fc"><td class="memItemLeft" align="right" valign="top"><a id="ad6d2faaeee9244a3d3d6bc3c5eddc3fc"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#ad6d2faaeee9244a3d3d6bc3c5eddc3fc">isReductionOperator</a> (omp_construct_enum omp_type)</td></tr>
<tr class="memdesc:ad6d2faaeee9244a3d3d6bc3c5eddc3fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if an OpenMP construct is a reduction operator. <br /></td></tr>
<tr class="separator:ad6d2faaeee9244a3d3d6bc3c5eddc3fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad910f83affb025c0efc9cc2536dfb81"><td class="memItemLeft" align="right" valign="top"><a id="aad910f83affb025c0efc9cc2536dfb81"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#aad910f83affb025c0efc9cc2536dfb81">isDependenceType</a> (omp_construct_enum omp_type)</td></tr>
<tr class="memdesc:aad910f83affb025c0efc9cc2536dfb81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if an OpenMP construct is a dependence type for omp task depend. <br /></td></tr>
<tr class="separator:aad910f83affb025c0efc9cc2536dfb81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7501a3bda788701ed37519c2e0f56a2f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#a7501a3bda788701ed37519c2e0f56a2f">patchUpSharedVariables</a> (<a class="el" href="classSgFile.html">SgFile</a> *)</td></tr>
<tr class="memdesc:a7501a3bda788701ed37519c2e0f56a2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">makeDataSharingExplicit() can call some of existing functions for some work in <a class="el" href="namespaceOmpSupport.html" title="Types and functions to support OpenMP.">OmpSupport</a> namespace by Hongyi 07/16/2012 TODO: add a function within the <a class="el" href="namespaceOmpSupport.html" title="Types and functions to support OpenMP.">OmpSupport</a> namespace, the function should transform the AST, so all variables' data-sharing attributes are explicitied represented in the AST.  <a href="namespaceOmpSupport.html#a7501a3bda788701ed37519c2e0f56a2f">More...</a><br /></td></tr>
<tr class="separator:a7501a3bda788701ed37519c2e0f56a2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a109c3a085942e285df4d6a9b8d470f90"><td class="memItemLeft" align="right" valign="top"><a id="a109c3a085942e285df4d6a9b8d470f90"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>makeDataSharingExplicit</b> (<a class="el" href="classSgFile.html">SgFile</a> *)</td></tr>
<tr class="separator:a109c3a085942e285df4d6a9b8d470f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a949516f6dba7524ecfe19cb4bacafbe8"><td class="memItemLeft" align="right" valign="top"><a id="a949516f6dba7524ecfe19cb4bacafbe8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>commandLineProcessing</b> (std::vector&lt; std::string &gt; &amp;argvList)</td></tr>
<tr class="separator:a949516f6dba7524ecfe19cb4bacafbe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ad14255713b507fc965732164024806"><td class="memItemLeft" align="right" valign="top"><a id="a9ad14255713b507fc965732164024806"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#a9ad14255713b507fc965732164024806">lower_omp</a> (<a class="el" href="classSgSourceFile.html">SgSourceFile</a> *)</td></tr>
<tr class="memdesc:a9ad14255713b507fc965732164024806"><td class="mdescLeft">&#160;</td><td class="mdescRight">The top level interface to translate OpenMP directives. <br /></td></tr>
<tr class="separator:a9ad14255713b507fc965732164024806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3576a0e489161489c9582937f2d907f"><td class="memItemLeft" align="right" valign="top"><a id="ad3576a0e489161489c9582937f2d907f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>analyze_omp</b> (<a class="el" href="classSgSourceFile.html">SgSourceFile</a> *)</td></tr>
<tr class="separator:ad3576a0e489161489c9582937f2d907f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98e85da767f2a26695fdcd9d70c4adf3"><td class="memItemLeft" align="right" valign="top"><a id="a98e85da767f2a26695fdcd9d70c4adf3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#a98e85da767f2a26695fdcd9d70c4adf3">insertRTLHeaders</a> (<a class="el" href="classSgSourceFile.html">SgSourceFile</a> *)</td></tr>
<tr class="memdesc:a98e85da767f2a26695fdcd9d70c4adf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert #include "xxx.h", the interface of a runtime library to the compiler. <br /></td></tr>
<tr class="separator:a98e85da767f2a26695fdcd9d70c4adf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a404b0f71c1b780fec510bbd850fbcda1"><td class="memItemLeft" align="right" valign="top"><a id="a404b0f71c1b780fec510bbd850fbcda1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#a404b0f71c1b780fec510bbd850fbcda1">insertRTLinitAndCleanCode</a> (<a class="el" href="classSgSourceFile.html">SgSourceFile</a> *)</td></tr>
<tr class="memdesc:a404b0f71c1b780fec510bbd850fbcda1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert runtime init and terminate routines to main() entry. <br /></td></tr>
<tr class="separator:a404b0f71c1b780fec510bbd850fbcda1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a877ffb2ef7945e03c853c136acd6071c"><td class="memItemLeft" align="right" valign="top"><a id="a877ffb2ef7945e03c853c136acd6071c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>insertAcceleratorInit</b> (<a class="el" href="classSgSourceFile.html">SgSourceFile</a> *)</td></tr>
<tr class="separator:a877ffb2ef7945e03c853c136acd6071c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b151fb4117c4b6b8b0e774d6c358006"><td class="memItemLeft" align="right" valign="top"><a id="a2b151fb4117c4b6b8b0e774d6c358006"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#a2b151fb4117c4b6b8b0e774d6c358006">transOmpParallel</a> (<a class="el" href="classSgNode.html">SgNode</a> *node)</td></tr>
<tr class="memdesc:a2b151fb4117c4b6b8b0e774d6c358006"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate omp parallel. <br /></td></tr>
<tr class="separator:a2b151fb4117c4b6b8b0e774d6c358006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa460279915813087b3109bad38558f4b"><td class="memItemLeft" align="right" valign="top"><a id="aa460279915813087b3109bad38558f4b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#aa460279915813087b3109bad38558f4b">transOmpTargetParallel</a> (<a class="el" href="classSgNode.html">SgNode</a> *node)</td></tr>
<tr class="memdesc:aa460279915813087b3109bad38558f4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate omp parallel under "omp target". <br /></td></tr>
<tr class="separator:aa460279915813087b3109bad38558f4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a547b91648d9a4437b6f6b410687aeda8"><td class="memItemLeft" align="right" valign="top"><a id="a547b91648d9a4437b6f6b410687aeda8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#a547b91648d9a4437b6f6b410687aeda8">transOmpSections</a> (<a class="el" href="classSgNode.html">SgNode</a> *node)</td></tr>
<tr class="memdesc:a547b91648d9a4437b6f6b410687aeda8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate omp sections. <br /></td></tr>
<tr class="separator:a547b91648d9a4437b6f6b410687aeda8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae015c3c4d380f148944d2cb9f2a8a305"><td class="memItemLeft" align="right" valign="top"><a id="ae015c3c4d380f148944d2cb9f2a8a305"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#ae015c3c4d380f148944d2cb9f2a8a305">transOmpTask</a> (<a class="el" href="classSgNode.html">SgNode</a> *node)</td></tr>
<tr class="memdesc:ae015c3c4d380f148944d2cb9f2a8a305"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate omp task. <br /></td></tr>
<tr class="separator:ae015c3c4d380f148944d2cb9f2a8a305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c92a11bacf34f814ed2ee636512da3a"><td class="memItemLeft" align="right" valign="top"><a id="a9c92a11bacf34f814ed2ee636512da3a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#a9c92a11bacf34f814ed2ee636512da3a">transUpirLoopParallel</a> (<a class="el" href="classSgNode.html">SgNode</a> *node)</td></tr>
<tr class="memdesc:a9c92a11bacf34f814ed2ee636512da3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate UPIR parallel loops. <br /></td></tr>
<tr class="separator:a9c92a11bacf34f814ed2ee636512da3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8834de54bb3fee4a3f75e5aa7b7e60d4"><td class="memItemLeft" align="right" valign="top"><a id="a8834de54bb3fee4a3f75e5aa7b7e60d4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#a8834de54bb3fee4a3f75e5aa7b7e60d4">transOmpLoop</a> (<a class="el" href="classSgNode.html">SgNode</a> *node)</td></tr>
<tr class="memdesc:a8834de54bb3fee4a3f75e5aa7b7e60d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate omp for or omp do loops. <br /></td></tr>
<tr class="separator:a8834de54bb3fee4a3f75e5aa7b7e60d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f7f29754e2a97ffae8e21dbd2a30942"><td class="memItemLeft" align="right" valign="top"><a id="a6f7f29754e2a97ffae8e21dbd2a30942"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#a6f7f29754e2a97ffae8e21dbd2a30942">transOmpTargetLoop</a> (<a class="el" href="classSgNode.html">SgNode</a> *node)</td></tr>
<tr class="memdesc:a6f7f29754e2a97ffae8e21dbd2a30942"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate omp for or omp do loops affected by the "omp target" directive, using naive 1-to-1 mapping Liao 1/28/2013. <br /></td></tr>
<tr class="separator:a6f7f29754e2a97ffae8e21dbd2a30942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a570eb492119157e48576da8fe539c0da"><td class="memItemLeft" align="right" valign="top"><a id="a570eb492119157e48576da8fe539c0da"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#a570eb492119157e48576da8fe539c0da">transOmpTargetLoop_RoundRobin</a> (<a class="el" href="classSgNode.html">SgNode</a> *node)</td></tr>
<tr class="memdesc:a570eb492119157e48576da8fe539c0da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate omp for or omp do loops affected by the "omp target" directive, using a round robin-scheduler Liao 7/10/2014. <br /></td></tr>
<tr class="separator:a570eb492119157e48576da8fe539c0da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c59562231bb9a568ee6ef65bd6cc3ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#a1c59562231bb9a568ee6ef65bd6cc3ec">transOmpTarget</a> (<a class="el" href="classSgNode.html">SgNode</a> *node)</td></tr>
<tr class="memdesc:a1c59562231bb9a568ee6ef65bd6cc3ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate Fortran omp do.  <a href="namespaceOmpSupport.html#a1c59562231bb9a568ee6ef65bd6cc3ec">More...</a><br /></td></tr>
<tr class="separator:a1c59562231bb9a568ee6ef65bd6cc3ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3995a5c314ed5d9bd06a39220208f711"><td class="memItemLeft" align="right" valign="top"><a id="a3995a5c314ed5d9bd06a39220208f711"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#a3995a5c314ed5d9bd06a39220208f711">transOmpTargetData</a> (<a class="el" href="classSgNode.html">SgNode</a> *node)</td></tr>
<tr class="memdesc:a3995a5c314ed5d9bd06a39220208f711"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate "omp target data". <br /></td></tr>
<tr class="separator:a3995a5c314ed5d9bd06a39220208f711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d0cefae7b38c9b035dbbd2f5a417e80"><td class="memItemLeft" align="right" valign="top"><a id="a2d0cefae7b38c9b035dbbd2f5a417e80"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#a2d0cefae7b38c9b035dbbd2f5a417e80">transOmpBarrier</a> (<a class="el" href="classSgNode.html">SgNode</a> *node)</td></tr>
<tr class="memdesc:a2d0cefae7b38c9b035dbbd2f5a417e80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate omp barrier. <br /></td></tr>
<tr class="separator:a2d0cefae7b38c9b035dbbd2f5a417e80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfc6ed0fb6cdc06e4b6cd3e0b50b9c0c"><td class="memItemLeft" align="right" valign="top"><a id="adfc6ed0fb6cdc06e4b6cd3e0b50b9c0c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#adfc6ed0fb6cdc06e4b6cd3e0b50b9c0c">transOmpFlush</a> (<a class="el" href="classSgNode.html">SgNode</a> *node)</td></tr>
<tr class="memdesc:adfc6ed0fb6cdc06e4b6cd3e0b50b9c0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate omp flush. <br /></td></tr>
<tr class="separator:adfc6ed0fb6cdc06e4b6cd3e0b50b9c0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88cd2daf13f11b87b823d673fa512f07"><td class="memItemLeft" align="right" valign="top"><a id="a88cd2daf13f11b87b823d673fa512f07"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#a88cd2daf13f11b87b823d673fa512f07">transOmpTaskwait</a> (<a class="el" href="classSgNode.html">SgNode</a> *node)</td></tr>
<tr class="memdesc:a88cd2daf13f11b87b823d673fa512f07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate omp taskwait. <br /></td></tr>
<tr class="separator:a88cd2daf13f11b87b823d673fa512f07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91e377cd0e5da19d049a0d335419ba96"><td class="memItemLeft" align="right" valign="top"><a id="a91e377cd0e5da19d049a0d335419ba96"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#a91e377cd0e5da19d049a0d335419ba96">transOmpThreadprivate</a> (<a class="el" href="classSgNode.html">SgNode</a> *node)</td></tr>
<tr class="memdesc:a91e377cd0e5da19d049a0d335419ba96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate omp threadprivate. <br /></td></tr>
<tr class="separator:a91e377cd0e5da19d049a0d335419ba96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92d605f2c191dfe399343fd2af91d019"><td class="memItemLeft" align="right" valign="top"><a id="a92d605f2c191dfe399343fd2af91d019"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#a92d605f2c191dfe399343fd2af91d019">transOmpOrdered</a> (<a class="el" href="classSgNode.html">SgNode</a> *node)</td></tr>
<tr class="memdesc:a92d605f2c191dfe399343fd2af91d019"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate the ordered directive (not the ordered clause) <br /></td></tr>
<tr class="separator:a92d605f2c191dfe399343fd2af91d019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ce2fb3d01361a12fada8d678b2e1008"><td class="memItemLeft" align="right" valign="top"><a id="a2ce2fb3d01361a12fada8d678b2e1008"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#a2ce2fb3d01361a12fada8d678b2e1008">transOmpAtomic</a> (<a class="el" href="classSgNode.html">SgNode</a> *node)</td></tr>
<tr class="memdesc:a2ce2fb3d01361a12fada8d678b2e1008"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate omp atomic. <br /></td></tr>
<tr class="separator:a2ce2fb3d01361a12fada8d678b2e1008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a101582626c5f4d0f5e38481522bbf1ad"><td class="memItemLeft" align="right" valign="top"><a id="a101582626c5f4d0f5e38481522bbf1ad"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#a101582626c5f4d0f5e38481522bbf1ad">transOmpCritical</a> (<a class="el" href="classSgNode.html">SgNode</a> *node)</td></tr>
<tr class="memdesc:a101582626c5f4d0f5e38481522bbf1ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate omp critical. <br /></td></tr>
<tr class="separator:a101582626c5f4d0f5e38481522bbf1ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f911ebe755bc85aa73b25324bda24a8"><td class="memItemLeft" align="right" valign="top"><a id="a3f911ebe755bc85aa73b25324bda24a8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#a3f911ebe755bc85aa73b25324bda24a8">transOmpMaster</a> (<a class="el" href="classSgNode.html">SgNode</a> *node)</td></tr>
<tr class="memdesc:a3f911ebe755bc85aa73b25324bda24a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate omp master. <br /></td></tr>
<tr class="separator:a3f911ebe755bc85aa73b25324bda24a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5784dbc40c3d9f01093ae944cf5208a"><td class="memItemLeft" align="right" valign="top"><a id="ab5784dbc40c3d9f01093ae944cf5208a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#ab5784dbc40c3d9f01093ae944cf5208a">transOmpSingle</a> (<a class="el" href="classSgNode.html">SgNode</a> *node)</td></tr>
<tr class="memdesc:ab5784dbc40c3d9f01093ae944cf5208a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate omp single. <br /></td></tr>
<tr class="separator:ab5784dbc40c3d9f01093ae944cf5208a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0fd4abd5331307778816e8ab3df2419"><td class="memItemLeft" align="right" valign="top"><a id="ac0fd4abd5331307778816e8ab3df2419"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#ac0fd4abd5331307778816e8ab3df2419">transOmpMetadirective</a> (<a class="el" href="classSgNode.html">SgNode</a> *node)</td></tr>
<tr class="memdesc:ac0fd4abd5331307778816e8ab3df2419"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate omp metadirective. <br /></td></tr>
<tr class="separator:ac0fd4abd5331307778816e8ab3df2419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ac365fa1c2599bb7557177d65db6068"><td class="memItemLeft" align="right" valign="top"><a id="a5ac365fa1c2599bb7557177d65db6068"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#a5ac365fa1c2599bb7557177d65db6068">transOmpSimd</a> (<a class="el" href="classSgNode.html">SgNode</a> *node)</td></tr>
<tr class="memdesc:a5ac365fa1c2599bb7557177d65db6068"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate omp simd. <br /></td></tr>
<tr class="separator:a5ac365fa1c2599bb7557177d65db6068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42dfaf23189f5b0a6250c9460f00bbd7"><td class="memItemLeft" align="right" valign="top"><a id="a42dfaf23189f5b0a6250c9460f00bbd7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#a42dfaf23189f5b0a6250c9460f00bbd7">transOmpUnroll</a> (<a class="el" href="classSgNode.html">SgNode</a> *node)</td></tr>
<tr class="memdesc:a42dfaf23189f5b0a6250c9460f00bbd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate omp unroll. <br /></td></tr>
<tr class="separator:a42dfaf23189f5b0a6250c9460f00bbd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74e70865b874895e6d665a55525bff32"><td class="memItemLeft" align="right" valign="top"><a id="a74e70865b874895e6d665a55525bff32"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#a74e70865b874895e6d665a55525bff32">transOmpTile</a> (<a class="el" href="classSgNode.html">SgNode</a> *node)</td></tr>
<tr class="memdesc:a74e70865b874895e6d665a55525bff32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate omp tile. <br /></td></tr>
<tr class="separator:a74e70865b874895e6d665a55525bff32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b9ede060bb0248e5a29a2ed3459da37"><td class="memItemLeft" align="right" valign="top"><a id="a0b9ede060bb0248e5a29a2ed3459da37"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#a0b9ede060bb0248e5a29a2ed3459da37">createUpirStatementTree</a> (<a class="el" href="classSgSourceFile.html">SgSourceFile</a> *file)</td></tr>
<tr class="memdesc:a0b9ede060bb0248e5a29a2ed3459da37"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classAnalysis.html">Analysis</a> helpers. <br /></td></tr>
<tr class="separator:a0b9ede060bb0248e5a29a2ed3459da37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f2fd1e271a086f1240834eaf2d0d05a"><td class="memItemLeft" align="right" valign="top"><a id="a3f2fd1e271a086f1240834eaf2d0d05a"></a>
<a class="el" href="classSgStatement.html">SgStatement</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getUpirParent</b> (<a class="el" href="classSgStatement.html">SgStatement</a> *node)</td></tr>
<tr class="separator:a3f2fd1e271a086f1240834eaf2d0d05a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8246bd178d19abb107b7b123c645745c"><td class="memItemLeft" align="right" valign="top"><a id="a8246bd178d19abb107b7b123c645745c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setUpirRelationship</b> (<a class="el" href="classSgStatement.html">SgStatement</a> *parent, <a class="el" href="classSgStatement.html">SgStatement</a> *child)</td></tr>
<tr class="separator:a8246bd178d19abb107b7b123c645745c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62e109f7981e29c89b050a956d3aa133"><td class="memItemLeft" align="right" valign="top"><a id="a62e109f7981e29c89b050a956d3aa133"></a>
Rose_STL_Container&lt; <a class="el" href="classSgNode.html">SgNode</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>mergeSgNodeList</b> (Rose_STL_Container&lt; <a class="el" href="classSgNode.html">SgNode</a> * &gt; node_list1, Rose_STL_Container&lt; <a class="el" href="classSgNode.html">SgNode</a> * &gt; node_list2)</td></tr>
<tr class="separator:a62e109f7981e29c89b050a956d3aa133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae738b4a762f85b6518166caebd40fbb4"><td class="memItemLeft" align="right" valign="top"><a id="ae738b4a762f85b6518166caebd40fbb4"></a>
<a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#ae738b4a762f85b6518166caebd40fbb4">generateOutlinedTask</a> (<a class="el" href="classSgNode.html">SgNode</a> *node, std::string &amp;wrapper_name, std::set&lt; const <a class="el" href="classSgVariableSymbol.html">SgVariableSymbol</a> * &gt; &amp;syms, std::set&lt; const <a class="el" href="classSgVariableSymbol.html">SgVariableSymbol</a> * &gt; &amp;pdSyms3, bool use_task_param=false)</td></tr>
<tr class="memdesc:ae738b4a762f85b6518166caebd40fbb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper function to generate implicit or explicit task for either omp parallel or omp task. <br /></td></tr>
<tr class="separator:ae738b4a762f85b6518166caebd40fbb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98e21e091b97082edbd005ebc254b5b9"><td class="memItemLeft" align="right" valign="top"><a id="a98e21e091b97082edbd005ebc254b5b9"></a>
ROSE_DLL_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#a98e21e091b97082edbd005ebc254b5b9">transOmpVariables</a> (<a class="el" href="classSgStatement.html">SgStatement</a> *ompStmt, <a class="el" href="classSgBasicBlock.html">SgBasicBlock</a> *bb1, <a class="el" href="classSgExpression.html">SgExpression</a> *orig_loop_upper=NULL, bool withinAcceleratorModel=false)</td></tr>
<tr class="memdesc:a98e21e091b97082edbd005ebc254b5b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate OpenMP variables associated with an OpenMP pragma, such as private, firstprivate, lastprivate, reduction, etc. bb1 is the translation generated code block in which the variable handling statements will be inserted. Original loop upper bound is needed for implementing lastprivate (check if it is the last iteration). withinAcceleratorModel means if we only translate private() variables, used to support accelerator model. <br /></td></tr>
<tr class="separator:a98e21e091b97082edbd005ebc254b5b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a695aca02b7682997262cfe10f0047a93"><td class="memItemLeft" align="right" valign="top"><a id="a695aca02b7682997262cfe10f0047a93"></a>
ROSE_DLL_API SgInitializedNamePtrList&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#a695aca02b7682997262cfe10f0047a93">collectAllClauseVariables</a> (<a class="el" href="classSgUpirFieldBodyStatement.html">SgUpirFieldBodyStatement</a> *clause_stmt)</td></tr>
<tr class="memdesc:a695aca02b7682997262cfe10f0047a93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect all variables from OpenMP clauses associated with an omp statement: private, reduction, etc. <br /></td></tr>
<tr class="separator:a695aca02b7682997262cfe10f0047a93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdae304b89f15d22e71b88c706f7038c"><td class="memItemLeft" align="right" valign="top"><a id="afdae304b89f15d22e71b88c706f7038c"></a>
ROSE_DLL_API SgInitializedNamePtrList&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#afdae304b89f15d22e71b88c706f7038c">collectClauseVariables</a> (<a class="el" href="classSgUpirFieldBodyStatement.html">SgUpirFieldBodyStatement</a> *clause_stmt, const VariantT &amp;vt)</td></tr>
<tr class="memdesc:afdae304b89f15d22e71b88c706f7038c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect variables from a particular type of OpenMP clauses associated with an omp statement: private, reduction, etc. <br /></td></tr>
<tr class="separator:afdae304b89f15d22e71b88c706f7038c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c1634b18567db603ed2cd28f66511e5"><td class="memItemLeft" align="right" valign="top"><a id="a2c1634b18567db603ed2cd28f66511e5"></a>
ROSE_DLL_API SgInitializedNamePtrList&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#a2c1634b18567db603ed2cd28f66511e5">collectClauseVariables</a> (<a class="el" href="classSgUpirFieldBodyStatement.html">SgUpirFieldBodyStatement</a> *clause_stmt, const VariantVector &amp;vvt)</td></tr>
<tr class="memdesc:a2c1634b18567db603ed2cd28f66511e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect variables from given types of OpenMP clauses associated with an omp statement: private, reduction, etc. <br /></td></tr>
<tr class="separator:a2c1634b18567db603ed2cd28f66511e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9981a0a1a480af4ba0058dfb17478ee2"><td class="memItemLeft" align="right" valign="top"><a id="a9981a0a1a480af4ba0058dfb17478ee2"></a>
ROSE_DLL_API <a class="el" href="classSgExpression.html">SgExpression</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#a9981a0a1a480af4ba0058dfb17478ee2">getClauseExpression</a> (<a class="el" href="classSgStatement.html">SgStatement</a> *clause_stmt, const VariantVector &amp;vvt)</td></tr>
<tr class="memdesc:a9981a0a1a480af4ba0058dfb17478ee2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect expression from given types of OpenMP clauses associated with an omp statement: private, reduction, etc. <br /></td></tr>
<tr class="separator:a9981a0a1a480af4ba0058dfb17478ee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6673b13653f24e0bc7f359ff895806bb"><td class="memItemLeft" align="right" valign="top"><a id="a6673b13653f24e0bc7f359ff895806bb"></a>
ROSE_DLL_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#a6673b13653f24e0bc7f359ff895806bb">isInClauseVariableList</a> (<a class="el" href="classSgInitializedName.html">SgInitializedName</a> *var, <a class="el" href="classSgUpirFieldBodyStatement.html">SgUpirFieldBodyStatement</a> *clause_stmt, const VariantT &amp;vt)</td></tr>
<tr class="memdesc:a6673b13653f24e0bc7f359ff895806bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a variable is in a variable list of a given clause type. <br /></td></tr>
<tr class="separator:a6673b13653f24e0bc7f359ff895806bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93472f1b9466bf8dad2662856e2812b3"><td class="memItemLeft" align="right" valign="top"><a id="a93472f1b9466bf8dad2662856e2812b3"></a>
ROSE_DLL_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#a93472f1b9466bf8dad2662856e2812b3">isInClauseVariableList</a> (<a class="el" href="classSgInitializedName.html">SgInitializedName</a> *var, <a class="el" href="classSgUpirFieldBodyStatement.html">SgUpirFieldBodyStatement</a> *clause_stmt, const VariantVector &amp;vvt)</td></tr>
<tr class="memdesc:a93472f1b9466bf8dad2662856e2812b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a variable is in variable lists of given clause types. <br /></td></tr>
<tr class="separator:a93472f1b9466bf8dad2662856e2812b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97ac93c429bcb6007e9be3b443f987c5"><td class="memItemLeft" align="right" valign="top"><a id="a97ac93c429bcb6007e9be3b443f987c5"></a>
ROSE_DLL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#a97ac93c429bcb6007e9be3b443f987c5">replaceVariableReferences</a> (<a class="el" href="classSgNode.html">SgNode</a> *root, <a class="el" href="classSgVariableSymbol.html">SgVariableSymbol</a> *oldVar, <a class="el" href="classSgVariableSymbol.html">SgVariableSymbol</a> *newVar)</td></tr>
<tr class="memdesc:a97ac93c429bcb6007e9be3b443f987c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace references to oldVar within root with references to newVar, return the number of references replaced. <br /></td></tr>
<tr class="separator:a97ac93c429bcb6007e9be3b443f987c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b33ecf538a49b48239039fd4e51f3b8"><td class="memItemLeft" align="right" valign="top"><a id="a8b33ecf538a49b48239039fd4e51f3b8"></a>
ROSE_DLL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#a8b33ecf538a49b48239039fd4e51f3b8">replaceVariableReferences</a> (<a class="el" href="classSgNode.html">SgNode</a> *root, VariableSymbolMap_t varRemap)</td></tr>
<tr class="memdesc:a8b33ecf538a49b48239039fd4e51f3b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace variable references within root based on a map from old symbols to new symbols. <br /></td></tr>
<tr class="separator:a8b33ecf538a49b48239039fd4e51f3b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6dfe9c59c91efe7149787d3bac59ac1"><td class="memItemLeft" align="right" valign="top"><a id="ab6dfe9c59c91efe7149787d3bac59ac1"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#ab6dfe9c59c91efe7149787d3bac59ac1">replaceVariablesWithPointerDereference</a> (<a class="el" href="classSgNode.html">SgNode</a> *root, std::set&lt; <a class="el" href="classSgVariableSymbol.html">SgVariableSymbol</a> * &gt; &amp;vars)</td></tr>
<tr class="memdesc:ab6dfe9c59c91efe7149787d3bac59ac1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all variable references in a set by pointers to the variable. <br /></td></tr>
<tr class="separator:ab6dfe9c59c91efe7149787d3bac59ac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa685cef581148647ec248659ec866f56"><td class="memItemLeft" align="right" valign="top"><a id="aa685cef581148647ec248659ec866f56"></a>
ROSE_DLL_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#aa685cef581148647ec248659ec866f56">addClauseVariable</a> (<a class="el" href="classSgInitializedName.html">SgInitializedName</a> *var, <a class="el" href="classSgUpirFieldBodyStatement.html">SgUpirFieldBodyStatement</a> *clause_stmt, const VariantT &amp;vt)</td></tr>
<tr class="memdesc:aa685cef581148647ec248659ec866f56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a variable into a non-reduction clause of an OpenMP statement, create the clause transparently if it does not exist. <br /></td></tr>
<tr class="separator:aa685cef581148647ec248659ec866f56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50c9ba632d617de35c6832a2086804e0"><td class="memItemLeft" align="right" valign="top"><a id="a50c9ba632d617de35c6832a2086804e0"></a>
ROSE_DLL_API void&#160;</td><td class="memItemRight" valign="bottom"><b>addUpirDataVariable</b> (<a class="el" href="classSgUpirFieldBodyStatement.html">SgUpirFieldBodyStatement</a> *target, <a class="el" href="classSgUpirDataItemField.html">SgUpirDataItemField</a> *data_item)</td></tr>
<tr class="separator:a50c9ba632d617de35c6832a2086804e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a383ff602be4a72c4240694d83725d681"><td class="memItemLeft" align="right" valign="top"><a id="a383ff602be4a72c4240694d83725d681"></a>
ROSE_DLL_API <a class="el" href="classSgOmpVariablesClause.html">SgOmpVariablesClause</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#a383ff602be4a72c4240694d83725d681">buildOmpVariableClause</a> (<a class="el" href="classSgUpirFieldBodyStatement.html">SgUpirFieldBodyStatement</a> *clause_stmt, const VariantT &amp;vt)</td></tr>
<tr class="memdesc:a383ff602be4a72c4240694d83725d681"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a non-reduction variable clause for a given OpenMP directive. It directly returns the clause if the clause already exists. <br /></td></tr>
<tr class="separator:a383ff602be4a72c4240694d83725d681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4baab3ab9d509a7c11bd91f095487a8"><td class="memItemLeft" align="right" valign="top"><a id="ab4baab3ab9d509a7c11bd91f095487a8"></a>
ROSE_DLL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#ab4baab3ab9d509a7c11bd91f095487a8">removeClause</a> (<a class="el" href="classSgStatement.html">SgStatement</a> *clause_stmt, const VariantT &amp;vt)</td></tr>
<tr class="memdesc:ab4baab3ab9d509a7c11bd91f095487a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove one or more clauses of type vt. <br /></td></tr>
<tr class="separator:ab4baab3ab9d509a7c11bd91f095487a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46d1b7400c94a66683d9d75fce1fbcb2"><td class="memItemLeft" align="right" valign="top"><a id="a46d1b7400c94a66683d9d75fce1fbcb2"></a>
ROSE_DLL_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#a46d1b7400c94a66683d9d75fce1fbcb2">hasClause</a> (<a class="el" href="classSgStatement.html">SgStatement</a> *clause_stmt, const VariantT &amp;vt)</td></tr>
<tr class="memdesc:a46d1b7400c94a66683d9d75fce1fbcb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if an OpenMP statement has a clause of type vt. <br /></td></tr>
<tr class="separator:a46d1b7400c94a66683d9d75fce1fbcb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab101b499af6e2733fedfa5c58e4ec4d1"><td class="memItemLeft" align="right" valign="top"><a id="ab101b499af6e2733fedfa5c58e4ec4d1"></a>
ROSE_DLL_API Rose_STL_Container&lt; <a class="el" href="classSgOmpClause.html">SgOmpClause</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#ab101b499af6e2733fedfa5c58e4ec4d1">getClause</a> (<a class="el" href="classSgStatement.html">SgStatement</a> *clause_stmt, const VariantT &amp;vt)</td></tr>
<tr class="memdesc:ab101b499af6e2733fedfa5c58e4ec4d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get OpenMP clauses from an eligible OpenMP statement. <br /></td></tr>
<tr class="separator:ab101b499af6e2733fedfa5c58e4ec4d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eec3a7d3344edd74923ffd7859307d9"><td class="memItemLeft" align="right" valign="top"><a id="a6eec3a7d3344edd74923ffd7859307d9"></a>
ROSE_DLL_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#a6eec3a7d3344edd74923ffd7859307d9">useStaticSchedule</a> (<a class="el" href="classSgUpirFieldBodyStatement.html">SgUpirFieldBodyStatement</a> *omp_loop)</td></tr>
<tr class="memdesc:a6eec3a7d3344edd74923ffd7859307d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if an omp for/do loop use static schedule or not, including: default schedule, or schedule(static[,chunk_size]) <br /></td></tr>
<tr class="separator:a6eec3a7d3344edd74923ffd7859307d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad979f1dd97d3484d8fa9842ea2f975a5"><td class="memItemLeft" align="right" valign="top"><a id="ad979f1dd97d3484d8fa9842ea2f975a5"></a>
ROSE_DLL_API SgOmpClause::omp_reduction_identifier_enum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#ad979f1dd97d3484d8fa9842ea2f975a5">getReductionOperationType</a> (<a class="el" href="classSgInitializedName.html">SgInitializedName</a> *init_name, <a class="el" href="classSgUpirFieldBodyStatement.html">SgUpirFieldBodyStatement</a> *clause_stmt)</td></tr>
<tr class="memdesc:ad979f1dd97d3484d8fa9842ea2f975a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reduction variable's reduction operation type. <br /></td></tr>
<tr class="separator:ad979f1dd97d3484d8fa9842ea2f975a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93c0b88b89b131549c039ab8028d59bb"><td class="memItemLeft" align="right" valign="top"><a id="a93c0b88b89b131549c039ab8028d59bb"></a>
ROSE_DLL_API <a class="el" href="classSgExpression.html">SgExpression</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#a93c0b88b89b131549c039ab8028d59bb">createInitialValueExp</a> (SgOmpClause::omp_reduction_identifier_enum r_operator)</td></tr>
<tr class="memdesc:a93c0b88b89b131549c039ab8028d59bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an initial value according to reduction operator type. <br /></td></tr>
<tr class="separator:a93c0b88b89b131549c039ab8028d59bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e0bd3d3d27d4f23dcd8340bcf07a5b6"><td class="memItemLeft" align="right" valign="top"><a id="a8e0bd3d3d27d4f23dcd8340bcf07a5b6"></a>
ROSE_DLL_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#a8e0bd3d3d27d4f23dcd8340bcf07a5b6">generateGOMPLoopStartFuncName</a> (bool isOrdered, SgOmpClause::omp_schedule_kind_enum s_kind)</td></tr>
<tr class="memdesc:a8e0bd3d3d27d4f23dcd8340bcf07a5b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate GOMP loop schedule start function's name. <br /></td></tr>
<tr class="separator:a8e0bd3d3d27d4f23dcd8340bcf07a5b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeed9f1f738216fef339027c347c6e615"><td class="memItemLeft" align="right" valign="top"><a id="aeed9f1f738216fef339027c347c6e615"></a>
ROSE_DLL_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#aeed9f1f738216fef339027c347c6e615">generateGOMPLoopNextFuncName</a> (bool isOrdered, SgOmpClause::omp_schedule_kind_enum s_kind)</td></tr>
<tr class="memdesc:aeed9f1f738216fef339027c347c6e615"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate GOMP loop schedule next function's name. <br /></td></tr>
<tr class="separator:aeed9f1f738216fef339027c347c6e615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad381a8a9a107462e74e55a621babb28d"><td class="memItemLeft" align="right" valign="top"><a id="ad381a8a9a107462e74e55a621babb28d"></a>
ROSE_DLL_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#ad381a8a9a107462e74e55a621babb28d">toString</a> (SgOmpClause::omp_schedule_kind_enum s_kind)</td></tr>
<tr class="memdesc:ad381a8a9a107462e74e55a621babb28d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a schedule kind enum value to a small case string. <br /></td></tr>
<tr class="separator:ad381a8a9a107462e74e55a621babb28d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bb2040f5469b59cd3baaabf7c1c7450"><td class="memItemLeft" align="right" valign="top"><a id="a3bb2040f5469b59cd3baaabf7c1c7450"></a>
ROSE_DLL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#a3bb2040f5469b59cd3baaabf7c1c7450">patchUpPrivateVariables</a> (<a class="el" href="classSgFile.html">SgFile</a> *)</td></tr>
<tr class="memdesc:a3bb2040f5469b59cd3baaabf7c1c7450"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patch up private variables for omp for of entire file. The reason is that loop indices should be private by default and this function will make this explicit. <br /></td></tr>
<tr class="separator:a3bb2040f5469b59cd3baaabf7c1c7450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3863e39e286bc6846a4619c0b6806e7"><td class="memItemLeft" align="right" valign="top"><a id="ac3863e39e286bc6846a4619c0b6806e7"></a>
ROSE_DLL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#ac3863e39e286bc6846a4619c0b6806e7">patchUpPrivateVariables</a> (<a class="el" href="classSgStatement.html">SgStatement</a> *omp_loop)</td></tr>
<tr class="memdesc:ac3863e39e286bc6846a4619c0b6806e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patch up private variables for omp for. The reason is that loop indices should be private by default and this function will make this explicit. <br /></td></tr>
<tr class="separator:ac3863e39e286bc6846a4619c0b6806e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadab3d7eb05453e29a85178f1df5694a"><td class="memItemLeft" align="right" valign="top"><a id="aadab3d7eb05453e29a85178f1df5694a"></a>
ROSE_DLL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#aadab3d7eb05453e29a85178f1df5694a">patchUpFirstprivateVariables</a> (<a class="el" href="classSgFile.html">SgFile</a> *)</td></tr>
<tr class="memdesc:aadab3d7eb05453e29a85178f1df5694a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patch up firstprivate variables for omp task. The reason is that the specification 3.0 defines rules for implicitly determined data-sharing attributes and this function will make the firstprivate variable of omp task explicit. <br /></td></tr>
<tr class="separator:aadab3d7eb05453e29a85178f1df5694a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a843697fdaa86dcaf061a566a899ff399"><td class="memItemLeft" align="right" valign="top"><a id="a843697fdaa86dcaf061a566a899ff399"></a>
std::set&lt; <a class="el" href="classSgInitializedName.html">SgInitializedName</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#a843697fdaa86dcaf061a566a899ff399">collectThreadprivateVariables</a> ()</td></tr>
<tr class="memdesc:a843697fdaa86dcaf061a566a899ff399"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect threadprivate variables within the current project, return a set to avoid duplicated elements. No input parameters are needed since it finds match from memory pools. <br /></td></tr>
<tr class="separator:a843697fdaa86dcaf061a566a899ff399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11f6c2558c6097ef8159e589b1c87970"><td class="memItemLeft" align="right" valign="top"><a id="a11f6c2558c6097ef8159e589b1c87970"></a>
<a class="el" href="classSgVariableDeclaration.html">SgVariableDeclaration</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#a11f6c2558c6097ef8159e589b1c87970">buildAndInsertDeclarationForOmp</a> (const std::string &amp;name, <a class="el" href="classSgType.html">SgType</a> *type, <a class="el" href="classSgInitializer.html">SgInitializer</a> *varInit, <a class="el" href="classSgBasicBlock.html">SgBasicBlock</a> *orig_scope)</td></tr>
<tr class="memdesc:a11f6c2558c6097ef8159e589b1c87970"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special handling when trying to build and insert a variable declaration into a BB within Fortran OpenMP code. <br /></td></tr>
<tr class="separator:a11f6c2558c6097ef8159e589b1c87970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c8e542fd545455f79d186bc3fb0107d"><td class="memItemLeft" align="right" valign="top"><a id="a4c8e542fd545455f79d186bc3fb0107d"></a>
<a class="el" href="classSgBasicBlock.html">SgBasicBlock</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#a4c8e542fd545455f79d186bc3fb0107d">getEnclosingRegionOrFuncDefinition</a> (<a class="el" href="classSgNode.html">SgNode</a> *)</td></tr>
<tr class="memdesc:a4c8e542fd545455f79d186bc3fb0107d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find an enclosing parallel region or function definition's body. <br /></td></tr>
<tr class="separator:a4c8e542fd545455f79d186bc3fb0107d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab59136522fa2c557521a2db41c0910d7"><td class="memItemLeft" align="right" valign="top"><a id="ab59136522fa2c557521a2db41c0910d7"></a>
ROSE_DLL_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#ab59136522fa2c557521a2db41c0910d7">isInClauseVariableList</a> (<a class="el" href="classSgOmpClause.html">SgOmpClause</a> *cls, <a class="el" href="classSgSymbol.html">SgSymbol</a> *var)</td></tr>
<tr class="memdesc:ab59136522fa2c557521a2db41c0910d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a variable is in the clause's variable list. <br /></td></tr>
<tr class="separator:ab59136522fa2c557521a2db41c0910d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e76c4ddef59877fe93aa8d5a0ee2b70"><td class="memItemLeft" align="right" valign="top"><a id="a3e76c4ddef59877fe93aa8d5a0ee2b70"></a>
ROSE_DLL_API bool&#160;</td><td class="memItemRight" valign="bottom"><b>isInUpirDataSharingList</b> (<a class="el" href="classSgOmpClause.html">SgOmpClause</a> *data, <a class="el" href="classSgSymbol.html">SgSymbol</a> *<a class="el" href="classvariable.html">variable</a>, SgOmpClause::upir_data_sharing_enum sharing_property)</td></tr>
<tr class="separator:a3e76c4ddef59877fe93aa8d5a0ee2b70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40f5bc636c29296717ac0ecb921852a8"><td class="memItemLeft" align="right" valign="top"><a id="a40f5bc636c29296717ac0ecb921852a8"></a>
ROSE_DLL_API bool&#160;</td><td class="memItemRight" valign="bottom"><b>isInUpirDataSharingList</b> (<a class="el" href="classSgUpirFieldBodyStatement.html">SgUpirFieldBodyStatement</a> *target, <a class="el" href="classSgSymbol.html">SgSymbol</a> *<a class="el" href="classvariable.html">variable</a>, SgOmpClause::upir_data_sharing_enum sharing_property)</td></tr>
<tr class="separator:a40f5bc636c29296717ac0ecb921852a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3045ec9ec66d146297a0ae636dde1aa3"><td class="memItemLeft" align="right" valign="top"><a id="a3045ec9ec66d146297a0ae636dde1aa3"></a>
ROSE_DLL_API bool&#160;</td><td class="memItemRight" valign="bottom"><b>isInUpirDataSharingList</b> (<a class="el" href="classSgUpirFieldBodyStatement.html">SgUpirFieldBodyStatement</a> *target, <a class="el" href="classSgSymbol.html">SgSymbol</a> *<a class="el" href="classvariable.html">variable</a>, std::set&lt; SgOmpClause::upir_data_sharing_enum &gt; sharing_property)</td></tr>
<tr class="separator:a3045ec9ec66d146297a0ae636dde1aa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32c9372d74c54be8f82308977e184700"><td class="memItemLeft" align="right" valign="top"><a id="a32c9372d74c54be8f82308977e184700"></a>
ROSE_DLL_API bool&#160;</td><td class="memItemRight" valign="bottom"><b>isInUpirDataList</b> (<a class="el" href="classSgUpirFieldBodyStatement.html">SgUpirFieldBodyStatement</a> *target, <a class="el" href="classSgSymbol.html">SgSymbol</a> *<a class="el" href="classvariable.html">variable</a>)</td></tr>
<tr class="separator:a32c9372d74c54be8f82308977e184700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98a9671abaa3ec237bfb42b007ef23d2"><td class="memItemLeft" align="right" valign="top"><a id="a98a9671abaa3ec237bfb42b007ef23d2"></a>
ROSE_DLL_API <a class="el" href="classSgUpirDataItemField.html">SgUpirDataItemField</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>isInUpirDataList</b> (<a class="el" href="classSgOmpClause.html">SgOmpClause</a> *target, <a class="el" href="classSgSymbol.html">SgSymbol</a> *<a class="el" href="classvariable.html">variable</a>)</td></tr>
<tr class="separator:a98a9671abaa3ec237bfb42b007ef23d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37b17ab1689d8b4ef4cab3d36521b3ac"><td class="memItemLeft" align="right" valign="top"><a id="a37b17ab1689d8b4ef4cab3d36521b3ac"></a>
ROSE_DLL_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#a37b17ab1689d8b4ef4cab3d36521b3ac">isThreadprivate</a> (<a class="el" href="classSgSymbol.html">SgSymbol</a> *var)</td></tr>
<tr class="memdesc:a37b17ab1689d8b4ef4cab3d36521b3ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a variable is a threadprivate variable. It will search for all threadprivate directives to find the answer. <br /></td></tr>
<tr class="separator:a37b17ab1689d8b4ef4cab3d36521b3ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eed087b63b4c940da7d59a9f148d2f5"><td class="memItemLeft" align="right" valign="top">ROSE_DLL_API omp_construct_enum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#a7eed087b63b4c940da7d59a9f148d2f5">getDataSharingAttribute</a> (<a class="el" href="classSgSymbol.html">SgSymbol</a> *var, <a class="el" href="classSgNode.html">SgNode</a> *anchor_node)</td></tr>
<tr class="memdesc:a7eed087b63b4c940da7d59a9f148d2f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the data sharing attribute type of a variable, specified as a symbol and an anchor node (Must be the inner most node associated with the variable reference, e.g.  <a href="namespaceOmpSupport.html#a7eed087b63b4c940da7d59a9f148d2f5">More...</a><br /></td></tr>
<tr class="separator:a7eed087b63b4c940da7d59a9f148d2f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af51968a9d4386f3819161dca44b76542"><td class="memItemLeft" align="right" valign="top"><a id="af51968a9d4386f3819161dca44b76542"></a>
ROSE_DLL_API omp_construct_enum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#af51968a9d4386f3819161dca44b76542">getDataSharingAttribute</a> (<a class="el" href="classSgVarRefExp.html">SgVarRefExp</a> *varRef)</td></tr>
<tr class="memdesc:af51968a9d4386f3819161dca44b76542"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the OpenMP data sharing attribute type of a variable reference. <br /></td></tr>
<tr class="separator:af51968a9d4386f3819161dca44b76542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca716508b2b743aab5240e4acea9f68"><td class="memItemLeft" align="right" valign="top"><a id="afca716508b2b743aab5240e4acea9f68"></a>
ROSE_DLL_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#afca716508b2b743aab5240e4acea9f68">isSharedAccess</a> (<a class="el" href="classSgVarRefExp.html">SgVarRefExp</a> *varRef)</td></tr>
<tr class="memdesc:afca716508b2b743aab5240e4acea9f68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a variable access is a shared access , assuming it is already within an OpenMP region. <br /></td></tr>
<tr class="separator:afca716508b2b743aab5240e4acea9f68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54fa7a7c146b001c2563c3254ebb78f7"><td class="memItemLeft" align="right" valign="top"><a id="a54fa7a7c146b001c2563c3254ebb78f7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#a54fa7a7c146b001c2563c3254ebb78f7">extractMapClauses</a> (Rose_STL_Container&lt; <a class="el" href="classSgOmpClause.html">SgOmpClause</a> * &gt; map_clauses, std::map&lt; <a class="el" href="classSgSymbol.html">SgSymbol</a> *, std::vector&lt; std::pair&lt; <a class="el" href="classSgExpression.html">SgExpression</a> *, <a class="el" href="classSgExpression.html">SgExpression</a> * &gt; &gt; &gt; &amp;array_dimensions, std::map&lt; <a class="el" href="classSgSymbol.html">SgSymbol</a> *, std::vector&lt; std::pair&lt; SgOmpClause::omp_map_dist_data_enum, <a class="el" href="classSgExpression.html">SgExpression</a> * &gt; &gt; &gt; &amp;dist_data_policies, <a class="el" href="classSgOmpMapClause.html">SgOmpMapClause</a> **map_alloc_clause, <a class="el" href="classSgOmpMapClause.html">SgOmpMapClause</a> **map_to_clause, <a class="el" href="classSgOmpMapClause.html">SgOmpMapClause</a> **map_from_clause, <a class="el" href="classSgOmpMapClause.html">SgOmpMapClause</a> **map_tofrom_clause)</td></tr>
<tr class="memdesc:a54fa7a7c146b001c2563c3254ebb78f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract map clause information. <br /></td></tr>
<tr class="separator:a54fa7a7c146b001c2563c3254ebb78f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a406e9cfadde32b60ea49cd622f88d45a"><td class="memItemLeft" align="right" valign="top"><a id="a406e9cfadde32b60ea49cd622f88d45a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#a406e9cfadde32b60ea49cd622f88d45a">categorizeMapClauseVariables</a> (const SgInitializedNamePtrList &amp;all_vars, std::map&lt; <a class="el" href="classSgSymbol.html">SgSymbol</a> *, std::vector&lt; std::pair&lt; <a class="el" href="classSgExpression.html">SgExpression</a> *, <a class="el" href="classSgExpression.html">SgExpression</a> * &gt; &gt; &gt; &amp;array_dimensions, std::set&lt; <a class="el" href="classSgSymbol.html">SgSymbol</a> * &gt; &amp;array_syms, std::set&lt; <a class="el" href="classSgSymbol.html">SgSymbol</a> * &gt; &amp;atom_syms)</td></tr>
<tr class="memdesc:a406e9cfadde32b60ea49cd622f88d45a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Categorize mapped variables. <br /></td></tr>
<tr class="separator:a406e9cfadde32b60ea49cd622f88d45a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ad6e37a76fc52e19725e0509e53317996"><td class="memItemLeft" align="right" valign="top"><a id="ad6e37a76fc52e19725e0509e53317996"></a>
omp_construct_enum&#160;</td><td class="memItemRight" valign="bottom"><b>cur_omp_directive</b></td></tr>
<tr class="separator:ad6e37a76fc52e19725e0509e53317996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2297a3748cc91d4ba10b8d66dab3d384"><td class="memItemLeft" align="right" valign="top"><a id="a2297a3748cc91d4ba10b8d66dab3d384"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>enable_accelerator</b></td></tr>
<tr class="separator:a2297a3748cc91d4ba10b8d66dab3d384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30db8c05a30482833a0682ca3354ccdf"><td class="memItemLeft" align="right" valign="top"><a id="a30db8c05a30482833a0682ca3354ccdf"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>useDDE</b></td></tr>
<tr class="separator:a30db8c05a30482833a0682ca3354ccdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8e89533a4c04bd31d7393781274f68e"><td class="memItemLeft" align="right" valign="top"><a id="af8e89533a4c04bd31d7393781274f68e"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>nCounter</b></td></tr>
<tr class="separator:af8e89533a4c04bd31d7393781274f68e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43438c01722b3b4802ce8d082a636759"><td class="memItemLeft" align="right" valign="top"><a id="a43438c01722b3b4802ce8d082a636759"></a>
<a class="el" href="namespaceOmpSupport.html#abffc7f08fd77ecfd382fe54fd641dc10">omp_rtl_enum</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rtl_type</b></td></tr>
<tr class="separator:a43438c01722b3b4802ce8d082a636759"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a7501a3bda788701ed37519c2e0f56a2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7501a3bda788701ed37519c2e0f56a2f">&#9670;&nbsp;</a></span>patchUpSharedVariables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OmpSupport::patchUpSharedVariables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgFile.html">SgFile</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>makeDataSharingExplicit() can call some of existing functions for some work in <a class="el" href="namespaceOmpSupport.html" title="Types and functions to support OpenMP.">OmpSupport</a> namespace by Hongyi 07/16/2012 TODO: add a function within the <a class="el" href="namespaceOmpSupport.html" title="Types and functions to support OpenMP.">OmpSupport</a> namespace, the function should transform the AST, so all variables' data-sharing attributes are explicitied represented in the AST. </p>
<p>ROSE has dedicated AST nodes for OpenMP directives and the associated clauses, such as private, shared, reduction. </p>

</div>
</div>
<a id="a1c59562231bb9a568ee6ef65bd6cc3ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c59562231bb9a568ee6ef65bd6cc3ec">&#9670;&nbsp;</a></span>transOmpTarget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OmpSupport::transOmpTarget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Translate Fortran omp do. </p>
<p>Translate "omp target" </p>

</div>
</div>
<a id="a7eed087b63b4c940da7d59a9f148d2f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eed087b63b4c940da7d59a9f148d2f5">&#9670;&nbsp;</a></span>getDataSharingAttribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_DLL_API omp_construct_enum OmpSupport::getDataSharingAttribute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgSymbol.html">SgSymbol</a> *&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&#160;</td>
          <td class="paramname"><em>anchor_node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the data sharing attribute type of a variable, specified as a symbol and an anchor node (Must be the inner most node associated with the variable reference, e.g. </p>
<p>a <a class="el" href="classSgVarRefExp.html" title="This class represents the variable refernece in expressions.">SgVarRefExp</a>, <a class="el" href="classSgVariableDeclaration.html" title="This class represents the concept of a C or C++ variable declaration.">SgVariableDeclaration</a>, etc) Possible returned values include: e_shared, e_private, e_firstprivate, e_lastprivate, e_reduction, e_threadprivate, e_copyin, and e_copyprivate. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Dec 19 2022 23:40:25 for ROSE by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
