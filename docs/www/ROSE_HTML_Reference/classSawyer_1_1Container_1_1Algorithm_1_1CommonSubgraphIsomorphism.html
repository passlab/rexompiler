<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROSE: Sawyer::Container::Algorithm::CommonSubgraphIsomorphism&lt; GraphA, GraphB, SolutionProcessor, EquivalenceP &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="ROSE"/>
<link href="roseDoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ROSE
   &#160;<span id="projectnumber">0.11.96.11</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,true,'search.html','Search');
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceSawyer.html">Sawyer</a></li><li class="navelem"><a class="el" href="namespaceSawyer_1_1Container.html">Container</a></li><li class="navelem"><a class="el" href="namespaceSawyer_1_1Container_1_1Algorithm.html">Algorithm</a></li><li class="navelem"><a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html">CommonSubgraphIsomorphism</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Sawyer::Container::Algorithm::CommonSubgraphIsomorphism&lt; GraphA, GraphB, SolutionProcessor, EquivalenceP &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><h3>template&lt;class GraphA, class GraphB, class SolutionProcessor = CsiShowSolution&lt;GraphA, GraphB&gt;, class EquivalenceP = CsiEquivalence&lt;GraphA, GraphB&gt;&gt;<br />
class Sawyer::Container::Algorithm::CommonSubgraphIsomorphism&lt; GraphA, GraphB, SolutionProcessor, EquivalenceP &gt;</h3>

<p>Common subgraph isomorphism solver. </p>
<p>Finds subgraphs of two given graphs where the subgraphs are isomorphic to one another.</p>
<p>The solver assumes that any vertex in the first graph can be isomorphic to any vertex of the second graph unless the user provides his own equivalence predicate. The default predicate, <a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1CsiEquivalence.html">CsiEquivalence</a>, allows any vertex to be isomorphic to any other vertex (the solver additionally requires that the two subgraphs of any solution have the same number of edges). Providing an equivalence predicate can substantially reduce the search space, as can limiting the minimum size of solutions.</p>
<p>Each time a solution is found, the <code>SolutionProcessor</code> is invoked. Users will typically provide their own solution processor since the default processor, <a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1CsiShowSolution.html">CsiShowSolution</a>, only prints the solutions to standard output. The solution processor is only called for complete solutions when the end of a search path is reached; it is not called for intermediate solutions. The processor can return a code that indicates how the algorithm should proceed. See <a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1CsiShowSolution.html">CsiShowSolution</a> for more information.</p>
<p>To use this class, instantiate an instance and specify the two graphs to be compared (they can both be the same graph if desired), the solution handler callback, and the vertex equivalence predicate. Then, if necessary, make adjustements to the callback and/or predicate. Finally, invoke the <a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html#a795c5207d979a168d4f95814ce62f380">run</a> method. The graphs must not be modified between the time this solver is created and the <a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html#a795c5207d979a168d4f95814ce62f380">run</a> method returns.</p>
<p>The following functions are convenient wrappers around this class: <a class="el" href="namespaceSawyer_1_1Container_1_1Algorithm.html#a125e6d3b75c1f45be000702427b39a0f">findCommonIsomorphicSubgraphs</a>, <a class="el" href="namespaceSawyer_1_1Container_1_1Algorithm.html#a79f3b4db6da4e57a5a1d5ff7ff39b3f7">findFirstCommonIsomorphicSubgraph</a>, <a class="el" href="namespaceSawyer_1_1Container_1_1Algorithm.html#abdfddcc3c0de62ffb90d868264b20483">findIsomorphicSubgraphs</a>, <a class="el" href="namespaceSawyer_1_1Container_1_1Algorithm.html#af893c884305001ca91a0ef56a6c2f1b6">findMaximumCommonIsomorphicSubgraphs</a>. </p>

<p class="definition">Definition at line <a class="el" href="GraphAlgorithm_8h_source.html#l00443">443</a> of file <a class="el" href="GraphAlgorithm_8h_source.html">GraphAlgorithm.h</a>.</p>
</div>
<p><code>#include &lt;<a class="el" href="GraphAlgorithm_8h_source.html">util/Sawyer/GraphAlgorithm.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6259498f1de60e4a428cddcfd7991b81"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html#a6259498f1de60e4a428cddcfd7991b81">CommonSubgraphIsomorphism</a> (const GraphA &amp;g1, const GraphB &amp;g2, SolutionProcessor <a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html#abfe2af18d37f66365a12764777912f7a">solutionProcessor</a>=SolutionProcessor(), EquivalenceP equivalenceP=EquivalenceP())</td></tr>
<tr class="memdesc:a6259498f1de60e4a428cddcfd7991b81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a solver.  <a href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html#a6259498f1de60e4a428cddcfd7991b81">More...</a><br /></td></tr>
<tr class="separator:a6259498f1de60e4a428cddcfd7991b81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a795c5207d979a168d4f95814ce62f380"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html#a795c5207d979a168d4f95814ce62f380">run</a> ()</td></tr>
<tr class="memdesc:a795c5207d979a168d4f95814ce62f380"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform the common subgraph isomorphism analysis.  <a href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html#a795c5207d979a168d4f95814ce62f380">More...</a><br /></td></tr>
<tr class="separator:a795c5207d979a168d4f95814ce62f380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef213d856bdba10e04c210ff64cbdb68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html#aef213d856bdba10e04c210ff64cbdb68">reset</a> ()</td></tr>
<tr class="memdesc:aef213d856bdba10e04c210ff64cbdb68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases memory used by the analysis.  <a href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html#aef213d856bdba10e04c210ff64cbdb68">More...</a><br /></td></tr>
<tr class="separator:aef213d856bdba10e04c210ff64cbdb68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aaecdf4256eb655f03557ba236dcb9b40"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html#aaecdf4256eb655f03557ba236dcb9b40">minimumSolutionSize</a> () const</td></tr>
<tr class="memdesc:aaecdf4256eb655f03557ba236dcb9b40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: minimum allowed solution size.  <a href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html#aaecdf4256eb655f03557ba236dcb9b40">More...</a><br /></td></tr>
<tr class="separator:aaecdf4256eb655f03557ba236dcb9b40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2849ef5e8d80db5725c808757c32afe8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html#a2849ef5e8d80db5725c808757c32afe8">minimumSolutionSize</a> (size_t n)</td></tr>
<tr class="memdesc:a2849ef5e8d80db5725c808757c32afe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: minimum allowed solution size.  <a href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html#a2849ef5e8d80db5725c808757c32afe8">More...</a><br /></td></tr>
<tr class="separator:a2849ef5e8d80db5725c808757c32afe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ab2fcf9fbbfd7a370c3fce69df4583226"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html#ab2fcf9fbbfd7a370c3fce69df4583226">maximumSolutionSize</a> () const</td></tr>
<tr class="memdesc:ab2fcf9fbbfd7a370c3fce69df4583226"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: maximum allowed solution size.  <a href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html#ab2fcf9fbbfd7a370c3fce69df4583226">More...</a><br /></td></tr>
<tr class="separator:ab2fcf9fbbfd7a370c3fce69df4583226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45f3f476bcc82faabd751b27fd8ebe20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html#a45f3f476bcc82faabd751b27fd8ebe20">maximumSolutionSize</a> (size_t n)</td></tr>
<tr class="memdesc:a45f3f476bcc82faabd751b27fd8ebe20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: maximum allowed solution size.  <a href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html#a45f3f476bcc82faabd751b27fd8ebe20">More...</a><br /></td></tr>
<tr class="separator:a45f3f476bcc82faabd751b27fd8ebe20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aeb984b8ea962c1be738a7d094a38fbd4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html#aeb984b8ea962c1be738a7d094a38fbd4">monotonicallyIncreasing</a> () const</td></tr>
<tr class="memdesc:aeb984b8ea962c1be738a7d094a38fbd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: monotonically increasing solution size.  <a href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html#aeb984b8ea962c1be738a7d094a38fbd4">More...</a><br /></td></tr>
<tr class="separator:aeb984b8ea962c1be738a7d094a38fbd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc7b7559f4401b61fe5e3514735dbc0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html#afc7b7559f4401b61fe5e3514735dbc0f">monotonicallyIncreasing</a> (bool b)</td></tr>
<tr class="memdesc:afc7b7559f4401b61fe5e3514735dbc0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: monotonically increasing solution size.  <a href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html#afc7b7559f4401b61fe5e3514735dbc0f">More...</a><br /></td></tr>
<tr class="separator:afc7b7559f4401b61fe5e3514735dbc0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:abfe2af18d37f66365a12764777912f7a"><td class="memItemLeft" align="right" valign="top">SolutionProcessor &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html#abfe2af18d37f66365a12764777912f7a">solutionProcessor</a> ()</td></tr>
<tr class="memdesc:abfe2af18d37f66365a12764777912f7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: reference to the solution callback.  <a href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html#abfe2af18d37f66365a12764777912f7a">More...</a><br /></td></tr>
<tr class="separator:abfe2af18d37f66365a12764777912f7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a483ce902cc637883a4c65a7d637adc7b"><td class="memItemLeft" align="right" valign="top">const SolutionProcessor &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html#a483ce902cc637883a4c65a7d637adc7b">solutionProcessor</a> () const</td></tr>
<tr class="memdesc:a483ce902cc637883a4c65a7d637adc7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: reference to the solution callback.  <a href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html#a483ce902cc637883a4c65a7d637adc7b">More...</a><br /></td></tr>
<tr class="separator:a483ce902cc637883a4c65a7d637adc7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a8e06bbbd7643c8dccecab3823d1992cf"><td class="memItemLeft" align="right" valign="top">EquivalenceP &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html#a8e06bbbd7643c8dccecab3823d1992cf">equivalencePredicate</a> ()</td></tr>
<tr class="memdesc:a8e06bbbd7643c8dccecab3823d1992cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: reference to the vertex equivalence predicate.  <a href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html#a8e06bbbd7643c8dccecab3823d1992cf">More...</a><br /></td></tr>
<tr class="separator:a8e06bbbd7643c8dccecab3823d1992cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69e80165973320a2f2dda3acd174b331"><td class="memItemLeft" align="right" valign="top">const EquivalenceP &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html#a69e80165973320a2f2dda3acd174b331">equivalencePredicate</a> () const</td></tr>
<tr class="memdesc:a69e80165973320a2f2dda3acd174b331"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: reference to the vertex equivalence predicate.  <a href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html#a69e80165973320a2f2dda3acd174b331">More...</a><br /></td></tr>
<tr class="separator:a69e80165973320a2f2dda3acd174b331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a7670d6ffa227c87a23b17aa30ca0c495"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html#a7670d6ffa227c87a23b17aa30ca0c495">findingCommonSubgraphs</a> () const</td></tr>
<tr class="memdesc:a7670d6ffa227c87a23b17aa30ca0c495"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: find common subgraphs.  <a href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html#a7670d6ffa227c87a23b17aa30ca0c495">More...</a><br /></td></tr>
<tr class="separator:a7670d6ffa227c87a23b17aa30ca0c495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a111e8af69dc18cde3d6e0373a2535cc3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html#a111e8af69dc18cde3d6e0373a2535cc3">findingCommonSubgraphs</a> (bool b)</td></tr>
<tr class="memdesc:a111e8af69dc18cde3d6e0373a2535cc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: find common subgraphs.  <a href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html#a111e8af69dc18cde3d6e0373a2535cc3">More...</a><br /></td></tr>
<tr class="separator:a111e8af69dc18cde3d6e0373a2535cc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a6259498f1de60e4a428cddcfd7991b81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6259498f1de60e4a428cddcfd7991b81">&#9670;&nbsp;</a></span>CommonSubgraphIsomorphism()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GraphA , class GraphB , class SolutionProcessor  = CsiShowSolution&lt;GraphA, GraphB&gt;, class EquivalenceP  = CsiEquivalence&lt;GraphA, GraphB&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html">Sawyer::Container::Algorithm::CommonSubgraphIsomorphism</a>&lt; GraphA, GraphB, SolutionProcessor, EquivalenceP &gt;::<a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html">CommonSubgraphIsomorphism</a> </td>
          <td>(</td>
          <td class="paramtype">const GraphA &amp;&#160;</td>
          <td class="paramname"><em>g1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GraphB &amp;&#160;</td>
          <td class="paramname"><em>g2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SolutionProcessor&#160;</td>
          <td class="paramname"><em>solutionProcessor</em> = <code>SolutionProcessor()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EquivalenceP&#160;</td>
          <td class="paramname"><em>equivalenceP</em> = <code>EquivalenceP()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a solver. </p>
<p>Constructs a solver that will find subgraphs of <code>g1</code> and <code>g2</code> that are isomorpic to one another. The graphs must not be modified between the call to this constructor and the return of its <a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html#a795c5207d979a168d4f95814ce62f380">run</a> method.</p>
<p>The solution processor and equivalence predicate are copied into this solver. If the size of these objects is an issue, then they can be created with default constructors when the solver is created, and then modified afterward by obtaining a reference to the copies that are part of the solver.</p>
<p>The default solution processor, <a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1CsiShowSolution.html">CsiShowSolution</a>, prints the solutions to standard output. The default vertex equivalence predicate, <a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1CsiEquivalence.html">CsiEquivalence</a>, allows any vertex in graph <code>g1</code> to be isomorphic to any vertex in graph <code>g2</code>. The solver additionally constrains the two sugraphs of any solution to have the same number of edges (that's the essence of subgraph isomorphism and cannot be overridden by the vertex isomorphism predicate). </p>

<p class="definition">Definition at line <a class="el" href="GraphAlgorithm_8h_source.html#l00608">608</a> of file <a class="el" href="GraphAlgorithm_8h_source.html">GraphAlgorithm.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aaecdf4256eb655f03557ba236dcb9b40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaecdf4256eb655f03557ba236dcb9b40">&#9670;&nbsp;</a></span>minimumSolutionSize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GraphA , class GraphB , class SolutionProcessor  = CsiShowSolution&lt;GraphA, GraphB&gt;, class EquivalenceP  = CsiEquivalence&lt;GraphA, GraphB&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html">Sawyer::Container::Algorithm::CommonSubgraphIsomorphism</a>&lt; GraphA, GraphB, SolutionProcessor, EquivalenceP &gt;::minimumSolutionSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: minimum allowed solution size. </p>
<p>Determines the minimum size of solutions for which the solution processor callback is invoked. This minimum can be changed at any time before or during the analysis and is useful when looking for the largest isomorphic subgraphs. Not only does this property control when the solution processor is invoked, but it's also used to limit the search space&ndash;specifying a large minimum size causes the analysis to run faster.</p>
<p>Decreasing the minimum solution size during a run will not cause solutions that were smaller than its previous value to be found if those solutions have already been skipped or pruned from the search space.</p>
<p>The default minimum is one, which means that the trivial solution of two empty subgraphs is not reported to the callback.</p>
<p>See also, <a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html#ab2fcf9fbbfd7a370c3fce69df4583226">maximumSolutionSize</a>. </p>

<p class="definition">Definition at line <a class="el" href="GraphAlgorithm_8h_source.html#l00641">641</a> of file <a class="el" href="GraphAlgorithm_8h_source.html">GraphAlgorithm.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="GraphAlgorithm_8h_source.html#l01004">Sawyer::Container::Algorithm::findFirstCommonIsomorphicSubgraph()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism_aaecdf4256eb655f03557ba236dcb9b40_icgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism_aaecdf4256eb655f03557ba236dcb9b40_icgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism_aaecdf4256eb655f03557ba236dcb9b40_icgraph" id="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism_aaecdf4256eb655f03557ba236dcb9b40_icgraph">
<area shape="rect" title="Property: minimum allowed solution size." alt="" coords="239,5,507,61"/>
<area shape="rect" href="namespaceSawyer_1_1Container_1_1Algorithm.html#a79f3b4db6da4e57a5a1d5ff7ff39b3f7" title="Determine whether a common subgraph exists." alt="" coords="5,5,191,61"/>
</map>
</div>

</div>
</div>
<a id="a2849ef5e8d80db5725c808757c32afe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2849ef5e8d80db5725c808757c32afe8">&#9670;&nbsp;</a></span>minimumSolutionSize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GraphA , class GraphB , class SolutionProcessor  = CsiShowSolution&lt;GraphA, GraphB&gt;, class EquivalenceP  = CsiEquivalence&lt;GraphA, GraphB&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html">Sawyer::Container::Algorithm::CommonSubgraphIsomorphism</a>&lt; GraphA, GraphB, SolutionProcessor, EquivalenceP &gt;::minimumSolutionSize </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: minimum allowed solution size. </p>
<p>Determines the minimum size of solutions for which the solution processor callback is invoked. This minimum can be changed at any time before or during the analysis and is useful when looking for the largest isomorphic subgraphs. Not only does this property control when the solution processor is invoked, but it's also used to limit the search space&ndash;specifying a large minimum size causes the analysis to run faster.</p>
<p>Decreasing the minimum solution size during a run will not cause solutions that were smaller than its previous value to be found if those solutions have already been skipped or pruned from the search space.</p>
<p>The default minimum is one, which means that the trivial solution of two empty subgraphs is not reported to the callback.</p>
<p>See also, <a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html#ab2fcf9fbbfd7a370c3fce69df4583226">maximumSolutionSize</a>. </p>

<p class="definition">Definition at line <a class="el" href="GraphAlgorithm_8h_source.html#l00642">642</a> of file <a class="el" href="GraphAlgorithm_8h_source.html">GraphAlgorithm.h</a>.</p>

</div>
</div>
<a id="ab2fcf9fbbfd7a370c3fce69df4583226"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2fcf9fbbfd7a370c3fce69df4583226">&#9670;&nbsp;</a></span>maximumSolutionSize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GraphA , class GraphB , class SolutionProcessor  = CsiShowSolution&lt;GraphA, GraphB&gt;, class EquivalenceP  = CsiEquivalence&lt;GraphA, GraphB&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html">Sawyer::Container::Algorithm::CommonSubgraphIsomorphism</a>&lt; GraphA, GraphB, SolutionProcessor, EquivalenceP &gt;::maximumSolutionSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: maximum allowed solution size. </p>
<p>Determines the maximum size of solutions for which the solution processor callback is invoked. The maximum can be changed any time before or during the analysis. Once a maximum solution is found along some search path, the remainder of the search path is discarded.</p>
<p>Increasing the maximum solution size during a run will not cause solutions that were larger than its previous value to be found if those solutions have already been skipped.</p>
<p>The default maximum is larger than both graphs, which means all solutions will be found.</p>
<p>See also, <a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html#aaecdf4256eb655f03557ba236dcb9b40">minimumSolutionSize</a>. </p>

<p class="definition">Definition at line <a class="el" href="GraphAlgorithm_8h_source.html#l00659">659</a> of file <a class="el" href="GraphAlgorithm_8h_source.html">GraphAlgorithm.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="GraphAlgorithm_8h_source.html#l01004">Sawyer::Container::Algorithm::findFirstCommonIsomorphicSubgraph()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism_ab2fcf9fbbfd7a370c3fce69df4583226_icgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism_ab2fcf9fbbfd7a370c3fce69df4583226_icgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism_ab2fcf9fbbfd7a370c3fce69df4583226_icgraph" id="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism_ab2fcf9fbbfd7a370c3fce69df4583226_icgraph">
<area shape="rect" title="Property: maximum allowed solution size." alt="" coords="239,5,507,61"/>
<area shape="rect" href="namespaceSawyer_1_1Container_1_1Algorithm.html#a79f3b4db6da4e57a5a1d5ff7ff39b3f7" title="Determine whether a common subgraph exists." alt="" coords="5,5,191,61"/>
</map>
</div>

</div>
</div>
<a id="a45f3f476bcc82faabd751b27fd8ebe20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45f3f476bcc82faabd751b27fd8ebe20">&#9670;&nbsp;</a></span>maximumSolutionSize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GraphA , class GraphB , class SolutionProcessor  = CsiShowSolution&lt;GraphA, GraphB&gt;, class EquivalenceP  = CsiEquivalence&lt;GraphA, GraphB&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html">Sawyer::Container::Algorithm::CommonSubgraphIsomorphism</a>&lt; GraphA, GraphB, SolutionProcessor, EquivalenceP &gt;::maximumSolutionSize </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: maximum allowed solution size. </p>
<p>Determines the maximum size of solutions for which the solution processor callback is invoked. The maximum can be changed any time before or during the analysis. Once a maximum solution is found along some search path, the remainder of the search path is discarded.</p>
<p>Increasing the maximum solution size during a run will not cause solutions that were larger than its previous value to be found if those solutions have already been skipped.</p>
<p>The default maximum is larger than both graphs, which means all solutions will be found.</p>
<p>See also, <a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html#aaecdf4256eb655f03557ba236dcb9b40">minimumSolutionSize</a>. </p>

<p class="definition">Definition at line <a class="el" href="GraphAlgorithm_8h_source.html#l00660">660</a> of file <a class="el" href="GraphAlgorithm_8h_source.html">GraphAlgorithm.h</a>.</p>

</div>
</div>
<a id="aeb984b8ea962c1be738a7d094a38fbd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb984b8ea962c1be738a7d094a38fbd4">&#9670;&nbsp;</a></span>monotonicallyIncreasing() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GraphA , class GraphB , class SolutionProcessor  = CsiShowSolution&lt;GraphA, GraphB&gt;, class EquivalenceP  = CsiEquivalence&lt;GraphA, GraphB&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html">Sawyer::Container::Algorithm::CommonSubgraphIsomorphism</a>&lt; GraphA, GraphB, SolutionProcessor, EquivalenceP &gt;::monotonicallyIncreasing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: monotonically increasing solution size. </p>
<p>If true, then each solution reported to the solution processor will be at least as large as the previous solution. Setting this property will result in more efficient behavior than culling solutions in the solution processor because in the former situation the solver can eliminate branches of the search space. This property is useful when searching for the largest isomorphic subgraph. </p>

<p class="definition">Definition at line <a class="el" href="GraphAlgorithm_8h_source.html#l00671">671</a> of file <a class="el" href="GraphAlgorithm_8h_source.html">GraphAlgorithm.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="GraphAlgorithm_8h_source.html#l01098">Sawyer::Container::Algorithm::findMaximumCommonIsomorphicSubgraphs()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism_aeb984b8ea962c1be738a7d094a38fbd4_icgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism_aeb984b8ea962c1be738a7d094a38fbd4_icgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism_aeb984b8ea962c1be738a7d094a38fbd4_icgraph" id="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism_aeb984b8ea962c1be738a7d094a38fbd4_icgraph">
<area shape="rect" title="Property: monotonically increasing solution size." alt="" coords="269,5,537,61"/>
<area shape="rect" href="namespaceSawyer_1_1Container_1_1Algorithm.html#af893c884305001ca91a0ef56a6c2f1b6" title="Find maximum common isomorphic subgraphs." alt="" coords="5,5,221,61"/>
</map>
</div>

</div>
</div>
<a id="afc7b7559f4401b61fe5e3514735dbc0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc7b7559f4401b61fe5e3514735dbc0f">&#9670;&nbsp;</a></span>monotonicallyIncreasing() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GraphA , class GraphB , class SolutionProcessor  = CsiShowSolution&lt;GraphA, GraphB&gt;, class EquivalenceP  = CsiEquivalence&lt;GraphA, GraphB&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html">Sawyer::Container::Algorithm::CommonSubgraphIsomorphism</a>&lt; GraphA, GraphB, SolutionProcessor, EquivalenceP &gt;::monotonicallyIncreasing </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: monotonically increasing solution size. </p>
<p>If true, then each solution reported to the solution processor will be at least as large as the previous solution. Setting this property will result in more efficient behavior than culling solutions in the solution processor because in the former situation the solver can eliminate branches of the search space. This property is useful when searching for the largest isomorphic subgraph. </p>

<p class="definition">Definition at line <a class="el" href="GraphAlgorithm_8h_source.html#l00672">672</a> of file <a class="el" href="GraphAlgorithm_8h_source.html">GraphAlgorithm.h</a>.</p>

</div>
</div>
<a id="abfe2af18d37f66365a12764777912f7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfe2af18d37f66365a12764777912f7a">&#9670;&nbsp;</a></span>solutionProcessor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GraphA , class GraphB , class SolutionProcessor  = CsiShowSolution&lt;GraphA, GraphB&gt;, class EquivalenceP  = CsiEquivalence&lt;GraphA, GraphB&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SolutionProcessor&amp; <a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html">Sawyer::Container::Algorithm::CommonSubgraphIsomorphism</a>&lt; GraphA, GraphB, SolutionProcessor, EquivalenceP &gt;::solutionProcessor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: reference to the solution callback. </p>
<p>Returns a reference to the callback that will process each solution. The callback can be changed at any time between construction of this analysis and the return from its <a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html#a795c5207d979a168d4f95814ce62f380">run</a> method. </p>

<p class="definition">Definition at line <a class="el" href="GraphAlgorithm_8h_source.html#l00681">681</a> of file <a class="el" href="GraphAlgorithm_8h_source.html">GraphAlgorithm.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="GraphAlgorithm_8h_source.html#l00966">Sawyer::Container::Algorithm::findCommonIsomorphicSubgraphs()</a>, <a class="el" href="GraphAlgorithm_8h_source.html#l01004">Sawyer::Container::Algorithm::findFirstCommonIsomorphicSubgraph()</a>, <a class="el" href="GraphAlgorithm_8h_source.html#l01043">Sawyer::Container::Algorithm::findIsomorphicSubgraphs()</a>, and <a class="el" href="GraphAlgorithm_8h_source.html#l01098">Sawyer::Container::Algorithm::findMaximumCommonIsomorphicSubgraphs()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism_abfe2af18d37f66365a12764777912f7a_icgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism_abfe2af18d37f66365a12764777912f7a_icgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism_abfe2af18d37f66365a12764777912f7a_icgraph" id="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism_abfe2af18d37f66365a12764777912f7a_icgraph">
<area shape="rect" title="Property: reference to the solution callback." alt="" coords="285,123,553,179"/>
<area shape="rect" href="namespaceSawyer_1_1Container_1_1Algorithm.html#a125e6d3b75c1f45be000702427b39a0f" title="Find common isomorphic subgraphs." alt="" coords="10,5,233,61"/>
<area shape="rect" href="namespaceSawyer_1_1Container_1_1Algorithm.html#a79f3b4db6da4e57a5a1d5ff7ff39b3f7" title="Determine whether a common subgraph exists." alt="" coords="29,85,214,141"/>
<area shape="rect" href="namespaceSawyer_1_1Container_1_1Algorithm.html#abdfddcc3c0de62ffb90d868264b20483" title="Find an isomorphic subgraph." alt="" coords="5,166,237,207"/>
<area shape="rect" href="namespaceSawyer_1_1Container_1_1Algorithm.html#af893c884305001ca91a0ef56a6c2f1b6" title="Find maximum common isomorphic subgraphs." alt="" coords="13,232,229,288"/>
</map>
</div>

</div>
</div>
<a id="a483ce902cc637883a4c65a7d637adc7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a483ce902cc637883a4c65a7d637adc7b">&#9670;&nbsp;</a></span>solutionProcessor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GraphA , class GraphB , class SolutionProcessor  = CsiShowSolution&lt;GraphA, GraphB&gt;, class EquivalenceP  = CsiEquivalence&lt;GraphA, GraphB&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const SolutionProcessor&amp; <a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html">Sawyer::Container::Algorithm::CommonSubgraphIsomorphism</a>&lt; GraphA, GraphB, SolutionProcessor, EquivalenceP &gt;::solutionProcessor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: reference to the solution callback. </p>
<p>Returns a reference to the callback that will process each solution. The callback can be changed at any time between construction of this analysis and the return from its <a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html#a795c5207d979a168d4f95814ce62f380">run</a> method. </p>

<p class="definition">Definition at line <a class="el" href="GraphAlgorithm_8h_source.html#l00682">682</a> of file <a class="el" href="GraphAlgorithm_8h_source.html">GraphAlgorithm.h</a>.</p>

</div>
</div>
<a id="a8e06bbbd7643c8dccecab3823d1992cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e06bbbd7643c8dccecab3823d1992cf">&#9670;&nbsp;</a></span>equivalencePredicate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GraphA , class GraphB , class SolutionProcessor  = CsiShowSolution&lt;GraphA, GraphB&gt;, class EquivalenceP  = CsiEquivalence&lt;GraphA, GraphB&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EquivalenceP&amp; <a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html">Sawyer::Container::Algorithm::CommonSubgraphIsomorphism</a>&lt; GraphA, GraphB, SolutionProcessor, EquivalenceP &gt;::equivalencePredicate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: reference to the vertex equivalence predicate. </p>
<p>Returns a reference to the predicate that determines whether a vertex from one graph can be isomorphic to a vertex of the other graph. Solutions will only contain pairs of vertices for which the predicate returns true.</p>
<p>Changing the predicate during the <a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html#a795c5207d979a168d4f95814ce62f380">run</a> method may or may not have the desired effect. This is because the return value from the predicate (at least it's <a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1CsiEquivalence.html#ab8f954ded387a67b3f434c4c9e513608">mu</a> method) is computed up front and cached. </p>

<p class="definition">Definition at line <a class="el" href="GraphAlgorithm_8h_source.html#l00694">694</a> of file <a class="el" href="GraphAlgorithm_8h_source.html">GraphAlgorithm.h</a>.</p>

</div>
</div>
<a id="a69e80165973320a2f2dda3acd174b331"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69e80165973320a2f2dda3acd174b331">&#9670;&nbsp;</a></span>equivalencePredicate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GraphA , class GraphB , class SolutionProcessor  = CsiShowSolution&lt;GraphA, GraphB&gt;, class EquivalenceP  = CsiEquivalence&lt;GraphA, GraphB&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const EquivalenceP&amp; <a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html">Sawyer::Container::Algorithm::CommonSubgraphIsomorphism</a>&lt; GraphA, GraphB, SolutionProcessor, EquivalenceP &gt;::equivalencePredicate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: reference to the vertex equivalence predicate. </p>
<p>Returns a reference to the predicate that determines whether a vertex from one graph can be isomorphic to a vertex of the other graph. Solutions will only contain pairs of vertices for which the predicate returns true.</p>
<p>Changing the predicate during the <a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html#a795c5207d979a168d4f95814ce62f380">run</a> method may or may not have the desired effect. This is because the return value from the predicate (at least it's <a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1CsiEquivalence.html#ab8f954ded387a67b3f434c4c9e513608">mu</a> method) is computed up front and cached. </p>

<p class="definition">Definition at line <a class="el" href="GraphAlgorithm_8h_source.html#l00695">695</a> of file <a class="el" href="GraphAlgorithm_8h_source.html">GraphAlgorithm.h</a>.</p>

</div>
</div>
<a id="a7670d6ffa227c87a23b17aa30ca0c495"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7670d6ffa227c87a23b17aa30ca0c495">&#9670;&nbsp;</a></span>findingCommonSubgraphs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GraphA , class GraphB , class SolutionProcessor  = CsiShowSolution&lt;GraphA, GraphB&gt;, class EquivalenceP  = CsiEquivalence&lt;GraphA, GraphB&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html">Sawyer::Container::Algorithm::CommonSubgraphIsomorphism</a>&lt; GraphA, GraphB, SolutionProcessor, EquivalenceP &gt;::findingCommonSubgraphs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: find common subgraphs. </p>
<p>This property controls whether the solver finds subgraphs of both specified graphs, or requires that the entire first graph is a subgraph of the second. When true (the default) the solver finds solutions to the "common subgraph
 isomorphism" problem; when false it finds solutions to the "subgraph isomorphism" problem.</p>
<p>When this property is false the <a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html#aaecdf4256eb655f03557ba236dcb9b40">minimumSolutionSize</a> is ignored; all solutions will be equal in size to the number of vertices in the first graph. </p>

<p class="definition">Definition at line <a class="el" href="GraphAlgorithm_8h_source.html#l00708">708</a> of file <a class="el" href="GraphAlgorithm_8h_source.html">GraphAlgorithm.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="GraphAlgorithm_8h_source.html#l01043">Sawyer::Container::Algorithm::findIsomorphicSubgraphs()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism_a7670d6ffa227c87a23b17aa30ca0c495_icgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism_a7670d6ffa227c87a23b17aa30ca0c495_icgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism_a7670d6ffa227c87a23b17aa30ca0c495_icgraph" id="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism_a7670d6ffa227c87a23b17aa30ca0c495_icgraph">
<area shape="rect" title="Property: find common subgraphs." alt="" coords="285,5,553,61"/>
<area shape="rect" href="namespaceSawyer_1_1Container_1_1Algorithm.html#abdfddcc3c0de62ffb90d868264b20483" title="Find an isomorphic subgraph." alt="" coords="5,13,237,54"/>
</map>
</div>

</div>
</div>
<a id="a111e8af69dc18cde3d6e0373a2535cc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a111e8af69dc18cde3d6e0373a2535cc3">&#9670;&nbsp;</a></span>findingCommonSubgraphs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GraphA , class GraphB , class SolutionProcessor  = CsiShowSolution&lt;GraphA, GraphB&gt;, class EquivalenceP  = CsiEquivalence&lt;GraphA, GraphB&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html">Sawyer::Container::Algorithm::CommonSubgraphIsomorphism</a>&lt; GraphA, GraphB, SolutionProcessor, EquivalenceP &gt;::findingCommonSubgraphs </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: find common subgraphs. </p>
<p>This property controls whether the solver finds subgraphs of both specified graphs, or requires that the entire first graph is a subgraph of the second. When true (the default) the solver finds solutions to the "common subgraph
 isomorphism" problem; when false it finds solutions to the "subgraph isomorphism" problem.</p>
<p>When this property is false the <a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html#aaecdf4256eb655f03557ba236dcb9b40">minimumSolutionSize</a> is ignored; all solutions will be equal in size to the number of vertices in the first graph. </p>

<p class="definition">Definition at line <a class="el" href="GraphAlgorithm_8h_source.html#l00709">709</a> of file <a class="el" href="GraphAlgorithm_8h_source.html">GraphAlgorithm.h</a>.</p>

</div>
</div>
<a id="a795c5207d979a168d4f95814ce62f380"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a795c5207d979a168d4f95814ce62f380">&#9670;&nbsp;</a></span>run()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GraphA , class GraphB , class SolutionProcessor  = CsiShowSolution&lt;GraphA, GraphB&gt;, class EquivalenceP  = CsiEquivalence&lt;GraphA, GraphB&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html">Sawyer::Container::Algorithm::CommonSubgraphIsomorphism</a>&lt; GraphA, GraphB, SolutionProcessor, EquivalenceP &gt;::run </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform the common subgraph isomorphism analysis. </p>
<p>Runs the common subgraph isomorphism analysis from beginning to end, invoking the constructor-supplied solution processor for each solution that's found to be large enough (see <a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html#aaecdf4256eb655f03557ba236dcb9b40">minimumSolutionSize</a>). The solutions are not detected in any particular order.</p>
<p>The graphs provided to the analysis constructor on which this analysis runs must not be modified between when the analysis is created and this method returns. Actually, it is permissible to modify the contents of the graphs, just not their connectivity. I.e., changing the values stored at vertices and edges is fine, but inserting or erasing vertices or edges is not.</p>
<p>The <a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html#a795c5207d979a168d4f95814ce62f380">run</a> method may be called multiple times and will always start from the beginning. If the solution processor determines that the analysis is not required to complete then it may throw an exception. The <a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html#aef213d856bdba10e04c210ff64cbdb68">reset</a> method can be called afterward to delete memory used by the analysis (memory usage is not large to begin with), although this is not necessary since the destructor does not leak memory. </p>

<p class="definition">Definition at line <a class="el" href="GraphAlgorithm_8h_source.html#l00727">727</a> of file <a class="el" href="GraphAlgorithm_8h_source.html">GraphAlgorithm.h</a>.</p>

<p class="reference">References <a class="el" href="GraphAlgorithm_8h_source.html#l00737">Sawyer::Container::Algorithm::CommonSubgraphIsomorphism&lt; GraphA, GraphB, SolutionProcessor, EquivalenceP &gt;::reset()</a>.</p>

<p class="reference">Referenced by <a class="el" href="GraphAlgorithm_8h_source.html#l00966">Sawyer::Container::Algorithm::findCommonIsomorphicSubgraphs()</a>, <a class="el" href="GraphAlgorithm_8h_source.html#l01004">Sawyer::Container::Algorithm::findFirstCommonIsomorphicSubgraph()</a>, <a class="el" href="GraphAlgorithm_8h_source.html#l01043">Sawyer::Container::Algorithm::findIsomorphicSubgraphs()</a>, and <a class="el" href="GraphAlgorithm_8h_source.html#l01098">Sawyer::Container::Algorithm::findMaximumCommonIsomorphicSubgraphs()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism_a795c5207d979a168d4f95814ce62f380_cgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism_a795c5207d979a168d4f95814ce62f380_cgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism_a795c5207d979a168d4f95814ce62f380_cgraph" id="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism_a795c5207d979a168d4f95814ce62f380_cgraph">
<area shape="rect" title="Perform the common subgraph isomorphism analysis." alt="" coords="5,13,300,54"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html#aef213d856bdba10e04c210ff64cbdb68" title="Releases memory used by the analysis." alt="" coords="348,5,616,61"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism_a795c5207d979a168d4f95814ce62f380_icgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism_a795c5207d979a168d4f95814ce62f380_icgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism_a795c5207d979a168d4f95814ce62f380_icgraph" id="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism_a795c5207d979a168d4f95814ce62f380_icgraph">
<area shape="rect" title="Perform the common subgraph isomorphism analysis." alt="" coords="285,130,580,171"/>
<area shape="rect" href="namespaceSawyer_1_1Container_1_1Algorithm.html#a125e6d3b75c1f45be000702427b39a0f" title="Find common isomorphic subgraphs." alt="" coords="10,5,233,61"/>
<area shape="rect" href="namespaceSawyer_1_1Container_1_1Algorithm.html#a79f3b4db6da4e57a5a1d5ff7ff39b3f7" title="Determine whether a common subgraph exists." alt="" coords="29,85,214,141"/>
<area shape="rect" href="namespaceSawyer_1_1Container_1_1Algorithm.html#abdfddcc3c0de62ffb90d868264b20483" title="Find an isomorphic subgraph." alt="" coords="5,166,237,207"/>
<area shape="rect" href="namespaceSawyer_1_1Container_1_1Algorithm.html#af893c884305001ca91a0ef56a6c2f1b6" title="Find maximum common isomorphic subgraphs." alt="" coords="13,232,229,288"/>
</map>
</div>

</div>
</div>
<a id="aef213d856bdba10e04c210ff64cbdb68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef213d856bdba10e04c210ff64cbdb68">&#9670;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GraphA , class GraphB , class SolutionProcessor  = CsiShowSolution&lt;GraphA, GraphB&gt;, class EquivalenceP  = CsiEquivalence&lt;GraphA, GraphB&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html">Sawyer::Container::Algorithm::CommonSubgraphIsomorphism</a>&lt; GraphA, GraphB, SolutionProcessor, EquivalenceP &gt;::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Releases memory used by the analysis. </p>
<p>Releases memory that's used by the analysis, returning the analysis to its just-constructed state. This method is called implicitly at the beginning of each <a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html#a795c5207d979a168d4f95814ce62f380">run</a>. </p>

<p class="definition">Definition at line <a class="el" href="GraphAlgorithm_8h_source.html#l00737">737</a> of file <a class="el" href="GraphAlgorithm_8h_source.html">GraphAlgorithm.h</a>.</p>

<p class="reference">References <a class="el" href="DenseIntegerSet_8h_source.html#l00392">Sawyer::Container::DenseIntegerSet&lt; T &gt;::insertAll()</a>.</p>

<p class="reference">Referenced by <a class="el" href="GraphAlgorithm_8h_source.html#l00727">Sawyer::Container::Algorithm::CommonSubgraphIsomorphism&lt; GraphA, GraphB, SolutionProcessor, EquivalenceP &gt;::run()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism_aef213d856bdba10e04c210ff64cbdb68_cgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism_aef213d856bdba10e04c210ff64cbdb68_cgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism_aef213d856bdba10e04c210ff64cbdb68_cgraph" id="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism_aef213d856bdba10e04c210ff64cbdb68_cgraph">
<area shape="rect" title="Releases memory used by the analysis." alt="" coords="5,5,273,61"/>
<area shape="rect" href="classSawyer_1_1Container_1_1DenseIntegerSet.html#aa11430b2abc2573325cae2583127e4ed" title="Insert all possible members." alt="" coords="321,13,496,54"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism_aef213d856bdba10e04c210ff64cbdb68_icgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism_aef213d856bdba10e04c210ff64cbdb68_icgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism_aef213d856bdba10e04c210ff64cbdb68_icgraph" id="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism_aef213d856bdba10e04c210ff64cbdb68_icgraph">
<area shape="rect" title="Releases memory used by the analysis." alt="" coords="348,5,616,61"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Algorithm_1_1CommonSubgraphIsomorphism.html#a795c5207d979a168d4f95814ce62f380" title="Perform the common subgraph isomorphism analysis." alt="" coords="5,13,300,54"/>
</map>
</div>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="GraphAlgorithm_8h_source.html">GraphAlgorithm.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Dec 8 2022 21:18:53 for ROSE by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
