<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROSE: Sawyer::Lexer::TokenStream&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="ROSE"/>
<link href="roseDoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ROSE
   &#160;<span id="projectnumber">0.11.96.11</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,true,'search.html','Search');
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceSawyer.html">Sawyer</a></li><li class="navelem"><b>Lexer</b></li><li class="navelem"><a class="el" href="classSawyer_1_1Lexer_1_1TokenStream.html">TokenStream</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classSawyer_1_1Lexer_1_1TokenStream-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Sawyer::Lexer::TokenStream&lt; T &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><h3>template&lt;class T&gt;<br />
class Sawyer::Lexer::TokenStream&lt; T &gt;</h3>

<p>An ordered list of tokens scanned from input. </p>
<p>A token stream is an ordered list of tokens scanned from an unchanging input stream and consumed in the order they're produced. </p>

<p class="definition">Definition at line <a class="el" href="Lexer_8h_source.html#l00091">91</a> of file <a class="el" href="Lexer_8h_source.html">Lexer.h</a>.</p>
</div>
<p><code>#include &lt;<a class="el" href="Lexer_8h_source.html">Lexer.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Sawyer::Lexer::TokenStream&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Lexer_1_1TokenStream__inherit__graph.png" border="0" usemap="#Sawyer_1_1Lexer_1_1TokenStream_3_01T_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="Sawyer_1_1Lexer_1_1TokenStream_3_01T_01_4_inherit__map" id="Sawyer_1_1Lexer_1_1TokenStream_3_01T_01_4_inherit__map">
<area shape="rect" title="An ordered list of tokens scanned from input." alt="" coords="5,5,228,32"/>
<area shape="rect" href="classSawyer_1_1Lexer_1_1TokenStream.html" title=" " alt="" coords="21,95,212,136"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ab18afceb65d918f43c2606a123526b9f"><td class="memItemLeft" align="right" valign="top"><a id="ab18afceb65d918f43c2606a123526b9f"></a>
typedef T&#160;</td><td class="memItemRight" valign="bottom"><b>Token</b></td></tr>
<tr class="separator:ab18afceb65d918f43c2606a123526b9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa798b9cb574a60d131ed406e44d6bd9d"><td class="memItemLeft" align="right" valign="top"><a id="aa798b9cb574a60d131ed406e44d6bd9d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Lexer_1_1TokenStream.html#aa798b9cb574a60d131ed406e44d6bd9d">TokenStream</a> (const boost::filesystem::path &amp;fileName)</td></tr>
<tr class="memdesc:aa798b9cb574a60d131ed406e44d6bd9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a token stream from the contents of a file. <br /></td></tr>
<tr class="separator:aa798b9cb574a60d131ed406e44d6bd9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc7f666c34441c4b079e7e9d1c70f446"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Lexer_1_1TokenStream.html#afc7f666c34441c4b079e7e9d1c70f446">TokenStream</a> (const std::string &amp;inputString)</td></tr>
<tr class="memdesc:afc7f666c34441c4b079e7e9d1c70f446"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a token stream from a string.  <a href="classSawyer_1_1Lexer_1_1TokenStream.html#afc7f666c34441c4b079e7e9d1c70f446">More...</a><br /></td></tr>
<tr class="separator:afc7f666c34441c4b079e7e9d1c70f446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a568d69279d3a3882bb0586e1d2ef4334"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Lexer_1_1TokenStream.html#a568d69279d3a3882bb0586e1d2ef4334">TokenStream</a> (const <a class="el" href="classSawyer_1_1Container_1_1Buffer.html">Container::Buffer</a>&lt; size_t, char &gt;::Ptr &amp;buffer)</td></tr>
<tr class="memdesc:a568d69279d3a3882bb0586e1d2ef4334"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a token stream from a buffer.  <a href="classSawyer_1_1Lexer_1_1TokenStream.html#a568d69279d3a3882bb0586e1d2ef4334">More...</a><br /></td></tr>
<tr class="separator:a568d69279d3a3882bb0586e1d2ef4334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3af1b6e904ff8e7e307d05059757ca3"><td class="memItemLeft" align="right" valign="top"><a id="aa3af1b6e904ff8e7e307d05059757ca3"></a>
const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Lexer_1_1TokenStream.html#aa3af1b6e904ff8e7e307d05059757ca3">name</a> () const</td></tr>
<tr class="memdesc:aa3af1b6e904ff8e7e307d05059757ca3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Name of stream. <br /></td></tr>
<tr class="separator:aa3af1b6e904ff8e7e307d05059757ca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96bb680fafb0b2288acc4719fdd90417"><td class="memItemLeft" align="right" valign="top">const Token &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Lexer_1_1TokenStream.html#a96bb680fafb0b2288acc4719fdd90417">current</a> ()</td></tr>
<tr class="memdesc:a96bb680fafb0b2288acc4719fdd90417"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current token.  <a href="classSawyer_1_1Lexer_1_1TokenStream.html#a96bb680fafb0b2288acc4719fdd90417">More...</a><br /></td></tr>
<tr class="separator:a96bb680fafb0b2288acc4719fdd90417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5f63eba9aea813140f0c6bf3f43a832"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Lexer_1_1TokenStream.html#ab5f63eba9aea813140f0c6bf3f43a832">atEof</a> ()</td></tr>
<tr class="memdesc:ab5f63eba9aea813140f0c6bf3f43a832"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the stream is at the end.  <a href="classSawyer_1_1Lexer_1_1TokenStream.html#ab5f63eba9aea813140f0c6bf3f43a832">More...</a><br /></td></tr>
<tr class="separator:ab5f63eba9aea813140f0c6bf3f43a832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14e4e1cfbd3896ad9f88b39d2dc1afa9"><td class="memItemLeft" align="right" valign="top">const Token &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Lexer_1_1TokenStream.html#a14e4e1cfbd3896ad9f88b39d2dc1afa9">operator[]</a> (size_t lookahead)</td></tr>
<tr class="memdesc:a14e4e1cfbd3896ad9f88b39d2dc1afa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current or future token.  <a href="classSawyer_1_1Lexer_1_1TokenStream.html#a14e4e1cfbd3896ad9f88b39d2dc1afa9">More...</a><br /></td></tr>
<tr class="separator:a14e4e1cfbd3896ad9f88b39d2dc1afa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53ffee9a74369fedfddb1cee53e9e011"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Lexer_1_1TokenStream.html#a53ffee9a74369fedfddb1cee53e9e011">consume</a> (size_t n=1)</td></tr>
<tr class="memdesc:a53ffee9a74369fedfddb1cee53e9e011"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consume some tokens.  <a href="classSawyer_1_1Lexer_1_1TokenStream.html#a53ffee9a74369fedfddb1cee53e9e011">More...</a><br /></td></tr>
<tr class="separator:a53ffee9a74369fedfddb1cee53e9e011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a385020f92b67e3cd0600bdbd6601f550"><td class="memItemLeft" align="right" valign="top">std::pair&lt; size_t, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Lexer_1_1TokenStream.html#a385020f92b67e3cd0600bdbd6601f550">location</a> (size_t position)</td></tr>
<tr class="memdesc:a385020f92b67e3cd0600bdbd6601f550"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the line number and offset for an input position.  <a href="classSawyer_1_1Lexer_1_1TokenStream.html#a385020f92b67e3cd0600bdbd6601f550">More...</a><br /></td></tr>
<tr class="separator:a385020f92b67e3cd0600bdbd6601f550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a448b48c324c1155d3a5b7593f25cb894"><td class="memItemLeft" align="right" valign="top"><a id="a448b48c324c1155d3a5b7593f25cb894"></a>
std::pair&lt; size_t, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Lexer_1_1TokenStream.html#a448b48c324c1155d3a5b7593f25cb894">locationEof</a> ()</td></tr>
<tr class="memdesc:a448b48c324c1155d3a5b7593f25cb894"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last line index and character offset. <br /></td></tr>
<tr class="separator:a448b48c324c1155d3a5b7593f25cb894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a833b3d1350ccae1124812ed3a0dcc25a"><td class="memItemLeft" align="right" valign="top"><a id="a833b3d1350ccae1124812ed3a0dcc25a"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Lexer_1_1TokenStream.html#a833b3d1350ccae1124812ed3a0dcc25a">lineString</a> (size_t lineIdx)</td></tr>
<tr class="memdesc:a833b3d1350ccae1124812ed3a0dcc25a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the entire string for some line index. <br /></td></tr>
<tr class="separator:a833b3d1350ccae1124812ed3a0dcc25a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87702d46832f2f819eddcd5e03e4aedf"><td class="memItemLeft" align="right" valign="top">virtual Token&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Lexer_1_1TokenStream.html#a87702d46832f2f819eddcd5e03e4aedf">scanNextToken</a> (const <a class="el" href="classSawyer_1_1Container_1_1LineVector.html">Container::LineVector</a> &amp;content, size_t &amp;at)=0</td></tr>
<tr class="memdesc:a87702d46832f2f819eddcd5e03e4aedf"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classFunction.html">Function</a> that obtains the next token.  <a href="classSawyer_1_1Lexer_1_1TokenStream.html#a87702d46832f2f819eddcd5e03e4aedf">More...</a><br /></td></tr>
<tr class="separator:a87702d46832f2f819eddcd5e03e4aedf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a5c0af0563a967feaa81a4b6c5f8dcd97"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Lexer_1_1TokenStream.html#a5c0af0563a967feaa81a4b6c5f8dcd97">lexeme</a> (const Token &amp;t)</td></tr>
<tr class="memdesc:a5c0af0563a967feaa81a4b6c5f8dcd97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the lexeme for a token.  <a href="classSawyer_1_1Lexer_1_1TokenStream.html#a5c0af0563a967feaa81a4b6c5f8dcd97">More...</a><br /></td></tr>
<tr class="separator:a5c0af0563a967feaa81a4b6c5f8dcd97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24776a70d85d078376bb8f7196ad7100"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Lexer_1_1TokenStream.html#a24776a70d85d078376bb8f7196ad7100">lexeme</a> ()</td></tr>
<tr class="memdesc:a24776a70d85d078376bb8f7196ad7100"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the lexeme for a token.  <a href="classSawyer_1_1Lexer_1_1TokenStream.html#a24776a70d85d078376bb8f7196ad7100">More...</a><br /></td></tr>
<tr class="separator:a24776a70d85d078376bb8f7196ad7100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:affd7e3e57ddbb56816adf6a198615d4e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Lexer_1_1TokenStream.html#affd7e3e57ddbb56816adf6a198615d4e">isa</a> (const Token &amp;t, typename Token::TokenEnum type)</td></tr>
<tr class="memdesc:affd7e3e57ddbb56816adf6a198615d4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether token is a specific type.  <a href="classSawyer_1_1Lexer_1_1TokenStream.html#affd7e3e57ddbb56816adf6a198615d4e">More...</a><br /></td></tr>
<tr class="separator:affd7e3e57ddbb56816adf6a198615d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a239c0ed680c8f21fada507804e89f23f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Lexer_1_1TokenStream.html#a239c0ed680c8f21fada507804e89f23f">isa</a> (typename Token::TokenEnum type)</td></tr>
<tr class="memdesc:a239c0ed680c8f21fada507804e89f23f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether token is a specific type.  <a href="classSawyer_1_1Lexer_1_1TokenStream.html#a239c0ed680c8f21fada507804e89f23f">More...</a><br /></td></tr>
<tr class="separator:a239c0ed680c8f21fada507804e89f23f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a5130a5cc5f04f81c2b190585beec6112"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Lexer_1_1TokenStream.html#a5130a5cc5f04f81c2b190585beec6112">match</a> (const Token &amp;t, const char *s)</td></tr>
<tr class="memdesc:a5130a5cc5f04f81c2b190585beec6112"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether a token matches a string.  <a href="classSawyer_1_1Lexer_1_1TokenStream.html#a5130a5cc5f04f81c2b190585beec6112">More...</a><br /></td></tr>
<tr class="separator:a5130a5cc5f04f81c2b190585beec6112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fac6bb5c4151f245161a884b085e185"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Lexer_1_1TokenStream.html#a4fac6bb5c4151f245161a884b085e185">match</a> (const char *s)</td></tr>
<tr class="memdesc:a4fac6bb5c4151f245161a884b085e185"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether a token matches a string.  <a href="classSawyer_1_1Lexer_1_1TokenStream.html#a4fac6bb5c4151f245161a884b085e185">More...</a><br /></td></tr>
<tr class="separator:a4fac6bb5c4151f245161a884b085e185"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="afc7f666c34441c4b079e7e9d1c70f446"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc7f666c34441c4b079e7e9d1c70f446">&#9670;&nbsp;</a></span>TokenStream() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Lexer_1_1TokenStream.html">Sawyer::Lexer::TokenStream</a>&lt; T &gt;::<a class="el" href="classSawyer_1_1Lexer_1_1TokenStream.html">TokenStream</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>inputString</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a token stream from a string. </p>
<p>The string content is copied into the lexer and thus can be modified after the lexer returns without affecting the token stream. </p>

<p class="definition">Definition at line <a class="el" href="Lexer_8h_source.html#l00112">112</a> of file <a class="el" href="Lexer_8h_source.html">Lexer.h</a>.</p>

</div>
</div>
<a id="a568d69279d3a3882bb0586e1d2ef4334"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a568d69279d3a3882bb0586e1d2ef4334">&#9670;&nbsp;</a></span>TokenStream() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Lexer_1_1TokenStream.html">Sawyer::Lexer::TokenStream</a>&lt; T &gt;::<a class="el" href="classSawyer_1_1Lexer_1_1TokenStream.html">TokenStream</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Buffer.html">Container::Buffer</a>&lt; size_t, char &gt;::Ptr &amp;&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a token stream from a buffer. </p>
<p>The token stream uses the specified buffer, which should not be modified while the token stream is alive. </p>

<p class="definition">Definition at line <a class="el" href="Lexer_8h_source.html#l00118">118</a> of file <a class="el" href="Lexer_8h_source.html">Lexer.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a96bb680fafb0b2288acc4719fdd90417"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96bb680fafb0b2288acc4719fdd90417">&#9670;&nbsp;</a></span>current()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Token&amp; <a class="el" href="classSawyer_1_1Lexer_1_1TokenStream.html">Sawyer::Lexer::TokenStream</a>&lt; T &gt;::current </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the current token. </p>
<p>The current token will be an EOF token when all tokens are consumed. </p>

<p class="definition">Definition at line <a class="el" href="Lexer_8h_source.html#l00129">129</a> of file <a class="el" href="Lexer_8h_source.html">Lexer.h</a>.</p>

</div>
</div>
<a id="ab5f63eba9aea813140f0c6bf3f43a832"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5f63eba9aea813140f0c6bf3f43a832">&#9670;&nbsp;</a></span>atEof()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSawyer_1_1Lexer_1_1TokenStream.html">Sawyer::Lexer::TokenStream</a>&lt; T &gt;::atEof </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the stream is at the end. </p>
<p>This is equivalent to obtaining the current toking and checking whether it's the EOF token. </p>

<p class="definition">Definition at line <a class="el" href="Lexer_8h_source.html#l00136">136</a> of file <a class="el" href="Lexer_8h_source.html">Lexer.h</a>.</p>

</div>
</div>
<a id="a14e4e1cfbd3896ad9f88b39d2dc1afa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14e4e1cfbd3896ad9f88b39d2dc1afa9">&#9670;&nbsp;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Token&amp; <a class="el" href="classSawyer_1_1Lexer_1_1TokenStream.html">Sawyer::Lexer::TokenStream</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>lookahead</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the current or future token. </p>
<p>The array operator obtains a token from a virtual array whose first element is the current token, second element is one past the current token, etc. The array is infinite in length, padded with EOF tokens. </p>

<p class="definition">Definition at line <a class="el" href="Lexer_8h_source.html#l00144">144</a> of file <a class="el" href="Lexer_8h_source.html">Lexer.h</a>.</p>

</div>
</div>
<a id="a53ffee9a74369fedfddb1cee53e9e011"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53ffee9a74369fedfddb1cee53e9e011">&#9670;&nbsp;</a></span>consume()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSawyer_1_1Lexer_1_1TokenStream.html">Sawyer::Lexer::TokenStream</a>&lt; T &gt;::consume </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Consume some tokens. </p>
<p>Consumes tokens by shifting <code>n</code> tokens off the low-end of the virtual array of tokens. It is permissible to consume EOF tokens since more will be generated once the end-of-input is reached. </p>

<p class="definition">Definition at line <a class="el" href="Lexer_8h_source.html#l00158">158</a> of file <a class="el" href="Lexer_8h_source.html">Lexer.h</a>.</p>

</div>
</div>
<a id="a5c0af0563a967feaa81a4b6c5f8dcd97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c0af0563a967feaa81a4b6c5f8dcd97">&#9670;&nbsp;</a></span>lexeme() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classSawyer_1_1Lexer_1_1TokenStream.html">Sawyer::Lexer::TokenStream</a>&lt; T &gt;::lexeme </td>
          <td>(</td>
          <td class="paramtype">const Token &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the lexeme for a token. </p>
<p>Consults the input stream to obtain the lexeme for the specified token and converts that part of the stream to a string which is returned. The lexeme for an EOF token is an empty string, although other tokens might also have empty lexemes. One may query the lexeme for any token regardless of whether it's been consumed; in fact, one can even query lexemes for tokens that have never even been seen by the token stream.</p>
<p>The no-argument version returns the lexeme of the current token.</p>
<p>If you're trying to build a fast lexical analyzer, don't call this function to compare a lexeme against some known string. Instead, use <a class="el" href="classSawyer_1_1Lexer_1_1TokenStream.html#a5130a5cc5f04f81c2b190585beec6112">match</a>, which doesn't require copying. </p>

<p class="definition">Definition at line <a class="el" href="Lexer_8h_source.html#l00182">182</a> of file <a class="el" href="Lexer_8h_source.html">Lexer.h</a>.</p>

</div>
</div>
<a id="a24776a70d85d078376bb8f7196ad7100"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24776a70d85d078376bb8f7196ad7100">&#9670;&nbsp;</a></span>lexeme() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classSawyer_1_1Lexer_1_1TokenStream.html">Sawyer::Lexer::TokenStream</a>&lt; T &gt;::lexeme </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the lexeme for a token. </p>
<p>Consults the input stream to obtain the lexeme for the specified token and converts that part of the stream to a string which is returned. The lexeme for an EOF token is an empty string, although other tokens might also have empty lexemes. One may query the lexeme for any token regardless of whether it's been consumed; in fact, one can even query lexemes for tokens that have never even been seen by the token stream.</p>
<p>The no-argument version returns the lexeme of the current token.</p>
<p>If you're trying to build a fast lexical analyzer, don't call this function to compare a lexeme against some known string. Instead, use <a class="el" href="classSawyer_1_1Lexer_1_1TokenStream.html#a5130a5cc5f04f81c2b190585beec6112">match</a>, which doesn't require copying. </p>

<p class="definition">Definition at line <a class="el" href="Lexer_8h_source.html#l00189">189</a> of file <a class="el" href="Lexer_8h_source.html">Lexer.h</a>.</p>

</div>
</div>
<a id="affd7e3e57ddbb56816adf6a198615d4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affd7e3e57ddbb56816adf6a198615d4e">&#9670;&nbsp;</a></span>isa() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSawyer_1_1Lexer_1_1TokenStream.html">Sawyer::Lexer::TokenStream</a>&lt; T &gt;::isa </td>
          <td>(</td>
          <td class="paramtype">const Token &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Token::TokenEnum&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine whether token is a specific type. </p>
<p>This is sometimes easier to call since it gracefully handles EOF tokens. If called with only one argument, the desired type, then it checks the current token. </p>

<p class="definition">Definition at line <a class="el" href="Lexer_8h_source.html#l00200">200</a> of file <a class="el" href="Lexer_8h_source.html">Lexer.h</a>.</p>

</div>
</div>
<a id="a239c0ed680c8f21fada507804e89f23f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a239c0ed680c8f21fada507804e89f23f">&#9670;&nbsp;</a></span>isa() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSawyer_1_1Lexer_1_1TokenStream.html">Sawyer::Lexer::TokenStream</a>&lt; T &gt;::isa </td>
          <td>(</td>
          <td class="paramtype">typename Token::TokenEnum&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine whether token is a specific type. </p>
<p>This is sometimes easier to call since it gracefully handles EOF tokens. If called with only one argument, the desired type, then it checks the current token. </p>

<p class="definition">Definition at line <a class="el" href="Lexer_8h_source.html#l00204">204</a> of file <a class="el" href="Lexer_8h_source.html">Lexer.h</a>.</p>

</div>
</div>
<a id="a5130a5cc5f04f81c2b190585beec6112"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5130a5cc5f04f81c2b190585beec6112">&#9670;&nbsp;</a></span>match() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSawyer_1_1Lexer_1_1TokenStream.html">Sawyer::Lexer::TokenStream</a>&lt; T &gt;::match </td>
          <td>(</td>
          <td class="paramtype">const Token &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine whether a token matches a string. </p>
<p>Compares the specified string to a token's lexeme and returns true if they are the same. This is faster than obtaining the lexeme from a token and comparing to a string since there's no string copying involved with this function.</p>
<p>The no-argument version compares the string with the current tokens' lexeme. </p>

<p class="definition">Definition at line <a class="el" href="Lexer_8h_source.html#l00217">217</a> of file <a class="el" href="Lexer_8h_source.html">Lexer.h</a>.</p>

</div>
</div>
<a id="a4fac6bb5c4151f245161a884b085e185"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fac6bb5c4151f245161a884b085e185">&#9670;&nbsp;</a></span>match() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSawyer_1_1Lexer_1_1TokenStream.html">Sawyer::Lexer::TokenStream</a>&lt; T &gt;::match </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine whether a token matches a string. </p>
<p>Compares the specified string to a token's lexeme and returns true if they are the same. This is faster than obtaining the lexeme from a token and comparing to a string since there's no string copying involved with this function.</p>
<p>The no-argument version compares the string with the current tokens' lexeme. </p>

<p class="definition">Definition at line <a class="el" href="Lexer_8h_source.html#l00226">226</a> of file <a class="el" href="Lexer_8h_source.html">Lexer.h</a>.</p>

</div>
</div>
<a id="a385020f92b67e3cd0600bdbd6601f550"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a385020f92b67e3cd0600bdbd6601f550">&#9670;&nbsp;</a></span>location()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;size_t, size_t&gt; <a class="el" href="classSawyer_1_1Lexer_1_1TokenStream.html">Sawyer::Lexer::TokenStream</a>&lt; T &gt;::location </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the line number and offset for an input position. </p>
<p>Returns the zero-origin line number (a.k.a., line index) for the line containing the specified character position, and the offset of that character with respect to the beginning of the line. </p>

<p class="definition">Definition at line <a class="el" href="Lexer_8h_source.html#l00235">235</a> of file <a class="el" href="Lexer_8h_source.html">Lexer.h</a>.</p>

</div>
</div>
<a id="a87702d46832f2f819eddcd5e03e4aedf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87702d46832f2f819eddcd5e03e4aedf">&#9670;&nbsp;</a></span>scanNextToken()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Token <a class="el" href="classSawyer_1_1Lexer_1_1TokenStream.html">Sawyer::Lexer::TokenStream</a>&lt; T &gt;::scanNextToken </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1LineVector.html">Container::LineVector</a> &amp;&#160;</td>
          <td class="paramname"><em>content</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>at</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classFunction.html">Function</a> that obtains the next token. </p>
<p>Subclasses implement this function to obtain the next token that starts at or after the specified input position. Upon return, the function should adjust <code>at</code> to point to the next position for scanning a token, which is usually the first character after the returned token's lexeme. If the scanner reaches the end of input or any condition that it deems to be the end then it should return the EOF token (a default-constructed token), after which this function will not be called again. </p>

<p>Implemented in <a class="el" href="classSawyer_1_1Document_1_1Markup_1_1TokenStream.html#a123bc366b59769245e57e3d4be0ed1fb">Sawyer::Document::Markup::TokenStream</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="Lexer_8h_source.html">Lexer.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Dec 19 2022 23:40:28 for ROSE by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
