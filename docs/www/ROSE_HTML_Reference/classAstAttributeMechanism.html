<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROSE: AstAttributeMechanism Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="ROSE"/>
<link href="roseDoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ROSE
   &#160;<span id="projectnumber">0.11.96.11</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,true,'search.html','Search');
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classAstAttributeMechanism-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">AstAttributeMechanism Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>Stores named attributes in Sage IR nodes. </p>
<p>This attribute container stores one non-null, heap-allocated attribute per user-specified name. All values are derived from <a class="el" href="classAstAttribute.html">AstAttribute</a>. Any object can have an attribute container data member. For example, each AST node (<a class="el" href="classSgNode.html">SgNode</a>) contains one attribute container named <a class="el" href="classSgNode.html#a736c6ac907dee11bf631d5e059642ad0">SgNode::get_attributeMechanism</a>.</p>
<p>The value class's <a class="el" href="classAstAttribute.html#a9b2ca3a6f23e3408adfed7f3856e5d21">getOwnershipPolicy</a> method indicates whether the container owns the heap-allocated attribute and therefore whether the container is responsible for invoking <code>delete</code> on the attribute when the container is destroyed. New attribute subclasses should use the <a class="el" href="classAstAttribute.html#ab82a227fa3befab83ec49a8bc64d8884aee6f0ddaa9ca9fe05aabf769e617d959">AstAttribute::CONTAINER_OWNERSHIP</a> policy if possible.</p>
<p>IR node attribute values are always on the heap. Whenever an attribute container is copied, the container invokes the <a class="el" href="classAstAttribute.html#afde475da251d23d4b873550fce74881a">copy</a> method on all its attributes. The attributes' <code>copy</code> should either allocate a new copy of the attribute or return a null pointer. Since these values must be derived from <a class="el" href="classAstAttribute.html">AstAttribute</a>, it is not possible to directly store values whose type the user cannot modify to inherit from <a class="el" href="classAstAttribute.html">AstAttribute</a>. This includes POD types and classes defined in 3rd party libraries (e.g., <code>std::vector</code>). To store such values, the user must wrap them in another class that does inherit from <a class="el" href="classAstAttribute.html">AstAttribute</a> and which implements the necessary virtual functions.</p>
<p>The names of attributes are strings and the container does not check whether the string supplied to various container methods is spelled correctly. Using a misspelled attribute name is the same as using a different value name&ndash;in effect, operating on a completely different, unintended attribute.</p>
<p>The <a class="el" href="classAstAttributeMechanism.html">AstAttributeMechanism</a> is used by AST nodes (<a class="el" href="classSgNode.html">SgNode</a>) and is available via <a class="el" href="classSgNode.html#a736c6ac907dee11bf631d5e059642ad0">SgNode::get_attributeMechanism</a>, although that is not the preferred API. Instead, <a class="el" href="classSgNode.html">SgNode</a> provides an additional methods that contain "attribute" as part of their name. These "attribute" methods are mostly just wrappers around <a class="el" href="classSgNode.html#a736c6ac907dee11bf631d5e059642ad0">SgNode::get_attributeMechanism</a>.</p>
<p>Users can also use <a class="el" href="classAstAttributeMechanism.html">AstAttributeMechanism</a> as a data member in their own classes. However, <a class="el" href="namespaceSawyer_1_1Attribute.html">Sawyer::Attribute</a> is another choice: not only does it serve as the implementation for <a class="el" href="classAstAttributeMechanism.html">AstAttributeMechanism</a>, but it also supports checked attribute names and attributes that are values rather than pointers, including POD, 3rd-party types, and shared-ownership pointers. The amount of boilerplate that needs to be written in order to store a <a class="el" href="namespaceSawyer_1_1Attribute.html">Sawyer::Attribute</a> is much less than that required to store an attribute with <a class="el" href="classAstAttributeMechanism.html">AstAttributeMechanism</a>.</p>
<p>For additional information, including examples, see <a class="el" href="group__attributes.html">Working with attributes</a>. </p>

<p class="definition">Definition at line <a class="el" href="AstAttributeMechanism_8h_source.html#l00248">248</a> of file <a class="el" href="AstAttributeMechanism_8h_source.html">AstAttributeMechanism.h</a>.</p>
</div>
<p><code>#include &lt;<a class="el" href="AstAttributeMechanism_8h_source.html">midend/astProcessing/AstAttributeMechanism.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:afc3ea302f3a2459d08542643ea8b8d4e"><td class="memItemLeft" align="right" valign="top"><a id="afc3ea302f3a2459d08542643ea8b8d4e"></a>
typedef std::set&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAstAttributeMechanism.html#afc3ea302f3a2459d08542643ea8b8d4e">AttributeIdentifiers</a></td></tr>
<tr class="memdesc:afc3ea302f3a2459d08542643ea8b8d4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set of attribute names. <br /></td></tr>
<tr class="separator:afc3ea302f3a2459d08542643ea8b8d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:adb50adf1e225c3c2d578016ee51aa971"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAstAttributeMechanism.html#adb50adf1e225c3c2d578016ee51aa971">AstAttributeMechanism</a> ()</td></tr>
<tr class="memdesc:adb50adf1e225c3c2d578016ee51aa971"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="classAstAttributeMechanism.html#adb50adf1e225c3c2d578016ee51aa971">More...</a><br /></td></tr>
<tr class="separator:adb50adf1e225c3c2d578016ee51aa971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8f08d6ad7caa0bab276bb4ae019690a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAstAttributeMechanism.html#af8f08d6ad7caa0bab276bb4ae019690a">AstAttributeMechanism</a> (const <a class="el" href="classAstAttributeMechanism.html">AstAttributeMechanism</a> &amp;other)</td></tr>
<tr class="memdesc:af8f08d6ad7caa0bab276bb4ae019690a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="classAstAttributeMechanism.html#af8f08d6ad7caa0bab276bb4ae019690a">More...</a><br /></td></tr>
<tr class="separator:af8f08d6ad7caa0bab276bb4ae019690a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af96a11722f70380b6e60ff90698ff96e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAstAttributeMechanism.html">AstAttributeMechanism</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAstAttributeMechanism.html#af96a11722f70380b6e60ff90698ff96e">operator=</a> (const <a class="el" href="classAstAttributeMechanism.html">AstAttributeMechanism</a> &amp;other)</td></tr>
<tr class="memdesc:af96a11722f70380b6e60ff90698ff96e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <a href="classAstAttributeMechanism.html#af96a11722f70380b6e60ff90698ff96e">More...</a><br /></td></tr>
<tr class="separator:af96a11722f70380b6e60ff90698ff96e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b2def7aebda7ad58737e45da277e0b9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAstAttributeMechanism.html#a5b2def7aebda7ad58737e45da277e0b9">~AstAttributeMechanism</a> ()</td></tr>
<tr class="memdesc:a5b2def7aebda7ad58737e45da277e0b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="classAstAttributeMechanism.html#a5b2def7aebda7ad58737e45da277e0b9">More...</a><br /></td></tr>
<tr class="separator:a5b2def7aebda7ad58737e45da277e0b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13d19c3cdaee50e3835513ddbca151b1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAstAttributeMechanism.html#a13d19c3cdaee50e3835513ddbca151b1">exists</a> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:a13d19c3cdaee50e3835513ddbca151b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test for attribute existence.  <a href="classAstAttributeMechanism.html#a13d19c3cdaee50e3835513ddbca151b1">More...</a><br /></td></tr>
<tr class="separator:a13d19c3cdaee50e3835513ddbca151b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0b9f68ebcc439391debab91740762c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAstAttributeMechanism.html#aa0b9f68ebcc439391debab91740762c9">set</a> (const std::string &amp;name, <a class="el" href="classAstAttribute.html">AstAttribute</a> *value)</td></tr>
<tr class="memdesc:aa0b9f68ebcc439391debab91740762c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an attribute.  <a href="classAstAttributeMechanism.html#aa0b9f68ebcc439391debab91740762c9">More...</a><br /></td></tr>
<tr class="separator:aa0b9f68ebcc439391debab91740762c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50ed79b10c3d7f8a5792374a352c9769"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAstAttributeMechanism.html#a50ed79b10c3d7f8a5792374a352c9769">add</a> (const std::string &amp;name, <a class="el" href="classAstAttribute.html">AstAttribute</a> *value)</td></tr>
<tr class="memdesc:a50ed79b10c3d7f8a5792374a352c9769"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a new value if the attribute doesn't already exist.  <a href="classAstAttributeMechanism.html#a50ed79b10c3d7f8a5792374a352c9769">More...</a><br /></td></tr>
<tr class="separator:a50ed79b10c3d7f8a5792374a352c9769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a138f1f1378f4bc65175fc746229c7364"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAstAttributeMechanism.html#a138f1f1378f4bc65175fc746229c7364">replace</a> (const std::string &amp;name, <a class="el" href="classAstAttribute.html">AstAttribute</a> *value)</td></tr>
<tr class="memdesc:a138f1f1378f4bc65175fc746229c7364"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a new value if the attribute already exists.  <a href="classAstAttributeMechanism.html#a138f1f1378f4bc65175fc746229c7364">More...</a><br /></td></tr>
<tr class="separator:a138f1f1378f4bc65175fc746229c7364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42ac8b3e9d038a0e97549d51abaab4f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAstAttribute.html">AstAttribute</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAstAttributeMechanism.html#a42ac8b3e9d038a0e97549d51abaab4f7">operator[]</a> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:a42ac8b3e9d038a0e97549d51abaab4f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an attribute value.  <a href="classAstAttributeMechanism.html#a42ac8b3e9d038a0e97549d51abaab4f7">More...</a><br /></td></tr>
<tr class="separator:a42ac8b3e9d038a0e97549d51abaab4f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4915a80d22045e3697e6e3c107530a5e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAstAttributeMechanism.html#a4915a80d22045e3697e6e3c107530a5e">remove</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a4915a80d22045e3697e6e3c107530a5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases the specified attribute.  <a href="classAstAttributeMechanism.html#a4915a80d22045e3697e6e3c107530a5e">More...</a><br /></td></tr>
<tr class="separator:a4915a80d22045e3697e6e3c107530a5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa612df698a15f4bcf549bf4e10d03062"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAstAttributeMechanism.html#afc3ea302f3a2459d08542643ea8b8d4e">AttributeIdentifiers</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAstAttributeMechanism.html#aa612df698a15f4bcf549bf4e10d03062">getAttributeIdentifiers</a> () const</td></tr>
<tr class="memdesc:aa612df698a15f4bcf549bf4e10d03062"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of stored attribute names.  <a href="classAstAttributeMechanism.html#aa612df698a15f4bcf549bf4e10d03062">More...</a><br /></td></tr>
<tr class="separator:aa612df698a15f4bcf549bf4e10d03062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fe93fb33283d90cf46afcefc07b0f94"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAstAttributeMechanism.html#a4fe93fb33283d90cf46afcefc07b0f94">size</a> () const</td></tr>
<tr class="memdesc:a4fe93fb33283d90cf46afcefc07b0f94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of attributes stored.  <a href="classAstAttributeMechanism.html#a4fe93fb33283d90cf46afcefc07b0f94">More...</a><br /></td></tr>
<tr class="separator:a4fe93fb33283d90cf46afcefc07b0f94"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="adb50adf1e225c3c2d578016ee51aa971"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb50adf1e225c3c2d578016ee51aa971">&#9670;&nbsp;</a></span>AstAttributeMechanism() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">AstAttributeMechanism::AstAttributeMechanism </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>Constructs an attribute mechanism that holds no attributes. </p>

<p class="definition">Definition at line <a class="el" href="AstAttributeMechanism_8h_source.html#l00256">256</a> of file <a class="el" href="AstAttributeMechanism_8h_source.html">AstAttributeMechanism.h</a>.</p>

</div>
</div>
<a id="af8f08d6ad7caa0bab276bb4ae019690a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8f08d6ad7caa0bab276bb4ae019690a">&#9670;&nbsp;</a></span>AstAttributeMechanism() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">AstAttributeMechanism::AstAttributeMechanism </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAstAttributeMechanism.html">AstAttributeMechanism</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p>Copying an attribute container will copy the heap-allocated attribute values by invoking each value's <code>copy</code> method. If the method returns null then the new attribute container will not have that attribute; i.e., the <a class="el" href="classAstAttributeMechanism.html#a13d19c3cdaee50e3835513ddbca151b1">exists</a> method returns false.</p>
<p><b>New semantics:</b> The original behavior was that if the value's <code>copy</code> method returned null, the <a class="el" href="classAstAttributeMechanism.html#a13d19c3cdaee50e3835513ddbca151b1">exists</a> predicate returned true even though no value existed. </p>

<p class="definition">Definition at line <a class="el" href="AstAttributeMechanism_8h_source.html#l00266">266</a> of file <a class="el" href="AstAttributeMechanism_8h_source.html">AstAttributeMechanism.h</a>.</p>

</div>
</div>
<a id="a5b2def7aebda7ad58737e45da277e0b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b2def7aebda7ad58737e45da277e0b9">&#9670;&nbsp;</a></span>~AstAttributeMechanism()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AstAttributeMechanism::~AstAttributeMechanism </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>Destroying the attribute container should cause unused attributes to be destroyed. If an attribute implements the AstAttribute::CONTAINER_OWNERHSIP policy then the container explicitly deletes the attribute, otherwise it is up to the attribute class's designer to implement a deletion policy that prevents leaks.</p>
<p><b>New semantics:</b> The original implementation did not delete attributes when the container was destroyed, although it had commented-out code to do so. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af96a11722f70380b6e60ff90698ff96e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af96a11722f70380b6e60ff90698ff96e">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAstAttributeMechanism.html">AstAttributeMechanism</a>&amp; AstAttributeMechanism::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAstAttributeMechanism.html">AstAttributeMechanism</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assignment operator. </p>
<p>Assigning one attribute container to another will cause the destination container's attributes to be erased and deleted, and the source container's attributes to be copied. The assignment operator is exception safe: it will either successfully copy and assign all attributes or not assign any attributes. However, if an attribute uses anything other than the AstAttribute::CONTAINER_OWNERHSIP ownership policy then it is up to the attribute type's designer to handle deletion of attributes that were copied before the exception occurred.</p>
<p><b>New semantics:</b> The original implementation had a copy constructor but no assignment operator. Assignment of one attribute container to another caused both containers to share the attribute values allocated on the heap, making it nearly impossible to figure out when they could be safely deleted and therefore leading to memory leaks. </p>

</div>
</div>
<a id="a13d19c3cdaee50e3835513ddbca151b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13d19c3cdaee50e3835513ddbca151b1">&#9670;&nbsp;</a></span>exists()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AstAttributeMechanism::exists </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test for attribute existence. </p>
<p>Test whether this container holds an attribute with the specified name. This predicate returns true only if the name exists and points to a non-null attribute value. The name need not be declared in the attribute system.</p>
<p><b>New semantics:</b> It is now permissible to invoke this method on a const attribute container and this method no longer copies the name argument. </p>

</div>
</div>
<a id="aa0b9f68ebcc439391debab91740762c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0b9f68ebcc439391debab91740762c9">&#9670;&nbsp;</a></span>set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AstAttributeMechanism::set </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAstAttribute.html">AstAttribute</a> *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert an attribute. </p>
<p>Inserts the specified heap-allocated value for the given attribute name, replacing any previous value stored for that same name.</p>
<p>If the new value uses the <a class="el" href="classAstAttribute.html#ab82a227fa3befab83ec49a8bc64d8884aee6f0ddaa9ca9fe05aabf769e617d959">AstAttribute::CONTAINER_OWNERSHIP</a> policy then ownership is immediately transferred/moved to this container, which becomes responsible for deleting the attribute as appropriate to prevent leasks. Otherwise, the attribute's designer is responsible for implementing an ownership policy that safely prevents leaks.</p>
<p>If the old value (if present) uses the <a class="el" href="classAstAttribute.html#ab82a227fa3befab83ec49a8bc64d8884aee6f0ddaa9ca9fe05aabf769e617d959">AstAttribute::CONTAINER_OWNERSHIP</a> policy then it is deleted. Otherwise the attribute's designer is responsible for implementing an ownership policy that safely prevents leaks, and the attribute must not be deleted until after this method returns.</p>
<p><b>New semantics:</b> The old implementation didn't delete the previous attribute value. The old implementation allowed setting a null value, in which case the old <code>exists</code> returned true but the <code>operator</code>[] returned no attribute. </p>

</div>
</div>
<a id="a50ed79b10c3d7f8a5792374a352c9769"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50ed79b10c3d7f8a5792374a352c9769">&#9670;&nbsp;</a></span>add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AstAttributeMechanism::add </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAstAttribute.html">AstAttribute</a> *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert a new value if the attribute doesn't already exist. </p>
<p>Tests whether an attribute with the specified name <a class="el" href="classAstAttributeMechanism.html#a13d19c3cdaee50e3835513ddbca151b1">exists</a> and if not, invokes <a class="el" href="classAstAttributeMechanism.html#aa0b9f68ebcc439391debab91740762c9">set</a>. See <a class="el" href="classAstAttributeMechanism.html#aa0b9f68ebcc439391debab91740762c9">set</a> for details about ownership of the new attribute. Returns true if an attribute with the specified name did not already existed.</p>
<p><b>New semantics:</b> The old implementation was ambiguous about who owned the object after this call. It didn't take ownership of an attribute that wasn't inserted, but it also didn't indicate whether it was inserted. The old implementation printed an error message on standard error if the attribute existed (even if only its name existed but it had no value) and then returned to the caller without doing anything. Inserting a null value was allowed by the old implementation, in which case the old <code>exists</code> returned true but the old <code>operator</code>[] returned no attribute. </p>

</div>
</div>
<a id="a138f1f1378f4bc65175fc746229c7364"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a138f1f1378f4bc65175fc746229c7364">&#9670;&nbsp;</a></span>replace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AstAttributeMechanism::replace </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAstAttribute.html">AstAttribute</a> *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert a new value if the attribute already exists. </p>
<p>Tests whether the specified attribute exists, and if so, invokes <a class="el" href="classAstAttributeMechanism.html#aa0b9f68ebcc439391debab91740762c9">set</a>. See <a class="el" href="classAstAttributeMechanism.html#aa0b9f68ebcc439391debab91740762c9">set</a> for details about ownership of the old and new attributes. Returns true if an attribute with the specified name already existed.</p>
<p><b>New semantics:</b> The old implementation was ambiguous about who owned the object after this call. It didn't take ownership of an attribute that wasn't inserted, but it also didn't indicate whether it was inserted. The old implementation printed an error message on standard error if the attribute didn't exist and then returned to the caller without doing anything. Inserting a null value was allowed by the old implementation, in which case the old <code>exists</code> returned true but the old <code>operator</code>[] returned no attribute. </p>

</div>
</div>
<a id="a42ac8b3e9d038a0e97549d51abaab4f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42ac8b3e9d038a0e97549d51abaab4f7">&#9670;&nbsp;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAstAttribute.html">AstAttribute</a>* AstAttributeMechanism::operator[] </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an attribute value. </p>
<p>Returns the value associated with the given attribute, or null if the attribute does not exist. This method does not copy the attribute before returning it, therefore the caller should not delete the attribute. Erasing the attribute from the container may cause the pointer to become invalid, depending on the attribute's ownership policy. If the attribute uses the <a class="el" href="classAstAttribute.html#ab82a227fa3befab83ec49a8bc64d8884aee6f0ddaa9ca9fe05aabf769e617d959">AstAttribute::CONTAINER_OWNERSHIP</a> method then the attribute can be modified through its pointer without affecting attributes in other containers, otherwise the behavior is up to the attribute's designer.</p>
<p>The caller will need to <code>dynamic_cast</code> the returned pointer to the appropriate subclass of <a class="el" href="classAstAttribute.html">AstAttribute</a>.</p>
<p><b>New semantics:</b> The old implementation partly created an attribute if it didn't exist: <code>exists</code> started returning true although <code>operator</code>[] continued to return no attribute. The old implementation printed an error message to standard error if the attribute did not exist. </p>

</div>
</div>
<a id="a4915a80d22045e3697e6e3c107530a5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4915a80d22045e3697e6e3c107530a5e">&#9670;&nbsp;</a></span>remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AstAttributeMechanism::remove </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erases the specified attribute. </p>
<p>If an attribute with the specified name exists then it is removed from the container. If the attribute implements the <a class="el" href="classAstAttribute.html#ab82a227fa3befab83ec49a8bc64d8884aee6f0ddaa9ca9fe05aabf769e617d959">AstAttribute::CONTAINER_OWNERSHIP</a> policy then this container deletes the attribute, otherwise it is up to the attribute's designer to implement a safe way to prevent attribute leaks, and the attribute must not be deleted until after this method returns.</p>
<p><b>New semantics:</b> The old implementation did not delete the attribute value. It also printed an error message to standard error if the attribute did not exist. </p>

</div>
</div>
<a id="aa612df698a15f4bcf549bf4e10d03062"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa612df698a15f4bcf549bf4e10d03062">&#9670;&nbsp;</a></span>getAttributeIdentifiers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAstAttributeMechanism.html#afc3ea302f3a2459d08542643ea8b8d4e">AttributeIdentifiers</a> AstAttributeMechanism::getAttributeIdentifiers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List of stored attribute names. </p>
<p>Returns the set of names for attributes stored in this container. This can be used to iterate over the attributes, as in:</p>
<div class="fragment"></div><!-- fragment --><p> Or using the <a class="el" href="classSgNode.html">SgNode</a> API for attributes:</p>
<div class="fragment"></div><!-- fragment --><p> <b>New semantics:</b> The old implementation also returned some names that had no attribute values. For instance, if <code>operator</code>[] was invoked for an attribute that didn't exist then that name was also returned. </p>

</div>
</div>
<a id="a4fe93fb33283d90cf46afcefc07b0f94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fe93fb33283d90cf46afcefc07b0f94">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t AstAttributeMechanism::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of attributes stored. </p>
<p>Returns the number of attributes stored in this container.</p>
<p><b>New semantics:</b> The old implementation returned a signed integer instead of <code>size_t</code> as is customary for size measurements. It also could not be invoked on a const container. It also could return a value larger larger than the number of stored attributes (such as when a previous query for a non-existing attribute occurred). </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="AstAttributeMechanism_8h_source.html">AstAttributeMechanism.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Dec 8 2022 21:18:18 for ROSE by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
