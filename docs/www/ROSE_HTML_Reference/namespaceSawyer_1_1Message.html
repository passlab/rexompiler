<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROSE: Sawyer::Message Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="ROSE"/>
<link href="roseDoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ROSE
   &#160;<span id="projectnumber">0.11.96.11</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,true,'search.html','Search');
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceSawyer.html">Sawyer</a></li><li class="navelem"><a class="el" href="namespaceSawyer_1_1Message.html">Message</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Sawyer::Message Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>Formatted diagnostic messages emitted to various backends. </p>
<p>This namespace provides functionality to conditionally emit diagnostic messages based on software component and message importance. Although the library has extensive capabilities for controlling the message format and where to send the message, most uses of this namespace are to emit a message, so we'll describe that by way of introduction...</p>
<h1><a class="anchor" id="emitting"></a>
Emitting a message</h1>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceSawyer_1_1Message.html">Sawyer::Message</a>;</div>
<div class="line"><a class="code" href="namespaceSawyer_1_1Message.html#a26daa7a957cb93fe351393e5cc4ecfb0">mlog</a>[<a class="code" href="namespaceSawyer_1_1Message.html#abfb4d3240797db3a74bbf691f708a1c9abaad1fa32e5fd30aad22a4dff4750e2b">INFO</a>] &lt;&lt;<span class="stringliteral">&quot;about to process \&quot;&quot;</span> &lt;&lt;filename &lt;&lt;<span class="stringliteral">&quot;\&quot;\n&quot;</span></div>
</div><!-- fragment --><p>The <code>mlog</code> is a message <a class="el" href="classSawyer_1_1Message_1_1Facility.html" title="Collection of streams.">Facility</a> that holds a number of streams, each of which can be enabled or disabled. Inserting to a disabled message stream causes the message to be thrown away. The <code>INFO</code> is a message Importance, of which the library defines eight levels ranging from debug through fatal. The expression <code>mlog[INFO]</code> selects one of the message <a class="el" href="classSawyer_1_1Message_1_1Stream.html" title="Converts text to messages.">Stream</a> objects from the facility. The linefeed marks the end of a message; messages are "partial" until the linefeed is inserted, but depending on the sink (final destination) even partial messages might be shown. Since a message stream is a subclass of std::ostream, all the usual output insertion operators just work.</p>
<p>One of the benefits of using this namespace is that the output will have a consistent look and feel. It can even be colorized based on message importance (at least for ANSI terminal output). The output will look something like this:</p>
<div class="fragment"><div class="line">identityTranslator[31044] 0.00128 disassembler[<a class="code" href="namespaceSawyer_1_1Message.html#abfb4d3240797db3a74bbf691f708a1c9abaad1fa32e5fd30aad22a4dff4750e2b">INFO</a>]: about to process <span class="stringliteral">&quot;grep&quot;</span></div>
</div><!-- fragment --><p>The "identityTranslator" is the name of the executable, the 31044 is the process ID, "0.00128" is the time in seconds since the program started, "disassembler" is the software component that is reporting this messsage (i.e., the messsage facility), and "INFO" is the importance level.</p>
<h1><a class="anchor" id="facility"></a>
Defining facilities</h1>
<p>Before one can start emitting messages, he needs to define a message <a class="el" href="classSawyer_1_1Message_1_1Facility.html" title="Collection of streams.">Facility</a> (<code>mlog</code> in the first example). The library defines one facility, <a class="el" href="namespaceSawyer_1_1Message.html#a26daa7a957cb93fe351393e5cc4ecfb0" title="Facility used by Sawyer components.">Sawyer::Message::mlog</a>, which can be used, but it's better to define a message facility for each software component because then messages can be controlled per software component, and the component will be clearly indicated in the output ("disassembler" in the previous example). A software component could be a function, class, namespace, entire library, or entire program&ndash;whatever granularity one wants.</p>
<p>Here's an example that creates a facility at class level:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Disassembler {</div>
<div class="line">    <span class="keyword">static</span> <a class="code" href="classSawyer_1_1Message_1_1Facility.html">Sawyer::Message::Facility</a> <a class="code" href="namespaceSawyer_1_1Message.html#a26daa7a957cb93fe351393e5cc4ecfb0">mlog</a>;</div>
<div class="line">    ...</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><a class="code" href="classSawyer_1_1Message_1_1Facility.html">Sawyer::Message::Facility</a> Disassembler::mlog(<span class="stringliteral">&quot;disassembler&quot;</span>);</div>
</div><!-- fragment --><p>The <code>mlog</code> is constructed in a useable state with all streams enabled and output going to standard error via file descriptor 2. It is given a string name, "disassembler", that will show up in the output. The class may want to make two adjustments at run-time:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Disassembler::initClass() {</div>
<div class="line">    <a class="code" href="namespaceSawyer_1_1Message.html#a26daa7a957cb93fe351393e5cc4ecfb0">mlog</a>.<a class="code" href="classSawyer_1_1Message_1_1Facility.html#a9a75fb6cc458056c6c96af39927f4c4d">initStreams</a>(destination);</div>
<div class="line">    <a class="code" href="namespaceSawyer_1_1Message.html#a1bb51db7d9bc62c602f6104a24231490">mfacilities</a>.<a class="code" href="classSawyer_1_1Message_1_1Facilities.html#adc22eb086e579c24720a99d157c601dc">insert</a>(<a class="code" href="namespaceSawyer_1_1Message.html#a26daa7a957cb93fe351393e5cc4ecfb0">mlog</a>);</div>
<div class="line">}</div>
</div><!-- fragment --><p>The <code>initStreams</code> call reinitializes the message streams so they use your library's message plumbing, <code>destination</code>, which is a <a class="el" href="namespaceSawyer_1_1Message.html#a8303ffa916b56acb3514453e07ea79b5" title="Smart pointer.">Sawyer::Message::DestinationPtr</a> (types whose names end with "Ptr" point to reference counted objects). The streams had previously been using <a class="el" href="namespaceSawyer_1_1Message.html#a1f2be778ddc20105e6ddca1966a62db8" title="Library-provided message destination.">Sawyer::Message::merr</a>, but pointing them all to your destination means that the destination for all messages can be changed in one place: if you want messages to go to syslogd, you change how <code>destination</code> is created. As we'll see below, the destination also controls things like colored output.</p>
<p>The <code>mfacilities.insert</code> call registers the new <code>mlog</code> with a global <a class="el" href="classSawyer_1_1Message_1_1Facilities.html" title="Collection of facilities.">Facilities</a> object, which we describe next...</p>
<h1><a class="anchor" id="facilities"></a>
Collections of facility objects</h1>
<p>Any combination of <a class="el" href="classSawyer_1_1Message_1_1Facility.html" title="Collection of streams.">Facility</a> objects can be grouped together into one or more <a class="el" href="classSawyer_1_1Message_1_1Facilities.html" title="Collection of facilities.">Facilities</a> (note plural) objects so they can be enabled and disabled collectively. A <a class="el" href="classSawyer_1_1Message_1_1Facilities.html" title="Collection of facilities.">Facilities</a> object, also referred to as a facility group, is able to parse a simple language provided as a string, which is often provided from the command-line parser.</p>
<p>This example creates three facilities and groups them together:</p>
<div class="fragment"><div class="line">Facility mlog1(<span class="stringliteral">&quot;disassembler&quot;</span>, destination);</div>
<div class="line">Facility mlog2(<span class="stringliteral">&quot;c++ parser&quot;</span>, destination)</div>
<div class="line">Facility mlog3(<span class="stringliteral">&quot;StringUtility::split&quot;</span>, destination);</div>
<div class="line"> </div>
<div class="line">Facilities facilities;</div>
<div class="line">facilities.insert(mlog1);</div>
<div class="line">facilities.insert(mlog2, <span class="stringliteral">&quot;cpp_parser&quot;</span>);</div>
<div class="line">facilities.insert(mlog3);</div>
</div><!-- fragment --><p>The three <code>insert</code> calls incorporate the three facilities into the group by reference and give them names in the configuration language. The names in the config language must look like C++ names (including <code>::</code> and <code>.</code> operators), so the second <code>insert</code> needs to supply a valid name. The other two use the facility's name, which is also the string that is printed when messages are output. A unique, non-empty name must be supplied for each facility in a group, although the names for the facilities themselves need not be unique or even non-empty. The library provides <a class="el" href="namespaceSawyer_1_1Message.html#a1bb51db7d9bc62c602f6104a24231490" title="Library-provided facility group.">Sawyer::Message::mfacilities</a> and users are encouraged to use it as their primary facility group.</p>
<p>The facilities in a group can be controlled (enabled or disabled) with the <a class="el" href="classSawyer_1_1Message_1_1Facilities.html#a5eee6e4f739534b2a2399142be6c5361" title="Parse a single command-line switch and enable/disable the indicated streams.">Facilities::control</a> method, which takes a string in the control language (see method for details). For example, to enable output for all levels of importance except debugging, across all registered facilities, but only warning and higher messages for the disassembler's facility:</p>
<div class="fragment"><div class="line">facilities.control(<span class="stringliteral">&quot;all, !debug, disassembler(&gt;=warn)&quot;</span>)</div>
</div><!-- fragment --><p>The terms are processed from left to right, but only if the entire string is valid. If the string is invalid then an exception is thrown that includes an error message and the exact position in the string where the error occurred.</p>
<h1><a class="anchor" id="plumbing"></a>
Plumbing lattice</h1>
<p>Inserting a message to a stream with <code>&lt;&lt;</code> operators is only half the story&ndash;the plumbing lattice deals with how a message is conveyed to the final destination(s) and what transformations happen along the way. The plumbing is a run-time constructed lattice containing internal nodes and leaf nodes. Each leaf node is a final destination, or sink, for a message and can be a C++ <code>std::ostream</code>, a C <code>FILE</code> pointer, a Unix file descriptor, the syslog daemon, or a user-defined destination. The internal nodes serve as multiplexers, filters, rate limiters, etc.</p>
<p>All plumbing lattice nodes are dynamically allocated and reference counted. Instead of using the normal C++ constructors, plumbing objects are created with static <code>instance</code> methods that perform the allocation and return a smart pointer. The type names for smart pointers are the class names with a "Ptr" suffix, and <a class="el" href="classSawyer_1_1SharedPointer.html">Sawyer::SharedPointer</a> serves as the implementation.</p>
<p>For instance, a lattice that accepts any kind of message, limits the output to at most one message per second, and sends the messages to standard error and a file can be constructed like this:</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceSawyer_1_1Message.html#a8303ffa916b56acb3514453e07ea79b5">DestinationPtr</a> <a class="code" href="namespaceRose_1_1Diagnostics.html#a1ba0507284dc0ed4bf22f0a5f3fe5ac4">destination</a> = <a class="code" href="classSawyer_1_1Message_1_1Multiplexer.html#a144a5a8a7c1695cdc804701ea93c17cb">TimeFilter::instance</a>(1.0)</div>
<div class="line">                               -&gt;to(<a class="code" href="classSawyer_1_1Message_1_1FdSink.html#abbb5db08a5db5f91eb1750b832b217bd">FdSink::instance</a>(2),     <span class="comment">//standard error on Unix</span></div>
<div class="line">                                    <a class="code" href="classSawyer_1_1Message_1_1FileSink.html#a528adad7bdb18a8ff5cbfa6b3d604d83">FileSink::instance</a>(f));  <span class="comment">// f is some FILE* we opened already</span></div>
</div><!-- fragment --><p>The <code>destination</code> can then be used to construct streams and facilities. The <a class="el" href="classSawyer_1_1Message_1_1Destination.html" title="Base class for all types of message destinations.">Destination</a> class is the base class for all plumbing lattice nodes, thus DestinationPtr is the base class for all pointers to nodes. Of course, similar redirection can be done outside the program using standard Unix tools and file redirection, except that performing redirection via a plumbing lattice has a few advantages:</p>
<ul>
<li>the program itself can control the redirection </li>
<li>different paths through the lattice can result in different message formats </li>
<li>final destinations can be programmatic, such as writing to syslogd or a database </li>
<li>the library might do a better presentation when two streams go to the same destination</li>
</ul>
<h1><a class="anchor" id="tips"></a>
Tips and tricks</h1>
<h2><a class="anchor" id="name"></a>
Naming tips</h2>
<p>Avoid using the name "log" since it may conflict with <code>::log</code> from math.h.</p>
<p>If facilities are consistently named (e.g., always "mlog") then code that emits messages can always use that name and will automatically get the most narrowly scoped facility that's visible according to C++ visibility rules, which is probably the facility that is most applicable.</p>
<p>A <code>using namespace <a class="el" href="namespaceSawyer_1_1Message.html" title="Formatted diagnostic messages emitted to various backends.">Sawyer::Message</a></code> will prevent you from having to qualify the message importance symbols, but if you name your facilities "mlog" they may be ambiguous with <a class="el" href="namespaceSawyer_1_1Message.html#a26daa7a957cb93fe351393e5cc4ecfb0" title="Facility used by Sawyer components.">Sawyer::Message::mlog</a>. <a class="el" href="namespaceSawyer.html" title="Name space for the entire library.">Sawyer</a> also provides the namespace <a class="el" href="namespaceSawyer_1_1Message_1_1Common.html" title="Commonly used message types.">Sawyer::Message::Common</a>, which defines only the most commonly used types (the importance levels, <a class="el" href="classSawyer_1_1Message_1_1Stream.html" title="Converts text to messages.">Stream</a>, <a class="el" href="classSawyer_1_1Message_1_1Facility.html" title="Collection of streams.">Facility</a>, and <a class="el" href="classSawyer_1_1Message_1_1Facilities.html" title="Collection of facilities.">Facilities</a>).</p>
<h2><a class="anchor" id="perf"></a>
Performance tips</h2>
<p>Although every attempt was made to keep the library efficient, when features and performance conflict, features win. If messages insert operators <code>&lt;&lt;</code> are expensive then it is best to avoid calling them when the stream to which they're inserted is disabled&ndash;they'd just be thrown away anyway. Programs that already emit messages to streams probably use <code>if</code> statements or conditional compilation already, and those constructs can continue to be used. In fact, when a stream is evaluated in a Boolean context it returns true when enabled and false when disabled:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (<a class="code" href="namespaceSawyer_1_1Message.html#a26daa7a957cb93fe351393e5cc4ecfb0">mlog</a>[<a class="code" href="namespaceSawyer_1_1Message.html#abfb4d3240797db3a74bbf691f708a1c9af04facf962ba167db8a1e5d2b435fb93">DEBUG</a>])</div>
<div class="line">    <a class="code" href="namespaceSawyer_1_1Message.html#a26daa7a957cb93fe351393e5cc4ecfb0">mlog</a>[<a class="code" href="namespaceSawyer_1_1Message.html#abfb4d3240797db3a74bbf691f708a1c9af04facf962ba167db8a1e5d2b435fb93">DEBUG</a>] &lt;&lt;<span class="stringliteral">&quot;the result is &quot;</span> &lt;&lt;something_expensive() &lt;&lt;<span class="stringliteral">&quot;\n&quot;</span>;</div>
</div><!-- fragment --><p>When <code>if</code> statements are used extensively for this purpose in a project whose style guide mandates that the body must be on the following line, the logging code occupies twice as much vertical space as necessary (or three or four times, with curly braces) and can become quite obtrusive. Here are two other ways to get the same effect:</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceSawyer_1_1Message.html#a26daa7a957cb93fe351393e5cc4ecfb0">mlog</a>[<a class="code" href="namespaceSawyer_1_1Message.html#abfb4d3240797db3a74bbf691f708a1c9af04facf962ba167db8a1e5d2b435fb93">DEBUG</a>] and <a class="code" href="namespaceSawyer_1_1Message.html#a26daa7a957cb93fe351393e5cc4ecfb0">mlog</a>[<a class="code" href="namespaceSawyer_1_1Message.html#abfb4d3240797db3a74bbf691f708a1c9af04facf962ba167db8a1e5d2b435fb93">DEBUG</a>] &lt;&lt;<span class="stringliteral">&quot;the result is &quot;</span> &lt;&lt;something_expensive() &lt;&lt;<span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">SAWYER_MESG(<a class="code" href="namespaceSawyer_1_1Message.html#a26daa7a957cb93fe351393e5cc4ecfb0">mlog</a>[<a class="code" href="namespaceSawyer_1_1Message.html#abfb4d3240797db3a74bbf691f708a1c9af04facf962ba167db8a1e5d2b435fb93">DEBUG</a>]) &lt;&lt;<span class="stringliteral">&quot;the result is &quot;</span> &lt;&lt;something_expensive() &lt;&lt;<span class="stringliteral">&quot;\n&quot;</span>;</div>
</div><!-- fragment --><p>The alternate spelling "SAWYER_MSG" is also allowed.</p>
<h2><a class="anchor" id="temp"></a>
Temporary streams</h2>
<p>Although <code>std::ostream</code> objects are not copyable, and not movable before c++11, <a class="el" href="namespaceSawyer.html" title="Name space for the entire library.">Sawyer</a>'s message streams implement a form of copying/moving. Namely, a <a class="el" href="classSawyer_1_1Message_1_1Stream.html" title="Converts text to messages.">Stream</a> copy constructor can be used to create a new message stream identical to the source message stream, and any partial message in the source stream is moved to the destination stream. This enables a way to create a temporary stream for use inside a function:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> longFunctionWithLotsOfDebugging() {</div>
<div class="line">    Stream debug(<a class="code" href="namespaceSawyer_1_1Message.html#a26daa7a957cb93fe351393e5cc4ecfb0">mlog</a>[<a class="code" href="namespaceSawyer_1_1Message.html#abfb4d3240797db3a74bbf691f708a1c9af04facf962ba167db8a1e5d2b435fb93">DEBUG</a>]);</div>
<div class="line">    ...</div>
<div class="line">    debug &lt;&lt;<span class="stringliteral">&quot;got here\n&quot;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="partial"></a>
Partial messages</h2>
<p>One problem that authors often encounter when emitting diagnostics is that they want to print an incomplete line, then perform some work, then complete the line. But if the "some work" also prints diagnostics then the output will be all messed up. This library attempts to fix that, at least when the software uses this library for all its diagnostic output. Here's the most basic form:</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceSawyer_1_1Message.html#a26daa7a957cb93fe351393e5cc4ecfb0">mlog</a>[<a class="code" href="namespaceSawyer_1_1Message.html#abfb4d3240797db3a74bbf691f708a1c9af04facf962ba167db8a1e5d2b435fb93">DEBUG</a>] &lt;&lt;<span class="stringliteral">&quot;first part&quot;</span>;          <span class="comment">// partial since no line-feed</span></div>
<div class="line"><a class="code" href="namespaceSawyer_1_1Message.html#a26daa7a957cb93fe351393e5cc4ecfb0">mlog</a>[<a class="code" href="namespaceSawyer_1_1Message.html#abfb4d3240797db3a74bbf691f708a1c9abaad1fa32e5fd30aad22a4dff4750e2b">INFO</a>] &lt;&lt;<span class="stringliteral">&quot;some other message\n&quot;</span>; <span class="comment">// unrelated message</span></div>
<div class="line"><a class="code" href="namespaceSawyer_1_1Message.html#a26daa7a957cb93fe351393e5cc4ecfb0">mlog</a>[<a class="code" href="namespaceSawyer_1_1Message.html#abfb4d3240797db3a74bbf691f708a1c9af04facf962ba167db8a1e5d2b435fb93">DEBUG</a>] &lt;&lt;<span class="stringliteral">&quot;; second part\n&quot;</span>;     <span class="comment">// complete the partial message</span></div>
</div><!-- fragment --><p>The output to sinks like standard error that support partial messages will be, sans prefixes:</p>
<div class="fragment"><div class="line">first part...</div>
<div class="line">some other message</div>
<div class="line">first part; second part</div>
</div><!-- fragment --><p>But there's a slight problem with that code: if the second line had been a message written to <code>mlog[DEBUG]</code> instead of <code>mlog[INFO]</code> then the library would not have been able to tell that "some other message" is unrelated to "first part" and would have emitted something that's not any better than using plain old <code>std::cerr</code>:</p>
<div class="fragment"><div class="line">first partsome other message</div>
<div class="line">; second part</div>
</div><!-- fragment --><p>This most often occurs when "some other message" is emitted from some other function, so its not immediately evident that something is inserting a message in the midst of our partial message. A better way is to create a temporary message stream and use that stream to complete the partial message. Since the copy constructor also moves any partial message from the source stream to the new stream, we can even emit the partial message on the same line as the declaration. Here's a silly example of the process:</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> multiply(<span class="keywordtype">unsigned</span> a, <span class="keywordtype">unsigned</span> b) {</div>
<div class="line">    Stream mesg(<a class="code" href="namespaceSawyer_1_1Message.html#a26daa7a957cb93fe351393e5cc4ecfb0">mlog</a>[<a class="code" href="namespaceSawyer_1_1Message.html#abfb4d3240797db3a74bbf691f708a1c9af04facf962ba167db8a1e5d2b435fb93">DEBUG</a>] &lt;&lt;<span class="stringliteral">&quot;multiply(&quot;</span> &lt;&lt;a &lt;&lt;<span class="stringliteral">&quot;, &quot;</span> &lt;&lt;b &lt;&lt;<span class="stringliteral">&quot;)&quot;</span>);</div>
<div class="line">    <span class="keywordtype">unsigned</span> result = 0;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;b; ++i)</div>
<div class="line">        result = add(result, b); <span class="comment">//might also write to mlog[DEBUG]</span></div>
<div class="line">    mesg &lt;&lt;<span class="stringliteral">&quot; = &quot;</span> &lt;&lt;result &lt;&lt;<span class="stringliteral">&quot;\n&quot;</span>; <span class="comment">// finish the message</span></div>
<div class="line">    <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
</div><!-- fragment --><p>The <code>mesg</code> stream need not be used only for completing the one message. In fact, one of the benefits of the <a class="el" href="namespaceSawyer_1_1Message.html#temp">Temporary streams</a> hint is that partial messages emitted using the <code>debug</code> stream cannot be interferred with from called functions that might use <code>mlog[DEBUG]</code>. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceSawyer_1_1Message_1_1Common"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Message_1_1Common.html">Common</a></td></tr>
<tr class="memdesc:namespaceSawyer_1_1Message_1_1Common"><td class="mdescLeft">&#160;</td><td class="mdescRight">Commonly used message types. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Message_1_1ColorSet.html">ColorSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Colors to use for each message importance.  <a href="classSawyer_1_1Message_1_1ColorSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSawyer_1_1Message_1_1ColorSpec.html">ColorSpec</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ANSI Color specification for text written to a terminal.  <a href="structSawyer_1_1Message_1_1ColorSpec.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Message_1_1Destination.html">Destination</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all types of message destinations.  <a href="classSawyer_1_1Message_1_1Destination.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Message_1_1Facilities.html">Facilities</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collection of facilities.  <a href="classSawyer_1_1Message_1_1Facilities.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Message_1_1FacilitiesGuard.html">FacilitiesGuard</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves and restores facilities.  <a href="classSawyer_1_1Message_1_1FacilitiesGuard.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Message_1_1Facility.html">Facility</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collection of streams.  <a href="classSawyer_1_1Message_1_1Facility.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Message_1_1FdSink.html">FdSink</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send free-format messages to a Unix file descriptor.  <a href="classSawyer_1_1Message_1_1FdSink.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Message_1_1FileSink.html">FileSink</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send free-format messages to a C <code>FILE</code> pointer.  <a href="classSawyer_1_1Message_1_1FileSink.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Message_1_1Filter.html">Filter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for internal nodes that filter messages.  <a href="classSawyer_1_1Message_1_1Filter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Message_1_1Gang.html">Gang</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Message_1_1HighWater.html">HighWater</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Message_1_1ImportanceFilter.html">ImportanceFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters messages based on importance level.  <a href="classSawyer_1_1Message_1_1ImportanceFilter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Message_1_1Mesg.html">Mesg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A single message.  <a href="classSawyer_1_1Message_1_1Mesg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSawyer_1_1Message_1_1MesgProps.html">MesgProps</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Properties for messages.  <a href="structSawyer_1_1Message_1_1MesgProps.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Message_1_1Multiplexer.html">Multiplexer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends incoming messages to multiple destinations.  <a href="classSawyer_1_1Message_1_1Multiplexer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Message_1_1Prefix.html">Prefix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information printed at the beginning of each free-format message.  <a href="classSawyer_1_1Message_1_1Prefix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Message_1_1SequenceFilter.html">SequenceFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters messages based on how many messages have been seen.  <a href="classSawyer_1_1Message_1_1SequenceFilter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Message_1_1SProxy.html">SProxy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Message_1_1Stream.html">Stream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts text to messages.  <a href="classSawyer_1_1Message_1_1Stream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Message_1_1StreamSink.html">StreamSink</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send free-format messages to a C++ I/O stream.  <a href="classSawyer_1_1Message_1_1StreamSink.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Message_1_1SyslogSink.html">SyslogSink</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends messages to the syslog daemon.  <a href="classSawyer_1_1Message_1_1SyslogSink.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Message_1_1TimeFilter.html">TimeFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters messages based on time.  <a href="classSawyer_1_1Message_1_1TimeFilter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Message_1_1UnformattedSink.html">UnformattedSink</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for final destinations that are free-format.  <a href="classSawyer_1_1Message_1_1UnformattedSink.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aacd58e004be45eccc17db40fa57f9737"><td class="memItemLeft" align="right" valign="top">typedef std::pair&lt; <a class="el" href="namespaceSawyer_1_1Message.html#a8303ffa916b56acb3514453e07ea79b5">DestinationPtr</a>, <a class="el" href="structSawyer_1_1Message_1_1MesgProps.html">MesgProps</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Message.html#aacd58e004be45eccc17db40fa57f9737">BakedDestination</a></td></tr>
<tr class="memdesc:aacd58e004be45eccc17db40fa57f9737"><td class="mdescLeft">&#160;</td><td class="mdescRight">Baked properties for a destination.  <a href="namespaceSawyer_1_1Message.html#aacd58e004be45eccc17db40fa57f9737">More...</a><br /></td></tr>
<tr class="separator:aacd58e004be45eccc17db40fa57f9737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f4ac816e08aac8a39009aa0ae8f25a3"><td class="memItemLeft" align="right" valign="top"><a id="a3f4ac816e08aac8a39009aa0ae8f25a3"></a>
typedef std::vector&lt; <a class="el" href="namespaceSawyer_1_1Message.html#aacd58e004be45eccc17db40fa57f9737">BakedDestination</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Message.html#a3f4ac816e08aac8a39009aa0ae8f25a3">BakedDestinations</a></td></tr>
<tr class="memdesc:a3f4ac816e08aac8a39009aa0ae8f25a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Baked properties for multiple destinations. <br /></td></tr>
<tr class="separator:a3f4ac816e08aac8a39009aa0ae8f25a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:abfb4d3240797db3a74bbf691f708a1c9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Message.html#abfb4d3240797db3a74bbf691f708a1c9">Importance</a> { <br />
&#160;&#160;<a class="el" href="namespaceSawyer_1_1Message.html#abfb4d3240797db3a74bbf691f708a1c9af04facf962ba167db8a1e5d2b435fb93">DEBUG</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceSawyer_1_1Message.html#abfb4d3240797db3a74bbf691f708a1c9a90bf0c35fdfdb66aa2a5760524878c92">TRACE</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceSawyer_1_1Message.html#abfb4d3240797db3a74bbf691f708a1c9af3d19c270e9071c1ce2b5f2c3f6715dd">WHERE</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceSawyer_1_1Message.html#abfb4d3240797db3a74bbf691f708a1c9a538a612c7a02e55d51e68b4dc4df21c3">MARCH</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceSawyer_1_1Message.html#abfb4d3240797db3a74bbf691f708a1c9abaad1fa32e5fd30aad22a4dff4750e2b">INFO</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceSawyer_1_1Message.html#abfb4d3240797db3a74bbf691f708a1c9a52f8e5eea9bfc070f3e0a152e3d1537a">WARN</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceSawyer_1_1Message.html#abfb4d3240797db3a74bbf691f708a1c9a85ccc0760cef2470d0c119884610d394">ERROR</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceSawyer_1_1Message.html#abfb4d3240797db3a74bbf691f708a1c9abb7c0d080435a4a981ba171d08dc3bb7">FATAL</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceSawyer_1_1Message.html#abfb4d3240797db3a74bbf691f708a1c9a16f99409d07bbe140d7b7f00c1fc7d09">N_IMPORTANCE</a>
<br />
 }</td></tr>
<tr class="memdesc:abfb4d3240797db3a74bbf691f708a1c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Level of importance for a message.  <a href="namespaceSawyer_1_1Message.html#abfb4d3240797db3a74bbf691f708a1c9">More...</a><br /></td></tr>
<tr class="separator:abfb4d3240797db3a74bbf691f708a1c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeac28ccbf0aa440d434d9055c7da1d15"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Message.html#aeac28ccbf0aa440d434d9055c7da1d15">AnsiColor</a> { <br />
&#160;&#160;<a class="el" href="namespaceSawyer_1_1Message.html#aeac28ccbf0aa440d434d9055c7da1d15afa95fc3911eda269166b985e8b97f2c1">COLOR_BLACK</a> = 0, 
<br />
&#160;&#160;<a class="el" href="namespaceSawyer_1_1Message.html#aeac28ccbf0aa440d434d9055c7da1d15a6bae098067cea16895a6828ecc8cca0b">COLOR_RED</a> = 1, 
<br />
&#160;&#160;<a class="el" href="namespaceSawyer_1_1Message.html#aeac28ccbf0aa440d434d9055c7da1d15ac93de509b6ddfb5b8cb6f1183f91002b">COLOR_GREEN</a> = 2, 
<br />
&#160;&#160;<a class="el" href="namespaceSawyer_1_1Message.html#aeac28ccbf0aa440d434d9055c7da1d15a861124addc5e32c715318a473d85af9a">COLOR_YELLOW</a> = 3, 
<br />
&#160;&#160;<a class="el" href="namespaceSawyer_1_1Message.html#aeac28ccbf0aa440d434d9055c7da1d15ab3bbeb91a0fe7684e0818a17f72c8dc6">COLOR_BLUE</a> = 4, 
<br />
&#160;&#160;<a class="el" href="namespaceSawyer_1_1Message.html#aeac28ccbf0aa440d434d9055c7da1d15aaec2e123aaed751da054ce111b07ff03">COLOR_MAGENTA</a> = 5, 
<br />
&#160;&#160;<a class="el" href="namespaceSawyer_1_1Message.html#aeac28ccbf0aa440d434d9055c7da1d15a5cb4a46d54bcd98d55a47b279724393d">COLOR_CYAN</a> = 6, 
<br />
&#160;&#160;<a class="el" href="namespaceSawyer_1_1Message.html#aeac28ccbf0aa440d434d9055c7da1d15aa6a4772045feb733899595ca23e22d21">COLOR_WHITE</a> = 7, 
<br />
&#160;&#160;<a class="el" href="namespaceSawyer_1_1Message.html#aeac28ccbf0aa440d434d9055c7da1d15abec1d0c20494ea043f710e69fee7b3bc">COLOR_DEFAULT</a> = 8
<br />
 }</td></tr>
<tr class="memdesc:aeac28ccbf0aa440d434d9055c7da1d15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Colors used by sinks that write to terminals.  <a href="namespaceSawyer_1_1Message.html#aeac28ccbf0aa440d434d9055c7da1d15">More...</a><br /></td></tr>
<tr class="separator:aeac28ccbf0aa440d434d9055c7da1d15"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8d983cf7caef37db89d2d4aa21d78daf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Message.html#a8d983cf7caef37db89d2d4aa21d78daf">initializeLibrary</a> ()</td></tr>
<tr class="memdesc:a8d983cf7caef37db89d2d4aa21d78daf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly initialize the library.  <a href="namespaceSawyer_1_1Message.html#a8d983cf7caef37db89d2d4aa21d78daf">More...</a><br /></td></tr>
<tr class="separator:a8d983cf7caef37db89d2d4aa21d78daf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3b038ece31d47b041d51973ac3d6fb1"><td class="memItemLeft" align="right" valign="top"><a id="af3b038ece31d47b041d51973ac3d6fb1"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Message.html#af3b038ece31d47b041d51973ac3d6fb1">stringifyImportance</a> (<a class="el" href="namespaceSawyer_1_1Message.html#abfb4d3240797db3a74bbf691f708a1c9">Importance</a>)</td></tr>
<tr class="memdesc:af3b038ece31d47b041d51973ac3d6fb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an <a class="el" href="namespaceSawyer_1_1Message.html#abfb4d3240797db3a74bbf691f708a1c9">Importance</a> enum to a string. <br /></td></tr>
<tr class="separator:af3b038ece31d47b041d51973ac3d6fb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20cc3c06d10f9aee80477ca530122149"><td class="memItemLeft" align="right" valign="top"><a id="a20cc3c06d10f9aee80477ca530122149"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Message.html#a20cc3c06d10f9aee80477ca530122149">stringifyColor</a> (<a class="el" href="namespaceSawyer_1_1Message.html#aeac28ccbf0aa440d434d9055c7da1d15">AnsiColor</a>)</td></tr>
<tr class="memdesc:a20cc3c06d10f9aee80477ca530122149"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an <a class="el" href="namespaceSawyer_1_1Message.html#aeac28ccbf0aa440d434d9055c7da1d15">AnsiColor</a> enum to a string. <br /></td></tr>
<tr class="separator:a20cc3c06d10f9aee80477ca530122149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea4bf126561efe8c608182f2c8b05c76"><td class="memItemLeft" align="right" valign="top"><a id="aea4bf126561efe8c608182f2c8b05c76"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Message.html#aea4bf126561efe8c608182f2c8b05c76">now</a> ()</td></tr>
<tr class="memdesc:aea4bf126561efe8c608182f2c8b05c76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current system time in seconds. <br /></td></tr>
<tr class="separator:aea4bf126561efe8c608182f2c8b05c76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeae28b6d1fe4aeb9d0fc94e7d5d546db"><td class="memItemLeft" align="right" valign="top"><a id="aeae28b6d1fe4aeb9d0fc94e7d5d546db"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Message.html#aeae28b6d1fe4aeb9d0fc94e7d5d546db">escape</a> (const std::string &amp;)</td></tr>
<tr class="memdesc:aeae28b6d1fe4aeb9d0fc94e7d5d546db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a string to its C representation. <br /></td></tr>
<tr class="separator:aeae28b6d1fe4aeb9d0fc94e7d5d546db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c9f772acffa23865f8a21244122c23a"><td class="memItemLeft" align="right" valign="top"><a id="a4c9f772acffa23865f8a21244122c23a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Message.html#a4c9f772acffa23865f8a21244122c23a">isTerminal</a> (int fd)</td></tr>
<tr class="memdesc:a4c9f772acffa23865f8a21244122c23a"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if fd is a tty. <br /></td></tr>
<tr class="separator:a4c9f772acffa23865f8a21244122c23a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea8adc425c9d3fce765576cde1a2fdc4"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Message.html#aea8adc425c9d3fce765576cde1a2fdc4">operator&lt;&lt;</a> (std::ostream &amp;o, const <a class="el" href="structSawyer_1_1Message_1_1MesgProps.html">MesgProps</a> &amp;props)</td></tr>
<tr class="memdesc:aea8adc425c9d3fce765576cde1a2fdc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the values for all message properties.  <a href="namespaceSawyer_1_1Message.html#aea8adc425c9d3fce765576cde1a2fdc4">More...</a><br /></td></tr>
<tr class="separator:aea8adc425c9d3fce765576cde1a2fdc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15a65cf3e17029eb5cd8e6c3b0deb5ef"><td class="memItemLeft" align="right" valign="top"><a id="a15a65cf3e17029eb5cd8e6c3b0deb5ef"></a>
<a class="el" href="classSawyer_1_1Message_1_1Stream.html">Stream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>firstEnabled</b> (<a class="el" href="classSawyer_1_1Message_1_1Stream.html">Stream</a> &amp;s1)</td></tr>
<tr class="separator:a15a65cf3e17029eb5cd8e6c3b0deb5ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a36684cec1d0ff6a504f32ee3250539"><td class="memItemLeft" align="right" valign="top"><a id="a8a36684cec1d0ff6a504f32ee3250539"></a>
<a class="el" href="classSawyer_1_1Message_1_1Stream.html">Stream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>firstEnabled</b> (<a class="el" href="classSawyer_1_1Message_1_1Stream.html">Stream</a> &amp;s1, <a class="el" href="classSawyer_1_1Message_1_1Stream.html">Stream</a> &amp;s2)</td></tr>
<tr class="separator:a8a36684cec1d0ff6a504f32ee3250539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac88e36a26169e04028efa23e23ec6cd3"><td class="memItemLeft" align="right" valign="top"><a id="ac88e36a26169e04028efa23e23ec6cd3"></a>
<a class="el" href="classSawyer_1_1Message_1_1Stream.html">Stream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>firstEnabled</b> (<a class="el" href="classSawyer_1_1Message_1_1Stream.html">Stream</a> &amp;s1, <a class="el" href="classSawyer_1_1Message_1_1Stream.html">Stream</a> &amp;s2, <a class="el" href="classSawyer_1_1Message_1_1Stream.html">Stream</a> &amp;s3)</td></tr>
<tr class="separator:ac88e36a26169e04028efa23e23ec6cd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc9190b413130e02c76deaa224e13871"><td class="memItemLeft" align="right" valign="top"><a id="afc9190b413130e02c76deaa224e13871"></a>
<a class="el" href="classSawyer_1_1Message_1_1Stream.html">Stream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>firstEnabled</b> (<a class="el" href="classSawyer_1_1Message_1_1Stream.html">Stream</a> &amp;s1, <a class="el" href="classSawyer_1_1Message_1_1Stream.html">Stream</a> &amp;s2, <a class="el" href="classSawyer_1_1Message_1_1Stream.html">Stream</a> &amp;s3, <a class="el" href="classSawyer_1_1Message_1_1Stream.html">Stream</a> &amp;s4)</td></tr>
<tr class="separator:afc9190b413130e02c76deaa224e13871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a441109f8ea2223e4093ad8e0d2434f6b"><td class="memItemLeft" align="right" valign="top"><a id="a441109f8ea2223e4093ad8e0d2434f6b"></a>
<a class="el" href="classSawyer_1_1Message_1_1Stream.html">Stream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>firstEnabled</b> (<a class="el" href="classSawyer_1_1Message_1_1Stream.html">Stream</a> &amp;s1, <a class="el" href="classSawyer_1_1Message_1_1Stream.html">Stream</a> &amp;s2, <a class="el" href="classSawyer_1_1Message_1_1Stream.html">Stream</a> &amp;s3, <a class="el" href="classSawyer_1_1Message_1_1Stream.html">Stream</a> &amp;s4, <a class="el" href="classSawyer_1_1Message_1_1Stream.html">Stream</a> &amp;s5)</td></tr>
<tr class="separator:a441109f8ea2223e4093ad8e0d2434f6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84bfab9e290f9d67d6fc5f7c852c1107"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Message.html#a84bfab9e290f9d67d6fc5f7c852c1107">shutdown</a> ()</td></tr>
<tr class="memdesc:a84bfab9e290f9d67d6fc5f7c852c1107"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset global variables to initial states.  <a href="namespaceSawyer_1_1Message.html#a84bfab9e290f9d67d6fc5f7c852c1107">More...</a><br /></td></tr>
<tr class="separator:a84bfab9e290f9d67d6fc5f7c852c1107"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a1f2be778ddc20105e6ddca1966a62db8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSawyer_1_1Message.html#a8303ffa916b56acb3514453e07ea79b5">DestinationPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Message.html#a1f2be778ddc20105e6ddca1966a62db8">merr</a></td></tr>
<tr class="memdesc:a1f2be778ddc20105e6ddca1966a62db8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Library-provided message destination.  <a href="namespaceSawyer_1_1Message.html#a1f2be778ddc20105e6ddca1966a62db8">More...</a><br /></td></tr>
<tr class="separator:a1f2be778ddc20105e6ddca1966a62db8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26daa7a957cb93fe351393e5cc4ecfb0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Message_1_1Facility.html">Facility</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Message.html#a26daa7a957cb93fe351393e5cc4ecfb0">mlog</a></td></tr>
<tr class="memdesc:a26daa7a957cb93fe351393e5cc4ecfb0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classSawyer_1_1Message_1_1Facility.html" title="Collection of streams.">Facility</a> used by <a class="el" href="namespaceSawyer.html" title="Name space for the entire library.">Sawyer</a> components.  <a href="namespaceSawyer_1_1Message.html#a26daa7a957cb93fe351393e5cc4ecfb0">More...</a><br /></td></tr>
<tr class="separator:a26daa7a957cb93fe351393e5cc4ecfb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bb51db7d9bc62c602f6104a24231490"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Message_1_1Facilities.html">Facilities</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Message.html#a1bb51db7d9bc62c602f6104a24231490">mfacilities</a></td></tr>
<tr class="memdesc:a1bb51db7d9bc62c602f6104a24231490"><td class="mdescLeft">&#160;</td><td class="mdescRight">Library-provided facility group.  <a href="namespaceSawyer_1_1Message.html#a1bb51db7d9bc62c602f6104a24231490">More...</a><br /></td></tr>
<tr class="separator:a1bb51db7d9bc62c602f6104a24231490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bb715d1c4db66507766c1e2de522473"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Message_1_1SProxy.html">SProxy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Message.html#a7bb715d1c4db66507766c1e2de522473">assertionStream</a></td></tr>
<tr class="memdesc:a7bb715d1c4db66507766c1e2de522473"><td class="mdescLeft">&#160;</td><td class="mdescRight">The stream to be used for assertions.  <a href="namespaceSawyer_1_1Message.html#a7bb715d1c4db66507766c1e2de522473">More...</a><br /></td></tr>
<tr class="separator:a7bb715d1c4db66507766c1e2de522473"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a8303ffa916b56acb3514453e07ea79b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8303ffa916b56acb3514453e07ea79b5">&#9670;&nbsp;</a></span>DestinationPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSawyer_1_1SharedPointer.html">SharedPointer</a>&lt;class <a class="el" href="classSawyer_1_1Message_1_1Destination.html">Destination</a>&gt; <a class="el" href="namespaceSawyer_1_1Message.html#a8303ffa916b56acb3514453e07ea79b5">Sawyer::Message::DestinationPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Smart pointer. </p>
<p><a class="el" href="namespaceSawyer.html" title="Name space for the entire library.">Sawyer</a> uses reference-counting smart pointers for most objects in order to alleviate the user from having to keep track of which objects own which other objects and when it is safe to delete an object. This is especially convenient for the plumbing part of <a class="el" href="namespaceSawyer.html" title="Name space for the entire library.">Sawyer</a> where objects are connected to each other in a lattice and may have multiple parents.</p>
<p><a class="el" href="namespaceSawyer.html" title="Name space for the entire library.">Sawyer</a> uses the following conventions for objects that use smart pointers:</p>
<ol>
<li>
The name of the smart pointer type is the name of the base class followed by "Ptr". For instance, a smart pointer for the <a class="el" href="classSawyer_1_1Message_1_1FileSink.html" title="Send free-format messages to a C FILE pointer.">FileSink</a> class is named FileSinkPtr. </li>
<li>
C++ constructors for such objects are protected to that users don't inadvertently create such an object on the stack and then try to use its address in a smart pointer situation. </li>
<li>
Users should use the <code>instance</code> class methods instead of constructors to instantiate an instance of such a class. These methods allocate a new object and return a smart pointer to that object. </li>
<li>
<a class="el" href="namespaceSawyer.html" title="Name space for the entire library.">Sawyer</a> uses <a class="el" href="classSawyer_1_1SharedPointer.html">SharedPointer</a> for its smart pointer implementation. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="Message_8h_source.html#l00475">475</a> of file <a class="el" href="Message_8h_source.html">Message.h</a>.</p>

</div>
</div>
<a id="a0cae094f02d49b84081c1475b2455cf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cae094f02d49b84081c1475b2455cf6">&#9670;&nbsp;</a></span>MultiplexerPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSawyer_1_1SharedPointer.html">SharedPointer</a>&lt;class <a class="el" href="classSawyer_1_1Message_1_1Multiplexer.html">Multiplexer</a>&gt; <a class="el" href="namespaceSawyer_1_1Message.html#a0cae094f02d49b84081c1475b2455cf6">Sawyer::Message::MultiplexerPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Smart pointer. </p>
<p><a class="el" href="namespaceSawyer.html" title="Name space for the entire library.">Sawyer</a> uses reference-counting smart pointers for most objects in order to alleviate the user from having to keep track of which objects own which other objects and when it is safe to delete an object. This is especially convenient for the plumbing part of <a class="el" href="namespaceSawyer.html" title="Name space for the entire library.">Sawyer</a> where objects are connected to each other in a lattice and may have multiple parents.</p>
<p><a class="el" href="namespaceSawyer.html" title="Name space for the entire library.">Sawyer</a> uses the following conventions for objects that use smart pointers:</p>
<ol>
<li>
The name of the smart pointer type is the name of the base class followed by "Ptr". For instance, a smart pointer for the <a class="el" href="classSawyer_1_1Message_1_1FileSink.html" title="Send free-format messages to a C FILE pointer.">FileSink</a> class is named FileSinkPtr. </li>
<li>
C++ constructors for such objects are protected to that users don't inadvertently create such an object on the stack and then try to use its address in a smart pointer situation. </li>
<li>
Users should use the <code>instance</code> class methods instead of constructors to instantiate an instance of such a class. These methods allocate a new object and return a smart pointer to that object. </li>
<li>
<a class="el" href="namespaceSawyer.html" title="Name space for the entire library.">Sawyer</a> uses <a class="el" href="classSawyer_1_1SharedPointer.html">SharedPointer</a> for its smart pointer implementation. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="Message_8h_source.html#l00476">476</a> of file <a class="el" href="Message_8h_source.html">Message.h</a>.</p>

</div>
</div>
<a id="a35803acff86ce79205cb4c15c8cfc989"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35803acff86ce79205cb4c15c8cfc989">&#9670;&nbsp;</a></span>FilterPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSawyer_1_1SharedPointer.html">SharedPointer</a>&lt;class <a class="el" href="classSawyer_1_1Message_1_1Filter.html">Filter</a>&gt; <a class="el" href="namespaceSawyer_1_1Message.html#a35803acff86ce79205cb4c15c8cfc989">Sawyer::Message::FilterPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Smart pointer. </p>
<p><a class="el" href="namespaceSawyer.html" title="Name space for the entire library.">Sawyer</a> uses reference-counting smart pointers for most objects in order to alleviate the user from having to keep track of which objects own which other objects and when it is safe to delete an object. This is especially convenient for the plumbing part of <a class="el" href="namespaceSawyer.html" title="Name space for the entire library.">Sawyer</a> where objects are connected to each other in a lattice and may have multiple parents.</p>
<p><a class="el" href="namespaceSawyer.html" title="Name space for the entire library.">Sawyer</a> uses the following conventions for objects that use smart pointers:</p>
<ol>
<li>
The name of the smart pointer type is the name of the base class followed by "Ptr". For instance, a smart pointer for the <a class="el" href="classSawyer_1_1Message_1_1FileSink.html" title="Send free-format messages to a C FILE pointer.">FileSink</a> class is named FileSinkPtr. </li>
<li>
C++ constructors for such objects are protected to that users don't inadvertently create such an object on the stack and then try to use its address in a smart pointer situation. </li>
<li>
Users should use the <code>instance</code> class methods instead of constructors to instantiate an instance of such a class. These methods allocate a new object and return a smart pointer to that object. </li>
<li>
<a class="el" href="namespaceSawyer.html" title="Name space for the entire library.">Sawyer</a> uses <a class="el" href="classSawyer_1_1SharedPointer.html">SharedPointer</a> for its smart pointer implementation. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="Message_8h_source.html#l00477">477</a> of file <a class="el" href="Message_8h_source.html">Message.h</a>.</p>

</div>
</div>
<a id="a4e64c9b66c8bab0795019df0a8c35e36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e64c9b66c8bab0795019df0a8c35e36">&#9670;&nbsp;</a></span>SequenceFilterPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSawyer_1_1SharedPointer.html">SharedPointer</a>&lt;class <a class="el" href="classSawyer_1_1Message_1_1SequenceFilter.html">SequenceFilter</a>&gt; <a class="el" href="namespaceSawyer_1_1Message.html#a4e64c9b66c8bab0795019df0a8c35e36">Sawyer::Message::SequenceFilterPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Smart pointer. </p>
<p><a class="el" href="namespaceSawyer.html" title="Name space for the entire library.">Sawyer</a> uses reference-counting smart pointers for most objects in order to alleviate the user from having to keep track of which objects own which other objects and when it is safe to delete an object. This is especially convenient for the plumbing part of <a class="el" href="namespaceSawyer.html" title="Name space for the entire library.">Sawyer</a> where objects are connected to each other in a lattice and may have multiple parents.</p>
<p><a class="el" href="namespaceSawyer.html" title="Name space for the entire library.">Sawyer</a> uses the following conventions for objects that use smart pointers:</p>
<ol>
<li>
The name of the smart pointer type is the name of the base class followed by "Ptr". For instance, a smart pointer for the <a class="el" href="classSawyer_1_1Message_1_1FileSink.html" title="Send free-format messages to a C FILE pointer.">FileSink</a> class is named FileSinkPtr. </li>
<li>
C++ constructors for such objects are protected to that users don't inadvertently create such an object on the stack and then try to use its address in a smart pointer situation. </li>
<li>
Users should use the <code>instance</code> class methods instead of constructors to instantiate an instance of such a class. These methods allocate a new object and return a smart pointer to that object. </li>
<li>
<a class="el" href="namespaceSawyer.html" title="Name space for the entire library.">Sawyer</a> uses <a class="el" href="classSawyer_1_1SharedPointer.html">SharedPointer</a> for its smart pointer implementation. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="Message_8h_source.html#l00478">478</a> of file <a class="el" href="Message_8h_source.html">Message.h</a>.</p>

</div>
</div>
<a id="ad57400ce2c0ef0385e030a65662e5cb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad57400ce2c0ef0385e030a65662e5cb7">&#9670;&nbsp;</a></span>TimeFilterPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSawyer_1_1SharedPointer.html">SharedPointer</a>&lt;class <a class="el" href="classSawyer_1_1Message_1_1TimeFilter.html">TimeFilter</a>&gt; <a class="el" href="namespaceSawyer_1_1Message.html#ad57400ce2c0ef0385e030a65662e5cb7">Sawyer::Message::TimeFilterPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Smart pointer. </p>
<p><a class="el" href="namespaceSawyer.html" title="Name space for the entire library.">Sawyer</a> uses reference-counting smart pointers for most objects in order to alleviate the user from having to keep track of which objects own which other objects and when it is safe to delete an object. This is especially convenient for the plumbing part of <a class="el" href="namespaceSawyer.html" title="Name space for the entire library.">Sawyer</a> where objects are connected to each other in a lattice and may have multiple parents.</p>
<p><a class="el" href="namespaceSawyer.html" title="Name space for the entire library.">Sawyer</a> uses the following conventions for objects that use smart pointers:</p>
<ol>
<li>
The name of the smart pointer type is the name of the base class followed by "Ptr". For instance, a smart pointer for the <a class="el" href="classSawyer_1_1Message_1_1FileSink.html" title="Send free-format messages to a C FILE pointer.">FileSink</a> class is named FileSinkPtr. </li>
<li>
C++ constructors for such objects are protected to that users don't inadvertently create such an object on the stack and then try to use its address in a smart pointer situation. </li>
<li>
Users should use the <code>instance</code> class methods instead of constructors to instantiate an instance of such a class. These methods allocate a new object and return a smart pointer to that object. </li>
<li>
<a class="el" href="namespaceSawyer.html" title="Name space for the entire library.">Sawyer</a> uses <a class="el" href="classSawyer_1_1SharedPointer.html">SharedPointer</a> for its smart pointer implementation. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="Message_8h_source.html#l00479">479</a> of file <a class="el" href="Message_8h_source.html">Message.h</a>.</p>

</div>
</div>
<a id="a7073f994be93533b9b85d7f1d1afffa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7073f994be93533b9b85d7f1d1afffa5">&#9670;&nbsp;</a></span>ImportanceFilterPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSawyer_1_1SharedPointer.html">SharedPointer</a>&lt;class <a class="el" href="classSawyer_1_1Message_1_1ImportanceFilter.html">ImportanceFilter</a>&gt; <a class="el" href="namespaceSawyer_1_1Message.html#a7073f994be93533b9b85d7f1d1afffa5">Sawyer::Message::ImportanceFilterPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Smart pointer. </p>
<p><a class="el" href="namespaceSawyer.html" title="Name space for the entire library.">Sawyer</a> uses reference-counting smart pointers for most objects in order to alleviate the user from having to keep track of which objects own which other objects and when it is safe to delete an object. This is especially convenient for the plumbing part of <a class="el" href="namespaceSawyer.html" title="Name space for the entire library.">Sawyer</a> where objects are connected to each other in a lattice and may have multiple parents.</p>
<p><a class="el" href="namespaceSawyer.html" title="Name space for the entire library.">Sawyer</a> uses the following conventions for objects that use smart pointers:</p>
<ol>
<li>
The name of the smart pointer type is the name of the base class followed by "Ptr". For instance, a smart pointer for the <a class="el" href="classSawyer_1_1Message_1_1FileSink.html" title="Send free-format messages to a C FILE pointer.">FileSink</a> class is named FileSinkPtr. </li>
<li>
C++ constructors for such objects are protected to that users don't inadvertently create such an object on the stack and then try to use its address in a smart pointer situation. </li>
<li>
Users should use the <code>instance</code> class methods instead of constructors to instantiate an instance of such a class. These methods allocate a new object and return a smart pointer to that object. </li>
<li>
<a class="el" href="namespaceSawyer.html" title="Name space for the entire library.">Sawyer</a> uses <a class="el" href="classSawyer_1_1SharedPointer.html">SharedPointer</a> for its smart pointer implementation. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="Message_8h_source.html#l00480">480</a> of file <a class="el" href="Message_8h_source.html">Message.h</a>.</p>

</div>
</div>
<a id="a13a9020922f178fffacc25c8cd3e059a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13a9020922f178fffacc25c8cd3e059a">&#9670;&nbsp;</a></span>GangPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSawyer_1_1SharedPointer.html">SharedPointer</a>&lt;class <a class="el" href="classSawyer_1_1Message_1_1Gang.html">Gang</a>&gt; <a class="el" href="namespaceSawyer_1_1Message.html#a13a9020922f178fffacc25c8cd3e059a">Sawyer::Message::GangPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Smart pointer. </p>
<p><a class="el" href="namespaceSawyer.html" title="Name space for the entire library.">Sawyer</a> uses reference-counting smart pointers for most objects in order to alleviate the user from having to keep track of which objects own which other objects and when it is safe to delete an object. This is especially convenient for the plumbing part of <a class="el" href="namespaceSawyer.html" title="Name space for the entire library.">Sawyer</a> where objects are connected to each other in a lattice and may have multiple parents.</p>
<p><a class="el" href="namespaceSawyer.html" title="Name space for the entire library.">Sawyer</a> uses the following conventions for objects that use smart pointers:</p>
<ol>
<li>
The name of the smart pointer type is the name of the base class followed by "Ptr". For instance, a smart pointer for the <a class="el" href="classSawyer_1_1Message_1_1FileSink.html" title="Send free-format messages to a C FILE pointer.">FileSink</a> class is named FileSinkPtr. </li>
<li>
C++ constructors for such objects are protected to that users don't inadvertently create such an object on the stack and then try to use its address in a smart pointer situation. </li>
<li>
Users should use the <code>instance</code> class methods instead of constructors to instantiate an instance of such a class. These methods allocate a new object and return a smart pointer to that object. </li>
<li>
<a class="el" href="namespaceSawyer.html" title="Name space for the entire library.">Sawyer</a> uses <a class="el" href="classSawyer_1_1SharedPointer.html">SharedPointer</a> for its smart pointer implementation. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="Message_8h_source.html#l00481">481</a> of file <a class="el" href="Message_8h_source.html">Message.h</a>.</p>

</div>
</div>
<a id="a6f1076a1d90e2dfd1a50a3a74342d852"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f1076a1d90e2dfd1a50a3a74342d852">&#9670;&nbsp;</a></span>PrefixPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSawyer_1_1SharedPointer.html">SharedPointer</a>&lt;class <a class="el" href="classSawyer_1_1Message_1_1Prefix.html">Prefix</a>&gt; <a class="el" href="namespaceSawyer_1_1Message.html#a6f1076a1d90e2dfd1a50a3a74342d852">Sawyer::Message::PrefixPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Smart pointer. </p>
<p><a class="el" href="namespaceSawyer.html" title="Name space for the entire library.">Sawyer</a> uses reference-counting smart pointers for most objects in order to alleviate the user from having to keep track of which objects own which other objects and when it is safe to delete an object. This is especially convenient for the plumbing part of <a class="el" href="namespaceSawyer.html" title="Name space for the entire library.">Sawyer</a> where objects are connected to each other in a lattice and may have multiple parents.</p>
<p><a class="el" href="namespaceSawyer.html" title="Name space for the entire library.">Sawyer</a> uses the following conventions for objects that use smart pointers:</p>
<ol>
<li>
The name of the smart pointer type is the name of the base class followed by "Ptr". For instance, a smart pointer for the <a class="el" href="classSawyer_1_1Message_1_1FileSink.html" title="Send free-format messages to a C FILE pointer.">FileSink</a> class is named FileSinkPtr. </li>
<li>
C++ constructors for such objects are protected to that users don't inadvertently create such an object on the stack and then try to use its address in a smart pointer situation. </li>
<li>
Users should use the <code>instance</code> class methods instead of constructors to instantiate an instance of such a class. These methods allocate a new object and return a smart pointer to that object. </li>
<li>
<a class="el" href="namespaceSawyer.html" title="Name space for the entire library.">Sawyer</a> uses <a class="el" href="classSawyer_1_1SharedPointer.html">SharedPointer</a> for its smart pointer implementation. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="Message_8h_source.html#l00482">482</a> of file <a class="el" href="Message_8h_source.html">Message.h</a>.</p>

</div>
</div>
<a id="a2680d7b7c91ee2c7a2fd1497ce08c7f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2680d7b7c91ee2c7a2fd1497ce08c7f8">&#9670;&nbsp;</a></span>UnformattedSinkPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSawyer_1_1SharedPointer.html">SharedPointer</a>&lt;class <a class="el" href="classSawyer_1_1Message_1_1UnformattedSink.html">UnformattedSink</a>&gt; <a class="el" href="namespaceSawyer_1_1Message.html#a2680d7b7c91ee2c7a2fd1497ce08c7f8">Sawyer::Message::UnformattedSinkPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Smart pointer. </p>
<p><a class="el" href="namespaceSawyer.html" title="Name space for the entire library.">Sawyer</a> uses reference-counting smart pointers for most objects in order to alleviate the user from having to keep track of which objects own which other objects and when it is safe to delete an object. This is especially convenient for the plumbing part of <a class="el" href="namespaceSawyer.html" title="Name space for the entire library.">Sawyer</a> where objects are connected to each other in a lattice and may have multiple parents.</p>
<p><a class="el" href="namespaceSawyer.html" title="Name space for the entire library.">Sawyer</a> uses the following conventions for objects that use smart pointers:</p>
<ol>
<li>
The name of the smart pointer type is the name of the base class followed by "Ptr". For instance, a smart pointer for the <a class="el" href="classSawyer_1_1Message_1_1FileSink.html" title="Send free-format messages to a C FILE pointer.">FileSink</a> class is named FileSinkPtr. </li>
<li>
C++ constructors for such objects are protected to that users don't inadvertently create such an object on the stack and then try to use its address in a smart pointer situation. </li>
<li>
Users should use the <code>instance</code> class methods instead of constructors to instantiate an instance of such a class. These methods allocate a new object and return a smart pointer to that object. </li>
<li>
<a class="el" href="namespaceSawyer.html" title="Name space for the entire library.">Sawyer</a> uses <a class="el" href="classSawyer_1_1SharedPointer.html">SharedPointer</a> for its smart pointer implementation. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="Message_8h_source.html#l00483">483</a> of file <a class="el" href="Message_8h_source.html">Message.h</a>.</p>

</div>
</div>
<a id="a7dd4341bf7a8afb3b2adfe0c047a08bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dd4341bf7a8afb3b2adfe0c047a08bb">&#9670;&nbsp;</a></span>FdSinkPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSawyer_1_1SharedPointer.html">SharedPointer</a>&lt;class <a class="el" href="classSawyer_1_1Message_1_1FdSink.html">FdSink</a>&gt; <a class="el" href="namespaceSawyer_1_1Message.html#a7dd4341bf7a8afb3b2adfe0c047a08bb">Sawyer::Message::FdSinkPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Smart pointer. </p>
<p><a class="el" href="namespaceSawyer.html" title="Name space for the entire library.">Sawyer</a> uses reference-counting smart pointers for most objects in order to alleviate the user from having to keep track of which objects own which other objects and when it is safe to delete an object. This is especially convenient for the plumbing part of <a class="el" href="namespaceSawyer.html" title="Name space for the entire library.">Sawyer</a> where objects are connected to each other in a lattice and may have multiple parents.</p>
<p><a class="el" href="namespaceSawyer.html" title="Name space for the entire library.">Sawyer</a> uses the following conventions for objects that use smart pointers:</p>
<ol>
<li>
The name of the smart pointer type is the name of the base class followed by "Ptr". For instance, a smart pointer for the <a class="el" href="classSawyer_1_1Message_1_1FileSink.html" title="Send free-format messages to a C FILE pointer.">FileSink</a> class is named FileSinkPtr. </li>
<li>
C++ constructors for such objects are protected to that users don't inadvertently create such an object on the stack and then try to use its address in a smart pointer situation. </li>
<li>
Users should use the <code>instance</code> class methods instead of constructors to instantiate an instance of such a class. These methods allocate a new object and return a smart pointer to that object. </li>
<li>
<a class="el" href="namespaceSawyer.html" title="Name space for the entire library.">Sawyer</a> uses <a class="el" href="classSawyer_1_1SharedPointer.html">SharedPointer</a> for its smart pointer implementation. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="Message_8h_source.html#l00484">484</a> of file <a class="el" href="Message_8h_source.html">Message.h</a>.</p>

</div>
</div>
<a id="ae3f4919184912f94fab3ff1765cde242"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3f4919184912f94fab3ff1765cde242">&#9670;&nbsp;</a></span>FileSinkPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSawyer_1_1SharedPointer.html">SharedPointer</a>&lt;class <a class="el" href="classSawyer_1_1Message_1_1FileSink.html">FileSink</a>&gt; <a class="el" href="namespaceSawyer_1_1Message.html#ae3f4919184912f94fab3ff1765cde242">Sawyer::Message::FileSinkPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Smart pointer. </p>
<p><a class="el" href="namespaceSawyer.html" title="Name space for the entire library.">Sawyer</a> uses reference-counting smart pointers for most objects in order to alleviate the user from having to keep track of which objects own which other objects and when it is safe to delete an object. This is especially convenient for the plumbing part of <a class="el" href="namespaceSawyer.html" title="Name space for the entire library.">Sawyer</a> where objects are connected to each other in a lattice and may have multiple parents.</p>
<p><a class="el" href="namespaceSawyer.html" title="Name space for the entire library.">Sawyer</a> uses the following conventions for objects that use smart pointers:</p>
<ol>
<li>
The name of the smart pointer type is the name of the base class followed by "Ptr". For instance, a smart pointer for the <a class="el" href="classSawyer_1_1Message_1_1FileSink.html" title="Send free-format messages to a C FILE pointer.">FileSink</a> class is named FileSinkPtr. </li>
<li>
C++ constructors for such objects are protected to that users don't inadvertently create such an object on the stack and then try to use its address in a smart pointer situation. </li>
<li>
Users should use the <code>instance</code> class methods instead of constructors to instantiate an instance of such a class. These methods allocate a new object and return a smart pointer to that object. </li>
<li>
<a class="el" href="namespaceSawyer.html" title="Name space for the entire library.">Sawyer</a> uses <a class="el" href="classSawyer_1_1SharedPointer.html">SharedPointer</a> for its smart pointer implementation. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="Message_8h_source.html#l00485">485</a> of file <a class="el" href="Message_8h_source.html">Message.h</a>.</p>

</div>
</div>
<a id="ac53eb6011dde491e3543e0de105716ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac53eb6011dde491e3543e0de105716ca">&#9670;&nbsp;</a></span>StreamSinkPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSawyer_1_1SharedPointer.html">SharedPointer</a>&lt;class <a class="el" href="classSawyer_1_1Message_1_1StreamSink.html">StreamSink</a>&gt; <a class="el" href="namespaceSawyer_1_1Message.html#ac53eb6011dde491e3543e0de105716ca">Sawyer::Message::StreamSinkPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Smart pointer. </p>
<p><a class="el" href="namespaceSawyer.html" title="Name space for the entire library.">Sawyer</a> uses reference-counting smart pointers for most objects in order to alleviate the user from having to keep track of which objects own which other objects and when it is safe to delete an object. This is especially convenient for the plumbing part of <a class="el" href="namespaceSawyer.html" title="Name space for the entire library.">Sawyer</a> where objects are connected to each other in a lattice and may have multiple parents.</p>
<p><a class="el" href="namespaceSawyer.html" title="Name space for the entire library.">Sawyer</a> uses the following conventions for objects that use smart pointers:</p>
<ol>
<li>
The name of the smart pointer type is the name of the base class followed by "Ptr". For instance, a smart pointer for the <a class="el" href="classSawyer_1_1Message_1_1FileSink.html" title="Send free-format messages to a C FILE pointer.">FileSink</a> class is named FileSinkPtr. </li>
<li>
C++ constructors for such objects are protected to that users don't inadvertently create such an object on the stack and then try to use its address in a smart pointer situation. </li>
<li>
Users should use the <code>instance</code> class methods instead of constructors to instantiate an instance of such a class. These methods allocate a new object and return a smart pointer to that object. </li>
<li>
<a class="el" href="namespaceSawyer.html" title="Name space for the entire library.">Sawyer</a> uses <a class="el" href="classSawyer_1_1SharedPointer.html">SharedPointer</a> for its smart pointer implementation. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="Message_8h_source.html#l00486">486</a> of file <a class="el" href="Message_8h_source.html">Message.h</a>.</p>

</div>
</div>
<a id="aa13586a771517c835f61126e79f083d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa13586a771517c835f61126e79f083d4">&#9670;&nbsp;</a></span>SyslogSinkPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSawyer_1_1SharedPointer.html">SharedPointer</a>&lt;class <a class="el" href="classSawyer_1_1Message_1_1SyslogSink.html">SyslogSink</a>&gt; <a class="el" href="namespaceSawyer_1_1Message.html#aa13586a771517c835f61126e79f083d4">Sawyer::Message::SyslogSinkPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Smart pointer. </p>
<p><a class="el" href="namespaceSawyer.html" title="Name space for the entire library.">Sawyer</a> uses reference-counting smart pointers for most objects in order to alleviate the user from having to keep track of which objects own which other objects and when it is safe to delete an object. This is especially convenient for the plumbing part of <a class="el" href="namespaceSawyer.html" title="Name space for the entire library.">Sawyer</a> where objects are connected to each other in a lattice and may have multiple parents.</p>
<p><a class="el" href="namespaceSawyer.html" title="Name space for the entire library.">Sawyer</a> uses the following conventions for objects that use smart pointers:</p>
<ol>
<li>
The name of the smart pointer type is the name of the base class followed by "Ptr". For instance, a smart pointer for the <a class="el" href="classSawyer_1_1Message_1_1FileSink.html" title="Send free-format messages to a C FILE pointer.">FileSink</a> class is named FileSinkPtr. </li>
<li>
C++ constructors for such objects are protected to that users don't inadvertently create such an object on the stack and then try to use its address in a smart pointer situation. </li>
<li>
Users should use the <code>instance</code> class methods instead of constructors to instantiate an instance of such a class. These methods allocate a new object and return a smart pointer to that object. </li>
<li>
<a class="el" href="namespaceSawyer.html" title="Name space for the entire library.">Sawyer</a> uses <a class="el" href="classSawyer_1_1SharedPointer.html">SharedPointer</a> for its smart pointer implementation. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="Message_8h_source.html#l00487">487</a> of file <a class="el" href="Message_8h_source.html">Message.h</a>.</p>

</div>
</div>
<a id="aacd58e004be45eccc17db40fa57f9737"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacd58e004be45eccc17db40fa57f9737">&#9670;&nbsp;</a></span>BakedDestination</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::pair&lt;<a class="el" href="namespaceSawyer_1_1Message.html#a8303ffa916b56acb3514453e07ea79b5">DestinationPtr</a>, <a class="el" href="structSawyer_1_1Message_1_1MesgProps.html">MesgProps</a>&gt; <a class="el" href="namespaceSawyer_1_1Message.html#aacd58e004be45eccc17db40fa57f9737">Sawyer::Message::BakedDestination</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Baked properties for a destination. </p>
<p>Rather than recompute properties every time characters of a message are inserted into a stream, the library computes the properties just once when the first character of a message is inserted. This process is called "baking the properties" and the result is an <code>std::pair</code> that contains a destination and its baked properties. </p>

<p class="definition">Definition at line <a class="el" href="Message_8h_source.html#l00494">494</a> of file <a class="el" href="Message_8h_source.html">Message.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="abfb4d3240797db3a74bbf691f708a1c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfb4d3240797db3a74bbf691f708a1c9">&#9670;&nbsp;</a></span>Importance</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceSawyer_1_1Message.html#abfb4d3240797db3a74bbf691f708a1c9">Sawyer::Message::Importance</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Level of importance for a message. </p>
<p>The library defines only these importance levels and does not provide a mechanism by which additional levels can be added. The reasoning is that multiple message facilities should be used to subdivide universal stream of messages into smaller categories, and that message sinks should be able to expect a well defined set of importance levels.</p>
<p>The message importance symbols are sorted numerically so that more critical levels have a higher numeric value than less critical levels. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="abfb4d3240797db3a74bbf691f708a1c9af04facf962ba167db8a1e5d2b435fb93"></a>DEBUG&#160;</td><td class="fielddoc"><p>Messages intended to be useful primarily to the author of the code. </p>
<p>This level of importance is not often present in publically-released source code and serves mostly as an alternative for authors that like to debug-by-print. </p>
</td></tr>
<tr><td class="fieldname"><a id="abfb4d3240797db3a74bbf691f708a1c9a90bf0c35fdfdb66aa2a5760524878c92"></a>TRACE&#160;</td><td class="fielddoc"><p>Detailed tracing information useful to end-users that are trying to understand program internals. </p>
<p>These messages can also be thought of as debug messages that are useful to end users. Tracing occurs in two levels, where <code>TRACE</code> is the low-level tracing that includes all traceable messages. It can be assumed that if <code>TRACE</code> messages are enabled then <code>WHERE</code> messages are also enabled to provide the broader context. </p>
</td></tr>
<tr><td class="fieldname"><a id="abfb4d3240797db3a74bbf691f708a1c9af3d19c270e9071c1ce2b5f2c3f6715dd"></a>WHERE&#160;</td><td class="fielddoc"><p>Granular tracing information useful to end-users that are trying to understand program internals. </p>
<p>These can also be thought of as debug messages that are useful to end users. Tracing occurs in two levels, where <code>WHERE</code> provides a more granular overview of the trace. </p>
</td></tr>
<tr><td class="fieldname"><a id="abfb4d3240797db3a74bbf691f708a1c9a538a612c7a02e55d51e68b4dc4df21c3"></a>MARCH&#160;</td><td class="fielddoc"><p>Progress reports and other similar rapidly updating partial messages. </p>
</td></tr>
<tr><td class="fieldname"><a id="abfb4d3240797db3a74bbf691f708a1c9abaad1fa32e5fd30aad22a4dff4750e2b"></a>INFO&#160;</td><td class="fielddoc"><p>Informative messages. </p>
<p>These messages confer information that might be important but do not indicate situations that are abnormal. </p>
</td></tr>
<tr><td class="fieldname"><a id="abfb4d3240797db3a74bbf691f708a1c9a52f8e5eea9bfc070f3e0a152e3d1537a"></a>WARN&#160;</td><td class="fielddoc"><p>Warning messages that indicate an unusual situation from which the program was able to fully recover. </p>
</td></tr>
<tr><td class="fieldname"><a id="abfb4d3240797db3a74bbf691f708a1c9a85ccc0760cef2470d0c119884610d394"></a>ERROR&#160;</td><td class="fielddoc"><p><a class="el" href="classSawyer_1_1Error.html" title="Error value.">Error</a> messages that indicate an abnormal situation from which the program was able to at least partially recover. </p>
</td></tr>
<tr><td class="fieldname"><a id="abfb4d3240797db3a74bbf691f708a1c9abb7c0d080435a4a981ba171d08dc3bb7"></a>FATAL&#160;</td><td class="fielddoc"><p>Messages that indicate an abnormal situation from which the program was unable to recover. </p>
<p>Producing a message of this type does not in itself terminate the program&ndash;it merely indicates that the program is about to terminate. Since one software component's fatal error might be a calling components's recoverable error, exceptions should generally be thrown. About the only time <code>FATAL</code> is used is when a logic assertion is about to fail, and even then it's usually called from inside assert-like functions (see <a class="el" href="namespaceSawyer_1_1Assert.html" title="Run-time logic assertions.">Sawyer::Assert</a> for examples). </p>
</td></tr>
<tr><td class="fieldname"><a id="abfb4d3240797db3a74bbf691f708a1c9a16f99409d07bbe140d7b7f00c1fc7d09"></a>N_IMPORTANCE&#160;</td><td class="fielddoc"><p>Number of distinct importance levels. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Message_8h_source.html#l00313">313</a> of file <a class="el" href="Message_8h_source.html">Message.h</a>.</p>

</div>
</div>
<a id="aeac28ccbf0aa440d434d9055c7da1d15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeac28ccbf0aa440d434d9055c7da1d15">&#9670;&nbsp;</a></span>AnsiColor</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceSawyer_1_1Message.html#aeac28ccbf0aa440d434d9055c7da1d15">Sawyer::Message::AnsiColor</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Colors used by sinks that write to terminals. </p>
<p>Note that most modern terminal emulators allow the user to specify the actual colors that are displayed for each of these, so the display color might not match the color name. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aeac28ccbf0aa440d434d9055c7da1d15afa95fc3911eda269166b985e8b97f2c1"></a>COLOR_BLACK&#160;</td><td class="fielddoc"><p>ANSI "black" color. </p>
</td></tr>
<tr><td class="fieldname"><a id="aeac28ccbf0aa440d434d9055c7da1d15a6bae098067cea16895a6828ecc8cca0b"></a>COLOR_RED&#160;</td><td class="fielddoc"><p>ANSI "red" color. </p>
</td></tr>
<tr><td class="fieldname"><a id="aeac28ccbf0aa440d434d9055c7da1d15ac93de509b6ddfb5b8cb6f1183f91002b"></a>COLOR_GREEN&#160;</td><td class="fielddoc"><p>ANSI "green" color. </p>
</td></tr>
<tr><td class="fieldname"><a id="aeac28ccbf0aa440d434d9055c7da1d15a861124addc5e32c715318a473d85af9a"></a>COLOR_YELLOW&#160;</td><td class="fielddoc"><p>ANSI "yellow" color. </p>
</td></tr>
<tr><td class="fieldname"><a id="aeac28ccbf0aa440d434d9055c7da1d15ab3bbeb91a0fe7684e0818a17f72c8dc6"></a>COLOR_BLUE&#160;</td><td class="fielddoc"><p>ANSI "blue" color. </p>
</td></tr>
<tr><td class="fieldname"><a id="aeac28ccbf0aa440d434d9055c7da1d15aaec2e123aaed751da054ce111b07ff03"></a>COLOR_MAGENTA&#160;</td><td class="fielddoc"><p>ANSI "magenta" color. </p>
</td></tr>
<tr><td class="fieldname"><a id="aeac28ccbf0aa440d434d9055c7da1d15a5cb4a46d54bcd98d55a47b279724393d"></a>COLOR_CYAN&#160;</td><td class="fielddoc"><p>ANSI "cyan" color. </p>
</td></tr>
<tr><td class="fieldname"><a id="aeac28ccbf0aa440d434d9055c7da1d15aa6a4772045feb733899595ca23e22d21"></a>COLOR_WHITE&#160;</td><td class="fielddoc"><p>ANSI "white" color. </p>
</td></tr>
<tr><td class="fieldname"><a id="aeac28ccbf0aa440d434d9055c7da1d15abec1d0c20494ea043f710e69fee7b3bc"></a>COLOR_DEFAULT&#160;</td><td class="fielddoc"><p>ANSI default color. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Message_8h_source.html#l00343">343</a> of file <a class="el" href="Message_8h_source.html">Message.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a8d983cf7caef37db89d2d4aa21d78daf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d983cf7caef37db89d2d4aa21d78daf">&#9670;&nbsp;</a></span>initializeLibrary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Sawyer::Message::initializeLibrary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Explicitly initialize the library. </p>
<p>This initializes any global objects provided by the library to users. This happens automatically for many API calls, but sometimes needs to be called explicitly. Calling this after the library has already been initialized does nothing. The function always returns true.</p>
<p>Thread safety: This function is thread-safe. </p>

</div>
</div>
<a id="aea8adc425c9d3fce765576cde1a2fdc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea8adc425c9d3fce765576cde1a2fdc4">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Sawyer::Message::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structSawyer_1_1Message_1_1MesgProps.html">MesgProps</a> &amp;&#160;</td>
          <td class="paramname"><em>props</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print the values for all message properties. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSawyer_1_1Message_1_1MesgProps.html#a36580238d27fe4a0ed78e6455f9cdf01" title="Print the values for all properties.">MesgProps::print()</a>. </dd></dl>

</div>
</div>
<a id="a84bfab9e290f9d67d6fc5f7c852c1107"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84bfab9e290f9d67d6fc5f7c852c1107">&#9670;&nbsp;</a></span>shutdown()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Sawyer::Message::shutdown </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset global variables to initial states. </p>
<p>This function resets global variables such as <a class="el" href="namespaceSawyer_1_1Message.html#a1f2be778ddc20105e6ddca1966a62db8">merr</a>, <a class="el" href="namespaceSawyer_1_1Message.html#a26daa7a957cb93fe351393e5cc4ecfb0">mlog</a>, and <a class="el" href="namespaceSawyer_1_1Message.html#a1bb51db7d9bc62c602f6104a24231490">mfacilities</a> to their default-constructed state. Sometimes it's necessary to do this during program exit, otherwise the C++ runtime might terminate the <a class="el" href="namespaceSawyer_1_1Boost.html" title="Boost Graph Library API for Sawyer::Container::Boost.">Boost</a> thread synchronization library before <a class="el" href="namespaceSawyer.html" title="Name space for the entire library.">Sawyer</a>, which leads to exceptions or segmentation faults when <a class="el" href="namespaceSawyer.html" title="Name space for the entire library.">Sawyer</a>'s stream destructors run. In fact, <a class="el" href="namespaceSawyer_1_1Message.html#a8d983cf7caef37db89d2d4aa21d78daf">initializeLibrary</a> arranges for this shutdown function to be called by exit. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a1f2be778ddc20105e6ddca1966a62db8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f2be778ddc20105e6ddca1966a62db8">&#9670;&nbsp;</a></span>merr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSawyer_1_1Message.html#a8303ffa916b56acb3514453e07ea79b5">DestinationPtr</a> Sawyer::Message::merr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Library-provided message destination. </p>
<p>This is the top of a lattice that sends all messages to file descriptor 2, which is usually standard error. </p>

</div>
</div>
<a id="a26daa7a957cb93fe351393e5cc4ecfb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26daa7a957cb93fe351393e5cc4ecfb0">&#9670;&nbsp;</a></span>mlog</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Message_1_1Facility.html">Facility</a> Sawyer::Message::mlog</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classSawyer_1_1Message_1_1Facility.html" title="Collection of streams.">Facility</a> used by <a class="el" href="namespaceSawyer.html" title="Name space for the entire library.">Sawyer</a> components. </p>
<p>This facility is added to the <a class="el" href="namespaceSawyer_1_1Message.html#a1bb51db7d9bc62c602f6104a24231490">mfacilities</a> group with the name "sawyer". </p>

<p class="reference">Referenced by <a class="el" href="CommandLineBoost_8h_source.html#l00106">Sawyer::CommandLine::Boost::command_line_parser::command_line_parser()</a>.</p>

</div>
</div>
<a id="a1bb51db7d9bc62c602f6104a24231490"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bb51db7d9bc62c602f6104a24231490">&#9670;&nbsp;</a></span>mfacilities</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Message_1_1Facilities.html">Facilities</a> Sawyer::Message::mfacilities</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Library-provided facility group. </p>
<p>When the library is initialized, this group contains only <a class="el" href="namespaceSawyer_1_1Message.html#a26daa7a957cb93fe351393e5cc4ecfb0">mlog</a> with the name "sawyer". Users are free to manipulate this facility however they choose, and if everyone uses this group then all the facilities across all users can be controlled from this one place. </p>

</div>
</div>
<a id="a7bb715d1c4db66507766c1e2de522473"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bb715d1c4db66507766c1e2de522473">&#9670;&nbsp;</a></span>assertionStream</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Message_1_1SProxy.html">SProxy</a> Sawyer::Message::assertionStream</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The stream to be used for assertions. </p>
<p>The default is to use <code><a class="el" href="namespaceSawyer_1_1Message.html#a26daa7a957cb93fe351393e5cc4ecfb0" title="Facility used by Sawyer components.">Sawyer::Message::mlog</a>[FATAL]</code>. This variable is initialized at the first call to <a class="el" href="namespaceSawyer_1_1Assert.html#a185766b790e1a467b609b9009e0c8984">Assert::fail</a> if it is a null pointer. Users can assign a different stream to it any time before then:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[]) {</div>
<div class="line">    <a class="code" href="namespaceSawyer_1_1Message.html#a7bb715d1c4db66507766c1e2de522473">Sawyer::Message::assertionStream</a> = Sawer::Message::mlog[<a class="code" href="namespaceSawyer_1_1Message.html#abfb4d3240797db3a74bbf691f708a1c9abb7c0d080435a4a981ba171d08dc3bb7">FATAL</a>];</div>
</div><!-- fragment --> 
</div>
</div>
</div><!-- contents -->
<div class="ttc" id="aclassSawyer_1_1Message_1_1FdSink_html_abbb5db08a5db5f91eb1750b832b217bd"><div class="ttname"><a href="classSawyer_1_1Message_1_1FdSink.html#abbb5db08a5db5f91eb1750b832b217bd">Sawyer::Message::FdSink::instance</a></div><div class="ttdeci">static FdSinkPtr instance(int fd, const PrefixPtr &amp;prefix=PrefixPtr())</div><div class="ttdoc">Allocating constructor.</div><div class="ttdef"><b>Definition:</b> <a href="Message_8h_source.html#l01297">Message.h:1297</a></div></div>
<div class="ttc" id="anamespaceSawyer_1_1Message_html_a1bb51db7d9bc62c602f6104a24231490"><div class="ttname"><a href="namespaceSawyer_1_1Message.html#a1bb51db7d9bc62c602f6104a24231490">Sawyer::Message::mfacilities</a></div><div class="ttdeci">Facilities mfacilities</div><div class="ttdoc">Library-provided facility group.</div></div>
<div class="ttc" id="anamespaceSawyer_1_1Message_html_a26daa7a957cb93fe351393e5cc4ecfb0"><div class="ttname"><a href="namespaceSawyer_1_1Message.html#a26daa7a957cb93fe351393e5cc4ecfb0">Sawyer::Message::mlog</a></div><div class="ttdeci">Facility mlog</div><div class="ttdoc">Facility used by Sawyer components.</div></div>
<div class="ttc" id="aclassSawyer_1_1Message_1_1Facilities_html_adc22eb086e579c24720a99d157c601dc"><div class="ttname"><a href="classSawyer_1_1Message_1_1Facilities.html#adc22eb086e579c24720a99d157c601dc">Sawyer::Message::Facilities::insert</a></div><div class="ttdeci">Facilities &amp; insert(Facility &amp;facility, const std::string &amp;name=&quot;&quot;)</div><div class="ttdoc">Register a facility so it can be controlled as part of a collection of facilities.</div></div>
<div class="ttc" id="anamespaceSawyer_1_1Message_html_abfb4d3240797db3a74bbf691f708a1c9af04facf962ba167db8a1e5d2b435fb93"><div class="ttname"><a href="namespaceSawyer_1_1Message.html#abfb4d3240797db3a74bbf691f708a1c9af04facf962ba167db8a1e5d2b435fb93">Sawyer::Message::DEBUG</a></div><div class="ttdeci">@ DEBUG</div><div class="ttdoc">Messages intended to be useful primarily to the author of the code.</div><div class="ttdef"><b>Definition:</b> <a href="Message_8h_source.html#l00314">Message.h:314</a></div></div>
<div class="ttc" id="anamespaceSawyer_1_1Message_html_a8303ffa916b56acb3514453e07ea79b5"><div class="ttname"><a href="namespaceSawyer_1_1Message.html#a8303ffa916b56acb3514453e07ea79b5">Sawyer::Message::DestinationPtr</a></div><div class="ttdeci">SharedPointer&lt; class Destination &gt; DestinationPtr</div><div class="ttdoc">Smart pointer.</div><div class="ttdef"><b>Definition:</b> <a href="Message_8h_source.html#l00475">Message.h:475</a></div></div>
<div class="ttc" id="anamespaceSawyer_1_1Message_html_a7bb715d1c4db66507766c1e2de522473"><div class="ttname"><a href="namespaceSawyer_1_1Message.html#a7bb715d1c4db66507766c1e2de522473">Sawyer::Message::assertionStream</a></div><div class="ttdeci">SProxy assertionStream</div><div class="ttdoc">The stream to be used for assertions.</div></div>
<div class="ttc" id="aclassSawyer_1_1Message_1_1Facility_html_a9a75fb6cc458056c6c96af39927f4c4d"><div class="ttname"><a href="classSawyer_1_1Message_1_1Facility.html#a9a75fb6cc458056c6c96af39927f4c4d">Sawyer::Message::Facility::initStreams</a></div><div class="ttdeci">Facility &amp; initStreams(const DestinationPtr &amp;)</div><div class="ttdoc">Cause all streams to use the specified destination.</div></div>
<div class="ttc" id="anamespaceSawyer_1_1Message_html_abfb4d3240797db3a74bbf691f708a1c9abb7c0d080435a4a981ba171d08dc3bb7"><div class="ttname"><a href="namespaceSawyer_1_1Message.html#abfb4d3240797db3a74bbf691f708a1c9abb7c0d080435a4a981ba171d08dc3bb7">Sawyer::Message::FATAL</a></div><div class="ttdeci">@ FATAL</div><div class="ttdoc">Messages that indicate an abnormal situation from which the program was unable to recover.</div><div class="ttdef"><b>Definition:</b> <a href="Message_8h_source.html#l00332">Message.h:332</a></div></div>
<div class="ttc" id="anamespaceSawyer_1_1Message_html_abfb4d3240797db3a74bbf691f708a1c9abaad1fa32e5fd30aad22a4dff4750e2b"><div class="ttname"><a href="namespaceSawyer_1_1Message.html#abfb4d3240797db3a74bbf691f708a1c9abaad1fa32e5fd30aad22a4dff4750e2b">Sawyer::Message::INFO</a></div><div class="ttdeci">@ INFO</div><div class="ttdoc">Informative messages.</div><div class="ttdef"><b>Definition:</b> <a href="Message_8h_source.html#l00326">Message.h:326</a></div></div>
<div class="ttc" id="aclassSawyer_1_1Message_1_1Multiplexer_html_a144a5a8a7c1695cdc804701ea93c17cb"><div class="ttname"><a href="classSawyer_1_1Message_1_1Multiplexer.html#a144a5a8a7c1695cdc804701ea93c17cb">Sawyer::Message::Multiplexer::instance</a></div><div class="ttdeci">static MultiplexerPtr instance()</div><div class="ttdoc">Allocating constructor.</div><div class="ttdef"><b>Definition:</b> <a href="Message_8h_source.html#l00679">Message.h:679</a></div></div>
<div class="ttc" id="anamespaceRose_1_1Diagnostics_html_a1ba0507284dc0ed4bf22f0a5f3fe5ac4"><div class="ttname"><a href="namespaceRose_1_1Diagnostics.html#a1ba0507284dc0ed4bf22f0a5f3fe5ac4">Rose::Diagnostics::destination</a></div><div class="ttdeci">ROSE_DLL_API Sawyer::Message::DestinationPtr destination</div><div class="ttdoc">Default destination for ROSE diagnostics.</div></div>
<div class="ttc" id="aclassSawyer_1_1Message_1_1Facility_html"><div class="ttname"><a href="classSawyer_1_1Message_1_1Facility.html">Sawyer::Message::Facility</a></div><div class="ttdoc">Collection of streams.</div><div class="ttdef"><b>Definition:</b> <a href="Message_8h_source.html#l01606">Message.h:1606</a></div></div>
<div class="ttc" id="aclassSawyer_1_1Message_1_1FileSink_html_a528adad7bdb18a8ff5cbfa6b3d604d83"><div class="ttname"><a href="classSawyer_1_1Message_1_1FileSink.html#a528adad7bdb18a8ff5cbfa6b3d604d83">Sawyer::Message::FileSink::instance</a></div><div class="ttdeci">static FileSinkPtr instance(FILE *f, const PrefixPtr &amp;prefix=PrefixPtr())</div><div class="ttdoc">Allocating constructor.</div><div class="ttdef"><b>Definition:</b> <a href="Message_8h_source.html#l01314">Message.h:1314</a></div></div>
<div class="ttc" id="anamespaceSawyer_1_1Message_html"><div class="ttname"><a href="namespaceSawyer_1_1Message.html">Sawyer::Message</a></div><div class="ttdoc">Formatted diagnostic messages emitted to various backends.</div><div class="ttdef"><b>Definition:</b> <a href="Message_8h_source.html#l00276">Message.h:276</a></div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Dec 19 2022 23:40:28 for ROSE by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
