<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROSE: StaticSingleAssignment Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="ROSE"/>
<link href="roseDoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ROSE
   &#160;<span id="projectnumber">0.11.96.11</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,true,'search.html','Search');
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classStaticSingleAssignment-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">StaticSingleAssignment Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>Static single assignment analysis. </p>
<p>Contains all the functionality to implement variable renaming on a given program. For this class, we do not actually transform the AST directly, rather we perform the analysis and add attributes to the AST nodes so that later optimizations can access the results of this analysis while still preserving the original AST. </p>

<p class="definition">Definition at line <a class="el" href="staticSingleAssignment_8h_source.html#l00100">100</a> of file <a class="el" href="staticSingleAssignment_8h_source.html">staticSingleAssignment.h</a>.</p>
</div>
<p><code>#include &lt;<a class="el" href="staticSingleAssignment_8h_source.html">staticSingleAssignment.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for StaticSingleAssignment:</div>
<div class="dyncontent">
<div class="center"><img src="classStaticSingleAssignment__coll__graph.png" border="0" usemap="#StaticSingleAssignment_coll__map" alt="Collaboration graph"/></div>
<map name="StaticSingleAssignment_coll__map" id="StaticSingleAssignment_coll__map">
<area shape="rect" title="Static single assignment analysis." alt="" coords="8,109,169,136"/>
<area shape="rect" title=" " alt="" coords="5,5,172,47"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ac331e1110ecdbb40e8efee09b0284862"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="classSgInitializedName.html">SgInitializedName</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#ac331e1110ecdbb40e8efee09b0284862">VarName</a></td></tr>
<tr class="memdesc:ac331e1110ecdbb40e8efee09b0284862"><td class="mdescLeft">&#160;</td><td class="mdescRight">A compound variable name as used by the variable renaming.  <a href="classStaticSingleAssignment.html#ac331e1110ecdbb40e8efee09b0284862">More...</a><br /></td></tr>
<tr class="separator:ac331e1110ecdbb40e8efee09b0284862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcb347322834917dd31dd57af44001f8"><td class="memItemLeft" align="right" valign="top">typedef boost::unordered_map&lt; <a class="el" href="classSgNode.html">SgNode</a> *, std::set&lt; <a class="el" href="classStaticSingleAssignment.html#ac331e1110ecdbb40e8efee09b0284862">VarName</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#adcb347322834917dd31dd57af44001f8">LocalDefUseTable</a></td></tr>
<tr class="memdesc:adcb347322834917dd31dd57af44001f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes the defs or uses at each node.  <a href="classStaticSingleAssignment.html#adcb347322834917dd31dd57af44001f8">More...</a><br /></td></tr>
<tr class="separator:adcb347322834917dd31dd57af44001f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac26931d0a5d15d7f85913020563f9dd7"><td class="memItemLeft" align="right" valign="top">typedef FilteredCFGNode&lt; <a class="el" href="structssa__private_1_1DataflowCfgFilter.html">ssa_private::DataflowCfgFilter</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#ac26931d0a5d15d7f85913020563f9dd7">FilteredCfgNode</a></td></tr>
<tr class="memdesc:ac26931d0a5d15d7f85913020563f9dd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">A filtered CFGNode that is used for DefUse traversal.  <a href="classStaticSingleAssignment.html#ac26931d0a5d15d7f85913020563f9dd7">More...</a><br /></td></tr>
<tr class="separator:ac26931d0a5d15d7f85913020563f9dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaff056020ff2698604fdec2296405e8b"><td class="memItemLeft" align="right" valign="top">typedef FilteredCFGEdge&lt; <a class="el" href="structssa__private_1_1DataflowCfgFilter.html">ssa_private::DataflowCfgFilter</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#aaff056020ff2698604fdec2296405e8b">FilteredCfgEdge</a></td></tr>
<tr class="memdesc:aaff056020ff2698604fdec2296405e8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A filtered CFGEdge that is used for DefUse traversal.  <a href="classStaticSingleAssignment.html#aaff056020ff2698604fdec2296405e8b">More...</a><br /></td></tr>
<tr class="separator:aaff056020ff2698604fdec2296405e8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75967eb37074af951e85ad1142755b08"><td class="memItemLeft" align="right" valign="top"><a id="a75967eb37074af951e85ad1142755b08"></a>
typedef boost::shared_ptr&lt; <a class="el" href="classReachingDef.html">ReachingDef</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ReachingDefPtr</b></td></tr>
<tr class="separator:a75967eb37074af951e85ad1142755b08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa867994c56b8018439d2cc95d8ef4981"><td class="memItemLeft" align="right" valign="top"><a id="aa867994c56b8018439d2cc95d8ef4981"></a>
typedef std::map&lt; <a class="el" href="classStaticSingleAssignment.html#ac331e1110ecdbb40e8efee09b0284862">VarName</a>, ReachingDefPtr &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#aa867994c56b8018439d2cc95d8ef4981">NodeReachingDefTable</a></td></tr>
<tr class="memdesc:aa867994c56b8018439d2cc95d8ef4981"><td class="mdescLeft">&#160;</td><td class="mdescRight">A map from each variable to its reaching definitions at the current node. <br /></td></tr>
<tr class="separator:aa867994c56b8018439d2cc95d8ef4981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa29c315fbca6973d875f6832b62589f"><td class="memItemLeft" align="right" valign="top">typedef boost::unordered_map&lt; <a class="el" href="classSgNode.html">SgNode</a> *, std::pair&lt; <a class="el" href="classStaticSingleAssignment.html#aa867994c56b8018439d2cc95d8ef4981">NodeReachingDefTable</a>, <a class="el" href="classStaticSingleAssignment.html#aa867994c56b8018439d2cc95d8ef4981">NodeReachingDefTable</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#aaa29c315fbca6973d875f6832b62589f">GlobalReachingDefTable</a></td></tr>
<tr class="memdesc:aaa29c315fbca6973d875f6832b62589f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The first table is the IN table.  <a href="classStaticSingleAssignment.html#aaa29c315fbca6973d875f6832b62589f">More...</a><br /></td></tr>
<tr class="separator:aaa29c315fbca6973d875f6832b62589f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9b42c79b83b951b9e29efc06a4e3bdb"><td class="memItemLeft" align="right" valign="top"><a id="ab9b42c79b83b951b9e29efc06a4e3bdb"></a>
typedef boost::unordered_map&lt; <a class="el" href="classSgNode.html">SgNode</a> *, <a class="el" href="classStaticSingleAssignment.html#aa867994c56b8018439d2cc95d8ef4981">NodeReachingDefTable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#ab9b42c79b83b951b9e29efc06a4e3bdb">UseTable</a></td></tr>
<tr class="memdesc:ab9b42c79b83b951b9e29efc06a4e3bdb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classMap.html" title="Extends std::map with methods that return optional values.">Map</a> from each node to the variables used at that node and their reaching definitions. <br /></td></tr>
<tr class="separator:ab9b42c79b83b951b9e29efc06a4e3bdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae66caa726cd1fd2741b71e015f383d55"><td class="memItemLeft" align="right" valign="top"><a id="ae66caa726cd1fd2741b71e015f383d55"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>StaticSingleAssignment</b> (<a class="el" href="classSgProject.html">SgProject</a> *proj)</td></tr>
<tr class="separator:ae66caa726cd1fd2741b71e015f383d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7340f93af9c35d8231170dac4fdea47c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#a7340f93af9c35d8231170dac4fdea47c">run</a> (bool interprocedural, bool treatPointersAsStructures)</td></tr>
<tr class="memdesc:a7340f93af9c35d8231170dac4fdea47c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run the analysis.  <a href="classStaticSingleAssignment.html#a7340f93af9c35d8231170dac4fdea47c">More...</a><br /></td></tr>
<tr class="separator:a7340f93af9c35d8231170dac4fdea47c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae22322f55e06b7df73fb590f0f748020"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#ae22322f55e06b7df73fb590f0f748020">toDOT</a> (const std::string fileName)</td></tr>
<tr class="memdesc:ae22322f55e06b7df73fb590f0f748020"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the CFG with any UniqueNames and Def/Use information visible.  <a href="classStaticSingleAssignment.html#ae22322f55e06b7df73fb590f0f748020">More...</a><br /></td></tr>
<tr class="separator:ae22322f55e06b7df73fb590f0f748020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9774845d765b66e68b9016666f75cbaa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#a9774845d765b66e68b9016666f75cbaa">toFilteredDOT</a> (const std::string fileName)</td></tr>
<tr class="memdesc:a9774845d765b66e68b9016666f75cbaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the CFG with any UniqueNames and Def/Use information visible.  <a href="classStaticSingleAssignment.html#a9774845d765b66e68b9016666f75cbaa">More...</a><br /></td></tr>
<tr class="separator:a9774845d765b66e68b9016666f75cbaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae89656a0ff151efb144bd571106b0fb8"><td class="memItemLeft" align="right" valign="top"><a id="ae89656a0ff151efb144bd571106b0fb8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>printOriginalDefs</b> (<a class="el" href="classSgNode.html">SgNode</a> *node)</td></tr>
<tr class="separator:ae89656a0ff151efb144bd571106b0fb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c2b0e5f5ed7a787a417a72097b5a732"><td class="memItemLeft" align="right" valign="top"><a id="a9c2b0e5f5ed7a787a417a72097b5a732"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>printOriginalDefTable</b> ()</td></tr>
<tr class="separator:a9c2b0e5f5ed7a787a417a72097b5a732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a73c5246f974e2a72e9df0fa25ebf9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classStaticSingleAssignment.html#adcb347322834917dd31dd57af44001f8">LocalDefUseTable</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#a9a73c5246f974e2a72e9df0fa25ebf9a">getOriginalDefTable</a> ()</td></tr>
<tr class="memdesc:a9a73c5246f974e2a72e9df0fa25ebf9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the table of definitions for every node.  <a href="classStaticSingleAssignment.html#a9a73c5246f974e2a72e9df0fa25ebf9a">More...</a><br /></td></tr>
<tr class="separator:a9a73c5246f974e2a72e9df0fa25ebf9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ab457322cb1f1c3031b82b9643f8b4f"><td class="memItemLeft" align="right" valign="top"><a id="a8ab457322cb1f1c3031b82b9643f8b4f"></a>
<a class="el" href="classStaticSingleAssignment.html#adcb347322834917dd31dd57af44001f8">LocalDefUseTable</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getLocalUsesTable</b> ()</td></tr>
<tr class="separator:a8ab457322cb1f1c3031b82b9643f8b4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a849b955426161fb016bc28c1f840726f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classStaticSingleAssignment.html#aa867994c56b8018439d2cc95d8ef4981">NodeReachingDefTable</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#a849b955426161fb016bc28c1f840726f">getOutgoingDefsAtNode</a> (<a class="el" href="classSgNode.html">SgNode</a> *node) const</td></tr>
<tr class="memdesc:a849b955426161fb016bc28c1f840726f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the definitions of all the variables right after the given node has executed.  <a href="classStaticSingleAssignment.html#a849b955426161fb016bc28c1f840726f">More...</a><br /></td></tr>
<tr class="separator:a849b955426161fb016bc28c1f840726f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1de1194e93b1201af57976c2b67339b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classStaticSingleAssignment.html#aa867994c56b8018439d2cc95d8ef4981">NodeReachingDefTable</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#ac1de1194e93b1201af57976c2b67339b">getReachingDefsAtNode_</a> (<a class="el" href="classSgNode.html">SgNode</a> *node) const</td></tr>
<tr class="memdesc:ac1de1194e93b1201af57976c2b67339b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the definitions of all the variables immediately before the given node has executed.  <a href="classStaticSingleAssignment.html#ac1de1194e93b1201af57976c2b67339b">More...</a><br /></td></tr>
<tr class="separator:ac1de1194e93b1201af57976c2b67339b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae52c0d0571e9ebd340b26386db0df2c4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classStaticSingleAssignment.html#aa867994c56b8018439d2cc95d8ef4981">NodeReachingDefTable</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#ae52c0d0571e9ebd340b26386db0df2c4">getUsesAtNode</a> (<a class="el" href="classSgNode.html">SgNode</a> *node) const</td></tr>
<tr class="memdesc:ae52c0d0571e9ebd340b26386db0df2c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of all the variables used at this node.  <a href="classStaticSingleAssignment.html#ae52c0d0571e9ebd340b26386db0df2c4">More...</a><br /></td></tr>
<tr class="separator:ae52c0d0571e9ebd340b26386db0df2c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc3b52c524bcdbe1698f59214319bde0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classStaticSingleAssignment.html#aa867994c56b8018439d2cc95d8ef4981">NodeReachingDefTable</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#abc3b52c524bcdbe1698f59214319bde0">getDefsAtNode</a> (<a class="el" href="classSgNode.html">SgNode</a> *node) const</td></tr>
<tr class="memdesc:abc3b52c524bcdbe1698f59214319bde0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of all the variables defined at the given node.  <a href="classStaticSingleAssignment.html#abc3b52c524bcdbe1698f59214319bde0">More...</a><br /></td></tr>
<tr class="separator:abc3b52c524bcdbe1698f59214319bde0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaaf056f70686973e0e286c8c7226c2e"><td class="memItemLeft" align="right" valign="top"><a id="afaaf056f70686973e0e286c8c7226c2e"></a>
std::set&lt; <a class="el" href="classStaticSingleAssignment.html#ac331e1110ecdbb40e8efee09b0284862">VarName</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#afaaf056f70686973e0e286c8c7226c2e">getVarsUsedInSubtree</a> (<a class="el" href="classSgNode.html">SgNode</a> *root) const</td></tr>
<tr class="memdesc:afaaf056f70686973e0e286c8c7226c2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a set of all the variables names that have uses in the subtree. <br /></td></tr>
<tr class="separator:afaaf056f70686973e0e286c8c7226c2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a760d8e04c3c3765a9a97f94c4d74d545"><td class="memItemLeft" align="right" valign="top"><a id="a760d8e04c3c3765a9a97f94c4d74d545"></a>
std::set&lt; <a class="el" href="classStaticSingleAssignment.html#ac331e1110ecdbb40e8efee09b0284862">VarName</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#a760d8e04c3c3765a9a97f94c4d74d545">getVarsDefinedInSubtree</a> (<a class="el" href="classSgNode.html">SgNode</a> *root) const</td></tr>
<tr class="memdesc:a760d8e04c3c3765a9a97f94c4d74d545"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a node, traverses all its children in the AST and collects all the variable names that have definitions in the subtree. <br /></td></tr>
<tr class="separator:a760d8e04c3c3765a9a97f94c4d74d545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f967369c7be8ddfd24bf85381d01506"><td class="memItemLeft" align="right" valign="top">std::set&lt; <a class="el" href="classStaticSingleAssignment.html#ac331e1110ecdbb40e8efee09b0284862">VarName</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#a6f967369c7be8ddfd24bf85381d01506">getOriginalVarsDefinedInSubtree</a> (<a class="el" href="classSgNode.html">SgNode</a> *root) const</td></tr>
<tr class="memdesc:a6f967369c7be8ddfd24bf85381d01506"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a node, traverses all its children in the AST and collects all the variable names that have original definitions in the subtree.  <a href="classStaticSingleAssignment.html#a6f967369c7be8ddfd24bf85381d01506">More...</a><br /></td></tr>
<tr class="separator:a6f967369c7be8ddfd24bf85381d01506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add0647a7406e082c34837c5d6befeb88"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classStaticSingleAssignment.html#aa867994c56b8018439d2cc95d8ef4981">NodeReachingDefTable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#add0647a7406e082c34837c5d6befeb88">getLastVersions</a> (<a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> *func) const</td></tr>
<tr class="memdesc:add0647a7406e082c34837c5d6befeb88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last encountered definition of every variable.  <a href="classStaticSingleAssignment.html#add0647a7406e082c34837c5d6befeb88">More...</a><br /></td></tr>
<tr class="separator:add0647a7406e082c34837c5d6befeb88"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a8d0b08bd7c2d47df3f932e4f9730ef4a"><td class="memItemLeft" align="right" valign="top"><a id="a8d0b08bd7c2d47df3f932e4f9730ef4a"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>getDebug</b> ()</td></tr>
<tr class="separator:a8d0b08bd7c2d47df3f932e4f9730ef4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c2fb246c830ac4f68a16f64d7b50f6b"><td class="memItemLeft" align="right" valign="top"><a id="a8c2fb246c830ac4f68a16f64d7b50f6b"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>getDebugExtra</b> ()</td></tr>
<tr class="separator:a8c2fb246c830ac4f68a16f64d7b50f6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad431a7db92fca6b44e362d4a4cc380c4"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#ad431a7db92fca6b44e362d4a4cc380c4">isPrefixOfName</a> (<a class="el" href="classStaticSingleAssignment.html#ac331e1110ecdbb40e8efee09b0284862">VarName</a> name, <a class="el" href="classStaticSingleAssignment.html#ac331e1110ecdbb40e8efee09b0284862">VarName</a> prefix)</td></tr>
<tr class="memdesc:ad431a7db92fca6b44e362d4a4cc380c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find if the given prefix is a prefix of the given name.  <a href="classStaticSingleAssignment.html#ad431a7db92fca6b44e362d4a4cc380c4">More...</a><br /></td></tr>
<tr class="separator:ad431a7db92fca6b44e362d4a4cc380c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35267ee8644b19fca8cc573649fbb24b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classssa__private_1_1VarUniqueName.html">ssa_private::VarUniqueName</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#a35267ee8644b19fca8cc573649fbb24b">getUniqueName</a> (<a class="el" href="classSgNode.html">SgNode</a> *node)</td></tr>
<tr class="memdesc:a35267ee8644b19fca8cc573649fbb24b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the uniqueName attribute for the given node.  <a href="classStaticSingleAssignment.html#a35267ee8644b19fca8cc573649fbb24b">More...</a><br /></td></tr>
<tr class="separator:a35267ee8644b19fca8cc573649fbb24b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a976474bbfc0366540c0ca8ef0dab77d3"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classStaticSingleAssignment.html#ac331e1110ecdbb40e8efee09b0284862">VarName</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#a976474bbfc0366540c0ca8ef0dab77d3">getVarName</a> (<a class="el" href="classSgNode.html">SgNode</a> *node)</td></tr>
<tr class="memdesc:a976474bbfc0366540c0ca8ef0dab77d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the variable name of the given node.  <a href="classStaticSingleAssignment.html#a976474bbfc0366540c0ca8ef0dab77d3">More...</a><br /></td></tr>
<tr class="separator:a976474bbfc0366540c0ca8ef0dab77d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e4b36e017885f616cd6b391c5205f8"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classStaticSingleAssignment.html#ac331e1110ecdbb40e8efee09b0284862">VarName</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#ac0e4b36e017885f616cd6b391c5205f8">getVarForExpression</a> (<a class="el" href="classSgNode.html">SgNode</a> *node)</td></tr>
<tr class="memdesc:ac0e4b36e017885f616cd6b391c5205f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">If an expression evaluates to a reference of a variable, returns that variable.  <a href="classStaticSingleAssignment.html#ac0e4b36e017885f616cd6b391c5205f8">More...</a><br /></td></tr>
<tr class="separator:ac0e4b36e017885f616cd6b391c5205f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28ce0ed01016c6dea58c6be900d95d63"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSgExpression.html">SgExpression</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#a28ce0ed01016c6dea58c6be900d95d63">buildVariableReference</a> (const <a class="el" href="classStaticSingleAssignment.html#ac331e1110ecdbb40e8efee09b0284862">VarName</a> &amp;var, <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *scope=NULL)</td></tr>
<tr class="memdesc:a28ce0ed01016c6dea58c6be900d95d63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an AST fragment containing the appropriate varRefs and Dot/Arrow ops to access the given variable.  <a href="classStaticSingleAssignment.html#a28ce0ed01016c6dea58c6be900d95d63">More...</a><br /></td></tr>
<tr class="separator:a28ce0ed01016c6dea58c6be900d95d63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25e6ba89f1da6252d4518d73d091e4be"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#a25e6ba89f1da6252d4518d73d091e4be">isVarInScope</a> (const <a class="el" href="classStaticSingleAssignment.html#ac331e1110ecdbb40e8efee09b0284862">VarName</a> &amp;var, <a class="el" href="classSgNode.html">SgNode</a> *scope)</td></tr>
<tr class="memdesc:a25e6ba89f1da6252d4518d73d091e4be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the scope of the given node, and returns true if the given variable is accessible there.  <a href="classStaticSingleAssignment.html#a25e6ba89f1da6252d4518d73d091e4be">More...</a><br /></td></tr>
<tr class="separator:a25e6ba89f1da6252d4518d73d091e4be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a019e51da21fd909ef647f9692239751c"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#a019e51da21fd909ef647f9692239751c">varnameToString</a> (const <a class="el" href="classStaticSingleAssignment.html#ac331e1110ecdbb40e8efee09b0284862">VarName</a> &amp;vec)</td></tr>
<tr class="memdesc:a019e51da21fd909ef647f9692239751c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string representation of a varName.  <a href="classStaticSingleAssignment.html#a019e51da21fd909ef647f9692239751c">More...</a><br /></td></tr>
<tr class="separator:a019e51da21fd909ef647f9692239751c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae782076117cc18412c3f276bd144ef33"><td class="memItemLeft" align="right" valign="top"><a id="ae782076117cc18412c3f276bd144ef33"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>printLocalDefUseTable</b> (const <a class="el" href="classStaticSingleAssignment.html#adcb347322834917dd31dd57af44001f8">LocalDefUseTable</a> &amp;table)</td></tr>
<tr class="separator:ae782076117cc18412c3f276bd144ef33"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a56caa76396dd2ecaa37fddfbd441c228"><td class="memItemLeft" align="right" valign="top"><a id="a56caa76396dd2ecaa37fddfbd441c228"></a>
static <a class="el" href="classStaticSingleAssignment.html#ac331e1110ecdbb40e8efee09b0284862">VarName</a>&#160;</td><td class="memItemRight" valign="bottom"><b>emptyName</b></td></tr>
<tr class="separator:a56caa76396dd2ecaa37fddfbd441c228"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ac331e1110ecdbb40e8efee09b0284862"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac331e1110ecdbb40e8efee09b0284862">&#9670;&nbsp;</a></span>VarName</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="classSgInitializedName.html">SgInitializedName</a>*&gt; <a class="el" href="classStaticSingleAssignment.html#ac331e1110ecdbb40e8efee09b0284862">StaticSingleAssignment::VarName</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A compound variable name as used by the variable renaming. </p>
<p><br  />
 </p>

<p class="definition">Definition at line <a class="el" href="staticSingleAssignment_8h_source.html#l00109">109</a> of file <a class="el" href="staticSingleAssignment_8h_source.html">staticSingleAssignment.h</a>.</p>

</div>
</div>
<a id="adcb347322834917dd31dd57af44001f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcb347322834917dd31dd57af44001f8">&#9670;&nbsp;</a></span>LocalDefUseTable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::unordered_map&lt;<a class="el" href="classSgNode.html">SgNode</a>*, std::set&lt;<a class="el" href="classStaticSingleAssignment.html#ac331e1110ecdbb40e8efee09b0284862">VarName</a>&gt; &gt; <a class="el" href="classStaticSingleAssignment.html#adcb347322834917dd31dd57af44001f8">StaticSingleAssignment::LocalDefUseTable</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Describes the defs or uses at each node. </p>
<p>This is for local, rather than propagated, information. </p>

<p class="definition">Definition at line <a class="el" href="staticSingleAssignment_8h_source.html#l00112">112</a> of file <a class="el" href="staticSingleAssignment_8h_source.html">staticSingleAssignment.h</a>.</p>

</div>
</div>
<a id="ac26931d0a5d15d7f85913020563f9dd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac26931d0a5d15d7f85913020563f9dd7">&#9670;&nbsp;</a></span>FilteredCfgNode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef FilteredCFGNode&lt;<a class="el" href="structssa__private_1_1DataflowCfgFilter.html">ssa_private::DataflowCfgFilter</a>&gt; <a class="el" href="classStaticSingleAssignment.html#ac26931d0a5d15d7f85913020563f9dd7">StaticSingleAssignment::FilteredCfgNode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A filtered CFGNode that is used for DefUse traversal. </p>
<p><br  />
 </p>

<p class="definition">Definition at line <a class="el" href="staticSingleAssignment_8h_source.html#l00115">115</a> of file <a class="el" href="staticSingleAssignment_8h_source.html">staticSingleAssignment.h</a>.</p>

</div>
</div>
<a id="aaff056020ff2698604fdec2296405e8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaff056020ff2698604fdec2296405e8b">&#9670;&nbsp;</a></span>FilteredCfgEdge</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef FilteredCFGEdge&lt;<a class="el" href="structssa__private_1_1DataflowCfgFilter.html">ssa_private::DataflowCfgFilter</a>&gt; <a class="el" href="classStaticSingleAssignment.html#aaff056020ff2698604fdec2296405e8b">StaticSingleAssignment::FilteredCfgEdge</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A filtered CFGEdge that is used for DefUse traversal. </p>
<p><br  />
 </p>

<p class="definition">Definition at line <a class="el" href="staticSingleAssignment_8h_source.html#l00118">118</a> of file <a class="el" href="staticSingleAssignment_8h_source.html">staticSingleAssignment.h</a>.</p>

</div>
</div>
<a id="aaa29c315fbca6973d875f6832b62589f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa29c315fbca6973d875f6832b62589f">&#9670;&nbsp;</a></span>GlobalReachingDefTable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::unordered_map&lt;<a class="el" href="classSgNode.html">SgNode</a>*, std::pair&lt;<a class="el" href="classStaticSingleAssignment.html#aa867994c56b8018439d2cc95d8ef4981">NodeReachingDefTable</a>, <a class="el" href="classStaticSingleAssignment.html#aa867994c56b8018439d2cc95d8ef4981">NodeReachingDefTable</a>&gt; &gt; <a class="el" href="classStaticSingleAssignment.html#aaa29c315fbca6973d875f6832b62589f">StaticSingleAssignment::GlobalReachingDefTable</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The first table is the IN table. </p>
<p>The second table is the OUT table. </p>

<p class="definition">Definition at line <a class="el" href="staticSingleAssignment_8h_source.html#l00126">126</a> of file <a class="el" href="staticSingleAssignment_8h_source.html">staticSingleAssignment.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7340f93af9c35d8231170dac4fdea47c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7340f93af9c35d8231170dac4fdea47c">&#9670;&nbsp;</a></span>run()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void StaticSingleAssignment::run </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>interprocedural</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>treatPointersAsStructures</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run the analysis. </p>
<p>If interprocedural analysis is not enabled, functionc all expressions (<a class="el" href="classSgFunctionCallExp.html" title="This class represents the concept of a C++ function call (which is an expression).">SgFunctionCallExp</a>) will not count as definitions of any variables. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interprocedural</td><td>true to enable interprocedural analysis, false to perform no interprocedural analysis. </td></tr>
    <tr><td class="paramname">treatPointersAsStructures</td><td>if true, p-&gt;x is versioned as if it were the variable p.x. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae22322f55e06b7df73fb590f0f748020"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae22322f55e06b7df73fb590f0f748020">&#9670;&nbsp;</a></span>toDOT()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void StaticSingleAssignment::toDOT </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>fileName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print the CFG with any UniqueNames and Def/Use information visible. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fileName</td><td>The filename to save graph as. Filenames will be prepended. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9774845d765b66e68b9016666f75cbaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9774845d765b66e68b9016666f75cbaa">&#9670;&nbsp;</a></span>toFilteredDOT()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void StaticSingleAssignment::toFilteredDOT </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>fileName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print the CFG with any UniqueNames and Def/Use information visible. </p>
<p>This will only print the nodes that are of interest to the filter function used by the def/use traversal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fileName</td><td>The filename to save graph as. Filenames will be prepended. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9a73c5246f974e2a72e9df0fa25ebf9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a73c5246f974e2a72e9df0fa25ebf9a">&#9670;&nbsp;</a></span>getOriginalDefTable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classStaticSingleAssignment.html#adcb347322834917dd31dd57af44001f8">LocalDefUseTable</a>&amp; StaticSingleAssignment::getOriginalDefTable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the table of definitions for every node. </p>
<p>These definitions are NOT propagated.</p>
<dl class="section return"><dt>Returns</dt><dd>Definition table. </dd></dl>

<p class="definition">Definition at line <a class="el" href="staticSingleAssignment_8h_source.html#l00380">380</a> of file <a class="el" href="staticSingleAssignment_8h_source.html">staticSingleAssignment.h</a>.</p>

</div>
</div>
<a id="a849b955426161fb016bc28c1f840726f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a849b955426161fb016bc28c1f840726f">&#9670;&nbsp;</a></span>getOutgoingDefsAtNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classStaticSingleAssignment.html#aa867994c56b8018439d2cc95d8ef4981">NodeReachingDefTable</a>&amp; StaticSingleAssignment::getOutgoingDefsAtNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the definitions of all the variables right after the given node has executed. </p>
<p>This function does not work correctly for "container" nodes such as <a class="el" href="classSgBasicBlock.html" title="This class represents the concept of a block (not a basic block from control flow analysis).">SgBasicBlock</a>, SgCommaOp, SgExprStmt. If there is a definition at the node itself, e.g. <a class="el" href="classSgAssignOp.html">SgAssignOp</a>, it is included in the outgoing defs. </p>

</div>
</div>
<a id="ac1de1194e93b1201af57976c2b67339b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1de1194e93b1201af57976c2b67339b">&#9670;&nbsp;</a></span>getReachingDefsAtNode_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classStaticSingleAssignment.html#aa867994c56b8018439d2cc95d8ef4981">NodeReachingDefTable</a>&amp; StaticSingleAssignment::getReachingDefsAtNode_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the definitions of all the variables immediately before the given node has executed. </p>
<p>If there is a definition at the node itself, e.g. <a class="el" href="classSgAssignOp.html">SgAssignOp</a>, it is not included in the reaching defs. </p>

</div>
</div>
<a id="ae52c0d0571e9ebd340b26386db0df2c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae52c0d0571e9ebd340b26386db0df2c4">&#9670;&nbsp;</a></span>getUsesAtNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classStaticSingleAssignment.html#aa867994c56b8018439d2cc95d8ef4981">NodeReachingDefTable</a>&amp; StaticSingleAssignment::getUsesAtNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a list of all the variables used at this node. </p>
<p>Note that uses don't propagate past an <a class="el" href="classSgStatement.html" title="This class represents the notion of a statement.">SgStatement</a>. Each use is mapped to the reaching definition to which the use corresponds. </p>

</div>
</div>
<a id="abc3b52c524bcdbe1698f59214319bde0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc3b52c524bcdbe1698f59214319bde0">&#9670;&nbsp;</a></span>getDefsAtNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classStaticSingleAssignment.html#aa867994c56b8018439d2cc95d8ef4981">NodeReachingDefTable</a>&amp; StaticSingleAssignment::getDefsAtNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a list of all the variables defined at the given node. </p>
<p>Note that this will return an empty collections for nodes that do not modify any variables. Compare this function to getReachingDefsAtNode. </p>

</div>
</div>
<a id="a6f967369c7be8ddfd24bf85381d01506"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f967369c7be8ddfd24bf85381d01506">&#9670;&nbsp;</a></span>getOriginalVarsDefinedInSubtree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt;<a class="el" href="classStaticSingleAssignment.html#ac331e1110ecdbb40e8efee09b0284862">VarName</a>&gt; StaticSingleAssignment::getOriginalVarsDefinedInSubtree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&#160;</td>
          <td class="paramname"><em>root</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a node, traverses all its children in the AST and collects all the variable names that have original definitions in the subtree. </p>
<p>Expanded definitions are not included - for example if p.x is defined, p is not included. </p>

</div>
</div>
<a id="add0647a7406e082c34837c5d6befeb88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add0647a7406e082c34837c5d6befeb88">&#9670;&nbsp;</a></span>getLastVersions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classStaticSingleAssignment.html#aa867994c56b8018439d2cc95d8ef4981">NodeReachingDefTable</a> StaticSingleAssignment::getLastVersions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> *&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the last encountered definition of every variable. </p>
<p>Variables go out of scope, so quering for reaching definitions at the end of a function doesn't return the last versions of all variables. </p>

</div>
</div>
<a id="ad431a7db92fca6b44e362d4a4cc380c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad431a7db92fca6b44e362d4a4cc380c4">&#9670;&nbsp;</a></span>isPrefixOfName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool StaticSingleAssignment::isPrefixOfName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classStaticSingleAssignment.html#ac331e1110ecdbb40e8efee09b0284862">VarName</a>&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classStaticSingleAssignment.html#ac331e1110ecdbb40e8efee09b0284862">VarName</a>&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find if the given prefix is a prefix of the given name. </p>
<p>This will return whether the given name has the given prefix inside it.</p>
<p>ex. a.b.c has prefix a.b, but not a.c</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name to search. </td></tr>
    <tr><td class="paramname">prefix</td><td>The prefix to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the prefix is in this name. </dd></dl>

</div>
</div>
<a id="a35267ee8644b19fca8cc573649fbb24b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35267ee8644b19fca8cc573649fbb24b">&#9670;&nbsp;</a></span>getUniqueName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classssa__private_1_1VarUniqueName.html">ssa_private::VarUniqueName</a>* StaticSingleAssignment::getUniqueName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the uniqueName attribute for the given node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Node to get the attribute from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The attribute, or NULL. </dd></dl>

</div>
</div>
<a id="a976474bbfc0366540c0ca8ef0dab77d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a976474bbfc0366540c0ca8ef0dab77d3">&#9670;&nbsp;</a></span>getVarName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classStaticSingleAssignment.html#ac331e1110ecdbb40e8efee09b0284862">VarName</a>&amp; StaticSingleAssignment::getVarName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the variable name of the given node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node to get the name for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The name, or empty name. </dd></dl>

</div>
</div>
<a id="ac0e4b36e017885f616cd6b391c5205f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0e4b36e017885f616cd6b391c5205f8">&#9670;&nbsp;</a></span>getVarForExpression()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classStaticSingleAssignment.html#ac331e1110ecdbb40e8efee09b0284862">VarName</a>&amp; StaticSingleAssignment::getVarForExpression </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If an expression evaluates to a reference of a variable, returns that variable. </p>
<p>Handles casts, comma ops, address of ops, etc. For example, Given the expression (...., &amp;a), this method would return the VarName for a. </p>

</div>
</div>
<a id="a28ce0ed01016c6dea58c6be900d95d63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28ce0ed01016c6dea58c6be900d95d63">&#9670;&nbsp;</a></span>buildVariableReference()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSgExpression.html">SgExpression</a>* StaticSingleAssignment::buildVariableReference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classStaticSingleAssignment.html#ac331e1110ecdbb40e8efee09b0284862">VarName</a> &amp;&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *&#160;</td>
          <td class="paramname"><em>scope</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an AST fragment containing the appropriate varRefs and Dot/Arrow ops to access the given variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">var</td><td>The variable to construct access for. </td></tr>
    <tr><td class="paramname">scope</td><td>The scope within which to construct the access. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An expression that access the given variable in the given scope. </dd></dl>

</div>
</div>
<a id="a25e6ba89f1da6252d4518d73d091e4be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25e6ba89f1da6252d4518d73d091e4be">&#9670;&nbsp;</a></span>isVarInScope()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool StaticSingleAssignment::isVarInScope </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classStaticSingleAssignment.html#ac331e1110ecdbb40e8efee09b0284862">VarName</a> &amp;&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&#160;</td>
          <td class="paramname"><em>scope</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the scope of the given node, and returns true if the given variable is accessible there. </p>
<p>False if the variable is not accessible. </p>

</div>
</div>
<a id="a019e51da21fd909ef647f9692239751c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a019e51da21fd909ef647f9692239751c">&#9670;&nbsp;</a></span>varnameToString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string StaticSingleAssignment::varnameToString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classStaticSingleAssignment.html#ac331e1110ecdbb40e8efee09b0284862">VarName</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a string representation of a varName. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>varName to get string for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>String for given varName. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="staticSingleAssignment_8h_source.html">staticSingleAssignment.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Dec 19 2022 23:40:25 for ROSE by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
