<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROSE: Sawyer::Tree::Node Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="ROSE"/>
<link href="roseDoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ROSE
   &#160;<span id="projectnumber">0.11.96.11</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,true,'search.html','Search');
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceSawyer.html">Sawyer</a></li><li class="navelem"><a class="el" href="namespaceSawyer_1_1Tree.html">Tree</a></li><li class="navelem"><a class="el" href="classSawyer_1_1Tree_1_1Node.html">Node</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classSawyer_1_1Tree_1_1Node-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Sawyer::Tree::Node Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>Base class for <a class="el" href="namespaceSawyer_1_1Tree.html">Tree</a> nodes. </p>
<p>All nodes of a tree inherit from this type. The main features that this class provides are:</p>
<ul>
<li>When declaring a tree node, the parent-child edges are declared using the <a class="el" href="classSawyer_1_1Tree_1_1ChildEdge.html">ChildEdge</a> type as described in that type's documentation.</li>
</ul>
<ul>
<li>Every node has a <code>children</code> data member that enumerates the nodes pointed to by the <a class="el" href="classSawyer_1_1Tree_1_1ChildEdge.html">ChildEdge</a> data members. This list of all children is updated automatically as assignments are made to the <a class="el" href="classSawyer_1_1Tree_1_1ChildEdge.html">ChildEdge</a> data members.</li>
</ul>
<ul>
<li>Every node has a <code>parent</code> data member that points to the parent node in the tree, or null if this node is the root of a tree. The parent pointers are updated automatically as nodes are inserted into and removed from the tree.</li>
</ul>
<ul>
<li><a class="el" href="classSawyer_1_1Tree_1_1Node.html" title="Base class for Tree nodes.">Node</a> memory is managed using <code>std::shared_ptr</code>, and node memory is reclaimed automatically when there are no more references to the node, either as parent-child edges or other shared pointers outside the tree's control. The pointers from child to parent within the tree data structure itself are weak and do not count as references to the parent node.</li>
</ul>
<ul>
<li>a number of traversals are defined, the two most general being <a class="el" href="classSawyer_1_1Tree_1_1Node.html#a12e22489ac094bb85f9254c955fd5e1a">traverse</a> and <a class="el" href="classSawyer_1_1Tree_1_1Node.html#acfcb73b3bb170715837940ad4c9d44e5">traverseParents</a>. The other traversals are more specialized and are built upon the first two. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="Tree_8h_source.html#l00479">479</a> of file <a class="el" href="Tree_8h_source.html">Tree.h</a>.</p>
</div>
<p><code>#include &lt;<a class="el" href="Tree_8h_source.html">Tree.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Sawyer::Tree::Node:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Tree_1_1Node__inherit__graph.png" border="0" usemap="#Sawyer_1_1Tree_1_1Node_inherit__map" alt="Inheritance graph"/></div>
<map name="Sawyer_1_1Tree_1_1Node_inherit__map" id="Sawyer_1_1Tree_1_1Node_inherit__map">
<area shape="rect" title="Base class for Tree nodes." alt="" coords="32,95,171,121"/>
<area shape="rect" href="classSawyer_1_1Tree_1_1ListNode.html" title="A node containing only a list of children." alt="" coords="5,169,197,196"/>
<area shape="rect" title=" " alt="" coords="32,5,171,47"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for Sawyer::Tree::Node:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Tree_1_1Node__coll__graph.png" border="0" usemap="#Sawyer_1_1Tree_1_1Node_coll__map" alt="Collaboration graph"/></div>
<map name="Sawyer_1_1Tree_1_1Node_coll__map" id="Sawyer_1_1Tree_1_1Node_coll__map">
<area shape="rect" title="Base class for Tree nodes." alt="" coords="279,71,417,98"/>
<area shape="rect" title=" " alt="" coords="24,5,163,47"/>
<area shape="rect" href="classSawyer_1_1Tree_1_1ParentEdge.html" title="Edge pointing from child to parent." alt="" coords="5,71,181,98"/>
<area shape="rect" href="classSawyer_1_1Tree_1_1Children.html" title="Vector of parent&#45;to&#45;child pointers." alt="" coords="15,122,171,149"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8b77a92db50973f995d56a58493d5210"><td class="memItemLeft" align="right" valign="top"><a id="a8b77a92db50973f995d56a58493d5210"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1Node.html#a8b77a92db50973f995d56a58493d5210">Node</a> ()</td></tr>
<tr class="memdesc:a8b77a92db50973f995d56a58493d5210"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an empty node. <br /></td></tr>
<tr class="separator:a8b77a92db50973f995d56a58493d5210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae31249ddaef7a54133fbf30e3e7c3114"><td class="memItemLeft" align="right" valign="top"><a id="ae31249ddaef7a54133fbf30e3e7c3114"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1Node.html#ae31249ddaef7a54133fbf30e3e7c3114">~Node</a> ()</td></tr>
<tr class="memdesc:ae31249ddaef7a54133fbf30e3e7c3114"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nodes are polymorphic. <br /></td></tr>
<tr class="separator:ae31249ddaef7a54133fbf30e3e7c3114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc356dd9643c22dc1f8e81788ad8e061"><td class="memItemLeft" align="right" valign="top"><a id="adc356dd9643c22dc1f8e81788ad8e061"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Node</b> (const <a class="el" href="classSawyer_1_1Tree_1_1Node.html">Node</a> &amp;)=delete</td></tr>
<tr class="separator:adc356dd9643c22dc1f8e81788ad8e061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42ec1a51b3cbaab1be010056d8267a58"><td class="memItemLeft" align="right" valign="top"><a id="a42ec1a51b3cbaab1be010056d8267a58"></a>
<a class="el" href="classSawyer_1_1Tree_1_1Node.html">Node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classSawyer_1_1Tree_1_1Node.html">Node</a> &amp;)=delete</td></tr>
<tr class="separator:a42ec1a51b3cbaab1be010056d8267a58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a12e22489ac094bb85f9254c955fd5e1a"><td class="memTemplParams" colspan="2">template&lt;class Functor &gt; </td></tr>
<tr class="memitem:a12e22489ac094bb85f9254c955fd5e1a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceSawyer_1_1Tree.html#a704adef2b0317fd76cc589b14c11fa5d">TraversalAction</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1Node.html#a12e22489ac094bb85f9254c955fd5e1a">traverse</a> (Functor functor)</td></tr>
<tr class="memdesc:a12e22489ac094bb85f9254c955fd5e1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse the tree starting at this node and following child pointers.  <a href="classSawyer_1_1Tree_1_1Node.html#a12e22489ac094bb85f9254c955fd5e1a">More...</a><br /></td></tr>
<tr class="separator:a12e22489ac094bb85f9254c955fd5e1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8758a487d093026d1b70667910bb8f2"><td class="memTemplParams" colspan="2">template&lt;class Functor &gt; </td></tr>
<tr class="memitem:ab8758a487d093026d1b70667910bb8f2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceSawyer_1_1Tree.html#a704adef2b0317fd76cc589b14c11fa5d">TraversalAction</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1Node.html#ab8758a487d093026d1b70667910bb8f2">traverse</a> (Functor functor) const</td></tr>
<tr class="memdesc:ab8758a487d093026d1b70667910bb8f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse the tree starting at this node and following child pointers.  <a href="classSawyer_1_1Tree_1_1Node.html#ab8758a487d093026d1b70667910bb8f2">More...</a><br /></td></tr>
<tr class="separator:ab8758a487d093026d1b70667910bb8f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a55a0fa7a56899667f5258d5a29e39db9"><td class="memTemplParams" colspan="2">template&lt;class T , class Functor &gt; </td></tr>
<tr class="memitem:a55a0fa7a56899667f5258d5a29e39db9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceSawyer_1_1Tree.html#a704adef2b0317fd76cc589b14c11fa5d">TraversalAction</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1Node.html#a55a0fa7a56899667f5258d5a29e39db9">traverseType</a> (Functor functor)</td></tr>
<tr class="memdesc:a55a0fa7a56899667f5258d5a29e39db9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse the tree restricted by type.  <a href="classSawyer_1_1Tree_1_1Node.html#a55a0fa7a56899667f5258d5a29e39db9">More...</a><br /></td></tr>
<tr class="separator:a55a0fa7a56899667f5258d5a29e39db9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ac56fde8f00e6fea77dfe2cba947347"><td class="memTemplParams" colspan="2">template&lt;class T , class Functor &gt; </td></tr>
<tr class="memitem:a8ac56fde8f00e6fea77dfe2cba947347"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceSawyer_1_1Tree.html#a704adef2b0317fd76cc589b14c11fa5d">TraversalAction</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1Node.html#a8ac56fde8f00e6fea77dfe2cba947347">traverseType</a> (Functor functor) const</td></tr>
<tr class="memdesc:a8ac56fde8f00e6fea77dfe2cba947347"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse the tree restricted by type.  <a href="classSawyer_1_1Tree_1_1Node.html#a8ac56fde8f00e6fea77dfe2cba947347">More...</a><br /></td></tr>
<tr class="separator:a8ac56fde8f00e6fea77dfe2cba947347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:acfcb73b3bb170715837940ad4c9d44e5"><td class="memTemplParams" colspan="2">template&lt;class Functor &gt; </td></tr>
<tr class="memitem:acfcb73b3bb170715837940ad4c9d44e5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceSawyer_1_1Tree.html#a704adef2b0317fd76cc589b14c11fa5d">TraversalAction</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1Node.html#acfcb73b3bb170715837940ad4c9d44e5">traverseParents</a> (Functor functor)</td></tr>
<tr class="memdesc:acfcb73b3bb170715837940ad4c9d44e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse the tree by following parent pointers.  <a href="classSawyer_1_1Tree_1_1Node.html#acfcb73b3bb170715837940ad4c9d44e5">More...</a><br /></td></tr>
<tr class="separator:acfcb73b3bb170715837940ad4c9d44e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af805d62626a1875c4ca56e9bb55f413f"><td class="memTemplParams" colspan="2">template&lt;class Functor &gt; </td></tr>
<tr class="memitem:af805d62626a1875c4ca56e9bb55f413f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceSawyer_1_1Tree.html#a704adef2b0317fd76cc589b14c11fa5d">TraversalAction</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1Node.html#af805d62626a1875c4ca56e9bb55f413f">traverseParents</a> (Functor functor) const</td></tr>
<tr class="memdesc:af805d62626a1875c4ca56e9bb55f413f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse the tree by following parent pointers.  <a href="classSawyer_1_1Tree_1_1Node.html#af805d62626a1875c4ca56e9bb55f413f">More...</a><br /></td></tr>
<tr class="separator:af805d62626a1875c4ca56e9bb55f413f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a8197da73d0542fbd68dbd7bdb0d08277"><td class="memTemplParams" colspan="2"><a id="a8197da73d0542fbd68dbd7bdb0d08277"></a>
template&lt;class Predicate &gt; </td></tr>
<tr class="memitem:a8197da73d0542fbd68dbd7bdb0d08277"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceSawyer_1_1Tree.html#af4a9b1ac7a4cb3e8585398905c9ebe5e">NodePtr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1Node.html#a8197da73d0542fbd68dbd7bdb0d08277">find</a> (Predicate predicate)</td></tr>
<tr class="memdesc:a8197da73d0542fbd68dbd7bdb0d08277"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse an tree to find the first node satisfying the predicate. <br /></td></tr>
<tr class="separator:a8197da73d0542fbd68dbd7bdb0d08277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7254d0b0fbafe76e79ee15d072debef2"><td class="memTemplParams" colspan="2"><a id="a7254d0b0fbafe76e79ee15d072debef2"></a>
template&lt;class Predicate &gt; </td></tr>
<tr class="memitem:a7254d0b0fbafe76e79ee15d072debef2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceSawyer_1_1Tree.html#af4a9b1ac7a4cb3e8585398905c9ebe5e">NodePtr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1Node.html#a7254d0b0fbafe76e79ee15d072debef2">find</a> (Predicate predicate) const</td></tr>
<tr class="memdesc:a7254d0b0fbafe76e79ee15d072debef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse an tree to find the first node satisfying the predicate. <br /></td></tr>
<tr class="separator:a7254d0b0fbafe76e79ee15d072debef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a6103b7f7672831b655e70111c3f7bc25"><td class="memTemplParams" colspan="2"><a id="a6103b7f7672831b655e70111c3f7bc25"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a6103b7f7672831b655e70111c3f7bc25"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1Node.html#a6103b7f7672831b655e70111c3f7bc25">findType</a> ()</td></tr>
<tr class="memdesc:a6103b7f7672831b655e70111c3f7bc25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find first child that's the specified type. <br /></td></tr>
<tr class="separator:a6103b7f7672831b655e70111c3f7bc25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1561c564e286e64238f26b3f9f2992c5"><td class="memTemplParams" colspan="2"><a id="a1561c564e286e64238f26b3f9f2992c5"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a1561c564e286e64238f26b3f9f2992c5"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1Node.html#a1561c564e286e64238f26b3f9f2992c5">findType</a> () const</td></tr>
<tr class="memdesc:a1561c564e286e64238f26b3f9f2992c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find first child that's the specified type. <br /></td></tr>
<tr class="separator:a1561c564e286e64238f26b3f9f2992c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:acfaaf4cbba997f3d2ab5a62b782457e1"><td class="memTemplParams" colspan="2"><a id="acfaaf4cbba997f3d2ab5a62b782457e1"></a>
template&lt;class T , class Predicate &gt; </td></tr>
<tr class="memitem:acfaaf4cbba997f3d2ab5a62b782457e1"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1Node.html#acfaaf4cbba997f3d2ab5a62b782457e1">findType</a> (Predicate predicate)</td></tr>
<tr class="memdesc:acfaaf4cbba997f3d2ab5a62b782457e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find first child of specified type satisfying the predicate. <br /></td></tr>
<tr class="separator:acfaaf4cbba997f3d2ab5a62b782457e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20b890a3ab635375142453d094df9330"><td class="memTemplParams" colspan="2"><a id="a20b890a3ab635375142453d094df9330"></a>
template&lt;class T , class Predicate &gt; </td></tr>
<tr class="memitem:a20b890a3ab635375142453d094df9330"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1Node.html#a20b890a3ab635375142453d094df9330">findType</a> (Predicate predicate) const</td></tr>
<tr class="memdesc:a20b890a3ab635375142453d094df9330"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find first child of specified type satisfying the predicate. <br /></td></tr>
<tr class="separator:a20b890a3ab635375142453d094df9330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a6b4ace5625e64e9f1265711cd6916513"><td class="memTemplParams" colspan="2"><a id="a6b4ace5625e64e9f1265711cd6916513"></a>
template&lt;class Predicate &gt; </td></tr>
<tr class="memitem:a6b4ace5625e64e9f1265711cd6916513"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceSawyer_1_1Tree.html#af4a9b1ac7a4cb3e8585398905c9ebe5e">NodePtr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1Node.html#a6b4ace5625e64e9f1265711cd6916513">findParent</a> (Predicate predicate)</td></tr>
<tr class="memdesc:a6b4ace5625e64e9f1265711cd6916513"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find closest ancestor that satifies the predicate. <br /></td></tr>
<tr class="separator:a6b4ace5625e64e9f1265711cd6916513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a286ceb28a5f5f5db003b6626bd22dabd"><td class="memTemplParams" colspan="2"><a id="a286ceb28a5f5f5db003b6626bd22dabd"></a>
template&lt;class Predicate &gt; </td></tr>
<tr class="memitem:a286ceb28a5f5f5db003b6626bd22dabd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceSawyer_1_1Tree.html#af4a9b1ac7a4cb3e8585398905c9ebe5e">NodePtr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1Node.html#a286ceb28a5f5f5db003b6626bd22dabd">findParent</a> (Predicate predicate) const</td></tr>
<tr class="memdesc:a286ceb28a5f5f5db003b6626bd22dabd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find closest ancestor that satifies the predicate. <br /></td></tr>
<tr class="separator:a286ceb28a5f5f5db003b6626bd22dabd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a3ded13ab780629960a759b2dd18cad1a"><td class="memTemplParams" colspan="2"><a id="a3ded13ab780629960a759b2dd18cad1a"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a3ded13ab780629960a759b2dd18cad1a"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1Node.html#a3ded13ab780629960a759b2dd18cad1a">findParentType</a> ()</td></tr>
<tr class="memdesc:a3ded13ab780629960a759b2dd18cad1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find closest ancestor of specified type. <br /></td></tr>
<tr class="separator:a3ded13ab780629960a759b2dd18cad1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6aca24c52a60231c78ff39899a4ed15"><td class="memTemplParams" colspan="2"><a id="ad6aca24c52a60231c78ff39899a4ed15"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ad6aca24c52a60231c78ff39899a4ed15"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1Node.html#ad6aca24c52a60231c78ff39899a4ed15">findParentType</a> () const</td></tr>
<tr class="memdesc:ad6aca24c52a60231c78ff39899a4ed15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find closest ancestor of specified type. <br /></td></tr>
<tr class="separator:ad6aca24c52a60231c78ff39899a4ed15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a6711558f6fef04220551a0a3ec63d9d6"><td class="memTemplParams" colspan="2"><a id="a6711558f6fef04220551a0a3ec63d9d6"></a>
template&lt;class T , class Predicate &gt; </td></tr>
<tr class="memitem:a6711558f6fef04220551a0a3ec63d9d6"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1Node.html#a6711558f6fef04220551a0a3ec63d9d6">findParentType</a> (Predicate predicate)</td></tr>
<tr class="memdesc:a6711558f6fef04220551a0a3ec63d9d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find closest ancestor of specified type that satisfies the predicate. <br /></td></tr>
<tr class="separator:a6711558f6fef04220551a0a3ec63d9d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9900caa6c9417c05448a1fba7638b67"><td class="memTemplParams" colspan="2"><a id="aa9900caa6c9417c05448a1fba7638b67"></a>
template&lt;class T , class Predicate &gt; </td></tr>
<tr class="memitem:aa9900caa6c9417c05448a1fba7638b67"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1Node.html#aa9900caa6c9417c05448a1fba7638b67">findParentType</a> (Predicate predicate) const</td></tr>
<tr class="memdesc:aa9900caa6c9417c05448a1fba7638b67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find closest ancestor of specified type that satisfies the predicate. <br /></td></tr>
<tr class="separator:aa9900caa6c9417c05448a1fba7638b67"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a43c6e37a263bae722919e7820a913213"><td class="memItemLeft" align="right" valign="top"><a id="a43c6e37a263bae722919e7820a913213"></a>
<a class="el" href="classSawyer_1_1Tree_1_1ParentEdge.html">ParentEdge</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1Node.html#a43c6e37a263bae722919e7820a913213">parent</a></td></tr>
<tr class="memdesc:a43c6e37a263bae722919e7820a913213"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the parent node, if any. <br /></td></tr>
<tr class="separator:a43c6e37a263bae722919e7820a913213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2de457adf4e432ea3f3f8c7bb2b4972"><td class="memItemLeft" align="right" valign="top"><a id="ab2de457adf4e432ea3f3f8c7bb2b4972"></a>
<a class="el" href="classSawyer_1_1Tree_1_1Children.html">Children</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1Node.html#ab2de457adf4e432ea3f3f8c7bb2b4972">children</a></td></tr>
<tr class="memdesc:ab2de457adf4e432ea3f3f8c7bb2b4972"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of pointers to children. <br /></td></tr>
<tr class="separator:ab2de457adf4e432ea3f3f8c7bb2b4972"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a12e22489ac094bb85f9254c955fd5e1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12e22489ac094bb85f9254c955fd5e1a">&#9670;&nbsp;</a></span>traverse() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Functor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSawyer_1_1Tree.html#a704adef2b0317fd76cc589b14c11fa5d">TraversalAction</a> Sawyer::Tree::Node::traverse </td>
          <td>(</td>
          <td class="paramtype">Functor&#160;</td>
          <td class="paramname"><em>functor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Traverse the tree starting at this node and following child pointers. </p>
<p>The <code>functor</code> takes two arguments: the tree node under consideration, and a TraversalEvent that indicates whether the traversal is entering or leaving the node. The functor must return a <a class="el" href="namespaceSawyer_1_1Tree.html#a704adef2b0317fd76cc589b14c11fa5d">TraversalAction</a> to describe what should happen next.</p>
<p>If the functor called by the node enter event returns <a class="el" href="namespaceSawyer_1_1Tree.html#a704adef2b0317fd76cc589b14c11fa5da8e1fe5b5da5496c5ef45b35b9b14a58e">SKIP_CHILDREN</a>, then none of the children are traversed and the next call to the functor is for leaving that same node.</p>
<p>If any call to the functor returns ABORT, then the traversal is immediately aborted.</p>
<p>If any functor returns ABORT, then the <a class="el" href="classSawyer_1_1Tree_1_1Node.html#a12e22489ac094bb85f9254c955fd5e1a">traverse</a> function also returns ABORT. Otherwise the <a class="el" href="classSawyer_1_1Tree_1_1Node.html#a12e22489ac094bb85f9254c955fd5e1a">traverse</a> function returns CONTINUE. </p>

<p class="definition">Definition at line <a class="el" href="Tree_8h_source.html#l00516">516</a> of file <a class="el" href="Tree_8h_source.html">Tree.h</a>.</p>

</div>
</div>
<a id="ab8758a487d093026d1b70667910bb8f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8758a487d093026d1b70667910bb8f2">&#9670;&nbsp;</a></span>traverse() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Functor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSawyer_1_1Tree.html#a704adef2b0317fd76cc589b14c11fa5d">TraversalAction</a> Sawyer::Tree::Node::traverse </td>
          <td>(</td>
          <td class="paramtype">Functor&#160;</td>
          <td class="paramname"><em>functor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Traverse the tree starting at this node and following child pointers. </p>
<p>The <code>functor</code> takes two arguments: the tree node under consideration, and a TraversalEvent that indicates whether the traversal is entering or leaving the node. The functor must return a <a class="el" href="namespaceSawyer_1_1Tree.html#a704adef2b0317fd76cc589b14c11fa5d">TraversalAction</a> to describe what should happen next.</p>
<p>If the functor called by the node enter event returns <a class="el" href="namespaceSawyer_1_1Tree.html#a704adef2b0317fd76cc589b14c11fa5da8e1fe5b5da5496c5ef45b35b9b14a58e">SKIP_CHILDREN</a>, then none of the children are traversed and the next call to the functor is for leaving that same node.</p>
<p>If any call to the functor returns ABORT, then the traversal is immediately aborted.</p>
<p>If any functor returns ABORT, then the <a class="el" href="classSawyer_1_1Tree_1_1Node.html#a12e22489ac094bb85f9254c955fd5e1a">traverse</a> function also returns ABORT. Otherwise the <a class="el" href="classSawyer_1_1Tree_1_1Node.html#a12e22489ac094bb85f9254c955fd5e1a">traverse</a> function returns CONTINUE. </p>

<p class="definition">Definition at line <a class="el" href="Tree_8h_source.html#l00520">520</a> of file <a class="el" href="Tree_8h_source.html">Tree.h</a>.</p>

</div>
</div>
<a id="a55a0fa7a56899667f5258d5a29e39db9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55a0fa7a56899667f5258d5a29e39db9">&#9670;&nbsp;</a></span>traverseType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Functor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSawyer_1_1Tree.html#a704adef2b0317fd76cc589b14c11fa5d">TraversalAction</a> Sawyer::Tree::Node::traverseType </td>
          <td>(</td>
          <td class="paramtype">Functor&#160;</td>
          <td class="paramname"><em>functor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Traverse the tree restricted by type. </p>
<p>Traverses the entire tree, but calls the functor only for nodes of the specified type (or subtype). </p>

<p class="definition">Definition at line <a class="el" href="Tree_8h_source.html#l01107">1107</a> of file <a class="el" href="Tree_8h_source.html">Tree.h</a>.</p>

</div>
</div>
<a id="a8ac56fde8f00e6fea77dfe2cba947347"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ac56fde8f00e6fea77dfe2cba947347">&#9670;&nbsp;</a></span>traverseType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Functor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSawyer_1_1Tree.html#a704adef2b0317fd76cc589b14c11fa5d">TraversalAction</a> Sawyer::Tree::Node::traverseType </td>
          <td>(</td>
          <td class="paramtype">Functor&#160;</td>
          <td class="paramname"><em>functor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Traverse the tree restricted by type. </p>
<p>Traverses the entire tree, but calls the functor only for nodes of the specified type (or subtype). </p>

<p class="definition">Definition at line <a class="el" href="Tree_8h_source.html#l01113">1113</a> of file <a class="el" href="Tree_8h_source.html">Tree.h</a>.</p>

</div>
</div>
<a id="acfcb73b3bb170715837940ad4c9d44e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfcb73b3bb170715837940ad4c9d44e5">&#9670;&nbsp;</a></span>traverseParents() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Functor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSawyer_1_1Tree.html#a704adef2b0317fd76cc589b14c11fa5d">TraversalAction</a> Sawyer::Tree::Node::traverseParents </td>
          <td>(</td>
          <td class="paramtype">Functor&#160;</td>
          <td class="paramname"><em>functor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Traverse the tree by following parent pointers. </p>
<p>Other than following pointers from children to parents, this traversal is identical to the downward <a class="el" href="classSawyer_1_1Tree_1_1Node.html#a12e22489ac094bb85f9254c955fd5e1a">traverse</a> method. </p>

<p class="definition">Definition at line <a class="el" href="Tree_8h_source.html#l00543">543</a> of file <a class="el" href="Tree_8h_source.html">Tree.h</a>.</p>

</div>
</div>
<a id="af805d62626a1875c4ca56e9bb55f413f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af805d62626a1875c4ca56e9bb55f413f">&#9670;&nbsp;</a></span>traverseParents() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Functor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSawyer_1_1Tree.html#a704adef2b0317fd76cc589b14c11fa5d">TraversalAction</a> Sawyer::Tree::Node::traverseParents </td>
          <td>(</td>
          <td class="paramtype">Functor&#160;</td>
          <td class="paramname"><em>functor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Traverse the tree by following parent pointers. </p>
<p>Other than following pointers from children to parents, this traversal is identical to the downward <a class="el" href="classSawyer_1_1Tree_1_1Node.html#a12e22489ac094bb85f9254c955fd5e1a">traverse</a> method. </p>

<p class="definition">Definition at line <a class="el" href="Tree_8h_source.html#l00547">547</a> of file <a class="el" href="Tree_8h_source.html">Tree.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="Tree_8h_source.html">Tree.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Dec 19 2022 23:40:28 for ROSE by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
