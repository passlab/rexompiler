<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROSE: Range&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="ROSE"/>
<link href="roseDoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ROSE
   &#160;<span id="projectnumber">0.11.96.11</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,true,'search.html','Search');
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classRange-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Range&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><h3>template&lt;class T&gt;<br />
class Range&lt; T &gt;</h3>

<p>A contiguous range of values. </p>
<p>Represents a contiguous range of <code>size</code> values beginning at <code>begin</code>, and defines relationships between two ranges. The ranges are designed such that they can represent unsigned values up to and including the maximum possible values for the data type. However, this means that a range that represents all possible values will have a <a class="el" href="classRange.html#aeb6128b91ac1c805bf5880bc3db25d98" title="Returns the number of values represented by the range.">size()</a> of zero due to overflow.</p>
<p>Floating point ranges are also possible (types "float" or "double") but the behavior of some methods differs slightly from integers. For instance, an integer range containing a single value has size 1, but a floating point range with one value has size zero. The differences are noted in the documentation for the particular methods affected. </p>

<p class="definition">Definition at line <a class="el" href="rangemap_8h_source.html#l00050">50</a> of file <a class="el" href="rangemap_8h_source.html">rangemap.h</a>.</p>
</div>
<p><code>#include &lt;<a class="el" href="rangemap_8h_source.html">roseSupport/rangemap.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for Range&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classRange__coll__graph.png" border="0" usemap="#Range_3_01T_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="Range_3_01T_01_4_coll__map" id="Range_3_01T_01_4_coll__map">
<area shape="rect" title="A contiguous range of values." alt="" coords="5,109,97,136"/>
<area shape="rect" title=" " alt="" coords="32,5,71,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a0110e09e84e56cb5b63bc5bde2a2a241"><td class="memItemLeft" align="right" valign="top"><a id="a0110e09e84e56cb5b63bc5bde2a2a241"></a>
typedef T&#160;</td><td class="memItemRight" valign="bottom"><b>Value</b></td></tr>
<tr class="separator:a0110e09e84e56cb5b63bc5bde2a2a241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3923ec69e4164340464742755686ade"><td class="memItemLeft" align="right" valign="top"><a id="ae3923ec69e4164340464742755686ade"></a>
typedef std::pair&lt; <a class="el" href="classRange.html">Range</a>, <a class="el" href="classRange.html">Range</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRange.html#ae3923ec69e4164340464742755686ade">Pair</a></td></tr>
<tr class="memdesc:ae3923ec69e4164340464742755686ade"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pair of ranges. <br /></td></tr>
<tr class="separator:ae3923ec69e4164340464742755686ade"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6f65c35914aeb4d5238b6acddaf40680"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRange.html#a6f65c35914aeb4d5238b6acddaf40680">Range</a> ()</td></tr>
<tr class="memdesc:a6f65c35914aeb4d5238b6acddaf40680"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an empty range.  <a href="classRange.html#a6f65c35914aeb4d5238b6acddaf40680">More...</a><br /></td></tr>
<tr class="separator:a6f65c35914aeb4d5238b6acddaf40680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63708908faf1d6cd293bf6a83cf5a13a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRange.html#a63708908faf1d6cd293bf6a83cf5a13a">Range</a> (const Value &amp;<a class="el" href="classRange.html#a130cadb6ba89a4777ca44fa1a6489f27">first</a>)</td></tr>
<tr class="memdesc:a63708908faf1d6cd293bf6a83cf5a13a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new range of unit size.  <a href="classRange.html#a63708908faf1d6cd293bf6a83cf5a13a">More...</a><br /></td></tr>
<tr class="separator:a63708908faf1d6cd293bf6a83cf5a13a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3930d5474001c881ca3ff922fb22501b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRange.html#a3930d5474001c881ca3ff922fb22501b">Range</a> (const Value &amp;<a class="el" href="classRange.html#a130cadb6ba89a4777ca44fa1a6489f27">first</a>, const Value &amp;<a class="el" href="classRange.html#aeb6128b91ac1c805bf5880bc3db25d98">size</a>)</td></tr>
<tr class="memdesc:a3930d5474001c881ca3ff922fb22501b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new range of specified size.  <a href="classRange.html#a3930d5474001c881ca3ff922fb22501b">More...</a><br /></td></tr>
<tr class="separator:a3930d5474001c881ca3ff922fb22501b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affb09623a26db19382ff3e1b4c1ef320"><td class="memTemplParams" colspan="2"><a id="affb09623a26db19382ff3e1b4c1ef320"></a>
template&lt;class Other &gt; </td></tr>
<tr class="memitem:affb09623a26db19382ff3e1b4c1ef320"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRange.html#affb09623a26db19382ff3e1b4c1ef320">Range</a> (const Other &amp;other)</td></tr>
<tr class="memdesc:affb09623a26db19382ff3e1b4c1ef320"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new range from a different range. <br /></td></tr>
<tr class="separator:affb09623a26db19382ff3e1b4c1ef320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb6128b91ac1c805bf5880bc3db25d98"><td class="memItemLeft" align="right" valign="top">Value&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRange.html#aeb6128b91ac1c805bf5880bc3db25d98">size</a> () const</td></tr>
<tr class="memdesc:aeb6128b91ac1c805bf5880bc3db25d98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of values represented by the range.  <a href="classRange.html#aeb6128b91ac1c805bf5880bc3db25d98">More...</a><br /></td></tr>
<tr class="separator:aeb6128b91ac1c805bf5880bc3db25d98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1565cc76fe5c129d27f91fc52111ac0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRange.html#ae3923ec69e4164340464742755686ade">Pair</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRange.html#af1565cc76fe5c129d27f91fc52111ac0">split_range_at</a> (const Value &amp;at) const</td></tr>
<tr class="memdesc:af1565cc76fe5c129d27f91fc52111ac0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a range into two parts.  <a href="classRange.html#af1565cc76fe5c129d27f91fc52111ac0">More...</a><br /></td></tr>
<tr class="separator:af1565cc76fe5c129d27f91fc52111ac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1b42f0582bb921b869204a0f032634d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRange.html">Range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRange.html#ae1b42f0582bb921b869204a0f032634d">join</a> (const <a class="el" href="classRange.html">Range</a> &amp;right) const</td></tr>
<tr class="memdesc:ae1b42f0582bb921b869204a0f032634d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Joins two adjacent ranges.  <a href="classRange.html#ae1b42f0582bb921b869204a0f032634d">More...</a><br /></td></tr>
<tr class="separator:ae1b42f0582bb921b869204a0f032634d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad9acd6f1f309be7f5ea1545625846b3"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classRange.html">Range</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRange.html#aad9acd6f1f309be7f5ea1545625846b3">erase</a> (const <a class="el" href="classRange.html">Range</a> &amp;to_erase) const</td></tr>
<tr class="memdesc:aad9acd6f1f309be7f5ea1545625846b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase part of a range to return zero, one, or two new ranges.  <a href="classRange.html#aad9acd6f1f309be7f5ea1545625846b3">More...</a><br /></td></tr>
<tr class="separator:aad9acd6f1f309be7f5ea1545625846b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a31e4ce0e271ea628fa3b2a9f9cb3c2"><td class="memItemLeft" align="right" valign="top"><a id="a7a31e4ce0e271ea628fa3b2a9f9cb3c2"></a>
<a class="el" href="classRange.html">Range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRange.html#a7a31e4ce0e271ea628fa3b2a9f9cb3c2">intersect</a> (const <a class="el" href="classRange.html">Range</a> &amp;other) const</td></tr>
<tr class="memdesc:a7a31e4ce0e271ea628fa3b2a9f9cb3c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intersection of two ranges. <br /></td></tr>
<tr class="separator:a7a31e4ce0e271ea628fa3b2a9f9cb3c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a465aed8393a396cb2fa663823e13d5b1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRange.html#a465aed8393a396cb2fa663823e13d5b1">empty</a> () const</td></tr>
<tr class="memdesc:a465aed8393a396cb2fa663823e13d5b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this range is empty.  <a href="classRange.html#a465aed8393a396cb2fa663823e13d5b1">More...</a><br /></td></tr>
<tr class="separator:a465aed8393a396cb2fa663823e13d5b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05a5b908926e64956b0db27d19b0bd5e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRange.html#a05a5b908926e64956b0db27d19b0bd5e">clear</a> ()</td></tr>
<tr class="memdesc:a05a5b908926e64956b0db27d19b0bd5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a range empty.  <a href="classRange.html#a05a5b908926e64956b0db27d19b0bd5e">More...</a><br /></td></tr>
<tr class="separator:a05a5b908926e64956b0db27d19b0bd5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4366ac4b363a01d09d3a5ceb8d363687"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRange.html#a4366ac4b363a01d09d3a5ceb8d363687">begins_with</a> (const <a class="el" href="classRange.html">Range</a> &amp;x) const</td></tr>
<tr class="memdesc:a4366ac4b363a01d09d3a5ceb8d363687"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do both ranges begin at the same place?  <a href="classRange.html#a4366ac4b363a01d09d3a5ceb8d363687">More...</a><br /></td></tr>
<tr class="separator:a4366ac4b363a01d09d3a5ceb8d363687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedd334dfa64295d16df19456cbf9914b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRange.html#aedd334dfa64295d16df19456cbf9914b">ends_with</a> (const <a class="el" href="classRange.html">Range</a> &amp;x) const</td></tr>
<tr class="memdesc:aedd334dfa64295d16df19456cbf9914b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do both ranges end at the same place?  <a href="classRange.html#aedd334dfa64295d16df19456cbf9914b">More...</a><br /></td></tr>
<tr class="separator:aedd334dfa64295d16df19456cbf9914b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad96c05f51ff94ad174f5f2bee8308353"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRange.html#ad96c05f51ff94ad174f5f2bee8308353">begins_after</a> (const <a class="el" href="classRange.html">Range</a> &amp;x, bool strict=true) const</td></tr>
<tr class="memdesc:ad96c05f51ff94ad174f5f2bee8308353"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does this range begin (strictly) after the beginning of another range?  <a href="classRange.html#ad96c05f51ff94ad174f5f2bee8308353">More...</a><br /></td></tr>
<tr class="separator:ad96c05f51ff94ad174f5f2bee8308353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2e055ad621559a8d09563244275e877"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRange.html#ad2e055ad621559a8d09563244275e877">begins_before</a> (const <a class="el" href="classRange.html">Range</a> &amp;x, bool strict=true) const</td></tr>
<tr class="memdesc:ad2e055ad621559a8d09563244275e877"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does this range begin (strictly) before the beginning of another range?  <a href="classRange.html#ad2e055ad621559a8d09563244275e877">More...</a><br /></td></tr>
<tr class="separator:ad2e055ad621559a8d09563244275e877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a568148ea1f7a012b6a9ee75579d2b544"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRange.html#a568148ea1f7a012b6a9ee75579d2b544">ends_after</a> (const <a class="el" href="classRange.html">Range</a> &amp;x, bool strict=true) const</td></tr>
<tr class="memdesc:a568148ea1f7a012b6a9ee75579d2b544"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does this range end (strictly) after the end of another range?  <a href="classRange.html#a568148ea1f7a012b6a9ee75579d2b544">More...</a><br /></td></tr>
<tr class="separator:a568148ea1f7a012b6a9ee75579d2b544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5519eb67dd6df2586a2a21073880dbc3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRange.html#a5519eb67dd6df2586a2a21073880dbc3">ends_before</a> (const <a class="el" href="classRange.html">Range</a> &amp;x, bool strict=true) const</td></tr>
<tr class="memdesc:a5519eb67dd6df2586a2a21073880dbc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does this range end (strictly) before the end of another range?  <a href="classRange.html#a5519eb67dd6df2586a2a21073880dbc3">More...</a><br /></td></tr>
<tr class="separator:a5519eb67dd6df2586a2a21073880dbc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a912b54aab45eeb8c4301f5c9e918c802"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRange.html#a912b54aab45eeb8c4301f5c9e918c802">contains</a> (const <a class="el" href="classRange.html">Range</a> &amp;x, bool strict=false) const</td></tr>
<tr class="memdesc:a912b54aab45eeb8c4301f5c9e918c802"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does this range contain the argument range?  <a href="classRange.html#a912b54aab45eeb8c4301f5c9e918c802">More...</a><br /></td></tr>
<tr class="separator:a912b54aab45eeb8c4301f5c9e918c802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a114a9f8c195e2cc8286c4bff8af963d8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRange.html#a114a9f8c195e2cc8286c4bff8af963d8">contained_in</a> (const <a class="el" href="classRange.html">Range</a> &amp;x, bool strict=false) const</td></tr>
<tr class="memdesc:a114a9f8c195e2cc8286c4bff8af963d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this range contained in the argument range?  <a href="classRange.html#a114a9f8c195e2cc8286c4bff8af963d8">More...</a><br /></td></tr>
<tr class="separator:a114a9f8c195e2cc8286c4bff8af963d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc11e8e5da0d8040213090be1c57642b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRange.html#abc11e8e5da0d8040213090be1c57642b">congruent</a> (const <a class="el" href="classRange.html">Range</a> &amp;x) const</td></tr>
<tr class="memdesc:abc11e8e5da0d8040213090be1c57642b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Are two ranges equal?  <a href="classRange.html#abc11e8e5da0d8040213090be1c57642b">More...</a><br /></td></tr>
<tr class="separator:abc11e8e5da0d8040213090be1c57642b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8235f297331f655a89d44c3930cc6ec5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRange.html#a8235f297331f655a89d44c3930cc6ec5">left_of</a> (const <a class="el" href="classRange.html">Range</a> &amp;x) const</td></tr>
<tr class="memdesc:a8235f297331f655a89d44c3930cc6ec5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this range left of the argument range?  <a href="classRange.html#a8235f297331f655a89d44c3930cc6ec5">More...</a><br /></td></tr>
<tr class="separator:a8235f297331f655a89d44c3930cc6ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f5aa3b5c4e5b92b394e45d94a7dfeaa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRange.html#a6f5aa3b5c4e5b92b394e45d94a7dfeaa">right_of</a> (const <a class="el" href="classRange.html">Range</a> &amp;x) const</td></tr>
<tr class="memdesc:a6f5aa3b5c4e5b92b394e45d94a7dfeaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this range right of the argument range?  <a href="classRange.html#a6f5aa3b5c4e5b92b394e45d94a7dfeaa">More...</a><br /></td></tr>
<tr class="separator:a6f5aa3b5c4e5b92b394e45d94a7dfeaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf652e7f98ecb33841f68933837b74fd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRange.html#acf652e7f98ecb33841f68933837b74fd">overlaps</a> (const <a class="el" href="classRange.html">Range</a> &amp;x) const</td></tr>
<tr class="memdesc:acf652e7f98ecb33841f68933837b74fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does this range overlap with the argument range?  <a href="classRange.html#acf652e7f98ecb33841f68933837b74fd">More...</a><br /></td></tr>
<tr class="separator:acf652e7f98ecb33841f68933837b74fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42e5a1fd8d22b971b1ae6baf579dfbfa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRange.html#a42e5a1fd8d22b971b1ae6baf579dfbfa">distinct</a> (const <a class="el" href="classRange.html">Range</a> &amp;x) const</td></tr>
<tr class="memdesc:a42e5a1fd8d22b971b1ae6baf579dfbfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this range non-overlapping with the argument range?  <a href="classRange.html#a42e5a1fd8d22b971b1ae6baf579dfbfa">More...</a><br /></td></tr>
<tr class="separator:a42e5a1fd8d22b971b1ae6baf579dfbfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8355e4409e104e2ed2395aabf7abd038"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRange.html#a8355e4409e104e2ed2395aabf7abd038">abuts_lt</a> (const <a class="el" href="classRange.html">Range</a> &amp;x) const</td></tr>
<tr class="memdesc:a8355e4409e104e2ed2395aabf7abd038"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this range immediately left of the argument range?  <a href="classRange.html#a8355e4409e104e2ed2395aabf7abd038">More...</a><br /></td></tr>
<tr class="separator:a8355e4409e104e2ed2395aabf7abd038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a819bc05993d5b45f6b32be1c403ac2c0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRange.html#a819bc05993d5b45f6b32be1c403ac2c0">abuts_gt</a> (const <a class="el" href="classRange.html">Range</a> &amp;x) const</td></tr>
<tr class="memdesc:a819bc05993d5b45f6b32be1c403ac2c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this range immediately right of the argument range?  <a href="classRange.html#a819bc05993d5b45f6b32be1c403ac2c0">More...</a><br /></td></tr>
<tr class="separator:a819bc05993d5b45f6b32be1c403ac2c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3184fc28579e6b15a12ac32ea1207c08"><td class="memItemLeft" align="right" valign="top"><a id="a3184fc28579e6b15a12ac32ea1207c08"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classRange.html">Range</a> &amp;x) const</td></tr>
<tr class="separator:a3184fc28579e6b15a12ac32ea1207c08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af65e11d0f082430565e22be905010406"><td class="memItemLeft" align="right" valign="top"><a id="af65e11d0f082430565e22be905010406"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classRange.html">Range</a> &amp;x) const</td></tr>
<tr class="separator:af65e11d0f082430565e22be905010406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57676eaa1f39c1c3828dfb9c694c21e9"><td class="memItemLeft" align="right" valign="top"><a id="a57676eaa1f39c1c3828dfb9c694c21e9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>print</b> (std::ostream &amp;o) const</td></tr>
<tr class="separator:a57676eaa1f39c1c3828dfb9c694c21e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3019881ac0a1e947a1d453bf351d970"><td class="memItemLeft" align="right" valign="top"><a id="ab3019881ac0a1e947a1d453bf351d970"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>empty</b> () const</td></tr>
<tr class="separator:ab3019881ac0a1e947a1d453bf351d970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab79216fe7200b8925d382723803dcedc"><td class="memItemLeft" align="right" valign="top"><a id="ab79216fe7200b8925d382723803dcedc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clear</b> ()</td></tr>
<tr class="separator:ab79216fe7200b8925d382723803dcedc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca5bccbb11fefd8d2aa96ee5d3ff8be3"><td class="memItemLeft" align="right" valign="top"><a id="aca5bccbb11fefd8d2aa96ee5d3ff8be3"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>relaxed_first</b> () const</td></tr>
<tr class="separator:aca5bccbb11fefd8d2aa96ee5d3ff8be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dd3f30bfbbb4bb3b15b2f7f7926286e"><td class="memItemLeft" align="right" valign="top"><a id="a8dd3f30bfbbb4bb3b15b2f7f7926286e"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>size</b> () const</td></tr>
<tr class="separator:a8dd3f30bfbbb4bb3b15b2f7f7926286e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a072550aa5e4b7c1a4f44cdb7ac4fb4d9"><td class="memItemLeft" align="right" valign="top"><a id="a072550aa5e4b7c1a4f44cdb7ac4fb4d9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>resize</b> (const double &amp;new_size)</td></tr>
<tr class="separator:a072550aa5e4b7c1a4f44cdb7ac4fb4d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87ce16af8cb42113f836a9138c2724e0"><td class="memItemLeft" align="right" valign="top"><a id="a87ce16af8cb42113f836a9138c2724e0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>relaxed_resize</b> (const double &amp;new_size)</td></tr>
<tr class="separator:a87ce16af8cb42113f836a9138c2724e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcda64c0a43f71af8f35cf4cc2c23ccb"><td class="memItemLeft" align="right" valign="top"><a id="adcda64c0a43f71af8f35cf4cc2c23ccb"></a>
<a class="el" href="classRange.html">Range</a>&lt; double &gt;::<a class="el" href="classRange.html#ae3923ec69e4164340464742755686ade">Pair</a>&#160;</td><td class="memItemRight" valign="bottom"><b>split_range_at</b> (const double &amp;at) const</td></tr>
<tr class="separator:adcda64c0a43f71af8f35cf4cc2c23ccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5b7d2339f65f0d8ede796da9dba7579"><td class="memItemLeft" align="right" valign="top"><a id="ab5b7d2339f65f0d8ede796da9dba7579"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>minimum</b> ()</td></tr>
<tr class="separator:ab5b7d2339f65f0d8ede796da9dba7579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c024e5c81a030e4cb11aafe4c6de057"><td class="memItemLeft" align="right" valign="top"><a id="a2c024e5c81a030e4cb11aafe4c6de057"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>maximum</b> ()</td></tr>
<tr class="separator:a2c024e5c81a030e4cb11aafe4c6de057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acea6017a8e909ee538630a2268fdd3fc"><td class="memItemLeft" align="right" valign="top"><a id="acea6017a8e909ee538630a2268fdd3fc"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>empty</b> () const</td></tr>
<tr class="separator:acea6017a8e909ee538630a2268fdd3fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3cefcc5a147db88ef9cf31fc62c3c07"><td class="memItemLeft" align="right" valign="top"><a id="ae3cefcc5a147db88ef9cf31fc62c3c07"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clear</b> ()</td></tr>
<tr class="separator:ae3cefcc5a147db88ef9cf31fc62c3c07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3a8fba6ed9e6c4185fd12b8b58fe265"><td class="memItemLeft" align="right" valign="top"><a id="ad3a8fba6ed9e6c4185fd12b8b58fe265"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>relaxed_first</b> () const</td></tr>
<tr class="separator:ad3a8fba6ed9e6c4185fd12b8b58fe265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb591b941ae80199fd1bde42710a7290"><td class="memItemLeft" align="right" valign="top"><a id="afb591b941ae80199fd1bde42710a7290"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>size</b> () const</td></tr>
<tr class="separator:afb591b941ae80199fd1bde42710a7290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43e51060ca8fc64350b76996b13f61c4"><td class="memItemLeft" align="right" valign="top"><a id="a43e51060ca8fc64350b76996b13f61c4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>resize</b> (const float &amp;new_size)</td></tr>
<tr class="separator:a43e51060ca8fc64350b76996b13f61c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a03ef3aa481d9835fc63c7ab6117d78"><td class="memItemLeft" align="right" valign="top"><a id="a3a03ef3aa481d9835fc63c7ab6117d78"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>relaxed_resize</b> (const float &amp;new_size)</td></tr>
<tr class="separator:a3a03ef3aa481d9835fc63c7ab6117d78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2f880787afa9241a2e4fc15c7568cdc"><td class="memItemLeft" align="right" valign="top"><a id="ae2f880787afa9241a2e4fc15c7568cdc"></a>
<a class="el" href="classRange.html">Range</a>&lt; float &gt;::<a class="el" href="classRange.html#ae3923ec69e4164340464742755686ade">Pair</a>&#160;</td><td class="memItemRight" valign="bottom"><b>split_range_at</b> (const float &amp;at) const</td></tr>
<tr class="separator:ae2f880787afa9241a2e4fc15c7568cdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26d9a5b09615559a56b2e0b3ee6e4762"><td class="memItemLeft" align="right" valign="top"><a id="a26d9a5b09615559a56b2e0b3ee6e4762"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>minimum</b> ()</td></tr>
<tr class="separator:a26d9a5b09615559a56b2e0b3ee6e4762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e1ec23b102256d0379ba75388069548"><td class="memItemLeft" align="right" valign="top"><a id="a4e1ec23b102256d0379ba75388069548"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>maximum</b> ()</td></tr>
<tr class="separator:a4e1ec23b102256d0379ba75388069548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a130cadb6ba89a4777ca44fa1a6489f27"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRange.html#a130cadb6ba89a4777ca44fa1a6489f27">first</a> (const Value &amp;first)</td></tr>
<tr class="memdesc:a130cadb6ba89a4777ca44fa1a6489f27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor for the first value of a range.  <a href="classRange.html#a130cadb6ba89a4777ca44fa1a6489f27">More...</a><br /></td></tr>
<tr class="separator:a130cadb6ba89a4777ca44fa1a6489f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add78a5b6d9526306391f1a32d4e35a5f"><td class="memItemLeft" align="right" valign="top">const Value&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRange.html#add78a5b6d9526306391f1a32d4e35a5f">first</a> () const</td></tr>
<tr class="memdesc:add78a5b6d9526306391f1a32d4e35a5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor for the first value of a range.  <a href="classRange.html#add78a5b6d9526306391f1a32d4e35a5f">More...</a><br /></td></tr>
<tr class="separator:add78a5b6d9526306391f1a32d4e35a5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a23c9832a5ff249bc3ed2e7c259ffbe"><td class="memItemLeft" align="right" valign="top">Value&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRange.html#a6a23c9832a5ff249bc3ed2e7c259ffbe">relaxed_first</a> () const</td></tr>
<tr class="memdesc:a6a23c9832a5ff249bc3ed2e7c259ffbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor for the first value of a range.  <a href="classRange.html#a6a23c9832a5ff249bc3ed2e7c259ffbe">More...</a><br /></td></tr>
<tr class="separator:a6a23c9832a5ff249bc3ed2e7c259ffbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a347c0e723bcd929107dc0fffe31478f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRange.html#a347c0e723bcd929107dc0fffe31478f2">last</a> (const Value &amp;last)</td></tr>
<tr class="memdesc:a347c0e723bcd929107dc0fffe31478f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor for the last value of a range.  <a href="classRange.html#a347c0e723bcd929107dc0fffe31478f2">More...</a><br /></td></tr>
<tr class="separator:a347c0e723bcd929107dc0fffe31478f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62640643b90f783799fb5b414fe5886e"><td class="memItemLeft" align="right" valign="top">const Value&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRange.html#a62640643b90f783799fb5b414fe5886e">last</a> () const</td></tr>
<tr class="memdesc:a62640643b90f783799fb5b414fe5886e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor for the last value of a range.  <a href="classRange.html#a62640643b90f783799fb5b414fe5886e">More...</a><br /></td></tr>
<tr class="separator:a62640643b90f783799fb5b414fe5886e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4de01a5a9c10a8d6399690f226d06038"><td class="memItemLeft" align="right" valign="top">const Value&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRange.html#a4de01a5a9c10a8d6399690f226d06038">relaxed_last</a> () const</td></tr>
<tr class="memdesc:a4de01a5a9c10a8d6399690f226d06038"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor for the last value of a range.  <a href="classRange.html#a4de01a5a9c10a8d6399690f226d06038">More...</a><br /></td></tr>
<tr class="separator:a4de01a5a9c10a8d6399690f226d06038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a6d27e17fadca79e6f3851c60ee50d12c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRange.html#a6d27e17fadca79e6f3851c60ee50d12c">resize</a> (const Value &amp;new_size)</td></tr>
<tr class="memdesc:a6d27e17fadca79e6f3851c60ee50d12c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the range size by adjusting the maximum value.  <a href="classRange.html#a6d27e17fadca79e6f3851c60ee50d12c">More...</a><br /></td></tr>
<tr class="separator:a6d27e17fadca79e6f3851c60ee50d12c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f5c7d315a8304db49076bfea9a30a24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRange.html#a8f5c7d315a8304db49076bfea9a30a24">relaxed_resize</a> (const Value &amp;new_size)</td></tr>
<tr class="memdesc:a8f5c7d315a8304db49076bfea9a30a24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the range size by adjusting the maximum value.  <a href="classRange.html#a8f5c7d315a8304db49076bfea9a30a24">More...</a><br /></td></tr>
<tr class="separator:a8f5c7d315a8304db49076bfea9a30a24"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a785281ce194b217cf86c35a4d6f42c98"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classRange.html">Range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRange.html#a785281ce194b217cf86c35a4d6f42c98">inin</a> (const Value &amp;v1, const Value &amp;v2)</td></tr>
<tr class="memdesc:a785281ce194b217cf86c35a4d6f42c98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new range by giving the first (inclusive) and last value (inclusive).  <a href="classRange.html#a785281ce194b217cf86c35a4d6f42c98">More...</a><br /></td></tr>
<tr class="separator:a785281ce194b217cf86c35a4d6f42c98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01f96080d72cc93eb611df9032539f6c"><td class="memItemLeft" align="right" valign="top"><a id="a01f96080d72cc93eb611df9032539f6c"></a>
static Value&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRange.html#a01f96080d72cc93eb611df9032539f6c">minimum</a> ()</td></tr>
<tr class="memdesc:a01f96080d72cc93eb611df9032539f6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the minimum possible value represented by this range. <br /></td></tr>
<tr class="separator:a01f96080d72cc93eb611df9032539f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71ec8b29f10d748e6c9548e1b38c2d6f"><td class="memItemLeft" align="right" valign="top"><a id="a71ec8b29f10d748e6c9548e1b38c2d6f"></a>
static Value&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRange.html#a71ec8b29f10d748e6c9548e1b38c2d6f">maximum</a> ()</td></tr>
<tr class="memdesc:a71ec8b29f10d748e6c9548e1b38c2d6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum possible value represented by this range. <br /></td></tr>
<tr class="separator:a71ec8b29f10d748e6c9548e1b38c2d6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f18d23e23462756b3ee7d433414eaa9"><td class="memItemLeft" align="right" valign="top"><a id="a6f18d23e23462756b3ee7d433414eaa9"></a>
static <a class="el" href="classRange.html">Range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRange.html#a6f18d23e23462756b3ee7d433414eaa9">all</a> ()</td></tr>
<tr class="memdesc:a6f18d23e23462756b3ee7d433414eaa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a range that covers all possible values. <br /></td></tr>
<tr class="separator:a6f18d23e23462756b3ee7d433414eaa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:af299b59b3a30f29cda6c684e377ce75c"><td class="memItemLeft" align="right" valign="top"><a id="af299b59b3a30f29cda6c684e377ce75c"></a>
Value&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRange.html#af299b59b3a30f29cda6c684e377ce75c">r_first</a></td></tr>
<tr class="memdesc:af299b59b3a30f29cda6c684e377ce75c"><td class="mdescLeft">&#160;</td><td class="mdescRight">First value in range. <br /></td></tr>
<tr class="separator:af299b59b3a30f29cda6c684e377ce75c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a6e0ab604e9afadc469eb3cb1a65584"><td class="memItemLeft" align="right" valign="top"><a id="a8a6e0ab604e9afadc469eb3cb1a65584"></a>
Value&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRange.html#a8a6e0ab604e9afadc469eb3cb1a65584">r_last</a></td></tr>
<tr class="memdesc:a8a6e0ab604e9afadc469eb3cb1a65584"><td class="mdescLeft">&#160;</td><td class="mdescRight">Last value in range. <br /></td></tr>
<tr class="separator:a8a6e0ab604e9afadc469eb3cb1a65584"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a6f65c35914aeb4d5238b6acddaf40680"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f65c35914aeb4d5238b6acddaf40680">&#9670;&nbsp;</a></span>Range() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRange.html">Range</a>&lt; T &gt;::<a class="el" href="classRange.html">Range</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an empty range. </p>
<p>Ranges may have an empty size, but empty ranges will never appear inside a <a class="el" href="classRangeMap.html" title="A container of ranges, somewhat like a set.">RangeMap</a> object. The <code>begin</code> value of an empty range is meaningless. </p>

<p class="definition">Definition at line <a class="el" href="rangemap_8h_source.html#l00064">64</a> of file <a class="el" href="rangemap_8h_source.html">rangemap.h</a>.</p>

</div>
</div>
<a id="a63708908faf1d6cd293bf6a83cf5a13a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63708908faf1d6cd293bf6a83cf5a13a">&#9670;&nbsp;</a></span>Range() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRange.html">Range</a>&lt; T &gt;::<a class="el" href="classRange.html">Range</a> </td>
          <td>(</td>
          <td class="paramtype">const Value &amp;&#160;</td>
          <td class="paramname"><em>first</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new range of unit size. </p>
<p>The new range contains only the specified value. </p>

<p class="definition">Definition at line <a class="el" href="rangemap_8h_source.html#l00068">68</a> of file <a class="el" href="rangemap_8h_source.html">rangemap.h</a>.</p>

</div>
</div>
<a id="a3930d5474001c881ca3ff922fb22501b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3930d5474001c881ca3ff922fb22501b">&#9670;&nbsp;</a></span>Range() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRange.html">Range</a>&lt; T &gt;::<a class="el" href="classRange.html">Range</a> </td>
          <td>(</td>
          <td class="paramtype">const Value &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Value &amp;&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new range of specified size. </p>
<p>If <code>size</code> is zero then an empty range is created. Note that a zero size is also returned for a range that contains all values, but this is due to overflow. Whether this is an integer range or a floating point range, if size is zero then the range is considered to be empty (but the <code>first</code> value is remembered). To create a floating point range with a single value, use the single-argument constructor. </p>

<p class="definition">Definition at line <a class="el" href="rangemap_8h_source.html#l00075">75</a> of file <a class="el" href="rangemap_8h_source.html">rangemap.h</a>.</p>

<p class="reference">References <a class="el" href="rangemap_8h_source.html#l00257">Range&lt; T &gt;::clear()</a>, <a class="el" href="rangemap_8h_source.html#l00108">Range&lt; T &gt;::first()</a>, and <a class="el" href="rangemap_8h_source.html#l00059">Range&lt; T &gt;::r_last</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classRange_a3930d5474001c881ca3ff922fb22501b_cgraph.png" border="0" usemap="#classRange_a3930d5474001c881ca3ff922fb22501b_cgraph" alt=""/></div>
<map name="classRange_a3930d5474001c881ca3ff922fb22501b_cgraph" id="classRange_a3930d5474001c881ca3ff922fb22501b_cgraph">
<area shape="rect" title="Create a new range of specified size." alt="" coords="5,31,112,57"/>
<area shape="rect" href="classRange.html#a05a5b908926e64956b0db27d19b0bd5e" title="Make a range empty." alt="" coords="160,5,256,32"/>
<area shape="rect" href="classRange.html#add78a5b6d9526306391f1a32d4e35a5f" title="Accessor for the first value of a range." alt="" coords="163,56,253,83"/>
</map>
</div>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a785281ce194b217cf86c35a4d6f42c98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a785281ce194b217cf86c35a4d6f42c98">&#9670;&nbsp;</a></span>inin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classRange.html">Range</a> <a class="el" href="classRange.html">Range</a>&lt; T &gt;::inin </td>
          <td>(</td>
          <td class="paramtype">const Value &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Value &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new range by giving the first (inclusive) and last value (inclusive). </p>
<p>This is the only way to create a range that contains all values since the size of such a range overflows the range's Value type. If the two values are equal then the created range contains only that value; if the first value is larger than the second then the range is considered to be empty. </p>

<p class="definition">Definition at line <a class="el" href="rangemap_8h_source.html#l00094">94</a> of file <a class="el" href="rangemap_8h_source.html">rangemap.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="rangemap_8h_source.html#l01371">RangeMap&lt; R, T &gt;::invert_within()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classRange_a785281ce194b217cf86c35a4d6f42c98_icgraph.png" border="0" usemap="#classRange_a785281ce194b217cf86c35a4d6f42c98_icgraph" alt=""/></div>
<map name="classRange_a785281ce194b217cf86c35a4d6f42c98_icgraph" id="classRange_a785281ce194b217cf86c35a4d6f42c98_icgraph">
<area shape="rect" title="Create a new range by giving the first (inclusive) and last value (inclusive)." alt="" coords="220,5,308,32"/>
<area shape="rect" href="classRangeMap.html#a1a97944c25e824155320715afd71bc3c" title="Create a range map that&#39;s the inverse of some other map." alt="" coords="5,5,172,32"/>
</map>
</div>

</div>
</div>
<a id="a130cadb6ba89a4777ca44fa1a6489f27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a130cadb6ba89a4777ca44fa1a6489f27">&#9670;&nbsp;</a></span>first() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classRange.html">Range</a>&lt; T &gt;::first </td>
          <td>(</td>
          <td class="paramtype">const Value &amp;&#160;</td>
          <td class="paramname"><em>first</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accessor for the first value of a range. </p>
<p>It does not make sense to ask for the first value of an empty range, and an assertion will fail if such a request is made. However, <a class="el" href="classRange.html#a6a23c9832a5ff249bc3ed2e7c259ffbe" title="Accessor for the first value of a range.">relaxed_first()</a> will return a value anyway. </p>

<p class="definition">Definition at line <a class="el" href="rangemap_8h_source.html#l00105">105</a> of file <a class="el" href="rangemap_8h_source.html">rangemap.h</a>.</p>

</div>
</div>
<a id="add78a5b6d9526306391f1a32d4e35a5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add78a5b6d9526306391f1a32d4e35a5f">&#9670;&nbsp;</a></span>first() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Value <a class="el" href="classRange.html">Range</a>&lt; T &gt;::first </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accessor for the first value of a range. </p>
<p>It does not make sense to ask for the first value of an empty range, and an assertion will fail if such a request is made. However, <a class="el" href="classRange.html#a6a23c9832a5ff249bc3ed2e7c259ffbe" title="Accessor for the first value of a range.">relaxed_first()</a> will return a value anyway. </p>

<p class="definition">Definition at line <a class="el" href="rangemap_8h_source.html#l00108">108</a> of file <a class="el" href="rangemap_8h_source.html">rangemap.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="rangemap_8h_source.html#l00075">Range&lt; T &gt;::Range()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classRange_add78a5b6d9526306391f1a32d4e35a5f_icgraph.png" border="0" usemap="#classRange_add78a5b6d9526306391f1a32d4e35a5f_icgraph" alt=""/></div>
<map name="classRange_add78a5b6d9526306391f1a32d4e35a5f_icgraph" id="classRange_add78a5b6d9526306391f1a32d4e35a5f_icgraph">
<area shape="rect" title="Accessor for the first value of a range." alt="" coords="160,5,251,32"/>
<area shape="rect" href="classRange.html#a3930d5474001c881ca3ff922fb22501b" title="Create a new range of specified size." alt="" coords="5,5,112,32"/>
</map>
</div>

</div>
</div>
<a id="a6a23c9832a5ff249bc3ed2e7c259ffbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a23c9832a5ff249bc3ed2e7c259ffbe">&#9670;&nbsp;</a></span>relaxed_first()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Value <a class="el" href="classRange.html">Range</a>&lt; T &gt;::relaxed_first </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accessor for the first value of a range. </p>
<p>It does not make sense to ask for the first value of an empty range, and an assertion will fail if such a request is made. However, <a class="el" href="classRange.html#a6a23c9832a5ff249bc3ed2e7c259ffbe" title="Accessor for the first value of a range.">relaxed_first()</a> will return a value anyway. </p>

<p class="definition">Definition at line <a class="el" href="rangemap_8h_source.html#l00117">117</a> of file <a class="el" href="rangemap_8h_source.html">rangemap.h</a>.</p>

</div>
</div>
<a id="a347c0e723bcd929107dc0fffe31478f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a347c0e723bcd929107dc0fffe31478f2">&#9670;&nbsp;</a></span>last() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classRange.html">Range</a>&lt; T &gt;::last </td>
          <td>(</td>
          <td class="paramtype">const Value &amp;&#160;</td>
          <td class="paramname"><em>last</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accessor for the last value of a range. </p>
<p>It does not make sense to ask for the last value of an empty range, and an assertion will fail if such a request is made. However, <a class="el" href="classRange.html#a4de01a5a9c10a8d6399690f226d06038" title="Accessor for the last value of a range.">relaxed_last()</a> will return a value anyway. </p>

<p class="definition">Definition at line <a class="el" href="rangemap_8h_source.html#l00129">129</a> of file <a class="el" href="rangemap_8h_source.html">rangemap.h</a>.</p>

</div>
</div>
<a id="a62640643b90f783799fb5b414fe5886e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62640643b90f783799fb5b414fe5886e">&#9670;&nbsp;</a></span>last() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Value <a class="el" href="classRange.html">Range</a>&lt; T &gt;::last </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accessor for the last value of a range. </p>
<p>It does not make sense to ask for the last value of an empty range, and an assertion will fail if such a request is made. However, <a class="el" href="classRange.html#a4de01a5a9c10a8d6399690f226d06038" title="Accessor for the last value of a range.">relaxed_last()</a> will return a value anyway. </p>

<p class="definition">Definition at line <a class="el" href="rangemap_8h_source.html#l00132">132</a> of file <a class="el" href="rangemap_8h_source.html">rangemap.h</a>.</p>

</div>
</div>
<a id="a4de01a5a9c10a8d6399690f226d06038"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4de01a5a9c10a8d6399690f226d06038">&#9670;&nbsp;</a></span>relaxed_last()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Value <a class="el" href="classRange.html">Range</a>&lt; T &gt;::relaxed_last </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accessor for the last value of a range. </p>
<p>It does not make sense to ask for the last value of an empty range, and an assertion will fail if such a request is made. However, <a class="el" href="classRange.html#a4de01a5a9c10a8d6399690f226d06038" title="Accessor for the last value of a range.">relaxed_last()</a> will return a value anyway. </p>

<p class="definition">Definition at line <a class="el" href="rangemap_8h_source.html#l00136">136</a> of file <a class="el" href="rangemap_8h_source.html">rangemap.h</a>.</p>

</div>
</div>
<a id="aeb6128b91ac1c805bf5880bc3db25d98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb6128b91ac1c805bf5880bc3db25d98">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Value <a class="el" href="classRange.html">Range</a>&lt; T &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of values represented by the range. </p>
<p>Note that if the range contains all possible values then the returned size may be zero due to overflow, in which case the <a class="el" href="classRange.html#a465aed8393a396cb2fa663823e13d5b1" title="Returns true if this range is empty.">empty()</a> method should also be called to make the determination.</p>
<p>Floating point range sizes are simply the last value minus the first value. Therefore, a singleton floating point range will return a size of zero, while a singleton integer range will return a size of one. This is actualy consistent behavior if you think of an integer value N as the floating point range [N,N+1), where N is included in the range but N+1 is not. </p>

<p class="definition">Definition at line <a class="el" href="rangemap_8h_source.html#l00149">149</a> of file <a class="el" href="rangemap_8h_source.html">rangemap.h</a>.</p>

</div>
</div>
<a id="a6d27e17fadca79e6f3851c60ee50d12c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d27e17fadca79e6f3851c60ee50d12c">&#9670;&nbsp;</a></span>resize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classRange.html">Range</a>&lt; T &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">const Value &amp;&#160;</td>
          <td class="paramname"><em>new_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the range size by adjusting the maximum value. </p>
<p>It is an error to change the size of a range from zero to non-zero, but the <a class="el" href="classRange.html#a8f5c7d315a8304db49076bfea9a30a24" title="Sets the range size by adjusting the maximum value.">relaxed_resize()</a> is available for that purpose.</p>
<p>Setting the size to zero causes different behavior for integer ranges than it does for floating point ranges. For integer ranges, setting the size to zero clears the range (makes it empty); for floating point ranges, setting the size to zero causes the range to contain only the starting value. Floating point ranges can be cleared by setting the new size to a negative value. The <a class="el" href="classRange.html#a05a5b908926e64956b0db27d19b0bd5e" title="Make a range empty.">clear()</a> method should be favored over <a class="el" href="classRange.html#a6d27e17fadca79e6f3851c60ee50d12c" title="Sets the range size by adjusting the maximum value.">resize()</a> for making a range empty. </p>

<p class="definition">Definition at line <a class="el" href="rangemap_8h_source.html#l00164">164</a> of file <a class="el" href="rangemap_8h_source.html">rangemap.h</a>.</p>

<p class="reference">References <a class="el" href="rangemap_8h_source.html#l00257">Range&lt; T &gt;::clear()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classRange_a6d27e17fadca79e6f3851c60ee50d12c_cgraph.png" border="0" usemap="#classRange_a6d27e17fadca79e6f3851c60ee50d12c_cgraph" alt=""/></div>
<map name="classRange_a6d27e17fadca79e6f3851c60ee50d12c_cgraph" id="classRange_a6d27e17fadca79e6f3851c60ee50d12c_cgraph">
<area shape="rect" title="Sets the range size by adjusting the maximum value." alt="" coords="5,5,108,32"/>
<area shape="rect" href="classRange.html#a05a5b908926e64956b0db27d19b0bd5e" title="Make a range empty." alt="" coords="156,5,252,32"/>
</map>
</div>

</div>
</div>
<a id="a8f5c7d315a8304db49076bfea9a30a24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f5c7d315a8304db49076bfea9a30a24">&#9670;&nbsp;</a></span>relaxed_resize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classRange.html">Range</a>&lt; T &gt;::relaxed_resize </td>
          <td>(</td>
          <td class="paramtype">const Value &amp;&#160;</td>
          <td class="paramname"><em>new_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the range size by adjusting the maximum value. </p>
<p>It is an error to change the size of a range from zero to non-zero, but the <a class="el" href="classRange.html#a8f5c7d315a8304db49076bfea9a30a24" title="Sets the range size by adjusting the maximum value.">relaxed_resize()</a> is available for that purpose.</p>
<p>Setting the size to zero causes different behavior for integer ranges than it does for floating point ranges. For integer ranges, setting the size to zero clears the range (makes it empty); for floating point ranges, setting the size to zero causes the range to contain only the starting value. Floating point ranges can be cleared by setting the new size to a negative value. The <a class="el" href="classRange.html#a05a5b908926e64956b0db27d19b0bd5e" title="Make a range empty.">clear()</a> method should be favored over <a class="el" href="classRange.html#a6d27e17fadca79e6f3851c60ee50d12c" title="Sets the range size by adjusting the maximum value.">resize()</a> for making a range empty. </p>

<p class="definition">Definition at line <a class="el" href="rangemap_8h_source.html#l00173">173</a> of file <a class="el" href="rangemap_8h_source.html">rangemap.h</a>.</p>

</div>
</div>
<a id="af1565cc76fe5c129d27f91fc52111ac0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1565cc76fe5c129d27f91fc52111ac0">&#9670;&nbsp;</a></span>split_range_at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRange.html#ae3923ec69e4164340464742755686ade">Pair</a> <a class="el" href="classRange.html">Range</a>&lt; T &gt;::split_range_at </td>
          <td>(</td>
          <td class="paramtype">const Value &amp;&#160;</td>
          <td class="paramname"><em>at</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split a range into two parts. </p>
<p>Returns a pair of adjacent ranges such that <code>at</code> is the first value of the second returned range. The split point must be such that neither range is empty. </p>

<p class="definition">Definition at line <a class="el" href="rangemap_8h_source.html#l00186">186</a> of file <a class="el" href="rangemap_8h_source.html">rangemap.h</a>.</p>

</div>
</div>
<a id="ae1b42f0582bb921b869204a0f032634d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1b42f0582bb921b869204a0f032634d">&#9670;&nbsp;</a></span>join()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRange.html">Range</a> <a class="el" href="classRange.html">Range</a>&lt; T &gt;::join </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRange.html">Range</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Joins two adjacent ranges. </p>
<p>This range must be the left range, and the argument is the right range. They must be adjacent without overlapping. If one of the ranges is empty, then the return value is the other range (which might also be empty). </p>

<p class="definition">Definition at line <a class="el" href="rangemap_8h_source.html#l00197">197</a> of file <a class="el" href="rangemap_8h_source.html">rangemap.h</a>.</p>

</div>
</div>
<a id="aad9acd6f1f309be7f5ea1545625846b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad9acd6f1f309be7f5ea1545625846b3">&#9670;&nbsp;</a></span>erase()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classRange.html">Range</a>&gt; <a class="el" href="classRange.html">Range</a>&lt; T &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRange.html">Range</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>to_erase</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase part of a range to return zero, one, or two new ranges. </p>
<p>The possible situations are: </p><ol>
<li>
The range to erase can be a superset of this range, in which case this entire range is erased and nothing is returned. </li>
<li>
The range to erase can be empty, in which case this range is returned. </li>
<li>
The range to erase does not intersect this range, in which case this range is returned. </li>
<li>
The range to erase can overlap the low end of this range, in which case only the non-overlapping high end of this range is returned. </li>
<li>
The range to erase can overlap the high end of this range, in which case only the non-overlapping low end of this range is returned. </li>
<li>
The range to erase overlaps only the middle part of this range, in which case two ranges are returned: the non-overlapping low end of this range, and the non-overlapping high end of this range. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="rangemap_8h_source.html#l00220">220</a> of file <a class="el" href="rangemap_8h_source.html">rangemap.h</a>.</p>

</div>
</div>
<a id="a465aed8393a396cb2fa663823e13d5b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a465aed8393a396cb2fa663823e13d5b1">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classRange.html">Range</a>&lt; T &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this range is empty. </p>
<p>Note that many of the range comparison methods have special cases for empty ranges. Note that due to overflow, the <a class="el" href="classRange.html#aeb6128b91ac1c805bf5880bc3db25d98" title="Returns the number of values represented by the range.">size()</a> method may return zero for integer ranges if this range contains all possible values. It follows, then that the expressions "empty()" and "0==size()" are not always equal. </p>

<p class="definition">Definition at line <a class="el" href="rangemap_8h_source.html#l00251">251</a> of file <a class="el" href="rangemap_8h_source.html">rangemap.h</a>.</p>

</div>
</div>
<a id="a05a5b908926e64956b0db27d19b0bd5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05a5b908926e64956b0db27d19b0bd5e">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classRange.html">Range</a>&lt; T &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a range empty. </p>
<p>An empty range is one in which r_first is greater than r_last. We make special provisions here so that <a class="el" href="classRange.html#a6a23c9832a5ff249bc3ed2e7c259ffbe" title="Accessor for the first value of a range.">relaxed_first()</a> will continue to return the same value as it did before the range was set to empty. </p>

<p class="definition">Definition at line <a class="el" href="rangemap_8h_source.html#l00257">257</a> of file <a class="el" href="rangemap_8h_source.html">rangemap.h</a>.</p>

<p class="reference">References <a class="el" href="rangemap_8h_source.html#l00058">Range&lt; T &gt;::r_first</a>, and <a class="el" href="rangemap_8h_source.html#l00059">Range&lt; T &gt;::r_last</a>.</p>

<p class="reference">Referenced by <a class="el" href="rangemap_8h_source.html#l00075">Range&lt; T &gt;::Range()</a>, and <a class="el" href="rangemap_8h_source.html#l00164">Range&lt; T &gt;::resize()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classRange_a05a5b908926e64956b0db27d19b0bd5e_icgraph.png" border="0" usemap="#classRange_a05a5b908926e64956b0db27d19b0bd5e_icgraph" alt=""/></div>
<map name="classRange_a05a5b908926e64956b0db27d19b0bd5e_icgraph" id="classRange_a05a5b908926e64956b0db27d19b0bd5e_icgraph">
<area shape="rect" title="Make a range empty." alt="" coords="160,31,256,57"/>
<area shape="rect" href="classRange.html#a3930d5474001c881ca3ff922fb22501b" title="Create a new range of specified size." alt="" coords="5,5,112,32"/>
<area shape="rect" href="classRange.html#a6d27e17fadca79e6f3851c60ee50d12c" title="Sets the range size by adjusting the maximum value." alt="" coords="7,56,110,83"/>
</map>
</div>

</div>
</div>
<a id="a4366ac4b363a01d09d3a5ceb8d363687"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4366ac4b363a01d09d3a5ceb8d363687">&#9670;&nbsp;</a></span>begins_with()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classRange.html">Range</a>&lt; T &gt;::begins_with </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRange.html">Range</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do both ranges begin at the same place? </p>
<p>An empty range never begins with any other range, including other empty ranges. </p>

<p class="definition">Definition at line <a class="el" href="rangemap_8h_source.html#l00272">272</a> of file <a class="el" href="rangemap_8h_source.html">rangemap.h</a>.</p>

</div>
</div>
<a id="aedd334dfa64295d16df19456cbf9914b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedd334dfa64295d16df19456cbf9914b">&#9670;&nbsp;</a></span>ends_with()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classRange.html">Range</a>&lt; T &gt;::ends_with </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRange.html">Range</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do both ranges end at the same place? </p>
<p>An empty range never ends with any other range, including other empty ranges. </p>

<p class="definition">Definition at line <a class="el" href="rangemap_8h_source.html#l00281">281</a> of file <a class="el" href="rangemap_8h_source.html">rangemap.h</a>.</p>

</div>
</div>
<a id="ad96c05f51ff94ad174f5f2bee8308353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad96c05f51ff94ad174f5f2bee8308353">&#9670;&nbsp;</a></span>begins_after()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classRange.html">Range</a>&lt; T &gt;::begins_after </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRange.html">Range</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does this range begin (strictly) after the beginning of another range? </p>
<p>An empty range never begins after any other range, including other empty ranges. </p>

<p class="definition">Definition at line <a class="el" href="rangemap_8h_source.html#l00290">290</a> of file <a class="el" href="rangemap_8h_source.html">rangemap.h</a>.</p>

</div>
</div>
<a id="ad2e055ad621559a8d09563244275e877"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2e055ad621559a8d09563244275e877">&#9670;&nbsp;</a></span>begins_before()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classRange.html">Range</a>&lt; T &gt;::begins_before </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRange.html">Range</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does this range begin (strictly) before the beginning of another range? </p>
<p>An empty range never begins before any other range, including other empty ranges. </p>

<p class="definition">Definition at line <a class="el" href="rangemap_8h_source.html#l00299">299</a> of file <a class="el" href="rangemap_8h_source.html">rangemap.h</a>.</p>

</div>
</div>
<a id="a568148ea1f7a012b6a9ee75579d2b544"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a568148ea1f7a012b6a9ee75579d2b544">&#9670;&nbsp;</a></span>ends_after()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classRange.html">Range</a>&lt; T &gt;::ends_after </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRange.html">Range</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does this range end (strictly) after the end of another range? </p>
<p>An empty range never ends after any other range, including other empty ranges. </p>

<p class="definition">Definition at line <a class="el" href="rangemap_8h_source.html#l00308">308</a> of file <a class="el" href="rangemap_8h_source.html">rangemap.h</a>.</p>

</div>
</div>
<a id="a5519eb67dd6df2586a2a21073880dbc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5519eb67dd6df2586a2a21073880dbc3">&#9670;&nbsp;</a></span>ends_before()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classRange.html">Range</a>&lt; T &gt;::ends_before </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRange.html">Range</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does this range end (strictly) before the end of another range? </p>
<p>An empty range never ends before any other range, including other empty ranges. </p>

<p class="definition">Definition at line <a class="el" href="rangemap_8h_source.html#l00317">317</a> of file <a class="el" href="rangemap_8h_source.html">rangemap.h</a>.</p>

</div>
</div>
<a id="a912b54aab45eeb8c4301f5c9e918c802"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a912b54aab45eeb8c4301f5c9e918c802">&#9670;&nbsp;</a></span>contains()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classRange.html">Range</a>&lt; T &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRange.html">Range</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does this range contain the argument range? </p>
<p>The argument is contained in this range if the argument starts at or after the start of this range and ends at or before the end of this range. If <code>strict</code> is true, then the comparisons do not include equality. An empty range does not contain any other range, including other empty ranges. </p>

<p class="definition">Definition at line <a class="el" href="rangemap_8h_source.html#l00328">328</a> of file <a class="el" href="rangemap_8h_source.html">rangemap.h</a>.</p>

</div>
</div>
<a id="a114a9f8c195e2cc8286c4bff8af963d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a114a9f8c195e2cc8286c4bff8af963d8">&#9670;&nbsp;</a></span>contained_in()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classRange.html">Range</a>&lt; T &gt;::contained_in </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRange.html">Range</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this range contained in the argument range? </p>
<p>This range is contained in the argument range if this range starts at or after the start of the argument and ends at or before the end of the argument. If <code>strict</code> is true, then the comparisons do not include equality. An empty range does not contain any other range, including other empty ranges. </p>

<p class="definition">Definition at line <a class="el" href="rangemap_8h_source.html#l00339">339</a> of file <a class="el" href="rangemap_8h_source.html">rangemap.h</a>.</p>

</div>
</div>
<a id="abc11e8e5da0d8040213090be1c57642b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc11e8e5da0d8040213090be1c57642b">&#9670;&nbsp;</a></span>congruent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classRange.html">Range</a>&lt; T &gt;::congruent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRange.html">Range</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Are two ranges equal? </p>
<p>They are equal if the start and end at the same place or if they are both empty. </p>

<p class="definition">Definition at line <a class="el" href="rangemap_8h_source.html#l00348">348</a> of file <a class="el" href="rangemap_8h_source.html">rangemap.h</a>.</p>

</div>
</div>
<a id="a8235f297331f655a89d44c3930cc6ec5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8235f297331f655a89d44c3930cc6ec5">&#9670;&nbsp;</a></span>left_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classRange.html">Range</a>&lt; T &gt;::left_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRange.html">Range</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this range left of the argument range? </p>
<p>This range is left of the argument range if this range ends before the start of the argument. They may adjoin, but must not overlap. An empty range is never left of any other range, including other empty ranges. </p>

<p class="definition">Definition at line <a class="el" href="rangemap_8h_source.html#l00358">358</a> of file <a class="el" href="rangemap_8h_source.html">rangemap.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="rangemap_8h_source.html#l01390">RangeMap&lt; R, T &gt;::select_overlapping_ranges()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classRange_a8235f297331f655a89d44c3930cc6ec5_icgraph.png" border="0" usemap="#classRange_a8235f297331f655a89d44c3930cc6ec5_icgraph" alt=""/></div>
<map name="classRange_a8235f297331f655a89d44c3930cc6ec5_icgraph" id="classRange_a8235f297331f655a89d44c3930cc6ec5_icgraph">
<area shape="rect" title="Is this range left of the argument range?" alt="" coords="255,13,359,39"/>
<area shape="rect" href="classRangeMap.html#ab7c14322b9300e0460723c753e886aa5" title="Select ranges overlapping selector range." alt="" coords="5,5,207,47"/>
</map>
</div>

</div>
</div>
<a id="a6f5aa3b5c4e5b92b394e45d94a7dfeaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f5aa3b5c4e5b92b394e45d94a7dfeaa">&#9670;&nbsp;</a></span>right_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classRange.html">Range</a>&lt; T &gt;::right_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRange.html">Range</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this range right of the argument range? </p>
<p>This range is right of the argument range if this range starts after the end of the argument range. They may adjoin, but must not overlap. An empty range is never right of any other range, including other empty ranges. </p>

<p class="definition">Definition at line <a class="el" href="rangemap_8h_source.html#l00368">368</a> of file <a class="el" href="rangemap_8h_source.html">rangemap.h</a>.</p>

</div>
</div>
<a id="acf652e7f98ecb33841f68933837b74fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf652e7f98ecb33841f68933837b74fd">&#9670;&nbsp;</a></span>overlaps()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classRange.html">Range</a>&lt; T &gt;::overlaps </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRange.html">Range</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does this range overlap with the argument range? </p>
<p>An empty range does not overlap with any other rance, including other empty ranges. </p>

<p class="definition">Definition at line <a class="el" href="rangemap_8h_source.html#l00377">377</a> of file <a class="el" href="rangemap_8h_source.html">rangemap.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="rangemap_8h_source.html#l01390">RangeMap&lt; R, T &gt;::select_overlapping_ranges()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classRange_acf652e7f98ecb33841f68933837b74fd_icgraph.png" border="0" usemap="#classRange_acf652e7f98ecb33841f68933837b74fd_icgraph" alt=""/></div>
<map name="classRange_acf652e7f98ecb33841f68933837b74fd_icgraph" id="classRange_acf652e7f98ecb33841f68933837b74fd_icgraph">
<area shape="rect" title="Does this range overlap with the argument range?" alt="" coords="255,13,372,39"/>
<area shape="rect" href="classRangeMap.html#ab7c14322b9300e0460723c753e886aa5" title="Select ranges overlapping selector range." alt="" coords="5,5,207,47"/>
</map>
</div>

</div>
</div>
<a id="a42e5a1fd8d22b971b1ae6baf579dfbfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42e5a1fd8d22b971b1ae6baf579dfbfa">&#9670;&nbsp;</a></span>distinct()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classRange.html">Range</a>&lt; T &gt;::distinct </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRange.html">Range</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this range non-overlapping with the argument range? </p>
<p>In other words, do the two ranges represent distinct sets of values? An empty range is always distinct from all other ranges (including other empty ranges). </p>

<p class="definition">Definition at line <a class="el" href="rangemap_8h_source.html#l00387">387</a> of file <a class="el" href="rangemap_8h_source.html">rangemap.h</a>.</p>

</div>
</div>
<a id="a8355e4409e104e2ed2395aabf7abd038"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8355e4409e104e2ed2395aabf7abd038">&#9670;&nbsp;</a></span>abuts_lt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classRange.html">Range</a>&lt; T &gt;::abuts_lt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRange.html">Range</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this range immediately left of the argument range? </p>
<p>Returns true if this range ends at the beginning of the argument, with no overlap and no space between them. An empty range does not abut any other range, including other empty ranges. </p>

<p class="definition">Definition at line <a class="el" href="rangemap_8h_source.html#l00397">397</a> of file <a class="el" href="rangemap_8h_source.html">rangemap.h</a>.</p>

</div>
</div>
<a id="a819bc05993d5b45f6b32be1c403ac2c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a819bc05993d5b45f6b32be1c403ac2c0">&#9670;&nbsp;</a></span>abuts_gt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classRange.html">Range</a>&lt; T &gt;::abuts_gt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRange.html">Range</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this range immediately right of the argument range? </p>
<p>Returns true if this range begins at the end of the argument, with no overlap and no space between them. An empty range does not abut any other range, including other empty ranges. </p>

<p class="definition">Definition at line <a class="el" href="rangemap_8h_source.html#l00407">407</a> of file <a class="el" href="rangemap_8h_source.html">rangemap.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="rangemap_8h_source.html">rangemap.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Dec 8 2022 21:18:18 for ROSE by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
