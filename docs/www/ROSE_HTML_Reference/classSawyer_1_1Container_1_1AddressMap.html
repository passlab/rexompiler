<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROSE: Sawyer::Container::AddressMap&lt; A, T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="ROSE"/>
<link href="roseDoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ROSE
   &#160;<span id="projectnumber">0.11.96.11</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,true,'search.html','Search');
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceSawyer.html">Sawyer</a></li><li class="navelem"><a class="el" href="namespaceSawyer_1_1Container.html">Container</a></li><li class="navelem"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classSawyer_1_1Container_1_1AddressMap-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Sawyer::Container::AddressMap&lt; A, T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><h3>template&lt;class A, class T = boost::uint8_t&gt;<br />
class Sawyer::Container::AddressMap&lt; A, T &gt;</h3>

<p>A mapping from address space to values. </p>
<p>This object maps addresses (actually, intervals thereof) to values. Addresses must be an integral unsigned type but values may be any type as long as they are default constructible and copyable. The address type is usually an integral type whose width is the log base 2 of the size of the address space; the value type is often unsigned 8-bit bytes.</p>
<p>An address map accomplishes the mapping by inheriting from an <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>, whose intervals are <code><a class="el" href="classSawyer_1_1Container_1_1Interval.html" title="Range of values delimited by endpoints.">Interval</a></code> and whose values are <code>AddressSegment&lt;A,T&gt;</code>. The <a class="el" href="classSawyer_1_1Container_1_1AddressSegment.html">AddressSegment</a> objects point to reference-counted <a class="el" href="classSawyer_1_1Container_1_1Buffer.html">Buffer</a> objects that hold the values. The same values can be mapped at different addresses by inserting segments at those addresses that point to a common buffer.</p>
<p>An address map implements read and write concepts for copying values between user-supplied buffers and the storage areas referenced by the map. Many of the address map methods operate over a region of the map described by a set of constraints that are matched within the map. Constraints are indicated by listing them before the map I/O operation, but they do not modify the map in any way&ndash;they exist outside the map. Constraints are combined by logical conjunction. For instance, the <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a9c8520e0f4a70e6d310cce43b9e5d146">AddressMap::next</a> method returns the lowest address that satisfies the given constraints, or nothing. If we wanted to search for the lowest address beteen 1000 and 1999 inclusive, that has read access but not write access, we would do so like this:</p>
<div class="fragment"><div class="line">Optional&lt;Address&gt; x = map.within(1000,1999).require(READABLE).prohibit(WRITABLE).next();</div>
</div><!-- fragment --><p>In fact, by making use of the <a class="el" href="classSawyer_1_1Optional.html">Sawyer::Optional</a> API, we can write a loop that iterates over such addresses, although there may be more efficient ways to do this than one address at a time:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<a class="code" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> x=1000; map.within(x,1999).<a class="code" href="classSawyer_1_1Container_1_1AddressMap.html#aa3d023864ebbf9ca4e6f009f36cbac61">require</a>(READABLE).<a class="code" href="classSawyer_1_1Container_1_1AddressMap.html#ae44b092e3f2f17005b055086de062d5c">prohibit</a>(WRITABLE).<a class="code" href="classSawyer_1_1Container_1_1AddressMap.html#a9c8520e0f4a70e6d310cce43b9e5d146">next</a>().assignTo(x); ++x) ...</div>
</div><!-- fragment --><p>The next example shows how to read a buffer's worth of values anchored at a particular starting value. The <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#ae17e760e87b8cbeb207310f6f4dc8b20">read</a> method returns an address interval to indicate what addresses were accessed, but in this case we're only interested in the number of such addresses since we know the starting address.</p>
<div class="fragment"><div class="line"><a class="code" href="classSawyer_1_1Container_1_1AddressMap.html#aa7a7317b6be4502317ab4357b5989660">Value</a> buf[10];</div>
<div class="line"><span class="keywordtype">size_t</span> nAccessed = map.at(1000).limit(10).read(buf).size();</div>
</div><!-- fragment --><p>An interval return value is more useful when we don't know where the operation occurs until after it occurs. For instance, to read up to 10 values that are readable at or beyond some address:</p>
<div class="fragment"><div class="line"><a class="code" href="classSawyer_1_1Container_1_1AddressMap.html#aa7a7317b6be4502317ab4357b5989660">Value</a> buf[10]</div>
<div class="line">Interval&lt;Address&gt; accessed = map.atOrAfter(1000).limit(10).require(READABLE).read(buf);</div>
</div><!-- fragment --><p>Since all map operations take the same constraints, it is possible to rewrite the previous <code>for</code> loop so that instead of searching for an address it actually reads data. Here's a loop that prints all the data that's readable but not writable and falls between two addresses, regardless of what other segments also exist in that same interval:</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">size_t</span> bufsz = 256;</div>
<div class="line"><a class="code" href="classSawyer_1_1Container_1_1AddressMap.html#aa7a7317b6be4502317ab4357b5989660">Value</a> buf[bufsz];</div>
<div class="line"><a class="code" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> addr = 1000;</div>
<div class="line"><span class="keywordflow">while</span> (<a class="code" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a> accessed = map.within(addr, 1999).require(READABLE).prohibit(WRITABLE).limit(bufsz).read(buf)) {</div>
<div class="line">    <span class="keywordflow">for</span> (<a class="code" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> i=accessed.least(); i&lt;=accessed.greatest(); ++i)</div>
<div class="line">        std::cout &lt;&lt;i &lt;&lt;<span class="stringliteral">&quot;: &quot;</span> &lt;&lt;buf[i-accessed.least()] &lt;&lt;<span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">    addr += accessed.size();</div>
<div class="line">}</div>
</div><!-- fragment --><p>Most I/O methods require that constraints match only contiguous addresses. If there is an intervening address that does not satisfy the constraint, including addresses that are not mapped, then the matched range terminates at the non-matching address. However, the <code>MATCH_NONCONTIGUOUS</code> flag can be used to relax this, in which case the matched interval of addresses may include addresses that are not mapped. Regardless of whether contiguous addresses are required, the returned interval of addresses will never contain an address that is mapped and does not also satisfy the constraints. I/O operations (read and write) require contiguous addresses, but some other methods don't. For instance, the expressions</p>
<div class="fragment"><div class="line">Interval&lt;Address&gt; found1 = map.within(100,200).require(READABLE).available(MATCH_CONTIGUOUS);</div>
<div class="line">Interval&lt;Address&gt; found2 = map.within(100,200).require(READABLE).available(MATCH_NONCONTIGUOUS);</div>
</div><!-- fragment --><p>are the same except the second one returns an interval that might include non-mapped addresses. A few methods go even further and are able to operate across mapped addresses that don't satisfy the segment constraints, skipping over the addresses that don't satisfy the constraints. For instance, the <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a79044a63583ed0fa8cd49c945372d696">prune</a> and <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#ab1d024a2128d70727cfce72518a32bfd">keep</a> functions operate this way so that a call like:</p>
<div class="fragment"><div class="line">map.within(100,200).require(READABLE).prohibit(WRITABLE).keep();</div>
</div><!-- fragment --><p>will discard all addresses except keeping those which are between 100 and 200 (inclusive) and which are readable but not writable. The documentation for each method states whether the default is contiguous matching, non-contiguous matching, or skipping over whole segments, and the method can take a bit flag (<a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a>) to change its default behavior (with some restrictions).</p>
<p>One of the <a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a> bits indicates whether the constraint should match the lowest or highest possible addresses. The default is to match the constraint at the lowest possible addresses. Matching at the highest addresses is useful when iterating backward. For instance, if one wants to read up to 1024 values that end at address 1023 but is not sure how many prior addresses are readable, he could use backward matching. This is much more efficient than the alternative of searching backward one address at a time, and is simpler than doing an explicit binary search:</p>
<div class="fragment"><div class="line"><a class="code" href="classSawyer_1_1Container_1_1AddressMap.html#aa7a7317b6be4502317ab4357b5989660">Value</a> buf[1024];</div>
<div class="line">Interval&lt;Address&gt; accessed = map.at(1023).limit(1024).read(buf, MATCH_BACKWARD);</div>
</div><!-- fragment --><p>Backward and forward I/O behaves identically as far as which array element holds which value. In all cases array element zero contains the value at the lowest address read or written.</p>
<p>Here's an example that creates two buffers (they happen to point to arrays that the <a class="el" href="classSawyer_1_1Container_1_1Buffer.html" title="Base class for all buffers.">Buffer</a> objects do not own), maps them at addresses in such a way that part of the smaller of the two buffers occludes the larger buffer, and then performs a write operation that touches parts of both buffers. We then rewrite part of the mapping and do another write operation:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceSawyer_1_1Container.html">Sawyer::Container</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <a class="code" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classSawyer_1_1Container_1_1Interval.html">Interval&lt;Address&gt;</a> Addresses;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classSawyer_1_1SharedPointer.html">Buffer&lt;Address, char&gt;::Ptr</a> BufferPtr;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classSawyer_1_1Container_1_1AddressSegment.html">AddressSegment&lt;Address, char&gt;</a> <a class="code" href="classSawyer_1_1Container_1_1AddressMap.html#a30140763fdfb3c3c12e8fd6a1dc22ea9">Segment</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap&lt;Address, char&gt;</a> MemoryMap;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create some buffer objects</span></div>
<div class="line"><span class="keywordtype">char</span> data1[15];</div>
<div class="line">memcpy(data1, <span class="stringliteral">&quot;---------------&quot;</span>, 15);</div>
<div class="line">BufferPtr buf1 = <a class="code" href="classSawyer_1_1Container_1_1StaticBuffer.html#a7033524d4f99774a85d6685080b7625a">Sawyer::Container::StaticBuffer&lt;Address, char&gt;::instance</a>(data1, 15);</div>
<div class="line"><span class="keywordtype">char</span> data2[5];</div>
<div class="line">memcpy(data2, <span class="stringliteral">&quot;##########&quot;</span>, 10);</div>
<div class="line">BufferPtr buf2 = <a class="code" href="classSawyer_1_1Container_1_1StaticBuffer.html#a7033524d4f99774a85d6685080b7625a">Sawyer::Container::StaticBuffer&lt;Address, char&gt;::instance</a>(data2, 5); <span class="comment">// using only first 5 bytes</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Map data2 into the middle of data1</span></div>
<div class="line">MemoryMap map;</div>
<div class="line">map.insert(Addresses::baseSize(1000, 15), <a class="code" href="classSawyer_1_1Container_1_1AddressMap.html#a30140763fdfb3c3c12e8fd6a1dc22ea9">Segment</a>(buf1));</div>
<div class="line">map.insert(Addresses::baseSize(1005,  5), <a class="code" href="classSawyer_1_1Container_1_1AddressMap.html#a30140763fdfb3c3c12e8fd6a1dc22ea9">Segment</a>(buf2)); </div>
<div class="line"> </div>
<div class="line"><span class="comment">// Write across both buffers and check that data2 occluded data1</span></div>
<div class="line">Addresses accessed = map.at(1001).limit(13).write(<span class="stringliteral">&quot;bcdefghijklmn&quot;</span>);</div>
<div class="line">ASSERT_always_require(accessed.size()==13);</div>
<div class="line">ASSERT_always_require(0==memcmp(data1, <span class="stringliteral">&quot;-bcde-----klmn-&quot;</span>, 15));</div>
<div class="line">ASSERT_always_require(0==memcmp(data2,      <span class="stringliteral">&quot;fghij#####&quot;</span>, 10));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Map the middle of data1 over the top of data2 again and check that the mapping has one element. I.e., the three</span></div>
<div class="line"><span class="comment">// separate parts were recombined into a single entry since they are three consecutive areas of a single buffer.</span></div>
<div class="line">map.insert(Addresses::baseSize(1005, 5), <a class="code" href="classSawyer_1_1Container_1_1AddressMap.html#a30140763fdfb3c3c12e8fd6a1dc22ea9">Segment</a>(buf1, 5));</div>
<div class="line">ASSERT_always_require(map.nSegments()==1);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Write some data again</span></div>
<div class="line">accessed = map.at(1001).limit(13).write(<span class="stringliteral">&quot;BCDEFGHIJKLMN&quot;</span>);</div>
<div class="line">ASSERT_always_require(accessed.size()==13);</div>
<div class="line">ASSERT_always_require(0==memcmp(data1, <span class="stringliteral">&quot;-BCDEFGHIJKLMN-&quot;</span>, 15));</div>
<div class="line">ASSERT_always_require(0==memcmp(data2,      <span class="stringliteral">&quot;fghij#####&quot;</span>, 10));</div>
</div><!-- fragment --><h1><a class="anchor" id="errors"></a>
Microsoft C++ compilers</h1>
<p>Microsoft Visual Studio 12 2013 (MSVC 18.0.30501.0) and possibly other versions look up non-dependent names in template base classes in violation of C++ standards and apparently no switch to make their behavior compliant with the standard. This causes problems for <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html" title="A mapping from address space to values.">AddressMap</a> because unqualified references to <code>Interval</code> should refer to the <a class="el" href="classSawyer_1_1Container_1_1Interval.html" title="Range of values delimited by endpoints.">Sawyer::Container::Interval</a> class template, but instead they refer to the <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a> typedef in the base class. Our work around is to qualify all occurrences of <code>Interval</code> where Microsoft compilers go wrong. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01004">1004</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>
</div>
<p><code>#include &lt;<a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Sawyer::Container::AddressMap&lt; A, T &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1AddressMap__inherit__graph.png" border="0" usemap="#Sawyer_1_1Container_1_1AddressMap_3_01A_00_01T_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="Sawyer_1_1Container_1_1AddressMap_3_01A_00_01T_01_4_inherit__map" id="Sawyer_1_1Container_1_1AddressMap_3_01A_00_01T_01_4_inherit__map">
<area shape="rect" title="A mapping from address space to values." alt="" coords="308,35,451,76"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalMap.html" title=" " alt="" coords="5,5,260,105"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for Sawyer::Container::AddressMap&lt; A, T &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1AddressMap__coll__graph.png" border="0" usemap="#Sawyer_1_1Container_1_1AddressMap_3_01A_00_01T_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="Sawyer_1_1Container_1_1AddressMap_3_01A_00_01T_01_4_coll__map" id="Sawyer_1_1Container_1_1AddressMap_3_01A_00_01T_01_4_coll__map">
<area shape="rect" title="A mapping from address space to values." alt="" coords="308,35,451,76"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalMap.html" title=" " alt="" coords="5,5,260,105"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap_1_1Visitor.html">Visitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for traversals.  <a href="classSawyer_1_1Container_1_1AddressMap_1_1Visitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a1134be6cf10571edef9ffe6ab06fd7a9"><td class="memItemLeft" align="right" valign="top">typedef A&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a></td></tr>
<tr class="memdesc:a1134be6cf10571edef9ffe6ab06fd7a9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceSawyer_1_1Type.html" title="Data types.">Type</a> for addresses.  <a href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">More...</a><br /></td></tr>
<tr class="separator:a1134be6cf10571edef9ffe6ab06fd7a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7a7317b6be4502317ab4357b5989660"><td class="memItemLeft" align="right" valign="top"><a id="aa7a7317b6be4502317ab4357b5989660"></a>
typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#aa7a7317b6be4502317ab4357b5989660">Value</a></td></tr>
<tr class="memdesc:aa7a7317b6be4502317ab4357b5989660"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceSawyer_1_1Type.html" title="Data types.">Type</a> of data stored in the address space. <br /></td></tr>
<tr class="separator:aa7a7317b6be4502317ab4357b5989660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30140763fdfb3c3c12e8fd6a1dc22ea9"><td class="memItemLeft" align="right" valign="top"><a id="a30140763fdfb3c3c12e8fd6a1dc22ea9"></a>
typedef <a class="el" href="classSawyer_1_1Container_1_1AddressSegment.html">AddressSegment</a>&lt; A, T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a30140763fdfb3c3c12e8fd6a1dc22ea9">Segment</a></td></tr>
<tr class="memdesc:a30140763fdfb3c3c12e8fd6a1dc22ea9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceSawyer_1_1Type.html" title="Data types.">Type</a> of segments stored by this map. <br /></td></tr>
<tr class="separator:a30140763fdfb3c3c12e8fd6a1dc22ea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a853b56b98075440d935890ac4f0c0053"><td class="memItemLeft" align="right" valign="top"><a id="a853b56b98075440d935890ac4f0c0053"></a>
typedef <a class="el" href="classSawyer_1_1Container_1_1Buffer.html">Sawyer::Container::Buffer</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a>, <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#aa7a7317b6be4502317ab4357b5989660">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Buffer</b></td></tr>
<tr class="separator:a853b56b98075440d935890ac4f0c0053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2c9cf858603ecda80b73929ad8fcbc9"><td class="memItemLeft" align="right" valign="top"><a id="af2c9cf858603ecda80b73929ad8fcbc9"></a>
typedef <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad3da8180167b02f750f8138e21fea1b8">Super::Node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#af2c9cf858603ecda80b73929ad8fcbc9">Node</a></td></tr>
<tr class="memdesc:af2c9cf858603ecda80b73929ad8fcbc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage node containing interval/segment pair. <br /></td></tr>
<tr class="separator:af2c9cf858603ecda80b73929ad8fcbc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f7204596756341c0ea7eeadc5d38262"><td class="memItemLeft" align="right" valign="top"><a id="a9f7204596756341c0ea7eeadc5d38262"></a>
typedef <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ae50e191b16e240244fb48af0232e88ac">Super::ValueIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a9f7204596756341c0ea7eeadc5d38262">SegmentIterator</a></td></tr>
<tr class="memdesc:a9f7204596756341c0ea7eeadc5d38262"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterates over segments in the map. <br /></td></tr>
<tr class="separator:a9f7204596756341c0ea7eeadc5d38262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa852a793027a1c74c097147546910f47"><td class="memItemLeft" align="right" valign="top"><a id="aa852a793027a1c74c097147546910f47"></a>
typedef <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a050e4ca3dcf0d65fba2d65b20e9730d9">Super::ConstValueIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#aa852a793027a1c74c097147546910f47">ConstSegmentIterator</a></td></tr>
<tr class="memdesc:aa852a793027a1c74c097147546910f47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterators over segments in the map. <br /></td></tr>
<tr class="separator:aa852a793027a1c74c097147546910f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0994c89a6b4a525a52f8f341ae3d28ed"><td class="memItemLeft" align="right" valign="top"><a id="a0994c89a6b4a525a52f8f341ae3d28ed"></a>
typedef <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ae5130ce1b0e59f7bddd6b68f02da3b2e">Super::ConstIntervalIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a0994c89a6b4a525a52f8f341ae3d28ed">ConstIntervalIterator</a></td></tr>
<tr class="memdesc:a0994c89a6b4a525a52f8f341ae3d28ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterates over address intervals in the map. <br /></td></tr>
<tr class="separator:a0994c89a6b4a525a52f8f341ae3d28ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6954614b9b130d841261ad4d2644316"><td class="memItemLeft" align="right" valign="top"><a id="ac6954614b9b130d841261ad4d2644316"></a>
typedef <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">Super::NodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#ac6954614b9b130d841261ad4d2644316">NodeIterator</a></td></tr>
<tr class="memdesc:ac6954614b9b130d841261ad4d2644316"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterates over address interval, segment pairs in the map. <br /></td></tr>
<tr class="separator:ac6954614b9b130d841261ad4d2644316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf7a3b18db58eae98d782531b3f155b5"><td class="memItemLeft" align="right" valign="top"><a id="abf7a3b18db58eae98d782531b3f155b5"></a>
typedef <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">Super::ConstNodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#abf7a3b18db58eae98d782531b3f155b5">ConstNodeIterator</a></td></tr>
<tr class="memdesc:abf7a3b18db58eae98d782531b3f155b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterates over address interval/segment pairs in the map. <br /></td></tr>
<tr class="separator:abf7a3b18db58eae98d782531b3f155b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classSawyer_1_1Container_1_1IntervalMap"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classSawyer_1_1Container_1_1IntervalMap')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">Sawyer::Container::IntervalMap&lt; Interval&lt; A &gt;, AddressSegment&lt; A, boost::uint8_t &gt;, AddressMapImpl::SegmentMergePolicy&lt; A, boost::uint8_t &gt; &gt;</a></td></tr>
<tr class="memitem:a664961032974fd71f132d8931edd68de inherit pub_types_classSawyer_1_1Container_1_1IntervalMap"><td class="memItemLeft" align="right" valign="top"><a id="a664961032974fd71f132d8931edd68de"></a>
typedef <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>&lt; A &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a></td></tr>
<tr class="memdesc:a664961032974fd71f132d8931edd68de inherit pub_types_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interval type. <br /></td></tr>
<tr class="separator:a664961032974fd71f132d8931edd68de inherit pub_types_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c7ef387287aa01aa632dfeafc121e95 inherit pub_types_classSawyer_1_1Container_1_1IntervalMap"><td class="memItemLeft" align="right" valign="top"><a id="a7c7ef387287aa01aa632dfeafc121e95"></a>
typedef <a class="el" href="classSawyer_1_1Container_1_1AddressSegment.html">AddressSegment</a>&lt; A, boost::uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a7c7ef387287aa01aa632dfeafc121e95">Value</a></td></tr>
<tr class="memdesc:a7c7ef387287aa01aa632dfeafc121e95 inherit pub_types_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value type. <br /></td></tr>
<tr class="separator:a7c7ef387287aa01aa632dfeafc121e95 inherit pub_types_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae27b32aea90cdef93228cd5c978c00ef inherit pub_types_classSawyer_1_1Container_1_1IntervalMap"><td class="memItemLeft" align="right" valign="top"><a id="ae27b32aea90cdef93228cd5c978c00ef"></a>
typedef <a class="el" href="classSawyer_1_1Container_1_1Map.html">Container::Map</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a7c7ef387287aa01aa632dfeafc121e95">Value</a>, IntervalCompare &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ae27b32aea90cdef93228cd5c978c00ef">Map</a></td></tr>
<tr class="memdesc:ae27b32aea90cdef93228cd5c978c00ef inherit pub_types_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the underlying map. <br /></td></tr>
<tr class="separator:ae27b32aea90cdef93228cd5c978c00ef inherit pub_types_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3da8180167b02f750f8138e21fea1b8 inherit pub_types_classSawyer_1_1Container_1_1IntervalMap"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSawyer_1_1Container_1_1Map_1_1Node.html">Map::Node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad3da8180167b02f750f8138e21fea1b8">Node</a></td></tr>
<tr class="memdesc:ad3da8180167b02f750f8138e21fea1b8 inherit pub_types_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage node.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#ad3da8180167b02f750f8138e21fea1b8">More...</a><br /></td></tr>
<tr class="separator:ad3da8180167b02f750f8138e21fea1b8 inherit pub_types_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5130ce1b0e59f7bddd6b68f02da3b2e inherit pub_types_classSawyer_1_1Container_1_1IntervalMap"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSawyer_1_1Container_1_1Map_1_1ConstKeyIterator.html">Map::ConstKeyIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ae5130ce1b0e59f7bddd6b68f02da3b2e">ConstIntervalIterator</a></td></tr>
<tr class="memdesc:ae5130ce1b0e59f7bddd6b68f02da3b2e inherit pub_types_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interval iterator.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#ae5130ce1b0e59f7bddd6b68f02da3b2e">More...</a><br /></td></tr>
<tr class="separator:ae5130ce1b0e59f7bddd6b68f02da3b2e inherit pub_types_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae50e191b16e240244fb48af0232e88ac inherit pub_types_classSawyer_1_1Container_1_1IntervalMap"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSawyer_1_1Container_1_1Map_1_1ValueIterator.html">Map::ValueIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ae50e191b16e240244fb48af0232e88ac">ValueIterator</a></td></tr>
<tr class="memdesc:ae50e191b16e240244fb48af0232e88ac inherit pub_types_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value iterator.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#ae50e191b16e240244fb48af0232e88ac">More...</a><br /></td></tr>
<tr class="separator:ae50e191b16e240244fb48af0232e88ac inherit pub_types_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a050e4ca3dcf0d65fba2d65b20e9730d9 inherit pub_types_classSawyer_1_1Container_1_1IntervalMap"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSawyer_1_1Container_1_1Map_1_1ConstValueIterator.html">Map::ConstValueIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ConstValueIterator</b></td></tr>
<tr class="memdesc:a050e4ca3dcf0d65fba2d65b20e9730d9 inherit pub_types_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value iterator.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#a050e4ca3dcf0d65fba2d65b20e9730d9">More...</a><br /></td></tr>
<tr class="separator:a050e4ca3dcf0d65fba2d65b20e9730d9 inherit pub_types_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a643bf7e3b1413a950b3e66bd7244dacb inherit pub_types_classSawyer_1_1Container_1_1IntervalMap"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSawyer_1_1Container_1_1Map_1_1NodeIterator.html">Map::NodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a></td></tr>
<tr class="memdesc:a643bf7e3b1413a950b3e66bd7244dacb inherit pub_types_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node iterator.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">More...</a><br /></td></tr>
<tr class="separator:a643bf7e3b1413a950b3e66bd7244dacb inherit pub_types_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad28df1a69755b5534a2ddb68bd447e61 inherit pub_types_classSawyer_1_1Container_1_1IntervalMap"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSawyer_1_1Container_1_1Map_1_1ConstNodeIterator.html">Map::ConstNodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ConstNodeIterator</b></td></tr>
<tr class="memdesc:ad28df1a69755b5534a2ddb68bd447e61 inherit pub_types_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node iterator.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">More...</a><br /></td></tr>
<tr class="separator:ad28df1a69755b5534a2ddb68bd447e61 inherit pub_types_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3e8cd51e41cea7489ea3f78b0d30365c"><td class="memItemLeft" align="right" valign="top"><a id="a3e8cd51e41cea7489ea3f78b0d30365c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a3e8cd51e41cea7489ea3f78b0d30365c">AddressMap</a> ()</td></tr>
<tr class="memdesc:a3e8cd51e41cea7489ea3f78b0d30365c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an empty address map. <br /></td></tr>
<tr class="separator:a3e8cd51e41cea7489ea3f78b0d30365c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ac1bbe4c8188403070b62fbd6e85fa9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a2ac1bbe4c8188403070b62fbd6e85fa9">AddressMap</a> (const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &amp;other, bool copyOnWrite=false)</td></tr>
<tr class="memdesc:a2ac1bbe4c8188403070b62fbd6e85fa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="classSawyer_1_1Container_1_1AddressMap.html#a2ac1bbe4c8188403070b62fbd6e85fa9">More...</a><br /></td></tr>
<tr class="separator:a2ac1bbe4c8188403070b62fbd6e85fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a300a26b869a20b7c773f75f7c3d75e04"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a300a26b869a20b7c773f75f7c3d75e04">checkConsistency</a> () const</td></tr>
<tr class="memdesc:a300a26b869a20b7c773f75f7c3d75e04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check map consistency.  <a href="classSawyer_1_1Container_1_1AddressMap.html#a300a26b869a20b7c773f75f7c3d75e04">More...</a><br /></td></tr>
<tr class="separator:a300a26b869a20b7c773f75f7c3d75e04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78c1ef82354f141b3961d957e8728158"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a78c1ef82354f141b3961d957e8728158">nSegments</a> () const</td></tr>
<tr class="memdesc:a78c1ef82354f141b3961d957e8728158"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of segments contained in the map.  <a href="classSawyer_1_1Container_1_1AddressMap.html#a78c1ef82354f141b3961d957e8728158">More...</a><br /></td></tr>
<tr class="separator:a78c1ef82354f141b3961d957e8728158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c8520e0f4a70e6d310cce43b9e5d146"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a9c8520e0f4a70e6d310cce43b9e5d146">next</a> (const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; &amp;c, <a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a> flags=0) const</td></tr>
<tr class="memdesc:a9c8520e0f4a70e6d310cce43b9e5d146"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum or maximum address that satisfies constraints.  <a href="classSawyer_1_1Container_1_1AddressMap.html#a9c8520e0f4a70e6d310cce43b9e5d146">More...</a><br /></td></tr>
<tr class="separator:a9c8520e0f4a70e6d310cce43b9e5d146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dbd7779c82f1cc7bdb4e0354b253b5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1Interval.html">Sawyer::Container::Interval</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1dbd7779c82f1cc7bdb4e0354b253b5d">available</a> (const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; &amp;c, <a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a> flags=0) const</td></tr>
<tr class="memdesc:a1dbd7779c82f1cc7bdb4e0354b253b5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adress interval that satisfies constraints.  <a href="classSawyer_1_1Container_1_1AddressMap.html#a1dbd7779c82f1cc7bdb4e0354b253b5d">More...</a><br /></td></tr>
<tr class="separator:a1dbd7779c82f1cc7bdb4e0354b253b5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb9a20f07deebeaacfeb58846102b2df"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#adb9a20f07deebeaacfeb58846102b2df">exists</a> (const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; &amp;c, <a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a> flags=0) const</td></tr>
<tr class="memdesc:adb9a20f07deebeaacfeb58846102b2df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if an address exists with the specified constraints.  <a href="classSawyer_1_1Container_1_1AddressMap.html#adb9a20f07deebeaacfeb58846102b2df">More...</a><br /></td></tr>
<tr class="separator:adb9a20f07deebeaacfeb58846102b2df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a216440bf5700dcf32389269e8e1ae1d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1Interval.html">Sawyer::Container::Interval</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a216440bf5700dcf32389269e8e1ae1d9">unmapped</a> (<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> boundary, <a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a> flags=0) const</td></tr>
<tr class="memdesc:a216440bf5700dcf32389269e8e1ae1d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find unmapped interval.  <a href="classSawyer_1_1Container_1_1AddressMap.html#a216440bf5700dcf32389269e8e1ae1d9">More...</a><br /></td></tr>
<tr class="separator:a216440bf5700dcf32389269e8e1ae1d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa03abdaf7a123ec5526ee2aa589612a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#aa03abdaf7a123ec5526ee2aa589612a9">findFreeSpace</a> (size_t nValues, size_t alignment=1, <a class="el" href="classSawyer_1_1Container_1_1Interval.html">Sawyer::Container::Interval</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> &gt; restriction=<a class="el" href="classSawyer_1_1Container_1_1Interval.html">Sawyer::Container::Interval</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> &gt;::whole(), <a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a> flags=0) const</td></tr>
<tr class="memdesc:aa03abdaf7a123ec5526ee2aa589612a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find free space.  <a href="classSawyer_1_1Container_1_1AddressMap.html#aa03abdaf7a123ec5526ee2aa589612a9">More...</a><br /></td></tr>
<tr class="separator:aa03abdaf7a123ec5526ee2aa589612a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79044a63583ed0fa8cd49c945372d696"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a79044a63583ed0fa8cd49c945372d696">prune</a> (const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; &amp;c, <a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a> flags=0)</td></tr>
<tr class="memdesc:a79044a63583ed0fa8cd49c945372d696"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prune away addresses that match constraints.  <a href="classSawyer_1_1Container_1_1AddressMap.html#a79044a63583ed0fa8cd49c945372d696">More...</a><br /></td></tr>
<tr class="separator:a79044a63583ed0fa8cd49c945372d696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1d024a2128d70727cfce72518a32bfd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#ab1d024a2128d70727cfce72518a32bfd">keep</a> (const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; &amp;c, <a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a> flags=0)</td></tr>
<tr class="memdesc:ab1d024a2128d70727cfce72518a32bfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Keep only addresses that match constraints.  <a href="classSawyer_1_1Container_1_1AddressMap.html#ab1d024a2128d70727cfce72518a32bfd">More...</a><br /></td></tr>
<tr class="separator:ab1d024a2128d70727cfce72518a32bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1406ad656e7e800fd01f9d17ccc297a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1406ad656e7e800fd01f9d17ccc297a8">changeAccess</a> (unsigned requiredAccess, unsigned prohibitedAccess, const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; &amp;c, <a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a> flags=0)</td></tr>
<tr class="memdesc:a1406ad656e7e800fd01f9d17ccc297a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change access bits for addresses that match constraints.  <a href="classSawyer_1_1Container_1_1AddressMap.html#a1406ad656e7e800fd01f9d17ccc297a8">More...</a><br /></td></tr>
<tr class="separator:a1406ad656e7e800fd01f9d17ccc297a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aa3d023864ebbf9ca4e6f009f36cbac61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#aa3d023864ebbf9ca4e6f009f36cbac61">require</a> (unsigned x) const</td></tr>
<tr class="memdesc:aa3d023864ebbf9ca4e6f009f36cbac61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: required access bits.  <a href="classSawyer_1_1Container_1_1AddressMap.html#aa3d023864ebbf9ca4e6f009f36cbac61">More...</a><br /></td></tr>
<tr class="separator:aa3d023864ebbf9ca4e6f009f36cbac61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c919eb303a5e43b93ef78dd4648267e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a7c919eb303a5e43b93ef78dd4648267e">require</a> (unsigned x)</td></tr>
<tr class="memdesc:a7c919eb303a5e43b93ef78dd4648267e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: required access bits.  <a href="classSawyer_1_1Container_1_1AddressMap.html#a7c919eb303a5e43b93ef78dd4648267e">More...</a><br /></td></tr>
<tr class="separator:a7c919eb303a5e43b93ef78dd4648267e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ae44b092e3f2f17005b055086de062d5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#ae44b092e3f2f17005b055086de062d5c">prohibit</a> (unsigned x) const</td></tr>
<tr class="memdesc:ae44b092e3f2f17005b055086de062d5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: prohibited access bits.  <a href="classSawyer_1_1Container_1_1AddressMap.html#ae44b092e3f2f17005b055086de062d5c">More...</a><br /></td></tr>
<tr class="separator:ae44b092e3f2f17005b055086de062d5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af69bb0b70bae0445c21f06e2ddf80cd7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#af69bb0b70bae0445c21f06e2ddf80cd7">prohibit</a> (unsigned x)</td></tr>
<tr class="memdesc:af69bb0b70bae0445c21f06e2ddf80cd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: prohibited access bits.  <a href="classSawyer_1_1Container_1_1AddressMap.html#af69bb0b70bae0445c21f06e2ddf80cd7">More...</a><br /></td></tr>
<tr class="separator:af69bb0b70bae0445c21f06e2ddf80cd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a77f3c82ee321afbc3b3fd493cdcd7090"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a77f3c82ee321afbc3b3fd493cdcd7090">access</a> (unsigned x) const</td></tr>
<tr class="memdesc:a77f3c82ee321afbc3b3fd493cdcd7090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: required and prohibited access bits.  <a href="classSawyer_1_1Container_1_1AddressMap.html#a77f3c82ee321afbc3b3fd493cdcd7090">More...</a><br /></td></tr>
<tr class="separator:a77f3c82ee321afbc3b3fd493cdcd7090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c7f978008ee37d4fb659a22260e694f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a4c7f978008ee37d4fb659a22260e694f">access</a> (unsigned x)</td></tr>
<tr class="memdesc:a4c7f978008ee37d4fb659a22260e694f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: required and prohibited access bits.  <a href="classSawyer_1_1Container_1_1AddressMap.html#a4c7f978008ee37d4fb659a22260e694f">More...</a><br /></td></tr>
<tr class="separator:a4c7f978008ee37d4fb659a22260e694f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:abc18c5c2fd73b462ece48f067581ab31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#abc18c5c2fd73b462ece48f067581ab31">substr</a> (const std::string &amp;x) const</td></tr>
<tr class="memdesc:abc18c5c2fd73b462ece48f067581ab31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: segment name substring.  <a href="classSawyer_1_1Container_1_1AddressMap.html#abc18c5c2fd73b462ece48f067581ab31">More...</a><br /></td></tr>
<tr class="separator:abc18c5c2fd73b462ece48f067581ab31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb3355cf35be6e3d39921b750408ea62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#abb3355cf35be6e3d39921b750408ea62">substr</a> (const std::string &amp;x)</td></tr>
<tr class="memdesc:abb3355cf35be6e3d39921b750408ea62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: segment name substring.  <a href="classSawyer_1_1Container_1_1AddressMap.html#abb3355cf35be6e3d39921b750408ea62">More...</a><br /></td></tr>
<tr class="separator:abb3355cf35be6e3d39921b750408ea62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:adfcc00193310fa1925dc30d33fd52f91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#adfcc00193310fa1925dc30d33fd52f91">at</a> (<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> x) const</td></tr>
<tr class="memdesc:adfcc00193310fa1925dc30d33fd52f91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: anchor point.  <a href="classSawyer_1_1Container_1_1AddressMap.html#adfcc00193310fa1925dc30d33fd52f91">More...</a><br /></td></tr>
<tr class="separator:adfcc00193310fa1925dc30d33fd52f91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2efe482764a0b07d5d362f3e7f445a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#ad2efe482764a0b07d5d362f3e7f445a1">at</a> (<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> x)</td></tr>
<tr class="memdesc:ad2efe482764a0b07d5d362f3e7f445a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: anchor point.  <a href="classSawyer_1_1Container_1_1AddressMap.html#ad2efe482764a0b07d5d362f3e7f445a1">More...</a><br /></td></tr>
<tr class="separator:ad2efe482764a0b07d5d362f3e7f445a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aaad3000d0cfe62768ee1e0b632cfb924"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#aaad3000d0cfe62768ee1e0b632cfb924">at</a> (const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">Sawyer::Container::Interval</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> &gt; &amp;x) const</td></tr>
<tr class="memdesc:aaad3000d0cfe62768ee1e0b632cfb924"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: anchored interval.  <a href="classSawyer_1_1Container_1_1AddressMap.html#aaad3000d0cfe62768ee1e0b632cfb924">More...</a><br /></td></tr>
<tr class="separator:aaad3000d0cfe62768ee1e0b632cfb924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96369b15afc113dddc496bfb12ff3a4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a96369b15afc113dddc496bfb12ff3a4b">at</a> (const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">Sawyer::Container::Interval</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> &gt; &amp;x)</td></tr>
<tr class="memdesc:a96369b15afc113dddc496bfb12ff3a4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: anchored interval.  <a href="classSawyer_1_1Container_1_1AddressMap.html#a96369b15afc113dddc496bfb12ff3a4b">More...</a><br /></td></tr>
<tr class="separator:a96369b15afc113dddc496bfb12ff3a4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ac130692f6531282e29f00bbde4fba4fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#ac130692f6531282e29f00bbde4fba4fd">limit</a> (size_t x) const</td></tr>
<tr class="memdesc:ac130692f6531282e29f00bbde4fba4fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: limit matched size.  <a href="classSawyer_1_1Container_1_1AddressMap.html#ac130692f6531282e29f00bbde4fba4fd">More...</a><br /></td></tr>
<tr class="separator:ac130692f6531282e29f00bbde4fba4fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0096a1e09debf3b8a5543c03e72aae70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a0096a1e09debf3b8a5543c03e72aae70">limit</a> (size_t x)</td></tr>
<tr class="memdesc:a0096a1e09debf3b8a5543c03e72aae70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: limit matched size.  <a href="classSawyer_1_1Container_1_1AddressMap.html#a0096a1e09debf3b8a5543c03e72aae70">More...</a><br /></td></tr>
<tr class="separator:a0096a1e09debf3b8a5543c03e72aae70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a58cfb85f4e20628d21be615ecb454864"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a58cfb85f4e20628d21be615ecb454864">atOrAfter</a> (<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> x) const</td></tr>
<tr class="memdesc:a58cfb85f4e20628d21be615ecb454864"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: address lower bound.  <a href="classSawyer_1_1Container_1_1AddressMap.html#a58cfb85f4e20628d21be615ecb454864">More...</a><br /></td></tr>
<tr class="separator:a58cfb85f4e20628d21be615ecb454864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adac64b5cadbf7a9771e60231f5e393e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#adac64b5cadbf7a9771e60231f5e393e5">atOrAfter</a> (<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> x)</td></tr>
<tr class="memdesc:adac64b5cadbf7a9771e60231f5e393e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: address lower bound.  <a href="classSawyer_1_1Container_1_1AddressMap.html#adac64b5cadbf7a9771e60231f5e393e5">More...</a><br /></td></tr>
<tr class="separator:adac64b5cadbf7a9771e60231f5e393e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a208c19edd648c2a14bdbc0ea3b573f4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a208c19edd648c2a14bdbc0ea3b573f4f">atOrBefore</a> (<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> x) const</td></tr>
<tr class="memdesc:a208c19edd648c2a14bdbc0ea3b573f4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: address upper bound.  <a href="classSawyer_1_1Container_1_1AddressMap.html#a208c19edd648c2a14bdbc0ea3b573f4f">More...</a><br /></td></tr>
<tr class="separator:a208c19edd648c2a14bdbc0ea3b573f4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae135a389ebf1686b0f5466665946cb66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#ae135a389ebf1686b0f5466665946cb66">atOrBefore</a> (<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> x)</td></tr>
<tr class="memdesc:ae135a389ebf1686b0f5466665946cb66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: address upper bound.  <a href="classSawyer_1_1Container_1_1AddressMap.html#ae135a389ebf1686b0f5466665946cb66">More...</a><br /></td></tr>
<tr class="separator:ae135a389ebf1686b0f5466665946cb66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ae5ebef9012fe87f1628a3a261b03fd7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#ae5ebef9012fe87f1628a3a261b03fd7f">within</a> (const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">Sawyer::Container::Interval</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> &gt; &amp;x) const</td></tr>
<tr class="memdesc:ae5ebef9012fe87f1628a3a261b03fd7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: address lower and upper bounds.  <a href="classSawyer_1_1Container_1_1AddressMap.html#ae5ebef9012fe87f1628a3a261b03fd7f">More...</a><br /></td></tr>
<tr class="separator:ae5ebef9012fe87f1628a3a261b03fd7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c28ab95b498fa2bc4975dc2896eeb34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a4c28ab95b498fa2bc4975dc2896eeb34">within</a> (const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">Sawyer::Container::Interval</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> &gt; &amp;x)</td></tr>
<tr class="memdesc:a4c28ab95b498fa2bc4975dc2896eeb34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: address lower and upper bounds.  <a href="classSawyer_1_1Container_1_1AddressMap.html#a4c28ab95b498fa2bc4975dc2896eeb34">More...</a><br /></td></tr>
<tr class="separator:a4c28ab95b498fa2bc4975dc2896eeb34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a832997ac9853c41280bd5c933084130f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a832997ac9853c41280bd5c933084130f">within</a> (<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> x, <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> y) const</td></tr>
<tr class="memdesc:a832997ac9853c41280bd5c933084130f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: address lower and upper bounds.  <a href="classSawyer_1_1Container_1_1AddressMap.html#a832997ac9853c41280bd5c933084130f">More...</a><br /></td></tr>
<tr class="separator:a832997ac9853c41280bd5c933084130f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab30e2f146fcfc37dc85a9bce2e48f1f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#ab30e2f146fcfc37dc85a9bce2e48f1f2">within</a> (<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> x, <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> y)</td></tr>
<tr class="memdesc:ab30e2f146fcfc37dc85a9bce2e48f1f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: address lower and upper bounds.  <a href="classSawyer_1_1Container_1_1AddressMap.html#ab30e2f146fcfc37dc85a9bce2e48f1f2">More...</a><br /></td></tr>
<tr class="separator:ab30e2f146fcfc37dc85a9bce2e48f1f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a30023638bbe0fdf14f6bf37eba178d84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a30023638bbe0fdf14f6bf37eba178d84">baseSize</a> (<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> base, <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#adbf9f66a08580ead37de8f0dd96d575e">size</a>) const</td></tr>
<tr class="memdesc:a30023638bbe0fdf14f6bf37eba178d84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: address lower and upper bounds.  <a href="classSawyer_1_1Container_1_1AddressMap.html#a30023638bbe0fdf14f6bf37eba178d84">More...</a><br /></td></tr>
<tr class="separator:a30023638bbe0fdf14f6bf37eba178d84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c60bbaa0927c122e3f3e7790b185f60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a4c60bbaa0927c122e3f3e7790b185f60">baseSize</a> (<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> base, <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#adbf9f66a08580ead37de8f0dd96d575e">size</a>)</td></tr>
<tr class="memdesc:a4c60bbaa0927c122e3f3e7790b185f60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: address lower and upper bounds.  <a href="classSawyer_1_1Container_1_1AddressMap.html#a4c60bbaa0927c122e3f3e7790b185f60">More...</a><br /></td></tr>
<tr class="separator:a4c60bbaa0927c122e3f3e7790b185f60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a056e03e61ac70958e5396cc39ef8190c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a056e03e61ac70958e5396cc39ef8190c">after</a> (<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> x) const</td></tr>
<tr class="memdesc:a056e03e61ac70958e5396cc39ef8190c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: address lower bound.  <a href="classSawyer_1_1Container_1_1AddressMap.html#a056e03e61ac70958e5396cc39ef8190c">More...</a><br /></td></tr>
<tr class="separator:a056e03e61ac70958e5396cc39ef8190c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2171cf51701fea042950e2dcf8b527d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#aa2171cf51701fea042950e2dcf8b527d">after</a> (<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> x)</td></tr>
<tr class="memdesc:aa2171cf51701fea042950e2dcf8b527d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: address lower bound.  <a href="classSawyer_1_1Container_1_1AddressMap.html#aa2171cf51701fea042950e2dcf8b527d">More...</a><br /></td></tr>
<tr class="separator:aa2171cf51701fea042950e2dcf8b527d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ad8562670e30a85accd75e7dc70e02cbc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#ad8562670e30a85accd75e7dc70e02cbc">before</a> (<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> x) const</td></tr>
<tr class="memdesc:ad8562670e30a85accd75e7dc70e02cbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: address upper bound.  <a href="classSawyer_1_1Container_1_1AddressMap.html#ad8562670e30a85accd75e7dc70e02cbc">More...</a><br /></td></tr>
<tr class="separator:ad8562670e30a85accd75e7dc70e02cbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27c01c5f99e9ad1561d7de45ea0e53ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a27c01c5f99e9ad1561d7de45ea0e53ab">before</a> (<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> x)</td></tr>
<tr class="memdesc:a27c01c5f99e9ad1561d7de45ea0e53ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: address upper bound.  <a href="classSawyer_1_1Container_1_1AddressMap.html#a27c01c5f99e9ad1561d7de45ea0e53ab">More...</a><br /></td></tr>
<tr class="separator:a27c01c5f99e9ad1561d7de45ea0e53ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a36a09beef2d2b0d0aededc581a764ab3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a36a09beef2d2b0d0aededc581a764ab3">singleSegment</a> () const</td></tr>
<tr class="memdesc:a36a09beef2d2b0d0aededc581a764ab3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: single segment.  <a href="classSawyer_1_1Container_1_1AddressMap.html#a36a09beef2d2b0d0aededc581a764ab3">More...</a><br /></td></tr>
<tr class="separator:a36a09beef2d2b0d0aededc581a764ab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a897fad779ffc4aa6b588645c4821e44f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a897fad779ffc4aa6b588645c4821e44f">singleSegment</a> ()</td></tr>
<tr class="memdesc:a897fad779ffc4aa6b588645c4821e44f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: single segment.  <a href="classSawyer_1_1Container_1_1AddressMap.html#a897fad779ffc4aa6b588645c4821e44f">More...</a><br /></td></tr>
<tr class="separator:a897fad779ffc4aa6b588645c4821e44f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a8c1698459053221a112841a23ea001dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a8c1698459053221a112841a23ea001dd">segmentPredicate</a> (<a class="el" href="classSawyer_1_1Container_1_1SegmentPredicate.html">SegmentPredicate</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a>, <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#aa7a7317b6be4502317ab4357b5989660">Value</a> &gt; *p) const</td></tr>
<tr class="memdesc:a8c1698459053221a112841a23ea001dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: arbitrary segment constraint.  <a href="classSawyer_1_1Container_1_1AddressMap.html#a8c1698459053221a112841a23ea001dd">More...</a><br /></td></tr>
<tr class="separator:a8c1698459053221a112841a23ea001dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc6e65b9c935bd94e9e0987fcfd00ddb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#afc6e65b9c935bd94e9e0987fcfd00ddb">segmentPredicate</a> (<a class="el" href="classSawyer_1_1Container_1_1SegmentPredicate.html">SegmentPredicate</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a>, <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#aa7a7317b6be4502317ab4357b5989660">Value</a> &gt; *p)</td></tr>
<tr class="memdesc:afc6e65b9c935bd94e9e0987fcfd00ddb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: arbitrary segment constraint.  <a href="classSawyer_1_1Container_1_1AddressMap.html#afc6e65b9c935bd94e9e0987fcfd00ddb">More...</a><br /></td></tr>
<tr class="separator:afc6e65b9c935bd94e9e0987fcfd00ddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ae9e6ba6b08b23a5612567199c0b2de32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#ae9e6ba6b08b23a5612567199c0b2de32">any</a> () const</td></tr>
<tr class="memdesc:ae9e6ba6b08b23a5612567199c0b2de32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: matches anything.  <a href="classSawyer_1_1Container_1_1AddressMap.html#ae9e6ba6b08b23a5612567199c0b2de32">More...</a><br /></td></tr>
<tr class="separator:ae9e6ba6b08b23a5612567199c0b2de32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e1b4ea62372c9ee4ddcb4583f0bcf67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a3e1b4ea62372c9ee4ddcb4583f0bcf67">any</a> ()</td></tr>
<tr class="memdesc:a3e1b4ea62372c9ee4ddcb4583f0bcf67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: matches anything.  <a href="classSawyer_1_1Container_1_1AddressMap.html#a3e1b4ea62372c9ee4ddcb4583f0bcf67">More...</a><br /></td></tr>
<tr class="separator:a3e1b4ea62372c9ee4ddcb4583f0bcf67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ac6151ac162e90dec4698bee00f484ea8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#ac6151ac162e90dec4698bee00f484ea8">none</a> () const</td></tr>
<tr class="memdesc:ac6151ac162e90dec4698bee00f484ea8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: matches nothing.  <a href="classSawyer_1_1Container_1_1AddressMap.html#ac6151ac162e90dec4698bee00f484ea8">More...</a><br /></td></tr>
<tr class="separator:ac6151ac162e90dec4698bee00f484ea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe729f3f34a61e283e79716850400e95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#afe729f3f34a61e283e79716850400e95">none</a> ()</td></tr>
<tr class="memdesc:afe729f3f34a61e283e79716850400e95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: matches nothing.  <a href="classSawyer_1_1Container_1_1AddressMap.html#afe729f3f34a61e283e79716850400e95">More...</a><br /></td></tr>
<tr class="separator:afe729f3f34a61e283e79716850400e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a401b8b33966dcbdb4dbe2b9e7ba0402a"><td class="memItemLeft" align="right" valign="top">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a9f7204596756341c0ea7eeadc5d38262">SegmentIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a401b8b33966dcbdb4dbe2b9e7ba0402a">segments</a> ()</td></tr>
<tr class="memdesc:a401b8b33966dcbdb4dbe2b9e7ba0402a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator range for all segments.  <a href="classSawyer_1_1Container_1_1AddressMap.html#a401b8b33966dcbdb4dbe2b9e7ba0402a">More...</a><br /></td></tr>
<tr class="separator:a401b8b33966dcbdb4dbe2b9e7ba0402a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a157bc462f7ab4b9c94b239c15ac99c8e"><td class="memItemLeft" align="right" valign="top">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#aa852a793027a1c74c097147546910f47">ConstSegmentIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a157bc462f7ab4b9c94b239c15ac99c8e">segments</a> () const</td></tr>
<tr class="memdesc:a157bc462f7ab4b9c94b239c15ac99c8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator range for all segments.  <a href="classSawyer_1_1Container_1_1AddressMap.html#a157bc462f7ab4b9c94b239c15ac99c8e">More...</a><br /></td></tr>
<tr class="separator:a157bc462f7ab4b9c94b239c15ac99c8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a266b1cbad20d21bfd8a88e51d1a51196"><td class="memItemLeft" align="right" valign="top">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#aa852a793027a1c74c097147546910f47">ConstSegmentIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a266b1cbad20d21bfd8a88e51d1a51196">segments</a> (const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; &amp;c, <a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a> flags=0) const</td></tr>
<tr class="memdesc:a266b1cbad20d21bfd8a88e51d1a51196"><td class="mdescLeft">&#160;</td><td class="mdescRight">Segments that overlap with constraints.  <a href="classSawyer_1_1Container_1_1AddressMap.html#a266b1cbad20d21bfd8a88e51d1a51196">More...</a><br /></td></tr>
<tr class="separator:a266b1cbad20d21bfd8a88e51d1a51196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab320e01d3e8afe0741eb1dff8acd0037"><td class="memItemLeft" align="right" valign="top">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a9f7204596756341c0ea7eeadc5d38262">SegmentIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#ab320e01d3e8afe0741eb1dff8acd0037">segments</a> (const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; &amp;c, <a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a> flags=0)</td></tr>
<tr class="memdesc:ab320e01d3e8afe0741eb1dff8acd0037"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator range for all segments.  <a href="classSawyer_1_1Container_1_1AddressMap.html#ab320e01d3e8afe0741eb1dff8acd0037">More...</a><br /></td></tr>
<tr class="separator:ab320e01d3e8afe0741eb1dff8acd0037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a000ced173d57eb4990dea1b45f0339e0"><td class="memItemLeft" align="right" valign="top">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#ac6954614b9b130d841261ad4d2644316">NodeIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a000ced173d57eb4990dea1b45f0339e0">nodes</a> ()</td></tr>
<tr class="memdesc:a000ced173d57eb4990dea1b45f0339e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator range for nodes.  <a href="classSawyer_1_1Container_1_1AddressMap.html#a000ced173d57eb4990dea1b45f0339e0">More...</a><br /></td></tr>
<tr class="separator:a000ced173d57eb4990dea1b45f0339e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa5e931be5d01934109ca9a293551ad1"><td class="memItemLeft" align="right" valign="top">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#abf7a3b18db58eae98d782531b3f155b5">ConstNodeIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#aaa5e931be5d01934109ca9a293551ad1">nodes</a> () const</td></tr>
<tr class="memdesc:aaa5e931be5d01934109ca9a293551ad1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator range for nodes.  <a href="classSawyer_1_1Container_1_1AddressMap.html#aaa5e931be5d01934109ca9a293551ad1">More...</a><br /></td></tr>
<tr class="separator:aaa5e931be5d01934109ca9a293551ad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a3ec685ae8bb406899f06706713fe0c93"><td class="memItemLeft" align="right" valign="top">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#abf7a3b18db58eae98d782531b3f155b5">ConstNodeIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a3ec685ae8bb406899f06706713fe0c93">nodes</a> (const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; &amp;c, <a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a> flags=0) const</td></tr>
<tr class="memdesc:a3ec685ae8bb406899f06706713fe0c93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nodes that overlap with constraints.  <a href="classSawyer_1_1Container_1_1AddressMap.html#a3ec685ae8bb406899f06706713fe0c93">More...</a><br /></td></tr>
<tr class="separator:a3ec685ae8bb406899f06706713fe0c93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33e1bdf9c9ed63d63e0ba3dfa82e967d"><td class="memItemLeft" align="right" valign="top">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#ac6954614b9b130d841261ad4d2644316">NodeIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a33e1bdf9c9ed63d63e0ba3dfa82e967d">nodes</a> (const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; &amp;c, <a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a> flags=0)</td></tr>
<tr class="memdesc:a33e1bdf9c9ed63d63e0ba3dfa82e967d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nodes that overlap with constraints.  <a href="classSawyer_1_1Container_1_1AddressMap.html#a33e1bdf9c9ed63d63e0ba3dfa82e967d">More...</a><br /></td></tr>
<tr class="separator:a33e1bdf9c9ed63d63e0ba3dfa82e967d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a11968c68b0efd523b24e371bff818613"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#abf7a3b18db58eae98d782531b3f155b5">ConstNodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a11968c68b0efd523b24e371bff818613">findNode</a> (const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; &amp;c, <a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a> flags=0) const</td></tr>
<tr class="memdesc:a11968c68b0efd523b24e371bff818613"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find node containing address.  <a href="classSawyer_1_1Container_1_1AddressMap.html#a11968c68b0efd523b24e371bff818613">More...</a><br /></td></tr>
<tr class="separator:a11968c68b0efd523b24e371bff818613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a164562fd38d476e8c0daf810075b399f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#ac6954614b9b130d841261ad4d2644316">NodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a164562fd38d476e8c0daf810075b399f">findNode</a> (const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; &amp;c, <a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a> flags=0)</td></tr>
<tr class="memdesc:a164562fd38d476e8c0daf810075b399f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find node containing address.  <a href="classSawyer_1_1Container_1_1AddressMap.html#a164562fd38d476e8c0daf810075b399f">More...</a><br /></td></tr>
<tr class="separator:a164562fd38d476e8c0daf810075b399f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a895d3400de898b3dd49a7bb7074dcf0e"><td class="memTemplParams" colspan="2">template&lt;typename Functor &gt; </td></tr>
<tr class="memitem:a895d3400de898b3dd49a7bb7074dcf0e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a895d3400de898b3dd49a7bb7074dcf0e">traverse</a> (Functor &amp;functor, const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; &amp;c, <a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a> flags=0) const</td></tr>
<tr class="memdesc:a895d3400de898b3dd49a7bb7074dcf0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke a function on each address interval.  <a href="classSawyer_1_1Container_1_1AddressMap.html#a895d3400de898b3dd49a7bb7074dcf0e">More...</a><br /></td></tr>
<tr class="separator:a895d3400de898b3dd49a7bb7074dcf0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a8b6e632d09737c2ca035640af3d565"><td class="memTemplParams" colspan="2">template&lt;typename Functor &gt; </td></tr>
<tr class="memitem:a0a8b6e632d09737c2ca035640af3d565"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a0a8b6e632d09737c2ca035640af3d565">traverse</a> (Functor &amp;functor, const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; &amp;c, <a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a> flags=0)</td></tr>
<tr class="memdesc:a0a8b6e632d09737c2ca035640af3d565"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke a function on each address interval.  <a href="classSawyer_1_1Container_1_1AddressMap.html#a0a8b6e632d09737c2ca035640af3d565">More...</a><br /></td></tr>
<tr class="separator:a0a8b6e632d09737c2ca035640af3d565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bd627686043b35501fabb3b89e867a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a9bd627686043b35501fabb3b89e867a8">traverse</a> (<a class="el" href="classSawyer_1_1Container_1_1AddressMap_1_1Visitor.html">Visitor</a> &amp;visitor, const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; &amp;c, <a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a> flags=0) const</td></tr>
<tr class="memdesc:a9bd627686043b35501fabb3b89e867a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke a function on each address interval.  <a href="classSawyer_1_1Container_1_1AddressMap.html#a9bd627686043b35501fabb3b89e867a8">More...</a><br /></td></tr>
<tr class="separator:a9bd627686043b35501fabb3b89e867a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b9c7d3e990027e75a9dbe45e10841ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a7b9c7d3e990027e75a9dbe45e10841ac">traverse</a> (<a class="el" href="classSawyer_1_1Container_1_1AddressMap_1_1Visitor.html">Visitor</a> &amp;visitor, const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; &amp;c, <a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a> flags=0)</td></tr>
<tr class="memdesc:a7b9c7d3e990027e75a9dbe45e10841ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke a function on each address interval.  <a href="classSawyer_1_1Container_1_1AddressMap.html#a7b9c7d3e990027e75a9dbe45e10841ac">More...</a><br /></td></tr>
<tr class="separator:a7b9c7d3e990027e75a9dbe45e10841ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ae17e760e87b8cbeb207310f6f4dc8b20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1Interval.html">Sawyer::Container::Interval</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#ae17e760e87b8cbeb207310f6f4dc8b20">read</a> (<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#aa7a7317b6be4502317ab4357b5989660">Value</a> *buf, const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; &amp;c, <a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a> flags=0) const</td></tr>
<tr class="memdesc:ae17e760e87b8cbeb207310f6f4dc8b20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads data into the supplied buffer.  <a href="classSawyer_1_1Container_1_1AddressMap.html#ae17e760e87b8cbeb207310f6f4dc8b20">More...</a><br /></td></tr>
<tr class="separator:ae17e760e87b8cbeb207310f6f4dc8b20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9719e774896dcd76f6fc70442ce73d33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1Interval.html">Sawyer::Container::Interval</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a9719e774896dcd76f6fc70442ce73d33">read</a> (std::vector&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#aa7a7317b6be4502317ab4357b5989660">Value</a> &gt; &amp;buf, const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; &amp;c, <a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a> flags=0) const</td></tr>
<tr class="memdesc:a9719e774896dcd76f6fc70442ce73d33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads data into the supplied buffer.  <a href="classSawyer_1_1Container_1_1AddressMap.html#a9719e774896dcd76f6fc70442ce73d33">More...</a><br /></td></tr>
<tr class="separator:a9719e774896dcd76f6fc70442ce73d33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aafc28dc1c26b66b2142eefa1bf13f074"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1Interval.html">Sawyer::Container::Interval</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#aafc28dc1c26b66b2142eefa1bf13f074">write</a> (const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#aa7a7317b6be4502317ab4357b5989660">Value</a> *buf, const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; &amp;c, <a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a> flags=0)</td></tr>
<tr class="memdesc:aafc28dc1c26b66b2142eefa1bf13f074"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes data from the supplied buffer.  <a href="classSawyer_1_1Container_1_1AddressMap.html#aafc28dc1c26b66b2142eefa1bf13f074">More...</a><br /></td></tr>
<tr class="separator:aafc28dc1c26b66b2142eefa1bf13f074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a652030e760430ced6f1a39690e173122"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1Interval.html">Sawyer::Container::Interval</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a652030e760430ced6f1a39690e173122">write</a> (const std::vector&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#aa7a7317b6be4502317ab4357b5989660">Value</a> &gt; &amp;buf, const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; &amp;c, <a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a> flags=0)</td></tr>
<tr class="memdesc:a652030e760430ced6f1a39690e173122"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes data from the supplied buffer.  <a href="classSawyer_1_1Container_1_1AddressMap.html#a652030e760430ced6f1a39690e173122">More...</a><br /></td></tr>
<tr class="separator:a652030e760430ced6f1a39690e173122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSawyer_1_1Container_1_1IntervalMap')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">Sawyer::Container::IntervalMap&lt; Interval&lt; A &gt;, AddressSegment&lt; A, boost::uint8_t &gt;, AddressMapImpl::SegmentMergePolicy&lt; A, boost::uint8_t &gt; &gt;</a></td></tr>
<tr class="memitem:a0c5f60fb7032334c08cf77fa731aeb26 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a0c5f60fb7032334c08cf77fa731aeb26">IntervalMap</a> ()</td></tr>
<tr class="memdesc:a0c5f60fb7032334c08cf77fa731aeb26 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#a0c5f60fb7032334c08cf77fa731aeb26">More...</a><br /></td></tr>
<tr class="separator:a0c5f60fb7032334c08cf77fa731aeb26 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eec51514347acfef76b9b4a65654bcc inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a5eec51514347acfef76b9b4a65654bcc">IntervalMap</a> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; Interval2, T2, Policy2 &gt; &amp;other)</td></tr>
<tr class="memdesc:a5eec51514347acfef76b9b4a65654bcc inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#a5eec51514347acfef76b9b4a65654bcc">More...</a><br /></td></tr>
<tr class="separator:a5eec51514347acfef76b9b4a65654bcc inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86104e9747b2afce6b47d1fa30ffa5df inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a86104e9747b2afce6b47d1fa30ffa5df">operator=</a> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; Interval2, T2, Policy2 &gt; &amp;other)</td></tr>
<tr class="memdesc:a86104e9747b2afce6b47d1fa30ffa5df inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#a86104e9747b2afce6b47d1fa30ffa5df">More...</a><br /></td></tr>
<tr class="separator:a86104e9747b2afce6b47d1fa30ffa5df inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4ba034340ba48ff172b39cc80f3dc6e inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memItemLeft" align="right" valign="top">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ae5130ce1b0e59f7bddd6b68f02da3b2e">ConstIntervalIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ae4ba034340ba48ff172b39cc80f3dc6e">intervals</a> () const</td></tr>
<tr class="memdesc:ae4ba034340ba48ff172b39cc80f3dc6e inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterators for traversing keys.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#ae4ba034340ba48ff172b39cc80f3dc6e">More...</a><br /></td></tr>
<tr class="separator:ae4ba034340ba48ff172b39cc80f3dc6e inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25feb127b25f2d5f7616003a010abdca inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a25feb127b25f2d5f7616003a010abdca">firstUnmapped</a> (typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> minAddr) const</td></tr>
<tr class="memdesc:a25feb127b25f2d5f7616003a010abdca inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first unmapped region.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#a25feb127b25f2d5f7616003a010abdca">More...</a><br /></td></tr>
<tr class="separator:a25feb127b25f2d5f7616003a010abdca inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53ebe1dc48e4f3ef5051c97fb8d44c07 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a53ebe1dc48e4f3ef5051c97fb8d44c07">lastUnmapped</a> (typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> maxAddr) const</td></tr>
<tr class="memdesc:a53ebe1dc48e4f3ef5051c97fb8d44c07 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the last unmapped region.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#a53ebe1dc48e4f3ef5051c97fb8d44c07">More...</a><br /></td></tr>
<tr class="separator:a53ebe1dc48e4f3ef5051c97fb8d44c07 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8da2cba60c620a2c9d4e60f57fe7a530 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a8da2cba60c620a2c9d4e60f57fe7a530">exists</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#adbf9f66a08580ead37de8f0dd96d575e">size</a>) const</td></tr>
<tr class="memdesc:a8da2cba60c620a2c9d4e60f57fe7a530 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if element exists.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#a8da2cba60c620a2c9d4e60f57fe7a530">More...</a><br /></td></tr>
<tr class="separator:a8da2cba60c620a2c9d4e60f57fe7a530 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaad485b90e17980663b8ba6df88b3c5c inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a7c7ef387287aa01aa632dfeafc121e95">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#aaad485b90e17980663b8ba6df88b3c5c">getOptional</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;scalar) const</td></tr>
<tr class="memdesc:aaad485b90e17980663b8ba6df88b3c5c inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup and return a value or nothing.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#aaad485b90e17980663b8ba6df88b3c5c">More...</a><br /></td></tr>
<tr class="separator:aaad485b90e17980663b8ba6df88b3c5c inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20b99d95c8c627e166be33a780349195 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a7c7ef387287aa01aa632dfeafc121e95">Value</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a20b99d95c8c627e166be33a780349195">getOrDefault</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;scalar) const</td></tr>
<tr class="memdesc:a20b99d95c8c627e166be33a780349195 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup and return a value or a default.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#a20b99d95c8c627e166be33a780349195">More...</a><br /></td></tr>
<tr class="separator:a20b99d95c8c627e166be33a780349195 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb61e91bac6aa82b6a5193726799bdf9 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#acb61e91bac6aa82b6a5193726799bdf9">isEmpty</a> () const</td></tr>
<tr class="memdesc:acb61e91bac6aa82b6a5193726799bdf9 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the container is empty.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#acb61e91bac6aa82b6a5193726799bdf9">More...</a><br /></td></tr>
<tr class="separator:acb61e91bac6aa82b6a5193726799bdf9 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a017216edaa9c3064857c75fc63c07217 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a017216edaa9c3064857c75fc63c07217">nIntervals</a> () const</td></tr>
<tr class="memdesc:a017216edaa9c3064857c75fc63c07217 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of nodes in the container.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#a017216edaa9c3064857c75fc63c07217">More...</a><br /></td></tr>
<tr class="separator:a017216edaa9c3064857c75fc63c07217 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbf9f66a08580ead37de8f0dd96d575e inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#adbf9f66a08580ead37de8f0dd96d575e">size</a> () const</td></tr>
<tr class="memdesc:adbf9f66a08580ead37de8f0dd96d575e inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of values represented by this container.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#adbf9f66a08580ead37de8f0dd96d575e">More...</a><br /></td></tr>
<tr class="separator:adbf9f66a08580ead37de8f0dd96d575e inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e7d3909845b1efa5c5849f60faa3192 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memItemLeft" align="right" valign="top"><a id="a6e7d3909845b1efa5c5849f60faa3192"></a>
<a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a6e7d3909845b1efa5c5849f60faa3192">least</a> () const</td></tr>
<tr class="memdesc:a6e7d3909845b1efa5c5849f60faa3192 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimum scalar key. <br /></td></tr>
<tr class="separator:a6e7d3909845b1efa5c5849f60faa3192 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e15275d860b2da7e0de9a57fd3bd795 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt; typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a1e15275d860b2da7e0de9a57fd3bd795">least</a> (typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> lowerLimit) const</td></tr>
<tr class="memdesc:a1e15275d860b2da7e0de9a57fd3bd795 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the limited-minimum scalar key.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#a1e15275d860b2da7e0de9a57fd3bd795">More...</a><br /></td></tr>
<tr class="separator:a1e15275d860b2da7e0de9a57fd3bd795 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a385bbee53b2f1ba14ad34af9211f067d inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memItemLeft" align="right" valign="top"><a id="a385bbee53b2f1ba14ad34af9211f067d"></a>
<a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a385bbee53b2f1ba14ad34af9211f067d">greatest</a> () const</td></tr>
<tr class="memdesc:a385bbee53b2f1ba14ad34af9211f067d inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum scalar key. <br /></td></tr>
<tr class="separator:a385bbee53b2f1ba14ad34af9211f067d inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a7779da0f740c936fdb562087d91152 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt; typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a0a7779da0f740c936fdb562087d91152">greatest</a> (typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> upperLimit) const</td></tr>
<tr class="memdesc:a0a7779da0f740c936fdb562087d91152 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the limited-maximum scalar key.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#a0a7779da0f740c936fdb562087d91152">More...</a><br /></td></tr>
<tr class="separator:a0a7779da0f740c936fdb562087d91152 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d679a902269aaa699bcf8a4999c17c3 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt; typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a0d679a902269aaa699bcf8a4999c17c3">leastUnmapped</a> (typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> lowerLimit) const</td></tr>
<tr class="memdesc:a0d679a902269aaa699bcf8a4999c17c3 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the limited-minimum unmapped scalar key.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#a0d679a902269aaa699bcf8a4999c17c3">More...</a><br /></td></tr>
<tr class="separator:a0d679a902269aaa699bcf8a4999c17c3 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7059f415687b5e7caec66dd7f4b133a2 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt; typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a7059f415687b5e7caec66dd7f4b133a2">greatestUnmapped</a> (typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> upperLimit) const</td></tr>
<tr class="memdesc:a7059f415687b5e7caec66dd7f4b133a2 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the limited-maximum unmapped scalar key.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#a7059f415687b5e7caec66dd7f4b133a2">More...</a><br /></td></tr>
<tr class="separator:a7059f415687b5e7caec66dd7f4b133a2 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4734abf74cda51aa6252ecfc38342e93 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memItemLeft" align="right" valign="top"><a id="a4734abf74cda51aa6252ecfc38342e93"></a>
<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a4734abf74cda51aa6252ecfc38342e93">hull</a> () const</td></tr>
<tr class="memdesc:a4734abf74cda51aa6252ecfc38342e93 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the range of values in this map. <br /></td></tr>
<tr class="separator:a4734abf74cda51aa6252ecfc38342e93 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fd736a589e045f795c917a9d16c33d2 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memItemLeft" align="right" valign="top"><a id="a2fd736a589e045f795c917a9d16c33d2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a2fd736a589e045f795c917a9d16c33d2">clear</a> ()</td></tr>
<tr class="memdesc:a2fd736a589e045f795c917a9d16c33d2 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empties the container. <br /></td></tr>
<tr class="separator:a2fd736a589e045f795c917a9d16c33d2 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a797f0a6bd63f8debdcd0ccb2fcecf0f3 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memItemLeft" align="right" valign="top"><a id="a797f0a6bd63f8debdcd0ccb2fcecf0f3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a797f0a6bd63f8debdcd0ccb2fcecf0f3">erase</a> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a> &amp;erasure)</td></tr>
<tr class="memdesc:a797f0a6bd63f8debdcd0ccb2fcecf0f3 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase the specified interval. <br /></td></tr>
<tr class="separator:a797f0a6bd63f8debdcd0ccb2fcecf0f3 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e96516680b59244ef196a9e885ac0ca inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a3e96516680b59244ef196a9e885ac0ca">eraseMultiple</a> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, T2, Policy2 &gt; &amp;other)</td></tr>
<tr class="memdesc:a3e96516680b59244ef196a9e885ac0ca inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase intervals specified in another IntervalMap.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#a3e96516680b59244ef196a9e885ac0ca">More...</a><br /></td></tr>
<tr class="separator:a3e96516680b59244ef196a9e885ac0ca inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1effdf10ccfb80ed11cc999e850ab2bd inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a1effdf10ccfb80ed11cc999e850ab2bd">insert</a> (<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a> key, <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a7c7ef387287aa01aa632dfeafc121e95">Value</a> value, bool makeHole=true)</td></tr>
<tr class="memdesc:a1effdf10ccfb80ed11cc999e850ab2bd inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a key/value pair.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#a1effdf10ccfb80ed11cc999e850ab2bd">More...</a><br /></td></tr>
<tr class="separator:a1effdf10ccfb80ed11cc999e850ab2bd inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af596a5898489cd4c86320bd5a1aa4307 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#af596a5898489cd4c86320bd5a1aa4307">insertMultiple</a> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, T2, Policy2 &gt; &amp;other, bool makeHole=true)</td></tr>
<tr class="memdesc:af596a5898489cd4c86320bd5a1aa4307 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert values from another container.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#af596a5898489cd4c86320bd5a1aa4307">More...</a><br /></td></tr>
<tr class="separator:af596a5898489cd4c86320bd5a1aa4307 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11a77bbaa8abcabd5f21e3fafd19dafd inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memItemLeft" align="right" valign="top"><a id="a11a77bbaa8abcabd5f21e3fafd19dafd"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isOverlapping</b> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a> &amp;interval) const</td></tr>
<tr class="separator:a11a77bbaa8abcabd5f21e3fafd19dafd inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedc79f844559a4d50a71073d40f3c495 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memItemLeft" align="right" valign="top"><a id="aedc79f844559a4d50a71073d40f3c495"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isOverlapping</b> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, T2, Policy2 &gt; &amp;other) const</td></tr>
<tr class="separator:aedc79f844559a4d50a71073d40f3c495 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28ed971cc7c018a24e1bad32b6a3cd3d inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memItemLeft" align="right" valign="top"><a id="a28ed971cc7c018a24e1bad32b6a3cd3d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isDistinct</b> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a> &amp;interval) const</td></tr>
<tr class="separator:a28ed971cc7c018a24e1bad32b6a3cd3d inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac040de688b66d2fd0f96e9e8da36ccb3 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memItemLeft" align="right" valign="top"><a id="ac040de688b66d2fd0f96e9e8da36ccb3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isDistinct</b> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, T2, Policy2 &gt; &amp;other) const</td></tr>
<tr class="separator:ac040de688b66d2fd0f96e9e8da36ccb3 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a968496e5f3ddf732369084e3b9405fb6 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memItemLeft" align="right" valign="top"><a id="a968496e5f3ddf732369084e3b9405fb6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>contains</b> (<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a> key) const</td></tr>
<tr class="separator:a968496e5f3ddf732369084e3b9405fb6 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12776c478c6a1448865aa083fac5a2a4 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memItemLeft" align="right" valign="top"><a id="a12776c478c6a1448865aa083fac5a2a4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>contains</b> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, T2, Policy2 &gt; &amp;other) const</td></tr>
<tr class="separator:a12776c478c6a1448865aa083fac5a2a4 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bcd6255a35955db90ec2d0f939086e2 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memItemLeft" align="right" valign="top">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a4bcd6255a35955db90ec2d0f939086e2">nodes</a> ()</td></tr>
<tr class="memdesc:a4bcd6255a35955db90ec2d0f939086e2 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterators for traversing nodes.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#a4bcd6255a35955db90ec2d0f939086e2">More...</a><br /></td></tr>
<tr class="separator:a4bcd6255a35955db90ec2d0f939086e2 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d22ef3d4fc38b0ac068481e01211cb8 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memItemLeft" align="right" valign="top">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>nodes</b> () const</td></tr>
<tr class="memdesc:a3d22ef3d4fc38b0ac068481e01211cb8 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterators for traversing nodes.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#a3d22ef3d4fc38b0ac068481e01211cb8">More...</a><br /></td></tr>
<tr class="separator:a3d22ef3d4fc38b0ac068481e01211cb8 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe92a3a1fed8440a506b3cde7891a665 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memItemLeft" align="right" valign="top">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ae50e191b16e240244fb48af0232e88ac">ValueIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#afe92a3a1fed8440a506b3cde7891a665">values</a> ()</td></tr>
<tr class="memdesc:afe92a3a1fed8440a506b3cde7891a665 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterators for traversing values.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#afe92a3a1fed8440a506b3cde7891a665">More...</a><br /></td></tr>
<tr class="separator:afe92a3a1fed8440a506b3cde7891a665 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabafbf1a1a5177d6b21006309e73c1c2 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memItemLeft" align="right" valign="top">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a050e4ca3dcf0d65fba2d65b20e9730d9">ConstValueIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>values</b> () const</td></tr>
<tr class="memdesc:aabafbf1a1a5177d6b21006309e73c1c2 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterators for traversing values.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#aabafbf1a1a5177d6b21006309e73c1c2">More...</a><br /></td></tr>
<tr class="separator:aabafbf1a1a5177d6b21006309e73c1c2 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87170e7d06eb8710211a65fb9bc052c6 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a87170e7d06eb8710211a65fb9bc052c6">lowerBound</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;scalar)</td></tr>
<tr class="memdesc:a87170e7d06eb8710211a65fb9bc052c6 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first node whose interval ends at or above the specified scalar key.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#a87170e7d06eb8710211a65fb9bc052c6">More...</a><br /></td></tr>
<tr class="separator:a87170e7d06eb8710211a65fb9bc052c6 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cdf5d3be3c2b27013876e65f69acd5d inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>lowerBound</b> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;scalar) const</td></tr>
<tr class="memdesc:a4cdf5d3be3c2b27013876e65f69acd5d inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first node whose interval ends at or above the specified scalar key.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#a4cdf5d3be3c2b27013876e65f69acd5d">More...</a><br /></td></tr>
<tr class="separator:a4cdf5d3be3c2b27013876e65f69acd5d inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56a00171503e761f08e789d07692187e inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a56a00171503e761f08e789d07692187e">upperBound</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;scalar)</td></tr>
<tr class="memdesc:a56a00171503e761f08e789d07692187e inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first node whose interval begins above the specified scalar key.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#a56a00171503e761f08e789d07692187e">More...</a><br /></td></tr>
<tr class="separator:a56a00171503e761f08e789d07692187e inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f52b31510a0edd7a3a6b99848d66df7 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>upperBound</b> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;scalar) const</td></tr>
<tr class="memdesc:a1f52b31510a0edd7a3a6b99848d66df7 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first node whose interval begins above the specified scalar key.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#a1f52b31510a0edd7a3a6b99848d66df7">More...</a><br /></td></tr>
<tr class="separator:a1f52b31510a0edd7a3a6b99848d66df7 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae26fe590db1a0db229019c39ce9a63c4 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a7c7ef387287aa01aa632dfeafc121e95">Value</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ae26fe590db1a0db229019c39ce9a63c4">operator[]</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;scalar) const</td></tr>
<tr class="memdesc:ae26fe590db1a0db229019c39ce9a63c4 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to an existing value.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#ae26fe590db1a0db229019c39ce9a63c4">More...</a><br /></td></tr>
<tr class="separator:ae26fe590db1a0db229019c39ce9a63c4 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a698c1549cbf43028b6cb07721d449405 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a7c7ef387287aa01aa632dfeafc121e95">Value</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>get</b> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;scalar) const</td></tr>
<tr class="memdesc:a698c1549cbf43028b6cb07721d449405 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to an existing value.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#a698c1549cbf43028b6cb07721d449405">More...</a><br /></td></tr>
<tr class="separator:a698c1549cbf43028b6cb07721d449405 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9784567bd34e5bba82aaab13e0fd5934 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a7c7ef387287aa01aa632dfeafc121e95">Value</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a9784567bd34e5bba82aaab13e0fd5934">getOrElse</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;scalar, <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a7c7ef387287aa01aa632dfeafc121e95">Value</a> &amp;dflt)</td></tr>
<tr class="memdesc:a9784567bd34e5bba82aaab13e0fd5934 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup and return a value or something else.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#a9784567bd34e5bba82aaab13e0fd5934">More...</a><br /></td></tr>
<tr class="separator:a9784567bd34e5bba82aaab13e0fd5934 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa3f2968268e558b2f5c3088b419103e inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a7c7ef387287aa01aa632dfeafc121e95">Value</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getOrElse</b> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;scalar, const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a7c7ef387287aa01aa632dfeafc121e95">Value</a> &amp;dflt) const</td></tr>
<tr class="memdesc:aaa3f2968268e558b2f5c3088b419103e inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup and return a value or something else.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#aaa3f2968268e558b2f5c3088b419103e">More...</a><br /></td></tr>
<tr class="separator:aaa3f2968268e558b2f5c3088b419103e inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad53242671f18d795f3b040bdd0d7e49 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#aad53242671f18d795f3b040bdd0d7e49">findPrior</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;scalar)</td></tr>
<tr class="memdesc:aad53242671f18d795f3b040bdd0d7e49 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the last node whose interval starts at or below the specified scalar key.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#aad53242671f18d795f3b040bdd0d7e49">More...</a><br /></td></tr>
<tr class="separator:aad53242671f18d795f3b040bdd0d7e49 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab59f19099179c53ab74984bf74855aaa inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>findPrior</b> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;scalar) const</td></tr>
<tr class="memdesc:ab59f19099179c53ab74984bf74855aaa inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the last node whose interval starts at or below the specified scalar key.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#ab59f19099179c53ab74984bf74855aaa">More...</a><br /></td></tr>
<tr class="separator:ab59f19099179c53ab74984bf74855aaa inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d4a318aba4a2a8af2a6a6e3570279a8 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a9d4a318aba4a2a8af2a6a6e3570279a8">find</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;scalar)</td></tr>
<tr class="memdesc:a9d4a318aba4a2a8af2a6a6e3570279a8 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the node containing the specified scalar key.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#a9d4a318aba4a2a8af2a6a6e3570279a8">More...</a><br /></td></tr>
<tr class="separator:a9d4a318aba4a2a8af2a6a6e3570279a8 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6675861f9feb70004fe397d1600d466f inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>find</b> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;scalar) const</td></tr>
<tr class="memdesc:a6675861f9feb70004fe397d1600d466f inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the node containing the specified scalar key.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#a6675861f9feb70004fe397d1600d466f">More...</a><br /></td></tr>
<tr class="separator:a6675861f9feb70004fe397d1600d466f inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd6f088274649e06edc5911fa74c3379 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memItemLeft" align="right" valign="top">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#acd6f088274649e06edc5911fa74c3379">findAll</a> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a> &amp;interval)</td></tr>
<tr class="memdesc:acd6f088274649e06edc5911fa74c3379 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds all nodes overlapping the specified interval.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#acd6f088274649e06edc5911fa74c3379">More...</a><br /></td></tr>
<tr class="separator:acd6f088274649e06edc5911fa74c3379 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbc578d55f2c30733f592cf534535d83 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memItemLeft" align="right" valign="top">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>findAll</b> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a> &amp;interval) const</td></tr>
<tr class="memdesc:abbc578d55f2c30733f592cf534535d83 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds all nodes overlapping the specified interval.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#abbc578d55f2c30733f592cf534535d83">More...</a><br /></td></tr>
<tr class="separator:abbc578d55f2c30733f592cf534535d83 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5a821909b63dedab54193fbd4a747c5 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ab5a821909b63dedab54193fbd4a747c5">findFirstOverlap</a> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a> &amp;interval)</td></tr>
<tr class="memdesc:ab5a821909b63dedab54193fbd4a747c5 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find first interval that overlaps with the specified interval.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#ab5a821909b63dedab54193fbd4a747c5">More...</a><br /></td></tr>
<tr class="separator:ab5a821909b63dedab54193fbd4a747c5 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48ef3aaccd8a7cb97c33359be83ca883 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>findFirstOverlap</b> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a> &amp;interval) const</td></tr>
<tr class="memdesc:a48ef3aaccd8a7cb97c33359be83ca883 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find first interval that overlaps with the specified interval.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#a48ef3aaccd8a7cb97c33359be83ca883">More...</a><br /></td></tr>
<tr class="separator:a48ef3aaccd8a7cb97c33359be83ca883 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a8408ce80dfcf266dc6c8443cdf01bc inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a>, typename <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, T2, Policy2 &gt;::<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a2a8408ce80dfcf266dc6c8443cdf01bc">findFirstOverlap</a> (typename <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">IntervalMap::NodeIterator</a> thisIter, const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, T2, Policy2 &gt; &amp;other, typename <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, T2, Policy2 &gt;::<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a> otherIter)</td></tr>
<tr class="memdesc:a2a8408ce80dfcf266dc6c8443cdf01bc inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find first interval that overlaps with any in another container.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#a2a8408ce80dfcf266dc6c8443cdf01bc">More...</a><br /></td></tr>
<tr class="separator:a2a8408ce80dfcf266dc6c8443cdf01bc inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a191694b0521c2f5e1eabcdc948dd5d67 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a>, typename <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, T2, Policy2 &gt;::<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>findFirstOverlap</b> (typename <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">IntervalMap::ConstNodeIterator</a> thisIter, const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, T2, Policy2 &gt; &amp;other, typename <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, T2, Policy2 &gt;::<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a> otherIter) const</td></tr>
<tr class="memdesc:a191694b0521c2f5e1eabcdc948dd5d67 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find first interval that overlaps with any in another container.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#a191694b0521c2f5e1eabcdc948dd5d67">More...</a><br /></td></tr>
<tr class="separator:a191694b0521c2f5e1eabcdc948dd5d67 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f05fe11220a1d2c1e75e2fcde5a573d inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a6f05fe11220a1d2c1e75e2fcde5a573d">firstFit</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#adbf9f66a08580ead37de8f0dd96d575e">size</a>, <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a> start)</td></tr>
<tr class="memdesc:a6f05fe11220a1d2c1e75e2fcde5a573d inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first fit node at or after a starting point.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#a6f05fe11220a1d2c1e75e2fcde5a573d">More...</a><br /></td></tr>
<tr class="separator:a6f05fe11220a1d2c1e75e2fcde5a573d inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3710d6445b86359fc16236d2bb54a8a1 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>firstFit</b> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#adbf9f66a08580ead37de8f0dd96d575e">size</a>, <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a> start) const</td></tr>
<tr class="memdesc:a3710d6445b86359fc16236d2bb54a8a1 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first fit node at or after a starting point.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#a3710d6445b86359fc16236d2bb54a8a1">More...</a><br /></td></tr>
<tr class="separator:a3710d6445b86359fc16236d2bb54a8a1 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa299225e9e0576bc9944dde4b29d569 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#afa299225e9e0576bc9944dde4b29d569">bestFit</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#adbf9f66a08580ead37de8f0dd96d575e">size</a>, <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a> start)</td></tr>
<tr class="memdesc:afa299225e9e0576bc9944dde4b29d569 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the best fit node at or after a starting point.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#afa299225e9e0576bc9944dde4b29d569">More...</a><br /></td></tr>
<tr class="separator:afa299225e9e0576bc9944dde4b29d569 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a747ae7350949b0c59e9d40db1c62286f inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>bestFit</b> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#adbf9f66a08580ead37de8f0dd96d575e">size</a>, <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a> start) const</td></tr>
<tr class="memdesc:a747ae7350949b0c59e9d40db1c62286f inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the best fit node at or after a starting point.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#a747ae7350949b0c59e9d40db1c62286f">More...</a><br /></td></tr>
<tr class="separator:a747ae7350949b0c59e9d40db1c62286f inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classSawyer_1_1Container_1_1IntervalMap"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classSawyer_1_1Container_1_1IntervalMap')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">Sawyer::Container::IntervalMap&lt; Interval&lt; A &gt;, AddressSegment&lt; A, boost::uint8_t &gt;, AddressMapImpl::SegmentMergePolicy&lt; A, boost::uint8_t &gt; &gt;</a></td></tr>
<tr class="memitem:a328f4caeb3ed341e6f7fd6530a14d70a inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structSawyer_1_1Container_1_1IntervalMapTraits.html">IntervalMapTraits</a>&lt; IMap &gt;::<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>findPriorImpl</b> (IMap &amp;imap, const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;scalar)</td></tr>
<tr class="memdesc:a328f4caeb3ed341e6f7fd6530a14d70a inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the last node whose interval starts at or below the specified scalar key.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#a328f4caeb3ed341e6f7fd6530a14d70a">More...</a><br /></td></tr>
<tr class="separator:a328f4caeb3ed341e6f7fd6530a14d70a inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca75670b38521c5be0453d2c7d5221e6 inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structSawyer_1_1Container_1_1IntervalMapTraits.html">IntervalMapTraits</a>&lt; IMap &gt;::<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>findImpl</b> (IMap &amp;imap, const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;scalar)</td></tr>
<tr class="memdesc:aca75670b38521c5be0453d2c7d5221e6 inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the node containing the specified scalar key.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#aca75670b38521c5be0453d2c7d5221e6">More...</a><br /></td></tr>
<tr class="separator:aca75670b38521c5be0453d2c7d5221e6 inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7316ec22a4b76bad014ab7f4b0b5146 inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memItemLeft" align="right" valign="top">static boost::iterator_range&lt; typename <a class="el" href="structSawyer_1_1Container_1_1IntervalMapTraits.html">IntervalMapTraits</a>&lt; IMap &gt;::<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>findAllImpl</b> (IMap &amp;imap, const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a> &amp;interval)</td></tr>
<tr class="memdesc:ac7316ec22a4b76bad014ab7f4b0b5146 inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds all nodes overlapping the specified interval.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#ac7316ec22a4b76bad014ab7f4b0b5146">More...</a><br /></td></tr>
<tr class="separator:ac7316ec22a4b76bad014ab7f4b0b5146 inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6137a2a3d9544e3ed550d409ec36a25 inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structSawyer_1_1Container_1_1IntervalMapTraits.html">IntervalMapTraits</a>&lt; IMap &gt;::<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>findFirstOverlapImpl</b> (IMap &amp;imap, const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a> &amp;interval)</td></tr>
<tr class="memdesc:ac6137a2a3d9544e3ed550d409ec36a25 inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find first interval that overlaps with the specified interval.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#ac6137a2a3d9544e3ed550d409ec36a25">More...</a><br /></td></tr>
<tr class="separator:ac6137a2a3d9544e3ed550d409ec36a25 inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f0c498977ab94415ab40fe46e717d2f inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memItemLeft" align="right" valign="top">static std::pair&lt; typename <a class="el" href="structSawyer_1_1Container_1_1IntervalMapTraits.html">IntervalMapTraits</a>&lt; IMap &gt;::<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a>, typename <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, T2, Policy2 &gt;::<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>findFirstOverlapImpl</b> (IMap &amp;imap, typename <a class="el" href="structSawyer_1_1Container_1_1IntervalMapTraits.html">IntervalMapTraits</a>&lt; IMap &gt;::<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a> thisIter, const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, T2, Policy2 &gt; &amp;other, typename <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, T2, Policy2 &gt;::<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a> otherIter)</td></tr>
<tr class="memdesc:a2f0c498977ab94415ab40fe46e717d2f inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find first interval that overlaps with any in another container.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#a2f0c498977ab94415ab40fe46e717d2f">More...</a><br /></td></tr>
<tr class="separator:a2f0c498977ab94415ab40fe46e717d2f inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab0a866bb43163a34bd4ea8924117ae3 inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structSawyer_1_1Container_1_1IntervalMapTraits.html">IntervalMapTraits</a>&lt; IMap &gt;::<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>firstFitImpl</b> (IMap &amp;imap, const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#adbf9f66a08580ead37de8f0dd96d575e">size</a>, typename <a class="el" href="structSawyer_1_1Container_1_1IntervalMapTraits.html">IntervalMapTraits</a>&lt; IMap &gt;::<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a> start)</td></tr>
<tr class="memdesc:aab0a866bb43163a34bd4ea8924117ae3 inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first fit node at or after a starting point.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#aab0a866bb43163a34bd4ea8924117ae3">More...</a><br /></td></tr>
<tr class="separator:aab0a866bb43163a34bd4ea8924117ae3 inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6279404d9a97574a538b3d6a18c7001d inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structSawyer_1_1Container_1_1IntervalMapTraits.html">IntervalMapTraits</a>&lt; IMap &gt;::<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>bestFitImpl</b> (IMap &amp;imap, const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#adbf9f66a08580ead37de8f0dd96d575e">size</a>, typename <a class="el" href="structSawyer_1_1Container_1_1IntervalMapTraits.html">IntervalMapTraits</a>&lt; IMap &gt;::<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a> start)</td></tr>
<tr class="memdesc:a6279404d9a97574a538b3d6a18c7001d inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the best fit node at or after a starting point.  <a href="classSawyer_1_1Container_1_1IntervalMap.html#a6279404d9a97574a538b3d6a18c7001d">More...</a><br /></td></tr>
<tr class="separator:a6279404d9a97574a538b3d6a18c7001d inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a1134be6cf10571edef9ffe6ab06fd7a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1134be6cf10571edef9ffe6ab06fd7a9">&#9670;&nbsp;</a></span>Address</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef A <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespaceSawyer_1_1Type.html" title="Data types.">Type</a> for addresses. </p>
<p>This should be an unsigned type. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01009">1009</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a2ac1bbe4c8188403070b62fbd6e85fa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ac1bbe4c8188403070b62fbd6e85fa9">&#9670;&nbsp;</a></span>AddressMap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a>&lt; A, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>copyOnWrite</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p>The new address map has the same addresses mapped to the same buffers as the <code>other</code> map. The buffers themselves are not copied since they are reference counted.</p>
<p>If <code>copyOnWrite</code> is set then the buffers are marked so that any subsequent write to that buffer via the <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#aafc28dc1c26b66b2142eefa1bf13f074">write</a> method from any <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html" title="A mapping from address space to values.">AddressMap</a> object will cause a new copy to be created and used by the <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html" title="A mapping from address space to values.">AddressMap</a> that's doing the writing. One should be careful when buffers are intended to be shared because setting the copy-on-write bit on the buffer will cause the sharing to be broken. For example, if map1 is created and then copied into map2 with the copy-on-write bit cleared, then any writes to the buffer via map1 will be visible when reading from map2 and vice versa. However, if map3 is then created by copying either map1 or map2 with the copy-on-write bit set, then writes to any of the three maps will cause that map to obtain an independent copy of the buffer, effectively removing the sharing that was intended between map1 and map2. Another thing to be aware of is that some buffer types will return a different buffer type when they're copied. For instance, copying a <a class="el" href="classSawyer_1_1Container_1_1StaticBuffer.html">StaticBuffer</a> or <a class="el" href="classSawyer_1_1Container_1_1MappedBuffer.html">MappedBuffer</a> will return an <a class="el" href="classSawyer_1_1Container_1_1AllocatingBuffer.html">AllocatingBuffer</a>. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01047">1047</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressSegment_8h_source.html#l00141">Sawyer::Container::AddressSegment&lt; A, T &gt;::buffer()</a>, and <a class="el" href="IntervalMap_8h_source.html#l00299">Sawyer::Container::IntervalMap&lt; Interval&lt; A &gt;, AddressSegment&lt; A, boost::uint8_t &gt;, AddressMapImpl::SegmentMergePolicy&lt; A, boost::uint8_t &gt; &gt;::values()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1AddressMap_a2ac1bbe4c8188403070b62fbd6e85fa9_cgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1AddressMap_a2ac1bbe4c8188403070b62fbd6e85fa9_cgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1AddressMap_a2ac1bbe4c8188403070b62fbd6e85fa9_cgraph" id="classSawyer_1_1Container_1_1AddressMap_a2ac1bbe4c8188403070b62fbd6e85fa9_cgraph">
<area shape="rect" title="Copy constructor." alt="" coords="5,53,181,95"/>
<area shape="rect" href="classSawyer_1_1Container_1_1AddressSegment.html#acd64963667c58e506d31bb67f3fd0df0" title="Property: buffer." alt="" coords="275,5,438,47"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalMap.html#afe92a3a1fed8440a506b3cde7891a665" title="Iterators for traversing values." alt="" coords="229,71,484,171"/>
</map>
</div>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa3d023864ebbf9ca4e6f009f36cbac61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3d023864ebbf9ca4e6f009f36cbac61">&#9670;&nbsp;</a></span>require() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt;const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a>&gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::require </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constraint: required access bits. </p>
<p>Constrains address to those that have all of the access bits that are set in <code>x</code>. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01061">1061</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l00243">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::require()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1AddressMap_aa3d023864ebbf9ca4e6f009f36cbac61_cgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1AddressMap_aa3d023864ebbf9ca4e6f009f36cbac61_cgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1AddressMap_aa3d023864ebbf9ca4e6f009f36cbac61_cgraph" id="classSawyer_1_1Container_1_1AddressMap_aa3d023864ebbf9ca4e6f009f36cbac61_cgraph">
<area shape="rect" title="Constraint: required access bits." alt="" coords="5,13,148,54"/>
<area shape="rect" href="classSawyer_1_1Container_1_1AddressMapConstraints.html#a9f60d117f87d8891b44be885eaca42d0" title="Require certain access permissions." alt="" coords="196,5,359,61"/>
</map>
</div>

</div>
</div>
<a id="a7c919eb303a5e43b93ef78dd4648267e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c919eb303a5e43b93ef78dd4648267e">&#9670;&nbsp;</a></span>require() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt;<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a>&gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::require </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constraint: required access bits. </p>
<p>Constrains address to those that have all of the access bits that are set in <code>x</code>. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01064">1064</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l00243">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::require()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1AddressMap_a7c919eb303a5e43b93ef78dd4648267e_cgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1AddressMap_a7c919eb303a5e43b93ef78dd4648267e_cgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1AddressMap_a7c919eb303a5e43b93ef78dd4648267e_cgraph" id="classSawyer_1_1Container_1_1AddressMap_a7c919eb303a5e43b93ef78dd4648267e_cgraph">
<area shape="rect" title="Constraint: required access bits." alt="" coords="5,13,148,54"/>
<area shape="rect" href="classSawyer_1_1Container_1_1AddressMapConstraints.html#a9f60d117f87d8891b44be885eaca42d0" title="Require certain access permissions." alt="" coords="196,5,359,61"/>
</map>
</div>

</div>
</div>
<a id="ae44b092e3f2f17005b055086de062d5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae44b092e3f2f17005b055086de062d5c">&#9670;&nbsp;</a></span>prohibit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt;const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a>&gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::prohibit </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constraint: prohibited access bits. </p>
<p>Constrains addresses to those that have none of the access bits that are set in <code>x</code>. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01074">1074</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l00250">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::prohibit()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1AddressMap_ae44b092e3f2f17005b055086de062d5c_cgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1AddressMap_ae44b092e3f2f17005b055086de062d5c_cgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1AddressMap_ae44b092e3f2f17005b055086de062d5c_cgraph" id="classSawyer_1_1Container_1_1AddressMap_ae44b092e3f2f17005b055086de062d5c_cgraph">
<area shape="rect" title="Constraint: prohibited access bits." alt="" coords="5,13,151,54"/>
<area shape="rect" href="classSawyer_1_1Container_1_1AddressMapConstraints.html#a6e70f35a67b98c0fd63699e2c09c7012" title="Prohibit certain access permissions." alt="" coords="199,5,361,61"/>
</map>
</div>

</div>
</div>
<a id="af69bb0b70bae0445c21f06e2ddf80cd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af69bb0b70bae0445c21f06e2ddf80cd7">&#9670;&nbsp;</a></span>prohibit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt;<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a>&gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::prohibit </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constraint: prohibited access bits. </p>
<p>Constrains addresses to those that have none of the access bits that are set in <code>x</code>. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01077">1077</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l00250">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::prohibit()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1AddressMap_af69bb0b70bae0445c21f06e2ddf80cd7_cgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1AddressMap_af69bb0b70bae0445c21f06e2ddf80cd7_cgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1AddressMap_af69bb0b70bae0445c21f06e2ddf80cd7_cgraph" id="classSawyer_1_1Container_1_1AddressMap_af69bb0b70bae0445c21f06e2ddf80cd7_cgraph">
<area shape="rect" title="Constraint: prohibited access bits." alt="" coords="5,13,151,54"/>
<area shape="rect" href="classSawyer_1_1Container_1_1AddressMapConstraints.html#a6e70f35a67b98c0fd63699e2c09c7012" title="Prohibit certain access permissions." alt="" coords="199,5,361,61"/>
</map>
</div>

</div>
</div>
<a id="a77f3c82ee321afbc3b3fd493cdcd7090"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77f3c82ee321afbc3b3fd493cdcd7090">&#9670;&nbsp;</a></span>access() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt;const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a>&gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::access </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constraint: required and prohibited access bits. </p>
<p>Constrains address to those that have the specified access bits. This method is the same as calling <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#aa3d023864ebbf9ca4e6f009f36cbac61">require</a> with the specified bit vector, and <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#ae44b092e3f2f17005b055086de062d5c">prohibit</a> with the inverted bit vector. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01088">1088</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l00257">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::access()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1AddressMap_a77f3c82ee321afbc3b3fd493cdcd7090_cgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1AddressMap_a77f3c82ee321afbc3b3fd493cdcd7090_cgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1AddressMap_a77f3c82ee321afbc3b3fd493cdcd7090_cgraph" id="classSawyer_1_1Container_1_1AddressMap_a77f3c82ee321afbc3b3fd493cdcd7090_cgraph">
<area shape="rect" title="Constraint: required and prohibited access bits." alt="" coords="5,13,151,54"/>
<area shape="rect" href="classSawyer_1_1Container_1_1AddressMapConstraints.html#af4b03e73519e0bbc79686276ca72c07a" title="Require and prohibit certain access permissions." alt="" coords="199,5,361,61"/>
</map>
</div>

</div>
</div>
<a id="a4c7f978008ee37d4fb659a22260e694f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c7f978008ee37d4fb659a22260e694f">&#9670;&nbsp;</a></span>access() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt;<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a>&gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::access </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constraint: required and prohibited access bits. </p>
<p>Constrains address to those that have the specified access bits. This method is the same as calling <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#aa3d023864ebbf9ca4e6f009f36cbac61">require</a> with the specified bit vector, and <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#ae44b092e3f2f17005b055086de062d5c">prohibit</a> with the inverted bit vector. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01091">1091</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l00257">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::access()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1AddressMap_a4c7f978008ee37d4fb659a22260e694f_cgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1AddressMap_a4c7f978008ee37d4fb659a22260e694f_cgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1AddressMap_a4c7f978008ee37d4fb659a22260e694f_cgraph" id="classSawyer_1_1Container_1_1AddressMap_a4c7f978008ee37d4fb659a22260e694f_cgraph">
<area shape="rect" title="Constraint: required and prohibited access bits." alt="" coords="5,13,151,54"/>
<area shape="rect" href="classSawyer_1_1Container_1_1AddressMapConstraints.html#af4b03e73519e0bbc79686276ca72c07a" title="Require and prohibit certain access permissions." alt="" coords="199,5,361,61"/>
</map>
</div>

</div>
</div>
<a id="abc18c5c2fd73b462ece48f067581ab31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc18c5c2fd73b462ece48f067581ab31">&#9670;&nbsp;</a></span>substr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt;const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a>&gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::substr </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constraint: segment name substring. </p>
<p>Constrains addresses to those that belong to a segment that contains string <code>x</code> as part of its name. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01101">1101</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l00262">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::substr()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1AddressMap_abc18c5c2fd73b462ece48f067581ab31_cgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1AddressMap_abc18c5c2fd73b462ece48f067581ab31_cgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1AddressMap_abc18c5c2fd73b462ece48f067581ab31_cgraph" id="classSawyer_1_1Container_1_1AddressMap_abc18c5c2fd73b462ece48f067581ab31_cgraph">
<area shape="rect" title="Constraint: segment name substring." alt="" coords="5,13,144,54"/>
<area shape="rect" href="classSawyer_1_1Container_1_1AddressMapConstraints.html#a7868645e439c49fa12daa4fec946cb2a" title="Require certain segment names." alt="" coords="192,5,355,61"/>
</map>
</div>

</div>
</div>
<a id="abb3355cf35be6e3d39921b750408ea62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb3355cf35be6e3d39921b750408ea62">&#9670;&nbsp;</a></span>substr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt;<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a>&gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::substr </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constraint: segment name substring. </p>
<p>Constrains addresses to those that belong to a segment that contains string <code>x</code> as part of its name. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01104">1104</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l00262">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::substr()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1AddressMap_abb3355cf35be6e3d39921b750408ea62_cgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1AddressMap_abb3355cf35be6e3d39921b750408ea62_cgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1AddressMap_abb3355cf35be6e3d39921b750408ea62_cgraph" id="classSawyer_1_1Container_1_1AddressMap_abb3355cf35be6e3d39921b750408ea62_cgraph">
<area shape="rect" title="Constraint: segment name substring." alt="" coords="5,13,144,54"/>
<area shape="rect" href="classSawyer_1_1Container_1_1AddressMapConstraints.html#a7868645e439c49fa12daa4fec946cb2a" title="Require certain segment names." alt="" coords="192,5,355,61"/>
</map>
</div>

</div>
</div>
<a id="adfcc00193310fa1925dc30d33fd52f91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfcc00193310fa1925dc30d33fd52f91">&#9670;&nbsp;</a></span>at() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt;const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a>&gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constraint: anchor point. </p>
<p>Constrains addresses to a sequence that begins at <code>x</code>. If address <code>x</code> is not part of the addresses matched by the other constraints, then no address matches. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01115">1115</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l00282">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::at()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1AddressMap_adfcc00193310fa1925dc30d33fd52f91_cgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1AddressMap_adfcc00193310fa1925dc30d33fd52f91_cgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1AddressMap_adfcc00193310fa1925dc30d33fd52f91_cgraph" id="classSawyer_1_1Container_1_1AddressMap_adfcc00193310fa1925dc30d33fd52f91_cgraph">
<area shape="rect" title="Constraint: anchor point." alt="" coords="5,5,144,47"/>
<area shape="rect" href="classSawyer_1_1Container_1_1AddressMapConstraints.html#ad288a31241d2ae0cddcdd3a26a5a0ca8" title="Anchor at a certain address." alt="" coords="192,5,373,47"/>
</map>
</div>

</div>
</div>
<a id="ad2efe482764a0b07d5d362f3e7f445a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2efe482764a0b07d5d362f3e7f445a1">&#9670;&nbsp;</a></span>at() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt;<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a>&gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constraint: anchor point. </p>
<p>Constrains addresses to a sequence that begins at <code>x</code>. If address <code>x</code> is not part of the addresses matched by the other constraints, then no address matches. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01118">1118</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l00282">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::at()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1AddressMap_ad2efe482764a0b07d5d362f3e7f445a1_cgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1AddressMap_ad2efe482764a0b07d5d362f3e7f445a1_cgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1AddressMap_ad2efe482764a0b07d5d362f3e7f445a1_cgraph" id="classSawyer_1_1Container_1_1AddressMap_ad2efe482764a0b07d5d362f3e7f445a1_cgraph">
<area shape="rect" title="Constraint: anchor point." alt="" coords="5,5,144,47"/>
<area shape="rect" href="classSawyer_1_1Container_1_1AddressMapConstraints.html#ad288a31241d2ae0cddcdd3a26a5a0ca8" title="Anchor at a certain address." alt="" coords="192,5,373,47"/>
</map>
</div>

</div>
</div>
<a id="aaad3000d0cfe62768ee1e0b632cfb924"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaad3000d0cfe62768ee1e0b632cfb924">&#9670;&nbsp;</a></span>at() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt;const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a>&gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">Sawyer::Container::Interval</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constraint: anchored interval. </p>
<p>Constrains addresses so that the lowest or highest matched address is the specified anchor point. When matching constraints in the forward direction (the default) then the anchor must be the lowest address, and when matching in the backward direction the anchor must be the highest address. The direction is specified by an argument to the operation.</p>
<p>For instance:</p>
<div class="fragment"><div class="line">map.at(100).limit(10).read(buf);               <span class="comment">// 1</span></div>
<div class="line">map.at(100).limit(10).read(buf, MATCH_BACKWARD); <span class="comment">// 2</span></div>
</div><!-- fragment --><p>Expression 1 reads up to 10 values such that the lowest value read is at address 100, while expression 2 reads up to 10 values such that the highest value read is at address 100. In both cases, if address 100 is not mapped (or otherwise does not satisfy the constraints) then nothing is read. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01142">1142</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l00282">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::at()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1AddressMap_aaad3000d0cfe62768ee1e0b632cfb924_cgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1AddressMap_aaad3000d0cfe62768ee1e0b632cfb924_cgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1AddressMap_aaad3000d0cfe62768ee1e0b632cfb924_cgraph" id="classSawyer_1_1Container_1_1AddressMap_aaad3000d0cfe62768ee1e0b632cfb924_cgraph">
<area shape="rect" title="Constraint: anchored interval." alt="" coords="5,5,144,47"/>
<area shape="rect" href="classSawyer_1_1Container_1_1AddressMapConstraints.html#ad288a31241d2ae0cddcdd3a26a5a0ca8" title="Anchor at a certain address." alt="" coords="192,5,373,47"/>
</map>
</div>

</div>
</div>
<a id="a96369b15afc113dddc496bfb12ff3a4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96369b15afc113dddc496bfb12ff3a4b">&#9670;&nbsp;</a></span>at() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt;<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a>&gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">Sawyer::Container::Interval</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constraint: anchored interval. </p>
<p>Constrains addresses so that the lowest or highest matched address is the specified anchor point. When matching constraints in the forward direction (the default) then the anchor must be the lowest address, and when matching in the backward direction the anchor must be the highest address. The direction is specified by an argument to the operation.</p>
<p>For instance:</p>
<div class="fragment"><div class="line">map.at(100).limit(10).read(buf);               <span class="comment">// 1</span></div>
<div class="line">map.at(100).limit(10).read(buf, MATCH_BACKWARD); <span class="comment">// 2</span></div>
</div><!-- fragment --><p>Expression 1 reads up to 10 values such that the lowest value read is at address 100, while expression 2 reads up to 10 values such that the highest value read is at address 100. In both cases, if address 100 is not mapped (or otherwise does not satisfy the constraints) then nothing is read. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01145">1145</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l00282">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::at()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1AddressMap_a96369b15afc113dddc496bfb12ff3a4b_cgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1AddressMap_a96369b15afc113dddc496bfb12ff3a4b_cgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1AddressMap_a96369b15afc113dddc496bfb12ff3a4b_cgraph" id="classSawyer_1_1Container_1_1AddressMap_a96369b15afc113dddc496bfb12ff3a4b_cgraph">
<area shape="rect" title="Constraint: anchored interval." alt="" coords="5,5,144,47"/>
<area shape="rect" href="classSawyer_1_1Container_1_1AddressMapConstraints.html#ad288a31241d2ae0cddcdd3a26a5a0ca8" title="Anchor at a certain address." alt="" coords="192,5,373,47"/>
</map>
</div>

</div>
</div>
<a id="ac130692f6531282e29f00bbde4fba4fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac130692f6531282e29f00bbde4fba4fd">&#9670;&nbsp;</a></span>limit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt;const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a>&gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::limit </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constraint: limit matched size. </p>
<p>Constrains the matched addresses so that at most <code>x</code> addresses match. Forward matching matches the first <code>x</code> addresses while backward matching matches the last <code>x</code> addresses. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01156">1156</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l00296">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::limit()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1AddressMap_ac130692f6531282e29f00bbde4fba4fd_cgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1AddressMap_ac130692f6531282e29f00bbde4fba4fd_cgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1AddressMap_ac130692f6531282e29f00bbde4fba4fd_cgraph" id="classSawyer_1_1Container_1_1AddressMap_ac130692f6531282e29f00bbde4fba4fd_cgraph">
<area shape="rect" title="Constraint: limit matched size." alt="" coords="5,13,144,54"/>
<area shape="rect" href="classSawyer_1_1Container_1_1AddressMapConstraints.html#a1e7b229039bfde68032769c1fba95a5e" title="Limit matching length." alt="" coords="192,5,355,61"/>
</map>
</div>

</div>
</div>
<a id="a0096a1e09debf3b8a5543c03e72aae70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0096a1e09debf3b8a5543c03e72aae70">&#9670;&nbsp;</a></span>limit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt;<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a>&gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::limit </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constraint: limit matched size. </p>
<p>Constrains the matched addresses so that at most <code>x</code> addresses match. Forward matching matches the first <code>x</code> addresses while backward matching matches the last <code>x</code> addresses. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01159">1159</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l00296">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::limit()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1AddressMap_a0096a1e09debf3b8a5543c03e72aae70_cgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1AddressMap_a0096a1e09debf3b8a5543c03e72aae70_cgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1AddressMap_a0096a1e09debf3b8a5543c03e72aae70_cgraph" id="classSawyer_1_1Container_1_1AddressMap_a0096a1e09debf3b8a5543c03e72aae70_cgraph">
<area shape="rect" title="Constraint: limit matched size." alt="" coords="5,13,144,54"/>
<area shape="rect" href="classSawyer_1_1Container_1_1AddressMapConstraints.html#a1e7b229039bfde68032769c1fba95a5e" title="Limit matching length." alt="" coords="192,5,355,61"/>
</map>
</div>

</div>
</div>
<a id="a58cfb85f4e20628d21be615ecb454864"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58cfb85f4e20628d21be615ecb454864">&#9670;&nbsp;</a></span>atOrAfter() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt;const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a>&gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::atOrAfter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constraint: address lower bound. </p>
<p>Constrains matched addresses so that they are all greater than or equal to <code>x</code>. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01169">1169</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l00303">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::atOrAfter()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1AddressMap_a58cfb85f4e20628d21be615ecb454864_cgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1AddressMap_a58cfb85f4e20628d21be615ecb454864_cgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1AddressMap_a58cfb85f4e20628d21be615ecb454864_cgraph" id="classSawyer_1_1Container_1_1AddressMap_a58cfb85f4e20628d21be615ecb454864_cgraph">
<area shape="rect" title="Constraint: address lower bound." alt="" coords="5,13,161,54"/>
<area shape="rect" href="classSawyer_1_1Container_1_1AddressMapConstraints.html#ad00a4efe30167ddc5ca9764b6bd3c96c" title="Limit addresses." alt="" coords="209,5,372,61"/>
</map>
</div>

</div>
</div>
<a id="adac64b5cadbf7a9771e60231f5e393e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adac64b5cadbf7a9771e60231f5e393e5">&#9670;&nbsp;</a></span>atOrAfter() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt;<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a>&gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::atOrAfter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constraint: address lower bound. </p>
<p>Constrains matched addresses so that they are all greater than or equal to <code>x</code>. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01172">1172</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l00303">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::atOrAfter()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1AddressMap_adac64b5cadbf7a9771e60231f5e393e5_cgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1AddressMap_adac64b5cadbf7a9771e60231f5e393e5_cgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1AddressMap_adac64b5cadbf7a9771e60231f5e393e5_cgraph" id="classSawyer_1_1Container_1_1AddressMap_adac64b5cadbf7a9771e60231f5e393e5_cgraph">
<area shape="rect" title="Constraint: address lower bound." alt="" coords="5,13,161,54"/>
<area shape="rect" href="classSawyer_1_1Container_1_1AddressMapConstraints.html#ad00a4efe30167ddc5ca9764b6bd3c96c" title="Limit addresses." alt="" coords="209,5,372,61"/>
</map>
</div>

</div>
</div>
<a id="a208c19edd648c2a14bdbc0ea3b573f4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a208c19edd648c2a14bdbc0ea3b573f4f">&#9670;&nbsp;</a></span>atOrBefore() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt;const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a>&gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::atOrBefore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constraint: address upper bound. </p>
<p>Constrains matched addresses so that they are all less than or equal to <code>x</code>. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01182">1182</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l00316">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::atOrBefore()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1AddressMap_a208c19edd648c2a14bdbc0ea3b573f4f_cgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1AddressMap_a208c19edd648c2a14bdbc0ea3b573f4f_cgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1AddressMap_a208c19edd648c2a14bdbc0ea3b573f4f_cgraph" id="classSawyer_1_1Container_1_1AddressMap_a208c19edd648c2a14bdbc0ea3b573f4f_cgraph">
<area shape="rect" title="Constraint: address upper bound." alt="" coords="5,13,172,54"/>
<area shape="rect" href="classSawyer_1_1Container_1_1AddressMapConstraints.html#acf007c10cb47a0c16f6f3764b7638928" title="Limit addresses." alt="" coords="220,5,383,61"/>
</map>
</div>

</div>
</div>
<a id="ae135a389ebf1686b0f5466665946cb66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae135a389ebf1686b0f5466665946cb66">&#9670;&nbsp;</a></span>atOrBefore() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt;<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a>&gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::atOrBefore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constraint: address upper bound. </p>
<p>Constrains matched addresses so that they are all less than or equal to <code>x</code>. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01185">1185</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l00316">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::atOrBefore()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1AddressMap_ae135a389ebf1686b0f5466665946cb66_cgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1AddressMap_ae135a389ebf1686b0f5466665946cb66_cgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1AddressMap_ae135a389ebf1686b0f5466665946cb66_cgraph" id="classSawyer_1_1Container_1_1AddressMap_ae135a389ebf1686b0f5466665946cb66_cgraph">
<area shape="rect" title="Constraint: address upper bound." alt="" coords="5,13,172,54"/>
<area shape="rect" href="classSawyer_1_1Container_1_1AddressMapConstraints.html#acf007c10cb47a0c16f6f3764b7638928" title="Limit addresses." alt="" coords="220,5,383,61"/>
</map>
</div>

</div>
</div>
<a id="ae5ebef9012fe87f1628a3a261b03fd7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5ebef9012fe87f1628a3a261b03fd7f">&#9670;&nbsp;</a></span>within() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt;const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a>&gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::within </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">Sawyer::Container::Interval</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constraint: address lower and upper bounds. </p>
<p>Constrains matched addresses so they are all within the specified interval. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01195">1195</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l00329">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::within()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1AddressMap_ae5ebef9012fe87f1628a3a261b03fd7f_cgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1AddressMap_ae5ebef9012fe87f1628a3a261b03fd7f_cgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1AddressMap_ae5ebef9012fe87f1628a3a261b03fd7f_cgraph" id="classSawyer_1_1Container_1_1AddressMap_ae5ebef9012fe87f1628a3a261b03fd7f_cgraph">
<area shape="rect" title="Constraint: address lower and upper bounds." alt="" coords="5,13,144,54"/>
<area shape="rect" href="classSawyer_1_1Container_1_1AddressMapConstraints.html#a0e35e4c4083628449d94d1279c6bc7fd" title="Limit addresses." alt="" coords="192,5,355,61"/>
</map>
</div>

</div>
</div>
<a id="a4c28ab95b498fa2bc4975dc2896eeb34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c28ab95b498fa2bc4975dc2896eeb34">&#9670;&nbsp;</a></span>within() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt;<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a>&gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::within </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">Sawyer::Container::Interval</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constraint: address lower and upper bounds. </p>
<p>Constrains matched addresses so they are all within the specified interval. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01198">1198</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l00329">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::within()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1AddressMap_a4c28ab95b498fa2bc4975dc2896eeb34_cgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1AddressMap_a4c28ab95b498fa2bc4975dc2896eeb34_cgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1AddressMap_a4c28ab95b498fa2bc4975dc2896eeb34_cgraph" id="classSawyer_1_1Container_1_1AddressMap_a4c28ab95b498fa2bc4975dc2896eeb34_cgraph">
<area shape="rect" title="Constraint: address lower and upper bounds." alt="" coords="5,13,144,54"/>
<area shape="rect" href="classSawyer_1_1Container_1_1AddressMapConstraints.html#a0e35e4c4083628449d94d1279c6bc7fd" title="Limit addresses." alt="" coords="192,5,355,61"/>
</map>
</div>

</div>
</div>
<a id="a832997ac9853c41280bd5c933084130f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a832997ac9853c41280bd5c933084130f">&#9670;&nbsp;</a></span>within() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt;const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a>&gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::within </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a>&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constraint: address lower and upper bounds. </p>
<p>Constrains matched addresses so they are all greater than or equal to <code>x</code> and less than or equal to <code>y</code>. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01208">1208</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l00329">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::within()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1AddressMap_a832997ac9853c41280bd5c933084130f_cgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1AddressMap_a832997ac9853c41280bd5c933084130f_cgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1AddressMap_a832997ac9853c41280bd5c933084130f_cgraph" id="classSawyer_1_1Container_1_1AddressMap_a832997ac9853c41280bd5c933084130f_cgraph">
<area shape="rect" title="Constraint: address lower and upper bounds." alt="" coords="5,13,144,54"/>
<area shape="rect" href="classSawyer_1_1Container_1_1AddressMapConstraints.html#a0e35e4c4083628449d94d1279c6bc7fd" title="Limit addresses." alt="" coords="192,5,355,61"/>
</map>
</div>

</div>
</div>
<a id="ab30e2f146fcfc37dc85a9bce2e48f1f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab30e2f146fcfc37dc85a9bce2e48f1f2">&#9670;&nbsp;</a></span>within() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt;<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a>&gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::within </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a>&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constraint: address lower and upper bounds. </p>
<p>Constrains matched addresses so they are all greater than or equal to <code>x</code> and less than or equal to <code>y</code>. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01211">1211</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l00329">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::within()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1AddressMap_ab30e2f146fcfc37dc85a9bce2e48f1f2_cgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1AddressMap_ab30e2f146fcfc37dc85a9bce2e48f1f2_cgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1AddressMap_ab30e2f146fcfc37dc85a9bce2e48f1f2_cgraph" id="classSawyer_1_1Container_1_1AddressMap_ab30e2f146fcfc37dc85a9bce2e48f1f2_cgraph">
<area shape="rect" title="Constraint: address lower and upper bounds." alt="" coords="5,13,144,54"/>
<area shape="rect" href="classSawyer_1_1Container_1_1AddressMapConstraints.html#a0e35e4c4083628449d94d1279c6bc7fd" title="Limit addresses." alt="" coords="192,5,355,61"/>
</map>
</div>

</div>
</div>
<a id="a30023638bbe0fdf14f6bf37eba178d84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30023638bbe0fdf14f6bf37eba178d84">&#9670;&nbsp;</a></span>baseSize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt;const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a>&gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::baseSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a>&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constraint: address lower and upper bounds. </p>
<p>Specifies lower and upper bounds. The upper bound is specified indirectly by a size. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01221">1221</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l00339">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::baseSize()</a>, and <a class="el" href="IntervalMap_8h_source.html#l00681">Sawyer::Container::IntervalMap&lt; Interval&lt; A &gt;, AddressSegment&lt; A, boost::uint8_t &gt;, AddressMapImpl::SegmentMergePolicy&lt; A, boost::uint8_t &gt; &gt;::size()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1AddressMap_a30023638bbe0fdf14f6bf37eba178d84_cgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1AddressMap_a30023638bbe0fdf14f6bf37eba178d84_cgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1AddressMap_a30023638bbe0fdf14f6bf37eba178d84_cgraph" id="classSawyer_1_1Container_1_1AddressMap_a30023638bbe0fdf14f6bf37eba178d84_cgraph">
<area shape="rect" title="Constraint: address lower and upper bounds." alt="" coords="5,63,163,105"/>
<area shape="rect" href="classSawyer_1_1Container_1_1AddressMapConstraints.html#ad16896935c25c7824c776254f8178855" title="Limit addresses." alt="" coords="257,5,419,61"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalMap.html#adbf9f66a08580ead37de8f0dd96d575e" title="Returns the number of values represented by this container." alt="" coords="211,85,465,185"/>
</map>
</div>

</div>
</div>
<a id="a4c60bbaa0927c122e3f3e7790b185f60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c60bbaa0927c122e3f3e7790b185f60">&#9670;&nbsp;</a></span>baseSize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt;<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a>&gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::baseSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a>&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constraint: address lower and upper bounds. </p>
<p>Specifies lower and upper bounds. The upper bound is specified indirectly by a size. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01224">1224</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l00339">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::baseSize()</a>, and <a class="el" href="IntervalMap_8h_source.html#l00681">Sawyer::Container::IntervalMap&lt; Interval&lt; A &gt;, AddressSegment&lt; A, boost::uint8_t &gt;, AddressMapImpl::SegmentMergePolicy&lt; A, boost::uint8_t &gt; &gt;::size()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1AddressMap_a4c60bbaa0927c122e3f3e7790b185f60_cgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1AddressMap_a4c60bbaa0927c122e3f3e7790b185f60_cgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1AddressMap_a4c60bbaa0927c122e3f3e7790b185f60_cgraph" id="classSawyer_1_1Container_1_1AddressMap_a4c60bbaa0927c122e3f3e7790b185f60_cgraph">
<area shape="rect" title="Constraint: address lower and upper bounds." alt="" coords="5,63,163,105"/>
<area shape="rect" href="classSawyer_1_1Container_1_1AddressMapConstraints.html#ad16896935c25c7824c776254f8178855" title="Limit addresses." alt="" coords="257,5,419,61"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalMap.html#adbf9f66a08580ead37de8f0dd96d575e" title="Returns the number of values represented by this container." alt="" coords="211,85,465,185"/>
</map>
</div>

</div>
</div>
<a id="a056e03e61ac70958e5396cc39ef8190c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a056e03e61ac70958e5396cc39ef8190c">&#9670;&nbsp;</a></span>after() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt;const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a>&gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::after </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constraint: address lower bound. </p>
<p>Constrains matched addresses so that they are all greater than <code>x</code>. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01234">1234</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l00344">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::after()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1AddressMap_a056e03e61ac70958e5396cc39ef8190c_cgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1AddressMap_a056e03e61ac70958e5396cc39ef8190c_cgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1AddressMap_a056e03e61ac70958e5396cc39ef8190c_cgraph" id="classSawyer_1_1Container_1_1AddressMap_a056e03e61ac70958e5396cc39ef8190c_cgraph">
<area shape="rect" title="Constraint: address lower bound." alt="" coords="5,13,144,54"/>
<area shape="rect" href="classSawyer_1_1Container_1_1AddressMapConstraints.html#a73c20d1438a7ec1760e7977908bb81eb" title="Limit addresses." alt="" coords="192,5,355,61"/>
</map>
</div>

</div>
</div>
<a id="aa2171cf51701fea042950e2dcf8b527d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2171cf51701fea042950e2dcf8b527d">&#9670;&nbsp;</a></span>after() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt;<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a>&gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::after </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constraint: address lower bound. </p>
<p>Constrains matched addresses so that they are all greater than <code>x</code>. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01237">1237</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l00344">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::after()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1AddressMap_aa2171cf51701fea042950e2dcf8b527d_cgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1AddressMap_aa2171cf51701fea042950e2dcf8b527d_cgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1AddressMap_aa2171cf51701fea042950e2dcf8b527d_cgraph" id="classSawyer_1_1Container_1_1AddressMap_aa2171cf51701fea042950e2dcf8b527d_cgraph">
<area shape="rect" title="Constraint: address lower bound." alt="" coords="5,13,144,54"/>
<area shape="rect" href="classSawyer_1_1Container_1_1AddressMapConstraints.html#a73c20d1438a7ec1760e7977908bb81eb" title="Limit addresses." alt="" coords="192,5,355,61"/>
</map>
</div>

</div>
</div>
<a id="ad8562670e30a85accd75e7dc70e02cbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8562670e30a85accd75e7dc70e02cbc">&#9670;&nbsp;</a></span>before() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt;const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a>&gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::before </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constraint: address upper bound. </p>
<p>Constrains matched addresses so that they are all less than <code>x</code>. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01247">1247</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l00349">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::before()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1AddressMap_ad8562670e30a85accd75e7dc70e02cbc_cgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1AddressMap_ad8562670e30a85accd75e7dc70e02cbc_cgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1AddressMap_ad8562670e30a85accd75e7dc70e02cbc_cgraph" id="classSawyer_1_1Container_1_1AddressMap_ad8562670e30a85accd75e7dc70e02cbc_cgraph">
<area shape="rect" title="Constraint: address upper bound." alt="" coords="5,13,144,54"/>
<area shape="rect" href="classSawyer_1_1Container_1_1AddressMapConstraints.html#a631a9d37d2f3a6c3f2302646bb29ebaa" title="Limit addreses." alt="" coords="192,5,355,61"/>
</map>
</div>

</div>
</div>
<a id="a27c01c5f99e9ad1561d7de45ea0e53ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27c01c5f99e9ad1561d7de45ea0e53ab">&#9670;&nbsp;</a></span>before() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt;<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a>&gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::before </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constraint: address upper bound. </p>
<p>Constrains matched addresses so that they are all less than <code>x</code>. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01250">1250</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l00349">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::before()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1AddressMap_a27c01c5f99e9ad1561d7de45ea0e53ab_cgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1AddressMap_a27c01c5f99e9ad1561d7de45ea0e53ab_cgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1AddressMap_a27c01c5f99e9ad1561d7de45ea0e53ab_cgraph" id="classSawyer_1_1Container_1_1AddressMap_a27c01c5f99e9ad1561d7de45ea0e53ab_cgraph">
<area shape="rect" title="Constraint: address upper bound." alt="" coords="5,13,144,54"/>
<area shape="rect" href="classSawyer_1_1Container_1_1AddressMapConstraints.html#a631a9d37d2f3a6c3f2302646bb29ebaa" title="Limit addreses." alt="" coords="192,5,355,61"/>
</map>
</div>

</div>
</div>
<a id="a36a09beef2d2b0d0aededc581a764ab3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36a09beef2d2b0d0aededc581a764ab3">&#9670;&nbsp;</a></span>singleSegment() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt;const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a>&gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::singleSegment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constraint: single segment. </p>
<p>Constrains matched addresses so that they all come from the same segment. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01260">1260</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l00354">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::singleSegment()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1AddressMap_a36a09beef2d2b0d0aededc581a764ab3_cgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1AddressMap_a36a09beef2d2b0d0aededc581a764ab3_cgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1AddressMap_a36a09beef2d2b0d0aededc581a764ab3_cgraph" id="classSawyer_1_1Container_1_1AddressMap_a36a09beef2d2b0d0aededc581a764ab3_cgraph">
<area shape="rect" title="Constraint: single segment." alt="" coords="5,13,195,54"/>
<area shape="rect" href="classSawyer_1_1Container_1_1AddressMapConstraints.html#a6cf478b298b305dc88158f585914263d" title="Limit matching to single segment." alt="" coords="243,5,405,61"/>
</map>
</div>

</div>
</div>
<a id="a897fad779ffc4aa6b588645c4821e44f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a897fad779ffc4aa6b588645c4821e44f">&#9670;&nbsp;</a></span>singleSegment() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt;<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a>&gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::singleSegment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constraint: single segment. </p>
<p>Constrains matched addresses so that they all come from the same segment. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01263">1263</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l00354">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::singleSegment()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1AddressMap_a897fad779ffc4aa6b588645c4821e44f_cgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1AddressMap_a897fad779ffc4aa6b588645c4821e44f_cgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1AddressMap_a897fad779ffc4aa6b588645c4821e44f_cgraph" id="classSawyer_1_1Container_1_1AddressMap_a897fad779ffc4aa6b588645c4821e44f_cgraph">
<area shape="rect" title="Constraint: single segment." alt="" coords="5,13,195,54"/>
<area shape="rect" href="classSawyer_1_1Container_1_1AddressMapConstraints.html#a6cf478b298b305dc88158f585914263d" title="Limit matching to single segment." alt="" coords="243,5,405,61"/>
</map>
</div>

</div>
</div>
<a id="a8c1698459053221a112841a23ea001dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c1698459053221a112841a23ea001dd">&#9670;&nbsp;</a></span>segmentPredicate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt;const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a>&gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::segmentPredicate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1Container_1_1SegmentPredicate.html">SegmentPredicate</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a>, <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#aa7a7317b6be4502317ab4357b5989660">Value</a> &gt; *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constraint: arbitrary segment constraint. </p>
<p>Constraints matched addresses to those for which the chain of segment predicates return true. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01273">1273</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l00361">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::segmentPredicate()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1AddressMap_a8c1698459053221a112841a23ea001dd_cgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1AddressMap_a8c1698459053221a112841a23ea001dd_cgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1AddressMap_a8c1698459053221a112841a23ea001dd_cgraph" id="classSawyer_1_1Container_1_1AddressMap_a8c1698459053221a112841a23ea001dd_cgraph">
<area shape="rect" title="Constraint: arbitrary segment constraint." alt="" coords="5,13,213,54"/>
<area shape="rect" href="classSawyer_1_1Container_1_1AddressMapConstraints.html#a6e5f99800abf7adc8377339835cc8fb0" title="Limit segments." alt="" coords="261,5,424,61"/>
</map>
</div>

</div>
</div>
<a id="afc6e65b9c935bd94e9e0987fcfd00ddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc6e65b9c935bd94e9e0987fcfd00ddb">&#9670;&nbsp;</a></span>segmentPredicate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt;<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a>&gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::segmentPredicate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1Container_1_1SegmentPredicate.html">SegmentPredicate</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a>, <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#aa7a7317b6be4502317ab4357b5989660">Value</a> &gt; *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constraint: arbitrary segment constraint. </p>
<p>Constraints matched addresses to those for which the chain of segment predicates return true. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01276">1276</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l00361">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::segmentPredicate()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1AddressMap_afc6e65b9c935bd94e9e0987fcfd00ddb_cgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1AddressMap_afc6e65b9c935bd94e9e0987fcfd00ddb_cgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1AddressMap_afc6e65b9c935bd94e9e0987fcfd00ddb_cgraph" id="classSawyer_1_1Container_1_1AddressMap_afc6e65b9c935bd94e9e0987fcfd00ddb_cgraph">
<area shape="rect" title="Constraint: arbitrary segment constraint." alt="" coords="5,13,213,54"/>
<area shape="rect" href="classSawyer_1_1Container_1_1AddressMapConstraints.html#a6e5f99800abf7adc8377339835cc8fb0" title="Limit segments." alt="" coords="261,5,424,61"/>
</map>
</div>

</div>
</div>
<a id="ae9e6ba6b08b23a5612567199c0b2de32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9e6ba6b08b23a5612567199c0b2de32">&#9670;&nbsp;</a></span>any() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt;const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a>&gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::any </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constraint: matches anything. </p>
<p>The null constraint matches any mapped address. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01286">1286</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

</div>
</div>
<a id="a3e1b4ea62372c9ee4ddcb4583f0bcf67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e1b4ea62372c9ee4ddcb4583f0bcf67">&#9670;&nbsp;</a></span>any() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt;<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a>&gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::any </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constraint: matches anything. </p>
<p>The null constraint matches any mapped address. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01289">1289</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

</div>
</div>
<a id="ac6151ac162e90dec4698bee00f484ea8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6151ac162e90dec4698bee00f484ea8">&#9670;&nbsp;</a></span>none() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt;const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a>&gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::none </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constraint: matches nothing. </p>
<p>Constrains addresses so that none of them can match. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01299">1299</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l00275">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::none()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1AddressMap_ac6151ac162e90dec4698bee00f484ea8_cgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1AddressMap_ac6151ac162e90dec4698bee00f484ea8_cgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1AddressMap_ac6151ac162e90dec4698bee00f484ea8_cgraph" id="classSawyer_1_1Container_1_1AddressMap_ac6151ac162e90dec4698bee00f484ea8_cgraph">
<area shape="rect" title="Constraint: matches nothing." alt="" coords="5,5,144,47"/>
<area shape="rect" href="classSawyer_1_1Container_1_1AddressMapConstraints.html#acab0f249f1a6f09f06a6caf8ea1ee32f" title="Constraints that match nothing." alt="" coords="192,5,391,47"/>
</map>
</div>

</div>
</div>
<a id="afe729f3f34a61e283e79716850400e95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe729f3f34a61e283e79716850400e95">&#9670;&nbsp;</a></span>none() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt;<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a>&gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::none </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constraint: matches nothing. </p>
<p>Constrains addresses so that none of them can match. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01302">1302</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l00275">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::none()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1AddressMap_afe729f3f34a61e283e79716850400e95_cgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1AddressMap_afe729f3f34a61e283e79716850400e95_cgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1AddressMap_afe729f3f34a61e283e79716850400e95_cgraph" id="classSawyer_1_1Container_1_1AddressMap_afe729f3f34a61e283e79716850400e95_cgraph">
<area shape="rect" title="Constraint: matches nothing." alt="" coords="5,5,144,47"/>
<area shape="rect" href="classSawyer_1_1Container_1_1AddressMapConstraints.html#acab0f249f1a6f09f06a6caf8ea1ee32f" title="Constraints that match nothing." alt="" coords="192,5,391,47"/>
</map>
</div>

</div>
</div>
<a id="a300a26b869a20b7c773f75f7c3d75e04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a300a26b869a20b7c773f75f7c3d75e04">&#9670;&nbsp;</a></span>checkConsistency()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::checkConsistency </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check map consistency. </p>
<p>Performs the following consistency checks and throws an <code>std::runtime_error</code> if something is wrong.</p>
<ul>
<li>A segment should not have a null buffer pointer.</li>
</ul>
<ul>
<li>Checks that the buffers of the map are appropriate sizes for the address interval in which they're mapped. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01314">1314</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressSegment_8h_source.html#l00141">Sawyer::Container::AddressSegment&lt; A, T &gt;::buffer()</a>, <a class="el" href="Interval_8h_source.html#l00213">Sawyer::Container::Interval&lt; T &gt;::greatest()</a>, <a class="el" href="Sawyer_2Map_8h_source.html#l00098">Sawyer::Container::Map&lt; K, T, Cmp, Alloc &gt;::Node::key()</a>, <a class="el" href="Interval_8h_source.html#l00207">Sawyer::Container::Interval&lt; T &gt;::least()</a>, <a class="el" href="AddressMap_8h_source.html#l01394">Sawyer::Container::AddressMap&lt; A, T &gt;::nodes()</a>, <a class="el" href="AddressSegment_8h_source.html#l00150">Sawyer::Container::AddressSegment&lt; A, T &gt;::offset()</a>, <a class="el" href="Interval_8h_source.html#l00279">Sawyer::Container::Interval&lt; T &gt;::size()</a>, and <a class="el" href="Sawyer_2Map_8h_source.html#l00105">Sawyer::Container::Map&lt; K, T, Cmp, Alloc &gt;::Node::value()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AddressMap_8h_source.html#l01690">Sawyer::Container::AddressMap&lt; A, T &gt;::read()</a>, and <a class="el" href="AddressMap_8h_source.html#l01751">Sawyer::Container::AddressMap&lt; A, T &gt;::write()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1AddressMap_a300a26b869a20b7c773f75f7c3d75e04_cgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1AddressMap_a300a26b869a20b7c773f75f7c3d75e04_cgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1AddressMap_a300a26b869a20b7c773f75f7c3d75e04_cgraph" id="classSawyer_1_1Container_1_1AddressMap_a300a26b869a20b7c773f75f7c3d75e04_cgraph">
<area shape="rect" title="Check map consistency." alt="" coords="5,235,216,276"/>
<area shape="rect" href="classSawyer_1_1Container_1_1AddressSegment.html#acd64963667c58e506d31bb67f3fd0df0" title="Property: buffer." alt="" coords="264,5,427,47"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Interval.html#a0c203b5387ef72aa3bcf8815ec8b7c16" title="Returns upper limit." alt="" coords="276,71,415,112"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Map_1_1Node.html#a3a6bfd720946fa7459f32e07a5d6f8f1" title="Key part of key/value node." alt="" coords="276,136,415,177"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Interval.html#abb62f08552ec4762be55510d97e7a233" title="Returns lower limit." alt="" coords="276,201,415,243"/>
<area shape="rect" href="classSawyer_1_1Container_1_1AddressMap.html#a000ced173d57eb4990dea1b45f0339e0" title="Iterator range for nodes." alt="" coords="276,267,415,308"/>
<area shape="rect" href="classSawyer_1_1Container_1_1AddressSegment.html#a970398df59bd3f5b326d072185afad23" title="Property: buffer offset." alt="" coords="264,332,427,373"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Interval.html#a75d8ca4e63b1180f6d2194a0ec79440d" title="Size of interval." alt="" coords="276,397,415,439"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Map_1_1Node.html#aa7eca3d931f2ca3a2bc77ef7011afe00" title="Value part of key/value node." alt="" coords="276,463,415,504"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1AddressMap_a300a26b869a20b7c773f75f7c3d75e04_icgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1AddressMap_a300a26b869a20b7c773f75f7c3d75e04_icgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1AddressMap_a300a26b869a20b7c773f75f7c3d75e04_icgraph" id="classSawyer_1_1Container_1_1AddressMap_a300a26b869a20b7c773f75f7c3d75e04_icgraph">
<area shape="rect" title="Check map consistency." alt="" coords="192,39,403,80"/>
<area shape="rect" href="classSawyer_1_1Container_1_1AddressMap.html#ae17e760e87b8cbeb207310f6f4dc8b20" title="Reads data into the supplied buffer." alt="" coords="5,5,144,47"/>
<area shape="rect" href="classSawyer_1_1Container_1_1AddressMap.html#aafc28dc1c26b66b2142eefa1bf13f074" title="Writes data from the supplied buffer." alt="" coords="5,71,144,112"/>
</map>
</div>

</div>
</div>
<a id="a78c1ef82354f141b3961d957e8728158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78c1ef82354f141b3961d957e8728158">&#9670;&nbsp;</a></span>nSegments()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::nSegments </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of segments contained in the map. </p>
<p>Multiple segments may be pointing to the same underlying buffer, and the number of segments is not necessarily the same as the net number of segments inserted and erased. For instance, if a segment is inserted for addresses [0,99] and then a different segment is inserted at [50,59], the map will contain three segments at addresses [0,49], [50,59], and [60,99], although the first and third segment point into different parts of the same buffer. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01339">1339</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="IntervalMap_8h_source.html#l00673">Sawyer::Container::IntervalMap&lt; Interval&lt; A &gt;, AddressSegment&lt; A, boost::uint8_t &gt;, AddressMapImpl::SegmentMergePolicy&lt; A, boost::uint8_t &gt; &gt;::nIntervals()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1AddressMap_a78c1ef82354f141b3961d957e8728158_cgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1AddressMap_a78c1ef82354f141b3961d957e8728158_cgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1AddressMap_a78c1ef82354f141b3961d957e8728158_cgraph" id="classSawyer_1_1Container_1_1AddressMap_a78c1ef82354f141b3961d957e8728158_cgraph">
<area shape="rect" title="Number of segments contained in the map." alt="" coords="5,35,175,76"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalMap.html#a017216edaa9c3064857c75fc63c07217" title="Number of nodes in the container." alt="" coords="223,5,477,105"/>
</map>
</div>

</div>
</div>
<a id="a401b8b33966dcbdb4dbe2b9e7ba0402a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a401b8b33966dcbdb4dbe2b9e7ba0402a">&#9670;&nbsp;</a></span>segments() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::iterator_range&lt;<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a9f7204596756341c0ea7eeadc5d38262">SegmentIterator</a>&gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::segments </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterator range for all segments. </p>
<p>This is just an alias for the <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#afe92a3a1fed8440a506b3cde7891a665">values</a> method defined in the super class. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01346">1346</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="IntervalMap_8h_source.html#l00299">Sawyer::Container::IntervalMap&lt; Interval&lt; A &gt;, AddressSegment&lt; A, boost::uint8_t &gt;, AddressMapImpl::SegmentMergePolicy&lt; A, boost::uint8_t &gt; &gt;::values()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1AddressMap_a401b8b33966dcbdb4dbe2b9e7ba0402a_cgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1AddressMap_a401b8b33966dcbdb4dbe2b9e7ba0402a_cgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1AddressMap_a401b8b33966dcbdb4dbe2b9e7ba0402a_cgraph" id="classSawyer_1_1Container_1_1AddressMap_a401b8b33966dcbdb4dbe2b9e7ba0402a_cgraph">
<area shape="rect" title="Iterator range for all segments." alt="" coords="5,35,165,76"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalMap.html#afe92a3a1fed8440a506b3cde7891a665" title="Iterators for traversing values." alt="" coords="213,5,468,105"/>
</map>
</div>

</div>
</div>
<a id="a157bc462f7ab4b9c94b239c15ac99c8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a157bc462f7ab4b9c94b239c15ac99c8e">&#9670;&nbsp;</a></span>segments() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::iterator_range&lt;<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#aa852a793027a1c74c097147546910f47">ConstSegmentIterator</a>&gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::segments </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterator range for all segments. </p>
<p>This is just an alias for the <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#afe92a3a1fed8440a506b3cde7891a665">values</a> method defined in the super class. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01347">1347</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="IntervalMap_8h_source.html#l00299">Sawyer::Container::IntervalMap&lt; Interval&lt; A &gt;, AddressSegment&lt; A, boost::uint8_t &gt;, AddressMapImpl::SegmentMergePolicy&lt; A, boost::uint8_t &gt; &gt;::values()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1AddressMap_a157bc462f7ab4b9c94b239c15ac99c8e_cgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1AddressMap_a157bc462f7ab4b9c94b239c15ac99c8e_cgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1AddressMap_a157bc462f7ab4b9c94b239c15ac99c8e_cgraph" id="classSawyer_1_1Container_1_1AddressMap_a157bc462f7ab4b9c94b239c15ac99c8e_cgraph">
<area shape="rect" title="Iterator range for all segments." alt="" coords="5,35,165,76"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalMap.html#afe92a3a1fed8440a506b3cde7891a665" title="Iterators for traversing values." alt="" coords="213,5,468,105"/>
</map>
</div>

</div>
</div>
<a id="a266b1cbad20d21bfd8a88e51d1a51196"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a266b1cbad20d21bfd8a88e51d1a51196">&#9670;&nbsp;</a></span>segments() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::iterator_range&lt;<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#aa852a793027a1c74c097147546910f47">ConstSegmentIterator</a>&gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::segments </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a>&lt; A, T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Segments that overlap with constraints. </p>
<p>Returns an iterator range for the first longest sequence of segments that all at least partly satisfy the specified constraints. Constraints are always matched at the address level and the return value consists of those segments that contain at least one matched address. Constraints normally match contiguous addresses, and therefore the returned list will be segments that are contiguous. Disabling the contiguous constraint with the <code>MATCH_NONCONTIGUOUS</code> flag relaxes the requirement that addresses be contiguous, although it still enforces that the matched interval contains only addresses that satisfy the constraints or addresses that are not mapped.</p>
<p>The following example finds the first sequence of one or more segments having "IAT" as a substring in their name and returns the longest sequence at that position. The sequence is then used to remove execute permission from each segment.</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="classSawyer_1_1Container_1_1AddressMap.html#a30140763fdfb3c3c12e8fd6a1dc22ea9">AddressMap&lt;Address,Value&gt;::Segment</a> <a class="code" href="classSawyer_1_1Container_1_1AddressMap.html#a30140763fdfb3c3c12e8fd6a1dc22ea9">Segment</a>;</div>
<div class="line">BOOST_FOREACH (<a class="code" href="classSawyer_1_1Container_1_1AddressMap.html#a30140763fdfb3c3c12e8fd6a1dc22ea9">Segment</a> &amp;segment, map.substr(<span class="stringliteral">&quot;IAT&quot;</span>).segments(MATCH_NONCONTIGUOUS))</div>
<div class="line">    segment.accessibility(segment.accessibility() &amp; ~EXECUTABLE);</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01370">1370</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

</div>
</div>
<a id="ab320e01d3e8afe0741eb1dff8acd0037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab320e01d3e8afe0741eb1dff8acd0037">&#9670;&nbsp;</a></span>segments() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::iterator_range&lt;<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a9f7204596756341c0ea7eeadc5d38262">SegmentIterator</a>&gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::segments </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a>&lt; A, T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterator range for all segments. </p>
<p>This is just an alias for the <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#afe92a3a1fed8440a506b3cde7891a665">values</a> method defined in the super class. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01379">1379</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

</div>
</div>
<a id="a000ced173d57eb4990dea1b45f0339e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a000ced173d57eb4990dea1b45f0339e0">&#9670;&nbsp;</a></span>nodes() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::iterator_range&lt;<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#ac6954614b9b130d841261ad4d2644316">NodeIterator</a>&gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::nodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterator range for nodes. </p>
<p>This is just an alias for the <a class="el" href="classSawyer_1_1Container_1_1Graph.html#nodes">Vertices and Edges</a> method defined in the super class. See also the overloaded method of the same name that takes a constraint and thus returns only some nodes. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01394">1394</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="IntervalMap_8h_source.html#l00283">Sawyer::Container::IntervalMap&lt; I, T, Policy &gt;::nodes()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AddressMap_8h_source.html#l01314">Sawyer::Container::AddressMap&lt; A, T &gt;::checkConsistency()</a>, <a class="el" href="AddressMap_8h_source.html#l01513">Sawyer::Container::AddressMap&lt; A, T &gt;::findNode()</a>, and <a class="el" href="AddressMap_8h_source.html#l01751">Sawyer::Container::AddressMap&lt; A, T &gt;::write()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1AddressMap_a000ced173d57eb4990dea1b45f0339e0_cgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1AddressMap_a000ced173d57eb4990dea1b45f0339e0_cgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1AddressMap_a000ced173d57eb4990dea1b45f0339e0_cgraph" id="classSawyer_1_1Container_1_1AddressMap_a000ced173d57eb4990dea1b45f0339e0_cgraph">
<area shape="rect" title="Iterator range for nodes." alt="" coords="5,5,144,47"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalMap.html#a4bcd6255a35955db90ec2d0f939086e2" title="Iterators for traversing nodes." alt="" coords="192,5,331,47"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1AddressMap_a000ced173d57eb4990dea1b45f0339e0_icgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1AddressMap_a000ced173d57eb4990dea1b45f0339e0_icgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1AddressMap_a000ced173d57eb4990dea1b45f0339e0_icgraph" id="classSawyer_1_1Container_1_1AddressMap_a000ced173d57eb4990dea1b45f0339e0_icgraph">
<area shape="rect" title="Iterator range for nodes." alt="" coords="451,64,589,105"/>
<area shape="rect" href="classSawyer_1_1Container_1_1AddressMap.html#a300a26b869a20b7c773f75f7c3d75e04" title="Check map consistency." alt="" coords="192,5,403,47"/>
<area shape="rect" href="classSawyer_1_1Container_1_1AddressMap.html#aafc28dc1c26b66b2142eefa1bf13f074" title="Writes data from the supplied buffer." alt="" coords="5,35,144,76"/>
<area shape="rect" href="classSawyer_1_1Container_1_1AddressMap.html#a11968c68b0efd523b24e371bff818613" title="Find node containing address." alt="" coords="220,123,375,164"/>
</map>
</div>

</div>
</div>
<a id="aaa5e931be5d01934109ca9a293551ad1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa5e931be5d01934109ca9a293551ad1">&#9670;&nbsp;</a></span>nodes() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::iterator_range&lt;<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#abf7a3b18db58eae98d782531b3f155b5">ConstNodeIterator</a>&gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::nodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterator range for nodes. </p>
<p>This is just an alias for the <a class="el" href="classSawyer_1_1Container_1_1Graph.html#nodes">Vertices and Edges</a> method defined in the super class. See also the overloaded method of the same name that takes a constraint and thus returns only some nodes. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01395">1395</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="IntervalMap_8h_source.html#l00283">Sawyer::Container::IntervalMap&lt; I, T, Policy &gt;::nodes()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1AddressMap_aaa5e931be5d01934109ca9a293551ad1_cgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1AddressMap_aaa5e931be5d01934109ca9a293551ad1_cgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1AddressMap_aaa5e931be5d01934109ca9a293551ad1_cgraph" id="classSawyer_1_1Container_1_1AddressMap_aaa5e931be5d01934109ca9a293551ad1_cgraph">
<area shape="rect" title="Iterator range for nodes." alt="" coords="5,5,144,47"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalMap.html#a4bcd6255a35955db90ec2d0f939086e2" title="Iterators for traversing nodes." alt="" coords="192,5,331,47"/>
</map>
</div>

</div>
</div>
<a id="a3ec685ae8bb406899f06706713fe0c93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ec685ae8bb406899f06706713fe0c93">&#9670;&nbsp;</a></span>nodes() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::iterator_range&lt;<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#abf7a3b18db58eae98d782531b3f155b5">ConstNodeIterator</a>&gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::nodes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a>&lt; A, T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Nodes that overlap with constraints. </p>
<p>Returns an iterator range for the first longest sequence of interval/segment nodes that all at least partly satisfy the specified constraints. Constraints are always matched at the address level and the return value consists of those nodes that contain at least one matched address. Constraints normally match contiguous addresses, and therefore the returned list will be nodes that are contiguous. Disabling the contiguous constraint with the <code>MATCH_NONCONTIGUOUS</code> flag relaxes the requirement that addresses be contiguous, although it still enforces that the matched interval contains only addresses that satisfy the constraints or addresses that are not mapped.</p>
<p>The following example finds the first sequence of one or more segments having addresses between 1000 and 2000 and "IAT" as part of their name and prints their address interval and name:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="classSawyer_1_1Container_1_1AddressMap.html#af2c9cf858603ecda80b73929ad8fcbc9">AddressMap&lt;Address,Value&gt;::Node</a> <a class="code" href="classSawyer_1_1Container_1_1AddressMap.html#af2c9cf858603ecda80b73929ad8fcbc9">Node</a>;</div>
<div class="line">BOOST_FOREACH (<span class="keyword">const</span> <a class="code" href="classSawyer_1_1Container_1_1AddressMap.html#af2c9cf858603ecda80b73929ad8fcbc9">Node</a> &amp;node, map.within(1000,2000).substr(<span class="stringliteral">&quot;IAT&quot;</span>).nodes(MATCH_NONCONTIGUOUS))</div>
<div class="line">    std::cout &lt;&lt;<span class="stringliteral">&quot;segment at &quot;</span> &lt;&lt;node.key() &lt;&lt;<span class="stringliteral">&quot; named &quot;</span> &lt;&lt;node.value().name() &lt;&lt;<span class="stringliteral">&quot;\n&quot;</span>;</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01418">1418</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

</div>
</div>
<a id="a33e1bdf9c9ed63d63e0ba3dfa82e967d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33e1bdf9c9ed63d63e0ba3dfa82e967d">&#9670;&nbsp;</a></span>nodes() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::iterator_range&lt;<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#ac6954614b9b130d841261ad4d2644316">NodeIterator</a>&gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::nodes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a>&lt; A, T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Nodes that overlap with constraints. </p>
<p>Returns an iterator range for the first longest sequence of interval/segment nodes that all at least partly satisfy the specified constraints. Constraints are always matched at the address level and the return value consists of those nodes that contain at least one matched address. Constraints normally match contiguous addresses, and therefore the returned list will be nodes that are contiguous. Disabling the contiguous constraint with the <code>MATCH_NONCONTIGUOUS</code> flag relaxes the requirement that addresses be contiguous, although it still enforces that the matched interval contains only addresses that satisfy the constraints or addresses that are not mapped.</p>
<p>The following example finds the first sequence of one or more segments having addresses between 1000 and 2000 and "IAT" as part of their name and prints their address interval and name:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="classSawyer_1_1Container_1_1AddressMap.html#af2c9cf858603ecda80b73929ad8fcbc9">AddressMap&lt;Address,Value&gt;::Node</a> <a class="code" href="classSawyer_1_1Container_1_1AddressMap.html#af2c9cf858603ecda80b73929ad8fcbc9">Node</a>;</div>
<div class="line">BOOST_FOREACH (<span class="keyword">const</span> <a class="code" href="classSawyer_1_1Container_1_1AddressMap.html#af2c9cf858603ecda80b73929ad8fcbc9">Node</a> &amp;node, map.within(1000,2000).substr(<span class="stringliteral">&quot;IAT&quot;</span>).nodes(MATCH_NONCONTIGUOUS))</div>
<div class="line">    std::cout &lt;&lt;<span class="stringliteral">&quot;segment at &quot;</span> &lt;&lt;node.key() &lt;&lt;<span class="stringliteral">&quot; named &quot;</span> &lt;&lt;node.value().name() &lt;&lt;<span class="stringliteral">&quot;\n&quot;</span>;</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01427">1427</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

</div>
</div>
<a id="a9c8520e0f4a70e6d310cce43b9e5d146"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c8520e0f4a70e6d310cce43b9e5d146">&#9670;&nbsp;</a></span>next()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt;<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a>&gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::next </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a>&lt; A, T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Minimum or maximum address that satisfies constraints. </p>
<p>This method returns the minimum or maximum address that satisfies the constraints, depending on whether the direction is forward or backward. It is named "next" because it is often used in loops that iterate over addresses. For instance, the following loop iterates over all readable addresses one at a time (there are more efficient ways to do this).</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> AddressMap&lt;Address,Value&gt; <a class="code" href="classSawyer_1_1Container_1_1IntervalMap.html#ae27b32aea90cdef93228cd5c978c00ef">Map</a>;</div>
<div class="line"><a class="code" href="classMap.html">Map</a> map = ...;</div>
<div class="line"><span class="keywordflow">for</span> (<a class="code" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> a=0; map.atOrAfter(a).<a class="code" href="classSawyer_1_1Container_1_1AddressMap.html#aa3d023864ebbf9ca4e6f009f36cbac61">require</a>(READABLE).<a class="code" href="classSawyer_1_1Container_1_1AddressMap.html#a9c8520e0f4a70e6d310cce43b9e5d146">next</a>().assignTo(a); ++a) {</div>
<div class="line">    ...</div>
<div class="line">    <span class="keywordflow">if</span> (a == map.hull().greatest())</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">}       </div>
</div><!-- fragment --><p>The conditional break at the end of the loop is to handle the case where <code>a</code> is the largest possible address, and incrementing it would result in an overflow back to a smaller address. The <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a4734abf74cda51aa6252ecfc38342e93">hull</a> method returns in constant time, but a slightly faster test (that is also more self-documenting) is:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (a == boost::integer_traits&lt;Address&gt;::const_max)</div>
<div class="line">    <span class="keywordflow">break</span>;</div>
</div><!-- fragment --><p>Backward iterating is similar:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> AddressMap&lt;Address,Value&gt; <a class="code" href="classSawyer_1_1Container_1_1IntervalMap.html#ae27b32aea90cdef93228cd5c978c00ef">Map</a>;</div>
<div class="line"><a class="code" href="classMap.html">Map</a> map = ...;</div>
<div class="line"><span class="keywordflow">for</span> (<a class="code" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> a=map.hull().greatest(); map.atOrBefore(a).require(READABLE).next(MATCH_BACKWARD).assignTo(a); --a) {</div>
<div class="line">    ...</div>
<div class="line">    <span class="keywordflow">if</span> (a == map.hull().least())</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">}</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01474">1474</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l00296">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::limit()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AddressMap_8h_source.html#l01504">Sawyer::Container::AddressMap&lt; A, T &gt;::exists()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1AddressMap_a9c8520e0f4a70e6d310cce43b9e5d146_cgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1AddressMap_a9c8520e0f4a70e6d310cce43b9e5d146_cgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1AddressMap_a9c8520e0f4a70e6d310cce43b9e5d146_cgraph" id="classSawyer_1_1Container_1_1AddressMap_a9c8520e0f4a70e6d310cce43b9e5d146_cgraph">
<area shape="rect" title="Minimum or maximum address that satisfies constraints." alt="" coords="5,13,144,54"/>
<area shape="rect" href="classSawyer_1_1Container_1_1AddressMapConstraints.html#a1e7b229039bfde68032769c1fba95a5e" title="Limit matching length." alt="" coords="192,5,355,61"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1AddressMap_a9c8520e0f4a70e6d310cce43b9e5d146_icgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1AddressMap_a9c8520e0f4a70e6d310cce43b9e5d146_icgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1AddressMap_a9c8520e0f4a70e6d310cce43b9e5d146_icgraph" id="classSawyer_1_1Container_1_1AddressMap_a9c8520e0f4a70e6d310cce43b9e5d146_icgraph">
<area shape="rect" title="Minimum or maximum address that satisfies constraints." alt="" coords="192,5,331,47"/>
<area shape="rect" href="classSawyer_1_1Container_1_1AddressMap.html#adb9a20f07deebeaacfeb58846102b2df" title="Determines if an address exists with the specified constraints." alt="" coords="5,5,144,47"/>
</map>
</div>

</div>
</div>
<a id="a1dbd7779c82f1cc7bdb4e0354b253b5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dbd7779c82f1cc7bdb4e0354b253b5d">&#9670;&nbsp;</a></span>available()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1Interval.html">Sawyer::Container::Interval</a>&lt;<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a>&gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::available </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a>&lt; A, T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adress interval that satisfies constraints. </p>
<p>Returns the lowest or highest (depending on direction) largest address interval that satisfies the specified constraints. The interval can be contiguous (the default), or it may contain unmapped addresses. In any case, all mapped addresses in the returned interval satisfy the constraints. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01488">1488</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

</div>
</div>
<a id="adb9a20f07deebeaacfeb58846102b2df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb9a20f07deebeaacfeb58846102b2df">&#9670;&nbsp;</a></span>exists()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::exists </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a>&lt; A, T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if an address exists with the specified constraints. </p>
<p>Checking for existence is just a wrapper around next. For instance, these two statements both check whether the address 1000 exists and has execute permission:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (map.at(1000).require(EXECUTABLE).<a class="code" href="classMap.html#a909fe3c1283566d250b70116c2be86a8">exists</a>()) ...</div>
<div class="line">if (map.at(1000).require(EXECUTABLE).next()) ...</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01504">1504</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l01474">Sawyer::Container::AddressMap&lt; A, T &gt;::next()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1AddressMap_adb9a20f07deebeaacfeb58846102b2df_cgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1AddressMap_adb9a20f07deebeaacfeb58846102b2df_cgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1AddressMap_adb9a20f07deebeaacfeb58846102b2df_cgraph" id="classSawyer_1_1Container_1_1AddressMap_adb9a20f07deebeaacfeb58846102b2df_cgraph">
<area shape="rect" title="Determines if an address exists with the specified constraints." alt="" coords="5,5,144,47"/>
<area shape="rect" href="classSawyer_1_1Container_1_1AddressMap.html#a9c8520e0f4a70e6d310cce43b9e5d146" title="Minimum or maximum address that satisfies constraints." alt="" coords="192,5,331,47"/>
</map>
</div>

</div>
</div>
<a id="a11968c68b0efd523b24e371bff818613"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11968c68b0efd523b24e371bff818613">&#9670;&nbsp;</a></span>findNode() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#abf7a3b18db58eae98d782531b3f155b5">ConstNodeIterator</a> <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::findNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a>&lt; A, T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find node containing address. </p>
<p>Finds the node that contains the first (or last, depending on direction) address that satisfies the constraints. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01513">1513</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l00296">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::limit()</a>, and <a class="el" href="AddressMap_8h_source.html#l01394">Sawyer::Container::AddressMap&lt; A, T &gt;::nodes()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1AddressMap_a11968c68b0efd523b24e371bff818613_cgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1AddressMap_a11968c68b0efd523b24e371bff818613_cgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1AddressMap_a11968c68b0efd523b24e371bff818613_cgraph" id="classSawyer_1_1Container_1_1AddressMap_a11968c68b0efd523b24e371bff818613_cgraph">
<area shape="rect" title="Find node containing address." alt="" coords="5,50,160,91"/>
<area shape="rect" href="classSawyer_1_1Container_1_1AddressMapConstraints.html#a1e7b229039bfde68032769c1fba95a5e" title="Limit matching length." alt="" coords="208,5,371,61"/>
<area shape="rect" href="classSawyer_1_1Container_1_1AddressMap.html#a000ced173d57eb4990dea1b45f0339e0" title="Iterator range for nodes." alt="" coords="220,86,359,127"/>
</map>
</div>

</div>
</div>
<a id="a164562fd38d476e8c0daf810075b399f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a164562fd38d476e8c0daf810075b399f">&#9670;&nbsp;</a></span>findNode() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#ac6954614b9b130d841261ad4d2644316">NodeIterator</a> <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::findNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a>&lt; A, T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find node containing address. </p>
<p>Finds the node that contains the first (or last, depending on direction) address that satisfies the constraints. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01516">1516</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l00296">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::limit()</a>, and <a class="el" href="AddressMap_8h_source.html#l01394">Sawyer::Container::AddressMap&lt; A, T &gt;::nodes()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1AddressMap_a164562fd38d476e8c0daf810075b399f_cgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1AddressMap_a164562fd38d476e8c0daf810075b399f_cgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1AddressMap_a164562fd38d476e8c0daf810075b399f_cgraph" id="classSawyer_1_1Container_1_1AddressMap_a164562fd38d476e8c0daf810075b399f_cgraph">
<area shape="rect" title="Find node containing address." alt="" coords="5,50,160,91"/>
<area shape="rect" href="classSawyer_1_1Container_1_1AddressMapConstraints.html#a1e7b229039bfde68032769c1fba95a5e" title="Limit matching length." alt="" coords="208,5,371,61"/>
<area shape="rect" href="classSawyer_1_1Container_1_1AddressMap.html#a000ced173d57eb4990dea1b45f0339e0" title="Iterator range for nodes." alt="" coords="220,86,359,127"/>
</map>
</div>

</div>
</div>
<a id="a216440bf5700dcf32389269e8e1ae1d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a216440bf5700dcf32389269e8e1ae1d9">&#9670;&nbsp;</a></span>unmapped()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1Interval.html">Sawyer::Container::Interval</a>&lt;<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a>&gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::unmapped </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a>&#160;</td>
          <td class="paramname"><em>boundary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find unmapped interval. </p>
<p>Searches for the lowest (or highest if direction is <code>MATCH_BACKWARD</code>) interval that is not mapped and returns its address and size. The returned interval will not contain addresses that are less than (or greater than) than <code>boundary</code>. If no such unmapped intervals exist then the empty interval is returned.</p>
<p>This method does not use constraints since it searches for addresses that do not exist in the map. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01529">1529</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="IntervalMap_8h_source.html#l00546">Sawyer::Container::IntervalMap&lt; Interval&lt; A &gt;, AddressSegment&lt; A, boost::uint8_t &gt;, AddressMapImpl::SegmentMergePolicy&lt; A, boost::uint8_t &gt; &gt;::firstUnmapped()</a>, and <a class="el" href="IntervalMap_8h_source.html#l00564">Sawyer::Container::IntervalMap&lt; Interval&lt; A &gt;, AddressSegment&lt; A, boost::uint8_t &gt;, AddressMapImpl::SegmentMergePolicy&lt; A, boost::uint8_t &gt; &gt;::lastUnmapped()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AddressMap_8h_source.html#l01542">Sawyer::Container::AddressMap&lt; A, T &gt;::findFreeSpace()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1AddressMap_a216440bf5700dcf32389269e8e1ae1d9_cgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1AddressMap_a216440bf5700dcf32389269e8e1ae1d9_cgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1AddressMap_a216440bf5700dcf32389269e8e1ae1d9_cgraph" id="classSawyer_1_1Container_1_1AddressMap_a216440bf5700dcf32389269e8e1ae1d9_cgraph">
<area shape="rect" title="Find unmapped interval." alt="" coords="5,97,168,139"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalMap.html#a25feb127b25f2d5f7616003a010abdca" title="Find the first unmapped region." alt="" coords="216,5,471,105"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalMap.html#a53ebe1dc48e4f3ef5051c97fb8d44c07" title="Find the last unmapped region." alt="" coords="216,129,471,229"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1AddressMap_a216440bf5700dcf32389269e8e1ae1d9_icgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1AddressMap_a216440bf5700dcf32389269e8e1ae1d9_icgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1AddressMap_a216440bf5700dcf32389269e8e1ae1d9_icgraph" id="classSawyer_1_1Container_1_1AddressMap_a216440bf5700dcf32389269e8e1ae1d9_icgraph">
<area shape="rect" title="Find unmapped interval." alt="" coords="240,5,403,47"/>
<area shape="rect" href="classSawyer_1_1Container_1_1AddressMap.html#aa03abdaf7a123ec5526ee2aa589612a9" title="Find free space." alt="" coords="5,5,192,47"/>
</map>
</div>

</div>
</div>
<a id="aa03abdaf7a123ec5526ee2aa589612a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa03abdaf7a123ec5526ee2aa589612a9">&#9670;&nbsp;</a></span>findFreeSpace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt;<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a>&gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::findFreeSpace </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>alignment</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1Container_1_1Interval.html">Sawyer::Container::Interval</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> &gt;&#160;</td>
          <td class="paramname"><em>restriction</em> = <code><a class="el" href="classSawyer_1_1Container_1_1Interval.html">Sawyer::Container::Interval</a>&lt;<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a>&gt;::whole()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find free space. </p>
<p>Finds a suitable region of unmapped address space in which <code>nValues</code> values can be mapped. The return value is either an address where the values can be mapped, or nothing if no such unmapped region is available. The <code>restriction</code> can be used to restrict which addresses are considered. The return value will have the specified alignment and will be either the lowest or highest possible address depending on whether direction is forward or backward.</p>
<p>This method does not use constraints since it searches for addresses that do not exist in the map. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01542">1542</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="Interval_8h_source.html#l00213">Sawyer::Container::Interval&lt; T &gt;::greatest()</a>, <a class="el" href="Interval_8h_source.html#l00219">Sawyer::Container::Interval&lt; T &gt;::isEmpty()</a>, <a class="el" href="Interval_8h_source.html#l00207">Sawyer::Container::Interval&lt; T &gt;::least()</a>, <a class="el" href="Interval_8h_source.html#l00279">Sawyer::Container::Interval&lt; T &gt;::size()</a>, <a class="el" href="AddressMap_8h_source.html#l01529">Sawyer::Container::AddressMap&lt; A, T &gt;::unmapped()</a>, and <a class="el" href="Interval_8h_source.html#l00180">Sawyer::Container::Interval&lt; T &gt;::whole()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1AddressMap_aa03abdaf7a123ec5526ee2aa589612a9_cgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1AddressMap_aa03abdaf7a123ec5526ee2aa589612a9_cgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1AddressMap_aa03abdaf7a123ec5526ee2aa589612a9_cgraph" id="classSawyer_1_1Container_1_1AddressMap_aa03abdaf7a123ec5526ee2aa589612a9_cgraph">
<area shape="rect" title="Find free space." alt="" coords="5,169,192,211"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Interval.html#a0c203b5387ef72aa3bcf8815ec8b7c16" title="Returns upper limit." alt="" coords="252,5,391,47"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Interval.html#aab81e29f7ededeac6d008e6dfaa1bf19" title="True if interval is empty." alt="" coords="252,71,391,112"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Interval.html#abb62f08552ec4762be55510d97e7a233" title="Returns lower limit." alt="" coords="252,136,391,177"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Interval.html#a75d8ca4e63b1180f6d2194a0ec79440d" title="Size of interval." alt="" coords="252,201,391,243"/>
<area shape="rect" href="classSawyer_1_1Container_1_1AddressMap.html#a216440bf5700dcf32389269e8e1ae1d9" title="Find unmapped interval." alt="" coords="240,267,403,308"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Interval.html#afef17d3137598cbd8a997969657d746b" title="Construct an interval that covers the entire domain." alt="" coords="252,332,391,373"/>
</map>
</div>

</div>
</div>
<a id="a895d3400de898b3dd49a7bb7074dcf0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a895d3400de898b3dd49a7bb7074dcf0e">&#9670;&nbsp;</a></span>traverse() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<div class="memtemplate">
template&lt;typename Functor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::traverse </td>
          <td>(</td>
          <td class="paramtype">Functor &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a>&lt; A, T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invoke a function on each address interval. </p>
<p>The functor is invoked with the following arguments: the memory map and an interval. If the functor returns false then the traversal is terminated. To facilitate the use of function-local types for the functor without requiring the use of explicit template parameters, one may pass a subclass of <a class="el" href="classSawyer_1_1Container_1_1AddressMap_1_1Visitor.html">Visitor</a> as the functor.</p>
<p>This example shows one way to print the names of segments that overlap with a given interval:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> AddressMap&lt;unsigned, char&gt; <a class="code" href="classSawyer_1_1Container_1_1IntervalMap.html#ae27b32aea90cdef93228cd5c978c00ef">Map</a>;</div>
<div class="line"><span class="keyword">struct</span>: Visitor {</div>
<div class="line">    <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> <a class="code" href="classMap.html">Map</a> &amp;map, <span class="keyword">const</span> Interval&lt;unsigned&gt; &amp;interval) {</div>
<div class="line">        <span class="keyword">const</span> Map::Segment &amp;segment = map.at(interval.least()).findNode()-&gt;value();</div>
<div class="line">        std::cerr &lt;&lt;<span class="stringliteral">&quot;segment \&quot;&quot;</span> &lt;&lt;segment.name() &lt;&lt;<span class="stringliteral">&quot;\&quot;\n&quot;</span>;</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line">} visitor;</div>
<div class="line"><a class="code" href="classMap.html">Map</a> map = ...;</div>
<div class="line">Interval&lt;unsigned&gt; where = ...;</div>
<div class="line">map.within(where).traverse(visitor);</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01622">1622</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="Sawyer_2Map_8h_source.html#l00098">Sawyer::Container::Map&lt; K, T, Cmp, Alloc &gt;::Node::key()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1AddressMap_a895d3400de898b3dd49a7bb7074dcf0e_cgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1AddressMap_a895d3400de898b3dd49a7bb7074dcf0e_cgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1AddressMap_a895d3400de898b3dd49a7bb7074dcf0e_cgraph" id="classSawyer_1_1Container_1_1AddressMap_a895d3400de898b3dd49a7bb7074dcf0e_cgraph">
<area shape="rect" title="Invoke a function on each address interval." alt="" coords="5,5,156,47"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Map_1_1Node.html#a3a6bfd720946fa7459f32e07a5d6f8f1" title="Key part of key/value node." alt="" coords="204,5,343,47"/>
</map>
</div>

</div>
</div>
<a id="a0a8b6e632d09737c2ca035640af3d565"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a8b6e632d09737c2ca035640af3d565">&#9670;&nbsp;</a></span>traverse() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<div class="memtemplate">
template&lt;typename Functor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::traverse </td>
          <td>(</td>
          <td class="paramtype">Functor &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a>&lt; A, T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invoke a function on each address interval. </p>
<p>The functor is invoked with the following arguments: the memory map and an interval. If the functor returns false then the traversal is terminated. To facilitate the use of function-local types for the functor without requiring the use of explicit template parameters, one may pass a subclass of <a class="el" href="classSawyer_1_1Container_1_1AddressMap_1_1Visitor.html">Visitor</a> as the functor.</p>
<p>This example shows one way to print the names of segments that overlap with a given interval:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> AddressMap&lt;unsigned, char&gt; <a class="code" href="classSawyer_1_1Container_1_1IntervalMap.html#ae27b32aea90cdef93228cd5c978c00ef">Map</a>;</div>
<div class="line"><span class="keyword">struct</span>: Visitor {</div>
<div class="line">    <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> <a class="code" href="classMap.html">Map</a> &amp;map, <span class="keyword">const</span> Interval&lt;unsigned&gt; &amp;interval) {</div>
<div class="line">        <span class="keyword">const</span> Map::Segment &amp;segment = map.at(interval.least()).findNode()-&gt;value();</div>
<div class="line">        std::cerr &lt;&lt;<span class="stringliteral">&quot;segment \&quot;&quot;</span> &lt;&lt;segment.name() &lt;&lt;<span class="stringliteral">&quot;\&quot;\n&quot;</span>;</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line">} visitor;</div>
<div class="line"><a class="code" href="classMap.html">Map</a> map = ...;</div>
<div class="line">Interval&lt;unsigned&gt; where = ...;</div>
<div class="line">map.within(where).traverse(visitor);</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01633">1633</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="Sawyer_2Map_8h_source.html#l00098">Sawyer::Container::Map&lt; K, T, Cmp, Alloc &gt;::Node::key()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1AddressMap_a0a8b6e632d09737c2ca035640af3d565_cgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1AddressMap_a0a8b6e632d09737c2ca035640af3d565_cgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1AddressMap_a0a8b6e632d09737c2ca035640af3d565_cgraph" id="classSawyer_1_1Container_1_1AddressMap_a0a8b6e632d09737c2ca035640af3d565_cgraph">
<area shape="rect" title="Invoke a function on each address interval." alt="" coords="5,5,156,47"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Map_1_1Node.html#a3a6bfd720946fa7459f32e07a5d6f8f1" title="Key part of key/value node." alt="" coords="204,5,343,47"/>
</map>
</div>

</div>
</div>
<a id="a9bd627686043b35501fabb3b89e867a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bd627686043b35501fabb3b89e867a8">&#9670;&nbsp;</a></span>traverse() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::traverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1Container_1_1AddressMap_1_1Visitor.html">Visitor</a> &amp;&#160;</td>
          <td class="paramname"><em>visitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a>&lt; A, T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invoke a function on each address interval. </p>
<p>The functor is invoked with the following arguments: the memory map and an interval. If the functor returns false then the traversal is terminated. To facilitate the use of function-local types for the functor without requiring the use of explicit template parameters, one may pass a subclass of <a class="el" href="classSawyer_1_1Container_1_1AddressMap_1_1Visitor.html">Visitor</a> as the functor.</p>
<p>This example shows one way to print the names of segments that overlap with a given interval:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> AddressMap&lt;unsigned, char&gt; <a class="code" href="classSawyer_1_1Container_1_1IntervalMap.html#ae27b32aea90cdef93228cd5c978c00ef">Map</a>;</div>
<div class="line"><span class="keyword">struct</span>: Visitor {</div>
<div class="line">    <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> <a class="code" href="classMap.html">Map</a> &amp;map, <span class="keyword">const</span> Interval&lt;unsigned&gt; &amp;interval) {</div>
<div class="line">        <span class="keyword">const</span> Map::Segment &amp;segment = map.at(interval.least()).findNode()-&gt;value();</div>
<div class="line">        std::cerr &lt;&lt;<span class="stringliteral">&quot;segment \&quot;&quot;</span> &lt;&lt;segment.name() &lt;&lt;<span class="stringliteral">&quot;\&quot;\n&quot;</span>;</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line">} visitor;</div>
<div class="line"><a class="code" href="classMap.html">Map</a> map = ...;</div>
<div class="line">Interval&lt;unsigned&gt; where = ...;</div>
<div class="line">map.within(where).traverse(visitor);</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01643">1643</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

</div>
</div>
<a id="a7b9c7d3e990027e75a9dbe45e10841ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b9c7d3e990027e75a9dbe45e10841ac">&#9670;&nbsp;</a></span>traverse() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::traverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1Container_1_1AddressMap_1_1Visitor.html">Visitor</a> &amp;&#160;</td>
          <td class="paramname"><em>visitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a>&lt; A, T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invoke a function on each address interval. </p>
<p>The functor is invoked with the following arguments: the memory map and an interval. If the functor returns false then the traversal is terminated. To facilitate the use of function-local types for the functor without requiring the use of explicit template parameters, one may pass a subclass of <a class="el" href="classSawyer_1_1Container_1_1AddressMap_1_1Visitor.html">Visitor</a> as the functor.</p>
<p>This example shows one way to print the names of segments that overlap with a given interval:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> AddressMap&lt;unsigned, char&gt; <a class="code" href="classSawyer_1_1Container_1_1IntervalMap.html#ae27b32aea90cdef93228cd5c978c00ef">Map</a>;</div>
<div class="line"><span class="keyword">struct</span>: Visitor {</div>
<div class="line">    <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> <a class="code" href="classMap.html">Map</a> &amp;map, <span class="keyword">const</span> Interval&lt;unsigned&gt; &amp;interval) {</div>
<div class="line">        <span class="keyword">const</span> Map::Segment &amp;segment = map.at(interval.least()).findNode()-&gt;value();</div>
<div class="line">        std::cerr &lt;&lt;<span class="stringliteral">&quot;segment \&quot;&quot;</span> &lt;&lt;segment.name() &lt;&lt;<span class="stringliteral">&quot;\&quot;\n&quot;</span>;</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line">} visitor;</div>
<div class="line"><a class="code" href="classMap.html">Map</a> map = ...;</div>
<div class="line">Interval&lt;unsigned&gt; where = ...;</div>
<div class="line">map.within(where).traverse(visitor);</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01646">1646</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

</div>
</div>
<a id="ae17e760e87b8cbeb207310f6f4dc8b20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae17e760e87b8cbeb207310f6f4dc8b20">&#9670;&nbsp;</a></span>read() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1Interval.html">Sawyer::Container::Interval</a>&lt;<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a>&gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#aa7a7317b6be4502317ab4357b5989660">Value</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a>&lt; A, T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads data into the supplied buffer. </p>
<p>Reads data into an array or STL vector according to the specified constraints. If the array is a null pointer then no data is read or copied and the return value indicates what addresses would have been accessed. When the buffer is an STL vector the constraints are augmented by also limiting the number of items accessed; the caller must do that explicitly for arrays. The return value is the interval of addresses that were read.</p>
<p>The constraints are usually curried before the actual read call, as in this example that reads up to 10 values starting at some address and returns the number of values read:</p>
<div class="fragment"><div class="line"><a class="code" href="classSawyer_1_1Container_1_1AddressMap.html#aa7a7317b6be4502317ab4357b5989660">Value</a> buf[10];</div>
<div class="line"><span class="keywordtype">size_t</span> nRead = map.at(start).limit(10).read(buf).size();</div>
</div><!-- fragment --><p>The following loop reads and prints all the readable values from a memory map using a large buffer for efficiency:</p>
<div class="fragment"><div class="line">std::vector&lt;Value&gt; buf(1024);</div>
<div class="line"><span class="keywordflow">while</span> (Interval&lt;Address&gt; accessed = map.atOrAfter(a).read(buf)) {</div>
<div class="line">    a = accessed.least();</div>
<div class="line">    BOOST_FOREACH (<span class="keyword">const</span> <a class="code" href="classSawyer_1_1Container_1_1AddressMap.html#aa7a7317b6be4502317ab4357b5989660">Value</a> &amp;v, buf)</div>
<div class="line">        std::cout &lt;&lt;a++ &lt;&lt;<span class="stringliteral">&quot;: &quot;</span> &lt;&lt;v &lt;&lt;<span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">    <span class="keywordflow">if</span> (accessed.greatest()==map.hull().greatest())</div>
<div class="line">        <span class="keywordflow">break</span>; <span class="comment">// to handle case when a++ overflowed</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>Reading can also be performed backward, such as this example that reads up to ten values such that the last value read is at address 999. The buffer will always contain results in address order, with the first element of the buffer being the value that was read with the lowest address.</p>
<div class="fragment"><div class="line"><a class="code" href="classSawyer_1_1Container_1_1AddressMap.html#aa7a7317b6be4502317ab4357b5989660">Value</a> buf[10];</div>
<div class="line"><span class="keywordtype">size_t</span> nRead = map.at(999).limit(10).read(buf, MATCH_BACKWARD).size();</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01690">1690</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l01314">Sawyer::Container::AddressMap&lt; A, T &gt;::checkConsistency()</a>, <a class="el" href="Interval_8h_source.html#l00219">Sawyer::Container::Interval&lt; T &gt;::isEmpty()</a>, <a class="el" href="Sawyer_2Map_8h_source.html#l00098">Sawyer::Container::Map&lt; K, T, Cmp, Alloc &gt;::Node::key()</a>, <a class="el" href="Interval_8h_source.html#l00207">Sawyer::Container::Interval&lt; T &gt;::least()</a>, <a class="el" href="Interval_8h_source.html#l00279">Sawyer::Container::Interval&lt; T &gt;::size()</a>, and <a class="el" href="Sawyer_2Map_8h_source.html#l00105">Sawyer::Container::Map&lt; K, T, Cmp, Alloc &gt;::Node::value()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AddressMap_8h_source.html#l01713">Sawyer::Container::AddressMap&lt; A, T &gt;::read()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1AddressMap_ae17e760e87b8cbeb207310f6f4dc8b20_cgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1AddressMap_ae17e760e87b8cbeb207310f6f4dc8b20_cgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1AddressMap_ae17e760e87b8cbeb207310f6f4dc8b20_cgraph" id="classSawyer_1_1Container_1_1AddressMap_ae17e760e87b8cbeb207310f6f4dc8b20_cgraph">
<area shape="rect" title="Reads data into the supplied buffer." alt="" coords="5,141,144,183"/>
<area shape="rect" href="classSawyer_1_1Container_1_1AddressMap.html#a300a26b869a20b7c773f75f7c3d75e04" title="Check map consistency." alt="" coords="192,112,403,153"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Map_1_1Node.html#a3a6bfd720946fa7459f32e07a5d6f8f1" title="Key part of key/value node." alt="" coords="451,5,589,47"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Interval.html#abb62f08552ec4762be55510d97e7a233" title="Returns lower limit." alt="" coords="451,72,589,113"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Interval.html#a75d8ca4e63b1180f6d2194a0ec79440d" title="Size of interval." alt="" coords="451,140,589,181"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Map_1_1Node.html#aa7eca3d931f2ca3a2bc77ef7011afe00" title="Value part of key/value node." alt="" coords="451,211,589,252"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Interval.html#aab81e29f7ededeac6d008e6dfaa1bf19" title="True if interval is empty." alt="" coords="228,280,367,321"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1AddressMap_ae17e760e87b8cbeb207310f6f4dc8b20_icgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1AddressMap_ae17e760e87b8cbeb207310f6f4dc8b20_icgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1AddressMap_ae17e760e87b8cbeb207310f6f4dc8b20_icgraph" id="classSawyer_1_1Container_1_1AddressMap_ae17e760e87b8cbeb207310f6f4dc8b20_icgraph">
<area shape="rect" title="Reads data into the supplied buffer." alt="" coords="192,5,331,47"/>
<area shape="rect" href="classSawyer_1_1Container_1_1AddressMap.html#a9719e774896dcd76f6fc70442ce73d33" title="Reads data into the supplied buffer." alt="" coords="5,5,144,47"/>
</map>
</div>

</div>
</div>
<a id="a9719e774896dcd76f6fc70442ce73d33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9719e774896dcd76f6fc70442ce73d33">&#9670;&nbsp;</a></span>read() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1Interval.html">Sawyer::Container::Interval</a>&lt;<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a>&gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::read </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#aa7a7317b6be4502317ab4357b5989660">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a>&lt; A, T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads data into the supplied buffer. </p>
<p>Reads data into an array or STL vector according to the specified constraints. If the array is a null pointer then no data is read or copied and the return value indicates what addresses would have been accessed. When the buffer is an STL vector the constraints are augmented by also limiting the number of items accessed; the caller must do that explicitly for arrays. The return value is the interval of addresses that were read.</p>
<p>The constraints are usually curried before the actual read call, as in this example that reads up to 10 values starting at some address and returns the number of values read:</p>
<div class="fragment"><div class="line"><a class="code" href="classSawyer_1_1Container_1_1AddressMap.html#aa7a7317b6be4502317ab4357b5989660">Value</a> buf[10];</div>
<div class="line"><span class="keywordtype">size_t</span> nRead = map.at(start).limit(10).read(buf).size();</div>
</div><!-- fragment --><p>The following loop reads and prints all the readable values from a memory map using a large buffer for efficiency:</p>
<div class="fragment"><div class="line">std::vector&lt;Value&gt; buf(1024);</div>
<div class="line"><span class="keywordflow">while</span> (Interval&lt;Address&gt; accessed = map.atOrAfter(a).read(buf)) {</div>
<div class="line">    a = accessed.least();</div>
<div class="line">    BOOST_FOREACH (<span class="keyword">const</span> <a class="code" href="classSawyer_1_1Container_1_1AddressMap.html#aa7a7317b6be4502317ab4357b5989660">Value</a> &amp;v, buf)</div>
<div class="line">        std::cout &lt;&lt;a++ &lt;&lt;<span class="stringliteral">&quot;: &quot;</span> &lt;&lt;v &lt;&lt;<span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">    <span class="keywordflow">if</span> (accessed.greatest()==map.hull().greatest())</div>
<div class="line">        <span class="keywordflow">break</span>; <span class="comment">// to handle case when a++ overflowed</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>Reading can also be performed backward, such as this example that reads up to ten values such that the last value read is at address 999. The buffer will always contain results in address order, with the first element of the buffer being the value that was read with the lowest address.</p>
<div class="fragment"><div class="line"><a class="code" href="classSawyer_1_1Container_1_1AddressMap.html#aa7a7317b6be4502317ab4357b5989660">Value</a> buf[10];</div>
<div class="line"><span class="keywordtype">size_t</span> nRead = map.at(999).limit(10).read(buf, MATCH_BACKWARD).size();</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01713">1713</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l00296">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::limit()</a>, and <a class="el" href="AddressMap_8h_source.html#l01690">Sawyer::Container::AddressMap&lt; A, T &gt;::read()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1AddressMap_a9719e774896dcd76f6fc70442ce73d33_cgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1AddressMap_a9719e774896dcd76f6fc70442ce73d33_cgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1AddressMap_a9719e774896dcd76f6fc70442ce73d33_cgraph" id="classSawyer_1_1Container_1_1AddressMap_a9719e774896dcd76f6fc70442ce73d33_cgraph">
<area shape="rect" title="Reads data into the supplied buffer." alt="" coords="5,50,144,91"/>
<area shape="rect" href="classSawyer_1_1Container_1_1AddressMapConstraints.html#a1e7b229039bfde68032769c1fba95a5e" title="Limit matching length." alt="" coords="192,5,355,61"/>
<area shape="rect" href="classSawyer_1_1Container_1_1AddressMap.html#ae17e760e87b8cbeb207310f6f4dc8b20" title="Reads data into the supplied buffer." alt="" coords="204,86,343,127"/>
</map>
</div>

</div>
</div>
<a id="aafc28dc1c26b66b2142eefa1bf13f074"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafc28dc1c26b66b2142eefa1bf13f074">&#9670;&nbsp;</a></span>write() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1Interval.html">Sawyer::Container::Interval</a>&lt;<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a>&gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::write </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#aa7a7317b6be4502317ab4357b5989660">Value</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a>&lt; A, T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes data from the supplied buffer. </p>
<p>Copies data from an array or STL vector into the underlying address map buffers corresponding to the specified constraints. If the array is a null pointer then no data is written and the return value indicates what addresses would have been accessed. The constraints are agumented by also requiring that the addresses be contiguous and lack the IMMUTABLE bit, and in the case of STL vectors that not more data is written thn what is in the vector. The return value is the interval of addresses that were written.</p>
<p>The Access::IMMUTABLE bit is usually used to indicate that a buffer cannot be modified (for instance, the buffer is memory allocated with read-only access by POSIX <code>mmap</code>).</p>
<p>The constraints are usually curried before the actual read call, as in this example that writes the vector's values into the map at the first writable address greater than or equal to 1000.</p>
<div class="fragment"><div class="line">std::vector&lt;Value&gt; buffer = {...};</div>
<div class="line">Interval&lt;Address&gt; written = map.atOrAfter(1000).require(WRITABLE).write(buffer);</div>
</div><!-- fragment --><p>Writing can also be performed backward, such as this example that writes up to ten values such that the last value written is at address 999. The buffer contains values in their address order.</p>
<div class="fragment"><div class="line"><a class="code" href="classSawyer_1_1Container_1_1AddressMap.html#aa7a7317b6be4502317ab4357b5989660">Value</a> buf[10] = { ... };</div>
<div class="line"><span class="keywordtype">size_t</span> nWritten = map.at(999).limit(10).write(buf, MATCH_BACKWARD).size();</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01751">1751</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressSegment_8h_source.html#l00141">Sawyer::Container::AddressSegment&lt; A, T &gt;::buffer()</a>, <a class="el" href="AddressMap_8h_source.html#l01314">Sawyer::Container::AddressMap&lt; A, T &gt;::checkConsistency()</a>, <a class="el" href="Interval_8h_source.html#l00219">Sawyer::Container::Interval&lt; T &gt;::isEmpty()</a>, <a class="el" href="Sawyer_2Map_8h_source.html#l00098">Sawyer::Container::Map&lt; K, T, Cmp, Alloc &gt;::Node::key()</a>, <a class="el" href="Interval_8h_source.html#l00207">Sawyer::Container::Interval&lt; T &gt;::least()</a>, <a class="el" href="IntervalMap_8h_source.html#l00308">Sawyer::Container::IntervalMap&lt; Interval&lt; A &gt;, AddressSegment&lt; A, boost::uint8_t &gt;, AddressMapImpl::SegmentMergePolicy&lt; A, boost::uint8_t &gt; &gt;::lowerBound()</a>, <a class="el" href="AddressMap_8h_source.html#l01394">Sawyer::Container::AddressMap&lt; A, T &gt;::nodes()</a>, <a class="el" href="AddressSegment_8h_source.html#l00150">Sawyer::Container::AddressSegment&lt; A, T &gt;::offset()</a>, <a class="el" href="AddressMap_8h_source.html#l00250">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::prohibit()</a>, <a class="el" href="Interval_8h_source.html#l00279">Sawyer::Container::Interval&lt; T &gt;::size()</a>, and <a class="el" href="Sawyer_2Map_8h_source.html#l00105">Sawyer::Container::Map&lt; K, T, Cmp, Alloc &gt;::Node::value()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AddressMap_8h_source.html#l01788">Sawyer::Container::AddressMap&lt; A, T &gt;::write()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1AddressMap_aafc28dc1c26b66b2142eefa1bf13f074_cgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1AddressMap_aafc28dc1c26b66b2142eefa1bf13f074_cgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1AddressMap_aafc28dc1c26b66b2142eefa1bf13f074_cgraph" id="classSawyer_1_1Container_1_1AddressMap_aafc28dc1c26b66b2142eefa1bf13f074_cgraph">
<area shape="rect" title="Writes data from the supplied buffer." alt="" coords="5,285,144,327"/>
<area shape="rect" href="classSawyer_1_1Container_1_1AddressSegment.html#acd64963667c58e506d31bb67f3fd0df0" title="Property: buffer." alt="" coords="495,5,657,47"/>
<area shape="rect" href="classSawyer_1_1Container_1_1AddressMap.html#a300a26b869a20b7c773f75f7c3d75e04" title="Check map consistency." alt="" coords="214,227,425,268"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Map_1_1Node.html#a3a6bfd720946fa7459f32e07a5d6f8f1" title="Key part of key/value node." alt="" coords="507,71,645,112"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Interval.html#abb62f08552ec4762be55510d97e7a233" title="Returns lower limit." alt="" coords="507,136,645,177"/>
<area shape="rect" href="classSawyer_1_1Container_1_1AddressMap.html#a000ced173d57eb4990dea1b45f0339e0" title="Iterator range for nodes." alt="" coords="507,201,645,243"/>
<area shape="rect" href="classSawyer_1_1Container_1_1AddressSegment.html#a970398df59bd3f5b326d072185afad23" title="Property: buffer offset." alt="" coords="495,267,657,308"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Interval.html#a75d8ca4e63b1180f6d2194a0ec79440d" title="Size of interval." alt="" coords="507,332,645,373"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Map_1_1Node.html#aa7eca3d931f2ca3a2bc77ef7011afe00" title="Value part of key/value node." alt="" coords="507,397,645,439"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Interval.html#aab81e29f7ededeac6d008e6dfaa1bf19" title="True if interval is empty." alt="" coords="250,445,389,487"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalMap.html#a87170e7d06eb8710211a65fb9bc052c6" title="Find the first node whose interval ends at or above the specified scalar key." alt="" coords="192,511,447,611"/>
<area shape="rect" href="classSawyer_1_1Container_1_1AddressMapConstraints.html#a6e70f35a67b98c0fd63699e2c09c7012" title="Prohibit certain access permissions." alt="" coords="238,635,401,691"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1AddressMap_aafc28dc1c26b66b2142eefa1bf13f074_icgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1AddressMap_aafc28dc1c26b66b2142eefa1bf13f074_icgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1AddressMap_aafc28dc1c26b66b2142eefa1bf13f074_icgraph" id="classSawyer_1_1Container_1_1AddressMap_aafc28dc1c26b66b2142eefa1bf13f074_icgraph">
<area shape="rect" title="Writes data from the supplied buffer." alt="" coords="192,5,331,47"/>
<area shape="rect" href="classSawyer_1_1Container_1_1AddressMap.html#a652030e760430ced6f1a39690e173122" title="Writes data from the supplied buffer." alt="" coords="5,5,144,47"/>
</map>
</div>

</div>
</div>
<a id="a652030e760430ced6f1a39690e173122"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a652030e760430ced6f1a39690e173122">&#9670;&nbsp;</a></span>write() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1Interval.html">Sawyer::Container::Interval</a>&lt;<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a>&gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::write </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#aa7a7317b6be4502317ab4357b5989660">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a>&lt; A, T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes data from the supplied buffer. </p>
<p>Copies data from an array or STL vector into the underlying address map buffers corresponding to the specified constraints. If the array is a null pointer then no data is written and the return value indicates what addresses would have been accessed. The constraints are agumented by also requiring that the addresses be contiguous and lack the IMMUTABLE bit, and in the case of STL vectors that not more data is written thn what is in the vector. The return value is the interval of addresses that were written.</p>
<p>The Access::IMMUTABLE bit is usually used to indicate that a buffer cannot be modified (for instance, the buffer is memory allocated with read-only access by POSIX <code>mmap</code>).</p>
<p>The constraints are usually curried before the actual read call, as in this example that writes the vector's values into the map at the first writable address greater than or equal to 1000.</p>
<div class="fragment"><div class="line">std::vector&lt;Value&gt; buffer = {...};</div>
<div class="line">Interval&lt;Address&gt; written = map.atOrAfter(1000).require(WRITABLE).write(buffer);</div>
</div><!-- fragment --><p>Writing can also be performed backward, such as this example that writes up to ten values such that the last value written is at address 999. The buffer contains values in their address order.</p>
<div class="fragment"><div class="line"><a class="code" href="classSawyer_1_1Container_1_1AddressMap.html#aa7a7317b6be4502317ab4357b5989660">Value</a> buf[10] = { ... };</div>
<div class="line"><span class="keywordtype">size_t</span> nWritten = map.at(999).limit(10).write(buf, MATCH_BACKWARD).size();</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01788">1788</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l00296">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::limit()</a>, and <a class="el" href="AddressMap_8h_source.html#l01751">Sawyer::Container::AddressMap&lt; A, T &gt;::write()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1AddressMap_a652030e760430ced6f1a39690e173122_cgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1AddressMap_a652030e760430ced6f1a39690e173122_cgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1AddressMap_a652030e760430ced6f1a39690e173122_cgraph" id="classSawyer_1_1Container_1_1AddressMap_a652030e760430ced6f1a39690e173122_cgraph">
<area shape="rect" title="Writes data from the supplied buffer." alt="" coords="5,50,144,91"/>
<area shape="rect" href="classSawyer_1_1Container_1_1AddressMapConstraints.html#a1e7b229039bfde68032769c1fba95a5e" title="Limit matching length." alt="" coords="192,5,355,61"/>
<area shape="rect" href="classSawyer_1_1Container_1_1AddressMap.html#aafc28dc1c26b66b2142eefa1bf13f074" title="Writes data from the supplied buffer." alt="" coords="204,86,343,127"/>
</map>
</div>

</div>
</div>
<a id="a79044a63583ed0fa8cd49c945372d696"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79044a63583ed0fa8cd49c945372d696">&#9670;&nbsp;</a></span>prune()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::prune </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a>&lt; A, T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prune away addresses that match constraints. </p>
<p>Removes all addresses for which the constraints match. The addresses need not be contiguous in memory (in fact, noncontiguous is the default), and the matching segments need not be consecutive segments. In other words, the interval over which this function operates can include segments that do not satisfy the constraints (and are not pruned). For instance, to remove all segments that are writable regardless of whether other segments are interspersed:</p>
<div class="fragment"><div class="line">map.require(WRITABLE).contiguous(<span class="keyword">false</span>).prune();</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#ab1d024a2128d70727cfce72518a32bfd" title="Keep only addresses that match constraints.">keep</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01805">1805</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l00456">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::addressConstraints()</a>, <a class="el" href="IntervalMap_8h_source.html#l00770">Sawyer::Container::IntervalMap&lt; Interval&lt; A &gt;, AddressSegment&lt; A, boost::uint8_t &gt;, AddressMapImpl::SegmentMergePolicy&lt; A, boost::uint8_t &gt; &gt;::erase()</a>, <a class="el" href="IntervalSet_8h_source.html#l00532">Sawyer::Container::IntervalSet&lt; I &gt;::insert()</a>, <a class="el" href="IntervalSet_8h_source.html#l00225">Sawyer::Container::IntervalSet&lt; I &gt;::intervals()</a>, and <a class="el" href="Sawyer_2Map_8h_source.html#l00098">Sawyer::Container::Map&lt; K, T, Cmp, Alloc &gt;::Node::key()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1AddressMap_a79044a63583ed0fa8cd49c945372d696_cgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1AddressMap_a79044a63583ed0fa8cd49c945372d696_cgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1AddressMap_a79044a63583ed0fa8cd49c945372d696_cgraph" id="classSawyer_1_1Container_1_1AddressMap_a79044a63583ed0fa8cd49c945372d696_cgraph">
<area shape="rect" title="Prune away addresses that match constraints." alt="" coords="5,209,144,250"/>
<area shape="rect" href="classSawyer_1_1Container_1_1AddressMapConstraints.html#a5b3e52622c9de8ea77207c7572fece57" title="Construct new constraints from existing address constraints." alt="" coords="238,5,401,61"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalMap.html#a797f0a6bd63f8debdcd0ccb2fcecf0f3" title="Erase the specified interval." alt="" coords="192,85,447,185"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalSet.html#a8ba417febcca9d50fc16258470d6d176" title="Insert specified values." alt="" coords="250,209,389,250"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalSet.html#a0e226046a0d838309882964ee0fe315c" title="Iterator range for all intervals actually stored by this set." alt="" coords="248,274,391,315"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Map_1_1Node.html#a3a6bfd720946fa7459f32e07a5d6f8f1" title="Key part of key/value node." alt="" coords="250,339,389,381"/>
</map>
</div>

</div>
</div>
<a id="ab1d024a2128d70727cfce72518a32bfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1d024a2128d70727cfce72518a32bfd">&#9670;&nbsp;</a></span>keep()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::keep </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a>&lt; A, T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Keep only addresses that match constraints. </p>
<p>Keeps only those addresses that satisfy the given constraints, discarding all others. The addresses need not be contiguous (in fact, noncontiguous is the default), and the matching segments need not be consecutive segments. In other words, the interval over which this function operates can include segments that do not satisfy the constraints (and are pruned). For instance, to remove all segments that are not writable regardless of whether other segments are interspersed:</p>
<div class="fragment"><div class="line">map.require(WRITABLE).contiguous(<span class="keyword">false</span>).keep();</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a79044a63583ed0fa8cd49c945372d696" title="Prune away addresses that match constraints.">prune</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01832">1832</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l00456">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::addressConstraints()</a>, <a class="el" href="IntervalMap_8h_source.html#l00770">Sawyer::Container::IntervalMap&lt; Interval&lt; A &gt;, AddressSegment&lt; A, boost::uint8_t &gt;, AddressMapImpl::SegmentMergePolicy&lt; A, boost::uint8_t &gt; &gt;::erase()</a>, <a class="el" href="IntervalSet_8h_source.html#l00532">Sawyer::Container::IntervalSet&lt; I &gt;::insert()</a>, <a class="el" href="IntervalSet_8h_source.html#l00225">Sawyer::Container::IntervalSet&lt; I &gt;::intervals()</a>, <a class="el" href="IntervalSet_8h_source.html#l00494">Sawyer::Container::IntervalSet&lt; I &gt;::invert()</a>, and <a class="el" href="Sawyer_2Map_8h_source.html#l00098">Sawyer::Container::Map&lt; K, T, Cmp, Alloc &gt;::Node::key()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1AddressMap_ab1d024a2128d70727cfce72518a32bfd_cgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1AddressMap_ab1d024a2128d70727cfce72518a32bfd_cgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1AddressMap_ab1d024a2128d70727cfce72518a32bfd_cgraph" id="classSawyer_1_1Container_1_1AddressMap_ab1d024a2128d70727cfce72518a32bfd_cgraph">
<area shape="rect" title="Keep only addresses that match constraints." alt="" coords="5,242,144,283"/>
<area shape="rect" href="classSawyer_1_1Container_1_1AddressMapConstraints.html#a5b3e52622c9de8ea77207c7572fece57" title="Construct new constraints from existing address constraints." alt="" coords="238,5,401,61"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalMap.html#a797f0a6bd63f8debdcd0ccb2fcecf0f3" title="Erase the specified interval." alt="" coords="192,85,447,185"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalSet.html#a8ba417febcca9d50fc16258470d6d176" title="Insert specified values." alt="" coords="250,209,389,250"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalSet.html#a0e226046a0d838309882964ee0fe315c" title="Iterator range for all intervals actually stored by this set." alt="" coords="248,274,391,315"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalSet.html#a00b53cc9aec995d0794a00a37c3975e0" title="Invert." alt="" coords="250,339,389,381"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Map_1_1Node.html#a3a6bfd720946fa7459f32e07a5d6f8f1" title="Key part of key/value node." alt="" coords="250,405,389,446"/>
</map>
</div>

</div>
</div>
<a id="a1406ad656e7e800fd01f9d17ccc297a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1406ad656e7e800fd01f9d17ccc297a8">&#9670;&nbsp;</a></span>changeAccess()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::changeAccess </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>requiredAccess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>prohibitedAccess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a>&lt; A, T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change access bits for addresses that match constraints. </p>
<p>For all addresses that satisfy the specified constraints, add the <code>requiredAccess</code> and remove the <code>prohibitedAccess</code> bits. The addresses need not be contiguous (in fact, noncontiguous is the default), and the matching segments need not be consecutive segments. In other words, the interval over which this function operates can include addresses that do not satisfy the constraints and whose access bits are not modified. For instance, to add execute permission and remove write permission for all segments containing the string ".text":</p>
<div class="fragment"><div class="line">map.substr(<span class="stringliteral">&quot;.text&quot;</span>).changeAccess(EXECUTABLE, WRITABLE);</div>
</div><!-- fragment --><p>To set access bits to a specific value, supply the complement as the second argument. The following code changes all addresses between a specified range so that only the READABLE and WRITABLE bits are set and no others:</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> newAccess = READABLE | WRITABLE;</div>
<div class="line">map.within(100,200).changeAccess(newAccess, ~newAccess);</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01866">1866</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressSegment_8h_source.html#l00160">Sawyer::Container::AddressSegment&lt; A, T &gt;::accessibility()</a>, <a class="el" href="AddressMap_8h_source.html#l00456">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::addressConstraints()</a>, <a class="el" href="IntervalMap_8h_source.html#l00838">Sawyer::Container::IntervalMap&lt; Interval&lt; A &gt;, AddressSegment&lt; A, boost::uint8_t &gt;, AddressMapImpl::SegmentMergePolicy&lt; A, boost::uint8_t &gt; &gt;::insert()</a>, <a class="el" href="Sawyer_2Map_8h_source.html#l00098">Sawyer::Container::Map&lt; K, T, Cmp, Alloc &gt;::Node::key()</a>, <a class="el" href="Interval_8h_source.html#l00207">Sawyer::Container::Interval&lt; T &gt;::least()</a>, <a class="el" href="AddressSegment_8h_source.html#l00150">Sawyer::Container::AddressSegment&lt; A, T &gt;::offset()</a>, and <a class="el" href="Sawyer_2Map_8h_source.html#l00105">Sawyer::Container::Map&lt; K, T, Cmp, Alloc &gt;::Node::value()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1AddressMap_a1406ad656e7e800fd01f9d17ccc297a8_cgraph.png" border="0" usemap="#classSawyer_1_1Container_1_1AddressMap_a1406ad656e7e800fd01f9d17ccc297a8_cgraph" alt=""/></div>
<map name="classSawyer_1_1Container_1_1AddressMap_a1406ad656e7e800fd01f9d17ccc297a8_cgraph" id="classSawyer_1_1Container_1_1AddressMap_a1406ad656e7e800fd01f9d17ccc297a8_cgraph">
<area shape="rect" title="Change access bits for addresses that match constraints." alt="" coords="5,275,195,316"/>
<area shape="rect" href="classSawyer_1_1Container_1_1AddressSegment.html#a9cec5b7fe7b13aba6d8fc9fbcc962f6a" title="Property: access rights." alt="" coords="269,5,471,47"/>
<area shape="rect" href="classSawyer_1_1Container_1_1AddressMapConstraints.html#a5b3e52622c9de8ea77207c7572fece57" title="Construct new constraints from existing address constraints." alt="" coords="289,71,451,127"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalMap.html#a1effdf10ccfb80ed11cc999e850ab2bd" title="Insert a key/value pair." alt="" coords="243,151,497,251"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Map_1_1Node.html#a3a6bfd720946fa7459f32e07a5d6f8f1" title="Key part of key/value node." alt="" coords="301,275,439,316"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Interval.html#abb62f08552ec4762be55510d97e7a233" title="Returns lower limit." alt="" coords="301,340,439,381"/>
<area shape="rect" href="classSawyer_1_1Container_1_1AddressSegment.html#a970398df59bd3f5b326d072185afad23" title="Property: buffer offset." alt="" coords="289,405,451,447"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Map_1_1Node.html#aa7eca3d931f2ca3a2bc77ef7011afe00" title="Value part of key/value node." alt="" coords="301,471,439,512"/>
</map>
</div>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="AddressMap_8h_source.html">AddressMap.h</a></li>
</ul>
</div><!-- contents -->
<div class="ttc" id="aclassSawyer_1_1Container_1_1AddressSegment_html"><div class="ttname"><a href="classSawyer_1_1Container_1_1AddressSegment.html">Sawyer::Container::AddressSegment</a></div><div class="ttdoc">A homogeneous interval of an address space.</div><div class="ttdef"><b>Definition:</b> <a href="AddressSegment_8h_source.html#l00037">AddressSegment.h:37</a></div></div>
<div class="ttc" id="aclassSawyer_1_1Container_1_1StaticBuffer_html_a7033524d4f99774a85d6685080b7625a"><div class="ttname"><a href="classSawyer_1_1Container_1_1StaticBuffer.html#a7033524d4f99774a85d6685080b7625a">Sawyer::Container::StaticBuffer::instance</a></div><div class="ttdeci">static Buffer&lt; A, T &gt;::Ptr instance(Value *values, Address size)</div><div class="ttdoc">Construct from caller-supplied data.</div><div class="ttdef"><b>Definition:</b> <a href="StaticBuffer_8h_source.html#l00085">StaticBuffer.h:85</a></div></div>
<div class="ttc" id="aclassSawyer_1_1Container_1_1IntervalMap_html_a664961032974fd71f132d8931edd68de"><div class="ttname"><a href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Sawyer::Container::IntervalMap&lt; Interval&lt; A &gt;, AddressSegment&lt; A, boost::uint8_t &gt;, AddressMapImpl::SegmentMergePolicy&lt; A, boost::uint8_t &gt; &gt;::Interval</a></div><div class="ttdeci">Interval&lt; A &gt; Interval</div><div class="ttdoc">Interval type.</div><div class="ttdef"><b>Definition:</b> <a href="IntervalMap_8h_source.html#l00173">IntervalMap.h:173</a></div></div>
<div class="ttc" id="aclassSawyer_1_1Container_1_1AddressMap_html_aa7a7317b6be4502317ab4357b5989660"><div class="ttname"><a href="classSawyer_1_1Container_1_1AddressMap.html#aa7a7317b6be4502317ab4357b5989660">Sawyer::Container::AddressMap::Value</a></div><div class="ttdeci">T Value</div><div class="ttdoc">Type of data stored in the address space.</div><div class="ttdef"><b>Definition:</b> <a href="AddressMap_8h_source.html#l01010">AddressMap.h:1010</a></div></div>
<div class="ttc" id="aclassSawyer_1_1Container_1_1AddressMap_html_ae44b092e3f2f17005b055086de062d5c"><div class="ttname"><a href="classSawyer_1_1Container_1_1AddressMap.html#ae44b092e3f2f17005b055086de062d5c">Sawyer::Container::AddressMap::prohibit</a></div><div class="ttdeci">AddressMapConstraints&lt; const AddressMap &gt; prohibit(unsigned x) const</div><div class="ttdoc">Constraint: prohibited access bits.</div><div class="ttdef"><b>Definition:</b> <a href="AddressMap_8h_source.html#l01074">AddressMap.h:1074</a></div></div>
<div class="ttc" id="aclassSawyer_1_1Container_1_1AddressMap_html_a30140763fdfb3c3c12e8fd6a1dc22ea9"><div class="ttname"><a href="classSawyer_1_1Container_1_1AddressMap.html#a30140763fdfb3c3c12e8fd6a1dc22ea9">Sawyer::Container::AddressMap::Segment</a></div><div class="ttdeci">AddressSegment&lt; A, T &gt; Segment</div><div class="ttdoc">Type of segments stored by this map.</div><div class="ttdef"><b>Definition:</b> <a href="AddressMap_8h_source.html#l01011">AddressMap.h:1011</a></div></div>
<div class="ttc" id="aclassSawyer_1_1Container_1_1AddressMap_html_af2c9cf858603ecda80b73929ad8fcbc9"><div class="ttname"><a href="classSawyer_1_1Container_1_1AddressMap.html#af2c9cf858603ecda80b73929ad8fcbc9">Sawyer::Container::AddressMap::Node</a></div><div class="ttdeci">Super::Node Node</div><div class="ttdoc">Storage node containing interval/segment pair.</div><div class="ttdef"><b>Definition:</b> <a href="AddressMap_8h_source.html#l01013">AddressMap.h:1013</a></div></div>
<div class="ttc" id="aclassMap_html_a909fe3c1283566d250b70116c2be86a8"><div class="ttname"><a href="classMap.html#a909fe3c1283566d250b70116c2be86a8">Map::exists</a></div><div class="ttdeci">bool exists(const Key &amp;key) const</div><div class="ttdoc">Convenience for determining if a key exists in this map.</div><div class="ttdef"><b>Definition:</b> <a href="Map_8h_source.html#l00089">Map.h:89</a></div></div>
<div class="ttc" id="aclassSawyer_1_1Container_1_1AddressMap_html_a9c8520e0f4a70e6d310cce43b9e5d146"><div class="ttname"><a href="classSawyer_1_1Container_1_1AddressMap.html#a9c8520e0f4a70e6d310cce43b9e5d146">Sawyer::Container::AddressMap::next</a></div><div class="ttdeci">Optional&lt; Address &gt; next(const AddressMapConstraints&lt; const AddressMap &gt; &amp;c, MatchFlags flags=0) const</div><div class="ttdoc">Minimum or maximum address that satisfies constraints.</div><div class="ttdef"><b>Definition:</b> <a href="AddressMap_8h_source.html#l01474">AddressMap.h:1474</a></div></div>
<div class="ttc" id="anamespaceSawyer_1_1Container_html"><div class="ttname"><a href="namespaceSawyer_1_1Container.html">Sawyer::Container</a></div><div class="ttdoc">Container classes that store user-defined values.</div><div class="ttdef"><b>Definition:</b> <a href="AddressMap_8h_source.html#l00035">AddressMap.h:35</a></div></div>
<div class="ttc" id="aclassSawyer_1_1Container_1_1AddressMap_html"><div class="ttname"><a href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a></div><div class="ttdoc">A mapping from address space to values.</div><div class="ttdef"><b>Definition:</b> <a href="AddressMap_8h_source.html#l01004">AddressMap.h:1004</a></div></div>
<div class="ttc" id="aclassSawyer_1_1SharedPointer_html"><div class="ttname"><a href="classSawyer_1_1SharedPointer.html">Sawyer::SharedPointer</a></div><div class="ttdoc">Reference-counting intrusive smart pointer.</div><div class="ttdef"><b>Definition:</b> <a href="SharedPointer_8h_source.html#l00068">SharedPointer.h:68</a></div></div>
<div class="ttc" id="aclassSawyer_1_1Container_1_1AddressMap_html_aa3d023864ebbf9ca4e6f009f36cbac61"><div class="ttname"><a href="classSawyer_1_1Container_1_1AddressMap.html#aa3d023864ebbf9ca4e6f009f36cbac61">Sawyer::Container::AddressMap::require</a></div><div class="ttdeci">AddressMapConstraints&lt; const AddressMap &gt; require(unsigned x) const</div><div class="ttdoc">Constraint: required access bits.</div><div class="ttdef"><b>Definition:</b> <a href="AddressMap_8h_source.html#l01061">AddressMap.h:1061</a></div></div>
<div class="ttc" id="aclassSawyer_1_1Container_1_1IntervalMap_html_ae27b32aea90cdef93228cd5c978c00ef"><div class="ttname"><a href="classSawyer_1_1Container_1_1IntervalMap.html#ae27b32aea90cdef93228cd5c978c00ef">Sawyer::Container::IntervalMap&lt; Interval&lt; A &gt;, AddressSegment&lt; A, boost::uint8_t &gt;, AddressMapImpl::SegmentMergePolicy&lt; A, boost::uint8_t &gt; &gt;::Map</a></div><div class="ttdeci">Container::Map&lt; Interval, Value, IntervalCompare &gt; Map</div><div class="ttdoc">Type of the underlying map.</div><div class="ttdef"><b>Definition:</b> <a href="IntervalMap_8h_source.html#l00190">IntervalMap.h:190</a></div></div>
<div class="ttc" id="aclassSawyer_1_1Container_1_1Interval_html"><div class="ttname"><a href="classSawyer_1_1Container_1_1Interval.html">Sawyer::Container::Interval&lt; Address &gt;</a></div></div>
<div class="ttc" id="aclassMap_html"><div class="ttname"><a href="classMap.html">Map</a></div><div class="ttdoc">Extends std::map with methods that return optional values.</div><div class="ttdef"><b>Definition:</b> <a href="Map_8h_source.html#l00010">Map.h:10</a></div></div>
<div class="ttc" id="aclassSawyer_1_1Container_1_1AddressMap_html_a1134be6cf10571edef9ffe6ab06fd7a9"><div class="ttname"><a href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Sawyer::Container::AddressMap::Address</a></div><div class="ttdeci">A Address</div><div class="ttdoc">Type for addresses.</div><div class="ttdef"><b>Definition:</b> <a href="AddressMap_8h_source.html#l01009">AddressMap.h:1009</a></div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Dec 19 2022 23:40:27 for ROSE by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
