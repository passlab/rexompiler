<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROSE: SageInterface Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="ROSE"/>
<link href="roseDoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ROSE
   &#160;<span id="projectnumber">0.11.96.11</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,true,'search.html','Search');
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">SageInterface Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>Functions that are useful when operating on the AST. </p>
<p>The Sage III IR design attempts to be minimalist. Thus additional functionality is intended to be presented using separate higher level interfaces which work with the IR. This namespace collects functions that operate on the IR and support numerous types of operations that are common to general analysis and transformation of the AST. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSageInterface_1_1const__int__expr__t.html">const_int_expr_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSageInterface_1_1DeclarationSets.html">DeclarationSets</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSageInterface_1_1DeferredTransformation.html">DeferredTransformation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSageInterface_1_1OutputLocalSymbolTables.html">OutputLocalSymbolTables</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSageInterface_1_1StatementGenerator.html">StatementGenerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for creating a statement whose computation writes its answer into a given variable.  <a href="classSageInterface_1_1StatementGenerator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSageInterface_1_1Transformation__Record.html">Transformation_Record</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSageInterface_1_1UniqueNameAttribute.html">UniqueNameAttribute</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A persistent attribute to represent a unique name for an expression.  <a href="classSageInterface_1_1UniqueNameAttribute.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab86783e884c0c9904545fda01630abfe"><td class="memItemLeft" align="right" valign="top"><a id="ab86783e884c0c9904545fda01630abfe"></a>
<a class="el" href="classSageInterface_1_1DeclarationSets.html">DeclarationSets</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>buildDeclarationSets</b> (<a class="el" href="classSgNode.html">SgNode</a> *)</td></tr>
<tr class="separator:ab86783e884c0c9904545fda01630abfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21d19eaa21c197ce5c65363d225eb31d"><td class="memItemLeft" align="right" valign="top"><a id="a21d19eaa21c197ce5c65363d225eb31d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#a21d19eaa21c197ce5c65363d225eb31d">addMessageStatement</a> (<a class="el" href="classSgStatement.html">SgStatement</a> *stmt, std::string message)</td></tr>
<tr class="memdesc:a21d19eaa21c197ce5c65363d225eb31d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classFunction.html">Function</a> to add "C" style comment to statement. <br /></td></tr>
<tr class="separator:a21d19eaa21c197ce5c65363d225eb31d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a1c34192a8f970d3a241c692ed36342e8"><td class="memItemLeft" align="right" valign="top"><a id="a1c34192a8f970d3a241c692ed36342e8"></a>
ROSE_DLL_API <a class="el" href="structSageInterface_1_1Transformation__Record.html">Transformation_Record</a>&#160;</td><td class="memItemRight" valign="bottom"><b>trans_records</b></td></tr>
<tr class="separator:a1c34192a8f970d3a241c692ed36342e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad7e45974f85c3009e8efe9b1bf18704"><td class="memItemLeft" align="right" valign="top"><a id="aad7e45974f85c3009e8efe9b1bf18704"></a>
ROSE_DLL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#aad7e45974f85c3009e8efe9b1bf18704">gensym_counter</a></td></tr>
<tr class="memdesc:aad7e45974f85c3009e8efe9b1bf18704"><td class="mdescLeft">&#160;</td><td class="mdescRight">An internal counter for generating unique <a class="el" href="classSgName.html" title="This class represents strings within the IR nodes.">SgName</a>. <br /></td></tr>
<tr class="separator:aad7e45974f85c3009e8efe9b1bf18704"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Stringify</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp4980e792ecc59d6d8f910b11531955dc"></a>Generate a useful string (name) to describe a <a class="el" href="classSgNode.html" title="This class represents the base class for all IR nodes within Sage III.">SgNode</a> </p>
</td></tr>
<tr class="memitem:a316d5a95dcdc1c3bcd857dcb61f3e100"><td class="memItemLeft" align="right" valign="top"><a id="a316d5a95dcdc1c3bcd857dcb61f3e100"></a>
std::map&lt; std::string, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#a316d5a95dcdc1c3bcd857dcb61f3e100">local_name_collision_map</a></td></tr>
<tr class="memdesc:a316d5a95dcdc1c3bcd857dcb61f3e100"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global map of name collisions to support <a class="el" href="namespaceSageInterface.html#a3c9884b02b0f7bc09b35e7371d66b865" title="Generate a useful name to support construction of identifiers from declarations.">generateUniqueNameForUseAsIdentifier()</a> function. <br /></td></tr>
<tr class="separator:a316d5a95dcdc1c3bcd857dcb61f3e100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb17ea89ed5a4d032496d6931774fd00"><td class="memItemLeft" align="right" valign="top"><a id="aeb17ea89ed5a4d032496d6931774fd00"></a>
std::map&lt; std::string, <a class="el" href="classSgNode.html">SgNode</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#aeb17ea89ed5a4d032496d6931774fd00">local_name_to_node_map</a></td></tr>
<tr class="memdesc:aeb17ea89ed5a4d032496d6931774fd00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global map of name collisions to support <a class="el" href="namespaceSageInterface.html#a3c9884b02b0f7bc09b35e7371d66b865" title="Generate a useful name to support construction of identifiers from declarations.">generateUniqueNameForUseAsIdentifier()</a> function. <br /></td></tr>
<tr class="separator:aeb17ea89ed5a4d032496d6931774fd00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaee1fa9cb55568bcba2614cc98d83dd"><td class="memItemLeft" align="right" valign="top"><a id="afaee1fa9cb55568bcba2614cc98d83dd"></a>
std::map&lt; <a class="el" href="classSgNode.html">SgNode</a> *, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#afaee1fa9cb55568bcba2614cc98d83dd">local_node_to_name_map</a></td></tr>
<tr class="memdesc:afaee1fa9cb55568bcba2614cc98d83dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global map of name collisions to support <a class="el" href="namespaceSageInterface.html#a3c9884b02b0f7bc09b35e7371d66b865" title="Generate a useful name to support construction of identifiers from declarations.">generateUniqueNameForUseAsIdentifier()</a> function. <br /></td></tr>
<tr class="separator:afaee1fa9cb55568bcba2614cc98d83dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8c38176c2d0e4d2bc851e70007902f9"><td class="memItemLeft" align="right" valign="top"><a id="ad8c38176c2d0e4d2bc851e70007902f9"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#ad8c38176c2d0e4d2bc851e70007902f9">get_name</a> (const <a class="el" href="classSgNode.html">SgNode</a> *node)</td></tr>
<tr class="memdesc:ad8c38176c2d0e4d2bc851e70007902f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a useful name to describe the <a class="el" href="classSgNode.html" title="This class represents the base class for all IR nodes within Sage III.">SgNode</a>. <br /></td></tr>
<tr class="separator:ad8c38176c2d0e4d2bc851e70007902f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcdc4bf692f0a99cf6c9f8dedd5dba0c"><td class="memItemLeft" align="right" valign="top"><a id="afcdc4bf692f0a99cf6c9f8dedd5dba0c"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#afcdc4bf692f0a99cf6c9f8dedd5dba0c">get_name</a> (const <a class="el" href="classSgStatement.html">SgStatement</a> *stmt)</td></tr>
<tr class="memdesc:afcdc4bf692f0a99cf6c9f8dedd5dba0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a useful name to describe the declaration. <br /></td></tr>
<tr class="separator:afcdc4bf692f0a99cf6c9f8dedd5dba0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae041006d7194c3dcf1771905a310551f"><td class="memItemLeft" align="right" valign="top"><a id="ae041006d7194c3dcf1771905a310551f"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#ae041006d7194c3dcf1771905a310551f">get_name</a> (const <a class="el" href="classSgExpression.html">SgExpression</a> *expr)</td></tr>
<tr class="memdesc:ae041006d7194c3dcf1771905a310551f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a useful name to describe the expression. <br /></td></tr>
<tr class="separator:ae041006d7194c3dcf1771905a310551f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a139b6ee7628669382055c4e5cc4091"><td class="memItemLeft" align="right" valign="top"><a id="a4a139b6ee7628669382055c4e5cc4091"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#a4a139b6ee7628669382055c4e5cc4091">get_name</a> (const <a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> *declaration)</td></tr>
<tr class="memdesc:a4a139b6ee7628669382055c4e5cc4091"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a useful name to describe the declaration. <br /></td></tr>
<tr class="separator:a4a139b6ee7628669382055c4e5cc4091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94a6b6ad81a1b4fe641ba34a6fa287fb"><td class="memItemLeft" align="right" valign="top"><a id="a94a6b6ad81a1b4fe641ba34a6fa287fb"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#a94a6b6ad81a1b4fe641ba34a6fa287fb">get_name</a> (const <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *scope)</td></tr>
<tr class="memdesc:a94a6b6ad81a1b4fe641ba34a6fa287fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a useful name to describe the scope. <br /></td></tr>
<tr class="separator:a94a6b6ad81a1b4fe641ba34a6fa287fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a215e9d46d141268e3b4841b6a4d105a1"><td class="memItemLeft" align="right" valign="top"><a id="a215e9d46d141268e3b4841b6a4d105a1"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#a215e9d46d141268e3b4841b6a4d105a1">get_name</a> (const <a class="el" href="classSgSymbol.html">SgSymbol</a> *symbol)</td></tr>
<tr class="memdesc:a215e9d46d141268e3b4841b6a4d105a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a useful name to describe the <a class="el" href="classSgSymbol.html" title="This class represents the concept of a name within the compiler.">SgSymbol</a>. <br /></td></tr>
<tr class="separator:a215e9d46d141268e3b4841b6a4d105a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3dbafd1030e3d2995e938b98c9e8a34"><td class="memItemLeft" align="right" valign="top"><a id="aa3dbafd1030e3d2995e938b98c9e8a34"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#aa3dbafd1030e3d2995e938b98c9e8a34">get_name</a> (const <a class="el" href="classSgType.html">SgType</a> *type)</td></tr>
<tr class="memdesc:aa3dbafd1030e3d2995e938b98c9e8a34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a useful name to describe the <a class="el" href="classSgType.html" title="This class represents the base class for all types.">SgType</a>. <br /></td></tr>
<tr class="separator:aa3dbafd1030e3d2995e938b98c9e8a34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5abb9bb7920c00cd4331354fc470049"><td class="memItemLeft" align="right" valign="top"><a id="ae5abb9bb7920c00cd4331354fc470049"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#ae5abb9bb7920c00cd4331354fc470049">get_name</a> (const <a class="el" href="classSgSupport.html">SgSupport</a> *node)</td></tr>
<tr class="memdesc:ae5abb9bb7920c00cd4331354fc470049"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a useful name to describe the <a class="el" href="classSgSupport.html" title="This class represents the base class of a numbr of IR nodes that don&#39;t otherwise fit into the existin...">SgSupport</a> IR node. <br /></td></tr>
<tr class="separator:ae5abb9bb7920c00cd4331354fc470049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fb6f2b9749473b0efcbb19bfd8d019b"><td class="memItemLeft" align="right" valign="top"><a id="a1fb6f2b9749473b0efcbb19bfd8d019b"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#a1fb6f2b9749473b0efcbb19bfd8d019b">get_name</a> (const <a class="el" href="classSgLocatedNodeSupport.html">SgLocatedNodeSupport</a> *node)</td></tr>
<tr class="memdesc:a1fb6f2b9749473b0efcbb19bfd8d019b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a useful name to describe the <a class="el" href="classSgLocatedNodeSupport.html">SgLocatedNodeSupport</a> IR node. <br /></td></tr>
<tr class="separator:a1fb6f2b9749473b0efcbb19bfd8d019b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a571cc2dc63fcd697dcab3e43feb87dc2"><td class="memItemLeft" align="right" valign="top"><a id="a571cc2dc63fcd697dcab3e43feb87dc2"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#a571cc2dc63fcd697dcab3e43feb87dc2">get_name</a> (const <a class="el" href="classSgC__PreprocessorDirectiveStatement.html">SgC_PreprocessorDirectiveStatement</a> *directive)</td></tr>
<tr class="memdesc:a571cc2dc63fcd697dcab3e43feb87dc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a useful name to describe the <a class="el" href="classSgC__PreprocessorDirectiveStatement.html">SgC_PreprocessorDirectiveStatement</a> IR node. <br /></td></tr>
<tr class="separator:a571cc2dc63fcd697dcab3e43feb87dc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae80c3edde132b58538fe96a143a2f83d"><td class="memItemLeft" align="right" valign="top"><a id="ae80c3edde132b58538fe96a143a2f83d"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#ae80c3edde132b58538fe96a143a2f83d">get_name</a> (const <a class="el" href="classSgToken.html">SgToken</a> *token)</td></tr>
<tr class="memdesc:ae80c3edde132b58538fe96a143a2f83d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a useful name to describe the <a class="el" href="classSgToken.html">SgToken</a> IR node. <br /></td></tr>
<tr class="separator:ae80c3edde132b58538fe96a143a2f83d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9f8b79baaa28932a05362575b19b80f"><td class="memItemLeft" align="right" valign="top"><a id="ad9f8b79baaa28932a05362575b19b80f"></a>
<a class="el" href="classSgType.html">SgType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#ad9f8b79baaa28932a05362575b19b80f">getDeclaredType</a> (const <a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> *declaration)</td></tr>
<tr class="memdesc:ad9f8b79baaa28932a05362575b19b80f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the type introduced by a declaration. <br /></td></tr>
<tr class="separator:ad9f8b79baaa28932a05362575b19b80f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c9884b02b0f7bc09b35e7371d66b865"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#a3c9884b02b0f7bc09b35e7371d66b865">generateUniqueNameForUseAsIdentifier</a> (<a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> *declaration)</td></tr>
<tr class="memdesc:a3c9884b02b0f7bc09b35e7371d66b865"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a useful name to support construction of identifiers from declarations.  <a href="namespaceSageInterface.html#a3c9884b02b0f7bc09b35e7371d66b865">More...</a><br /></td></tr>
<tr class="separator:a3c9884b02b0f7bc09b35e7371d66b865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6295982f349ce7338045bc3bfe07bd4e"><td class="memItemLeft" align="right" valign="top"><a id="a6295982f349ce7338045bc3bfe07bd4e"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#a6295982f349ce7338045bc3bfe07bd4e">generateUniqueNameForUseAsIdentifier_support</a> (<a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> *declaration)</td></tr>
<tr class="memdesc:a6295982f349ce7338045bc3bfe07bd4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global map of name collisions to support <a class="el" href="namespaceSageInterface.html#a3c9884b02b0f7bc09b35e7371d66b865" title="Generate a useful name to support construction of identifiers from declarations.">generateUniqueNameForUseAsIdentifier()</a> function. <br /></td></tr>
<tr class="separator:a6295982f349ce7338045bc3bfe07bd4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af07fd8a35c91875f96067c401739a604"><td class="memItemLeft" align="right" valign="top"><a id="af07fd8a35c91875f96067c401739a604"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#af07fd8a35c91875f96067c401739a604">computeUniqueNameForUseAsIdentifier</a> (<a class="el" href="classSgNode.html">SgNode</a> *astNode)</td></tr>
<tr class="memdesc:af07fd8a35c91875f96067c401739a604"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traversal to set the global map of names to node and node to names.collisions to support <a class="el" href="namespaceSageInterface.html#a3c9884b02b0f7bc09b35e7371d66b865" title="Generate a useful name to support construction of identifiers from declarations.">generateUniqueNameForUseAsIdentifier()</a> function. <br /></td></tr>
<tr class="separator:af07fd8a35c91875f96067c401739a604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac73a634012f4029fc8285eb9ac3a0984"><td class="memItemLeft" align="right" valign="top"><a id="ac73a634012f4029fc8285eb9ac3a0984"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#ac73a634012f4029fc8285eb9ac3a0984">reset_name_collision_map</a> ()</td></tr>
<tr class="memdesc:ac73a634012f4029fc8285eb9ac3a0984"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset map variables used to support <a class="el" href="namespaceSageInterface.html#a3c9884b02b0f7bc09b35e7371d66b865" title="Generate a useful name to support construction of identifiers from declarations.">generateUniqueNameForUseAsIdentifier()</a> function. <br /></td></tr>
<tr class="separator:ac73a634012f4029fc8285eb9ac3a0984"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ad62c74534fdcb9408a34343a929a1d33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad62c74534fdcb9408a34343a929a1d33">&#9670;&nbsp;</a></span>set_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_DLL_API int SageInterface::set_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgInitializedName.html">SgInitializedName</a> *&#160;</td>
          <td class="paramname"><em>initializedNameNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgName.html">SgName</a>&#160;</td>
          <td class="paramname"><em>new_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set_name of symbol in symbol table. </p>
<p>This function extracts the symbol from the relavant symbol table, changes the name (at the declaration) and reinserts it into the symbol table. </p>

</div>
</div>
<a id="acc0f3da74a44af1911c47be8f67fd286"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc0f3da74a44af1911c47be8f67fd286">&#9670;&nbsp;</a></span>outputLocalSymbolTables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_DLL_API void SageInterface::outputLocalSymbolTables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Output the local symbol tables. </p>
<p>\implementation Each symbol table is output with the file infor where it is located in the source code. </p>

</div>
</div>
<a id="af77c4adbf8e70c2904f5c95f80aa32b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af77c4adbf8e70c2904f5c95f80aa32b4">&#9670;&nbsp;</a></span>rebuildSymbolTable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::rebuildSymbolTable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *&#160;</td>
          <td class="paramname"><em>scope</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Regenerate the symbol table. </p>
<p>\implementation current symbol table must be NULL pointer before calling this function (for safety, but is this a good idea?) </p>

</div>
</div>
<a id="a3c9884b02b0f7bc09b35e7371d66b865"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c9884b02b0f7bc09b35e7371d66b865">&#9670;&nbsp;</a></span>generateUniqueNameForUseAsIdentifier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string SageInterface::generateUniqueNameForUseAsIdentifier </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> *&#160;</td>
          <td class="paramname"><em>declaration</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a useful name to support construction of identifiers from declarations. </p>
<p>This function permits names to be generated that will be unique across translation units (a specific requirement different from the context of the <a class="el" href="namespaceSageInterface.html#ad8c38176c2d0e4d2bc851e70007902f9" title="Generate a useful name to describe the SgNode.">get_name()</a> functions above). </p>

</div>
</div>
<a id="ac088828a4143b77fa9e3b11ba6b40a0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac088828a4143b77fa9e3b11ba6b40a0e">&#9670;&nbsp;</a></span>generateUniqueName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string SageInterface::generateUniqueName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgNode.html">SgNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignoreDifferenceBetweenDefiningAndNondefiningDeclarations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate unique name from C and C++ constructs. The name may contain space. </p>
<p>This is support for the AST merge, but is generally useful as a more general mechanism than name mangling which is more closely ties to the generation of names to support link-time function name resolution. This is more general than common name mangling in that it resolves more relevant differences between C and C++ declarations. (e.g. the type within the declaration: "struct { int:8; } foo;").</p>
<p>\implementation current work does not support expressions. </p>

</div>
</div>
<a id="a6401801005892a56b2f337d0ce501eb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6401801005892a56b2f337d0ce501eb7">&#9670;&nbsp;</a></span>generateUniqueVariableName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string SageInterface::generateUniqueVariableName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *&#160;</td>
          <td class="paramname"><em>scope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>baseName</em> = <code>&quot;temp&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a name like <b>temp#</b> that is unique in the current scope and any parent and children scopes. </p>
<p># is a unique integer counter. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseName</td><td>the word to be included in the variable names. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2e2c09133334d2db043980411ad65a7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e2c09133334d2db043980411ad65a7c">&#9670;&nbsp;</a></span>clearMangledNameCache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::clearMangledNameCache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgGlobal.html">SgGlobal</a> *&#160;</td>
          <td class="paramname"><em>globalScope</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Support for faster mangled name generation (caching avoids recomputation). </p>

</div>
</div>
<a id="a99a0f2f893616339b773b44d25a5e7e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99a0f2f893616339b773b44d25a5e7e8">&#9670;&nbsp;</a></span>astIntersection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_DLL_API std::vector&lt; <a class="el" href="classSgNode.html">SgNode</a> * &gt; SageInterface::astIntersection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&#160;</td>
          <td class="paramname"><em>original</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&#160;</td>
          <td class="paramname"><em>copy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgCopyHelp.html">SgCopyHelp</a> *&#160;</td>
          <td class="paramname"><em>help</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the intersection set for two ASTs. </p>
<p>This is part of a test done by the copy function to compute those IR nodes in the copy that still reference the original AST. </p>

</div>
</div>
<a id="a746a92a94fcc6190e015e74aa1c911e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a746a92a94fcc6190e015e74aa1c911e8">&#9670;&nbsp;</a></span>isAssignmentStatement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::isAssignmentStatement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&#160;</td>
          <td class="paramname"><em>_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgExpression.html">SgExpression</a> **&#160;</td>
          <td class="paramname"><em>lhs</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgExpression.html">SgExpression</a> **&#160;</td>
          <td class="paramname"><em>rhs</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>readlhs</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a <a class="el" href="classSgNode.html" title="This class represents the base class for all IR nodes within Sage III.">SgNode</a> _s is an assignment statement (any of =,+=,-=,&amp;=,/=, ^=, etc) </p>
<p>Return the left hand, right hand expressions and if the left hand variable is also being read </p>

</div>
</div>
<a id="acf7306c51d7bcf8aef7868cdf487819a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf7306c51d7bcf8aef7868cdf487819a">&#9670;&nbsp;</a></span>is_C_language()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_DLL_API bool SageInterface::is_C_language </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Brief These traverse the memory pool of <a class="el" href="classSgFile.html" title="This class represents a source file for a project (which may contian many source files and or directo...">SgFile</a> IR nodes and determine what languages are in use! </p>

<p class="definition">Definition at line <a class="el" href="sageInterface_8h_source.html#l00649">649</a> of file <a class="el" href="sageInterface_8h_source.html">sageInterface.h</a>.</p>

<p class="reference">References <a class="el" href="sageInterface_8h_source.html#l00649">Rose::is_C_language</a>.</p>

<p class="reference">Referenced by <a class="el" href="sageInterface_8h_source.html#l00649">is_C_language()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceSageInterface_acf7306c51d7bcf8aef7868cdf487819a_icgraph.png" border="0" usemap="#namespaceSageInterface_acf7306c51d7bcf8aef7868cdf487819a_icgraph" alt=""/></div>
<map name="namespaceSageInterface_acf7306c51d7bcf8aef7868cdf487819a_icgraph" id="namespaceSageInterface_acf7306c51d7bcf8aef7868cdf487819a_icgraph">
<area shape="rect" title=" " alt="" coords="5,29,144,71"/>
</map>
</div>

</div>
</div>
<a id="afd0ee5dff733df3e009326024b09552a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd0ee5dff733df3e009326024b09552a">&#9670;&nbsp;</a></span>is_OpenMP_language()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_DLL_API bool SageInterface::is_OpenMP_language </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Brief These traverse the memory pool of <a class="el" href="classSgFile.html" title="This class represents a source file for a project (which may contian many source files and or directo...">SgFile</a> IR nodes and determine what languages are in use! </p>

<p class="definition">Definition at line <a class="el" href="sageInterface_8h_source.html#l00650">650</a> of file <a class="el" href="sageInterface_8h_source.html">sageInterface.h</a>.</p>

</div>
</div>
<a id="a7cac06dd21ef31dd646f223eee65346b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cac06dd21ef31dd646f223eee65346b">&#9670;&nbsp;</a></span>is_UPC_language()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_DLL_API bool SageInterface::is_UPC_language </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Brief These traverse the memory pool of <a class="el" href="classSgFile.html" title="This class represents a source file for a project (which may contian many source files and or directo...">SgFile</a> IR nodes and determine what languages are in use! </p>

<p class="definition">Definition at line <a class="el" href="sageInterface_8h_source.html#l00651">651</a> of file <a class="el" href="sageInterface_8h_source.html">sageInterface.h</a>.</p>

</div>
</div>
<a id="a0a8f14a7fda04be1f439a99f754ae524"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a8f14a7fda04be1f439a99f754ae524">&#9670;&nbsp;</a></span>is_UPC_dynamic_threads()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_DLL_API bool SageInterface::is_UPC_dynamic_threads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Brief These traverse the memory pool of <a class="el" href="classSgFile.html" title="This class represents a source file for a project (which may contian many source files and or directo...">SgFile</a> IR nodes and determine what languages are in use! </p>

<p class="definition">Definition at line <a class="el" href="sageInterface_8h_source.html#l00652">652</a> of file <a class="el" href="sageInterface_8h_source.html">sageInterface.h</a>.</p>

</div>
</div>
<a id="ab60ea035bc6be6d72d19dc3250f6c5bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab60ea035bc6be6d72d19dc3250f6c5bf">&#9670;&nbsp;</a></span>is_C99_language()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_DLL_API bool SageInterface::is_C99_language </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Brief These traverse the memory pool of <a class="el" href="classSgFile.html" title="This class represents a source file for a project (which may contian many source files and or directo...">SgFile</a> IR nodes and determine what languages are in use! </p>

<p class="definition">Definition at line <a class="el" href="sageInterface_8h_source.html#l00653">653</a> of file <a class="el" href="sageInterface_8h_source.html">sageInterface.h</a>.</p>

</div>
</div>
<a id="a1014f45108b312d26ee7b77e2fbeb1cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1014f45108b312d26ee7b77e2fbeb1cd">&#9670;&nbsp;</a></span>is_Cxx_language()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_DLL_API bool SageInterface::is_Cxx_language </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Brief These traverse the memory pool of <a class="el" href="classSgFile.html" title="This class represents a source file for a project (which may contian many source files and or directo...">SgFile</a> IR nodes and determine what languages are in use! </p>

<p class="definition">Definition at line <a class="el" href="sageInterface_8h_source.html#l00654">654</a> of file <a class="el" href="sageInterface_8h_source.html">sageInterface.h</a>.</p>

</div>
</div>
<a id="a950baa805b1ccf606a9bbe3b444b55ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a950baa805b1ccf606a9bbe3b444b55ea">&#9670;&nbsp;</a></span>is_Fortran_language()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_DLL_API bool SageInterface::is_Fortran_language </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Brief These traverse the memory pool of <a class="el" href="classSgFile.html" title="This class represents a source file for a project (which may contian many source files and or directo...">SgFile</a> IR nodes and determine what languages are in use! </p>

<p class="definition">Definition at line <a class="el" href="sageInterface_8h_source.html#l00655">655</a> of file <a class="el" href="sageInterface_8h_source.html">sageInterface.h</a>.</p>

</div>
</div>
<a id="a30d579f1fc770c5d5354b5cf1c51f36d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30d579f1fc770c5d5354b5cf1c51f36d">&#9670;&nbsp;</a></span>is_CAF_language()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_DLL_API bool SageInterface::is_CAF_language </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Brief These traverse the memory pool of <a class="el" href="classSgFile.html" title="This class represents a source file for a project (which may contian many source files and or directo...">SgFile</a> IR nodes and determine what languages are in use! </p>

<p class="definition">Definition at line <a class="el" href="sageInterface_8h_source.html#l00656">656</a> of file <a class="el" href="sageInterface_8h_source.html">sageInterface.h</a>.</p>

</div>
</div>
<a id="a3dee5053805bee08c8ede28c2961cf5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dee5053805bee08c8ede28c2961cf5d">&#9670;&nbsp;</a></span>is_Cuda_language()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_DLL_API bool SageInterface::is_Cuda_language </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Brief These traverse the memory pool of <a class="el" href="classSgFile.html" title="This class represents a source file for a project (which may contian many source files and or directo...">SgFile</a> IR nodes and determine what languages are in use! </p>

<p class="definition">Definition at line <a class="el" href="sageInterface_8h_source.html#l00657">657</a> of file <a class="el" href="sageInterface_8h_source.html">sageInterface.h</a>.</p>

</div>
</div>
<a id="aaec7eb773d68133f86bd2826c41d6cea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaec7eb773d68133f86bd2826c41d6cea">&#9670;&nbsp;</a></span>is_OpenCL_language()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_DLL_API bool SageInterface::is_OpenCL_language </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Brief These traverse the memory pool of <a class="el" href="classSgFile.html" title="This class represents a source file for a project (which may contian many source files and or directo...">SgFile</a> IR nodes and determine what languages are in use! </p>

<p class="definition">Definition at line <a class="el" href="sageInterface_8h_source.html#l00658">658</a> of file <a class="el" href="sageInterface_8h_source.html">sageInterface.h</a>.</p>

</div>
</div>
<a id="aa66d704b7faf1e9e6b5d6268acfa7fc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa66d704b7faf1e9e6b5d6268acfa7fc9">&#9670;&nbsp;</a></span>is_mixed_C_and_Cxx_language()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_DLL_API bool SageInterface::is_mixed_C_and_Cxx_language </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Brief These traverse the memory pool of <a class="el" href="classSgFile.html" title="This class represents a source file for a project (which may contian many source files and or directo...">SgFile</a> IR nodes and determine what languages are in use! </p>

</div>
</div>
<a id="aa123249fbb8c6372f0aa592f4fd48f49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa123249fbb8c6372f0aa592f4fd48f49">&#9670;&nbsp;</a></span>is_mixed_Fortran_and_C_language()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_DLL_API bool SageInterface::is_mixed_Fortran_and_C_language </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Brief These traverse the memory pool of <a class="el" href="classSgFile.html" title="This class represents a source file for a project (which may contian many source files and or directo...">SgFile</a> IR nodes and determine what languages are in use! </p>

</div>
</div>
<a id="acd295b6d050f7041749938031b6e0c08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd295b6d050f7041749938031b6e0c08">&#9670;&nbsp;</a></span>is_mixed_Fortran_and_Cxx_language()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_DLL_API bool SageInterface::is_mixed_Fortran_and_Cxx_language </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Brief These traverse the memory pool of <a class="el" href="classSgFile.html" title="This class represents a source file for a project (which may contian many source files and or directo...">SgFile</a> IR nodes and determine what languages are in use! </p>

</div>
</div>
<a id="a2e29d19829607759ab655ca1899c4b49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e29d19829607759ab655ca1899c4b49">&#9670;&nbsp;</a></span>is_mixed_Fortran_and_C_and_Cxx_language()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_DLL_API bool SageInterface::is_mixed_Fortran_and_C_and_Cxx_language </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Brief These traverse the memory pool of <a class="el" href="classSgFile.html" title="This class represents a source file for a project (which may contian many source files and or directo...">SgFile</a> IR nodes and determine what languages are in use! </p>

</div>
</div>
<a id="a8f85fe194a694ffb9c31997b2a741d4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f85fe194a694ffb9c31997b2a741d4e">&#9670;&nbsp;</a></span>is_language_case_insensitive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_DLL_API bool SageInterface::is_language_case_insensitive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Brief These traverse the memory pool of <a class="el" href="classSgFile.html" title="This class represents a source file for a project (which may contian many source files and or directo...">SgFile</a> IR nodes and determine what languages are in use! </p>

</div>
</div>
<a id="a20c477556ba32bac8dfa682fb750e30b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20c477556ba32bac8dfa682fb750e30b">&#9670;&nbsp;</a></span>language_may_contain_nondeclarations_in_scope()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_DLL_API bool SageInterface::language_may_contain_nondeclarations_in_scope </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Brief These traverse the memory pool of <a class="el" href="classSgFile.html" title="This class represents a source file for a project (which may contian many source files and or directo...">SgFile</a> IR nodes and determine what languages are in use! </p>

</div>
</div>
<a id="a1035757c3d70027ffd221d21b36af053"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1035757c3d70027ffd221d21b36af053">&#9670;&nbsp;</a></span>resetScopeNumbers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::resetScopeNumbers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgFunctionDefinition.html">SgFunctionDefinition</a> *&#160;</td>
          <td class="paramname"><em>functionDeclaration</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assigns unique numbers to each <a class="el" href="classSgScopeStatement.html" title="This class represents the concept of a scope in C++ (e.g. global scope, fuction scope,...">SgScopeStatement</a> of a function. </p>
<p>This is used to provide unique names for variables and types defined is different nested scopes of a function (used in mangled name generation). </p>

</div>
</div>
<a id="ad3cad455182a3615812ac2597a50bd09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3cad455182a3615812ac2597a50bd09">&#9670;&nbsp;</a></span>clearScopeNumbers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::clearScopeNumbers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgFunctionDefinition.html">SgFunctionDefinition</a> *&#160;</td>
          <td class="paramname"><em>functionDefinition</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the cache of scope,integer pairs for the input function. </p>
<p>This is used to clear the cache of computed unique labels for scopes in a function. This function should be called after any transformation on a function that might effect the allocation of scopes and cause the existing unique numbers to be incorrect. This is part of support to provide unique names for variables and types defined is different nested scopes of a function (used in mangled name generation). </p>

</div>
</div>
<a id="ab456db305882bbb6be21968b59fc865c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab456db305882bbb6be21968b59fc865c">&#9670;&nbsp;</a></span>isPrototypeInScope()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::isPrototypeInScope </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *&#160;</td>
          <td class="paramname"><em>scope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> *&#160;</td>
          <td class="paramname"><em>functionDeclaration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> *&#160;</td>
          <td class="paramname"><em>startingAtDeclaration</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assigns unique numbers to each <a class="el" href="classSgScopeStatement.html" title="This class represents the concept of a scope in C++ (e.g. global scope, fuction scope,...">SgScopeStatement</a> of a function. </p>
<p>This is used to provide unique names for variables and types defined is different nested scopes of a function (used in mangled name generation). </p>

</div>
</div>
<a id="aa037fca8c41eb4a13e47016b217e4413"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa037fca8c41eb4a13e47016b217e4413">&#9670;&nbsp;</a></span>guardNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::guardNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgLocatedNode.html">SgLocatedNode</a> *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>guard</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add preproccessor guard around a given node. </p>
<p>It surrounds the node with "#if guard" and "#endif" </p>

</div>
</div>
<a id="ade0c3a67fbf2f2109657cc551961d236"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade0c3a67fbf2f2109657cc551961d236">&#9670;&nbsp;</a></span>insideSystemHeader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_DLL_API bool SageInterface::insideSystemHeader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgLocatedNode.html">SgLocatedNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set source position info(Sg_File_Info) as transformation generated for all SgNodes in memory pool. </p>
<p>Check if a node is from a system header file </p>

</div>
</div>
<a id="af309b7a1dbd39d4f04fbff270159cf03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af309b7a1dbd39d4f04fbff270159cf03">&#9670;&nbsp;</a></span>isStrictIntegerType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_DLL_API bool SageInterface::isStrictIntegerType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgType.html">SgType</a> *&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a type is an integral type, only allowing signed/unsigned short, int, long, long long. /! /! There is another similar function named <a class="el" href="classSgType.html#ae174dd9127536034ec1d4a70f23b0be7" title="There are many sorts of integer types (this queries an arbitrary type).">SgType::isIntegerType()</a>, which allows additional types char, wchar, and bool to be treated as integer types. </p>
<p>Check if a type is an integral type, only allowing signed/unsigned short, int, long, long long.</p>
<p>There is another similar function named <a class="el" href="classSgType.html#ae174dd9127536034ec1d4a70f23b0be7" title="There are many sorts of integer types (this queries an arbitrary type).">SgType::isIntegerType()</a>, which allows additional types char, wchar, and bool. </p>

</div>
</div>
<a id="a288c109c104a2c9628ca3c0f52410b1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a288c109c104a2c9628ca3c0f52410b1a">&#9670;&nbsp;</a></span>isPureVirtualClass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_DLL_API bool SageInterface::isPureVirtualClass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgType.html">SgType</a> *&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classClassHierarchyWrapper.html">ClassHierarchyWrapper</a> &amp;&#160;</td>
          <td class="paramname"><em>classHierarchy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a class type is a pure virtual class. </p>
<p>True means that there is at least one pure virtual function that has not been overridden. In the case of an incomplete class type (forward declaration), this function returns false. </p>

</div>
</div>
<a id="aed7944b577452c21dcf3aa0597d88d1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed7944b577452c21dcf3aa0597d88d1f">&#9670;&nbsp;</a></span>isPointerToNonConstType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_DLL_API bool SageInterface::isPointerToNonConstType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgType.html">SgType</a> *&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is this a pointer to a non-const type? Note that this function will return true for const pointers pointing to non-const types. </p>
<p>For example, (int* const y) points to a modifiable int, so this function returns true. Meanwhile, it returns false for (int const * x) and (int const * const x) because these types point to a const int. Also, only the outer layer of nested pointers is unwrapped. So the function returns true for (const int ** y), but returns false for const (int * const * x) </p>

</div>
</div>
<a id="a2e3e89b27a800ddbd1b59d5efca6be4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e3e89b27a800ddbd1b59d5efca6be4e">&#9670;&nbsp;</a></span>isScalarType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_DLL_API bool SageInterface::isScalarType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgType.html">SgType</a> *&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is this a scalar type? </p>
<p>We define the following <a class="el" href="classSgType.html" title="This class represents the base class for all types.">SgType</a> as scalar types: char, short, int, long , void, Wchar, Float, double, long long, string, bool, complex, imaginary </p>

</div>
</div>
<a id="a4f543ac715559ff0b76bdf8fd004fc09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f543ac715559ff0b76bdf8fd004fc09">&#9670;&nbsp;</a></span>get_C_array_dimensions() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classSgExpression.html">SgExpression</a>*&gt; SageInterface::get_C_array_dimensions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgArrayType.html">SgArrayType</a> &amp;&#160;</td>
          <td class="paramname"><em>arrtype</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the array dimensions in an array as defined for arrtype </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arrtype</td><td>the type of a C/C++ array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an array that contains an expression indicating each dimension's size. OWNERSHIP of the expressions is TRANSFERED TO the CALLER (which becomes responsible for freeing the expressions). Note, the first entry of the array is a <a class="el" href="classSgNullExpression.html">SgNullExpression</a>, iff the first array dimension was not specified. <div class="fragment"><div class="line"><span class="keywordtype">int</span> x[] = { 1, 2, 3 };</div>
</div><!-- fragment --> note, the expression does not have to be a constant <div class="fragment"><div class="line"><span class="keywordtype">int</span> x[i*5];</div>
</div><!-- fragment --> </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>return-value.empty() == false </dd>
<dd>
return-value[*] != NULL (no nullptr in the returned vector) </dd></dl>

</div>
</div>
<a id="ac4ca57179d072f3577b07b8e33818dca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4ca57179d072f3577b07b8e33818dca">&#9670;&nbsp;</a></span>get_C_array_dimensions() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classSgExpression.html">SgExpression</a>*&gt; SageInterface::get_C_array_dimensions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgArrayType.html">SgArrayType</a> &amp;&#160;</td>
          <td class="paramname"><em>arrtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSgVarRefExp.html">SgVarRefExp</a> &amp;&#160;</td>
          <td class="paramname"><em>varref</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the array dimensions in an array as defined for arrtype </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arrtype</td><td>the type of a C/C++ array </td></tr>
    <tr><td class="paramname">varref</td><td>a reference to an array variable (the variable of type arrtype) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an array that contains an expression indicating each dimension's size. OWNERSHIP of the expressions is TRANSFERED TO the CALLER (which becomes responsible for freeing the expressions). If the first array dimension was not specified an expression that indicates that size is generated. <div class="fragment"><div class="line"><span class="keywordtype">int</span> x[][3] = { 1, 2, 3, 4, 5, 6 };</div>
</div><!-- fragment --> the entry for the first dimension will be: <div class="fragment"><div class="line"><span class="comment">// 3 ... size of 2nd dimension</span></div>
<div class="line"><span class="keyword">sizeof</span>(x) / (<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>) * 3)</div>
</div><!-- fragment --> </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>arrtype is the array-type of varref </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>return-value.empty() == false </dd>
<dd>
return-value[*] != NULL (no nullptr in the returned vector) </dd>
<dd>
!isSgNullExpression(return-value[*]) </dd></dl>

</div>
</div>
<a id="aae2594fcfdf89b9fc795eb4b4c2d04aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae2594fcfdf89b9fc795eb4b4c2d04aa">&#9670;&nbsp;</a></span>get_C_array_dimensions() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classSgExpression.html">SgExpression</a>*&gt; SageInterface::get_C_array_dimensions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgArrayType.html">SgArrayType</a> &amp;&#160;</td>
          <td class="paramname"><em>arrtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgInitializedName.html">SgInitializedName</a> &amp;&#160;</td>
          <td class="paramname"><em>initname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section note"><dt>Note</dt><dd>see get_C_array_dimensions for <a class="el" href="classSgVarRefExp.html" title="This class represents the variable refernece in expressions.">SgVarRefExp</a> for details. </dd></dl>

</div>
</div>
<a id="a835d4c670de3bf57ee1919d6d919ff1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a835d4c670de3bf57ee1919d6d919ff1c">&#9670;&nbsp;</a></span>hasUpcSharedType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_DLL_API bool SageInterface::hasUpcSharedType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgType.html">SgType</a> *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgModifierType.html">SgModifierType</a> **&#160;</td>
          <td class="paramname"><em>mod_type_out</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Has a UPC shared type of any kinds (shared-to-shared, private-to-shared, shared-to-private, shared scalar/array)? An optional parameter, mod_type_out, stores the first <a class="el" href="classSgModifierType.html">SgModifierType</a> with UPC access information. </p>
<p>Note: we classify private-to-shared as 'has shared' type for convenience here. It is indeed a private type in strict sense. AST graph for some examples:</p><ul>
<li>shared scalar: <a class="el" href="classSgModifierType.html">SgModifierType</a> --&gt;base type</li>
<li>shared array: <a class="el" href="classSgArrayType.html">SgArrayType</a> --&gt; SgModiferType --&gt; base type</li>
<li>shared to shared: <a class="el" href="classSgModifierType.html">SgModifierType</a> --&gt; <a class="el" href="classSgPointerType.html">SgPointerType</a> --&gt; <a class="el" href="classSgModifierType.html">SgModifierType</a> -&gt;<a class="el" href="classSgTypeInt.html">SgTypeInt</a></li>
<li>shared to private: <a class="el" href="classSgModifierType.html">SgModifierType</a> --&gt; <a class="el" href="classSgPointerType.html">SgPointerType</a> --&gt; base type</li>
<li>private to shared: <a class="el" href="classSgPointerType.html">SgPointerType</a> --&gt; <a class="el" href="classSgModifierType.html">SgModifierType</a> --&gt; base type </li>
</ul>

</div>
</div>
<a id="a2b96aaaaee6802421214b8e0577a5e76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b96aaaaee6802421214b8e0577a5e76">&#9670;&nbsp;</a></span>isUpcSharedType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_DLL_API bool SageInterface::isUpcSharedType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgType.html">SgType</a> *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgModifierType.html">SgModifierType</a> **&#160;</td>
          <td class="paramname"><em>mod_type_out</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a type is a UPC shared type, including shared array, shared pointers etc. Exclude private pointers to shared types. Optionally return the modifier type with the UPC shared property. </p>
<p>ROSE uses <a class="el" href="classSgArrayType.html">SgArrayType</a> of <a class="el" href="classSgModifierType.html">SgModifierType</a> to represent shared arrays, not <a class="el" href="classSgModifierType.html">SgModifierType</a> points to <a class="el" href="classSgArrayType.html">SgArrayType</a>. Also typedef may cause a chain of nodes before reach the actual <a class="el" href="classSgModifierType.html">SgModifierType</a> with UPC shared property. </p>

</div>
</div>
<a id="a2e362e1e99cbb308cd82da109a4561de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e362e1e99cbb308cd82da109a4561de">&#9670;&nbsp;</a></span>isEquivalentFunctionType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_DLL_API bool SageInterface::isEquivalentFunctionType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgFunctionType.html">SgFunctionType</a> *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSgFunctionType.html">SgFunctionType</a> *&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if two types are equivalent <a class="el" href="classSgFunctionType.html" title="This class represents a type for all functions.">SgFunctionType</a> nodes. </p>
<p>This is necessary for template function types They may differ in one <a class="el" href="classSgTemplateType.html">SgTemplateType</a> pointer but identical otherwise. </p>

</div>
</div>
<a id="a0619c1fe88e3ede3e8406d0fa568d52b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0619c1fe88e3ede3e8406d0fa568d52b">&#9670;&nbsp;</a></span>addStepToLoopBody()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_DLL_API void SageInterface::addStepToLoopBody </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *&#160;</td>
          <td class="paramname"><em>loopStmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgStatement.html">SgStatement</a> *&#160;</td>
          <td class="paramname"><em>step</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a step statement to the end of a loop body Add a new label to the end of the loop, with the step statement after it; then change all continue statements in the old loop body into jumps to the label. </p>
<p>For example: while (a &lt; 5) {if (a &lt; -3) continue;} (adding "a++" to end) becomes while (a &lt; 5) {if (a &lt; -3) goto label; label: a++;} </p>

</div>
</div>
<a id="a87fdcc16e845bf87a4573b72f4a75bc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87fdcc16e845bf87a4573b72f4a75bc2">&#9670;&nbsp;</a></span>moveForStatementIncrementIntoBody()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_DLL_API void SageInterface::moveForStatementIncrementIntoBody </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgForStatement.html">SgForStatement</a> *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a step statement to the end of a loop body Add a new label to the end of the loop, with the step statement after it; then change all continue statements in the old loop body into jumps to the label. </p>
<p>For example: while (a &lt; 5) {if (a &lt; -3) continue;} (adding "a++" to end) becomes while (a &lt; 5) {if (a &lt; -3) goto label; label: a++;} </p>

</div>
</div>
<a id="a41655d6db2668b355c1f15922321a1c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41655d6db2668b355c1f15922321a1c4">&#9670;&nbsp;</a></span>convertForToWhile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_DLL_API void SageInterface::convertForToWhile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgForStatement.html">SgForStatement</a> *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a step statement to the end of a loop body Add a new label to the end of the loop, with the step statement after it; then change all continue statements in the old loop body into jumps to the label. </p>
<p>For example: while (a &lt; 5) {if (a &lt; -3) continue;} (adding "a++" to end) becomes while (a &lt; 5) {if (a &lt; -3) goto label; label: a++;} </p>

</div>
</div>
<a id="a9fbb3d59f96445d192f71db26b7d0b7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fbb3d59f96445d192f71db26b7d0b7d">&#9670;&nbsp;</a></span>convertAllForsToWhiles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_DLL_API void SageInterface::convertAllForsToWhiles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&#160;</td>
          <td class="paramname"><em>top</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a step statement to the end of a loop body Add a new label to the end of the loop, with the step statement after it; then change all continue statements in the old loop body into jumps to the label. </p>
<p>For example: while (a &lt; 5) {if (a &lt; -3) continue;} (adding "a++" to end) becomes while (a &lt; 5) {if (a &lt; -3) goto label; label: a++;} </p>

</div>
</div>
<a id="af8e98aa5fb667b85809a08627d2c6ce5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8e98aa5fb667b85809a08627d2c6ce5">&#9670;&nbsp;</a></span>hasMultipleInitStatmentsOrExpressions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_DLL_API bool SageInterface::hasMultipleInitStatmentsOrExpressions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgForStatement.html">SgForStatement</a> *&#160;</td>
          <td class="paramname"><em>for_loop</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a for loop uses C99 style initialization statement with multiple expressions like for (int i=0, j=0; ..) or for (i=0,j=0;...) </p>
<p>for (int i=0, j=0; ..) is stored as two variable declarations under <a class="el" href="classSgForInitStatement.html" title="This class represents the variable declaration or variable initialization withn a for loop.">SgForInitStatement</a>'s init_stmt member for (i=0,j=0;...) is stored as a single expression statement, with comma expression (i=0,j=0). </p>

</div>
</div>
<a id="abfb6a58a3e9f0ba11756e13e49876a6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfb6a58a3e9f0ba11756e13e49876a6b">&#9670;&nbsp;</a></span>setLoopBody()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_DLL_API void SageInterface::setLoopBody </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *&#160;</td>
          <td class="paramname"><em>loop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgStatement.html">SgStatement</a> *&#160;</td>
          <td class="paramname"><em>body</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a step statement to the end of a loop body Add a new label to the end of the loop, with the step statement after it; then change all continue statements in the old loop body into jumps to the label. </p>
<p>For example: while (a &lt; 5) {if (a &lt; -3) continue;} (adding "a++" to end) becomes while (a &lt; 5) {if (a &lt; -3) goto label; label: a++;} </p>

</div>
</div>
<a id="a444feec21ae8aad3cdee60b48f9b590b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a444feec21ae8aad3cdee60b48f9b590b">&#9670;&nbsp;</a></span>isCanonicalForLoop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_DLL_API bool SageInterface::isCanonicalForLoop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&#160;</td>
          <td class="paramname"><em>loop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgInitializedName.html">SgInitializedName</a> **&#160;</td>
          <td class="paramname"><em>ivar</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgExpression.html">SgExpression</a> **&#160;</td>
          <td class="paramname"><em>lb</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgExpression.html">SgExpression</a> **&#160;</td>
          <td class="paramname"><em>ub</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgExpression.html">SgExpression</a> **&#160;</td>
          <td class="paramname"><em>step</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgStatement.html">SgStatement</a> **&#160;</td>
          <td class="paramname"><em>body</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>hasIncrementalIterationSpace</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>isInclusiveUpperBound</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a for-loop has a canonical form, return loop index, bounds, step, and body if requested. </p>
<p>A canonical form is defined as : one initialization statement, a test expression, and an increment expression , loop index variable should be of an integer type. IsInclusiveUpperBound is true when &lt;= or &gt;= is used for loop condition </p>

</div>
</div>
<a id="aa05371b6de9178ae3c86fcade9e517f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa05371b6de9178ae3c86fcade9e517f4">&#9670;&nbsp;</a></span>forLoopNormalization()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_DLL_API bool SageInterface::forLoopNormalization </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgForStatement.html">SgForStatement</a> *&#160;</td>
          <td class="paramname"><em>loop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>foldConstant</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normalize a for loop, return true if successful. </p>
<p>Generated constants will be fold by default.</p>
<p>Translations are : For the init statement: for (int i=0;... ) becomes int i; for (i=0;..) For test expression: i&lt;x is normalized to i&lt;= (x-1) and i&gt;x is normalized to i&gt;= (x+1) For increment expression: i++ is normalized to i+=1 and i&ndash; is normalized to i+=-1 i-=s is normalized to i+= -s </p>

</div>
</div>
<a id="a7b01217b76e6a7111c1fd575073507df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b01217b76e6a7111c1fd575073507df">&#9670;&nbsp;</a></span>normalizeForLoopIncrement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_DLL_API bool SageInterface::normalizeForLoopIncrement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgForStatement.html">SgForStatement</a> *&#160;</td>
          <td class="paramname"><em>loop</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a step statement to the end of a loop body Add a new label to the end of the loop, with the step statement after it; then change all continue statements in the old loop body into jumps to the label. </p>
<p>For example: while (a &lt; 5) {if (a &lt; -3) continue;} (adding "a++" to end) becomes while (a &lt; 5) {if (a &lt; -3) goto label; label: a++;} </p>

</div>
</div>
<a id="ae633f3cd7e5ec68375c518ab3ff5db1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae633f3cd7e5ec68375c518ab3ff5db1e">&#9670;&nbsp;</a></span>loopCollapsing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgExprListExp.html">SgExprListExp</a>* SageInterface::loopCollapsing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgForStatement.html">SgForStatement</a> *&#160;</td>
          <td class="paramname"><em>target_loop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>collapsing_factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a step statement to the end of a loop body Add a new label to the end of the loop, with the step statement after it; then change all continue statements in the old loop body into jumps to the label. </p>
<p>For example: while (a &lt; 5) {if (a &lt; -3) continue;} (adding "a++" to end) becomes while (a &lt; 5) {if (a &lt; -3) goto label; label: a++;} </p>

</div>
</div>
<a id="ae7cbd683a1b04b01ce52e0e87865bfca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7cbd683a1b04b01ce52e0e87865bfca">&#9670;&nbsp;</a></span>getForLoopInformations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::getForLoopInformations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgForStatement.html">SgForStatement</a> *&#160;</td>
          <td class="paramname"><em>for_loop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgVariableSymbol.html">SgVariableSymbol</a> *&amp;&#160;</td>
          <td class="paramname"><em>iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgExpression.html">SgExpression</a> *&amp;&#160;</td>
          <td class="paramname"><em>lower_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgExpression.html">SgExpression</a> *&amp;&#160;</td>
          <td class="paramname"><em>upper_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgExpression.html">SgExpression</a> *&amp;&#160;</td>
          <td class="paramname"><em>stride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a step statement to the end of a loop body Add a new label to the end of the loop, with the step statement after it; then change all continue statements in the old loop body into jumps to the label. </p>
<p>For example: while (a &lt; 5) {if (a &lt; -3) continue;} (adding "a++" to end) becomes while (a &lt; 5) {if (a &lt; -3) goto label; label: a++;} </p>

</div>
</div>
<a id="ae033e337d88d92aa952932fdb077cbe4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae033e337d88d92aa952932fdb077cbe4">&#9670;&nbsp;</a></span>generateFileList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classSgFile.html">SgFile</a> * &gt; SageInterface::generateFileList </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns STL vector of <a class="el" href="classSgFile.html" title="This class represents a source file for a project (which may contian many source files and or directo...">SgFile</a> IR node pointers. </p>
<p>Demonstrates use of restricted traversal over just <a class="el" href="classSgFile.html" title="This class represents a source file for a project (which may contian many source files and or directo...">SgFile</a> IR nodes. </p>

</div>
</div>
<a id="a7bff575c2c4cabade5616ce55a7c6ebb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bff575c2c4cabade5616ce55a7c6ebb">&#9670;&nbsp;</a></span>getProject() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_DLL_API <a class="el" href="classSgProject.html">SgProject</a>* SageInterface::getProject </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current <a class="el" href="classSgProject.html" title="This class represents a source project, with a list of SgFile objects and global information about th...">SgProject</a> IR Node. </p>
<p>The library should never have more than one project and it asserts such. If no project has been created yet then this function returns the null pointer. </p>

</div>
</div>
<a id="a69e576eae814e9df07c35888a2b47068"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69e576eae814e9df07c35888a2b47068">&#9670;&nbsp;</a></span>getProject() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgProject.html">SgProject</a>* SageInterface::getProject </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgNode.html">SgNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the project associated with a node </dd></dl>

</div>
</div>
<a id="ab3fd7caa53c4504d7d668336d4be8097"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3fd7caa53c4504d7d668336d4be8097">&#9670;&nbsp;</a></span>findBreakStmts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classSgBreakStmt.html">SgBreakStmt</a>*&gt; SageInterface::findBreakStmts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgStatement.html">SgStatement</a> *&#160;</td>
          <td class="paramname"><em>code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fortranLabel</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find break statements inside a particular statement, stopping at nested loops or switches. </p>
<p>loops or switch statements defines their own contexts for break statements. The function will stop immediately if run on a loop or switch statement. If fortranLabel is non-empty, breaks (EXITs) to that label within nested loops are included in the returned list. </p>

</div>
</div>
<a id="ad8f642bb83545acd486c40aeb6f3093f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8f642bb83545acd486c40aeb6f3093f">&#9670;&nbsp;</a></span>findContinueStmts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classSgContinueStmt.html">SgContinueStmt</a>*&gt; SageInterface::findContinueStmts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgStatement.html">SgStatement</a> *&#160;</td>
          <td class="paramname"><em>code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fortranLabel</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find all continue statements inside a particular statement, stopping at nested loops. </p>
<p>Nested loops define their own contexts for continue statements. The function will stop immediately if run on a loop statement. If fortranLabel is non-empty, continues (CYCLEs) to that label within nested loops are included in the returned list. </p>

</div>
</div>
<a id="a0b7def913d21eb6782926fb61ae65520"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b7def913d21eb6782926fb61ae65520">&#9670;&nbsp;</a></span>getEnclosingNode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">NodeType* SageInterface::getEnclosingNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgNode.html">SgNode</a> *&#160;</td>
          <td class="paramname"><em>astNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>includingSelf</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a node by type using upward traversal. </p>
<p>Traverse backward through a specified node's ancestors, starting with the node's parent and progressing to more distant ancestors, to find the first node matching the specified or derived type. If <code>includingSelf</code> is true then the starting node, <code>astNode</code>, is returned if its type matches, otherwise the search starts at the parent of <code>astNode</code>.</p>
<p>For the purposes of this function, the parent (P) of an <a class="el" href="classSgDeclarationStatement.html" title="This class represents the concept of a declaration statement.">SgDeclarationStatement</a> node (N) is considered to be the first non-defining declaration of N if N has both a defining declaration and a first non-defining declaration and the defining declaration is different than the first non-defining declaration.</p>
<p>If no ancestor of the requisite type of subtypes is found then this function returns a null pointer.</p>
<p>If <code>astNode</code> is the null pointer, then the return value is a null pointer. That is, if there is no node, then there cannot be an enclosing node of the specified type. </p>

<p class="definition">Definition at line <a class="el" href="sageInterface_8h_source.html#l01437">1437</a> of file <a class="el" href="sageInterface_8h_source.html">sageInterface.h</a>.</p>

<p class="reference">References <a class="el" href="classSgNode.html#aa8723e70f7512769a015e94ca03224d2">SgNode::class_name()</a>, <a class="el" href="classSgDeclarationStatement.html#a513421834e1f61e1cc936b02f9562363">SgDeclarationStatement::get_definingDeclaration()</a>, <a class="el" href="Cxx__Grammar_8h_source.html#l07416">SgNode::get_file_info()</a>, <a class="el" href="classSgDeclarationStatement.html#ac60b5ad6aa43536c27e02840e2b90d92">SgDeclarationStatement::get_firstNondefiningDeclaration()</a>, and <a class="el" href="classSgNode.html#a3384eb2fc572b3371cd9681121cbefa3">SgNode::get_parent()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceSageInterface_a0b7def913d21eb6782926fb61ae65520_cgraph.png" border="0" usemap="#namespaceSageInterface_a0b7def913d21eb6782926fb61ae65520_cgraph" alt=""/></div>
<map name="namespaceSageInterface_a0b7def913d21eb6782926fb61ae65520_cgraph" id="namespaceSageInterface_a0b7def913d21eb6782926fb61ae65520_cgraph">
<area shape="rect" title="Find a node by type using upward traversal." alt="" coords="5,123,223,149"/>
<area shape="rect" href="classSgNode.html#aa8723e70f7512769a015e94ca03224d2" title="returns a string representing the class name" alt="" coords="303,5,450,32"/>
<area shape="rect" href="classSgDeclarationStatement.html#a513421834e1f61e1cc936b02f9562363" title="This is an access function for the SgDeclarationStatement::p_definingDeclaration data member (see tha..." alt="" coords="293,57,460,98"/>
<area shape="rect" href="classSgNode.html#a1afd70bdff1ae22521e6199f0fddb8e9" title="File information containing filename, line number, column number, and if the SgNode is a part of a ne..." alt="" coords="303,123,450,149"/>
<area shape="rect" href="classSgDeclarationStatement.html#ac60b5ad6aa43536c27e02840e2b90d92" title="This is an access function for the SgDeclarationStatement::p_firstNondefiningDeclaration data member ..." alt="" coords="271,174,483,215"/>
<area shape="rect" href="classSgNode.html#a3384eb2fc572b3371cd9681121cbefa3" title="Access function for parent node." alt="" coords="307,240,446,267"/>
</map>
</div>

</div>
</div>
<a id="a895209065eba0439109f15304bcdfdf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a895209065eba0439109f15304bcdfdf7">&#9670;&nbsp;</a></span>getEnclosingFunctionDefinition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_DLL_API <a class="el" href="classSgFunctionDefinition.html">SgFunctionDefinition</a>* SageInterface::getEnclosingFunctionDefinition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&#160;</td>
          <td class="paramname"><em>astNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>includingSelf</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a node by type using upward traversal. </p>
<p>Traverse backward through a specified node's ancestors, starting with the node's parent and progressing to more distant ancestors, to find the first node matching the specified or derived type. If <code>includingSelf</code> is true then the starting node, <code>astNode</code>, is returned if its type matches, otherwise the search starts at the parent of <code>astNode</code>.</p>
<p>For the purposes of this function, the parent (P) of an <a class="el" href="classSgDeclarationStatement.html" title="This class represents the concept of a declaration statement.">SgDeclarationStatement</a> node (N) is considered to be the first non-defining declaration of N if N has both a defining declaration and a first non-defining declaration and the defining declaration is different than the first non-defining declaration.</p>
<p>If no ancestor of the requisite type of subtypes is found then this function returns a null pointer.</p>
<p>If <code>astNode</code> is the null pointer, then the return value is a null pointer. That is, if there is no node, then there cannot be an enclosing node of the specified type. </p>

</div>
</div>
<a id="a95ca2a6a7a3ce7319e40313bffd34e82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95ca2a6a7a3ce7319e40313bffd34e82">&#9670;&nbsp;</a></span>isInSubTree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_DLL_API bool SageInterface::isInSubTree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgExpression.html">SgExpression</a> *&#160;</td>
          <td class="paramname"><em>subtree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgExpression.html">SgExpression</a> *&#160;</td>
          <td class="paramname"><em>exp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a node by type using upward traversal. </p>
<p>Traverse backward through a specified node's ancestors, starting with the node's parent and progressing to more distant ancestors, to find the first node matching the specified or derived type. If <code>includingSelf</code> is true then the starting node, <code>astNode</code>, is returned if its type matches, otherwise the search starts at the parent of <code>astNode</code>.</p>
<p>For the purposes of this function, the parent (P) of an <a class="el" href="classSgDeclarationStatement.html" title="This class represents the concept of a declaration statement.">SgDeclarationStatement</a> node (N) is considered to be the first non-defining declaration of N if N has both a defining declaration and a first non-defining declaration and the defining declaration is different than the first non-defining declaration.</p>
<p>If no ancestor of the requisite type of subtypes is found then this function returns a null pointer.</p>
<p>If <code>astNode</code> is the null pointer, then the return value is a null pointer. That is, if there is no node, then there cannot be an enclosing node of the specified type. </p>

</div>
</div>
<a id="a6ec90a96c13d6d65ce029d8f2b8b0fbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ec90a96c13d6d65ce029d8f2b8b0fbb">&#9670;&nbsp;</a></span>getFunctionDeclaration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_DLL_API <a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a>* SageInterface::getFunctionDeclaration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgFunctionCallExp.html">SgFunctionCallExp</a> *&#160;</td>
          <td class="paramname"><em>functionCallExp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a node by type using upward traversal. </p>
<p>Traverse backward through a specified node's ancestors, starting with the node's parent and progressing to more distant ancestors, to find the first node matching the specified or derived type. If <code>includingSelf</code> is true then the starting node, <code>astNode</code>, is returned if its type matches, otherwise the search starts at the parent of <code>astNode</code>.</p>
<p>For the purposes of this function, the parent (P) of an <a class="el" href="classSgDeclarationStatement.html" title="This class represents the concept of a declaration statement.">SgDeclarationStatement</a> node (N) is considered to be the first non-defining declaration of N if N has both a defining declaration and a first non-defining declaration and the defining declaration is different than the first non-defining declaration.</p>
<p>If no ancestor of the requisite type of subtypes is found then this function returns a null pointer.</p>
<p>If <code>astNode</code> is the null pointer, then the return value is a null pointer. That is, if there is no node, then there cannot be an enclosing node of the specified type. </p>

</div>
</div>
<a id="ae73fb712147f02a4bb58453ec9dd02db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae73fb712147f02a4bb58453ec9dd02db">&#9670;&nbsp;</a></span>isDataMemberReference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_DLL_API bool SageInterface::isDataMemberReference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgVarRefExp.html">SgVarRefExp</a> *&#160;</td>
          <td class="paramname"><em>varRefExp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a node by type using upward traversal. </p>
<p>Traverse backward through a specified node's ancestors, starting with the node's parent and progressing to more distant ancestors, to find the first node matching the specified or derived type. If <code>includingSelf</code> is true then the starting node, <code>astNode</code>, is returned if its type matches, otherwise the search starts at the parent of <code>astNode</code>.</p>
<p>For the purposes of this function, the parent (P) of an <a class="el" href="classSgDeclarationStatement.html" title="This class represents the concept of a declaration statement.">SgDeclarationStatement</a> node (N) is considered to be the first non-defining declaration of N if N has both a defining declaration and a first non-defining declaration and the defining declaration is different than the first non-defining declaration.</p>
<p>If no ancestor of the requisite type of subtypes is found then this function returns a null pointer.</p>
<p>If <code>astNode</code> is the null pointer, then the return value is a null pointer. That is, if there is no node, then there cannot be an enclosing node of the specified type. </p>

</div>
</div>
<a id="a895a178fcf6d2ae1ddf7d70129f65c4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a895a178fcf6d2ae1ddf7d70129f65c4e">&#9670;&nbsp;</a></span>isAddressTaken()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_DLL_API bool SageInterface::isAddressTaken </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgExpression.html">SgExpression</a> *&#160;</td>
          <td class="paramname"><em>refExp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a node by type using upward traversal. </p>
<p>Traverse backward through a specified node's ancestors, starting with the node's parent and progressing to more distant ancestors, to find the first node matching the specified or derived type. If <code>includingSelf</code> is true then the starting node, <code>astNode</code>, is returned if its type matches, otherwise the search starts at the parent of <code>astNode</code>.</p>
<p>For the purposes of this function, the parent (P) of an <a class="el" href="classSgDeclarationStatement.html" title="This class represents the concept of a declaration statement.">SgDeclarationStatement</a> node (N) is considered to be the first non-defining declaration of N if N has both a defining declaration and a first non-defining declaration and the defining declaration is different than the first non-defining declaration.</p>
<p>If no ancestor of the requisite type of subtypes is found then this function returns a null pointer.</p>
<p>If <code>astNode</code> is the null pointer, then the return value is a null pointer. That is, if there is no node, then there cannot be an enclosing node of the specified type. </p>

</div>
</div>
<a id="a68d95b424c79cb812333cadc730dc965"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68d95b424c79cb812333cadc730dc965">&#9670;&nbsp;</a></span>isMemberFunctionMemberReference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_DLL_API bool SageInterface::isMemberFunctionMemberReference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgMemberFunctionRefExp.html">SgMemberFunctionRefExp</a> *&#160;</td>
          <td class="paramname"><em>memberFunctionRefExp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a node by type using upward traversal. </p>
<p>Traverse backward through a specified node's ancestors, starting with the node's parent and progressing to more distant ancestors, to find the first node matching the specified or derived type. If <code>includingSelf</code> is true then the starting node, <code>astNode</code>, is returned if its type matches, otherwise the search starts at the parent of <code>astNode</code>.</p>
<p>For the purposes of this function, the parent (P) of an <a class="el" href="classSgDeclarationStatement.html" title="This class represents the concept of a declaration statement.">SgDeclarationStatement</a> node (N) is considered to be the first non-defining declaration of N if N has both a defining declaration and a first non-defining declaration and the defining declaration is different than the first non-defining declaration.</p>
<p>If no ancestor of the requisite type of subtypes is found then this function returns a null pointer.</p>
<p>If <code>astNode</code> is the null pointer, then the return value is a null pointer. That is, if there is no node, then there cannot be an enclosing node of the specified type. </p>

</div>
</div>
<a id="ad983cac496e9e4f063e3e628af18ae8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad983cac496e9e4f063e3e628af18ae8e">&#9670;&nbsp;</a></span>getClassTypeChainForMemberReference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_DLL_API std::list&lt;<a class="el" href="classSgClassType.html">SgClassType</a>*&gt; SageInterface::getClassTypeChainForMemberReference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgExpression.html">SgExpression</a> *&#160;</td>
          <td class="paramname"><em>refExp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a node by type using upward traversal. </p>
<p>Traverse backward through a specified node's ancestors, starting with the node's parent and progressing to more distant ancestors, to find the first node matching the specified or derived type. If <code>includingSelf</code> is true then the starting node, <code>astNode</code>, is returned if its type matches, otherwise the search starts at the parent of <code>astNode</code>.</p>
<p>For the purposes of this function, the parent (P) of an <a class="el" href="classSgDeclarationStatement.html" title="This class represents the concept of a declaration statement.">SgDeclarationStatement</a> node (N) is considered to be the first non-defining declaration of N if N has both a defining declaration and a first non-defining declaration and the defining declaration is different than the first non-defining declaration.</p>
<p>If no ancestor of the requisite type of subtypes is found then this function returns a null pointer.</p>
<p>If <code>astNode</code> is the null pointer, then the return value is a null pointer. That is, if there is no node, then there cannot be an enclosing node of the specified type. </p>

</div>
</div>
<a id="ad16762258166f0db940956e9d34daa42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad16762258166f0db940956e9d34daa42">&#9670;&nbsp;</a></span>getFrontendSpecificNodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_DLL_API std::set&lt;<a class="el" href="classSgNode.html">SgNode</a>*&gt; SageInterface::getFrontendSpecificNodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a node by type using upward traversal. </p>
<p>Traverse backward through a specified node's ancestors, starting with the node's parent and progressing to more distant ancestors, to find the first node matching the specified or derived type. If <code>includingSelf</code> is true then the starting node, <code>astNode</code>, is returned if its type matches, otherwise the search starts at the parent of <code>astNode</code>.</p>
<p>For the purposes of this function, the parent (P) of an <a class="el" href="classSgDeclarationStatement.html" title="This class represents the concept of a declaration statement.">SgDeclarationStatement</a> node (N) is considered to be the first non-defining declaration of N if N has both a defining declaration and a first non-defining declaration and the defining declaration is different than the first non-defining declaration.</p>
<p>If no ancestor of the requisite type of subtypes is found then this function returns a null pointer.</p>
<p>If <code>astNode</code> is the null pointer, then the return value is a null pointer. That is, if there is no node, then there cannot be an enclosing node of the specified type. </p>

</div>
</div>
<a id="a96a01e8b47e65d101528627b33201cef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96a01e8b47e65d101528627b33201cef">&#9670;&nbsp;</a></span>outputSharedNodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_DLL_API void SageInterface::outputSharedNodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a node by type using upward traversal. </p>
<p>Traverse backward through a specified node's ancestors, starting with the node's parent and progressing to more distant ancestors, to find the first node matching the specified or derived type. If <code>includingSelf</code> is true then the starting node, <code>astNode</code>, is returned if its type matches, otherwise the search starts at the parent of <code>astNode</code>.</p>
<p>For the purposes of this function, the parent (P) of an <a class="el" href="classSgDeclarationStatement.html" title="This class represents the concept of a declaration statement.">SgDeclarationStatement</a> node (N) is considered to be the first non-defining declaration of N if N has both a defining declaration and a first non-defining declaration and the defining declaration is different than the first non-defining declaration.</p>
<p>If no ancestor of the requisite type of subtypes is found then this function returns a null pointer.</p>
<p>If <code>astNode</code> is the null pointer, then the return value is a null pointer. That is, if there is no node, then there cannot be an enclosing node of the specified type. </p>

</div>
</div>
<a id="af1ca90720fdbe874b92674a64dfda6f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1ca90720fdbe874b92674a64dfda6f6">&#9670;&nbsp;</a></span>displayScope()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_DLL_API void SageInterface::displayScope </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *&#160;</td>
          <td class="paramname"><em>scope</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a node by type using upward traversal. </p>
<p>Traverse backward through a specified node's ancestors, starting with the node's parent and progressing to more distant ancestors, to find the first node matching the specified or derived type. If <code>includingSelf</code> is true then the starting node, <code>astNode</code>, is returned if its type matches, otherwise the search starts at the parent of <code>astNode</code>.</p>
<p>For the purposes of this function, the parent (P) of an <a class="el" href="classSgDeclarationStatement.html" title="This class represents the concept of a declaration statement.">SgDeclarationStatement</a> node (N) is considered to be the first non-defining declaration of N if N has both a defining declaration and a first non-defining declaration and the defining declaration is different than the first non-defining declaration.</p>
<p>If no ancestor of the requisite type of subtypes is found then this function returns a null pointer.</p>
<p>If <code>astNode</code> is the null pointer, then the return value is a null pointer. That is, if there is no node, then there cannot be an enclosing node of the specified type. </p>

</div>
</div>
<a id="abfb5106b3009aa3e60235de6c0417676"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfb5106b3009aa3e60235de6c0417676">&#9670;&nbsp;</a></span>isSameFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_DLL_API bool SageInterface::isSameFunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> *&#160;</td>
          <td class="paramname"><em>func1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> *&#160;</td>
          <td class="paramname"><em>func2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if two function declarations refer to the same one. Two function declarations are the same when they are a) identical, b) same name in C c) same qualified named and mangled name in C++. A nondefining (prototype) declaration and a defining declaration of a same function are treated as the same. </p>
<p>There is a similar function bool compareFunctionDeclarations(SgFunctionDeclaration *f1, SgFunctionDeclaration *f2) from Classhierarchy.C </p>

</div>
</div>
<a id="a3a61d70da92edb2de207a88d648001c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a61d70da92edb2de207a88d648001c3">&#9670;&nbsp;</a></span>hasSimpleChildrenList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_DLL_API bool SageInterface::hasSimpleChildrenList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *&#160;</td>
          <td class="paramname"><em>scope</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a scope statement has a simple children statement list so insert additional statements under the scope is straightforward and unambiguous . </p>
<p>for example, <a class="el" href="classSgBasicBlock.html" title="This class represents the concept of a block (not a basic block from control flow analysis).">SgBasicBlock</a> has a simple statement list while IfStmt does not. </p>

</div>
</div>
<a id="aca3887cc5c23c14b6c0d7cda12f26638"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca3887cc5c23c14b6c0d7cda12f26638">&#9670;&nbsp;</a></span>statementCanBeTransformed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_DLL_API bool SageInterface::statementCanBeTransformed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgStatement.html">SgStatement</a> *&#160;</td>
          <td class="paramname"><em>stmt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If header file unparsing and token-based unparsing are used, then some statements in header files used with the same name and different include syntax can't be transformed. </p>
<p>This is currently because there is no way to generally test the resulting transformed code generated by ROSE. </p>

</div>
</div>
<a id="a8b8089083afe0aca12b1c9ba64d4ddc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b8089083afe0aca12b1c9ba64d4ddc6">&#9670;&nbsp;</a></span>createTempVariableForExpression()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classSgVariableDeclaration.html">SgVariableDeclaration</a>*, <a class="el" href="classSgExpression.html">SgExpression</a>* &gt; SageInterface::createTempVariableForExpression </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgExpression.html">SgExpression</a> *&#160;</td>
          <td class="paramname"><em>expression</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *&#160;</td>
          <td class="paramname"><em>scope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>initializeInDeclaration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgAssignOp.html">SgAssignOp</a> **&#160;</td>
          <td class="paramname"><em>reEvaluate</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an expression, generates a temporary variable whose initializer optionally evaluates that expression. </p>
<p>Then, the var reference expression returned can be used instead of the original expression. The temporary variable created can be reassigned to the expression by the returned <a class="el" href="classSgAssignOp.html">SgAssignOp</a>; this can be used when the expression the variable represents needs to be evaluated. NOTE: This handles reference types correctly by using pointer types for the temporary. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expression</td><td>Expression which will be replaced by a variable </td></tr>
    <tr><td class="paramname">scope</td><td>scope in which the temporary variable will be generated </td></tr>
    <tr><td class="paramname">reEvaluate</td><td>an assignment op to reevaluate the expression. Leave NULL if not needed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>declaration of the temporary variable, and a a variable reference expression to use instead of the original expression. </dd></dl>

</div>
</div>
<a id="a3794dcade911a884337dc00da53007ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3794dcade911a884337dc00da53007ca">&#9670;&nbsp;</a></span>appendArg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_DLL_API <a class="el" href="classSgVariableSymbol.html">SgVariableSymbol</a>* SageInterface::appendArg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgFunctionParameterList.html">SgFunctionParameterList</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgInitializedName.html">SgInitializedName</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append an argument to <a class="el" href="classSgFunctionParameterList.html" title="This class represents the concept of a declaration list.">SgFunctionParameterList</a>, transparently set parent,scope, and symbols for arguments when possible. </p>
<p>We recommend to build <a class="el" href="classSgFunctionParameterList.html" title="This class represents the concept of a declaration list.">SgFunctionParameterList</a> before building a function declaration However, it is still allowed to append new arguments for existing function declarations.  </p>

</div>
</div>
<a id="af0e335f898272797d60d0e9c49b26952"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0e335f898272797d60d0e9c49b26952">&#9670;&nbsp;</a></span>replaceSubexpressionWithStatement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_DLL_API void SageInterface::replaceSubexpressionWithStatement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgExpression.html">SgExpression</a> *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSageInterface_1_1StatementGenerator.html">SageInterface::StatementGenerator</a> *&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to replaceExpressionWithStatement, but with more restrictions. </p>
<p>Assumptions: from is not within the test of a loop or ifStmt, not currently traversing from or the statement it is in </p>

</div>
</div>
<a id="ac2e87704a725fdefd834d8ef9fb0f7df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e87704a725fdefd834d8ef9fb0f7df">&#9670;&nbsp;</a></span>fixVariableReferences()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_DLL_API int SageInterface::fixVariableReferences </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cleanUnusedSymbol</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connect variable reference to the right variable symbols when feasible, return the number of references being fixed. </p>
<p>In AST translation, it is possible to build a variable reference before the variable is being declared. buildVarRefExp() will use fake initialized name and symbol as placeholders to get the work done. Users should call fixVariableReference() when AST is complete and all variable declarations are in place. </p>

</div>
</div>
<a id="ae399a4b7318283b52db2f8f2c405098d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae399a4b7318283b52db2f8f2c405098d">&#9670;&nbsp;</a></span>fixVariableDeclaration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_DLL_API void SageInterface::fixVariableDeclaration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgVariableDeclaration.html">SgVariableDeclaration</a> *&#160;</td>
          <td class="paramname"><em>varDecl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *&#160;</td>
          <td class="paramname"><em>scope</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Patch up symbol, scope, and parent information when a <a class="el" href="classSgVariableDeclaration.html" title="This class represents the concept of a C or C++ variable declaration.">SgVariableDeclaration</a>'s scope is known. </p>
<p>It is possible to build a variable declaration without knowing its scope information during bottom-up construction of AST, though top-down construction is recommended in general. In this case, we have to patch up symbol table, scope and parent information when the scope is known. This function is usually used internally within appendStatment(), <a class="el" href="namespaceSageInterface.html#ac440d2a39c4785a9a699d53c0be37043" title="Insert a statement before or after the target statement within the target&#39;s scope....">insertStatement()</a>. </p>

</div>
</div>
<a id="a3b03db0cf1eb9f5cbeec315ab015a383"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b03db0cf1eb9f5cbeec315ab015a383">&#9670;&nbsp;</a></span>reportModifiedStatements()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_DLL_API void SageInterface::reportModifiedStatements </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connect variable reference to the right variable symbols when feasible, return the number of references being fixed. </p>
<p>In AST translation, it is possible to build a variable reference before the variable is being declared. buildVarRefExp() will use fake initialized name and symbol as placeholders to get the work done. Users should call fixVariableReference() when AST is complete and all variable declarations are in place. </p>

</div>
</div>
<a id="adfd8e3d26a2a1beb04892cd45b3599d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfd8e3d26a2a1beb04892cd45b3599d9">&#9670;&nbsp;</a></span>translateToUseCppDeclarations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_DLL_API void SageInterface::translateToUseCppDeclarations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connect variable reference to the right variable symbols when feasible, return the number of references being fixed. </p>
<p>In AST translation, it is possible to build a variable reference before the variable is being declared. buildVarRefExp() will use fake initialized name and symbol as placeholders to get the work done. Users should call fixVariableReference() when AST is complete and all variable declarations are in place. </p>

</div>
</div>
<a id="a216682e366c10fed891aa0f7bc64939d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a216682e366c10fed891aa0f7bc64939d">&#9670;&nbsp;</a></span>translateScopeToUseCppDeclarations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_DLL_API void SageInterface::translateScopeToUseCppDeclarations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *&#160;</td>
          <td class="paramname"><em>scope</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connect variable reference to the right variable symbols when feasible, return the number of references being fixed. </p>
<p>In AST translation, it is possible to build a variable reference before the variable is being declared. buildVarRefExp() will use fake initialized name and symbol as placeholders to get the work done. Users should call fixVariableReference() when AST is complete and all variable declarations are in place. </p>

</div>
</div>
<a id="aeef675813304392966435ce21f6a5e07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeef675813304392966435ce21f6a5e07">&#9670;&nbsp;</a></span>translateStatementToUseCppDeclarations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_DLL_API std::vector&lt;<a class="el" href="classSgC__PreprocessorDirectiveStatement.html">SgC_PreprocessorDirectiveStatement</a>*&gt; SageInterface::translateStatementToUseCppDeclarations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgStatement.html">SgStatement</a> *&#160;</td>
          <td class="paramname"><em>statement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *&#160;</td>
          <td class="paramname"><em>scope</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connect variable reference to the right variable symbols when feasible, return the number of references being fixed. </p>
<p>In AST translation, it is possible to build a variable reference before the variable is being declared. buildVarRefExp() will use fake initialized name and symbol as placeholders to get the work done. Users should call fixVariableReference() when AST is complete and all variable declarations are in place. </p>

</div>
</div>
<a id="ae6e7a28e98b60cebece16ff72745671d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6e7a28e98b60cebece16ff72745671d">&#9670;&nbsp;</a></span>printOutComments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_DLL_API void SageInterface::printOutComments </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgLocatedNode.html">SgLocatedNode</a> *&#160;</td>
          <td class="paramname"><em>locatedNode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connect variable reference to the right variable symbols when feasible, return the number of references being fixed. </p>
<p>In AST translation, it is possible to build a variable reference before the variable is being declared. buildVarRefExp() will use fake initialized name and symbol as placeholders to get the work done. Users should call fixVariableReference() when AST is complete and all variable declarations are in place. </p>

</div>
</div>
<a id="a0e89a85f2deeced5b205d1a2a2b6ee6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e89a85f2deeced5b205d1a2a2b6ee6c">&#9670;&nbsp;</a></span>skipTranslateToUseCppDeclaration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_DLL_API bool SageInterface::skipTranslateToUseCppDeclaration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPreprocessingInfo.html">PreprocessingInfo</a> *&#160;</td>
          <td class="paramname"><em>currentPreprocessingInfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connect variable reference to the right variable symbols when feasible, return the number of references being fixed. </p>
<p>In AST translation, it is possible to build a variable reference before the variable is being declared. buildVarRefExp() will use fake initialized name and symbol as placeholders to get the work done. Users should call fixVariableReference() when AST is complete and all variable declarations are in place. </p>

</div>
</div>
<a id="aa823b7da7e7886d02285ae21b06dff55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa823b7da7e7886d02285ae21b06dff55">&#9670;&nbsp;</a></span>outputFileIds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_DLL_API void SageInterface::outputFileIds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connect variable reference to the right variable symbols when feasible, return the number of references being fixed. </p>
<p>In AST translation, it is possible to build a variable reference before the variable is being declared. buildVarRefExp() will use fake initialized name and symbol as placeholders to get the work done. Users should call fixVariableReference() when AST is complete and all variable declarations are in place. </p>

</div>
</div>
<a id="a2e66b833bf8ffbf3e4774c82f0bb8f58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e66b833bf8ffbf3e4774c82f0bb8f58">&#9670;&nbsp;</a></span>updateDefiningNondefiningLinks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_DLL_API void SageInterface::updateDefiningNondefiningLinks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> *&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *&#160;</td>
          <td class="paramname"><em>scope</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update defining and nondefining links due to a newly introduced function declaration. Should be used after inserting the function into a scope. </p>
<p>This function not only set the defining and nondefining links of the newly introduced function declaration inside a scope, but also update other same function declarations' links accordingly if there are any. Assumption: The function has already inserted/appended/prepended into the scope before calling this function. </p>

</div>
</div>
<a id="acb7038f93f8354d26c8641dc4ca5b2a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb7038f93f8354d26c8641dc4ca5b2a0">&#9670;&nbsp;</a></span>constantFolding()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_DLL_API void SageInterface::constantFolding </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constant folding an AST subtree rooted at 'r' (replacing its children with their constant values, if applicable). Please be advised that constant folding on floating point computation may decrease the accuracy of floating point computations! </p>
<p>It is a wrapper function for ConstantFolding::constantFoldingOptimization(). Note that only r's children are replaced with their corresponding constant values, not the input <a class="el" href="classSgNode.html" title="This class represents the base class for all IR nodes within Sage III.">SgNode</a> r itself. You have to call this upon an expression's parent node if you want to fold the expression. </p>

</div>
</div>
<a id="a858801122e8d6dc4092d8d1be887f7c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a858801122e8d6dc4092d8d1be887f7c7">&#9670;&nbsp;</a></span>instrumentEndOfFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_DLL_API int SageInterface::instrumentEndOfFunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> *&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgStatement.html">SgStatement</a> *&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Instrument(Add a statement, often a function call) into a function right before the return points, handle multiple return statements (with duplicated statement s) and return expressions with side effects. Return the number of statements inserted. </p>
<p>Useful when adding a runtime library call to terminate the runtime system right before the end of a program, especially for OpenMP and UPC runtime systems. Return with complex expressions with side effects are rewritten using an additional assignment statement. </p>

</div>
</div>
<a id="a58c825e46324c42bd29985287325cb85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58c825e46324c42bd29985287325cb85">&#9670;&nbsp;</a></span>mergeDeclarationAndAssignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_DLL_API bool SageInterface::mergeDeclarationAndAssignment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgVariableDeclaration.html">SgVariableDeclaration</a> *&#160;</td>
          <td class="paramname"><em>decl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgExprStatement.html">SgExprStatement</a> *&#160;</td>
          <td class="paramname"><em>assign_stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>removeAssignStmt</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merge a variable assignment statement into a matching variable declaration statement. Callers should make sure the merge is semantically correct (by not introducing compilation errors). This function simply does the merge transformation, without eligibility check. </p>
<p>e.g. int i; i=10; becomes int i=10; the original i=10 will be deleted after the merge if success, return true, otherwise return false (e.g. variable declaration does not match or already has an initializer) The original assignment stmt will be removed by default This function is a bit ambiguous about the merge direction, to be phased out. </p>

</div>
</div>
<a id="a23cd9b9813deca2a78b89fa23050769a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23cd9b9813deca2a78b89fa23050769a">&#9670;&nbsp;</a></span>mergeDeclarationWithAssignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_DLL_API bool SageInterface::mergeDeclarationWithAssignment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgVariableDeclaration.html">SgVariableDeclaration</a> *&#160;</td>
          <td class="paramname"><em>decl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgExprStatement.html">SgExprStatement</a> *&#160;</td>
          <td class="paramname"><em>assign_stmt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merge a declaration statement into a matching followed variable assignment. Callers should make sure the merge is semantically correct (by not introducing compilation errors). This function simply does the merge transformation, without eligibility check. </p>
<p>e.g. int i; i=10; becomes int i=10; the original int i; will be deleted after the merge </p>

</div>
</div>
<a id="a4e070f3a6d02e8cf1cb52a8b6b8e7074"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e070f3a6d02e8cf1cb52a8b6b8e7074">&#9670;&nbsp;</a></span>splitVariableDeclaration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_DLL_API <a class="el" href="classSgExprStatement.html">SgExprStatement</a>* SageInterface::splitVariableDeclaration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgVariableDeclaration.html">SgVariableDeclaration</a> *&#160;</td>
          <td class="paramname"><em>decl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split a variable declaration with an rhs assignment into two statements: a declaration and an assignment. </p>
<p>Return the generated assignment statement, if any e.g. int i =10; becomes int i; i=10; This can be seen as a normalization of declarations </p>

</div>
</div>
<a id="aa7eb5f0b0548361570d7dc218a63dd34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7eb5f0b0548361570d7dc218a63dd34">&#9670;&nbsp;</a></span>splitExpression()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_DLL_API <a class="el" href="classSgAssignInitializer.html">SgAssignInitializer</a>* SageInterface::splitExpression </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgExpression.html">SgExpression</a> *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>newName</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace an expression with a temporary variable and an assignment statement. </p>
<p>Add a new temporary variable to contain the value of 'from'. Change reference to 'from' to use this new variable. Assumptions: (1)'from' is not within the test of a loop or 'if'; (2)not currently traversing 'from' or the statement it is in. Return value: the new temp variable declaration's assign initializer containing the from expression. </p>

</div>
</div>
<a id="a7c34b2c7c9c66106eb13c6d253217b5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c34b2c7c9c66106eb13c6d253217b5e">&#9670;&nbsp;</a></span>getIntegerConstantValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long long SageInterface::getIntegerConstantValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgValueExp.html">SgValueExp</a> *&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the constant value from a constant integer expression; abort on everything else. </p>
<p>Note that signed long longs are converted to unsigned. </p>

</div>
</div>
<a id="adb9d4a03d11809413cca4cac1dfc18a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb9d4a03d11809413cca4cac1dfc18a7">&#9670;&nbsp;</a></span>wrapFunction() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classSgStatement.html">SgStatement</a>*, <a class="el" href="classSgInitializedName.html">SgInitializedName</a>*&gt; SageInterface::wrapFunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> &amp;&#160;</td>
          <td class="paramname"><em>definingDeclaration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgName.html">SgName</a>&#160;</td>
          <td class="paramname"><em>newName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>moves the body of a function f to a new function f<code>; f's body is replaced with code that forwards the call to f</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>a pair indicating the statement containing the call of f` and an initialized name refering to the temporary variable holding the result of f`. In case f returns void the initialized name is NULL. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">definingDeclaration</td><td>the defining function declaration of f </td></tr>
    <tr><td class="paramname">newName</td><td>the name of function f<code> \details f's new body becomes { f</code>(...); } and { int res = f`(...); return res; } for functions returning void and a value, respectively. two function declarations are inserted in f's enclosing scope <div class="fragment"><div class="line">result_type f`(...);                       &lt;--- (1)</div>
<div class="line">result_type f (...) { forward call to f` }</div>
<div class="line">result_type f`(...) { original code }      &lt;--- (2)</div>
</div><!-- fragment --> Calls to f are not updated, thus in the transformed code all calls will continue calling f (this is also true for recursive function calls from within the body of f`). After the function has created the wrapper, definingDeclaration becomes the wrapper function The definition of f<code>is the next entry in the statement list; the forward declaration of f</code> is the previous entry in the statement list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>definingDeclaration must be a defining declaration of a free standing function. typeid(SgFunctionDeclaration) == typeid(definingDeclaration) i.e., this function is NOT implemented for class member functions, template functions, procedures, etc. </dd></dl>

<p class="reference">Referenced by <a class="el" href="sageInterface_8h_source.html#l02483">wrapFunction()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceSageInterface_adb9d4a03d11809413cca4cac1dfc18a7_icgraph.png" border="0" usemap="#namespaceSageInterface_adb9d4a03d11809413cca4cac1dfc18a7_icgraph" alt=""/></div>
<map name="namespaceSageInterface_adb9d4a03d11809413cca4cac1dfc18a7_icgraph" id="namespaceSageInterface_adb9d4a03d11809413cca4cac1dfc18a7_icgraph">
<area shape="rect" title="moves the body of a function f to a new function f; f&#39;s body is replaced with code that forwards the ..." alt="" coords="243,5,432,32"/>
<area shape="rect" href="namespaceSageInterface.html#a3d8723ca83cd39f49fac552109ce6928" title="This is an overloaded member function, provided for convenience. It differs from the above function o..." alt="" coords="5,5,195,32"/>
</map>
</div>

</div>
</div>
<a id="a3d8723ca83cd39f49fac552109ce6928"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d8723ca83cd39f49fac552109ce6928">&#9670;&nbsp;</a></span>wrapFunction() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NameGen &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classSgStatement.html">SgStatement</a>*, <a class="el" href="classSgInitializedName.html">SgInitializedName</a>*&gt; SageInterface::wrapFunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> &amp;&#160;</td>
          <td class="paramname"><em>definingDeclaration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NameGen&#160;</td>
          <td class="paramname"><em>nameGen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">NameGen</td><td>functor that generates a new name based on the old name. interface: <a class="el" href="classSgName.html" title="This class represents strings within the IR nodes.">SgName</a> nameGen(const SgName&amp;) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nameGen</td><td>name generator</td></tr>
  </table>
  </dd>
</dl>
<p>see wrapFunction for details </p>

<p class="definition">Definition at line <a class="el" href="sageInterface_8h_source.html#l02483">2483</a> of file <a class="el" href="sageInterface_8h_source.html">sageInterface.h</a>.</p>

<p class="reference">References <a class="el" href="namespaceSageInterface.html#adb9d4a03d11809413cca4cac1dfc18a7">wrapFunction()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceSageInterface_a3d8723ca83cd39f49fac552109ce6928_cgraph.png" border="0" usemap="#namespaceSageInterface_a3d8723ca83cd39f49fac552109ce6928_cgraph" alt=""/></div>
<map name="namespaceSageInterface_a3d8723ca83cd39f49fac552109ce6928_cgraph" id="namespaceSageInterface_a3d8723ca83cd39f49fac552109ce6928_cgraph">
<area shape="rect" title="This is an overloaded member function, provided for convenience. It differs from the above function o..." alt="" coords="5,5,195,32"/>
<area shape="rect" href="namespaceSageInterface.html#adb9d4a03d11809413cca4cac1dfc18a7" title="moves the body of a function f to a new function f; f&#39;s body is replaced with code that forwards the ..." alt="" coords="243,5,432,32"/>
</map>
</div>

</div>
</div>
<a id="a404510d4e75e1303dbfbfe9ada829802"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a404510d4e75e1303dbfbfe9ada829802">&#9670;&nbsp;</a></span>isTemplateInstantiationFromTemplateDeclarationSatisfyingFilter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::isTemplateInstantiationFromTemplateDeclarationSatisfyingFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function detects template instantiations that are relevant when filters are used. </p>
<p>EDG normalizes some in-class template functions and member functions to be redefined outside of a class. this causes the associated template instantiations to be declared outside of the class, and to be marked as compiler generated (since the compiler generated form outside of the class declaration). ROSE captures the function definitions, but in the new location (defined outside of the class declaration). This can confuse some simple tests for template instantiations that are a part of definitions in a file, thus we have this function to detect this specific normalization. </p>

<p class="definition">Definition at line <a class="el" href="sageInterface_8h_source.html#l02804">2804</a> of file <a class="el" href="sageInterface_8h_source.html">sageInterface.h</a>.</p>

<p class="reference">References <a class="el" href="classSgDeclarationStatement.html#ac60b5ad6aa43536c27e02840e2b90d92">SgDeclarationStatement::get_firstNondefiningDeclaration()</a>, <a class="el" href="classSgTemplateInstantiationMemberFunctionDecl.html#ad9551393bbd65620fef53d3889403667">SgTemplateInstantiationMemberFunctionDecl::get_templateDeclaration()</a>, and <a class="el" href="classSgTemplateInstantiationFunctionDecl.html#a6a9d1da707b6b48f1a2aa93801523feb">SgTemplateInstantiationFunctionDecl::get_templateDeclaration()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceSageInterface_a404510d4e75e1303dbfbfe9ada829802_cgraph.png" border="0" usemap="#namespaceSageInterface_a404510d4e75e1303dbfbfe9ada829802_cgraph" alt=""/></div>
<map name="namespaceSageInterface_a404510d4e75e1303dbfbfe9ada829802_cgraph" id="namespaceSageInterface_a404510d4e75e1303dbfbfe9ada829802_cgraph">
<area shape="rect" title="This function detects template instantiations that are relevant when filters are used." alt="" coords="5,63,248,119"/>
<area shape="rect" href="classSgDeclarationStatement.html#ac60b5ad6aa43536c27e02840e2b90d92" title="This is an access function for the SgDeclarationStatement::p_firstNondefiningDeclaration data member ..." alt="" coords="314,5,526,47"/>
<area shape="rect" href="classSgTemplateInstantiationMemberFunctionDecl.html#ad9551393bbd65620fef53d3889403667" title="Returns pointer to SgTemplateDeclaration from which instantiation is generated." alt="" coords="296,71,544,112"/>
<area shape="rect" href="classSgTemplateInstantiationFunctionDecl.html#a6a9d1da707b6b48f1a2aa93801523feb" title="Returns pointer to SgTemplateDeclaration from which instantiation is generated." alt="" coords="314,136,526,177"/>
</map>
</div>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Dec 8 2022 21:18:51 for ROSE by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
