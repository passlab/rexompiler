<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROSE: AstAttribute Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="ROSE"/>
<link href="roseDoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ROSE
   &#160;<span id="projectnumber">0.11.96.11</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,true,'search.html','Search');
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classAstAttribute-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">AstAttribute Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>Base class for all IR node attribute values. </p>
<p>This is the base class for all attribute values stored in the Sage IR node using the <a class="el" href="classAstAttributeMechanism.html">AstAttributeMechanism</a>. IR node attributes are polymorphic based on this abstract class, and are always allocated on the heap. Once the attribute value is handed to an attribute container method the container owns the value and is reponsible for deleting it. In the case of methods that only optionally insert a value, the value is deleted immediately if it's not inserted. But see <a class="el" href="classAstAttribute.html#a9b2ca3a6f23e3408adfed7f3856e5d21">getOwnershipPolicy</a> for additional information.</p>
<p>The underlying <a class="el" href="namespaceSawyer_1_1Attribute.html">Sawyer::Attribute</a> mechanism can store values of any type, including POD, 3rd party types, and pointers. On the other hand, the <a class="el" href="classAstAttributeMechanism.html">AstAttributeMechanism</a> interface described here stores only pointers to values allocated on the stack, owns those values, and supports operations that are useful specifically in IR nodes.</p>
<p>Subclasses should each implement a virtual <a class="el" href="classAstAttribute.html#afde475da251d23d4b873550fce74881a">copy</a> constructor, which should allocate a new copy of the value. The implementation in this base class returns a null pointer, which means that the attribute is not copied into a new AST node when its AST node is copied. If a subclass fails to implement the virtual copy constructor and a superclass has an implementation that return non-null, then copying the AST node will copy only the superclass part of the attribute and the new attribute will have the dynamic type of the superclass&ndash;probably not what you want!</p>
<p>For a more detailed description of using attributes in ROSE (and your own classes) see <a class="el" href="group__attributes.html">Working with attributes</a>. </p>

<p class="definition">Definition at line <a class="el" href="AstAttributeMechanism_8h_source.html#l00035">35</a> of file <a class="el" href="AstAttributeMechanism_8h_source.html">AstAttributeMechanism.h</a>.</p>
</div>
<p><code>#include &lt;<a class="el" href="AstAttributeMechanism_8h_source.html">midend/astProcessing/AstAttributeMechanism.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for AstAttribute:</div>
<div class="dyncontent">
<div class="center"><img src="classAstAttribute__inherit__graph.png" border="0" usemap="#AstAttribute_inherit__map" alt="Inheritance graph"/></div>
<map name="AstAttribute_inherit__map" id="AstAttribute_inherit__map">
<area shape="rect" title="Base class for all IR node attribute values." alt="" coords="5,349,96,376"/>
<area shape="rect" href="classAstRegExAttribute.html" title="Attribute containing a regex expression as a string." alt="" coords="180,5,311,32"/>
<area shape="rect" href="classAstTextAttribute.html" title=" " alt="" coords="187,56,303,83"/>
<area shape="rect" href="classAstValueAttribute.html" title="IR node attribute that stores a copyable value." alt="" coords="168,200,323,227"/>
<area shape="rect" href="classAstValueAttribute.html" title=" " alt="" coords="555,118,686,159"/>
<area shape="rect" href="classAstValueAttribute.html" title=" " alt="" coords="555,197,686,238"/>
<area shape="rect" href="classAstValueAttribute.html" title=" " alt="" coords="531,287,711,329"/>
<area shape="rect" href="classMetricAttribute.html" title="Attribute corresponding to a metric." alt="" coords="192,375,299,401"/>
<area shape="rect" href="classnumCallersAttribute.html" title=" " alt="" coords="177,425,314,452"/>
<area shape="rect" href="classSageInterface_1_1UniqueNameAttribute.html" title="A persistent attribute to represent a unique name for an expression." alt="" coords="152,477,339,518"/>
<area shape="rect" href="classssa__private_1_1VarUniqueName.html" title="Class holding a unique name for a variable." alt="" coords="149,543,341,569"/>
<area shape="rect" href="classStaticCFG_1_1CFGEdgeAttribute.html" title=" " alt="" coords="146,594,345,635"/>
<area shape="rect" href="classStaticCFG_1_1CFGNodeAttribute.html" title="This class stores index of each node as an attribuite of SgGraphNode." alt="" coords="145,660,345,687"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAstAttribute_1_1AttributeEdgeInfo.html">AttributeEdgeInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Support for attibutes to specify edges in the dot graphs.  <a href="classAstAttribute_1_1AttributeEdgeInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAstAttribute_1_1AttributeNodeInfo.html">AttributeNodeInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Support for adding nodes to DOT graphs.  <a href="classAstAttribute_1_1AttributeNodeInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ab82a227fa3befab83ec49a8bc64d8884"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAstAttribute.html#ab82a227fa3befab83ec49a8bc64d8884">OwnershipPolicy</a> { <br />
&#160;&#160;<a class="el" href="classAstAttribute.html#ab82a227fa3befab83ec49a8bc64d8884aee6f0ddaa9ca9fe05aabf769e617d959">CONTAINER_OWNERSHIP</a>, 
<br />
&#160;&#160;<a class="el" href="classAstAttribute.html#ab82a227fa3befab83ec49a8bc64d8884a10ea36f5ab6089a2cddbb0f9fd00fb61">NO_OWNERSHIP</a>, 
<br />
&#160;&#160;<a class="el" href="classAstAttribute.html#ab82a227fa3befab83ec49a8bc64d8884ac5bbb8c9cd61e5092be5a0b10d26c390">CUSTOM_OWNERSHIP</a>, 
<br />
&#160;&#160;<a class="el" href="classAstAttribute.html#ab82a227fa3befab83ec49a8bc64d8884a956bf70e4a4cc6b9c10d8c12a52e73a0">UNKNOWN_OWNERSHIP</a>
<br />
 }</td></tr>
<tr class="memdesc:ab82a227fa3befab83ec49a8bc64d8884"><td class="mdescLeft">&#160;</td><td class="mdescRight">Who owns this attribute.  <a href="classAstAttribute.html#ab82a227fa3befab83ec49a8bc64d8884">More...</a><br /></td></tr>
<tr class="separator:ab82a227fa3befab83ec49a8bc64d8884"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9b2ca3a6f23e3408adfed7f3856e5d21"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classAstAttribute.html#ab82a227fa3befab83ec49a8bc64d8884">OwnershipPolicy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAstAttribute.html#a9b2ca3a6f23e3408adfed7f3856e5d21">getOwnershipPolicy</a> () const</td></tr>
<tr class="memdesc:a9b2ca3a6f23e3408adfed7f3856e5d21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Who owns this attribute.  <a href="classAstAttribute.html#a9b2ca3a6f23e3408adfed7f3856e5d21">More...</a><br /></td></tr>
<tr class="separator:a9b2ca3a6f23e3408adfed7f3856e5d21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa01297c1e1e4469aba044bf6650456eb"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classAstAttribute.html">AstAttribute</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAstAttribute.html#aa01297c1e1e4469aba044bf6650456eb">constructor</a> () const</td></tr>
<tr class="memdesc:aa01297c1e1e4469aba044bf6650456eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual default constructor.  <a href="classAstAttribute.html#aa01297c1e1e4469aba044bf6650456eb">More...</a><br /></td></tr>
<tr class="separator:aa01297c1e1e4469aba044bf6650456eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afde475da251d23d4b873550fce74881a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classAstAttribute.html">AstAttribute</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAstAttribute.html#afde475da251d23d4b873550fce74881a">copy</a> () const</td></tr>
<tr class="memdesc:afde475da251d23d4b873550fce74881a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual copy constructor.  <a href="classAstAttribute.html#afde475da251d23d4b873550fce74881a">More...</a><br /></td></tr>
<tr class="separator:afde475da251d23d4b873550fce74881a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4f6a33d10e5d131a9fadfd0badcfb8d"><td class="memItemLeft" align="right" valign="top"><a id="aa4f6a33d10e5d131a9fadfd0badcfb8d"></a>
virtual <a class="el" href="classAstAttribute.html">AstAttribute</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>copy</b> ()</td></tr>
<tr class="separator:aa4f6a33d10e5d131a9fadfd0badcfb8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7b2177c686e996dd455c1f7ab9ecab6"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAstAttribute.html#aa7b2177c686e996dd455c1f7ab9ecab6">attribute_class_name</a> () const</td></tr>
<tr class="memdesc:aa7b2177c686e996dd455c1f7ab9ecab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attribute class name.  <a href="classAstAttribute.html#aa7b2177c686e996dd455c1f7ab9ecab6">More...</a><br /></td></tr>
<tr class="separator:aa7b2177c686e996dd455c1f7ab9ecab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b2bceb4c2df9f3681cf4452880b5493"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAstAttribute.html#a5b2bceb4c2df9f3681cf4452880b5493">toString</a> ()</td></tr>
<tr class="memdesc:a5b2bceb4c2df9f3681cf4452880b5493"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an attribute to a string.  <a href="classAstAttribute.html#a5b2bceb4c2df9f3681cf4452880b5493">More...</a><br /></td></tr>
<tr class="separator:a5b2bceb4c2df9f3681cf4452880b5493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af803af748ef1a2947c8752fb194a13ce"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAstAttribute.html#af803af748ef1a2947c8752fb194a13ce">commentOutNodeInGraph</a> ()</td></tr>
<tr class="memdesc:af803af748ef1a2947c8752fb194a13ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eliminate IR nodes in DOT graphs.  <a href="classAstAttribute.html#af803af748ef1a2947c8752fb194a13ce">More...</a><br /></td></tr>
<tr class="separator:af803af748ef1a2947c8752fb194a13ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a3ae6fd15a2773a56581e04bb5fa136e5"><td class="memItemLeft" align="right" valign="top"><a id="a3ae6fd15a2773a56581e04bb5fa136e5"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAstAttribute.html#a3ae6fd15a2773a56581e04bb5fa136e5">packed_size</a> ()</td></tr>
<tr class="memdesc:a3ae6fd15a2773a56581e04bb5fa136e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packing support. <br /></td></tr>
<tr class="separator:a3ae6fd15a2773a56581e04bb5fa136e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d114de98f34f74a6fd19ba9b5668688"><td class="memItemLeft" align="right" valign="top"><a id="a8d114de98f34f74a6fd19ba9b5668688"></a>
virtual char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAstAttribute.html#a8d114de98f34f74a6fd19ba9b5668688">packed_data</a> ()</td></tr>
<tr class="memdesc:a8d114de98f34f74a6fd19ba9b5668688"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packing support. <br /></td></tr>
<tr class="separator:a8d114de98f34f74a6fd19ba9b5668688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72e8354d44d877d1e65127e132657a73"><td class="memItemLeft" align="right" valign="top"><a id="a72e8354d44d877d1e65127e132657a73"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAstAttribute.html#a72e8354d44d877d1e65127e132657a73">unpacked_data</a> (int size, char *data)</td></tr>
<tr class="memdesc:a72e8354d44d877d1e65127e132657a73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packing support. <br /></td></tr>
<tr class="separator:a72e8354d44d877d1e65127e132657a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a7badc2c9e81f2174c4eb77988e5e657a"><td class="memItemLeft" align="right" valign="top"><a id="a7badc2c9e81f2174c4eb77988e5e657a"></a>
virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAstAttribute.html#a7badc2c9e81f2174c4eb77988e5e657a">additionalNodeOptions</a> ()</td></tr>
<tr class="memdesc:a7badc2c9e81f2174c4eb77988e5e657a"><td class="mdescLeft">&#160;</td><td class="mdescRight">DOT support. <br /></td></tr>
<tr class="separator:a7badc2c9e81f2174c4eb77988e5e657a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb1060515be80599f3cca23d474be78b"><td class="memItemLeft" align="right" valign="top"><a id="aeb1060515be80599f3cca23d474be78b"></a>
virtual std::vector&lt; <a class="el" href="classAstAttribute_1_1AttributeEdgeInfo.html">AttributeEdgeInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAstAttribute.html#aeb1060515be80599f3cca23d474be78b">additionalEdgeInfo</a> ()</td></tr>
<tr class="memdesc:aeb1060515be80599f3cca23d474be78b"><td class="mdescLeft">&#160;</td><td class="mdescRight">DOT support. <br /></td></tr>
<tr class="separator:aeb1060515be80599f3cca23d474be78b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad0a4edcda6d64fafc769a7ac556ed84"><td class="memItemLeft" align="right" valign="top"><a id="aad0a4edcda6d64fafc769a7ac556ed84"></a>
virtual std::vector&lt; <a class="el" href="classAstAttribute_1_1AttributeNodeInfo.html">AttributeNodeInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAstAttribute.html#aad0a4edcda6d64fafc769a7ac556ed84">additionalNodeInfo</a> ()</td></tr>
<tr class="memdesc:aad0a4edcda6d64fafc769a7ac556ed84"><td class="mdescLeft">&#160;</td><td class="mdescRight">DOT support. <br /></td></tr>
<tr class="separator:aad0a4edcda6d64fafc769a7ac556ed84"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="ab82a227fa3befab83ec49a8bc64d8884"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab82a227fa3befab83ec49a8bc64d8884">&#9670;&nbsp;</a></span>OwnershipPolicy</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classAstAttribute.html#ab82a227fa3befab83ec49a8bc64d8884">AstAttribute::OwnershipPolicy</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Who owns this attribute. </p>
<p>See <a class="el" href="classAstAttribute.html#a9b2ca3a6f23e3408adfed7f3856e5d21">getOwnershipPolicy</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ab82a227fa3befab83ec49a8bc64d8884aee6f0ddaa9ca9fe05aabf769e617d959"></a>CONTAINER_OWNERSHIP&#160;</td><td class="fielddoc"><p>Container owns attribute. </p>
<p>New subclasses should use this! </p>
</td></tr>
<tr><td class="fieldname"><a id="ab82a227fa3befab83ec49a8bc64d8884a10ea36f5ab6089a2cddbb0f9fd00fb61"></a>NO_OWNERSHIP&#160;</td><td class="fielddoc"><p>Attributes are always leaked. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab82a227fa3befab83ec49a8bc64d8884ac5bbb8c9cd61e5092be5a0b10d26c390"></a>CUSTOM_OWNERSHIP&#160;</td><td class="fielddoc"><p>Subclass defines ownership policy. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab82a227fa3befab83ec49a8bc64d8884a956bf70e4a4cc6b9c10d8c12a52e73a0"></a>UNKNOWN_OWNERSHIP&#160;</td><td class="fielddoc"><p>Default for old subclasses. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="AstAttributeMechanism_8h_source.html#l00040">40</a> of file <a class="el" href="AstAttributeMechanism_8h_source.html">AstAttributeMechanism.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9b2ca3a6f23e3408adfed7f3856e5d21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b2ca3a6f23e3408adfed7f3856e5d21">&#9670;&nbsp;</a></span>getOwnershipPolicy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classAstAttribute.html#ab82a227fa3befab83ec49a8bc64d8884">OwnershipPolicy</a> AstAttribute::getOwnershipPolicy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Who owns this attribute. </p>
<p>The original implementation of this class from the early 2000's did not have clear rules about who owned a heap-allocated attribute. The documentation was silent on the issue, and the implementation seemed to imply that container ownership was intended but was then commented out at some point. Any ownership policy should have the following properties:</p>
<ul>
<li>Attributes allocated on the heap should not be leaked. For instance, if an AST is deleted, then the attributes that were referenced by the AST nodes should also be eventually deleted. </li>
<li>The mechanism should not place undue burden on the user. For instance, if a user copies and later deletes an AST to which some analysis has attached attributes, the user should not need to be concerned with deleting attributes stored in the copy. </li>
<li>The mechanism should be able to support either deep or shallow attribute copies as appropriate for the attribute. The deep vs. shallow copying policy is implemented by the virtual <a class="el" href="classAstAttribute.html#afde475da251d23d4b873550fce74881a">copy</a> method, which must coordinate with the ownership policy to ensure no leaks.</li>
</ul>
<p>We define four ownership policies, although from the standpoint of an attribute container there are really only two: the container either deletes attributes or doesn't delete attributes. The four ownership policies are:</p>
<ul>
<li><code>CONTAINER_OWHERSHIP:</code> The simple approach to ownership, and the one that we recommend for all new attribute subclasses, is that the attribute container owns the attributes. When the container is copied (e.g., as part of copying an AST node) then it invokes the <a class="el" href="classAstAttribute.html#afde475da251d23d4b873550fce74881a">copy</a> methods of its attributes, and when the container is deleted (e.g., as part of deleting an AST node) then it explicitly deletes its attributes. This policy is an "allocate and
    forget" approach: once the creator inserts an attribute into the container it transfers/moves ownership to the container and the creator never needs to invoke <code>delete</code>. This policy also means that users never need to explicitly delete attributes if they copy and then delete an AST. Newly designed attribute subclasses should use this policy unless they have a very good reason to use another policy.</li>
</ul>
<ul>
<li><code>NO_OWNERSHIP:</code> Another simple approach is that ownership is transfered to the operating system. In other words, the attribute is <em>never</em> deleted by the program and its memory is reclaimed only when the program terminates. Attribute containers that are incorporated into objects that are frequently allocated and/or copied and then deleted will result in a large number of leaked attributes. This approach is not recommended and is present only for laziness.</li>
</ul>
<ul>
<li><code>CUSTOM_OWNERSHIP:</code> A third approach is that the attribute subclass implements its own ownership policy, which ideally should have the properties listed above. An attribute using this policy will never be deleted by an attribute container; the class must implement some other mechanism for tracking which attributes are allocated and whether they can be safely deleted.</li>
</ul>
<ul>
<li><code>UNKNOWN_OWNERSHIP:</code> This final policy is for subclasses implemented before clear attribute ownership rules were defined. Due to the ambiguity in the original <a class="el" href="classAstAttributeMechanism.html" title="Stores named attributes in Sage IR nodes.">AstAttributeMechanism</a> implementation and the fact that attributes are used by code outside the ROSE library, this must be the default implementation.</li>
</ul>
<p>Regardless of the ownership policy, an attribute must not be deleted while it is a member of an <a class="el" href="classAstAttributeMechanism.html" title="Stores named attributes in Sage IR nodes.">AstAttributeMechanism</a> container. This is because in order for the container to decide whether it should delete the attribute, it must first ask the attribute for its ownership policy. In other words, the following code will likely result in a segmentation fault:</p>
<div class="fragment"><div class="line"><a class="code" href="classSgDirectedGraphEdge.html">SgDirectedGraphEdge</a> *edge = ...;</div>
<div class="line"><span class="keyword">delete</span> edge-&gt;<a class="code" href="classSgGraphEdge.html#a2069f9404db2b364e96310dd0d0c13bd">getAttribute</a>(<span class="stringliteral">&quot;info&quot;</span>);</div>
<div class="line"><span class="keyword">delete</span> edge; <span class="comment">// INVALID ACCESS TO EDGE ATTRIBUTE HERE</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="aa01297c1e1e4469aba044bf6650456eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa01297c1e1e4469aba044bf6650456eb">&#9670;&nbsp;</a></span>constructor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classAstAttribute.html">AstAttribute</a>* AstAttribute::constructor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Virtual default constructor. </p>
<p>Default-constructs a new object on the heap and returns its pointer. All subclasses <em>must</em> implement this in order to instantiate the correct dynamic type, although many don't. Invoking this constructor in a subclass that fails to implement it will return an attribute that's an incorrect dynamic type.</p>
<p>It would be nice if we could make this pure virtual, but unfortunately ROSETTA-generated code fails to compile because it generates an instantiation of this interface (whether or not that code is ever executed is unknown). [Robb Matzke 2015-11-10]. </p>

<p class="definition">Definition at line <a class="el" href="AstAttributeMechanism_8h_source.html#l00145">145</a> of file <a class="el" href="AstAttributeMechanism_8h_source.html">AstAttributeMechanism.h</a>.</p>

</div>
</div>
<a id="afde475da251d23d4b873550fce74881a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afde475da251d23d4b873550fce74881a">&#9670;&nbsp;</a></span>copy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classAstAttribute.html">AstAttribute</a>* AstAttribute::copy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Virtual copy constructor. </p>
<p>Copy-constructs a new object on the heap and returns its pointer. All subclasses must implement this in order to instantiate the correct dynamic type, although many don't. If this <a class="el" href="classAstAttribute.html#afde475da251d23d4b873550fce74881a">copy</a> method returns a null pointer (like the base implementation) then the attribute is not copied as part of copying its container. E.g., an attribute stored in an AST will not be copied when the AST is copied if that attribute is directly derived from <a class="el" href="classAstAttribute.html">AstAttribute</a> and fails to implement <a class="el" href="classAstAttribute.html#afde475da251d23d4b873550fce74881a">copy</a>. If a subclass fails to implement <a class="el" href="classAstAttribute.html#afde475da251d23d4b873550fce74881a">copy</a> and inherits from a class that does implement a <a class="el" href="classAstAttribute.html#afde475da251d23d4b873550fce74881a">copy</a> that returns non-null, then the copied attribute will have an incorrect dynamic type.</p>
<p>It would be nice if we could make this pure virtual, but unfortunately ROSETTA-generated code fails to compile because it generates an instantiation of this interface (whether or not that code is ever executed is unkown). [Robb Matzke 2015-11-10] </p>

<p>Reimplemented in <a class="el" href="classAstIntAttribute.html#ae4c9b457510f1f45b2f554d2549d2ea2">AstIntAttribute</a>, <a class="el" href="classAstSgNodeListAttribute.html#ac097332d16a4942c2d6cc6822e39e72b">AstSgNodeListAttribute</a>, <a class="el" href="classAstSgNodeAttribute.html#a2c0d1fdfbd0148202d7fec2854c99096">AstSgNodeAttribute</a>, <a class="el" href="classAstRegExAttribute.html#a74e287f4dcc52bddf057c7ddbc0b36ed">AstRegExAttribute</a>, <a class="el" href="classAstValueAttribute.html#a29f4bc1846bc95610c3098cd904cff9b">AstValueAttribute&lt; T &gt;</a>, <a class="el" href="classMetricAttribute.html#a22d1d39cc052b0d1fa4188653e86eeef">MetricAttribute</a>, and <a class="el" href="classssa__private_1_1VarUniqueName.html#ad5ee1cd711b2fca3467b2f0493a643e1">ssa_private::VarUniqueName</a>.</p>

<p class="definition">Definition at line <a class="el" href="AstAttributeMechanism_8h_source.html#l00161">161</a> of file <a class="el" href="AstAttributeMechanism_8h_source.html">AstAttributeMechanism.h</a>.</p>

</div>
</div>
<a id="aa7b2177c686e996dd455c1f7ab9ecab6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7b2177c686e996dd455c1f7ab9ecab6">&#9670;&nbsp;</a></span>attribute_class_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string AstAttribute::attribute_class_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attribute class name. </p>
<p>Returns the name of the dynamic type. All subclasses must implement this in order to return the correct type name, although many don't. If a subclass fails to implement this then it will return an incorrect class name.</p>
<p>It would be nice if this could be pure virtual, but unfortunately ROSETTA-generated code fails to compile because it generates an instantiation of this interface (whether or not that code is ever executed is unknown). [Robb Matzke 2015-11-10] </p>

<p>Reimplemented in <a class="el" href="classAstIntAttribute.html#a1d6f26f3f39b412ba9ed641702743e31">AstIntAttribute</a>, <a class="el" href="classAstSgNodeListAttribute.html#a57dc5f9a16b18cb7beb3933073da17fa">AstSgNodeListAttribute</a>, <a class="el" href="classAstSgNodeAttribute.html#ac7601d50954c05c634c5ba3eb3a87a5f">AstSgNodeAttribute</a>, <a class="el" href="classAstRegExAttribute.html#a82d61ac69ff7ca875ddbe326d7ab0c9c">AstRegExAttribute</a>, <a class="el" href="classAstValueAttribute.html#a472acf458b6919d55f1ebaab51f6d046">AstValueAttribute&lt; T &gt;</a>, and <a class="el" href="classMetricAttribute.html#aeaefa765600b1280aeaeaaac3297420f">MetricAttribute</a>.</p>

<p class="definition">Definition at line <a class="el" href="AstAttributeMechanism_8h_source.html#l00181">181</a> of file <a class="el" href="AstAttributeMechanism_8h_source.html">AstAttributeMechanism.h</a>.</p>

</div>
</div>
<a id="a5b2bceb4c2df9f3681cf4452880b5493"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b2bceb4c2df9f3681cf4452880b5493">&#9670;&nbsp;</a></span>toString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string AstAttribute::toString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert an attribute to a string. </p>
<p>This is used by other components to print the value of an attribute. For example the pdf generation calls this function to print the value of an attribute in the pdf file. The default implementation is to return the attribute address in the heap as a string. </p>

<p>Reimplemented in <a class="el" href="classMetricAttribute.html#a45cee97d545317a7cd7d681187ba58f8">MetricAttribute</a>, and <a class="el" href="classAstTextAttribute.html#a4c8b84a24fac2b53348af1ad1471b106">AstTextAttribute</a>.</p>

</div>
</div>
<a id="af803af748ef1a2947c8752fb194a13ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af803af748ef1a2947c8752fb194a13ce">&#9670;&nbsp;</a></span>commentOutNodeInGraph()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool AstAttribute::commentOutNodeInGraph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Eliminate IR nodes in DOT graphs. </p>
<p>Or to tailor the presentation of information about ASTs. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="AstAttributeMechanism_8h_source.html">AstAttributeMechanism.h</a></li>
</ul>
</div><!-- contents -->
<div class="ttc" id="aclassSgGraphEdge_html_a2069f9404db2b364e96310dd0d0c13bd"><div class="ttname"><a href="classSgGraphEdge.html#a2069f9404db2b364e96310dd0d0c13bd">SgGraphEdge::getAttribute</a></div><div class="ttdeci">virtual AstAttribute * getAttribute(std::string s) const override</div><div class="ttdoc">Returns attribute of name 's'.</div></div>
<div class="ttc" id="aclassSgDirectedGraphEdge_html"><div class="ttname"><a href="classSgDirectedGraphEdge.html">SgDirectedGraphEdge</a></div><div class="ttdef"><b>Definition:</b> <a href="Cxx__Grammar_8h_source.html#l37888">Cxx_Grammar.h:37888</a></div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Dec 8 2022 21:18:18 for ROSE by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
