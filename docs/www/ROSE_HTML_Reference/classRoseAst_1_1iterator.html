<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROSE: RoseAst::iterator Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="ROSE"/>
<link href="roseDoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ROSE
   &#160;<span id="projectnumber">0.11.96.11</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,true,'search.html','Search');
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="classRoseAst.html">RoseAst</a></li><li class="navelem"><a class="el" href="classRoseAst_1_1iterator.html">iterator</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classRoseAst_1_1iterator-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">RoseAst::iterator Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>AST iterator. </p>
<p>This is an STL-compliant forward iterator for traversing AST nodes in depth-first pre-order. The <a class="el" href="classRoseAst_1_1iterator.html#a1d92c8fdff94d8a31d4733b0fd82441b">withoutNullValues</a> and <a class="el" href="classRoseAst_1_1iterator.html#a94cec5c6d3ecc24a83fd244d9ce3bce7">withNullValues</a> functions control whether the traversal follows null child pointers (the default is that null pointers are not followed). Entire subtrees can be exluded from traversal with the skipSubtreeOnForward function.</p>
<p>The iterator also provides a number of auxiliary functions for querying some structural properties of the AST w.r.t. the position in the traversal (e.g., <a class="el" href="classRoseAst_1_1iterator.html#a096ddd1c25f2069c6aa840094db82ddb">is_at_first_child</a>, <a class="el" href="classRoseAst_1_1iterator.html#af2cbda2e63326e60ccd9e4a4f3336dc4">is_at_last_child</a>, <a class="el" href="classRoseAst_1_1iterator.html#a247c170d7cad742971e0682d713e01c6">is_at_root</a>, <a class="el" href="classRoseAst_1_1iterator.html#a1b2a9b35198099eefce67a8840b43ac1">parent</a>, etc.).</p>
<dl class="section note"><dt>Note</dt><dd>Comparison of iterators is also correct for null values. Only if two iterators refer to the same (identical) null value, they are equal, otherwise they are not. If they refer to different null values they are different. Hence, different null values in the AST are treated like different nodes. This is necessary to allow STL algorithms to work properly on the AST. </dd></dl>

<p class="definition">Definition at line <a class="el" href="RoseAst_8h_source.html#l00056">56</a> of file <a class="el" href="RoseAst_8h_source.html">RoseAst.h</a>.</p>
</div>
<p><code>#include &lt;<a class="el" href="RoseAst_8h_source.html">midend/astMatching/RoseAst.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for RoseAst::iterator:</div>
<div class="dyncontent">
<div class="center"><img src="classRoseAst_1_1iterator__coll__graph.png" border="0" usemap="#RoseAst_1_1iterator_coll__map" alt="Collaboration graph"/></div>
<map name="RoseAst_1_1iterator_coll__map" id="RoseAst_1_1iterator_coll__map">
<area shape="rect" title="AST iterator." alt="" coords="5,97,127,124"/>
<area shape="rect" href="classSgNode.html" title="This class represents the base class for all IR nodes within Sage III." alt="" coords="31,7,101,33"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a933f47be7943702b8230ce672ced69b8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRoseAst_1_1iterator.html#a933f47be7943702b8230ce672ced69b8">iterator</a> ()</td></tr>
<tr class="memdesc:a933f47be7943702b8230ce672ced69b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="classRoseAst_1_1iterator.html#a933f47be7943702b8230ce672ced69b8">More...</a><br /></td></tr>
<tr class="separator:a933f47be7943702b8230ce672ced69b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4bd221b74baf9495a38f9599d23e388"><td class="memItemLeft" align="right" valign="top"><a id="aa4bd221b74baf9495a38f9599d23e388"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRoseAst_1_1iterator.html#aa4bd221b74baf9495a38f9599d23e388">iterator</a> (<a class="el" href="classSgNode.html">SgNode</a> *x, bool <a class="el" href="classRoseAst_1_1iterator.html#a94cec5c6d3ecc24a83fd244d9ce3bce7">withNullValues</a>, bool withTemplates)</td></tr>
<tr class="memdesc:aa4bd221b74baf9495a38f9599d23e388"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an iterator pointing to a particular AST node. <br /></td></tr>
<tr class="separator:aa4bd221b74baf9495a38f9599d23e388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9d33a3be7db8ef65825d640e11ea33e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRoseAst_1_1iterator.html#ad9d33a3be7db8ef65825d640e11ea33e">operator==</a> (const <a class="el" href="classRoseAst_1_1iterator.html">iterator</a> &amp;x) const</td></tr>
<tr class="memdesc:ad9d33a3be7db8ef65825d640e11ea33e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test iterator equality.  <a href="classRoseAst_1_1iterator.html#ad9d33a3be7db8ef65825d640e11ea33e">More...</a><br /></td></tr>
<tr class="separator:ad9d33a3be7db8ef65825d640e11ea33e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4860718789dbb8ae27d33616f97bfef2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRoseAst_1_1iterator.html#a4860718789dbb8ae27d33616f97bfef2">operator!=</a> (const <a class="el" href="classRoseAst_1_1iterator.html">iterator</a> &amp;x) const</td></tr>
<tr class="memdesc:a4860718789dbb8ae27d33616f97bfef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test iterator inequality.  <a href="classRoseAst_1_1iterator.html#a4860718789dbb8ae27d33616f97bfef2">More...</a><br /></td></tr>
<tr class="separator:a4860718789dbb8ae27d33616f97bfef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12b1c3af2120129c031452edb4fe4893"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSgNode.html">SgNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRoseAst_1_1iterator.html#a12b1c3af2120129c031452edb4fe4893">operator*</a> () const</td></tr>
<tr class="memdesc:a12b1c3af2120129c031452edb4fe4893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dereference an iterator.  <a href="classRoseAst_1_1iterator.html#a12b1c3af2120129c031452edb4fe4893">More...</a><br /></td></tr>
<tr class="separator:a12b1c3af2120129c031452edb4fe4893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accd31773e3396ce9a5b4c7ffa44c1c94"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRoseAst_1_1iterator.html#accd31773e3396ce9a5b4c7ffa44c1c94">skipChildrenOnForward</a> ()</td></tr>
<tr class="memdesc:accd31773e3396ce9a5b4c7ffa44c1c94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cause children to be skipped on the next advancement.  <a href="classRoseAst_1_1iterator.html#accd31773e3396ce9a5b4c7ffa44c1c94">More...</a><br /></td></tr>
<tr class="separator:accd31773e3396ce9a5b4c7ffa44c1c94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a257c3848dbc8998e8300c1c107f66a62"><td class="memItemLeft" align="right" valign="top"><a id="a257c3848dbc8998e8300c1c107f66a62"></a>
<a class="el" href="classRoseAst_1_1iterator.html">iterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>withoutTemplates</b> ()</td></tr>
<tr class="separator:a257c3848dbc8998e8300c1c107f66a62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac726a35f1f50642c3a108c75b37f3200"><td class="memItemLeft" align="right" valign="top"><a id="ac726a35f1f50642c3a108c75b37f3200"></a>
<a class="el" href="classRoseAst_1_1iterator.html">iterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>withTemplates</b> ()</td></tr>
<tr class="separator:ac726a35f1f50642c3a108c75b37f3200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b2a9b35198099eefce67a8840b43ac1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSgNode.html">SgNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRoseAst_1_1iterator.html#a1b2a9b35198099eefce67a8840b43ac1">parent</a> () const</td></tr>
<tr class="memdesc:a1b2a9b35198099eefce67a8840b43ac1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parent AST node relative to the iteration.  <a href="classRoseAst_1_1iterator.html#a1b2a9b35198099eefce67a8840b43ac1">More...</a><br /></td></tr>
<tr class="separator:a1b2a9b35198099eefce67a8840b43ac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a247c170d7cad742971e0682d713e01c6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRoseAst_1_1iterator.html#a247c170d7cad742971e0682d713e01c6">is_at_root</a> () const</td></tr>
<tr class="memdesc:a247c170d7cad742971e0682d713e01c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether iterator is pointing to root node of AST to be traversed.  <a href="classRoseAst_1_1iterator.html#a247c170d7cad742971e0682d713e01c6">More...</a><br /></td></tr>
<tr class="separator:a247c170d7cad742971e0682d713e01c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a096ddd1c25f2069c6aa840094db82ddb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRoseAst_1_1iterator.html#a096ddd1c25f2069c6aa840094db82ddb">is_at_first_child</a> () const</td></tr>
<tr class="memdesc:a096ddd1c25f2069c6aa840094db82ddb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether iterator is at the first child of its parent.  <a href="classRoseAst_1_1iterator.html#a096ddd1c25f2069c6aa840094db82ddb">More...</a><br /></td></tr>
<tr class="separator:a096ddd1c25f2069c6aa840094db82ddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2cbda2e63326e60ccd9e4a4f3336dc4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRoseAst_1_1iterator.html#af2cbda2e63326e60ccd9e4a4f3336dc4">is_at_last_child</a> () const</td></tr>
<tr class="memdesc:af2cbda2e63326e60ccd9e4a4f3336dc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether iterator as at the last child of its parent.  <a href="classRoseAst_1_1iterator.html#af2cbda2e63326e60ccd9e4a4f3336dc4">More...</a><br /></td></tr>
<tr class="separator:af2cbda2e63326e60ccd9e4a4f3336dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70b56805b76eb5ef50067955fc3b88b6"><td class="memItemLeft" align="right" valign="top"><a id="a70b56805b76eb5ef50067955fc3b88b6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_past_the_end</b> () const</td></tr>
<tr class="separator:a70b56805b76eb5ef50067955fc3b88b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3772003cd32eae7ed4dba59df28120ff"><td class="memItemLeft" align="right" valign="top"><a id="a3772003cd32eae7ed4dba59df28120ff"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>current_node_id</b> () const</td></tr>
<tr class="separator:a3772003cd32eae7ed4dba59df28120ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fe6767d97fb5a35a0b8722a497ad81f"><td class="memItemLeft" align="right" valign="top"><a id="a9fe6767d97fb5a35a0b8722a497ad81f"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>parent_node_id</b> () const</td></tr>
<tr class="separator:a9fe6767d97fb5a35a0b8722a497ad81f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81cf9048916b6fa27d3f5e6d95ad635e"><td class="memItemLeft" align="right" valign="top"><a id="a81cf9048916b6fa27d3f5e6d95ad635e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>print_top_element</b> () const</td></tr>
<tr class="separator:a81cf9048916b6fa27d3f5e6d95ad635e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa83f81dc50d91b656322b0a5dc726e56"><td class="memItemLeft" align="right" valign="top"><a id="aa83f81dc50d91b656322b0a5dc726e56"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRoseAst_1_1iterator.html#aa83f81dc50d91b656322b0a5dc726e56">stack_size</a> () const</td></tr>
<tr class="memdesc:aa83f81dc50d91b656322b0a5dc726e56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Depth of traversal. <br /></td></tr>
<tr class="separator:aa83f81dc50d91b656322b0a5dc726e56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a1cdab4e17e4d7d2eed763742c08585dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRoseAst_1_1iterator.html">iterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRoseAst_1_1iterator.html#a1cdab4e17e4d7d2eed763742c08585dd">operator++</a> ()</td></tr>
<tr class="memdesc:a1cdab4e17e4d7d2eed763742c08585dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advance the iterator.  <a href="classRoseAst_1_1iterator.html#a1cdab4e17e4d7d2eed763742c08585dd">More...</a><br /></td></tr>
<tr class="separator:a1cdab4e17e4d7d2eed763742c08585dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30ec01fdf753a5209ceea534bcb4df14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRoseAst_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRoseAst_1_1iterator.html#a30ec01fdf753a5209ceea534bcb4df14">operator++</a> (int)</td></tr>
<tr class="memdesc:a30ec01fdf753a5209ceea534bcb4df14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advance the iterator.  <a href="classRoseAst_1_1iterator.html#a30ec01fdf753a5209ceea534bcb4df14">More...</a><br /></td></tr>
<tr class="separator:a30ec01fdf753a5209ceea534bcb4df14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a1d92c8fdff94d8a31d4733b0fd82441b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRoseAst_1_1iterator.html">iterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRoseAst_1_1iterator.html#a1d92c8fdff94d8a31d4733b0fd82441b">withoutNullValues</a> ()</td></tr>
<tr class="memdesc:a1d92c8fdff94d8a31d4733b0fd82441b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mode to enable or disable skipping null child pointers.  <a href="classRoseAst_1_1iterator.html#a1d92c8fdff94d8a31d4733b0fd82441b">More...</a><br /></td></tr>
<tr class="separator:a1d92c8fdff94d8a31d4733b0fd82441b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94cec5c6d3ecc24a83fd244d9ce3bce7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRoseAst_1_1iterator.html">iterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRoseAst_1_1iterator.html#a94cec5c6d3ecc24a83fd244d9ce3bce7">withNullValues</a> ()</td></tr>
<tr class="memdesc:a94cec5c6d3ecc24a83fd244d9ce3bce7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mode to enable or disable skipping null child pointers.  <a href="classRoseAst_1_1iterator.html#a94cec5c6d3ecc24a83fd244d9ce3bce7">More...</a><br /></td></tr>
<tr class="separator:a94cec5c6d3ecc24a83fd244d9ce3bce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a2bbbf7ce054648c3aefe21d732acc27a"><td class="memItemLeft" align="right" valign="top"><a id="a2bbbf7ce054648c3aefe21d732acc27a"></a>
<a class="el" href="classSgNode.html">SgNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>_startNode</b></td></tr>
<tr class="separator:a2bbbf7ce054648c3aefe21d732acc27a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa2461c8771edaa6eebcc4e573517740"><td class="memItemLeft" align="right" valign="top"><a id="afa2461c8771edaa6eebcc4e573517740"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>_skipChildrenOnForward</b></td></tr>
<tr class="separator:afa2461c8771edaa6eebcc4e573517740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89047fabe19821e157a919a28af3a2b1"><td class="memItemLeft" align="right" valign="top"><a id="a89047fabe19821e157a919a28af3a2b1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>_withNullValues</b></td></tr>
<tr class="separator:a89047fabe19821e157a919a28af3a2b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac892c4d6b9f75cc373cd9e2bbee5719"><td class="memItemLeft" align="right" valign="top"><a id="aac892c4d6b9f75cc373cd9e2bbee5719"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>_withTemplates</b></td></tr>
<tr class="separator:aac892c4d6b9f75cc373cd9e2bbee5719"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a933f47be7943702b8230ce672ced69b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a933f47be7943702b8230ce672ced69b8">&#9670;&nbsp;</a></span>iterator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RoseAst::iterator::iterator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>Constructs an iterator that compares equal to the <a class="el" href="classRoseAst.html#ac96933f556c824d7909409028c97abf1">end</a> iterator. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad9d33a3be7db8ef65825d640e11ea33e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9d33a3be7db8ef65825d640e11ea33e">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RoseAst::iterator::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRoseAst_1_1iterator.html">iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test iterator equality. </p>
<p>Two iterators are equal if they point to the same node or they're both <a class="el" href="classRoseAst.html#ac96933f556c824d7909409028c97abf1">end</a> iterators. Two iterators that are pointing to null nodes are equal if and only if they refer to the same (identical) null value. If they refer to different null values they are different. Hence, different null values in the AST are treated like different nodes. This is necessary to allow STL algorithms to work.</p>
<p>Additionally, even if two iterators are pointing to the same AST node they will be equal only if they're in the same <a class="el" href="classRoseAst_1_1iterator.html#accd31773e3396ce9a5b4c7ffa44c1c94">skipChildrenOnForward</a> state. </p>

</div>
</div>
<a id="a4860718789dbb8ae27d33616f97bfef2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4860718789dbb8ae27d33616f97bfef2">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RoseAst::iterator::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRoseAst_1_1iterator.html">iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test iterator inequality. </p>
<p>This is just a convenince function that inverts the test for equality. </p>

</div>
</div>
<a id="a12b1c3af2120129c031452edb4fe4893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12b1c3af2120129c031452edb4fe4893">&#9670;&nbsp;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgNode.html">SgNode</a>* RoseAst::iterator::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dereference an iterator. </p>
<p>Dereference an iterator to obtain the AST node to which it points. Dereferencing an end iterator will throw an <code>std::out_of_range</code> exception. If null AST pointers are being followed, the return value can be a null node (see <a class="el" href="classRoseAst_1_1iterator.html#a94cec5c6d3ecc24a83fd244d9ce3bce7">withNullValues</a> and <a class="el" href="classRoseAst_1_1iterator.html#a1d92c8fdff94d8a31d4733b0fd82441b">withoutNullValues</a>). </p>

</div>
</div>
<a id="a1cdab4e17e4d7d2eed763742c08585dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cdab4e17e4d7d2eed763742c08585dd">&#9670;&nbsp;</a></span>operator++() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRoseAst_1_1iterator.html">iterator</a>&amp; RoseAst::iterator::operator++ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Advance the iterator. </p>
<p>Advances the iterator to the next AST node in a depth-first pre-order search. If the <a class="el" href="classRoseAst_1_1iterator.html#accd31773e3396ce9a5b4c7ffa44c1c94">skipChildrenOnForward</a> flag is set then all children of the current node are skipped and the <a class="el" href="classRoseAst_1_1iterator.html#accd31773e3396ce9a5b4c7ffa44c1c94">skipChildrenOnForward</a> flag is cleared. If the <a class="el" href="classRoseAst_1_1iterator.html#a1d92c8fdff94d8a31d4733b0fd82441b">withoutNullValues</a> flag is set, then all null child pointers are skipped but that flag is not cleared. </p>

</div>
</div>
<a id="a30ec01fdf753a5209ceea534bcb4df14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30ec01fdf753a5209ceea534bcb4df14">&#9670;&nbsp;</a></span>operator++() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRoseAst_1_1iterator.html">iterator</a> RoseAst::iterator::operator++ </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Advance the iterator. </p>
<p>Advances the iterator to the next AST node in a depth-first pre-order search. If the <a class="el" href="classRoseAst_1_1iterator.html#accd31773e3396ce9a5b4c7ffa44c1c94">skipChildrenOnForward</a> flag is set then all children of the current node are skipped and the <a class="el" href="classRoseAst_1_1iterator.html#accd31773e3396ce9a5b4c7ffa44c1c94">skipChildrenOnForward</a> flag is cleared. If the <a class="el" href="classRoseAst_1_1iterator.html#a1d92c8fdff94d8a31d4733b0fd82441b">withoutNullValues</a> flag is set, then all null child pointers are skipped but that flag is not cleared. </p>

</div>
</div>
<a id="accd31773e3396ce9a5b4c7ffa44c1c94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accd31773e3396ce9a5b4c7ffa44c1c94">&#9670;&nbsp;</a></span>skipChildrenOnForward()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RoseAst::iterator::skipChildrenOnForward </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cause children to be skipped on the next advancement. </p>
<p>This function marks the iterator so that it's next increment operator will advance over the current node's children without visiting them. The children are skipped only for the immediate next forward iteration (this is useful when used in the iterator idiom). This function is specific to tree iteration and allows to take tree structure into account although we are traversing the tree nodes as a sequence. </p>

</div>
</div>
<a id="a1d92c8fdff94d8a31d4733b0fd82441b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d92c8fdff94d8a31d4733b0fd82441b">&#9670;&nbsp;</a></span>withoutNullValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRoseAst_1_1iterator.html">iterator</a>&amp; RoseAst::iterator::withoutNullValues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mode to enable or disable skipping null child pointers. </p>
<p>The <a class="el" href="classRoseAst_1_1iterator.html#a1d92c8fdff94d8a31d4733b0fd82441b">withoutNullValues</a> mode causes the iterator to skip over null child pointers, while the <a class="el" href="classRoseAst_1_1iterator.html#a94cec5c6d3ecc24a83fd244d9ce3bce7">withNullValues</a> mode causse null child pointers to be followed followed. The mode affects subsequent advancement of the iterator, not its current value. In other words, in the <a class="el" href="classRoseAst_1_1iterator.html#a94cec5c6d3ecc24a83fd244d9ce3bce7">withNullValues</a> mode the iterator dereference operator will always return non-null values after its next increment. The default mode is <a class="el" href="classRoseAst_1_1iterator.html#a1d92c8fdff94d8a31d4733b0fd82441b">withoutNullValues</a>.</p>
<p>The function returns this iterator and can therefore be called together with <a class="el" href="classRoseAst.html#a6a47bc63810d96c2e324b2bdadb5781e">begin</a>, like this:</p>
<div class="fragment"><div class="line"><a class="code" href="classRoseAst_1_1iterator.html">RoseAst::iterator</a> i = ast.begin().<a class="code" href="classRoseAst_1_1iterator.html#a94cec5c6d3ecc24a83fd244d9ce3bce7">withNullValues</a>();</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a94cec5c6d3ecc24a83fd244d9ce3bce7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94cec5c6d3ecc24a83fd244d9ce3bce7">&#9670;&nbsp;</a></span>withNullValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRoseAst_1_1iterator.html">iterator</a>&amp; RoseAst::iterator::withNullValues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mode to enable or disable skipping null child pointers. </p>
<p>The <a class="el" href="classRoseAst_1_1iterator.html#a1d92c8fdff94d8a31d4733b0fd82441b">withoutNullValues</a> mode causes the iterator to skip over null child pointers, while the <a class="el" href="classRoseAst_1_1iterator.html#a94cec5c6d3ecc24a83fd244d9ce3bce7">withNullValues</a> mode causse null child pointers to be followed followed. The mode affects subsequent advancement of the iterator, not its current value. In other words, in the <a class="el" href="classRoseAst_1_1iterator.html#a94cec5c6d3ecc24a83fd244d9ce3bce7">withNullValues</a> mode the iterator dereference operator will always return non-null values after its next increment. The default mode is <a class="el" href="classRoseAst_1_1iterator.html#a1d92c8fdff94d8a31d4733b0fd82441b">withoutNullValues</a>.</p>
<p>The function returns this iterator and can therefore be called together with <a class="el" href="classRoseAst.html#a6a47bc63810d96c2e324b2bdadb5781e">begin</a>, like this:</p>
<div class="fragment"><div class="line"><a class="code" href="classRoseAst_1_1iterator.html">RoseAst::iterator</a> i = ast.begin().<a class="code" href="classRoseAst_1_1iterator.html#a94cec5c6d3ecc24a83fd244d9ce3bce7">withNullValues</a>();</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a1b2a9b35198099eefce67a8840b43ac1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b2a9b35198099eefce67a8840b43ac1">&#9670;&nbsp;</a></span>parent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgNode.html">SgNode</a>* RoseAst::iterator::parent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parent AST node relative to the iteration. </p>
<p>Returns the parent relative to the current iterator position, which might differ from the <code>get_parent</code> property of the current node. For instance, <a class="el" href="classRoseAst_1_1iterator.html#a1b2a9b35198099eefce67a8840b43ac1">parent</a> can return a non-null pointer when the current node is null. </p>

</div>
</div>
<a id="a247c170d7cad742971e0682d713e01c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a247c170d7cad742971e0682d713e01c6">&#9670;&nbsp;</a></span>is_at_root()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RoseAst::iterator::is_at_root </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test whether iterator is pointing to root node of AST to be traversed. </p>
<p>Returns true if and only if the current node of this iterator is also the root of the traversed subtree. </p>

</div>
</div>
<a id="a096ddd1c25f2069c6aa840094db82ddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a096ddd1c25f2069c6aa840094db82ddb">&#9670;&nbsp;</a></span>is_at_first_child()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RoseAst::iterator::is_at_first_child </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test whether iterator is at the first child of its parent. </p>
<p>Returns true if the current node of this iterator is the first child of the parent node. </p>

</div>
</div>
<a id="af2cbda2e63326e60ccd9e4a4f3336dc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2cbda2e63326e60ccd9e4a4f3336dc4">&#9670;&nbsp;</a></span>is_at_last_child()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RoseAst::iterator::is_at_last_child </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test whether iterator as at the last child of its parent. </p>
<p>Returns true if the current node of this iterator is the last child of the parent node. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="RoseAst_8h_source.html">RoseAst.h</a></li>
</ul>
</div><!-- contents -->
<div class="ttc" id="aclassRoseAst_1_1iterator_html"><div class="ttname"><a href="classRoseAst_1_1iterator.html">RoseAst::iterator</a></div><div class="ttdoc">AST iterator.</div><div class="ttdef"><b>Definition:</b> <a href="RoseAst_8h_source.html#l00056">RoseAst.h:56</a></div></div>
<div class="ttc" id="aclassRoseAst_1_1iterator_html_a94cec5c6d3ecc24a83fd244d9ce3bce7"><div class="ttname"><a href="classRoseAst_1_1iterator.html#a94cec5c6d3ecc24a83fd244d9ce3bce7">RoseAst::iterator::withNullValues</a></div><div class="ttdeci">iterator &amp; withNullValues()</div><div class="ttdoc">Mode to enable or disable skipping null child pointers.</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Dec 8 2022 21:18:18 for ROSE by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
