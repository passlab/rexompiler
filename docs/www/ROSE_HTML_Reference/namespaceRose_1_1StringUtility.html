<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROSE: Rose::StringUtility Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="ROSE"/>
<link href="roseDoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ROSE
   &#160;<span id="projectnumber">0.11.96.11</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,true,'search.html','Search');
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceRose.html">Rose</a></li><li class="navelem"><a class="el" href="namespaceRose_1_1StringUtility.html">StringUtility</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Rose::StringUtility Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>Functions for operating on strings. </p>
<p>This name space provides functions for operating on strings. See also, Boost String Algo [<a href="http://http://www.boost.org/doc/libs/1_78_0/doc/html/string_algo.html">http://http://www.boost.org/doc/libs/1_78_0/doc/html/string_algo.html</a>]. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1StringUtility_1_1FileNameClassification.html">FileNameClassification</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRose_1_1StringUtility_1_1StringWithLineNumber.html">StringWithLineNumber</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">String with source location information.  <a href="structRose_1_1StringUtility_1_1StringWithLineNumber.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:acddf0f6a1575dbd791fb139de7ffa57f"><td class="memItemLeft" align="right" valign="top"><a id="acddf0f6a1575dbd791fb139de7ffa57f"></a>
typedef std::vector&lt; <a class="el" href="structRose_1_1StringUtility_1_1StringWithLineNumber.html">StringWithLineNumber</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1StringUtility.html#acddf0f6a1575dbd791fb139de7ffa57f">FileWithLineNumbers</a></td></tr>
<tr class="memdesc:acddf0f6a1575dbd791fb139de7ffa57f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A vector of strings with line numbers and file names. <br /></td></tr>
<tr class="separator:acddf0f6a1575dbd791fb139de7ffa57f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23e88d274f3fa5dbe582ad6d5f335269"><td class="memItemLeft" align="right" valign="top"><a id="a23e88d274f3fa5dbe582ad6d5f335269"></a>
typedef std::string&#160;</td><td class="memItemRight" valign="bottom"><b>FileNameLibrary</b></td></tr>
<tr class="separator:a23e88d274f3fa5dbe582ad6d5f335269"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a26bc936c70d6e082bca98ffe178e1a49"><td class="memItemLeft" align="right" valign="top"><a id="a26bc936c70d6e082bca98ffe178e1a49"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>OSType</b> { <br />
&#160;&#160;<b>OS_TYPE_UNKNOWN</b>, 
<br />
&#160;&#160;<b>OS_TYPE_LINUX</b>, 
<br />
&#160;&#160;<b>OS_TYPE_OSX</b>, 
<br />
&#160;&#160;<b>OS_TYPE_WINDOWS</b>, 
<br />
&#160;&#160;<b>OS_TPYE_WINDOWSXP</b>
<br />
 }</td></tr>
<tr class="separator:a26bc936c70d6e082bca98ffe178e1a49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d204c1b31bef40e119c06d3ed1c2b79"><td class="memItemLeft" align="right" valign="top"><a id="a8d204c1b31bef40e119c06d3ed1c2b79"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>FileNameLocation</b> { <br />
&#160;&#160;<b>FILENAME_LOCATION_UNKNOWN</b>, 
<br />
&#160;&#160;<b>FILENAME_LOCATION_USER</b>, 
<br />
&#160;&#160;<b>FILENAME_LOCATION_LIBRARY</b>, 
<br />
&#160;&#160;<b>FILENAME_LOCATION_NOT_EXIST</b>
<br />
 }</td></tr>
<tr class="separator:a8d204c1b31bef40e119c06d3ed1c2b79"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a26865d1cd822b1f533b35ec57be241be"><td class="memItemLeft" align="right" valign="top">ROSE_UTIL_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1StringUtility.html#a26865d1cd822b1f533b35ec57be241be">convertToLowerCase</a> (const std::string &amp;inputString)</td></tr>
<tr class="memdesc:a26865d1cd822b1f533b35ec57be241be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to lower case.  <a href="namespaceRose_1_1StringUtility.html#a26865d1cd822b1f533b35ec57be241be">More...</a><br /></td></tr>
<tr class="separator:a26865d1cd822b1f533b35ec57be241be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ac43219a1a34888b481d4f69574e417"><td class="memItemLeft" align="right" valign="top">ROSE_UTIL_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1StringUtility.html#a8ac43219a1a34888b481d4f69574e417">fixLineTermination</a> (const std::string &amp;input)</td></tr>
<tr class="memdesc:a8ac43219a1a34888b481d4f69574e417"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalizes line termination.  <a href="namespaceRose_1_1StringUtility.html#a8ac43219a1a34888b481d4f69574e417">More...</a><br /></td></tr>
<tr class="separator:a8ac43219a1a34888b481d4f69574e417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc71a8534c10be8d3c98715582fd236c"><td class="memItemLeft" align="right" valign="top">ROSE_UTIL_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1StringUtility.html#abc71a8534c10be8d3c98715582fd236c">prefixLines</a> (const std::string &amp;lines, const std::string &amp;prefix, bool prefixAtFront=true, bool prefixAtBack=false)</td></tr>
<tr class="memdesc:abc71a8534c10be8d3c98715582fd236c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a prefix string before every line.  <a href="namespaceRose_1_1StringUtility.html#abc71a8534c10be8d3c98715582fd236c">More...</a><br /></td></tr>
<tr class="separator:abc71a8534c10be8d3c98715582fd236c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28d1bec0abcb2b97969846ef32301029"><td class="memItemLeft" align="right" valign="top">ROSE_UTIL_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1StringUtility.html#a28d1bec0abcb2b97969846ef32301029">leftJustify</a> (const std::string &amp;input, size_t width, char fill=' ')</td></tr>
<tr class="memdesc:a28d1bec0abcb2b97969846ef32301029"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left justify a string to specified width.  <a href="namespaceRose_1_1StringUtility.html#a28d1bec0abcb2b97969846ef32301029">More...</a><br /></td></tr>
<tr class="separator:a28d1bec0abcb2b97969846ef32301029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5abc706dd38162adaa9b573f44f11731"><td class="memItemLeft" align="right" valign="top">ROSE_UTIL_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1StringUtility.html#a5abc706dd38162adaa9b573f44f11731">rightJustify</a> (const std::string &amp;input, size_t width, char fill=' ')</td></tr>
<tr class="memdesc:a5abc706dd38162adaa9b573f44f11731"><td class="mdescLeft">&#160;</td><td class="mdescRight">Right justify a string to specified width.  <a href="namespaceRose_1_1StringUtility.html#a5abc706dd38162adaa9b573f44f11731">More...</a><br /></td></tr>
<tr class="separator:a5abc706dd38162adaa9b573f44f11731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae293e35e354a541a69b2f86df5792cc7"><td class="memItemLeft" align="right" valign="top">ROSE_UTIL_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1StringUtility.html#ae293e35e354a541a69b2f86df5792cc7">centerJustify</a> (const std::string &amp;input, size_t width, char fill=' ')</td></tr>
<tr class="memdesc:ae293e35e354a541a69b2f86df5792cc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Center a string in a field.  <a href="namespaceRose_1_1StringUtility.html#ae293e35e354a541a69b2f86df5792cc7">More...</a><br /></td></tr>
<tr class="separator:ae293e35e354a541a69b2f86df5792cc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a740bfb627d9263696c730f4849e30155"><td class="memItemLeft" align="right" valign="top">ROSE_UTIL_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1StringUtility.html#a740bfb627d9263696c730f4849e30155">makeOneLine</a> (const std::string &amp;s, std::string replacement=&quot; &quot;)</td></tr>
<tr class="memdesc:a740bfb627d9263696c730f4849e30155"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a multi-line string to a single line.  <a href="namespaceRose_1_1StringUtility.html#a740bfb627d9263696c730f4849e30155">More...</a><br /></td></tr>
<tr class="separator:a740bfb627d9263696c730f4849e30155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa879d203acfe91b47b542a4aca203255"><td class="memItemLeft" align="right" valign="top">ROSE_UTIL_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1StringUtility.html#aa879d203acfe91b47b542a4aca203255">trim</a> (const std::string &amp;str, const std::string &amp;strip=&quot; \t\r\n&quot;, bool at_beginning=true, bool at_end=true)</td></tr>
<tr class="memdesc:aa879d203acfe91b47b542a4aca203255"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims white space from the beginning and end of a string.  <a href="namespaceRose_1_1StringUtility.html#aa879d203acfe91b47b542a4aca203255">More...</a><br /></td></tr>
<tr class="separator:aa879d203acfe91b47b542a4aca203255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0af9a95405cb45cb67feb72263939af"><td class="memItemLeft" align="right" valign="top"><a id="af0af9a95405cb45cb67feb72263939af"></a>
ROSE_UTIL_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1StringUtility.html#af0af9a95405cb45cb67feb72263939af">untab</a> (const std::string &amp;str, size_t tabstops=8, size_t firstcol=0)</td></tr>
<tr class="memdesc:af0af9a95405cb45cb67feb72263939af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand horizontal tab characters. <br /></td></tr>
<tr class="separator:af0af9a95405cb45cb67feb72263939af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4896670bcfe3dffbda0630dba7ff844e"><td class="memItemLeft" align="right" valign="top">ROSE_UTIL_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1StringUtility.html#a4896670bcfe3dffbda0630dba7ff844e">removeRedundantSubstrings</a> (const std::string &amp;)</td></tr>
<tr class="memdesc:a4896670bcfe3dffbda0630dba7ff844e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove redundant and blank lines.  <a href="namespaceRose_1_1StringUtility.html#a4896670bcfe3dffbda0630dba7ff844e">More...</a><br /></td></tr>
<tr class="separator:a4896670bcfe3dffbda0630dba7ff844e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b9dbe5e7048925fc05e2f44a2bf923b"><td class="memItemLeft" align="right" valign="top">ROSE_UTIL_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1StringUtility.html#a6b9dbe5e7048925fc05e2f44a2bf923b">removeAnsiEscapes</a> (const std::string &amp;)</td></tr>
<tr class="memdesc:a6b9dbe5e7048925fc05e2f44a2bf923b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove ANSI escape characters.  <a href="namespaceRose_1_1StringUtility.html#a6b9dbe5e7048925fc05e2f44a2bf923b">More...</a><br /></td></tr>
<tr class="separator:a6b9dbe5e7048925fc05e2f44a2bf923b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af97c01c29557f49fdccdb9d204c40a39"><td class="memItemLeft" align="right" valign="top"><a id="af97c01c29557f49fdccdb9d204c40a39"></a>
ROSE_UTIL_API std::vector&lt; uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1StringUtility.html#af97c01c29557f49fdccdb9d204c40a39">decode_base64</a> (const std::string &amp;encoded)</td></tr>
<tr class="memdesc:af97c01c29557f49fdccdb9d204c40a39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert base-64 to binary. <br /></td></tr>
<tr class="separator:af97c01c29557f49fdccdb9d204c40a39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e2daa25e35616f1f07afcc0a84545f3"><td class="memItemLeft" align="right" valign="top">ROSE_UTIL_API unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1StringUtility.html#a1e2daa25e35616f1f07afcc0a84545f3">generate_checksum</a> (std::string s)</td></tr>
<tr class="memdesc:a1e2daa25e35616f1f07afcc0a84545f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a checkshum.  <a href="namespaceRose_1_1StringUtility.html#a1e2daa25e35616f1f07afcc0a84545f3">More...</a><br /></td></tr>
<tr class="separator:a1e2daa25e35616f1f07afcc0a84545f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16ace580d1de7d880fdc10cb078b8054"><td class="memItemLeft" align="right" valign="top"><a id="a16ace580d1de7d880fdc10cb078b8054"></a>
ROSE_UTIL_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1StringUtility.html#a16ace580d1de7d880fdc10cb078b8054">indentMultilineString</a> (const std::string &amp;inputString, int statementColumnNumber)</td></tr>
<tr class="memdesc:a16ace580d1de7d880fdc10cb078b8054"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formatting support for generated code strings. <br /></td></tr>
<tr class="separator:a16ace580d1de7d880fdc10cb078b8054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29a2ab773310bdc062478939a39e026b"><td class="memItemLeft" align="right" valign="top"><a id="a29a2ab773310bdc062478939a39e026b"></a>
ROSE_UTIL_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1StringUtility.html#a29a2ab773310bdc062478939a39e026b">add_to_reason_string</a> (std::string &amp;result, bool isset, bool do_pad, const std::string &amp;abbr, const std::string &amp;full)</td></tr>
<tr class="memdesc:a29a2ab773310bdc062478939a39e026b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append an abbreviation or full name to a string. <br /></td></tr>
<tr class="separator:a29a2ab773310bdc062478939a39e026b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29ff2232fd9a00a0b3dc8a27ad08c1bd"><td class="memItemLeft" align="right" valign="top">ROSE_UTIL_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1StringUtility.html#a29ff2232fd9a00a0b3dc8a27ad08c1bd">appendAsmComment</a> (const std::string &amp;s, const std::string &amp;comment)</td></tr>
<tr class="memdesc:a29ff2232fd9a00a0b3dc8a27ad08c1bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append an assembly comment to a string.  <a href="namespaceRose_1_1StringUtility.html#a29ff2232fd9a00a0b3dc8a27ad08c1bd">More...</a><br /></td></tr>
<tr class="separator:a29ff2232fd9a00a0b3dc8a27ad08c1bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf7821b02ca01054a3b4303aff3086e2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abf7821b02ca01054a3b4303aff3086e2"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1StringUtility.html#abf7821b02ca01054a3b4303aff3086e2">plural</a> (T n, const std::string &amp;plural_phrase, const std::string &amp;singular_phrase=&quot;&quot;)</td></tr>
<tr class="memdesc:abf7821b02ca01054a3b4303aff3086e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helpful way to print singular or plural words.  <a href="namespaceRose_1_1StringUtility.html#abf7821b02ca01054a3b4303aff3086e2">More...</a><br /></td></tr>
<tr class="separator:abf7821b02ca01054a3b4303aff3086e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11338855e4c812fea375a1b1490e949f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1StringUtility.html#a11338855e4c812fea375a1b1490e949f">demangledName</a> (std::string)</td></tr>
<tr class="memdesc:a11338855e4c812fea375a1b1490e949f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute demangled version of mangled name.  <a href="namespaceRose_1_1StringUtility.html#a11338855e4c812fea375a1b1490e949f">More...</a><br /></td></tr>
<tr class="separator:a11338855e4c812fea375a1b1490e949f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86064608af0dee7f4f723713d84c9a8c"><td class="memItemLeft" align="right" valign="top">ROSE_UTIL_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1StringUtility.html#a86064608af0dee7f4f723713d84c9a8c">htmlEscape</a> (const std::string &amp;)</td></tr>
<tr class="memdesc:a86064608af0dee7f4f723713d84c9a8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Escapes HTML special characters.  <a href="namespaceRose_1_1StringUtility.html#a86064608af0dee7f4f723713d84c9a8c">More...</a><br /></td></tr>
<tr class="separator:a86064608af0dee7f4f723713d84c9a8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b99f89a58f84ffc1dcbd8f648898998"><td class="memItemLeft" align="right" valign="top">ROSE_UTIL_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1StringUtility.html#a3b99f89a58f84ffc1dcbd8f648898998">cUnescape</a> (const std::string &amp;)</td></tr>
<tr class="memdesc:a3b99f89a58f84ffc1dcbd8f648898998"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unescapes C++ string literals.  <a href="namespaceRose_1_1StringUtility.html#a3b99f89a58f84ffc1dcbd8f648898998">More...</a><br /></td></tr>
<tr class="separator:a3b99f89a58f84ffc1dcbd8f648898998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8ec3278e38f3ece09cca1ddb95ab9b0"><td class="memItemLeft" align="right" valign="top">ROSE_UTIL_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1StringUtility.html#af8ec3278e38f3ece09cca1ddb95ab9b0">bourneEscape</a> (const std::string &amp;)</td></tr>
<tr class="memdesc:af8ec3278e38f3ece09cca1ddb95ab9b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Escapes characters that are special to the Bourne shell.  <a href="namespaceRose_1_1StringUtility.html#af8ec3278e38f3ece09cca1ddb95ab9b0">More...</a><br /></td></tr>
<tr class="separator:af8ec3278e38f3ece09cca1ddb95ab9b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a811088b1c86a34496a9579ef738d4c"><td class="memItemLeft" align="right" valign="top">ROSE_UTIL_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1StringUtility.html#a4a811088b1c86a34496a9579ef738d4c">yamlEscape</a> (const std::string &amp;)</td></tr>
<tr class="memdesc:a4a811088b1c86a34496a9579ef738d4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Escapes characters that are special to YAML strings.  <a href="namespaceRose_1_1StringUtility.html#a4a811088b1c86a34496a9579ef738d4c">More...</a><br /></td></tr>
<tr class="separator:a4a811088b1c86a34496a9579ef738d4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae75f65f70bab424673c62be455aef7af"><td class="memItemLeft" align="right" valign="top">ROSE_UTIL_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1StringUtility.html#ae75f65f70bab424673c62be455aef7af">csvEscape</a> (const std::string &amp;)</td></tr>
<tr class="memdesc:ae75f65f70bab424673c62be455aef7af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Escapes characters that are special in CSV tables.  <a href="namespaceRose_1_1StringUtility.html#ae75f65f70bab424673c62be455aef7af">More...</a><br /></td></tr>
<tr class="separator:ae75f65f70bab424673c62be455aef7af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06da8495880c56a381409cb344a0abcd"><td class="memItemLeft" align="right" valign="top">ROSE_UTIL_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1StringUtility.html#a06da8495880c56a381409cb344a0abcd">escapeNewLineCharaters</a> (const std::string &amp;)</td></tr>
<tr class="memdesc:a06da8495880c56a381409cb344a0abcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Escapes line feeds and double quotes.  <a href="namespaceRose_1_1StringUtility.html#a06da8495880c56a381409cb344a0abcd">More...</a><br /></td></tr>
<tr class="separator:a06da8495880c56a381409cb344a0abcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf3895a6a4621e51ff75e01badb43d50"><td class="memItemLeft" align="right" valign="top"><a id="abf3895a6a4621e51ff75e01badb43d50"></a>
ROSE_UTIL_API std::string&#160;</td><td class="memItemRight" valign="bottom"><b>escapeNewlineAndDoubleQuoteCharacters</b> (const std::string &amp;)</td></tr>
<tr class="separator:abf3895a6a4621e51ff75e01badb43d50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5c2208dc4542a9cf98fbf1553a0da15"><td class="memItemLeft" align="right" valign="top"><a id="aa5c2208dc4542a9cf98fbf1553a0da15"></a>
ROSE_UTIL_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1StringUtility.html#aa5c2208dc4542a9cf98fbf1553a0da15">numberToString</a> (const void *)</td></tr>
<tr class="memdesc:aa5c2208dc4542a9cf98fbf1553a0da15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a pointer to a string. <br /></td></tr>
<tr class="separator:aa5c2208dc4542a9cf98fbf1553a0da15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a887af6a63b9cd7bbb1fb560c2dbaf02f"><td class="memItemLeft" align="right" valign="top">ROSE_UTIL_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1StringUtility.html#a887af6a63b9cd7bbb1fb560c2dbaf02f">numberToString</a> (double)</td></tr>
<tr class="memdesc:a887af6a63b9cd7bbb1fb560c2dbaf02f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a floating-point number to a string.  <a href="namespaceRose_1_1StringUtility.html#a887af6a63b9cd7bbb1fb560c2dbaf02f">More...</a><br /></td></tr>
<tr class="separator:a887af6a63b9cd7bbb1fb560c2dbaf02f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6f57a9d50d062e00cb058c5367874f8"><td class="memItemLeft" align="right" valign="top"><a id="aa6f57a9d50d062e00cb058c5367874f8"></a>
ROSE_UTIL_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1StringUtility.html#aa6f57a9d50d062e00cb058c5367874f8">intToHex</a> (uint64_t)</td></tr>
<tr class="memdesc:aa6f57a9d50d062e00cb058c5367874f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an integer to a hexadecimal string. <br /></td></tr>
<tr class="separator:aa6f57a9d50d062e00cb058c5367874f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1601608fa2856aa31397370b8b5923c4"><td class="memItemLeft" align="right" valign="top">ROSE_UTIL_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1StringUtility.html#a1601608fa2856aa31397370b8b5923c4">addrToString</a> (uint64_t value, size_t nbits=0)</td></tr>
<tr class="memdesc:a1601608fa2856aa31397370b8b5923c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a virtual address to a string.  <a href="namespaceRose_1_1StringUtility.html#a1601608fa2856aa31397370b8b5923c4">More...</a><br /></td></tr>
<tr class="separator:a1601608fa2856aa31397370b8b5923c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a657bbe672481f4e3dc808c9507394b81"><td class="memItemLeft" align="right" valign="top">ROSE_UTIL_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1StringUtility.html#a657bbe672481f4e3dc808c9507394b81">addrToString</a> (const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">Sawyer::Container::Interval</a>&lt; uint64_t &gt; &amp;interval, size_t nbits=0)</td></tr>
<tr class="memdesc:a657bbe672481f4e3dc808c9507394b81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an interval of virtual addresses to a string.  <a href="namespaceRose_1_1StringUtility.html#a657bbe672481f4e3dc808c9507394b81">More...</a><br /></td></tr>
<tr class="separator:a657bbe672481f4e3dc808c9507394b81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99c50d27c5024f28de2d06360e5c9099"><td class="memItemLeft" align="right" valign="top">ROSE_UTIL_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1StringUtility.html#a99c50d27c5024f28de2d06360e5c9099">addrToString</a> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalSet.html">Sawyer::Container::IntervalSet</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1Interval.html">Sawyer::Container::Interval</a>&lt; uint64_t &gt; &gt; &amp;iset, size_t nbits=0)</td></tr>
<tr class="memdesc:a99c50d27c5024f28de2d06360e5c9099"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an interval set of virtual addresses to a string.  <a href="namespaceRose_1_1StringUtility.html#a99c50d27c5024f28de2d06360e5c9099">More...</a><br /></td></tr>
<tr class="separator:a99c50d27c5024f28de2d06360e5c9099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa95500e1767001293ee097925e9240ad"><td class="memItemLeft" align="right" valign="top">ROSE_UTIL_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1StringUtility.html#aa95500e1767001293ee097925e9240ad">addrToString</a> (const <a class="el" href="classSawyer_1_1Optional.html">Sawyer::Optional</a>&lt; uint64_t &gt; &amp;, size_t nbits=0)</td></tr>
<tr class="memdesc:aa95500e1767001293ee097925e9240ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an optional virtual address to a string.  <a href="namespaceRose_1_1StringUtility.html#aa95500e1767001293ee097925e9240ad">More...</a><br /></td></tr>
<tr class="separator:aa95500e1767001293ee097925e9240ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26d3122f20a16d509654a756887a5bde"><td class="memTemplParams" colspan="2"><a id="a26d3122f20a16d509654a756887a5bde"></a>
template&lt;typename Unsigned &gt; </td></tr>
<tr class="memitem:a26d3122f20a16d509654a756887a5bde"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1StringUtility.html#a26d3122f20a16d509654a756887a5bde">toBinary</a> (Unsigned value, size_t nBits=0, size_t groupSize=4, const std::string groupSeparator=&quot;_&quot;)</td></tr>
<tr class="memdesc:a26d3122f20a16d509654a756887a5bde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a number to a binary string. <br /></td></tr>
<tr class="separator:a26d3122f20a16d509654a756887a5bde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a326eb78c80f76baa38b74de200f74d05"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1StringUtility.html#a326eb78c80f76baa38b74de200f74d05">isContainedIn</a> (const std::string &amp;longString, const std::string &amp;shortString)</td></tr>
<tr class="memdesc:a326eb78c80f76baa38b74de200f74d05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether one string contains another.  <a href="namespaceRose_1_1StringUtility.html#a326eb78c80f76baa38b74de200f74d05">More...</a><br /></td></tr>
<tr class="separator:a326eb78c80f76baa38b74de200f74d05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09d17e008a92a61cff306b8a2eff4a60"><td class="memItemLeft" align="right" valign="top">ROSE_UTIL_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1StringUtility.html#a09d17e008a92a61cff306b8a2eff4a60">isLineTerminated</a> (const std::string &amp;s)</td></tr>
<tr class="memdesc:a09d17e008a92a61cff306b8a2eff4a60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the string ends with line termination.  <a href="namespaceRose_1_1StringUtility.html#a09d17e008a92a61cff306b8a2eff4a60">More...</a><br /></td></tr>
<tr class="separator:a09d17e008a92a61cff306b8a2eff4a60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ab237320e2746a1aa10f0ff8920f0e7"><td class="memItemLeft" align="right" valign="top">ROSE_UTIL_API std::list&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1StringUtility.html#a7ab237320e2746a1aa10f0ff8920f0e7">tokenize</a> (const std::string &amp;, char delim)</td></tr>
<tr class="memdesc:a7ab237320e2746a1aa10f0ff8920f0e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a string into a list based on a separator character.  <a href="namespaceRose_1_1StringUtility.html#a7ab237320e2746a1aa10f0ff8920f0e7">More...</a><br /></td></tr>
<tr class="separator:a7ab237320e2746a1aa10f0ff8920f0e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af843a06506631ee1781c2bd44cf207ef"><td class="memItemLeft" align="right" valign="top">ROSE_UTIL_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1StringUtility.html#af843a06506631ee1781c2bd44cf207ef">joinEnglish</a> (const std::vector&lt; std::string &gt; &amp;phrases, const std::string &amp;separator=&quot;,&quot;, const std::string &amp;finalIntro=&quot;and&quot;)</td></tr>
<tr class="memdesc:af843a06506631ee1781c2bd44cf207ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join strings as if they were English prose.  <a href="namespaceRose_1_1StringUtility.html#af843a06506631ee1781c2bd44cf207ef">More...</a><br /></td></tr>
<tr class="separator:af843a06506631ee1781c2bd44cf207ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37cf7a8302faea91ce6bfcfb75c52dd1"><td class="memItemLeft" align="right" valign="top">ROSE_UTIL_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1StringUtility.html#a37cf7a8302faea91ce6bfcfb75c52dd1">listToString</a> (const std::list&lt; int &gt; &amp;, bool separateStrings=false)</td></tr>
<tr class="memdesc:a37cf7a8302faea91ce6bfcfb75c52dd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a string from a list of integers.  <a href="namespaceRose_1_1StringUtility.html#a37cf7a8302faea91ce6bfcfb75c52dd1">More...</a><br /></td></tr>
<tr class="separator:a37cf7a8302faea91ce6bfcfb75c52dd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12064fe617818daf804c1c773c1fc67a"><td class="memItemLeft" align="right" valign="top">ROSE_UTIL_API std::list&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1StringUtility.html#a12064fe617818daf804c1c773c1fc67a">stringToList</a> (const std::string &amp;)</td></tr>
<tr class="memdesc:a12064fe617818daf804c1c773c1fc67a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a string into substrings at line feeds.  <a href="namespaceRose_1_1StringUtility.html#a12064fe617818daf804c1c773c1fc67a">More...</a><br /></td></tr>
<tr class="separator:a12064fe617818daf804c1c773c1fc67a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44907c4ec299747975586824d9d088ae"><td class="memItemLeft" align="right" valign="top">ROSE_UTIL_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1StringUtility.html#a44907c4ec299747975586824d9d088ae">splitStringIntoStrings</a> (const std::string &amp;inputString, char separator, std::vector&lt; std::string &gt; &amp;stringList)</td></tr>
<tr class="memdesc:a44907c4ec299747975586824d9d088ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits string into substring based on a separator character.  <a href="namespaceRose_1_1StringUtility.html#a44907c4ec299747975586824d9d088ae">More...</a><br /></td></tr>
<tr class="separator:a44907c4ec299747975586824d9d088ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2de64d792fa7e3ebfadc1211744a7a8"><td class="memItemLeft" align="right" valign="top">ROSE_UTIL_API unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1StringUtility.html#ac2de64d792fa7e3ebfadc1211744a7a8">hexadecimalToInt</a> (char)</td></tr>
<tr class="memdesc:ac2de64d792fa7e3ebfadc1211744a7a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an ASCII hexadecimal character to an integer.  <a href="namespaceRose_1_1StringUtility.html#ac2de64d792fa7e3ebfadc1211744a7a8">More...</a><br /></td></tr>
<tr class="separator:ac2de64d792fa7e3ebfadc1211744a7a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad08c20bdcb39760f890b9d139048e3f5"><td class="memTemplParams" colspan="2">template&lt;class IntegralType &gt; </td></tr>
<tr class="memitem:ad08c20bdcb39760f890b9d139048e3f5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Optional.html">Sawyer::Optional</a>&lt; typename std::enable_if&lt; std::is_integral&lt; IntegralType &gt;::value, IntegralType &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1StringUtility.html#ad08c20bdcb39760f890b9d139048e3f5">toDigit</a> (char ch, IntegralType radix=10)</td></tr>
<tr class="memdesc:ad08c20bdcb39760f890b9d139048e3f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a character to a numeric digit.  <a href="namespaceRose_1_1StringUtility.html#ad08c20bdcb39760f890b9d139048e3f5">More...</a><br /></td></tr>
<tr class="separator:ad08c20bdcb39760f890b9d139048e3f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeef730bf985791334cad7f92950a5511"><td class="memTemplParams" colspan="2">template&lt;class IntegralType &gt; </td></tr>
<tr class="memitem:aeef730bf985791334cad7f92950a5511"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_integral&lt; IntegralType &gt;::value, <a class="el" href="classSawyer_1_1Result.html">Sawyer::Result</a>&lt; IntegralType, std::string &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1StringUtility.html#aeef730bf985791334cad7f92950a5511">toNumber</a> (const std::string &amp;s)</td></tr>
<tr class="memdesc:aeef730bf985791334cad7f92950a5511"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safely convert a string to a number using C++ style syntax.  <a href="namespaceRose_1_1StringUtility.html#aeef730bf985791334cad7f92950a5511">More...</a><br /></td></tr>
<tr class="separator:aeef730bf985791334cad7f92950a5511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52995b3cbeeb19334b68a3d6cd704586"><td class="memTemplParams" colspan="2">template&lt;class IntegralType &gt; </td></tr>
<tr class="memitem:a52995b3cbeeb19334b68a3d6cd704586"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_integral&lt; IntegralType &gt;::value, IntegralType &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1StringUtility.html#a52995b3cbeeb19334b68a3d6cd704586">toNumberOrThrow</a> (const std::string &amp;s)</td></tr>
<tr class="memdesc:a52995b3cbeeb19334b68a3d6cd704586"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safely convert a string to a number using C++ style syntax.  <a href="namespaceRose_1_1StringUtility.html#a52995b3cbeeb19334b68a3d6cd704586">More...</a><br /></td></tr>
<tr class="separator:a52995b3cbeeb19334b68a3d6cd704586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab225edef1d28a17d18390fda810f5850"><td class="memItemLeft" align="right" valign="top"><a id="ab225edef1d28a17d18390fda810f5850"></a>
ROSE_UTIL_API OSType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1StringUtility.html#ab225edef1d28a17d18390fda810f5850">getOSType</a> ()</td></tr>
<tr class="memdesc:ab225edef1d28a17d18390fda810f5850"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain operating system type information. <br /></td></tr>
<tr class="separator:ab225edef1d28a17d18390fda810f5850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4a509e656483a877644b17d8344cc6c"><td class="memItemLeft" align="right" valign="top">ROSE_UTIL_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1StringUtility.html#aa4a509e656483a877644b17d8344cc6c">writeFile</a> (const std::string &amp;outputString, const std::string &amp;fileNameString, const std::string &amp;directoryName)</td></tr>
<tr class="memdesc:aa4a509e656483a877644b17d8344cc6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a file.  <a href="namespaceRose_1_1StringUtility.html#aa4a509e656483a877644b17d8344cc6c">More...</a><br /></td></tr>
<tr class="separator:aa4a509e656483a877644b17d8344cc6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94d686d29f5954bba2b30822e09dc6aa"><td class="memItemLeft" align="right" valign="top">ROSE_UTIL_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1StringUtility.html#a94d686d29f5954bba2b30822e09dc6aa">readFile</a> (const std::string &amp;fileName)</td></tr>
<tr class="memdesc:a94d686d29f5954bba2b30822e09dc6aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads entire text file.  <a href="namespaceRose_1_1StringUtility.html#a94d686d29f5954bba2b30822e09dc6aa">More...</a><br /></td></tr>
<tr class="separator:a94d686d29f5954bba2b30822e09dc6aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3d8e3bba4ccca3da3d9501f02c9e757"><td class="memItemLeft" align="right" valign="top">ROSE_UTIL_API <a class="el" href="namespaceRose_1_1StringUtility.html#acddf0f6a1575dbd791fb139de7ffa57f">FileWithLineNumbers</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1StringUtility.html#af3d8e3bba4ccca3da3d9501f02c9e757">readFileWithPos</a> (const std::string &amp;fileName)</td></tr>
<tr class="memdesc:af3d8e3bba4ccca3da3d9501f02c9e757"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an entire text file.  <a href="namespaceRose_1_1StringUtility.html#af3d8e3bba4ccca3da3d9501f02c9e757">More...</a><br /></td></tr>
<tr class="separator:af3d8e3bba4ccca3da3d9501f02c9e757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9272148d7ac9a8b3762b63d4d0e836a6"><td class="memItemLeft" align="right" valign="top">ROSE_UTIL_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1StringUtility.html#a9272148d7ac9a8b3762b63d4d0e836a6">homeDir</a> (std::string &amp;dir)</td></tr>
<tr class="memdesc:a9272148d7ac9a8b3762b63d4d0e836a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of the home directory.  <a href="namespaceRose_1_1StringUtility.html#a9272148d7ac9a8b3762b63d4d0e836a6">More...</a><br /></td></tr>
<tr class="separator:a9272148d7ac9a8b3762b63d4d0e836a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac895cf4df6fe844ca420bdce757ced0b"><td class="memItemLeft" align="right" valign="top">ROSE_UTIL_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1StringUtility.html#ac895cf4df6fe844ca420bdce757ced0b">stripPathFromFileName</a> (const std::string &amp;fileNameWithPath)</td></tr>
<tr class="memdesc:ac895cf4df6fe844ca420bdce757ced0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last component of a path in a filesystem.  <a href="namespaceRose_1_1StringUtility.html#ac895cf4df6fe844ca420bdce757ced0b">More...</a><br /></td></tr>
<tr class="separator:ac895cf4df6fe844ca420bdce757ced0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49afc611d92c58b7ec228d2d60ff2ad4"><td class="memItemLeft" align="right" valign="top">ROSE_UTIL_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1StringUtility.html#a49afc611d92c58b7ec228d2d60ff2ad4">getPathFromFileName</a> (const std::string &amp;fileNameWithPath)</td></tr>
<tr class="memdesc:a49afc611d92c58b7ec228d2d60ff2ad4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all but the last component of a path in a filesystem.  <a href="namespaceRose_1_1StringUtility.html#a49afc611d92c58b7ec228d2d60ff2ad4">More...</a><br /></td></tr>
<tr class="separator:a49afc611d92c58b7ec228d2d60ff2ad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29d142bf2b88492d444d910ba8e603ec"><td class="memItemLeft" align="right" valign="top">ROSE_UTIL_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1StringUtility.html#a29d142bf2b88492d444d910ba8e603ec">stripFileSuffixFromFileName</a> (const std::string &amp;fileNameWithSuffix)</td></tr>
<tr class="memdesc:a29d142bf2b88492d444d910ba8e603ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the file name without the ".suffix".  <a href="namespaceRose_1_1StringUtility.html#a29d142bf2b88492d444d910ba8e603ec">More...</a><br /></td></tr>
<tr class="separator:a29d142bf2b88492d444d910ba8e603ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af529063bdc538a23d815a5e554c545e9"><td class="memItemLeft" align="right" valign="top">ROSE_UTIL_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1StringUtility.html#af529063bdc538a23d815a5e554c545e9">getAbsolutePathFromRelativePath</a> (const std::string &amp;relativePath, bool printErrorIfAny=false)</td></tr>
<tr class="memdesc:af529063bdc538a23d815a5e554c545e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the absolute path from the relative path.  <a href="namespaceRose_1_1StringUtility.html#af529063bdc538a23d815a5e554c545e9">More...</a><br /></td></tr>
<tr class="separator:af529063bdc538a23d815a5e554c545e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2001c82471744d573b11c6cb9dd6371a"><td class="memItemLeft" align="right" valign="top">ROSE_UTIL_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1StringUtility.html#a2001c82471744d573b11c6cb9dd6371a">fileNameSuffix</a> (const std::string &amp;fileName)</td></tr>
<tr class="memdesc:a2001c82471744d573b11c6cb9dd6371a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the file name suffix (extension) without the leading dot.  <a href="namespaceRose_1_1StringUtility.html#a2001c82471744d573b11c6cb9dd6371a">More...</a><br /></td></tr>
<tr class="separator:a2001c82471744d573b11c6cb9dd6371a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5418684ba5945fb76fcdcfb7ba244f85"><td class="memItemLeft" align="right" valign="top">ROSE_UTIL_API std::list&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1StringUtility.html#a5418684ba5945fb76fcdcfb7ba244f85">findfile</a> (std::string patternString, std::string pathString) __attribute__((deprecated))</td></tr>
<tr class="memdesc:a5418684ba5945fb76fcdcfb7ba244f85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find file names non-recursively.  <a href="namespaceRose_1_1StringUtility.html#a5418684ba5945fb76fcdcfb7ba244f85">More...</a><br /></td></tr>
<tr class="separator:a5418684ba5945fb76fcdcfb7ba244f85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4cdd7ade0f7d6af216362c5351af6aa"><td class="memItemLeft" align="right" valign="top">ROSE_UTIL_API <a class="el" href="classRose_1_1StringUtility_1_1FileNameClassification.html">FileNameClassification</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1StringUtility.html#af4cdd7ade0f7d6af216362c5351af6aa">classifyFileName</a> (const std::string &amp;fileName, const std::string &amp;appPath)</td></tr>
<tr class="memdesc:af4cdd7ade0f7d6af216362c5351af6aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether a file is source code or system library.  <a href="namespaceRose_1_1StringUtility.html#af4cdd7ade0f7d6af216362c5351af6aa">More...</a><br /></td></tr>
<tr class="separator:af4cdd7ade0f7d6af216362c5351af6aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a705fd196f2a1c8c1bf517ce6671c8b0c"><td class="memItemLeft" align="right" valign="top">ROSE_UTIL_API <a class="el" href="classRose_1_1StringUtility_1_1FileNameClassification.html">FileNameClassification</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1StringUtility.html#a705fd196f2a1c8c1bf517ce6671c8b0c">classifyFileName</a> (const std::string &amp;fileName, const std::string &amp;appPath, OSType os)</td></tr>
<tr class="memdesc:a705fd196f2a1c8c1bf517ce6671c8b0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether a file is source code or system library.  <a href="namespaceRose_1_1StringUtility.html#a705fd196f2a1c8c1bf517ce6671c8b0c">More...</a><br /></td></tr>
<tr class="separator:a705fd196f2a1c8c1bf517ce6671c8b0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a871cf4c7310cb9916d4e32ff229ee1c3"><td class="memItemLeft" align="right" valign="top">ROSE_UTIL_API <a class="el" href="classRose_1_1StringUtility_1_1FileNameClassification.html">FileNameClassification</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1StringUtility.html#a871cf4c7310cb9916d4e32ff229ee1c3">classifyFileName</a> (const std::string &amp;fileName, const std::string &amp;appPath, const std::map&lt; std::string, std::string &gt; &amp;libPathCollection)</td></tr>
<tr class="memdesc:a871cf4c7310cb9916d4e32ff229ee1c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether a file is source code or system library.  <a href="namespaceRose_1_1StringUtility.html#a871cf4c7310cb9916d4e32ff229ee1c3">More...</a><br /></td></tr>
<tr class="separator:a871cf4c7310cb9916d4e32ff229ee1c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32bb771efbd8ba483a4ee90ea06fbfb5"><td class="memItemLeft" align="right" valign="top">ROSE_UTIL_API <a class="el" href="classRose_1_1StringUtility_1_1FileNameClassification.html">FileNameClassification</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1StringUtility.html#a32bb771efbd8ba483a4ee90ea06fbfb5">classifyFileName</a> (const std::string &amp;fileName, const std::string &amp;appPath, const std::map&lt; std::string, std::string &gt; &amp;libPathCollection, OSType os)</td></tr>
<tr class="memdesc:a32bb771efbd8ba483a4ee90ea06fbfb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether a file is source code or system library.  <a href="namespaceRose_1_1StringUtility.html#a32bb771efbd8ba483a4ee90ea06fbfb5">More...</a><br /></td></tr>
<tr class="separator:a32bb771efbd8ba483a4ee90ea06fbfb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e119b1db1e54fe0358a18b4cada6294"><td class="memItemLeft" align="right" valign="top">const ROSE_UTIL_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1StringUtility.html#a6e119b1db1e54fe0358a18b4cada6294">stripDotsFromHeaderFileName</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a6e119b1db1e54fe0358a18b4cada6294"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove leading dots.  <a href="namespaceRose_1_1StringUtility.html#a6e119b1db1e54fe0358a18b4cada6294">More...</a><br /></td></tr>
<tr class="separator:a6e119b1db1e54fe0358a18b4cada6294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a21cf61077a6ac9d8c24c63484c96cf"><td class="memItemLeft" align="right" valign="top">ROSE_UTIL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1StringUtility.html#a2a21cf61077a6ac9d8c24c63484c96cf">directoryDistance</a> (const std::string &amp;left, const std::string &amp;right)</td></tr>
<tr class="memdesc:a2a21cf61077a6ac9d8c24c63484c96cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Edit distance between two directory names.  <a href="namespaceRose_1_1StringUtility.html#a2a21cf61077a6ac9d8c24c63484c96cf">More...</a><br /></td></tr>
<tr class="separator:a2a21cf61077a6ac9d8c24c63484c96cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eca43732a911d67d335c6d5a2928c20"><td class="memItemLeft" align="right" valign="top">ROSE_UTIL_API std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1StringUtility.html#a6eca43732a911d67d335c6d5a2928c20">readWordsInFile</a> (std::string filename)</td></tr>
<tr class="memdesc:a6eca43732a911d67d335c6d5a2928c20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads words from a file.  <a href="namespaceRose_1_1StringUtility.html#a6eca43732a911d67d335c6d5a2928c20">More...</a><br /></td></tr>
<tr class="separator:a6eca43732a911d67d335c6d5a2928c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe4194514213d1b6d3c541a4dff9eaab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1StringUtility.html#abe4194514213d1b6d3c541a4dff9eaab">popen_wrapper</a> (const std::string &amp;command, std::vector&lt; std::string &gt; &amp;result)</td></tr>
<tr class="memdesc:abe4194514213d1b6d3c541a4dff9eaab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple wrapper for Unix popen command.  <a href="namespaceRose_1_1StringUtility.html#abe4194514213d1b6d3c541a4dff9eaab">More...</a><br /></td></tr>
<tr class="separator:abe4194514213d1b6d3c541a4dff9eaab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93a5f6eb60766729073c2ca8d5a50d18"><td class="memItemLeft" align="right" valign="top"><a id="a93a5f6eb60766729073c2ca8d5a50d18"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1StringUtility.html#a93a5f6eb60766729073c2ca8d5a50d18">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structRose_1_1StringUtility_1_1StringWithLineNumber.html">StringWithLineNumber</a> &amp;s)</td></tr>
<tr class="memdesc:a93a5f6eb60766729073c2ca8d5a50d18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a <a class="el" href="structRose_1_1StringUtility_1_1StringWithLineNumber.html" title="String with source location information.">StringWithLineNumber</a>. <br /></td></tr>
<tr class="separator:a93a5f6eb60766729073c2ca8d5a50d18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab128401cca6edd03b3c366f9fa1f458c"><td class="memItemLeft" align="right" valign="top">ROSE_UTIL_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1StringUtility.html#ab128401cca6edd03b3c366f9fa1f458c">toString</a> (const <a class="el" href="namespaceRose_1_1StringUtility.html#acddf0f6a1575dbd791fb139de7ffa57f">FileWithLineNumbers</a> &amp;strings, const std::string &amp;filename=&quot;&lt;unknown&gt;&quot;, int line=1)</td></tr>
<tr class="memdesc:ab128401cca6edd03b3c366f9fa1f458c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate C preprocessor #line directives.  <a href="namespaceRose_1_1StringUtility.html#ab128401cca6edd03b3c366f9fa1f458c">More...</a><br /></td></tr>
<tr class="separator:ab128401cca6edd03b3c366f9fa1f458c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a730285817dee408e76404ed9e0c5d442"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1StringUtility.html#acddf0f6a1575dbd791fb139de7ffa57f">FileWithLineNumbers</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1StringUtility.html#a730285817dee408e76404ed9e0c5d442">operator+=</a> (<a class="el" href="namespaceRose_1_1StringUtility.html#acddf0f6a1575dbd791fb139de7ffa57f">FileWithLineNumbers</a> &amp;a, const <a class="el" href="namespaceRose_1_1StringUtility.html#acddf0f6a1575dbd791fb139de7ffa57f">FileWithLineNumbers</a> &amp;b)</td></tr>
<tr class="memdesc:a730285817dee408e76404ed9e0c5d442"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append strings with source location information to vector of such.  <a href="namespaceRose_1_1StringUtility.html#a730285817dee408e76404ed9e0c5d442">More...</a><br /></td></tr>
<tr class="separator:a730285817dee408e76404ed9e0c5d442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3c610263bc1edc3378414b63aeb84a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1StringUtility.html#acddf0f6a1575dbd791fb139de7ffa57f">FileWithLineNumbers</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1StringUtility.html#aa3c610263bc1edc3378414b63aeb84a3">operator+</a> (const <a class="el" href="namespaceRose_1_1StringUtility.html#acddf0f6a1575dbd791fb139de7ffa57f">FileWithLineNumbers</a> &amp;a, const <a class="el" href="namespaceRose_1_1StringUtility.html#acddf0f6a1575dbd791fb139de7ffa57f">FileWithLineNumbers</a> &amp;b)</td></tr>
<tr class="memdesc:aa3c610263bc1edc3378414b63aeb84a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate vectors of strings with source location.  <a href="namespaceRose_1_1StringUtility.html#aa3c610263bc1edc3378414b63aeb84a3">More...</a><br /></td></tr>
<tr class="separator:aa3c610263bc1edc3378414b63aeb84a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a26865d1cd822b1f533b35ec57be241be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26865d1cd822b1f533b35ec57be241be">&#9670;&nbsp;</a></span>convertToLowerCase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_UTIL_API std::string Rose::StringUtility::convertToLowerCase </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>inputString</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert to lower case. </p>
<p>Returns a new string by converting each of the input characters to lower case with <code>tolower</code>. </p>

</div>
</div>
<a id="a8ac43219a1a34888b481d4f69574e417"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ac43219a1a34888b481d4f69574e417">&#9670;&nbsp;</a></span>fixLineTermination()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_UTIL_API std::string Rose::StringUtility::fixLineTermination </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normalizes line termination. </p>
<p>Changes ASCII-based line termination conventions used by various operating systems into the LF (line-feed) termination used by Multics, Unix and Unix-like systems (GNU/Linux, Mac OS X, FreeBSD, AIX, Xenix, etc.), BeOS, Amiga, RISC OS and others. Any occurrance of CR+LF, LF+CR, or CR by itself (in that order of left-to-right matching) is replaced by a single LF character. </p>

</div>
</div>
<a id="abc71a8534c10be8d3c98715582fd236c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc71a8534c10be8d3c98715582fd236c">&#9670;&nbsp;</a></span>prefixLines()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_UTIL_API std::string Rose::StringUtility::prefixLines </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>lines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>prefixAtFront</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>prefixAtBack</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert a prefix string before every line. </p>
<p>This function breaks the <code>lines</code> string into individual lines, inserts the <code>prefix</code> string at the beginning of each line, then concatenates the lines together into a return value. If <code>prefixAtFront</code> is true (the default) then the prefix is added to the first line of <code>lines</code>, otherwise the first line is unchanged. An empty <code>lines</code> string is considered to be a single line. If <code>prefixAtBack</code> is false (the default) then the prefix is not appended to the <code>lines</code> string if <code>lines</code> ends with a linefeed. </p>

</div>
</div>
<a id="a28d1bec0abcb2b97969846ef32301029"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28d1bec0abcb2b97969846ef32301029">&#9670;&nbsp;</a></span>leftJustify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_UTIL_API std::string Rose::StringUtility::leftJustify </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>fill</em> = <code>'&#160;'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Left justify a string to specified width. </p>
<p>The given string is either truncated or extended to make it the specified number of characters. New <code>fill</code> characters are added to the end of the string if necessary. </p>

</div>
</div>
<a id="a5abc706dd38162adaa9b573f44f11731"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5abc706dd38162adaa9b573f44f11731">&#9670;&nbsp;</a></span>rightJustify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_UTIL_API std::string Rose::StringUtility::rightJustify </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>fill</em> = <code>'&#160;'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Right justify a string to specified width. </p>
<p>The given string is either truncated or extended to make it the specified number of characters. New <code>fill</code> characters are added to the beginning of the string if necessary. </p>

</div>
</div>
<a id="ae293e35e354a541a69b2f86df5792cc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae293e35e354a541a69b2f86df5792cc7">&#9670;&nbsp;</a></span>centerJustify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_UTIL_API std::string Rose::StringUtility::centerJustify </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>fill</em> = <code>'&#160;'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Center a string in a field. </p>
<p>The given string is either truncated or extended to make it the specified number of characters. New <code>fill</code> characters are added to the beginning and end of the string if necessary. </p>

</div>
</div>
<a id="a740bfb627d9263696c730f4849e30155"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a740bfb627d9263696c730f4849e30155">&#9670;&nbsp;</a></span>makeOneLine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_UTIL_API std::string Rose::StringUtility::makeOneLine </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>replacement</em> = <code>&quot;&#160;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a multi-line string to a single line. </p>
<p>This function converts a multi-line string to a single line by replacing line-feeds and carriage-returns (and their surrounding white space) with a user-supplied replacement string (that defaults to a single space). Line termination (and it's surrounding white space) that appears at the front or back of the input string is removed without replacing it.</p>
<p>See roseTests/utilTests/stringTests.C for lots of examples.</p>
<p>A new string is returned. </p>

</div>
</div>
<a id="aa879d203acfe91b47b542a4aca203255"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa879d203acfe91b47b542a4aca203255">&#9670;&nbsp;</a></span>trim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_UTIL_API std::string Rose::StringUtility::trim </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>strip</em> = <code>&quot;&#160;\t\r\n&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>at_beginning</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>at_end</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trims white space from the beginning and end of a string. </p>
<p>Caller may specify the characters to strip and whether the stripping occurs at the begining, the end, or both. </p>

</div>
</div>
<a id="a4896670bcfe3dffbda0630dba7ff844e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4896670bcfe3dffbda0630dba7ff844e">&#9670;&nbsp;</a></span>removeRedundantSubstrings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_UTIL_API std::string Rose::StringUtility::removeRedundantSubstrings </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove redundant and blank lines. </p>
<p>Splits the input string into substrings according to <a class="el" href="namespaceRose_1_1StringUtility.html#a37cf7a8302faea91ce6bfcfb75c52dd1">listToString</a>, sorts the substrings and removes duplicates and lines that are empty (a line of only horizontal white space is not considered to be empty), then concatenates the substrings in their sorted order into the return value using <a class="el" href="namespaceRose_1_1StringUtility.html#a37cf7a8302faea91ce6bfcfb75c52dd1">listToString</a>, inserting extra white space at the beginning of all but the first line.</p>
<p>The original implementation had a bug (ROSE-304) that caused the first substring to be removed from the return value even if it was non-empty and unique. This happened when it was not followed by a line-feed. </p>

</div>
</div>
<a id="a6b9dbe5e7048925fc05e2f44a2bf923b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b9dbe5e7048925fc05e2f44a2bf923b">&#9670;&nbsp;</a></span>removeAnsiEscapes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_UTIL_API std::string Rose::StringUtility::removeAnsiEscapes </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove ANSI escape characters. </p>
<p>Currently handles only the "Control Sequence Introducer" commands, but these are the most common and most useful commands anyway since they include such things as cursor movement, erasing, scrolling, colors, and other graphic renditions. </p>

</div>
</div>
<a id="a7f1fc05c0971fa4efa8a80d19ee60c7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f1fc05c0971fa4efa8a80d19ee60c7f">&#9670;&nbsp;</a></span>encode_base64() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_UTIL_API std::string Rose::StringUtility::encode_base64 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>do_pad</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert binary data to base-64. </p>
<p>The base64 number system uses the characters A-Z, a-z, 0-9, +, and / (in that order). The returned string does not include linefeeds. If <code>do_pad</code> is true then '=' characters may appear at the end to make the total length a multiple of four. </p>

</div>
</div>
<a id="ac05c08d106b548082b386ea135a3e2f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac05c08d106b548082b386ea135a3e2f0">&#9670;&nbsp;</a></span>encode_base64() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_UTIL_API std::string Rose::StringUtility::encode_base64 </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nbytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>do_padd</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert binary data to base-64. </p>
<p>The base64 number system uses the characters A-Z, a-z, 0-9, +, and / (in that order). The returned string does not include linefeeds. If <code>do_pad</code> is true then '=' characters may appear at the end to make the total length a multiple of four. </p>

</div>
</div>
<a id="a1e2daa25e35616f1f07afcc0a84545f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e2daa25e35616f1f07afcc0a84545f3">&#9670;&nbsp;</a></span>generate_checksum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_UTIL_API unsigned long Rose::StringUtility::generate_checksum </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a checkshum. </p>
<p>This function returns a unique checksum from the mangled name used it provides a simple means to obtain a unique value for any C++ declaration. At a later date was should use the MD5 Checksum implementation (but we can do that later).</p>
<p>The declaration is the same under One-time Definition Rule (ODR) if and only if the checksum values for each declaration are the same. </p>

</div>
</div>
<a id="a29ff2232fd9a00a0b3dc8a27ad08c1bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29ff2232fd9a00a0b3dc8a27ad08c1bd">&#9670;&nbsp;</a></span>appendAsmComment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_UTIL_API std::string Rose::StringUtility::appendAsmComment </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append an assembly comment to a string. </p>
<p>Assembly comments are surrounded by "&lt;" and "&gt;" characters. If the string already ends with an assembly comment, then the specified comment is inserted before the final "&gt;" and separated from the previous comment with a comma. Assembly comments are usually used for things like printing a decimal representation of a hexadecimal value, etc.</p>
<p>Example: after executing these statements:</p>
<div class="fragment"><div class="line">std::string s = <span class="stringliteral">&quot;0xff&quot;</span>;</div>
<div class="line">s = <a class="code" href="namespaceRose_1_1StringUtility.html#a29ff2232fd9a00a0b3dc8a27ad08c1bd">appendAsmComment</a>(s, <span class="stringliteral">&quot;255&quot;</span>);</div>
<div class="line">s = <a class="code" href="namespaceRose_1_1StringUtility.html#a29ff2232fd9a00a0b3dc8a27ad08c1bd">appendAsmComment</a>(s, <span class="stringliteral">&quot;-1&quot;</span>);</div>
</div><!-- fragment --><p>The variable "s" will contain "0xff&lt;255,-1&gt;" </p>

</div>
</div>
<a id="abf7821b02ca01054a3b4303aff3086e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf7821b02ca01054a3b4303aff3086e2">&#9670;&nbsp;</a></span>plural()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string Rose::StringUtility::plural </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>plural_phrase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>singular_phrase</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helpful way to print singular or plural words. </p>
<div class="fragment"><div class="line"> <span class="keywordtype">size_t</span> n = ...;</div>
<div class="line"> std::cout &lt;&lt;<span class="stringliteral">&quot;received &quot;</span> &lt;&lt;<a class="code" href="namespaceRose_1_1StringUtility.html#abf7821b02ca01054a3b4303aff3086e2">plural</a>(n, <span class="stringliteral">&quot;values&quot;</span>) &lt;&lt;<span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">@encode</div>
<div class="line"> </div>
<div class="line"> Output <span class="keywordflow">for</span> various values of &lt;em&gt;n&lt;/em&gt; will be:</div>
<div class="line"> </div>
<div class="line">@code</div>
<div class="line"> received 0 values</div>
<div class="line"> received 1 value</div>
<div class="line"> received 2 values</div>
</div><!-- fragment --><p>This function uses a handful of grade-school rules and common exceptions for converting the supplied plural word to a singular word when necessary. If these are not enough, then the singular form can be supplied as the third argument.</p>
<div class="fragment"><div class="line">std::cout &lt;&lt;<span class="stringliteral">&quot;graph contains &quot;</span> &lt;&lt;<a class="code" href="namespaceRose_1_1StringUtility.html#abf7821b02ca01054a3b4303aff3086e2">plural</a>(nverts, <span class="stringliteral">&quot;vertices&quot;</span>, <span class="stringliteral">&quot;vertex&quot;</span>) &lt;&lt;<span class="stringliteral">&quot;\n&quot;</span>;</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="StringUtility_2Diagnostics_8h_source.html#l00067">67</a> of file <a class="el" href="StringUtility_2Diagnostics_8h_source.html">StringUtility/Diagnostics.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="StringToNumber_8h_source.html#l00112">toNumber()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceRose_1_1StringUtility_abf7821b02ca01054a3b4303aff3086e2_icgraph.png" border="0" usemap="#namespaceRose_1_1StringUtility_abf7821b02ca01054a3b4303aff3086e2_icgraph" alt=""/></div>
<map name="namespaceRose_1_1StringUtility_abf7821b02ca01054a3b4303aff3086e2_icgraph" id="namespaceRose_1_1StringUtility_abf7821b02ca01054a3b4303aff3086e2_icgraph">
<area shape="rect" title="Helpful way to print singular or plural words." alt="" coords="183,5,312,47"/>
<area shape="rect" href="namespaceRose_1_1StringUtility.html#aeef730bf985791334cad7f92950a5511" title="Safely convert a string to a number using C++ style syntax." alt="" coords="5,5,135,47"/>
</map>
</div>

</div>
</div>
<a id="a11338855e4c812fea375a1b1490e949f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11338855e4c812fea375a1b1490e949f">&#9670;&nbsp;</a></span>demangledName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Rose::StringUtility::demangledName </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute demangled version of mangled name. </p>
<p>Runs the c++filt command on the input string and returns the result. If c++filt cannot be run then it prints an error to standard error and another to standard output. The pipes opened to communicate with the c++filt subcommand might not be closed if there's an error. </p>

</div>
</div>
<a id="a86064608af0dee7f4f723713d84c9a8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86064608af0dee7f4f723713d84c9a8c">&#9670;&nbsp;</a></span>htmlEscape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_UTIL_API std::string Rose::StringUtility::htmlEscape </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Escapes HTML special characters. </p>
<p>Replaces "&lt;", "&gt;", and "&amp;" with HTML character names and returns the result. </p>

</div>
</div>
<a id="a3aed317913b7f65d80a2c76c5c019c8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aed317913b7f65d80a2c76c5c019c8b">&#9670;&nbsp;</a></span>cEscape() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_UTIL_API std::string Rose::StringUtility::cEscape </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>context</em> = <code>'&quot;'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Escapes characters that are special to C/C++. </p>
<p>Replaces special characters in the input so that it is suitable for the contents of a C string literal (if <code>context</code> is a double quote character) or the contents of a C character constant (if <code>context</code> is a single quote). That is, things like double quotes, line-feeds, tabs, non-printables, etc. are replace by their C backslash escaped versions. Returns the resulting string.</p>
<p>Note that if the first argument is a string then the context defaults to string literals, and if the first argument is a single character then the context defaults to character literals. Although this is usually what one wants, it's possible to change the context in both situations. </p>

<p class="reference">Referenced by <a class="el" href="SuffixMultiplierParser_8h_source.html#l00156">Rose::CommandLine::SuffixMultiplierParser&lt; uint64_t &gt;::parse()</a>, and <a class="el" href="IntervalParser_8h_source.html#l00188">Rose::CommandLine::IntervalParser&lt; Interval &gt;::parse()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceRose_1_1StringUtility_a3aed317913b7f65d80a2c76c5c019c8b_icgraph.png" border="0" usemap="#namespaceRose_1_1StringUtility_a3aed317913b7f65d80a2c76c5c019c8b_icgraph" alt=""/></div>
<map name="namespaceRose_1_1StringUtility_a3aed317913b7f65d80a2c76c5c019c8b_icgraph" id="namespaceRose_1_1StringUtility_a3aed317913b7f65d80a2c76c5c019c8b_icgraph">
<area shape="rect" title="Escapes characters that are special to C/C++." alt="" coords="207,50,336,91"/>
<area shape="rect" href="classRose_1_1CommandLine_1_1SuffixMultiplierParser.html#aee92715d76fdd5b61e95473b14692962" title="Parse from a C++ string." alt="" coords="5,5,159,61"/>
<area shape="rect" href="classRose_1_1CommandLine_1_1IntervalParser.html#a4c7ed7903fdaa2c395fb46855f583c8b" title="Parse an interval from a C++ string." alt="" coords="5,86,159,127"/>
</map>
</div>

</div>
</div>
<a id="af9fa246e6cbfd465fca5764567d4f304"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9fa246e6cbfd465fca5764567d4f304">&#9670;&nbsp;</a></span>cEscape() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_UTIL_API std::string Rose::StringUtility::cEscape </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>context</em> = <code>'\''</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Escapes characters that are special to C/C++. </p>
<p>Replaces special characters in the input so that it is suitable for the contents of a C string literal (if <code>context</code> is a double quote character) or the contents of a C character constant (if <code>context</code> is a single quote). That is, things like double quotes, line-feeds, tabs, non-printables, etc. are replace by their C backslash escaped versions. Returns the resulting string.</p>
<p>Note that if the first argument is a string then the context defaults to string literals, and if the first argument is a single character then the context defaults to character literals. Although this is usually what one wants, it's possible to change the context in both situations. </p>

</div>
</div>
<a id="a3b99f89a58f84ffc1dcbd8f648898998"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b99f89a58f84ffc1dcbd8f648898998">&#9670;&nbsp;</a></span>cUnescape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_UTIL_API std::string Rose::StringUtility::cUnescape </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unescapes C++ string literals. </p>
<p>When given a C++ string literals content, the part between the enclosing quotes, this function will look for escape sequences, parse them, and replace them in the return value with the actual characters they represent. For instance, passing in <code>std::string{"hello\\nworld\\00hidden"}</code> that contains 20 characters including two backslashes, the function replaces the first backslash+"n" pair with a line feed, and the second backslash+"0"+"0" with a NUL to result in <code>std::string{"hello\nworld\0hidden"}</code> (18 characters including the LF and NUL). Unicode escapes are not supported and will be left escaped in the return value. </p>

</div>
</div>
<a id="af8ec3278e38f3ece09cca1ddb95ab9b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8ec3278e38f3ece09cca1ddb95ab9b0">&#9670;&nbsp;</a></span>bourneEscape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_UTIL_API std::string Rose::StringUtility::bourneEscape </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Escapes characters that are special to the Bourne shell. </p>
<p>Assumes that the context is outside of any quoting and possibly adds quotes. </p>

</div>
</div>
<a id="a4a811088b1c86a34496a9579ef738d4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a811088b1c86a34496a9579ef738d4c">&#9670;&nbsp;</a></span>yamlEscape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_UTIL_API std::string Rose::StringUtility::yamlEscape </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Escapes characters that are special to YAML strings. </p>
<p>Assumes that the context is outside of any quoting and possibly adds quotes. </p>

</div>
</div>
<a id="ae75f65f70bab424673c62be455aef7af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae75f65f70bab424673c62be455aef7af">&#9670;&nbsp;</a></span>csvEscape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_UTIL_API std::string Rose::StringUtility::csvEscape </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Escapes characters that are special in CSV tables. </p>
<p>Assumes that the context is outside of any quoting and possib9 adds quotes. See RFC 4180 for details. </p>

</div>
</div>
<a id="a06da8495880c56a381409cb344a0abcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06da8495880c56a381409cb344a0abcd">&#9670;&nbsp;</a></span>escapeNewLineCharaters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_UTIL_API std::string Rose::StringUtility::escapeNewLineCharaters </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Escapes line feeds and double quotes. </p>
<p>Scans the input string character by character and replaces line-feed characters with a backslash followed by the letter "l" and replaces double quotes by a backslash followed by a double qoute. </p>

</div>
</div>
<a id="a71f0fb9e006fb962ba3d9429c5ed935f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71f0fb9e006fb962ba3d9429c5ed935f">&#9670;&nbsp;</a></span>numberToString() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_UTIL_API std::string Rose::StringUtility::numberToString </td>
          <td>(</td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an integer to a string. </p>
<p>These functions are wrappers around <code>boost::lexical_cast&lt;std::string&gt;</code>. </p>

</div>
</div>
<a id="a924a721ada214a534bbaae81ea121f30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a924a721ada214a534bbaae81ea121f30">&#9670;&nbsp;</a></span>numberToString() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_UTIL_API std::string Rose::StringUtility::numberToString </td>
          <td>(</td>
          <td class="paramtype">unsigned long long&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an integer to a string. </p>
<p>These functions are wrappers around <code>boost::lexical_cast&lt;std::string&gt;</code>. </p>

</div>
</div>
<a id="a3ea02f151047dc7cd9cb725db584a3f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ea02f151047dc7cd9cb725db584a3f4">&#9670;&nbsp;</a></span>numberToString() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_UTIL_API std::string Rose::StringUtility::numberToString </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an integer to a string. </p>
<p>These functions are wrappers around <code>boost::lexical_cast&lt;std::string&gt;</code>. </p>

</div>
</div>
<a id="af8d35c5686067ce7536ba647c4f8e4c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8d35c5686067ce7536ba647c4f8e4c6">&#9670;&nbsp;</a></span>numberToString() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_UTIL_API std::string Rose::StringUtility::numberToString </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an integer to a string. </p>
<p>These functions are wrappers around <code>boost::lexical_cast&lt;std::string&gt;</code>. </p>

</div>
</div>
<a id="a2b8d709cffa2fa8d004388af6b04eb3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b8d709cffa2fa8d004388af6b04eb3a">&#9670;&nbsp;</a></span>numberToString() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_UTIL_API std::string Rose::StringUtility::numberToString </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an integer to a string. </p>
<p>These functions are wrappers around <code>boost::lexical_cast&lt;std::string&gt;</code>. </p>

</div>
</div>
<a id="a498c59a60d92b667d2921b03c2a4c79b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a498c59a60d92b667d2921b03c2a4c79b">&#9670;&nbsp;</a></span>numberToString() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_UTIL_API std::string Rose::StringUtility::numberToString </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an integer to a string. </p>
<p>These functions are wrappers around <code>boost::lexical_cast&lt;std::string&gt;</code>. </p>

</div>
</div>
<a id="a887af6a63b9cd7bbb1fb560c2dbaf02f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a887af6a63b9cd7bbb1fb560c2dbaf02f">&#9670;&nbsp;</a></span>numberToString() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_UTIL_API std::string Rose::StringUtility::numberToString </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a floating-point number to a string. </p>
<p>The returned string uses <code>printf</code> with "%2.2f" format. </p>

</div>
</div>
<a id="a89f25fec4824d65b6c2ab8eabfaa9d54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89f25fec4824d65b6c2ab8eabfaa9d54">&#9670;&nbsp;</a></span>toHex2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_UTIL_API std::string Rose::StringUtility::toHex2 </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nbits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>show_unsigned_decimal</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>show_signed_decimal</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>decimal_threshold</em> = <code>256</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a number to a hexadecimal and decimal string. </p>
<p>The returned string starts with the hexadecimal representation of the number and an optional decimal representation in angle brackets. The decimal portion will contain a signed and/or unsigned value depending on whether the value is interpretted as signed and whether the sign bit is set. The signedToHex versions print the decimal value for only the signed interpretation; the unsignedToHex versions print only the decimal unsigned interpretation, and the toHex versions print both (but not redunantly). </p>

<p class="reference">Referenced by <a class="el" href="NumberToString_8h_source.html#l00066">toHex()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceRose_1_1StringUtility_a89f25fec4824d65b6c2ab8eabfaa9d54_icgraph.png" border="0" usemap="#namespaceRose_1_1StringUtility_a89f25fec4824d65b6c2ab8eabfaa9d54_icgraph" alt=""/></div>
<map name="namespaceRose_1_1StringUtility_a89f25fec4824d65b6c2ab8eabfaa9d54_icgraph" id="namespaceRose_1_1StringUtility_a89f25fec4824d65b6c2ab8eabfaa9d54_icgraph">
<area shape="rect" title="Convert a number to a hexadecimal and decimal string." alt="" coords="183,5,312,47"/>
<area shape="rect" href="namespaceRose_1_1StringUtility.html#a9787d323e1d8890a456f14daa0b65074" title="Convert a number to a hexadecimal and decimal string." alt="" coords="5,5,135,47"/>
</map>
</div>

</div>
</div>
<a id="ad98e75a5f74167b621baaf53ed5ce4eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad98e75a5f74167b621baaf53ed5ce4eb">&#9670;&nbsp;</a></span>signedToHex2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_UTIL_API std::string Rose::StringUtility::signedToHex2 </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nbits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a number to a hexadecimal and decimal string. </p>
<p>The returned string starts with the hexadecimal representation of the number and an optional decimal representation in angle brackets. The decimal portion will contain a signed and/or unsigned value depending on whether the value is interpretted as signed and whether the sign bit is set. The signedToHex versions print the decimal value for only the signed interpretation; the unsignedToHex versions print only the decimal unsigned interpretation, and the toHex versions print both (but not redunantly). </p>

<p class="reference">Referenced by <a class="el" href="NumberToString_8h_source.html#l00067">signedToHex()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceRose_1_1StringUtility_ad98e75a5f74167b621baaf53ed5ce4eb_icgraph.png" border="0" usemap="#namespaceRose_1_1StringUtility_ad98e75a5f74167b621baaf53ed5ce4eb_icgraph" alt=""/></div>
<map name="namespaceRose_1_1StringUtility_ad98e75a5f74167b621baaf53ed5ce4eb_icgraph" id="namespaceRose_1_1StringUtility_ad98e75a5f74167b621baaf53ed5ce4eb_icgraph">
<area shape="rect" title="Convert a number to a hexadecimal and decimal string." alt="" coords="183,5,312,47"/>
<area shape="rect" href="namespaceRose_1_1StringUtility.html#a7c011540ab0a925341e9ae38511928cd" title="Convert a number to a hexadecimal and decimal string." alt="" coords="5,5,135,47"/>
</map>
</div>

</div>
</div>
<a id="aa48e563573154a94a8b3c514d0e9f195"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa48e563573154a94a8b3c514d0e9f195">&#9670;&nbsp;</a></span>unsignedToHex2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_UTIL_API std::string Rose::StringUtility::unsignedToHex2 </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nbits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a number to a hexadecimal and decimal string. </p>
<p>The returned string starts with the hexadecimal representation of the number and an optional decimal representation in angle brackets. The decimal portion will contain a signed and/or unsigned value depending on whether the value is interpretted as signed and whether the sign bit is set. The signedToHex versions print the decimal value for only the signed interpretation; the unsignedToHex versions print only the decimal unsigned interpretation, and the toHex versions print both (but not redunantly). </p>

<p class="reference">Referenced by <a class="el" href="NumberToString_8h_source.html#l00068">unsignedToHex()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceRose_1_1StringUtility_aa48e563573154a94a8b3c514d0e9f195_icgraph.png" border="0" usemap="#namespaceRose_1_1StringUtility_aa48e563573154a94a8b3c514d0e9f195_icgraph" alt=""/></div>
<map name="namespaceRose_1_1StringUtility_aa48e563573154a94a8b3c514d0e9f195_icgraph" id="namespaceRose_1_1StringUtility_aa48e563573154a94a8b3c514d0e9f195_icgraph">
<area shape="rect" title="Convert a number to a hexadecimal and decimal string." alt="" coords="183,5,312,47"/>
<area shape="rect" href="namespaceRose_1_1StringUtility.html#af97299908ed7815aa1a183cd376a71bb" title="Convert a number to a hexadecimal and decimal string." alt="" coords="5,5,135,47"/>
</map>
</div>

</div>
</div>
<a id="a9787d323e1d8890a456f14daa0b65074"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9787d323e1d8890a456f14daa0b65074">&#9670;&nbsp;</a></span>toHex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string Rose::StringUtility::toHex </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a number to a hexadecimal and decimal string. </p>
<p>The returned string starts with the hexadecimal representation of the number and an optional decimal representation in angle brackets. The decimal portion will contain a signed and/or unsigned value depending on whether the value is interpretted as signed and whether the sign bit is set. The signedToHex versions print the decimal value for only the signed interpretation; the unsignedToHex versions print only the decimal unsigned interpretation, and the toHex versions print both (but not redunantly). </p>

<p class="definition">Definition at line <a class="el" href="NumberToString_8h_source.html#l00066">66</a> of file <a class="el" href="NumberToString_8h_source.html">NumberToString.h</a>.</p>

<p class="reference">References <a class="el" href="namespaceRose_1_1StringUtility.html#a89f25fec4824d65b6c2ab8eabfaa9d54">toHex2()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceRose_1_1StringUtility_a9787d323e1d8890a456f14daa0b65074_cgraph.png" border="0" usemap="#namespaceRose_1_1StringUtility_a9787d323e1d8890a456f14daa0b65074_cgraph" alt=""/></div>
<map name="namespaceRose_1_1StringUtility_a9787d323e1d8890a456f14daa0b65074_cgraph" id="namespaceRose_1_1StringUtility_a9787d323e1d8890a456f14daa0b65074_cgraph">
<area shape="rect" title="Convert a number to a hexadecimal and decimal string." alt="" coords="5,5,135,47"/>
<area shape="rect" href="namespaceRose_1_1StringUtility.html#a89f25fec4824d65b6c2ab8eabfaa9d54" title="Convert a number to a hexadecimal and decimal string." alt="" coords="183,5,312,47"/>
</map>
</div>

</div>
</div>
<a id="a7c011540ab0a925341e9ae38511928cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c011540ab0a925341e9ae38511928cd">&#9670;&nbsp;</a></span>signedToHex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string Rose::StringUtility::signedToHex </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a number to a hexadecimal and decimal string. </p>
<p>The returned string starts with the hexadecimal representation of the number and an optional decimal representation in angle brackets. The decimal portion will contain a signed and/or unsigned value depending on whether the value is interpretted as signed and whether the sign bit is set. The signedToHex versions print the decimal value for only the signed interpretation; the unsignedToHex versions print only the decimal unsigned interpretation, and the toHex versions print both (but not redunantly). </p>

<p class="definition">Definition at line <a class="el" href="NumberToString_8h_source.html#l00067">67</a> of file <a class="el" href="NumberToString_8h_source.html">NumberToString.h</a>.</p>

<p class="reference">References <a class="el" href="namespaceRose_1_1StringUtility.html#ad98e75a5f74167b621baaf53ed5ce4eb">signedToHex2()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceRose_1_1StringUtility_a7c011540ab0a925341e9ae38511928cd_cgraph.png" border="0" usemap="#namespaceRose_1_1StringUtility_a7c011540ab0a925341e9ae38511928cd_cgraph" alt=""/></div>
<map name="namespaceRose_1_1StringUtility_a7c011540ab0a925341e9ae38511928cd_cgraph" id="namespaceRose_1_1StringUtility_a7c011540ab0a925341e9ae38511928cd_cgraph">
<area shape="rect" title="Convert a number to a hexadecimal and decimal string." alt="" coords="5,5,135,47"/>
<area shape="rect" href="namespaceRose_1_1StringUtility.html#ad98e75a5f74167b621baaf53ed5ce4eb" title="Convert a number to a hexadecimal and decimal string." alt="" coords="183,5,312,47"/>
</map>
</div>

</div>
</div>
<a id="af97299908ed7815aa1a183cd376a71bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af97299908ed7815aa1a183cd376a71bb">&#9670;&nbsp;</a></span>unsignedToHex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string Rose::StringUtility::unsignedToHex </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a number to a hexadecimal and decimal string. </p>
<p>The returned string starts with the hexadecimal representation of the number and an optional decimal representation in angle brackets. The decimal portion will contain a signed and/or unsigned value depending on whether the value is interpretted as signed and whether the sign bit is set. The signedToHex versions print the decimal value for only the signed interpretation; the unsignedToHex versions print only the decimal unsigned interpretation, and the toHex versions print both (but not redunantly). </p>

<p class="definition">Definition at line <a class="el" href="NumberToString_8h_source.html#l00068">68</a> of file <a class="el" href="NumberToString_8h_source.html">NumberToString.h</a>.</p>

<p class="reference">References <a class="el" href="namespaceRose_1_1StringUtility.html#aa48e563573154a94a8b3c514d0e9f195">unsignedToHex2()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceRose_1_1StringUtility_af97299908ed7815aa1a183cd376a71bb_cgraph.png" border="0" usemap="#namespaceRose_1_1StringUtility_af97299908ed7815aa1a183cd376a71bb_cgraph" alt=""/></div>
<map name="namespaceRose_1_1StringUtility_af97299908ed7815aa1a183cd376a71bb_cgraph" id="namespaceRose_1_1StringUtility_af97299908ed7815aa1a183cd376a71bb_cgraph">
<area shape="rect" title="Convert a number to a hexadecimal and decimal string." alt="" coords="5,5,135,47"/>
<area shape="rect" href="namespaceRose_1_1StringUtility.html#aa48e563573154a94a8b3c514d0e9f195" title="Convert a number to a hexadecimal and decimal string." alt="" coords="183,5,312,47"/>
</map>
</div>

</div>
</div>
<a id="a1601608fa2856aa31397370b8b5923c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1601608fa2856aa31397370b8b5923c4">&#9670;&nbsp;</a></span>addrToString() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_UTIL_API std::string Rose::StringUtility::addrToString </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nbits</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a virtual address to a string. </p>
<p>Converts a virtual address to a hexadecimal string with a leading "0x". The string is zero-padded so that it explicitly represents at least <code>nbits</code> bits (four bits per hexadecimal digits). If <code>nbits</code> is zero then the function uses 32 bits for values that fit in 32 bits, otherwise 64 bits. </p>

<p class="reference">Referenced by <a class="el" href="IntervalParser_8h_source.html#l00199">Rose::CommandLine::IntervalParser&lt; Interval &gt;::toString()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceRose_1_1StringUtility_a1601608fa2856aa31397370b8b5923c4_icgraph.png" border="0" usemap="#namespaceRose_1_1StringUtility_a1601608fa2856aa31397370b8b5923c4_icgraph" alt=""/></div>
<map name="namespaceRose_1_1StringUtility_a1601608fa2856aa31397370b8b5923c4_icgraph" id="namespaceRose_1_1StringUtility_a1601608fa2856aa31397370b8b5923c4_icgraph">
<area shape="rect" title="Convert a virtual address to a string." alt="" coords="209,5,339,47"/>
<area shape="rect" href="classRose_1_1CommandLine_1_1IntervalParser.html#a5cc45b8f9c3a90dcbf0fabac34c71126" title="Unparse an interval to a string." alt="" coords="5,5,161,47"/>
</map>
</div>

</div>
</div>
<a id="a657bbe672481f4e3dc808c9507394b81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a657bbe672481f4e3dc808c9507394b81">&#9670;&nbsp;</a></span>addrToString() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_UTIL_API std::string Rose::StringUtility::addrToString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">Sawyer::Container::Interval</a>&lt; uint64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nbits</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an interval of virtual addresses to a string. </p>
<p>Converts an interval to a string by converting each address to a string, separating them with a comma, and enclosing the whole string in square brackets. </p>

</div>
</div>
<a id="a99c50d27c5024f28de2d06360e5c9099"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99c50d27c5024f28de2d06360e5c9099">&#9670;&nbsp;</a></span>addrToString() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_UTIL_API std::string Rose::StringUtility::addrToString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1IntervalSet.html">Sawyer::Container::IntervalSet</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1Interval.html">Sawyer::Container::Interval</a>&lt; uint64_t &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>iset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nbits</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an interval set of virtual addresses to a string. </p>
<p>Converts the interval-set to a string by converting each interval to a string, separating the intervals with commas, and enclosing the whole string in curly braces. </p>

</div>
</div>
<a id="aa95500e1767001293ee097925e9240ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa95500e1767001293ee097925e9240ad">&#9670;&nbsp;</a></span>addrToString() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_UTIL_API std::string Rose::StringUtility::addrToString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Optional.html">Sawyer::Optional</a>&lt; uint64_t &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nbits</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an optional virtual address to a string. </p>
<p>Same as the non-optional version of this function, but prints the word "none" if the argument is <a class="el" href="classSawyer_1_1Nothing.html">Sawyer::Nothing</a>. </p>

</div>
</div>
<a id="a326eb78c80f76baa38b74de200f74d05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a326eb78c80f76baa38b74de200f74d05">&#9670;&nbsp;</a></span>isContainedIn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::StringUtility::isContainedIn </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>longString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>shortString</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether one string contains another. </p>
<p>Returns true if <code>longString</code> contains <code>shortString</code> as a subsequence. </p>

<p class="definition">Definition at line <a class="el" href="Predicate_8h_source.html#l00018">18</a> of file <a class="el" href="Predicate_8h_source.html">Predicate.h</a>.</p>

</div>
</div>
<a id="a09d17e008a92a61cff306b8a2eff4a60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09d17e008a92a61cff306b8a2eff4a60">&#9670;&nbsp;</a></span>isLineTerminated()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_UTIL_API bool Rose::StringUtility::isLineTerminated </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the string ends with line termination. </p>
<p>Only common ASCII-based line terminations are recognized: CR+LF, LF+CR, CR (only), or LF (only). </p>

</div>
</div>
<a id="abeb29cbfa6cea9b3c9cd3c1481a5c79a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abeb29cbfa6cea9b3c9cd3c1481a5c79a">&#9670;&nbsp;</a></span>split() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_UTIL_API std::vector&lt;std::string&gt; Rose::StringUtility::split </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>separator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxparts</em> = <code><a class="el" href="namespaceRose.html#ac6b909559ee66844a1235ba9cc72aec8">UNLIMITED</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>trim_white_space</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splits strings into parts. </p>
<p>Find all non-overlapping occurrences the specified <code>separator</code> string by greedily scanning from left to right in the input string, <code>str</code>. The input string is then logically chopped into parts at each separator position and the parts are assembled into the return value. Only up to <code>maxparts-1</code> occurrences of the <code>separator</code> string are found, and any remaining occurrences are not treated specially. For instance, if <code>maxparts</code> is two then at most one separator is found and at most two substrings are returned. Separators at positions that would result in empty substrings being returned are not treated specially&ndash;empty substrings can be returned. This occurs when a separator is found at the beginning or end of a string or two separators are adjacent. The C++ library already has other functions for removing empty strings from a list. If <code>trim_white_space</code> is true then white space is removed from the beginning and end of each returned substring and resulting empty substrings are not removed from the return value. The first few arguments are in the same order as for Perl's "split" operator. </p>

</div>
</div>
<a id="acd8c27a14b818d7756ab613890f56985"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd8c27a14b818d7756ab613890f56985">&#9670;&nbsp;</a></span>split() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_UTIL_API std::vector&lt;std::string&gt; Rose::StringUtility::split </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>separator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxparts</em> = <code><a class="el" href="namespaceRose.html#ac6b909559ee66844a1235ba9cc72aec8">UNLIMITED</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>trim_white_space</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splits strings into parts. </p>
<p>Find all non-overlapping occurrences the specified <code>separator</code> string by greedily scanning from left to right in the input string, <code>str</code>. The input string is then logically chopped into parts at each separator position and the parts are assembled into the return value. Only up to <code>maxparts-1</code> occurrences of the <code>separator</code> string are found, and any remaining occurrences are not treated specially. For instance, if <code>maxparts</code> is two then at most one separator is found and at most two substrings are returned. Separators at positions that would result in empty substrings being returned are not treated specially&ndash;empty substrings can be returned. This occurs when a separator is found at the beginning or end of a string or two separators are adjacent. The C++ library already has other functions for removing empty strings from a list. If <code>trim_white_space</code> is true then white space is removed from the beginning and end of each returned substring and resulting empty substrings are not removed from the return value. The first few arguments are in the same order as for Perl's "split" operator. </p>

</div>
</div>
<a id="a7ab237320e2746a1aa10f0ff8920f0e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ab237320e2746a1aa10f0ff8920f0e7">&#9670;&nbsp;</a></span>tokenize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_UTIL_API std::list&lt;std::string&gt; Rose::StringUtility::tokenize </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split a string into a list based on a separator character. </p>
<p>Scans the input string for delimiter characters and splits the input into substrings at each delimiter positions. The delimiter is not included in the substring. Consecutive delimiter characters will result in an empty substring. </p>

</div>
</div>
<a id="aeb883fe97d7e41ab393b2dee47519e56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb883fe97d7e41ab393b2dee47519e56">&#9670;&nbsp;</a></span>join_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string Rose::StringUtility::join_range </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>separator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Join individual items to form a single string. </p>
<p>Given a container containing printable objects (such as <code>std::list&lt;std::string&gt;</code>, join the objects together separated from one another by the specified <code>separator</code>. The separator does not appear before the first object or after the final object. If the container is empty then an empty string is returned. </p>

<p class="definition">Definition at line <a class="el" href="SplitJoin_8h_source.html#l00053">53</a> of file <a class="el" href="SplitJoin_8h_source.html">SplitJoin.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="SplitJoin_8h_source.html#l00061">join()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceRose_1_1StringUtility_aeb883fe97d7e41ab393b2dee47519e56_icgraph.png" border="0" usemap="#namespaceRose_1_1StringUtility_aeb883fe97d7e41ab393b2dee47519e56_icgraph" alt=""/></div>
<map name="namespaceRose_1_1StringUtility_aeb883fe97d7e41ab393b2dee47519e56_icgraph" id="namespaceRose_1_1StringUtility_aeb883fe97d7e41ab393b2dee47519e56_icgraph">
<area shape="rect" title="Join individual items to form a single string." alt="" coords="183,5,312,47"/>
<area shape="rect" href="namespaceRose_1_1StringUtility.html#ab8dedf8e0b97da2ed5740173b5f85d28" title="Join individual items to form a single string." alt="" coords="5,5,135,47"/>
</map>
</div>

</div>
</div>
<a id="ab8dedf8e0b97da2ed5740173b5f85d28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8dedf8e0b97da2ed5740173b5f85d28">&#9670;&nbsp;</a></span>join() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string Rose::StringUtility::join </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>separator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>container</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Join individual items to form a single string. </p>
<p>Given a container containing printable objects (such as <code>std::list&lt;std::string&gt;</code>, join the objects together separated from one another by the specified <code>separator</code>. The separator does not appear before the first object or after the final object. If the container is empty then an empty string is returned. </p>

<p class="definition">Definition at line <a class="el" href="SplitJoin_8h_source.html#l00061">61</a> of file <a class="el" href="SplitJoin_8h_source.html">SplitJoin.h</a>.</p>

<p class="reference">References <a class="el" href="SplitJoin_8h_source.html#l00053">join_range()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceRose_1_1StringUtility_ab8dedf8e0b97da2ed5740173b5f85d28_cgraph.png" border="0" usemap="#namespaceRose_1_1StringUtility_ab8dedf8e0b97da2ed5740173b5f85d28_cgraph" alt=""/></div>
<map name="namespaceRose_1_1StringUtility_ab8dedf8e0b97da2ed5740173b5f85d28_cgraph" id="namespaceRose_1_1StringUtility_ab8dedf8e0b97da2ed5740173b5f85d28_cgraph">
<area shape="rect" title="Join individual items to form a single string." alt="" coords="5,5,135,47"/>
<area shape="rect" href="namespaceRose_1_1StringUtility.html#aeb883fe97d7e41ab393b2dee47519e56" title="Join individual items to form a single string." alt="" coords="183,5,312,47"/>
</map>
</div>

</div>
</div>
<a id="ad9ab2959d0b18bfc3f5054d753ccfb31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9ab2959d0b18bfc3f5054d753ccfb31">&#9670;&nbsp;</a></span>join() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string Rose::StringUtility::join </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>separator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>container</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Join individual items to form a single string. </p>
<p>Given a container containing printable objects (such as <code>std::list&lt;std::string&gt;</code>, join the objects together separated from one another by the specified <code>separator</code>. The separator does not appear before the first object or after the final object. If the container is empty then an empty string is returned. </p>

<p class="definition">Definition at line <a class="el" href="SplitJoin_8h_source.html#l00066">66</a> of file <a class="el" href="SplitJoin_8h_source.html">SplitJoin.h</a>.</p>

<p class="reference">References <a class="el" href="SplitJoin_8h_source.html#l00053">join_range()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceRose_1_1StringUtility_ad9ab2959d0b18bfc3f5054d753ccfb31_cgraph.png" border="0" usemap="#namespaceRose_1_1StringUtility_ad9ab2959d0b18bfc3f5054d753ccfb31_cgraph" alt=""/></div>
<map name="namespaceRose_1_1StringUtility_ad9ab2959d0b18bfc3f5054d753ccfb31_cgraph" id="namespaceRose_1_1StringUtility_ad9ab2959d0b18bfc3f5054d753ccfb31_cgraph">
<area shape="rect" title="Join individual items to form a single string." alt="" coords="5,5,135,47"/>
<area shape="rect" href="namespaceRose_1_1StringUtility.html#aeb883fe97d7e41ab393b2dee47519e56" title="Join individual items to form a single string." alt="" coords="183,5,312,47"/>
</map>
</div>

</div>
</div>
<a id="af5db0a39edbecf0d631e1218496b3087"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5db0a39edbecf0d631e1218496b3087">&#9670;&nbsp;</a></span>join() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_UTIL_API std::string Rose::StringUtility::join </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>separator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>strings</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nstrings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Join individual items to form a single string. </p>
<p>Given a container containing printable objects (such as <code>std::list&lt;std::string&gt;</code>, join the objects together separated from one another by the specified <code>separator</code>. The separator does not appear before the first object or after the final object. If the container is empty then an empty string is returned. </p>

</div>
</div>
<a id="aca004eb6e0fb43eed712ac0e1996501f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca004eb6e0fb43eed712ac0e1996501f">&#9670;&nbsp;</a></span>join() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_UTIL_API std::string Rose::StringUtility::join </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>separator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>strings</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nstrings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Join individual items to form a single string. </p>
<p>Given a container containing printable objects (such as <code>std::list&lt;std::string&gt;</code>, join the objects together separated from one another by the specified <code>separator</code>. The separator does not appear before the first object or after the final object. If the container is empty then an empty string is returned. </p>

</div>
</div>
<a id="a751d30be14039722d8b9fa218f75e35f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a751d30be14039722d8b9fa218f75e35f">&#9670;&nbsp;</a></span>join() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_UTIL_API std::string Rose::StringUtility::join </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>separator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>strings</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nstrings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Join individual items to form a single string. </p>
<p>Given a container containing printable objects (such as <code>std::list&lt;std::string&gt;</code>, join the objects together separated from one another by the specified <code>separator</code>. The separator does not appear before the first object or after the final object. If the container is empty then an empty string is returned. </p>

</div>
</div>
<a id="ac276edb3fb26bd8afc70b8bae9a91eae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac276edb3fb26bd8afc70b8bae9a91eae">&#9670;&nbsp;</a></span>join() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_UTIL_API std::string Rose::StringUtility::join </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>separator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>strings</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nstrings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Join individual items to form a single string. </p>
<p>Given a container containing printable objects (such as <code>std::list&lt;std::string&gt;</code>, join the objects together separated from one another by the specified <code>separator</code>. The separator does not appear before the first object or after the final object. If the container is empty then an empty string is returned. </p>

</div>
</div>
<a id="af843a06506631ee1781c2bd44cf207ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af843a06506631ee1781c2bd44cf207ef">&#9670;&nbsp;</a></span>joinEnglish()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_UTIL_API std::string Rose::StringUtility::joinEnglish </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>phrases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>separator</em> = <code>&quot;,&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>finalIntro</em> = <code>&quot;and&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Join strings as if they were English prose. </p>
<p>This is useful when generating documentation strings.</p>
<p>If the input is empty, the output is the empty string. I.e., <code>() =&gt; ""</code></p>
<p>If the input is one phrase, the output is that phrase. E.g., <code>("foo") =&gt; "foo"</code></p>
<p>If the input is two phrases, the output will be those two phrases separated by "and" (the <code>finalIntro</code>). E.g., <code>("foo", "bar") =&gt; "foo and bar"</code></p>
<p>If the input is three or more phrases, they will be separated from one another by commas (the <code>separator</code>) and the last item will also be introduced with "and" (the <code>finalIntro</code>). E.g., <code>("foo", "bar", "baz") =&gt; "foo, bar, and baz"</code></p>
<p>No transformations are performed on the input phrases. Space characters are inserted after each <code>separator</code> and <code>finalIntro</code>. A space is also inserted before the <code>finalIntro</code> when the input is two phrases. </p>

</div>
</div>
<a id="a37cf7a8302faea91ce6bfcfb75c52dd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37cf7a8302faea91ce6bfcfb75c52dd1">&#9670;&nbsp;</a></span>listToString() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_UTIL_API std::string Rose::StringUtility::listToString </td>
          <td>(</td>
          <td class="paramtype">const std::list&lt; int &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>separateStrings</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a string from a list of integers. </p>
<p>The return value is the concatenation of substrings. Each substring is formed by converting the corresponding integer from the list into a string via <a class="el" href="namespaceRose_1_1StringUtility.html#a71f0fb9e006fb962ba3d9429c5ed935f">numberToString</a> and then adding a single space character and an optional line feed. The line feeds are added only if <code>separateStrings</code> is true. </p>

</div>
</div>
<a id="a701a13f2f85ea65d2d5a2f5cc0e17f77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a701a13f2f85ea65d2d5a2f5cc0e17f77">&#9670;&nbsp;</a></span>listToString() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_UTIL_API std::string Rose::StringUtility::listToString </td>
          <td>(</td>
          <td class="paramtype">const std::list&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>separateStrings</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a string from a container of strings. </p>
<p>The return value is the concatenation of substrings. Each substring is formed by adding a single space to the corresponding list element and an optional line feed. The line feeds are added only if <code>separateStrings</code> is true. </p>

</div>
</div>
<a id="a437fdb99d743e615f4d0fb6acc5e7231"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a437fdb99d743e615f4d0fb6acc5e7231">&#9670;&nbsp;</a></span>listToString() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_UTIL_API std::string Rose::StringUtility::listToString </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>separateStrings</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a string from a container of strings. </p>
<p>The return value is the concatenation of substrings. Each substring is formed by adding a single space to the corresponding list element and an optional line feed. The line feeds are added only if <code>separateStrings</code> is true. </p>

</div>
</div>
<a id="a12064fe617818daf804c1c773c1fc67a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12064fe617818daf804c1c773c1fc67a">&#9670;&nbsp;</a></span>stringToList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_UTIL_API std::list&lt;std::string&gt; Rose::StringUtility::stringToList </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split a string into substrings at line feeds. </p>
<p>Splits the input string into substrings at the linefeed characters to construct a list, then removes empty strings from the list.</p>
<p>The original implementation (pre-2016) had a bug (ROSE-304) that caused the last substring to not be returned if it was not followed by a linefeed. That implementation was also slow for large inputs (ROSE-305). Both of these are now fixed since stringToList is now implemented in terms of <a class="el" href="namespaceRose_1_1StringUtility.html#abeb29cbfa6cea9b3c9cd3c1481a5c79a">split</a>. </p>

</div>
</div>
<a id="a44907c4ec299747975586824d9d088ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44907c4ec299747975586824d9d088ae">&#9670;&nbsp;</a></span>splitStringIntoStrings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_UTIL_API void Rose::StringUtility::splitStringIntoStrings </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>inputString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>separator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>stringList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splits string into substring based on a separator character. </p>
<p>Empty strings are removed from the result, which is returned in the <code>stringList</code> argument. The return argument is cleared before the splitting begins. </p>

</div>
</div>
<a id="ac2de64d792fa7e3ebfadc1211744a7a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2de64d792fa7e3ebfadc1211744a7a8">&#9670;&nbsp;</a></span>hexadecimalToInt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_UTIL_API unsigned Rose::StringUtility::hexadecimalToInt </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an ASCII hexadecimal character to an integer. </p>
<p>Converts the characters 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, a, b, c, d, e, f, A, B, C, D, E, and F into their hexadecimal integer equivalents. Returns zero if the input character is not in this set. </p>

</div>
</div>
<a id="a0893d3ce864ceb579daa758fae1f0cc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0893d3ce864ceb579daa758fae1f0cc8">&#9670;&nbsp;</a></span>toStrings()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container , class Stringifier &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; Rose::StringUtility::toStrings </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>numbers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRose_1_1Stringifier.html">Stringifier</a> &amp;&#160;</td>
          <td class="paramname"><em>stringifier</em> = <code><a class="el" href="namespaceRose_1_1StringUtility.html#a71f0fb9e006fb962ba3d9429c5ed935f">numberToString</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a bunch of numbers to strings. </p>
<p>This is convenient when one has a container of numbers and wants to call <a class="el" href="namespaceRose_1_1StringUtility.html#ab8dedf8e0b97da2ed5740173b5f85d28">join</a> to turn it into a single string. For instance, here's how to convert a set of integers to a comma-separated list:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceRose_1_1StringUtility.html">Rose::StringUtility</a>;</div>
<div class="line">std::set&lt;int&gt; numbers = ...;</div>
<div class="line">std::string s = <a class="code" href="namespaceRose_1_1StringUtility.html#ab8dedf8e0b97da2ed5740173b5f85d28">join</a>(<span class="stringliteral">&quot;, &quot;</span>, <a class="code" href="namespaceRose_1_1StringUtility.html#a0893d3ce864ceb579daa758fae1f0cc8">toStrings</a>(numbers));</div>
</div><!-- fragment --><p>Here's how to convert a vector of addresses to space-separated hexadecimal values: </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceRose_1_1StringUtility.html">Rose::StringUtility</a>;</div>
<div class="line">std::vector&lt;rose_addr_t&gt; addresses = ...;</div>
<div class="line">std::string s = <a class="code" href="namespaceRose_1_1StringUtility.html#ab8dedf8e0b97da2ed5740173b5f85d28">join</a>(<span class="stringliteral">&quot; &quot;</span>, <a class="code" href="namespaceRose_1_1StringUtility.html#a0893d3ce864ceb579daa758fae1f0cc8">toStrings</a>(addresses, <a class="code" href="namespaceRose_1_1StringUtility.html#a1601608fa2856aa31397370b8b5923c4">addrToString</a>));</div>
</div><!-- fragment --><p>Here's how one could surround each address with angle brackets: </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceRose_1_1StringUtility.html">Rose::StringUtility</a>;</div>
<div class="line"><span class="keyword">struct </span>AngleSurround {</div>
<div class="line">    std::string operator()(rose_addr_t addr) {</div>
<div class="line">       <span class="keywordflow">return</span> <span class="stringliteral">&quot;&lt;&quot;</span> + <a class="code" href="namespaceRose_1_1StringUtility.html#a1601608fa2856aa31397370b8b5923c4">addrToString</a>(addr) + <span class="stringliteral">&quot;&gt;&quot;</span>;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line">std::string s = <a class="code" href="namespaceRose_1_1StringUtility.html#ab8dedf8e0b97da2ed5740173b5f85d28">join</a>(<span class="stringliteral">&quot; &quot;</span>, <a class="code" href="namespaceRose_1_1StringUtility.html#a0893d3ce864ceb579daa758fae1f0cc8">toStrings</a>(addresses, AngleSurround()));</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="StringToNumber_8h_source.html#l00060">60</a> of file <a class="el" href="StringToNumber_8h_source.html">StringToNumber.h</a>.</p>

<p class="reference">References <a class="el" href="StringToNumber_8h_source.html#l00064">toStrings_range()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceRose_1_1StringUtility_a0893d3ce864ceb579daa758fae1f0cc8_cgraph.png" border="0" usemap="#namespaceRose_1_1StringUtility_a0893d3ce864ceb579daa758fae1f0cc8_cgraph" alt=""/></div>
<map name="namespaceRose_1_1StringUtility_a0893d3ce864ceb579daa758fae1f0cc8_cgraph" id="namespaceRose_1_1StringUtility_a0893d3ce864ceb579daa758fae1f0cc8_cgraph">
<area shape="rect" title="Converts a bunch of numbers to strings." alt="" coords="5,5,135,47"/>
<area shape="rect" href="namespaceRose_1_1StringUtility.html#afb90adb3f307f62a1f326514e8dbc407" title="Converts a bunch of numbers to strings." alt="" coords="183,5,312,47"/>
</map>
</div>

</div>
</div>
<a id="afb90adb3f307f62a1f326514e8dbc407"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb90adb3f307f62a1f326514e8dbc407">&#9670;&nbsp;</a></span>toStrings_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Iterator , class Stringifier &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; Rose::StringUtility::toStrings_range </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRose_1_1Stringifier.html">Stringifier</a> &amp;&#160;</td>
          <td class="paramname"><em>stringifier</em> = <code><a class="el" href="namespaceRose_1_1StringUtility.html#a71f0fb9e006fb962ba3d9429c5ed935f">numberToString</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a bunch of numbers to strings. </p>
<p>This is convenient when one has a container of numbers and wants to call <a class="el" href="namespaceRose_1_1StringUtility.html#ab8dedf8e0b97da2ed5740173b5f85d28">join</a> to turn it into a single string. For instance, here's how to convert a set of integers to a comma-separated list:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceRose_1_1StringUtility.html">Rose::StringUtility</a>;</div>
<div class="line">std::set&lt;int&gt; numbers = ...;</div>
<div class="line">std::string s = <a class="code" href="namespaceRose_1_1StringUtility.html#ab8dedf8e0b97da2ed5740173b5f85d28">join</a>(<span class="stringliteral">&quot;, &quot;</span>, <a class="code" href="namespaceRose_1_1StringUtility.html#a0893d3ce864ceb579daa758fae1f0cc8">toStrings</a>(numbers));</div>
</div><!-- fragment --><p>Here's how to convert a vector of addresses to space-separated hexadecimal values: </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceRose_1_1StringUtility.html">Rose::StringUtility</a>;</div>
<div class="line">std::vector&lt;rose_addr_t&gt; addresses = ...;</div>
<div class="line">std::string s = <a class="code" href="namespaceRose_1_1StringUtility.html#ab8dedf8e0b97da2ed5740173b5f85d28">join</a>(<span class="stringliteral">&quot; &quot;</span>, <a class="code" href="namespaceRose_1_1StringUtility.html#a0893d3ce864ceb579daa758fae1f0cc8">toStrings</a>(addresses, <a class="code" href="namespaceRose_1_1StringUtility.html#a1601608fa2856aa31397370b8b5923c4">addrToString</a>));</div>
</div><!-- fragment --><p>Here's how one could surround each address with angle brackets: </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceRose_1_1StringUtility.html">Rose::StringUtility</a>;</div>
<div class="line"><span class="keyword">struct </span>AngleSurround {</div>
<div class="line">    std::string operator()(rose_addr_t addr) {</div>
<div class="line">       <span class="keywordflow">return</span> <span class="stringliteral">&quot;&lt;&quot;</span> + <a class="code" href="namespaceRose_1_1StringUtility.html#a1601608fa2856aa31397370b8b5923c4">addrToString</a>(addr) + <span class="stringliteral">&quot;&gt;&quot;</span>;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line">std::string s = <a class="code" href="namespaceRose_1_1StringUtility.html#ab8dedf8e0b97da2ed5740173b5f85d28">join</a>(<span class="stringliteral">&quot; &quot;</span>, <a class="code" href="namespaceRose_1_1StringUtility.html#a0893d3ce864ceb579daa758fae1f0cc8">toStrings</a>(addresses, AngleSurround()));</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="StringToNumber_8h_source.html#l00064">64</a> of file <a class="el" href="StringToNumber_8h_source.html">StringToNumber.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="StringToNumber_8h_source.html#l00060">toStrings()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceRose_1_1StringUtility_afb90adb3f307f62a1f326514e8dbc407_icgraph.png" border="0" usemap="#namespaceRose_1_1StringUtility_afb90adb3f307f62a1f326514e8dbc407_icgraph" alt=""/></div>
<map name="namespaceRose_1_1StringUtility_afb90adb3f307f62a1f326514e8dbc407_icgraph" id="namespaceRose_1_1StringUtility_afb90adb3f307f62a1f326514e8dbc407_icgraph">
<area shape="rect" title="Converts a bunch of numbers to strings." alt="" coords="183,5,312,47"/>
<area shape="rect" href="namespaceRose_1_1StringUtility.html#a0893d3ce864ceb579daa758fae1f0cc8" title="Converts a bunch of numbers to strings." alt="" coords="5,5,135,47"/>
</map>
</div>

</div>
</div>
<a id="ad08c20bdcb39760f890b9d139048e3f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad08c20bdcb39760f890b9d139048e3f5">&#9670;&nbsp;</a></span>toDigit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IntegralType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Optional.html">Sawyer::Optional</a>&lt;typename std::enable_if&lt;std::is_integral&lt;IntegralType&gt;::value, IntegralType&gt;::type&gt; Rose::StringUtility::toDigit </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegralType&#160;</td>
          <td class="paramname"><em>radix</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a character to a numeric digit. </p>
<p>If the character is valid for the specified radix, then its numeric value is returned, otherwise nothing is returned. The radix must be less than or equal to 16. </p>

<p class="definition">Definition at line <a class="el" href="StringToNumber_8h_source.html#l00078">78</a> of file <a class="el" href="StringToNumber_8h_source.html">StringToNumber.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="StringToNumber_8h_source.html#l00112">toNumber()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceRose_1_1StringUtility_ad08c20bdcb39760f890b9d139048e3f5_icgraph.png" border="0" usemap="#namespaceRose_1_1StringUtility_ad08c20bdcb39760f890b9d139048e3f5_icgraph" alt=""/></div>
<map name="namespaceRose_1_1StringUtility_ad08c20bdcb39760f890b9d139048e3f5_icgraph" id="namespaceRose_1_1StringUtility_ad08c20bdcb39760f890b9d139048e3f5_icgraph">
<area shape="rect" title="Convert a character to a numeric digit." alt="" coords="183,5,312,47"/>
<area shape="rect" href="namespaceRose_1_1StringUtility.html#aeef730bf985791334cad7f92950a5511" title="Safely convert a string to a number using C++ style syntax." alt="" coords="5,5,135,47"/>
</map>
</div>

</div>
</div>
<a id="aeef730bf985791334cad7f92950a5511"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeef730bf985791334cad7f92950a5511">&#9670;&nbsp;</a></span>toNumber()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IntegralType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::is_integral&lt;IntegralType&gt;::value, <a class="el" href="classSawyer_1_1Result.html">Sawyer::Result</a>&lt;IntegralType, std::string&gt; &gt;::type Rose::StringUtility::toNumber </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Safely convert a string to a number using C++ style syntax. </p>
<p>The input string must parse as a integer without leading white space and without trailing characters. For signed integer types, the integer may be immediately preceded by a minus ("-") or plus ("+") sign. The integer part may be preceded by a radix indicator: "0x" for hexadecimal or "0b" for binary. Octal and other radices are not supported. Digits may be separated from one another (or from the radix specifier) by a single underscore, as in "0b_0001_0010_0011_0100_0101_0110_0111_1000".</p>
<p>The <code>IntegralType</code> must be a signed or unsigned integer type of any width. The <code>uint8_t</code> and <code>int8_t</code> types are also accepted although they're aliases for <code>unsigned char</code> and <code>signed char</code> .</p>
<p>If a syntax error occurs, or if the magnitude of the value is too large to be represented by the specified <code>IntegralType</code>, then an error message is returned. The text of the message begins with either "syntax error:" or "overflow error:". </p>

<p class="definition">Definition at line <a class="el" href="StringToNumber_8h_source.html#l00112">112</a> of file <a class="el" href="StringToNumber_8h_source.html">StringToNumber.h</a>.</p>

<p class="reference">References <a class="el" href="StringUtility_2Diagnostics_8h_source.html#l00067">plural()</a>, and <a class="el" href="StringToNumber_8h_source.html#l00078">toDigit()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceRose_1_1StringUtility_aeef730bf985791334cad7f92950a5511_cgraph.png" border="0" usemap="#namespaceRose_1_1StringUtility_aeef730bf985791334cad7f92950a5511_cgraph" alt=""/></div>
<map name="namespaceRose_1_1StringUtility_aeef730bf985791334cad7f92950a5511_cgraph" id="namespaceRose_1_1StringUtility_aeef730bf985791334cad7f92950a5511_cgraph">
<area shape="rect" title="Safely convert a string to a number using C++ style syntax." alt="" coords="5,39,135,80"/>
<area shape="rect" href="namespaceRose_1_1StringUtility.html#abf7821b02ca01054a3b4303aff3086e2" title="Helpful way to print singular or plural words." alt="" coords="183,5,312,47"/>
<area shape="rect" href="namespaceRose_1_1StringUtility.html#ad08c20bdcb39760f890b9d139048e3f5" title="Convert a character to a numeric digit." alt="" coords="183,71,312,112"/>
</map>
</div>

</div>
</div>
<a id="a52995b3cbeeb19334b68a3d6cd704586"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52995b3cbeeb19334b68a3d6cd704586">&#9670;&nbsp;</a></span>toNumberOrThrow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IntegralType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::is_integral&lt;IntegralType&gt;::value, IntegralType&gt;::type Rose::StringUtility::toNumberOrThrow </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Safely convert a string to a number using C++ style syntax. </p>
<p>This function is identical to <a class="el" href="namespaceRose_1_1StringUtility.html#aeef730bf985791334cad7f92950a5511">toNumber</a> except in the error situation. If an error occurs, then a <code><a class="el" href="classRose_1_1Exception.html" title="Base class for all ROSE exceptions.">Rose::Exception</a></code> is thrown whose message is the error message. </p>

<p class="definition">Definition at line <a class="el" href="StringToNumber_8h_source.html#l00198">198</a> of file <a class="el" href="StringToNumber_8h_source.html">StringToNumber.h</a>.</p>

</div>
</div>
<a id="aa4a509e656483a877644b17d8344cc6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4a509e656483a877644b17d8344cc6c">&#9670;&nbsp;</a></span>writeFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_UTIL_API void Rose::StringUtility::writeFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>outputString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fileNameString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>directoryName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a file. </p>
<p>Creates a new file, truncating any existing file with the same name, and writes the string <code>outputString</code> into the file. The name of the file is constructed by concatenating <code>directoryName</code> and <code>fileNameString</code> without any intervening component separator (e.g., no "/").</p>
<p>If the file cannot be created then this function silently fails (or aborts if ROSE is compiled in debug mode). </p>

</div>
</div>
<a id="a94d686d29f5954bba2b30822e09dc6aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94d686d29f5954bba2b30822e09dc6aa">&#9670;&nbsp;</a></span>readFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_UTIL_API std::string Rose::StringUtility::readFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fileName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads entire text file. </p>
<p>Opens the specified file, reads its contents into a string, closes the file, and returns that string.</p>
<p>If the file cannot be opened then an std::string error message is thrown. The message reads "File not found" regardless of the actual error condition. </p>

</div>
</div>
<a id="af3d8e3bba4ccca3da3d9501f02c9e757"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3d8e3bba4ccca3da3d9501f02c9e757">&#9670;&nbsp;</a></span>readFileWithPos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_UTIL_API <a class="el" href="namespaceRose_1_1StringUtility.html#acddf0f6a1575dbd791fb139de7ffa57f">FileWithLineNumbers</a> Rose::StringUtility::readFileWithPos </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fileName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an entire text file. </p>
<p>Opens the specified file, reads its contents line by line into a vector of strings with location information, closes the file, and returns the vector. The file names in the returned value are absolute names. The strings in the return value have their final line-feeds removed.</p>
<p>If the file cannot be opened then an std::string error message is thrown. The message reads "File not found" regardless of the actual error condition. </p>

</div>
</div>
<a id="a9272148d7ac9a8b3762b63d4d0e836a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9272148d7ac9a8b3762b63d4d0e836a6">&#9670;&nbsp;</a></span>homeDir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_UTIL_API void Rose::StringUtility::homeDir </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>dir</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Name of the home directory. </p>
<p>Returns the value of the "HOME" environment variable by copying it into the <code>dir</code> argument. Will segfault if this environment variable is not set. </p>

</div>
</div>
<a id="ac895cf4df6fe844ca420bdce757ced0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac895cf4df6fe844ca420bdce757ced0b">&#9670;&nbsp;</a></span>stripPathFromFileName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_UTIL_API std::string Rose::StringUtility::stripPathFromFileName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fileNameWithPath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the last component of a path in a filesystem. </p>
<p>Removes the "path" part of a "filename" (if there is one) and returns just the file name.</p>
<p>Terms are loosely defined and not likely to work for non-POSIX systems; consider using boost::filesystem instead. </p>

</div>
</div>
<a id="a49afc611d92c58b7ec228d2d60ff2ad4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49afc611d92c58b7ec228d2d60ff2ad4">&#9670;&nbsp;</a></span>getPathFromFileName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_UTIL_API std::string Rose::StringUtility::getPathFromFileName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fileNameWithPath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns all but the last component of a path in a filesystem. </p>
<p>This function removes the filename from the combined path and filename if it includes a path and returns only the path. Make it safe to input a filename without a path name (return the filename).</p>
<p>Terms are loosely defined and this function possibly doesn't work for non-POSIX file systems; consider using boost::filesystem instead. </p>

</div>
</div>
<a id="a29d142bf2b88492d444d910ba8e603ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29d142bf2b88492d444d910ba8e603ec">&#9670;&nbsp;</a></span>stripFileSuffixFromFileName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_UTIL_API std::string Rose::StringUtility::stripFileSuffixFromFileName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fileNameWithSuffix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the file name without the ".suffix". </p>
<p>Terms are loosely defined and it's not clear what happens for inputs like ".", ".foo", "..", ".foo.bar", "/.", etc. Consider using boost::filesystem instead. </p>

</div>
</div>
<a id="af529063bdc538a23d815a5e554c545e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af529063bdc538a23d815a5e554c545e9">&#9670;&nbsp;</a></span>getAbsolutePathFromRelativePath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_UTIL_API std::string Rose::StringUtility::getAbsolutePathFromRelativePath </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>relativePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>printErrorIfAny</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the absolute path from the relative path. </p>
<p>Terms are loosely defined and this function is not likely to work on non-POSIX systems. Consider using boost::filesystem instead. </p>

</div>
</div>
<a id="a2001c82471744d573b11c6cb9dd6371a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2001c82471744d573b11c6cb9dd6371a">&#9670;&nbsp;</a></span>fileNameSuffix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_UTIL_API std::string Rose::StringUtility::fileNameSuffix </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fileName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the file name suffix (extension) without the leading dot. </p>
<p>Filename could be either base name or name with full path. If no dot is found in the input fileName, the function just returns the original fileName.</p>
<p>Terms are loosely defined and this function is not likely to work correctly in some situations, such as when the "." is not in the last component of the file name. Consider using boost::filesystem instead. </p>

</div>
</div>
<a id="a5418684ba5945fb76fcdcfb7ba244f85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5418684ba5945fb76fcdcfb7ba244f85">&#9670;&nbsp;</a></span>findfile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_UTIL_API std::list&lt;std::string&gt; Rose::StringUtility::findfile </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>patternString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>pathString</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find file names non-recursively. </p>
<p>Scans the directory named <code>pathString</code> and returns a list of files in that directory which have <code>patternString</code> as a substring of their name. Note that <code>patternString</code> is not a glob or regular expression. The return value strings are formed by concatenating the <code>pathString</code> and the file name with an intervening slash.</p>
<p>This function does not work for non-POSIX systems. Consider using boost::filesystem instead, which has a directory iterator that works for non-POSIX systems also. </p>

</div>
</div>
<a id="af4cdd7ade0f7d6af216362c5351af6aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4cdd7ade0f7d6af216362c5351af6aa">&#9670;&nbsp;</a></span>classifyFileName() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_UTIL_API <a class="el" href="classRose_1_1StringUtility_1_1FileNameClassification.html">FileNameClassification</a> Rose::StringUtility::classifyFileName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>appPath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine whether a file is source code or system library. </p>
<p>Given a fileName and an appPath that is a path to some application's source code directory, return a <a class="el" href="classRose_1_1StringUtility_1_1FileNameClassification.html">FileNameClassification</a> indicating whether the fileName is part of the source code or some system library and automatically determine the operating system from the host uname </p>

</div>
</div>
<a id="a705fd196f2a1c8c1bf517ce6671c8b0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a705fd196f2a1c8c1bf517ce6671c8b0c">&#9670;&nbsp;</a></span>classifyFileName() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_UTIL_API <a class="el" href="classRose_1_1StringUtility_1_1FileNameClassification.html">FileNameClassification</a> Rose::StringUtility::classifyFileName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>appPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OSType&#160;</td>
          <td class="paramname"><em>os</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine whether a file is source code or system library. </p>
<p>Given a fileName and an appPath that is a path to some application's source code directory, return a <a class="el" href="classRose_1_1StringUtility_1_1FileNameClassification.html">FileNameClassification</a> indicating whether the fileName is part of the source code or some system library </p>

</div>
</div>
<a id="a871cf4c7310cb9916d4e32ff229ee1c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a871cf4c7310cb9916d4e32ff229ee1c3">&#9670;&nbsp;</a></span>classifyFileName() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_UTIL_API <a class="el" href="classRose_1_1StringUtility_1_1FileNameClassification.html">FileNameClassification</a> Rose::StringUtility::classifyFileName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>appPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>libPathCollection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine whether a file is source code or system library. </p>
<p>Given a fileName and an appPath that is a path to some application's source code directory, and a collection of library paths, return a <a class="el" href="classRose_1_1StringUtility_1_1FileNameClassification.html">FileNameClassification</a> indicating whether the fileName is part of the source code or some system library and automatically determine the operating system from the host uname </p>

</div>
</div>
<a id="a32bb771efbd8ba483a4ee90ea06fbfb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32bb771efbd8ba483a4ee90ea06fbfb5">&#9670;&nbsp;</a></span>classifyFileName() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_UTIL_API <a class="el" href="classRose_1_1StringUtility_1_1FileNameClassification.html">FileNameClassification</a> Rose::StringUtility::classifyFileName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>appPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>libPathCollection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OSType&#160;</td>
          <td class="paramname"><em>os</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine whether a file is source code or system library. </p>
<p>Given a fileName and an appPath that is a path to some application's source code directory, and a collection of library paths, return a <a class="el" href="classRose_1_1StringUtility_1_1FileNameClassification.html">FileNameClassification</a> indicating whether the fileName is part of the source code or some system library </p>

</div>
</div>
<a id="a6e119b1db1e54fe0358a18b4cada6294"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e119b1db1e54fe0358a18b4cada6294">&#9670;&nbsp;</a></span>stripDotsFromHeaderFileName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const ROSE_UTIL_API std::string Rose::StringUtility::stripDotsFromHeaderFileName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove leading dots. </p>
<p>Removes leading dots plus a space from a header file name that is given in the format that g++ -H returns </p>

</div>
</div>
<a id="a2a21cf61077a6ac9d8c24c63484c96cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a21cf61077a6ac9d8c24c63484c96cf">&#9670;&nbsp;</a></span>directoryDistance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_UTIL_API int Rose::StringUtility::directoryDistance </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Edit distance between two directory names. </p>
<p>Essentially the edit distance without substituion in directory name tokens between two directories. Returns the "distance" between left and right. The distance is defined as the number of cd's that only move up or down one directory that it would take to move from the directory of the filename to the directory that was given by appPath. This is intended as a heuristic to gage whether or not one believes that the left is related to the right directory. Examples:</p>
<p>Between /a/b/c/file.h and /a/b/d/e/ the distance is 3 because one must cd ..; cd d; cd e </p>

</div>
</div>
<a id="a6eca43732a911d67d335c6d5a2928c20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eca43732a911d67d335c6d5a2928c20">&#9670;&nbsp;</a></span>readWordsInFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_UTIL_API std::vector&lt;std::string&gt; Rose::StringUtility::readWordsInFile </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads words from a file. </p>
<p>Opens the specified file for reading and reads all words from the file using <code>std::istream</code> <code>operator&gt;&gt;</code> into <code>std::string</code>. If the file cannot be opened then an error message is printed to standard output (not error) and the program exits with status 1. </p>

</div>
</div>
<a id="abe4194514213d1b6d3c541a4dff9eaab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe4194514213d1b6d3c541a4dff9eaab">&#9670;&nbsp;</a></span>popen_wrapper()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::StringUtility::popen_wrapper </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>command</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simple wrapper for Unix popen command. </p>
<p>If there is a failure (cannot create pipes, command not found, command terminated abnormally, input buffer too small, etc), then an error is printed to standard error (with or without line termination) and false is returned. When an error occurs the pipes that were opened to communicate with the subcommand might not be closed. </p>

</div>
</div>
<a id="ab128401cca6edd03b3c366f9fa1f458c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab128401cca6edd03b3c366f9fa1f458c">&#9670;&nbsp;</a></span>toString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_UTIL_API std::string Rose::StringUtility::toString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1StringUtility.html#acddf0f6a1575dbd791fb139de7ffa57f">FileWithLineNumbers</a> &amp;&#160;</td>
          <td class="paramname"><em>strings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em> = <code>&quot;&lt;unknown&gt;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate C preprocessor #line directives. </p>
<p>Given a vector of strings with source location information, print those strings with intervening C preprocessor #line directives. For strings that have no source location, use the specified <code>filename</code> argument as the name of the file. The <code>physicalLine</code> is the line number to assume for the first line of output (the return value). The #line directives are not emitted into the return value when they're not needed (e.g., two <code>strings</code> are at successive line numbers of the same source file) or if ROSE has been configured to not emit #line directivies (i.e., the <code>SKIP_HASH_LINE_NUMBER_DECLARATIONS_IN_GENERATED_FILES</code> preprocessor symbol is defined). The <code>strings</code> should not have trailing linefeeds or else the output will contain extra blank lines. </p>

</div>
</div>
<a id="a730285817dee408e76404ed9e0c5d442"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a730285817dee408e76404ed9e0c5d442">&#9670;&nbsp;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1StringUtility.html#acddf0f6a1575dbd791fb139de7ffa57f">FileWithLineNumbers</a>&amp; Rose::StringUtility::operator+= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceRose_1_1StringUtility.html#acddf0f6a1575dbd791fb139de7ffa57f">FileWithLineNumbers</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1StringUtility.html#acddf0f6a1575dbd791fb139de7ffa57f">FileWithLineNumbers</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append strings with source location information to vector of such. </p>
<p>Modifies <code>a</code> by appending those strings from <code>b</code>. </p>

<p class="definition">Definition at line <a class="el" href="FileUtility_8h_source.html#l00303">303</a> of file <a class="el" href="FileUtility_8h_source.html">FileUtility.h</a>.</p>

</div>
</div>
<a id="aa3c610263bc1edc3378414b63aeb84a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3c610263bc1edc3378414b63aeb84a3">&#9670;&nbsp;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1StringUtility.html#acddf0f6a1575dbd791fb139de7ffa57f">FileWithLineNumbers</a> Rose::StringUtility::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1StringUtility.html#acddf0f6a1575dbd791fb139de7ffa57f">FileWithLineNumbers</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1StringUtility.html#acddf0f6a1575dbd791fb139de7ffa57f">FileWithLineNumbers</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenate vectors of strings with source location. </p>
<p>Returns a new vector of strings with location information by concatenating vector <code>a</code> with <code>b</code>. </p>

<p class="definition">Definition at line <a class="el" href="FileUtility_8h_source.html#l00311">311</a> of file <a class="el" href="FileUtility_8h_source.html">FileUtility.h</a>.</p>

</div>
</div>
<a id="a7b1a57c60d55cf20cc9ecc4a9772f443"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b1a57c60d55cf20cc9ecc4a9772f443">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1StringUtility.html#acddf0f6a1575dbd791fb139de7ffa57f">FileWithLineNumbers</a>&amp; Rose::StringUtility::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceRose_1_1StringUtility.html#acddf0f6a1575dbd791fb139de7ffa57f">FileWithLineNumbers</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append string to vector of strings with location information. </p>
<p>Appends <code>str</code> to the last string in the vector of strings with location information. If the vector is empty then a new element is created.</p>
<p>The new code is marked as either generated (empty file name) or not generated (non-empty name) based on whether the vector was initially empty or whether the final element of the vector was generated. Adding a string to an empty vector makes it always be a generated string; adding it to a non-empty vector makes it generated or not generated depending on whether the last element of the vector is generated or not generated.</p>
<p>The string <code>str</code> should not include line termination. (see <a class="el" href="namespaceRose_1_1StringUtility.html#ab128401cca6edd03b3c366f9fa1f458c">toString</a>). </p>

<p class="definition">Definition at line <a class="el" href="FileUtility_8h_source.html#l00330">330</a> of file <a class="el" href="FileUtility_8h_source.html">FileUtility.h</a>.</p>

</div>
</div>
<a id="a2d1a0081693a164c62d4e4d4ac3559e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d1a0081693a164c62d4e4d4ac3559e5">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1StringUtility.html#acddf0f6a1575dbd791fb139de7ffa57f">FileWithLineNumbers</a>&amp; Rose::StringUtility::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceRose_1_1StringUtility.html#acddf0f6a1575dbd791fb139de7ffa57f">FileWithLineNumbers</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append string to vector of strings with location information. </p>
<p>Appends <code>str</code> to the last string in the vector of strings with location information. If the vector is empty then a new element is created.</p>
<p>The new code is marked as either generated (empty file name) or not generated (non-empty name) based on whether the vector was initially empty or whether the final element of the vector was generated. Adding a string to an empty vector makes it always be a generated string; adding it to a non-empty vector makes it generated or not generated depending on whether the last element of the vector is generated or not generated.</p>
<p>The string <code>str</code> should not include line termination. (see <a class="el" href="namespaceRose_1_1StringUtility.html#ab128401cca6edd03b3c366f9fa1f458c">toString</a>). </p>

<p class="definition">Definition at line <a class="el" href="FileUtility_8h_source.html#l00339">339</a> of file <a class="el" href="FileUtility_8h_source.html">FileUtility.h</a>.</p>

</div>
</div>
<a id="a852b2712142fd0b0faac918ba669dc69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a852b2712142fd0b0faac918ba669dc69">&#9670;&nbsp;</a></span>copyEdit() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_UTIL_API std::string Rose::StringUtility::copyEdit </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>inputString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>oldToken</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>newToken</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace all occurrences of a string with another string. </p>
<p>Finds all occurrences of the <code>oldToken</code> string in <code>inputString</code> and replaces them each with <code>newToken</code>, returning the result. </p>

</div>
</div>
<a id="a619ab96e79288118d60ca2d7c795f080"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a619ab96e79288118d60ca2d7c795f080">&#9670;&nbsp;</a></span>copyEdit() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_UTIL_API <a class="el" href="namespaceRose_1_1StringUtility.html#acddf0f6a1575dbd791fb139de7ffa57f">FileWithLineNumbers</a> Rose::StringUtility::copyEdit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1StringUtility.html#acddf0f6a1575dbd791fb139de7ffa57f">FileWithLineNumbers</a> &amp;&#160;</td>
          <td class="paramname"><em>inputString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>oldToken</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>newToken</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace all occurrences of a string with another string. </p>
<p>Finds all occurrences of the <code>oldToken</code> string in <code>inputString</code> and replaces them each with <code>newToken</code>, returning the result. </p>

</div>
</div>
<a id="a4c963aa45dcf4f1ddf0df7274f6963e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c963aa45dcf4f1ddf0df7274f6963e7">&#9670;&nbsp;</a></span>copyEdit() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_UTIL_API <a class="el" href="namespaceRose_1_1StringUtility.html#acddf0f6a1575dbd791fb139de7ffa57f">FileWithLineNumbers</a> Rose::StringUtility::copyEdit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1StringUtility.html#acddf0f6a1575dbd791fb139de7ffa57f">FileWithLineNumbers</a> &amp;&#160;</td>
          <td class="paramname"><em>inputString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>oldToken</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1StringUtility.html#acddf0f6a1575dbd791fb139de7ffa57f">FileWithLineNumbers</a> &amp;&#160;</td>
          <td class="paramname"><em>newToken</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace all occurrences of a string with another string. </p>
<p>Finds all occurrences of the <code>oldToken</code> string in <code>inputString</code> and replaces them each with <code>newToken</code>, returning the result. </p>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="anamespaceRose_1_1StringUtility_html_a29ff2232fd9a00a0b3dc8a27ad08c1bd"><div class="ttname"><a href="namespaceRose_1_1StringUtility.html#a29ff2232fd9a00a0b3dc8a27ad08c1bd">Rose::StringUtility::appendAsmComment</a></div><div class="ttdeci">ROSE_UTIL_API std::string appendAsmComment(const std::string &amp;s, const std::string &amp;comment)</div><div class="ttdoc">Append an assembly comment to a string.</div></div>
<div class="ttc" id="anamespaceRose_1_1StringUtility_html_abf7821b02ca01054a3b4303aff3086e2"><div class="ttname"><a href="namespaceRose_1_1StringUtility.html#abf7821b02ca01054a3b4303aff3086e2">Rose::StringUtility::plural</a></div><div class="ttdeci">std::string plural(T n, const std::string &amp;plural_phrase, const std::string &amp;singular_phrase=&quot;&quot;)</div><div class="ttdoc">Helpful way to print singular or plural words.</div><div class="ttdef"><b>Definition:</b> <a href="StringUtility_2Diagnostics_8h_source.html#l00067">StringUtility/Diagnostics.h:67</a></div></div>
<div class="ttc" id="anamespaceRose_1_1StringUtility_html_a0893d3ce864ceb579daa758fae1f0cc8"><div class="ttname"><a href="namespaceRose_1_1StringUtility.html#a0893d3ce864ceb579daa758fae1f0cc8">Rose::StringUtility::toStrings</a></div><div class="ttdeci">std::vector&lt; std::string &gt; toStrings(const Container &amp;numbers, const Stringifier &amp;stringifier=numberToString)</div><div class="ttdoc">Converts a bunch of numbers to strings.</div><div class="ttdef"><b>Definition:</b> <a href="StringToNumber_8h_source.html#l00060">StringToNumber.h:60</a></div></div>
<div class="ttc" id="anamespaceRose_1_1StringUtility_html"><div class="ttname"><a href="namespaceRose_1_1StringUtility.html">Rose::StringUtility</a></div><div class="ttdoc">Functions for operating on strings.</div><div class="ttdef"><b>Definition:</b> <a href="StringUtility_8h_source.html#l00018">StringUtility.h:18</a></div></div>
<div class="ttc" id="anamespaceRose_1_1StringUtility_html_ab8dedf8e0b97da2ed5740173b5f85d28"><div class="ttname"><a href="namespaceRose_1_1StringUtility.html#ab8dedf8e0b97da2ed5740173b5f85d28">Rose::StringUtility::join</a></div><div class="ttdeci">std::string join(const std::string &amp;separator, const Container &amp;container)</div><div class="ttdoc">Join individual items to form a single string.</div><div class="ttdef"><b>Definition:</b> <a href="SplitJoin_8h_source.html#l00061">SplitJoin.h:61</a></div></div>
<div class="ttc" id="anamespaceRose_1_1StringUtility_html_a1601608fa2856aa31397370b8b5923c4"><div class="ttname"><a href="namespaceRose_1_1StringUtility.html#a1601608fa2856aa31397370b8b5923c4">Rose::StringUtility::addrToString</a></div><div class="ttdeci">ROSE_UTIL_API std::string addrToString(uint64_t value, size_t nbits=0)</div><div class="ttdoc">Convert a virtual address to a string.</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Dec 8 2022 21:18:48 for ROSE by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
