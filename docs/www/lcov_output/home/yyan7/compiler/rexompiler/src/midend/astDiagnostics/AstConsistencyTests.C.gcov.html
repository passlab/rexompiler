<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - ROSE - /home/yyan7/compiler/rexompiler/src/midend/astDiagnostics/AstConsistencyTests.C</title>
  <link rel="stylesheet" type="text/css" href="../../../../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../../../../index.html">top level</a> - <a href="index.html">home/yyan7/compiler/rexompiler/src/midend/astDiagnostics</a> - AstConsistencyTests.C<span style="font-size: 80%;"> (source / <a href="AstConsistencyTests.C.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">ROSE</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">1319</td>
            <td class="headerCovTableEntry">1991</td>
            <td class="headerCovTableEntryLo">66.2 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2022-12-08 13:48:47</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">54</td>
            <td class="headerCovTableEntry">65</td>
            <td class="headerCovTableEntryMed">83.1 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : // Author: Markus Schordan</a>
<a name="2"><span class="lineNum">       2 </span>            : // $Id: AstConsistencyTests.C,v 1.8 2008/01/25 02:25:46 dquinlan Exp $</a>
<a name="3"><span class="lineNum">       3 </span>            : </a>
<a name="4"><span class="lineNum">       4 </span>            : // tps (01/14/2010) : Switching from rose.h to sage3.</a>
<a name="5"><span class="lineNum">       5 </span>            : #include &quot;sage3basic.h&quot;</a>
<a name="6"><span class="lineNum">       6 </span>            : </a>
<a name="7"><span class="lineNum">       7 </span>            : #include &quot;rose_config.h&quot;</a>
<a name="8"><span class="lineNum">       8 </span>            : </a>
<a name="9"><span class="lineNum">       9 </span>            : // tps : needed to define this here as it is defined in rose.h</a>
<a name="10"><span class="lineNum">      10 </span>            : #include &quot;markCompilerGenerated.h&quot;</a>
<a name="11"><span class="lineNum">      11 </span>            : </a>
<a name="12"><span class="lineNum">      12 </span>            : #include &quot;AstDiagnostics.h&quot;</a>
<a name="13"><span class="lineNum">      13 </span>            : #ifndef ASTTESTS_C</a>
<a name="14"><span class="lineNum">      14 </span>            :    #define ASTTESTS_C</a>
<a name="15"><span class="lineNum">      15 </span>            : // DQ (8/9/2004): Modified to put code below outside of ASTTESTS_C if ... endif</a>
<a name="16"><span class="lineNum">      16 </span>            : #endif</a>
<a name="17"><span class="lineNum">      17 </span>            : </a>
<a name="18"><span class="lineNum">      18 </span>            : // DQ (3/6/2003): added from AstProcessing.h to avoid referencing</a>
<a name="19"><span class="lineNum">      19 </span>            : // the traversal classes in AstFixes.h before they are defined.</a>
<a name="20"><span class="lineNum">      20 </span>            : //#include &quot;sage3.h&quot;</a>
<a name="21"><span class="lineNum">      21 </span>            : #include &quot;roseInternal.h&quot;</a>
<a name="22"><span class="lineNum">      22 </span>            : </a>
<a name="23"><span class="lineNum">      23 </span>            : #include &quot;AstConsistencyTests.h&quot;</a>
<a name="24"><span class="lineNum">      24 </span>            : #include &quot;AstNodePtrs.h&quot;</a>
<a name="25"><span class="lineNum">      25 </span>            : #include &quot;AstTraversal.h&quot;</a>
<a name="26"><span class="lineNum">      26 </span>            : </a>
<a name="27"><span class="lineNum">      27 </span>            : // This controls output for debugging</a>
<a name="28"><span class="lineNum">      28 </span>            : #define WARN_ABOUT_ATYPICAL_LVALUES 0</a>
<a name="29"><span class="lineNum">      29 </span>            : </a>
<a name="30"><span class="lineNum">      30 </span>            : // DQ (10/14/2010):  This should only be included by source files that require it.</a>
<a name="31"><span class="lineNum">      31 </span>            : // This fixed a reported bug which caused conflicts with autoconf macros (e.g. PACKAGE_BUGREPORT).</a>
<a name="32"><span class="lineNum">      32 </span>            : #include &quot;rose_config.h&quot;</a>
<a name="33"><span class="lineNum">      33 </span>            : </a>
<a name="34"><span class="lineNum">      34 </span>            : // DQ (3/19/2012): We need this for a function in calss: TestForParentsMatchingASTStructure</a>
<a name="35"><span class="lineNum">      35 </span>            : #include &quot;stringify.h&quot;</a>
<a name="36"><span class="lineNum">      36 </span>            : </a>
<a name="37"><span class="lineNum">      37 </span>            : // DQ (3/24/2016): Adding message logging.</a>
<a name="38"><span class="lineNum">      38 </span>            : #include &lt;Rose/Diagnostics.h&gt;</a>
<a name="39"><span class="lineNum">      39 </span>            : </a>
<a name="40"><span class="lineNum">      40 </span>            : // DQ (12/31/2005): This is OK if not declared in a header file</a>
<a name="41"><span class="lineNum">      41 </span>            : using namespace std;</a>
<a name="42"><span class="lineNum">      42 </span>            : using namespace Rose;</a>
<a name="43"><span class="lineNum">      43 </span>            : </a>
<a name="44"><span class="lineNum">      44 </span>            : // DQ (3/24/2016): Adding Robb's message logging mechanism to contrl output debug message from the EDG/ROSE connection code.</a>
<a name="45"><span class="lineNum">      45 </span>            : using namespace Rose::Diagnostics;</a>
<a name="46"><span class="lineNum">      46 </span>            : </a>
<a name="47"><span class="lineNum">      47 </span>            : // DQ (3/24/2016): Adding Message logging mechanism.</a>
<a name="48"><span class="lineNum">      48 </span>            : Sawyer::Message::Facility TestChildPointersInMemoryPool::mlog;</a>
<a name="49"><span class="lineNum">      49 </span>            : </a>
<a name="50"><span class="lineNum">      50 </span>            : </a>
<a name="51"><span class="lineNum">      51 </span>            : /*! \file</a>
<a name="52"><span class="lineNum">      52 </span>            : </a>
<a name="53"><span class="lineNum">      53 </span>            :     This file contains the test run on the AST after construction (option).</a>
<a name="54"><span class="lineNum">      54 </span>            : </a>
<a name="55"><span class="lineNum">      55 </span>            : */</a>
<a name="56"><span class="lineNum">      56 </span>            : </a>
<a name="57"><span class="lineNum">      57 </span>            : /*! \page AstProperties AST Properties (Consistency Tests)</a>
<a name="58"><span class="lineNum">      58 </span>            : </a>
<a name="59"><span class="lineNum">      59 </span>            :     This documentation describes the properties of the AST. There are a number of consistency tests</a>
<a name="60"><span class="lineNum">      60 </span>            : of the AST, when all these pass the AST is verified to have specifi properties.  This documentation</a>
<a name="61"><span class="lineNum">      61 </span>            : lays out these properties of the AST (e.g. which pointers are always valid, etc.).</a>
<a name="62"><span class="lineNum">      62 </span>            : </a>
<a name="63"><span class="lineNum">      63 </span>            : */</a>
<a name="64"><span class="lineNum">      64 </span>            : </a>
<a name="65"><span class="lineNum">      65 </span>            : bool</a>
<a name="66"><span class="lineNum">      66 </span><span class="lineCov">   46902300 : AstTests::isPrefix(string prefix, string s)</span></a>
<a name="67"><span class="lineNum">      67 </span>            :    {</a>
<a name="68"><span class="lineNum">      68 </span><span class="lineCov">   46902300 :      return (s.find(prefix, 0) == 0);</span></a>
<a name="69"><span class="lineNum">      69 </span>            :    }</a>
<a name="70"><span class="lineNum">      70 </span>            : </a>
<a name="71"><span class="lineNum">      71 </span>            : unsigned int</a>
<a name="72"><span class="lineNum">      72 </span><span class="lineCov">   23097400 : AstTests::numPrefix(string prefix, vector&lt;string&gt; vs)</span></a>
<a name="73"><span class="lineNum">      73 </span>            :    {</a>
<a name="74"><span class="lineNum">      74 </span><span class="lineCov">   23097400 :      unsigned int num=0;</span></a>
<a name="75"><span class="lineNum">      75 </span><span class="lineCov">   69931600 :      for (vector&lt;string&gt;::iterator it=vs.begin();it!=vs.end();it++)</span></a>
<a name="76"><span class="lineNum">      76 </span>            :         {</a>
<a name="77"><span class="lineNum">      77 </span><span class="lineCov">   93890200 :           if (isPrefix(prefix,*it))</span></a>
<a name="78"><span class="lineNum">      78 </span>            :              {</a>
<a name="79"><span class="lineNum">      79 </span><span class="lineCov">    2181650 :                num++;</span></a>
<a name="80"><span class="lineNum">      80 </span>            :              }</a>
<a name="81"><span class="lineNum">      81 </span>            :         }</a>
<a name="82"><span class="lineNum">      82 </span><span class="lineCov">   23097400 :      return num;</span></a>
<a name="83"><span class="lineNum">      83 </span>            :    }</a>
<a name="84"><span class="lineNum">      84 </span>            : </a>
<a name="85"><span class="lineNum">      85 </span>            : unsigned int</a>
<a name="86"><span class="lineNum">      86 </span><span class="lineCov">   11003700 : AstTests::numSuccContainers(SgNode* node) {</span></a>
<a name="87"><span class="lineNum">      87 </span><span class="lineCov">   11003700 :   vector&lt;string&gt; names=node-&gt;get_traversalSuccessorNamesContainer();</span></a>
<a name="88"><span class="lineNum">      88 </span><span class="lineCov">   11003700 :   return numPrefix(&quot;[0]&quot;,names)+numPrefix(&quot;*[0]&quot;,names);</span></a>
<a name="89"><span class="lineNum">      89 </span>            : }</a>
<a name="90"><span class="lineNum">      90 </span>            : </a>
<a name="91"><span class="lineNum">      91 </span>            : unsigned int</a>
<a name="92"><span class="lineNum">      92 </span><span class="lineCov">    1089880 : AstTests::numSingleSuccs(SgNode* node) {</span></a>
<a name="93"><span class="lineNum">      93 </span><span class="lineCov">    1089880 :   vector&lt;string&gt; names=node-&gt;get_traversalSuccessorNamesContainer();</span></a>
<a name="94"><span class="lineNum">      94 </span><span class="lineCov">    1089880 :   return numPrefix(&quot;p_&quot;,names);</span></a>
<a name="95"><span class="lineNum">      95 </span>            : }</a>
<a name="96"><span class="lineNum">      96 </span>            : </a>
<a name="97"><span class="lineNum">      97 </span>            : bool</a>
<a name="98"><span class="lineNum">      98 </span><span class="lineCov">    5500920 : AstTests::isProblematic(SgNode* node)</span></a>
<a name="99"><span class="lineNum">      99 </span>            :    {</a>
<a name="100"><span class="lineNum">     100 </span>            :   // This function tests whether a node is problematic for the access of attributes</a>
<a name="101"><span class="lineNum">     101 </span>            :   // computed by the processing classes. There are two cases how attributes can be</a>
<a name="102"><span class="lineNum">     102 </span>            :   // accessed</a>
<a name="103"><span class="lineNum">     103 </span>            :   //    1. by using the (generated) enums</a>
<a name="104"><span class="lineNum">     104 </span>            :   //    2. by using an index for an offset in a children container</a>
<a name="105"><span class="lineNum">     105 </span>            :   // A node is problematic if both cases are mixed.  Therefore this test is included</a>
<a name="106"><span class="lineNum">     106 </span>            :   // in the consistancy tests to ensure that no new node that is added to the AST</a>
<a name="107"><span class="lineNum">     107 </span>            :   // violates this property.</a>
<a name="108"><span class="lineNum">     108 </span>            : </a>
<a name="109"><span class="lineNum">     109 </span>            :   // DQ (4/3/2006 (afternoon)): But I had to change it back since the AST it fails to pass this test.</a>
<a name="110"><span class="lineNum">     110 </span>            :   //     We need to work more with Markus to fix this!</a>
<a name="111"><span class="lineNum">     111 </span>            :   // DQ (4/3/2006 (morning)): Markus called and though this should be changed.</a>
<a name="112"><span class="lineNum">     112 </span>            :   // ERROR:  Call from Markus, this needs to be switched. But it will cause something to fail.</a>
<a name="113"><span class="lineNum">     113 </span>            :   // This is what it takes to allow the enums based interface to work within the traversal.</a>
<a name="114"><span class="lineNum">     114 </span>            : #if 1</a>
<a name="115"><span class="lineNum">     115 </span>            :   // DQ (8/10/2004): This is the correct test and no other one is appropriate, I gather!</a>
<a name="116"><span class="lineNum">     116 </span>            :   // DQ (4/4/2006): I believe that this was Markus's original code. And while I tried to make</a>
<a name="117"><span class="lineNum">     117 </span>            :   // it more clear with the alternative code below this didn't work.  So it was put back the</a>
<a name="118"><span class="lineNum">     118 </span>            :   // way I understood Markus had designed it.</a>
<a name="119"><span class="lineNum">     119 </span><span class="lineCov">    5500920 :      return (numSuccContainers(node) &gt; 1) || ( (numSuccContainers(node) &gt; 0) &amp;&amp; (numSingleSuccs(node) &gt; 0) );</span></a>
<a name="120"><span class="lineNum">     120 </span>            : #else</a>
<a name="121"><span class="lineNum">     121 </span>            :   // This case fails, I think because the numberOfDataMembers == 1 (to include the container itself)</a>
<a name="122"><span class="lineNum">     122 </span>            :   // actually 1 does not work, so I'm not sure what is going on here!  I have sent email to Markus.</a>
<a name="123"><span class="lineNum">     123 </span>            :   // int containerSize       = numSuccContainers(node);</a>
<a name="124"><span class="lineNum">     124 </span>            :      int numberOfContainers  = numSuccContainers(node);</a>
<a name="125"><span class="lineNum">     125 </span>            :      int numberOfDataMembers = numSingleSuccs(node);</a>
<a name="126"><span class="lineNum">     126 </span>            :   // return  ( (containerSize &gt;  1) &amp;&amp; (numberOfDataMembers == 0)) || ( (containerSize == 0) &amp;&amp; (numberOfDataMembers &gt; 0) );</a>
<a name="127"><span class="lineNum">     127 </span>            :      return  ( (numberOfContainers &gt;  1) &amp;&amp; (numberOfDataMembers == 0)) || ( (numberOfContainers == 0) &amp;&amp; (numberOfDataMembers &gt; 0) );</a>
<a name="128"><span class="lineNum">     128 </span>            : #endif</a>
<a name="129"><span class="lineNum">     129 </span>            :    }</a>
<a name="130"><span class="lineNum">     130 </span>            : </a>
<a name="131"><span class="lineNum">     131 </span>            : /*</a>
<a name="132"><span class="lineNum">     132 </span>            : void</a>
<a name="133"><span class="lineNum">     133 </span>            : AstTests::dummyTests(SgProject* sageProject) {</a>
<a name="134"><span class="lineNum">     134 </span>            :   DI inh; DS syn;</a>
<a name="135"><span class="lineNum">     135 </span>            :   syn=DummyISTestQuery().traverse(sageProject,inh);</a>
<a name="136"><span class="lineNum">     136 </span>            :   DummyITestQuery().traverse(sageProject,inh);</a>
<a name="137"><span class="lineNum">     137 </span>            :   syn=DummySTestQuery().traverse(sageProject);</a>
<a name="138"><span class="lineNum">     138 </span>            :   DummyTestQuery().traverse(sageProject,postorder);</a>
<a name="139"><span class="lineNum">     139 </span>            : }</a>
<a name="140"><span class="lineNum">     140 </span>            : */</a>
<a name="141"><span class="lineNum">     141 </span>            : </a>
<a name="142"><span class="lineNum">     142 </span>            : // DQ (10/6/2004): This function should be designed to take a SgNode</a>
<a name="143"><span class="lineNum">     143 </span>            : // as input so that any part of the AST could be tested!</a>
<a name="144"><span class="lineNum">     144 </span>            : bool</a>
<a name="145"><span class="lineNum">     145 </span><span class="lineCov">        326 : AstTests::isCorrectAst(SgProject* sageProject)</span></a>
<a name="146"><span class="lineNum">     146 </span>            :    {</a>
<a name="147"><span class="lineNum">     147 </span><span class="lineCov">        652 :      TimingPerformance timer (&quot;AST check for IR nodes without source position information:&quot;);</span></a>
<a name="148"><span class="lineNum">     148 </span>            : </a>
<a name="149"><span class="lineNum">     149 </span><span class="lineCov">        326 :      TestAstProperties t;</span></a>
<a name="150"><span class="lineNum">     150 </span><span class="lineCov">        326 :      bool returnValue = t.traverse(sageProject).val;</span></a>
<a name="151"><span class="lineNum">     151 </span>            : </a>
<a name="152"><span class="lineNum">     152 </span><span class="lineCov">        326 :      if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL )</span></a>
<a name="153"><span class="lineNum">     153 </span>            :         {</a>
<a name="154"><span class="lineNum">     154 </span><span class="lineNoCov">          0 :           printf (&quot;\nAST Diagnostics: Fequency of IR nodes missing ending source postion info: \n&quot;);</span></a>
<a name="155"><span class="lineNum">     155 </span>            : #ifdef __CYGWIN__</a>
<a name="156"><span class="lineNum">     156 </span>            :        // PC (9/18/2006): Diagnostic fails on cygwin</a>
<a name="157"><span class="lineNum">     157 </span>            :           puts(&quot;Diagnostic fails on cygwin&quot;);</a>
<a name="158"><span class="lineNum">     158 </span>            : #else</a>
<a name="159"><span class="lineNum">     159 </span>            :           bool found = false;</a>
<a name="160"><span class="lineNum">     160 </span><span class="lineNoCov">          0 :           for (int i = V_SgModifier; i != V_SgNumVariants; i++)</span></a>
<a name="161"><span class="lineNum">     161 </span>            :              {</a>
<a name="162"><span class="lineNum">     162 </span><span class="lineNoCov">          0 :                if (t.nodeWithoutFileInfoFrequencyCount[i] &gt; 0)</span></a>
<a name="163"><span class="lineNum">     163 </span>            :                   {</a>
<a name="164"><span class="lineNum">     164 </span><span class="lineNoCov">          0 :                     found = true;</span></a>
<a name="165"><span class="lineNum">     165 </span><span class="lineNoCov">          0 :                     printf (&quot;     Frequency at %s = %d \n&quot;,getVariantName(VariantT(i)).c_str(),t.nodeWithoutFileInfoFrequencyCount[i]);</span></a>
<a name="166"><span class="lineNum">     166 </span>            :                   }</a>
<a name="167"><span class="lineNum">     167 </span>            :              }</a>
<a name="168"><span class="lineNum">     168 </span>            : </a>
<a name="169"><span class="lineNum">     169 </span><span class="lineNoCov">          0 :           if (found == false)</span></a>
<a name="170"><span class="lineNum">     170 </span>            :              {</a>
<a name="171"><span class="lineNum">     171 </span><span class="lineNoCov">          0 :                printf (&quot;PASSED: All IR nodes have both starting and ending position information \n&quot;);</span></a>
<a name="172"><span class="lineNum">     172 </span>            :              }</a>
<a name="173"><span class="lineNum">     173 </span>            : #endif</a>
<a name="174"><span class="lineNum">     174 </span>            :         }</a>
<a name="175"><span class="lineNum">     175 </span>            : </a>
<a name="176"><span class="lineNum">     176 </span><span class="lineCov">        652 :      return returnValue;</span></a>
<a name="177"><span class="lineNum">     177 </span>            :    }</a>
<a name="178"><span class="lineNum">     178 </span>            : </a>
<a name="179"><span class="lineNum">     179 </span>            : void</a>
<a name="180"><span class="lineNum">     180 </span><span class="lineCov">        326 : AstTests::runAllTests(SgProject* sageProject)</span></a>
<a name="181"><span class="lineNum">     181 </span>            :    {</a>
<a name="182"><span class="lineNum">     182 </span>            :   // compilation tests of templated processing classes</a>
<a name="183"><span class="lineNum">     183 </span>            :   // DQ (3/30/2004): This function is called by the</a>
<a name="184"><span class="lineNum">     184 </span>            :   //      ROSE/src/roseTranslator.C RoseTestTranslator class</a>
<a name="185"><span class="lineNum">     185 </span>            : </a>
<a name="186"><span class="lineNum">     186 </span><span class="lineCov">        326 :      if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL )</span></a>
<a name="187"><span class="lineNum">     187 </span>            :         {</a>
<a name="188"><span class="lineNum">     188 </span><span class="lineNoCov">          0 :           printf (&quot;At TOP of AstTests::runAllTests() \n&quot;);</span></a>
<a name="189"><span class="lineNum">     189 </span>            :         }</a>
<a name="190"><span class="lineNum">     190 </span>            : </a>
<a name="191"><span class="lineNum">     191 </span>            : #ifdef NDEBUG</a>
<a name="192"><span class="lineNum">     192 </span>            :   // DQ (6/30/20133): If we have compiled with NDEBUG then nothing identified in this function</a>
<a name="193"><span class="lineNum">     193 </span>            :   // will be caught because every place we detect a problem we expect to end with ROSE_ASSERT()</a>
<a name="194"><span class="lineNum">     194 </span>            :   // which is disabled when ROSE is compiled with NDEBUG.  So more approriate (and equvalent)</a>
<a name="195"><span class="lineNum">     195 </span>            :   // semantics is that if ROSE is compiled with NDEBUG then we should just exit directly.</a>
<a name="196"><span class="lineNum">     196 </span>            :      TimingPerformance ndebug_timer (&quot;AST Consistency Tests (disabled by NDEBUG):&quot;);</a>
<a name="197"><span class="lineNum">     197 </span>            :      return;</a>
<a name="198"><span class="lineNum">     198 </span>            : #endif</a>
<a name="199"><span class="lineNum">     199 </span>            : </a>
<a name="200"><span class="lineNum">     200 </span>            :   // It is a proper place to put any tests of the AST that must always pass!</a>
<a name="201"><span class="lineNum">     201 </span>            : </a>
<a name="202"><span class="lineNum">     202 </span>            :   // Possible future tests:</a>
<a name="203"><span class="lineNum">     203 </span>            :   //    1) Test for redundant statements in the same basic block.</a>
<a name="204"><span class="lineNum">     204 </span>            :   //       This is a current bug which the AST tests didn't catch.</a>
<a name="205"><span class="lineNum">     205 </span>            : </a>
<a name="206"><span class="lineNum">     206 </span>            :   // DQ (7/6/2005): Introduce tracking of performance of ROSE.</a>
<a name="207"><span class="lineNum">     207 </span>            :   // ROSE_Performance::TimingPerformance(&quot;AST Consistency Tests&quot;);</a>
<a name="208"><span class="lineNum">     208 </span><span class="lineCov">        326 :      TimingPerformance timer (&quot;AST Consistency Tests:&quot;);</span></a>
<a name="209"><span class="lineNum">     209 </span>            : </a>
<a name="210"><span class="lineNum">     210 </span>            :   // DQ (2/17/2013): Added support to skip AST consistancy tests for performance testing.</a>
<a name="211"><span class="lineNum">     211 </span>            :   // The skipAstConsistancyTests variable is on the SgFile, not the SgProject.</a>
<a name="212"><span class="lineNum">     212 </span><span class="lineCov">        326 :      if (sageProject-&gt;get_fileList().empty() == false &amp;&amp; sageProject-&gt;get_fileList()[0]-&gt;get_skipAstConsistancyTests() == true)</span></a>
<a name="213"><span class="lineNum">     213 </span>            :         {</a>
<a name="214"><span class="lineNum">     214 </span><span class="lineNoCov">          0 :           printf (&quot;Note: In AstTests::runAllTests(): command line option used to skip AST consistancy tests \n&quot;);</span></a>
<a name="215"><span class="lineNum">     215 </span><span class="lineNoCov">          0 :           return;</span></a>
<a name="216"><span class="lineNum">     216 </span>            :         }</a>
<a name="217"><span class="lineNum">     217 </span>            : </a>
<a name="218"><span class="lineNum">     218 </span>            :   // DQ (2/23/2014): Adding support for gathering statistics from boost hash tables.</a>
<a name="219"><span class="lineNum">     219 </span><span class="lineCov">        326 :      if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL )</span></a>
<a name="220"><span class="lineNum">     220 </span>            :   // if ( SgProject::get_verbose() &gt;= 0 )</a>
<a name="221"><span class="lineNum">     221 </span>            :         {</a>
<a name="222"><span class="lineNum">     222 </span><span class="lineNoCov">          0 :           for (size_t i = 0; i &lt; sageProject-&gt;get_fileList().size(); i++)</span></a>
<a name="223"><span class="lineNum">     223 </span>            :              {</a>
<a name="224"><span class="lineNum">     224 </span><span class="lineNoCov">          0 :                SgSourceFile* sourceFile = isSgSourceFile(sageProject-&gt;get_fileList()[i]);</span></a>
<a name="225"><span class="lineNum">     225 </span><span class="lineNoCov">          0 :                if (sourceFile != NULL)</span></a>
<a name="226"><span class="lineNum">     226 </span>            :                   {</a>
<a name="227"><span class="lineNum">     227 </span><span class="lineNoCov">          0 :                     SgGlobal* globalScope = sourceFile-&gt;get_globalScope();</span></a>
<a name="228"><span class="lineNum">     228 </span><span class="lineNoCov">          0 :                     ROSE_ASSERT(globalScope != NULL);</span></a>
<a name="229"><span class="lineNum">     229 </span><span class="lineNoCov">          0 :                     size_t maxCollisions = globalScope-&gt;get_symbol_table()-&gt;maxCollisions();</span></a>
<a name="230"><span class="lineNum">     230 </span><span class="lineNoCov">          0 :                     printf (&quot;Symbol Table Statistics: sourceFile = %&quot; PRIuPTR &quot; maxCollisions = %&quot; PRIuPTR &quot; \n&quot;,i,maxCollisions);</span></a>
<a name="231"><span class="lineNum">     231 </span>            : </a>
<a name="232"><span class="lineNum">     232 </span><span class="lineNoCov">          0 :                     float load_factor     = globalScope-&gt;get_symbol_table()-&gt;get_table()-&gt;load_factor();</span></a>
<a name="233"><span class="lineNum">     233 </span><span class="lineNoCov">          0 :                     printf (&quot;Symbol Table Statistics: sourceFile = %&quot; PRIuPTR &quot; load_factor = %f \n&quot;,i,load_factor);</span></a>
<a name="234"><span class="lineNum">     234 </span>            : </a>
<a name="235"><span class="lineNum">     235 </span><span class="lineNoCov">          0 :                     float max_load_factor = globalScope-&gt;get_symbol_table()-&gt;get_table()-&gt;max_load_factor();</span></a>
<a name="236"><span class="lineNum">     236 </span><span class="lineNoCov">          0 :                     printf (&quot;Symbol Table Statistics: sourceFile = %&quot; PRIuPTR &quot; max_load_factor = %f \n&quot;,i,max_load_factor);</span></a>
<a name="237"><span class="lineNum">     237 </span>            :                   }</a>
<a name="238"><span class="lineNum">     238 </span>            :              }</a>
<a name="239"><span class="lineNum">     239 </span>            :         }</a>
<a name="240"><span class="lineNum">     240 </span>            : </a>
<a name="241"><span class="lineNum">     241 </span>            :   // CH (2010/7/26):</a>
<a name="242"><span class="lineNum">     242 </span>            :   // Before running tests, first clear all variable symbols which are not referenced in the memory pool.</a>
<a name="243"><span class="lineNum">     243 </span>            :   // This is because when building AST bottom-up, some temporary symbol may be generated to be referenced</a>
<a name="244"><span class="lineNum">     244 </span>            :   // by those variable references generated just using names. When all variable references are fixed,</a>
<a name="245"><span class="lineNum">     245 </span>            :   // those symbols are not used any more and then should be removed from memory pool.</a>
<a name="246"><span class="lineNum">     246 </span>            :   //</a>
<a name="247"><span class="lineNum">     247 </span>            :   // Liao 1/24/2013: I have to comment this out</a>
<a name="248"><span class="lineNum">     248 </span>            :   // for #define N 1000, when N is used in OpenMP directives, the OmpSupport::attachOmpAttributeInfo() will try to generate a</a>
<a name="249"><span class="lineNum">     249 </span>            :   // variable reference to N, But N cannot be found in AST, so unknownType is used.  But symbols with unknowntype will be removed</a>
<a name="250"><span class="lineNum">     250 </span>            :   // by this clearUnusedVariableSymbols()</a>
<a name="251"><span class="lineNum">     251 </span>            :      //SageInterface::clearUnusedVariableSymbols();</a>
<a name="252"><span class="lineNum">     252 </span>            : </a>
<a name="253"><span class="lineNum">     253 </span>            :   // printf (&quot;Inside of AstTests::runAllTests(sageProject = %p) \n&quot;,sageProject);</a>
<a name="254"><span class="lineNum">     254 </span>            : </a>
<a name="255"><span class="lineNum">     255 </span>            :   // printf (&quot;Exiting at top of AstTests::runAllTests() \n&quot;);</a>
<a name="256"><span class="lineNum">     256 </span>            :   // ROSE_ASSERT(false);</a>
<a name="257"><span class="lineNum">     257 </span>            : </a>
<a name="258"><span class="lineNum">     258 </span>            : /*! \page AstProperties AST Properties (Consistency Tests)</a>
<a name="259"><span class="lineNum">     259 </span>            : </a>
<a name="260"><span class="lineNum">     260 </span>            : \section section1 Traversal Tests</a>
<a name="261"><span class="lineNum">     261 </span>            : </a>
<a name="262"><span class="lineNum">     262 </span>            :      This test verifies that the different types of traversal work properly on the AST.</a>
<a name="263"><span class="lineNum">     263 </span>            : </a>
<a name="264"><span class="lineNum">     264 </span>            : */</a>
<a name="265"><span class="lineNum">     265 </span>            :   // DQ (3/30/2004): Not clear why we are avoiding having to specify unique variables, Markus?.</a>
<a name="266"><span class="lineNum">     266 </span><span class="lineCov">        326 :         {</span></a>
<a name="267"><span class="lineNum">     267 </span><span class="lineCov">        326 :           DummyISTestQuery1 q1;</span></a>
<a name="268"><span class="lineNum">     268 </span><span class="lineCov">        652 :           DummyITestQuery1  q2;</span></a>
<a name="269"><span class="lineNum">     269 </span><span class="lineCov">        652 :           DummySTestQuery1  q3;</span></a>
<a name="270"><span class="lineNum">     270 </span><span class="lineCov">        326 :           DummyTestQuery1   q4;</span></a>
<a name="271"><span class="lineNum">     271 </span>            :         }</a>
<a name="272"><span class="lineNum">     272 </span><span class="lineCov">        326 :         {</span></a>
<a name="273"><span class="lineNum">     273 </span><span class="lineCov">        326 :           DummyISTestQuery2 q1;</span></a>
<a name="274"><span class="lineNum">     274 </span><span class="lineCov">        652 :           DummyITestQuery2  q2;</span></a>
<a name="275"><span class="lineNum">     275 </span><span class="lineCov">        652 :           DummySTestQuery2  q3;</span></a>
<a name="276"><span class="lineNum">     276 </span><span class="lineCov">        326 :           DummyTestQuery2   q4;</span></a>
<a name="277"><span class="lineNum">     277 </span>            :         }</a>
<a name="278"><span class="lineNum">     278 </span><span class="lineCov">        326 :         {</span></a>
<a name="279"><span class="lineNum">     279 </span><span class="lineCov">        326 :           DummyISTestQuery3 q1;</span></a>
<a name="280"><span class="lineNum">     280 </span><span class="lineCov">        652 :           DummyITestQuery3  q2;</span></a>
<a name="281"><span class="lineNum">     281 </span><span class="lineCov">        652 :           DummySTestQuery3  q3;</span></a>
<a name="282"><span class="lineNum">     282 </span><span class="lineCov">        326 :           DummyTestQuery3   q4;</span></a>
<a name="283"><span class="lineNum">     283 </span>            :         }</a>
<a name="284"><span class="lineNum">     284 </span>            : </a>
<a name="285"><span class="lineNum">     285 </span>            :   // test statistics</a>
<a name="286"><span class="lineNum">     286 </span>            :   // AstNodeStatistics stat;</a>
<a name="287"><span class="lineNum">     287 </span>            :   // cout &lt;&lt; stat.toString(sageProject);</a>
<a name="288"><span class="lineNum">     288 </span>            :   // statistics data will be used for testing constraints on the AST</a>
<a name="289"><span class="lineNum">     289 </span>            : </a>
<a name="290"><span class="lineNum">     290 </span>            :   // test properties of AST</a>
<a name="291"><span class="lineNum">     291 </span>            :   // if (sageProject-&gt;get_useBackendOnly() == false)</a>
<a name="292"><span class="lineNum">     292 </span><span class="lineCov">        326 :      if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL )</span></a>
<a name="293"><span class="lineNum">     293 </span><span class="lineNoCov">          0 :           cout &lt;&lt; &quot;\nAST initial correctness test ... &quot; &lt;&lt; flush;</span></a>
<a name="294"><span class="lineNum">     294 </span><span class="lineCov">        326 :      if (isCorrectAst(sageProject))</span></a>
<a name="295"><span class="lineNum">     295 </span>            :         {</a>
<a name="296"><span class="lineNum">     296 </span>            :        // if (sageProject-&gt;get_useBackendOnly() == false)</a>
<a name="297"><span class="lineNum">     297 </span><span class="lineCov">        326 :           if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL )</span></a>
<a name="298"><span class="lineNum">     298 </span><span class="lineNoCov">          0 :                cout &lt;&lt; &quot;succeeded.&quot; &lt;&lt; endl;</span></a>
<a name="299"><span class="lineNum">     299 </span>            :         }</a>
<a name="300"><span class="lineNum">     300 </span>            :        else</a>
<a name="301"><span class="lineNum">     301 </span>            :         {</a>
<a name="302"><span class="lineNum">     302 </span>            :        // if (sageProject-&gt;get_useBackendOnly() == false)</a>
<a name="303"><span class="lineNum">     303 </span><span class="lineNoCov">          0 :           if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL )</span></a>
<a name="304"><span class="lineNum">     304 </span><span class="lineNoCov">          0 :                cout &lt;&lt; &quot;failed.&quot; &lt;&lt; endl;</span></a>
<a name="305"><span class="lineNum">     305 </span>            :             else</a>
<a name="306"><span class="lineNum">     306 </span><span class="lineNoCov">          0 :                cout &lt;&lt; &quot;AST Consistancy Tests have failed.&quot; &lt;&lt; endl;</span></a>
<a name="307"><span class="lineNum">     307 </span><span class="lineNoCov">          0 :           ROSE_ABORT();</span></a>
<a name="308"><span class="lineNum">     308 </span>            :         }</a>
<a name="309"><span class="lineNum">     309 </span>            : </a>
<a name="310"><span class="lineNum">     310 </span>            :   // Output an extra CR</a>
<a name="311"><span class="lineNum">     311 </span><span class="lineCov">        326 :      if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL )</span></a>
<a name="312"><span class="lineNum">     312 </span><span class="lineNoCov">          0 :           cout &lt;&lt; endl;</span></a>
<a name="313"><span class="lineNum">     313 </span>            : </a>
<a name="314"><span class="lineNum">     314 </span>            :   // DQ (3/30/2004): Added tests for templates (make sure that numerous fields are properly defined)</a>
<a name="315"><span class="lineNum">     315 </span>            :   // if (sageProject-&gt;get_useBackendOnly() == false)</a>
<a name="316"><span class="lineNum">     316 </span><span class="lineCov">        326 :      if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL )</span></a>
<a name="317"><span class="lineNum">     317 </span><span class="lineNoCov">          0 :         cout &lt;&lt; &quot;Redundent Statement Test started (tests only single scopes for redundent statements).&quot; &lt;&lt; endl;</span></a>
<a name="318"><span class="lineNum">     318 </span><span class="lineCov">        326 :         {</span></a>
<a name="319"><span class="lineNum">     319 </span><span class="lineCov">        326 :           TimingPerformance timer (&quot;AST check for unique IR nodes in each scope (excludes IR nodes marked explicitly as shared by AST merge):&quot;);</span></a>
<a name="320"><span class="lineNum">     320 </span>            : </a>
<a name="321"><span class="lineNum">     321 </span><span class="lineCov">        652 :           TestAstForUniqueStatementsInScopes redundentStatementTest;</span></a>
<a name="322"><span class="lineNum">     322 </span><span class="lineCov">        326 :           redundentStatementTest.traverse(sageProject,preorder);</span></a>
<a name="323"><span class="lineNum">     323 </span>            :         }</a>
<a name="324"><span class="lineNum">     324 </span>            :   // if (sageProject-&gt;get_useBackendOnly() == false)</a>
<a name="325"><span class="lineNum">     325 </span><span class="lineCov">        326 :      if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL )</span></a>
<a name="326"><span class="lineNum">     326 </span><span class="lineNoCov">          0 :           cout &lt;&lt; &quot;Redundent Statement Test finished.&quot; &lt;&lt; endl;</span></a>
<a name="327"><span class="lineNum">     327 </span>            : </a>
<a name="328"><span class="lineNum">     328 </span>            :   // DQ (9/24/2013): Fortran support has excessive output spew specific to this test.  We will fix this in</a>
<a name="329"><span class="lineNum">     329 </span>            :   // the new fortran work, but we can't have this much output spew presently.</a>
<a name="330"><span class="lineNum">     330 </span>            :   // DQ (9/21/2013): Force this to be skipped where ROSE's AST merge feature is active (since the point of</a>
<a name="331"><span class="lineNum">     331 </span>            :   // merge is to share IR nodes, it is pointless to detect sharing and generate output for each identified case).</a>
<a name="332"><span class="lineNum">     332 </span>            :   // if (sageProject-&gt;get_astMerge() == false)</a>
<a name="333"><span class="lineNum">     333 </span><span class="lineCov">        326 :      if (sageProject-&gt;get_ast_merge() == false &amp;&amp; sageProject-&gt;get_Fortran_only() == false)</span></a>
<a name="334"><span class="lineNum">     334 </span>            :         {</a>
<a name="335"><span class="lineNum">     335 </span>            :        // DQ (4/2/2012): Added test for unique IR nodes in the AST.</a>
<a name="336"><span class="lineNum">     336 </span><span class="lineCov">        290 :           if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL )</span></a>
<a name="337"><span class="lineNum">     337 </span><span class="lineNoCov">          0 :                cout &lt;&lt; &quot;Unique IR nodes in AST Test started (tests IR nodes uniqueness over whole of AST).&quot; &lt;&lt; endl;</span></a>
<a name="338"><span class="lineNum">     338 </span>            : </a>
<a name="339"><span class="lineNum">     339 </span><span class="lineCov">        290 :              {</span></a>
<a name="340"><span class="lineNum">     340 </span><span class="lineCov">        580 :                TimingPerformance timer (&quot;AST check for unique IR nodes in whole of AST (must excludes IR nodes marked explicitly as shared by AST merge):&quot;);</span></a>
<a name="341"><span class="lineNum">     341 </span>            : </a>
<a name="342"><span class="lineNum">     342 </span><span class="lineCov">        580 :                TestAstForUniqueNodesInAST redundentNodeTest;</span></a>
<a name="343"><span class="lineNum">     343 </span><span class="lineCov">        290 :                redundentNodeTest.traverse(sageProject,preorder);</span></a>
<a name="344"><span class="lineNum">     344 </span>            :              }</a>
<a name="345"><span class="lineNum">     345 </span>            : </a>
<a name="346"><span class="lineNum">     346 </span><span class="lineCov">        290 :           if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL )</span></a>
<a name="347"><span class="lineNum">     347 </span><span class="lineNoCov">          0 :                cout &lt;&lt; &quot;Unique IR nodes in AST Test finished.&quot; &lt;&lt; endl;</span></a>
<a name="348"><span class="lineNum">     348 </span>            :         }</a>
<a name="349"><span class="lineNum">     349 </span>            : </a>
<a name="350"><span class="lineNum">     350 </span>            : #if 0</a>
<a name="351"><span class="lineNum">     351 </span>            :   // DQ (10/11/2006): Debugging name qualification, so skip these tests which call the unparser!</a>
<a name="352"><span class="lineNum">     352 </span>            :      printf (&quot;WARNING: In AstConsistencyTests.C, while debugging code generation, mangled name testing (which includes tests of unparseToString() mechanism) is skipped \n&quot;);</a>
<a name="353"><span class="lineNum">     353 </span>            : #else</a>
<a name="354"><span class="lineNum">     354 </span>            :   // DQ (4/27/2005): Test of mangled names</a>
<a name="355"><span class="lineNum">     355 </span><span class="lineCov">        326 :      if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL )</span></a>
<a name="356"><span class="lineNum">     356 </span><span class="lineNoCov">          0 :           cout &lt;&lt; &quot;Mangled Name Test on AST started (tests properties of mangled names).&quot; &lt;&lt; endl;</span></a>
<a name="357"><span class="lineNum">     357 </span><span class="lineCov">        326 :         {</span></a>
<a name="358"><span class="lineNum">     358 </span><span class="lineCov">        326 :           TimingPerformance timer (&quot;AST mangle name test:&quot;);</span></a>
<a name="359"><span class="lineNum">     359 </span>            : </a>
<a name="360"><span class="lineNum">     360 </span><span class="lineCov">        652 :           TestAstForProperlyMangledNames mangledNameTest;</span></a>
<a name="361"><span class="lineNum">     361 </span><span class="lineCov">        326 :           mangledNameTest.traverse(sageProject,preorder);</span></a>
<a name="362"><span class="lineNum">     362 </span>            : </a>
<a name="363"><span class="lineNum">     363 </span><span class="lineCov">        326 :           if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL )</span></a>
<a name="364"><span class="lineNum">     364 </span>            :              {</a>
<a name="365"><span class="lineNum">     365 </span><span class="lineNoCov">          0 :                cout &lt;&lt; &quot;Mangled Name Test finished: (number of mangled name size = &quot; &lt;&lt; mangledNameTest.saved_numberOfMangledNames &lt;&lt; &quot;) &quot; &lt;&lt; endl;</span></a>
<a name="366"><span class="lineNum">     366 </span><span class="lineNoCov">          0 :                cout &lt;&lt; &quot;Mangled Name Test finished: (max mangled name size       = &quot; &lt;&lt; mangledNameTest.saved_maxMangledNameSize   &lt;&lt; &quot;) &quot; &lt;&lt; endl;</span></a>
<a name="367"><span class="lineNum">     367 </span><span class="lineCov">        326 :                cout &lt;&lt; &quot;Mangled Name Test finished: (total mangled name size     = &quot; &lt;&lt; mangledNameTest.saved_totalMangledNameSize &lt;&lt; &quot;) &quot; &lt;&lt; endl;</span></a>
<a name="368"><span class="lineNum">     368 </span>            :              }</a>
<a name="369"><span class="lineNum">     369 </span>            :         }</a>
<a name="370"><span class="lineNum">     370 </span>            : #endif</a>
<a name="371"><span class="lineNum">     371 </span>            : </a>
<a name="372"><span class="lineNum">     372 </span>            :   // DQ (4/27/2005): Test of compiler generated nodes</a>
<a name="373"><span class="lineNum">     373 </span><span class="lineCov">        326 :      if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL )</span></a>
<a name="374"><span class="lineNum">     374 </span><span class="lineNoCov">          0 :           cout &lt;&lt; &quot;Compiler Generated Node Test started.&quot; &lt;&lt; endl;</span></a>
<a name="375"><span class="lineNum">     375 </span><span class="lineCov">        326 :         {</span></a>
<a name="376"><span class="lineNum">     376 </span><span class="lineCov">        326 :           TimingPerformance timer (&quot;AST compiler generated node test:&quot;);</span></a>
<a name="377"><span class="lineNum">     377 </span>            : </a>
<a name="378"><span class="lineNum">     378 </span><span class="lineCov">        652 :           TestAstCompilerGeneratedNodes compilerGeneratedNodeTest;</span></a>
<a name="379"><span class="lineNum">     379 </span><span class="lineCov">        326 :           compilerGeneratedNodeTest.traverse(sageProject,preorder);</span></a>
<a name="380"><span class="lineNum">     380 </span>            :         }</a>
<a name="381"><span class="lineNum">     381 </span><span class="lineCov">        326 :      if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL )</span></a>
<a name="382"><span class="lineNum">     382 </span><span class="lineNoCov">          0 :           cout &lt;&lt; &quot;Compiler Generated Node Test finished.&quot; &lt;&lt; endl;</span></a>
<a name="383"><span class="lineNum">     383 </span>            : </a>
<a name="384"><span class="lineNum">     384 </span>            : #if 1</a>
<a name="385"><span class="lineNum">     385 </span>            :   // DQ (10/22/2007): The unparse to string functionality is now tested separately.</a>
<a name="386"><span class="lineNum">     386 </span>            :   // DQ (10/11/2006): Debugging name qualification, so skip these tests which call the unparser!</a>
<a name="387"><span class="lineNum">     387 </span>            :   // printf (&quot;WARNING: In AstConsistencyTests.C, while debugging code generation, attribute testing (which includes tests of unparseToString() mechanism) is skipped \n&quot;);</a>
<a name="388"><span class="lineNum">     388 </span>            : #else</a>
<a name="389"><span class="lineNum">     389 </span>            :   // test pdf and printing of attributes in pdf files</a>
<a name="390"><span class="lineNum">     390 </span>            :      if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL )</a>
<a name="391"><span class="lineNum">     391 </span>            :           cout &lt;&lt; &quot;Test attribute handling (includes tests of unparseToString() mechanism): started &quot; &lt;&lt; endl;</a>
<a name="392"><span class="lineNum">     392 </span>            :         {</a>
<a name="393"><span class="lineNum">     393 </span>            :           TimingPerformance timer (&quot;AST attribute handling test (includes tests of unparseToString() mechanism):&quot;);</a>
<a name="394"><span class="lineNum">     394 </span>            : </a>
<a name="395"><span class="lineNum">     395 </span>            :           AstTextAttributesHandling textAttributes(sageProject);</a>
<a name="396"><span class="lineNum">     396 </span>            :           textAttributes.setAll();</a>
<a name="397"><span class="lineNum">     397 </span>            :           AstPDFGeneration pdftest;</a>
<a name="398"><span class="lineNum">     398 </span>            :        // pdftest.generateInputFiles(sageProject); MS: deactivated 12/02/03</a>
<a name="399"><span class="lineNum">     399 </span>            :           textAttributes.removeAll();</a>
<a name="400"><span class="lineNum">     400 </span>            :         }</a>
<a name="401"><span class="lineNum">     401 </span>            :      if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL )</a>
<a name="402"><span class="lineNum">     402 </span>            :           cout &lt;&lt; &quot;Test attribute handling: finished &quot; &lt;&lt; endl;</a>
<a name="403"><span class="lineNum">     403 </span>            : #endif</a>
<a name="404"><span class="lineNum">     404 </span>            :   /*</a>
<a name="405"><span class="lineNum">     405 </span>            :      cout &lt;&lt; &quot;Testing for Nodes with NULL pointers started.&quot; &lt;&lt; endl;</a>
<a name="406"><span class="lineNum">     406 </span>            :      AstNodePtrs np;</a>
<a name="407"><span class="lineNum">     407 </span>            :      np.traverseInputFiles(sageProject);</a>
<a name="408"><span class="lineNum">     408 </span>            :      cout &lt;&lt; &quot;Testing for Nodes with NULL pointers finished.&quot; &lt;&lt; endl;</a>
<a name="409"><span class="lineNum">     409 </span>            : </a>
<a name="410"><span class="lineNum">     410 </span>            :      cout &lt;&lt; &quot;Full Testing for Revisit Testing started&quot; &lt;&lt; endl;</a>
<a name="411"><span class="lineNum">     411 </span>            :      TestAstNullPointers tp;</a>
<a name="412"><span class="lineNum">     412 </span>            :      tp.traverse(sageProject);</a>
<a name="413"><span class="lineNum">     413 </span>            :      cout &lt;&lt; &quot;Full Testing for Revisit Testing finished.&quot; &lt;&lt; endl;</a>
<a name="414"><span class="lineNum">     414 </span>            :   */</a>
<a name="415"><span class="lineNum">     415 </span>            : </a>
<a name="416"><span class="lineNum">     416 </span>            : #if 0</a>
<a name="417"><span class="lineNum">     417 </span>            :   // DQ (2/6/2004):</a>
<a name="418"><span class="lineNum">     418 </span>            :   // This test has been turned off since it broke once new nodes were added to the AST</a>
<a name="419"><span class="lineNum">     419 </span>            :   // and I don't really understnad how it works.  This is certainly something that we</a>
<a name="420"><span class="lineNum">     420 </span>            :   // need to BE Markus inorder to fix :-).</a>
<a name="421"><span class="lineNum">     421 </span>            :   // if (sageProject-&gt;get_useBackendOnly() == false)</a>
<a name="422"><span class="lineNum">     422 </span>            :      if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL )</a>
<a name="423"><span class="lineNum">     423 </span>            :           cout &lt;&lt; &quot;Testing default abstract C++ grammar started.&quot; &lt;&lt; endl;</a>
<a name="424"><span class="lineNum">     424 </span>            :      AgProcessing&lt;sgnodeParser&gt; ap;</a>
<a name="425"><span class="lineNum">     425 </span>            :      ap.evaluate(sageProject);</a>
<a name="426"><span class="lineNum">     426 </span>            :   // if (sageProject-&gt;get_useBackendOnly() == false)</a>
<a name="427"><span class="lineNum">     427 </span>            :      if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL )</a>
<a name="428"><span class="lineNum">     428 </span>            :           cout &lt;&lt; &quot;Testing default abstract C++ grammar finished.&quot; &lt;&lt; endl;</a>
<a name="429"><span class="lineNum">     429 </span>            : #endif</a>
<a name="430"><span class="lineNum">     430 </span>            : </a>
<a name="431"><span class="lineNum">     431 </span>            :   // DQ (4/2/2012): debugging why we have a cycle in the AST (test2012_59.C).</a>
<a name="432"><span class="lineNum">     432 </span>            :   // if (sageProject-&gt;get_useBackendOnly() == false)</a>
<a name="433"><span class="lineNum">     433 </span>            :   // if ( SgProject::get_verbose() &gt;= 0 ) // DIAGNOSTICS_VERBOSE_LEVEL )</a>
<a name="434"><span class="lineNum">     434 </span><span class="lineCov">        326 :      if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL )</span></a>
<a name="435"><span class="lineNum">     435 </span><span class="lineNoCov">          0 :           cout &lt;&lt; &quot;Cycle test started.&quot; &lt;&lt; endl;</span></a>
<a name="436"><span class="lineNum">     436 </span>            : </a>
<a name="437"><span class="lineNum">     437 </span><span class="lineCov">        326 :         {</span></a>
<a name="438"><span class="lineNum">     438 </span><span class="lineCov">        326 :           TimingPerformance timer (&quot;AST cycle test:&quot;);</span></a>
<a name="439"><span class="lineNum">     439 </span>            : </a>
<a name="440"><span class="lineNum">     440 </span><span class="lineCov">        652 :           AstCycleTest cycTest;</span></a>
<a name="441"><span class="lineNum">     441 </span><span class="lineCov">        326 :           cycTest.traverse(sageProject);</span></a>
<a name="442"><span class="lineNum">     442 </span>            :         }</a>
<a name="443"><span class="lineNum">     443 </span>            : </a>
<a name="444"><span class="lineNum">     444 </span>            :   // if (sageProject-&gt;get_useBackendOnly() == false)</a>
<a name="445"><span class="lineNum">     445 </span><span class="lineCov">        326 :      if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL )</span></a>
<a name="446"><span class="lineNum">     446 </span><span class="lineNoCov">          0 :         cout &lt;&lt; &quot;Cycle test finished. No cycle found.&quot; &lt;&lt; endl;</span></a>
<a name="447"><span class="lineNum">     447 </span>            : </a>
<a name="448"><span class="lineNum">     448 </span>            :   // DQ (3/30/2004): Added tests for templates (make sure that numerous fields are properly defined)</a>
<a name="449"><span class="lineNum">     449 </span>            :   // if (sageProject-&gt;get_useBackendOnly() == false)</a>
<a name="450"><span class="lineNum">     450 </span><span class="lineCov">        326 :      if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL )</span></a>
<a name="451"><span class="lineNum">     451 </span><span class="lineNoCov">          0 :           cout &lt;&lt; &quot;Template Test started.&quot; &lt;&lt; endl;</span></a>
<a name="452"><span class="lineNum">     452 </span><span class="lineCov">        326 :         {</span></a>
<a name="453"><span class="lineNum">     453 </span><span class="lineCov">        326 :           TimingPerformance timer (&quot;AST template properties test:&quot;);</span></a>
<a name="454"><span class="lineNum">     454 </span>            : </a>
<a name="455"><span class="lineNum">     455 </span><span class="lineCov">        652 :           TestAstTemplateProperties templateTest;</span></a>
<a name="456"><span class="lineNum">     456 </span><span class="lineCov">        326 :           templateTest.traverse(sageProject,preorder);</span></a>
<a name="457"><span class="lineNum">     457 </span>            :         }</a>
<a name="458"><span class="lineNum">     458 </span>            :   // if (sageProject-&gt;get_useBackendOnly() == false)</a>
<a name="459"><span class="lineNum">     459 </span><span class="lineCov">        326 :      if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL )</span></a>
<a name="460"><span class="lineNum">     460 </span><span class="lineNoCov">          0 :           cout &lt;&lt; &quot;Template Test finished.&quot; &lt;&lt; endl;</span></a>
<a name="461"><span class="lineNum">     461 </span>            : </a>
<a name="462"><span class="lineNum">     462 </span>            :   // DQ (6/24/2005): Test setup of defining and non-defining declaration pointers for each SgDeclarationStatement</a>
<a name="463"><span class="lineNum">     463 </span><span class="lineCov">        326 :      if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL )</span></a>
<a name="464"><span class="lineNum">     464 </span><span class="lineNoCov">          0 :           cout &lt;&lt; &quot;Defining and Non-Defining Declaration  Test started.&quot; &lt;&lt; endl;</span></a>
<a name="465"><span class="lineNum">     465 </span><span class="lineCov">        326 :         {</span></a>
<a name="466"><span class="lineNum">     466 </span><span class="lineCov">        326 :           TimingPerformance timer (&quot;AST defining and non-defining declaration test:&quot;);</span></a>
<a name="467"><span class="lineNum">     467 </span>            : </a>
<a name="468"><span class="lineNum">     468 </span><span class="lineCov">        652 :           TestAstForProperlySetDefiningAndNondefiningDeclarations declarationTest;</span></a>
<a name="469"><span class="lineNum">     469 </span><span class="lineCov">        326 :           declarationTest.traverse(sageProject,preorder);</span></a>
<a name="470"><span class="lineNum">     470 </span>            :         }</a>
<a name="471"><span class="lineNum">     471 </span><span class="lineCov">        326 :      if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL )</span></a>
<a name="472"><span class="lineNum">     472 </span><span class="lineNoCov">          0 :           cout &lt;&lt; &quot;Defining and Non-Defining Declaration Test finished.&quot; &lt;&lt; endl;</span></a>
<a name="473"><span class="lineNum">     473 </span>            : </a>
<a name="474"><span class="lineNum">     474 </span>            :   // DQ (6/24/2005): Test setup of defining and non-defining declaration pointers for each SgDeclarationStatement</a>
<a name="475"><span class="lineNum">     475 </span><span class="lineCov">        326 :      if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL )</span></a>
<a name="476"><span class="lineNum">     476 </span><span class="lineNoCov">          0 :           cout &lt;&lt; &quot;Symbol Table Test started.&quot; &lt;&lt; endl;</span></a>
<a name="477"><span class="lineNum">     477 </span><span class="lineCov">        326 :         {</span></a>
<a name="478"><span class="lineNum">     478 </span><span class="lineCov">        326 :           TimingPerformance timer (&quot;AST symbol table test:&quot;);</span></a>
<a name="479"><span class="lineNum">     479 </span>            : </a>
<a name="480"><span class="lineNum">     480 </span><span class="lineCov">        652 :           TestAstSymbolTables symbolTableTest;</span></a>
<a name="481"><span class="lineNum">     481 </span><span class="lineCov">        326 :           symbolTableTest.traverse(sageProject,preorder);</span></a>
<a name="482"><span class="lineNum">     482 </span>            :         }</a>
<a name="483"><span class="lineNum">     483 </span><span class="lineCov">        326 :      if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL )</span></a>
<a name="484"><span class="lineNum">     484 </span><span class="lineNoCov">          0 :           cout &lt;&lt; &quot;Symbol Table Test finished.&quot; &lt;&lt; endl;</span></a>
<a name="485"><span class="lineNum">     485 </span>            : </a>
<a name="486"><span class="lineNum">     486 </span>            :   // DQ (6/24/2005): Test setup of defining and non-defining declaration pointers for each SgDeclarationStatement</a>
<a name="487"><span class="lineNum">     487 </span><span class="lineCov">        326 :      if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL )</span></a>
<a name="488"><span class="lineNum">     488 </span><span class="lineNoCov">          0 :           cout &lt;&lt; &quot;Test return value of get_declaration() member functions started.&quot; &lt;&lt; endl;</span></a>
<a name="489"><span class="lineNum">     489 </span><span class="lineCov">        326 :         {</span></a>
<a name="490"><span class="lineNum">     490 </span><span class="lineCov">        326 :           TimingPerformance timer (&quot;AST test member function access functions:&quot;);</span></a>
<a name="491"><span class="lineNum">     491 </span>            : </a>
<a name="492"><span class="lineNum">     492 </span><span class="lineCov">        652 :           TestAstAccessToDeclarations getDeclarationMemberFunctionTest;</span></a>
<a name="493"><span class="lineNum">     493 </span><span class="lineCov">        326 :           getDeclarationMemberFunctionTest.traverse(sageProject,preorder);</span></a>
<a name="494"><span class="lineNum">     494 </span>            :         }</a>
<a name="495"><span class="lineNum">     495 </span><span class="lineCov">        326 :      if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL )</span></a>
<a name="496"><span class="lineNum">     496 </span><span class="lineNoCov">          0 :           cout &lt;&lt; &quot;Test return value of get_declaration() member functions finished.&quot; &lt;&lt; endl;</span></a>
<a name="497"><span class="lineNum">     497 </span>            : </a>
<a name="498"><span class="lineNum">     498 </span>            :   // DQ (2/21/2006): Test the type of all expressions and where ever a get_type function is implemented.</a>
<a name="499"><span class="lineNum">     499 </span><span class="lineCov">        326 :      if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL )</span></a>
<a name="500"><span class="lineNum">     500 </span><span class="lineNoCov">          0 :           cout &lt;&lt; &quot;Test return value of get_type() member functions started.&quot; &lt;&lt; endl;</span></a>
<a name="501"><span class="lineNum">     501 </span><span class="lineCov">        326 :         {</span></a>
<a name="502"><span class="lineNum">     502 </span><span class="lineCov">        326 :           TimingPerformance timer (&quot;AST expression type test:&quot;);</span></a>
<a name="503"><span class="lineNum">     503 </span><span class="lineCov">        652 :           TestExpressionTypes expressionTypeTest;</span></a>
<a name="504"><span class="lineNum">     504 </span><span class="lineCov">        326 :           expressionTypeTest.traverse(sageProject, preorder);</span></a>
<a name="505"><span class="lineNum">     505 </span>            :         }</a>
<a name="506"><span class="lineNum">     506 </span><span class="lineCov">        326 :      if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL )</span></a>
<a name="507"><span class="lineNum">     507 </span><span class="lineNoCov">          0 :           cout &lt;&lt; &quot;Test return value of get_type() member functions finished.&quot; &lt;&lt; endl;</span></a>
<a name="508"><span class="lineNum">     508 </span>            : </a>
<a name="509"><span class="lineNum">     509 </span>            :   // DQ (5/22/2006): Test the generation of mangled names.</a>
<a name="510"><span class="lineNum">     510 </span><span class="lineCov">        326 :      if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL )</span></a>
<a name="511"><span class="lineNum">     511 </span><span class="lineNoCov">          0 :           cout &lt;&lt; &quot;Test generation of mangled names started.&quot; &lt;&lt; endl;</span></a>
<a name="512"><span class="lineNum">     512 </span><span class="lineCov">        326 :         {</span></a>
<a name="513"><span class="lineNum">     513 </span><span class="lineCov">        652 :           TimingPerformance timer (&quot;AST mangled names test (exhaustive test using memory pool):&quot;);</span></a>
<a name="514"><span class="lineNum">     514 </span>            : </a>
<a name="515"><span class="lineNum">     515 </span><span class="lineCov">        326 :           TestMangledNames::test();</span></a>
<a name="516"><span class="lineNum">     516 </span>            :         }</a>
<a name="517"><span class="lineNum">     517 </span><span class="lineCov">        326 :      if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL )</span></a>
<a name="518"><span class="lineNum">     518 </span><span class="lineNoCov">          0 :           cout &lt;&lt; &quot;Test generation of mangled names finished.&quot; &lt;&lt; endl;</span></a>
<a name="519"><span class="lineNum">     519 </span>            : </a>
<a name="520"><span class="lineNum">     520 </span>            :   // DQ (6/26/2006): Test the parent pointers of IR nodes in memory pool.</a>
<a name="521"><span class="lineNum">     521 </span><span class="lineCov">        326 :      if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL )</span></a>
<a name="522"><span class="lineNum">     522 </span><span class="lineNoCov">          0 :           cout &lt;&lt; &quot;Test parent pointers of IR nodes in memory pool started.&quot; &lt;&lt; endl;</span></a>
<a name="523"><span class="lineNum">     523 </span><span class="lineCov">        326 :         {</span></a>
<a name="524"><span class="lineNum">     524 </span><span class="lineCov">        652 :           TimingPerformance timer (&quot;AST IR node parent pointers test:&quot;);</span></a>
<a name="525"><span class="lineNum">     525 </span>            : </a>
<a name="526"><span class="lineNum">     526 </span><span class="lineCov">        326 :           TestParentPointersInMemoryPool::test();</span></a>
<a name="527"><span class="lineNum">     527 </span>            :         }</a>
<a name="528"><span class="lineNum">     528 </span><span class="lineCov">        326 :      if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL )</span></a>
<a name="529"><span class="lineNum">     529 </span><span class="lineNoCov">          0 :           cout &lt;&lt; &quot;Test parent pointers of IR nodes in memory pool finished.&quot; &lt;&lt; endl;</span></a>
<a name="530"><span class="lineNum">     530 </span>            : </a>
<a name="531"><span class="lineNum">     531 </span>            :   // DQ (6/26/2006): Test the parent pointers of IR nodes in memory pool.</a>
<a name="532"><span class="lineNum">     532 </span><span class="lineCov">        326 :      if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL )</span></a>
<a name="533"><span class="lineNum">     533 </span><span class="lineNoCov">          0 :           cout &lt;&lt; &quot;Test parents child pointers of IR nodes in memory pool started.&quot; &lt;&lt; endl;</span></a>
<a name="534"><span class="lineNum">     534 </span><span class="lineCov">        326 :         {</span></a>
<a name="535"><span class="lineNum">     535 </span><span class="lineCov">        652 :           TimingPerformance timer (&quot;AST IR node child pointers test:&quot;);</span></a>
<a name="536"><span class="lineNum">     536 </span>            : </a>
<a name="537"><span class="lineNum">     537 </span><span class="lineCov">        326 :           TestChildPointersInMemoryPool::test();</span></a>
<a name="538"><span class="lineNum">     538 </span>            :         }</a>
<a name="539"><span class="lineNum">     539 </span><span class="lineCov">        326 :      if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL )</span></a>
<a name="540"><span class="lineNum">     540 </span><span class="lineNoCov">          0 :           cout &lt;&lt; &quot;Test parents child pointers of IR nodes in memory pool finished.&quot; &lt;&lt; endl;</span></a>
<a name="541"><span class="lineNum">     541 </span>            : </a>
<a name="542"><span class="lineNum">     542 </span>            : #if 0</a>
<a name="543"><span class="lineNum">     543 </span>            :   // DQ (3/7/2007): At some point I think I decided that this was not a valid test!</a>
<a name="544"><span class="lineNum">     544 </span>            :   // DQ (10/18/2006): Test the firstNondefiningDeclaration to make sure it is not used as a forward declaration (memory pool test).</a>
<a name="545"><span class="lineNum">     545 </span>            :      if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL )</a>
<a name="546"><span class="lineNum">     546 </span>            :           cout &lt;&lt; &quot;Test firstNondefiningDeclaration to make sure it is not used as a forward declaration started.&quot; &lt;&lt; endl;</a>
<a name="547"><span class="lineNum">     547 </span>            :      TestFirstNondefiningDeclarationsForForwardMarking::test();</a>
<a name="548"><span class="lineNum">     548 </span>            :      if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL )</a>
<a name="549"><span class="lineNum">     549 </span>            :           cout &lt;&lt; &quot;Test firstNondefiningDeclaration to make sure it is not used as a forward declaration finished.&quot; &lt;&lt; endl;</a>
<a name="550"><span class="lineNum">     550 </span>            : #endif</a>
<a name="551"><span class="lineNum">     551 </span>            : </a>
<a name="552"><span class="lineNum">     552 </span>            :   // DQ (6/26/2006): Test the parent pointers of IR nodes in memory pool.</a>
<a name="553"><span class="lineNum">     553 </span><span class="lineCov">        326 :      if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL )</span></a>
<a name="554"><span class="lineNum">     554 </span><span class="lineNoCov">          0 :           cout &lt;&lt; &quot;Test declarations for mapping to declaration associated with symbol(uses memory pool) started.&quot; &lt;&lt; endl;</span></a>
<a name="555"><span class="lineNum">     555 </span><span class="lineCov">        326 :         {</span></a>
<a name="556"><span class="lineNum">     556 </span><span class="lineCov">        652 :           TimingPerformance timer (&quot;Test for mapping to declaration associated with symbol test:&quot;);</span></a>
<a name="557"><span class="lineNum">     557 </span>            : </a>
<a name="558"><span class="lineNum">     558 </span><span class="lineCov">        326 :           TestMappingOfDeclarationsInMemoryPoolToSymbols::test();</span></a>
<a name="559"><span class="lineNum">     559 </span>            : </a>
<a name="560"><span class="lineNum">     560 </span>            :        // printf (&quot;Exiting after call to TestMappingOfDeclarationsInMemoryPoolToSymbols::test() \n&quot;);</a>
<a name="561"><span class="lineNum">     561 </span>            :        // ROSE_ASSERT(false);</a>
<a name="562"><span class="lineNum">     562 </span>            :         }</a>
<a name="563"><span class="lineNum">     563 </span>            : </a>
<a name="564"><span class="lineNum">     564 </span><span class="lineCov">        326 :      if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL )</span></a>
<a name="565"><span class="lineNum">     565 </span><span class="lineNoCov">          0 :           cout &lt;&lt; &quot;Test declarations for mapping to declaration associated with symbol(uses memory pool) finished.&quot; &lt;&lt; endl;</span></a>
<a name="566"><span class="lineNum">     566 </span>            : </a>
<a name="567"><span class="lineNum">     567 </span>            : </a>
<a name="568"><span class="lineNum">     568 </span>            :   // DQ (6/26/2006): Test expressions for l-value flags</a>
<a name="569"><span class="lineNum">     569 </span><span class="lineCov">        326 :      if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL )</span></a>
<a name="570"><span class="lineNum">     570 </span><span class="lineNoCov">          0 :           cout &lt;&lt; &quot;Test expressions for properly set l-values started.&quot; &lt;&lt; endl;</span></a>
<a name="571"><span class="lineNum">     571 </span><span class="lineCov">        326 :         {</span></a>
<a name="572"><span class="lineNum">     572 </span><span class="lineCov">        326 :           TimingPerformance timer (&quot;Test expressions for properly set l-values:&quot;);</span></a>
<a name="573"><span class="lineNum">     573 </span>            : </a>
<a name="574"><span class="lineNum">     574 </span><span class="lineCov">        652 :           TestLValueExpressions lvalueTest;</span></a>
<a name="575"><span class="lineNum">     575 </span><span class="lineCov">        326 :           lvalueTest.traverse(sageProject,preorder);</span></a>
<a name="576"><span class="lineNum">     576 </span>            : </a>
<a name="577"><span class="lineNum">     577 </span>            :                         // King84 (7/29/2010): Uncomment this to enable checking of the corrected LValues</a>
<a name="578"><span class="lineNum">     578 </span>            : #if 0</a>
<a name="579"><span class="lineNum">     579 </span>            :                         TestLValues lvaluesTest;</a>
<a name="580"><span class="lineNum">     580 </span>            :                         lvaluesTest.traverse(sageProject,preorder);</a>
<a name="581"><span class="lineNum">     581 </span>            : #endif</a>
<a name="582"><span class="lineNum">     582 </span>            :         }</a>
<a name="583"><span class="lineNum">     583 </span><span class="lineCov">        326 :      if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL )</span></a>
<a name="584"><span class="lineNum">     584 </span><span class="lineNoCov">          0 :           cout &lt;&lt; &quot;Test expressions for properly set l-values finished.&quot; &lt;&lt; endl;</span></a>
<a name="585"><span class="lineNum">     585 </span>            : </a>
<a name="586"><span class="lineNum">     586 </span>            :   // DQ (2/23/2009): Test the declarations to make sure that defining and non-defining appear in the same file (for outlining consistency).</a>
<a name="587"><span class="lineNum">     587 </span><span class="lineCov">        326 :      TestMultiFileConsistancy::test();</span></a>
<a name="588"><span class="lineNum">     588 </span>            : </a>
<a name="589"><span class="lineNum">     589 </span>            :   // DQ (11/28/2010): Test to make sure that Fortran is using case insensitive symbol tables and that C/C++ is using case sensitive symbol tables.</a>
<a name="590"><span class="lineNum">     590 </span><span class="lineCov">        326 :      TestForProperLanguageAndSymbolTableCaseSensitivity::test(sageProject);</span></a>
<a name="591"><span class="lineNum">     591 </span>            : </a>
<a name="592"><span class="lineNum">     592 </span><span class="lineCov">        326 :         {</span></a>
<a name="593"><span class="lineNum">     593 </span><span class="lineCov">        652 :           TimingPerformance timer (&quot;AST check for references to deleted IR nodes:&quot;);</span></a>
<a name="594"><span class="lineNum">     594 </span>            : </a>
<a name="595"><span class="lineNum">     595 </span>            :        // DQ (9/26/2011): Test for references to deleted IR nodes in the AST.</a>
<a name="596"><span class="lineNum">     596 </span><span class="lineCov">        326 :           TestForReferencesToDeletedNodes::test(sageProject);</span></a>
<a name="597"><span class="lineNum">     597 </span>            :         }</a>
<a name="598"><span class="lineNum">     598 </span>            : </a>
<a name="599"><span class="lineNum">     599 </span><span class="lineCov">        326 :      if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL )</span></a>
<a name="600"><span class="lineNum">     600 </span><span class="lineNoCov">          0 :           cout &lt;&lt; &quot;Test typedef types for cycles.&quot; &lt;&lt; endl;</span></a>
<a name="601"><span class="lineNum">     601 </span>            : </a>
<a name="602"><span class="lineNum">     602 </span><span class="lineCov">        326 :         {</span></a>
<a name="603"><span class="lineNum">     603 </span><span class="lineCov">        652 :           TimingPerformance timer (&quot;AST check for typedef type cycles:&quot;);</span></a>
<a name="604"><span class="lineNum">     604 </span>            : </a>
<a name="605"><span class="lineNum">     605 </span>            :        // DQ (9/26/2011): Test for references to deleted IR nodes in the AST.</a>
<a name="606"><span class="lineNum">     606 </span><span class="lineCov">        326 :           TestAstForCyclesInTypedefs::test();</span></a>
<a name="607"><span class="lineNum">     607 </span>            :         }</a>
<a name="608"><span class="lineNum">     608 </span>            : </a>
<a name="609"><span class="lineNum">     609 </span>            : </a>
<a name="610"><span class="lineNum">     610 </span>            : </a>
<a name="611"><span class="lineNum">     611 </span>            : </a>
<a name="612"><span class="lineNum">     612 </span>            : </a>
<a name="613"><span class="lineNum">     613 </span>            : #if 1</a>
<a name="614"><span class="lineNum">     614 </span>            :   // Comment out to see if we can checkin what we have fixed recently!</a>
<a name="615"><span class="lineNum">     615 </span>            : </a>
<a name="616"><span class="lineNum">     616 </span>            :   // DQ (7/20/2004): temporary call to help debug traversal on all regression tests</a>
<a name="617"><span class="lineNum">     617 </span>            :   // This query returns a list of types used in the AST</a>
<a name="618"><span class="lineNum">     618 </span><span class="lineCov">        652 :      Rose_STL_Container&lt;SgNode*&gt; typeList;</span></a>
<a name="619"><span class="lineNum">     619 </span><span class="lineCov">        326 :      if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL )</span></a>
<a name="620"><span class="lineNum">     620 </span><span class="lineNoCov">          0 :           printf (&quot;Calling NodeQuery::generateListOfTypes(SgProject) ... \n&quot;);</span></a>
<a name="621"><span class="lineNum">     621 </span><span class="lineCov">        326 :         {</span></a>
<a name="622"><span class="lineNum">     622 </span><span class="lineCov">        326 :           TimingPerformance timer (&quot;AST generate type list test:&quot;);</span></a>
<a name="623"><span class="lineNum">     623 </span>            : </a>
<a name="624"><span class="lineNum">     624 </span>            :        // This uses the query mechanism which uses the memory pools and as a result is much faster and more complete than before.</a>
<a name="625"><span class="lineNum">     625 </span><span class="lineCov">        326 :           typeList = NodeQuery::generateListOfTypes(sageProject);</span></a>
<a name="626"><span class="lineNum">     626 </span>            :         }</a>
<a name="627"><span class="lineNum">     627 </span><span class="lineCov">        326 :      if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL )</span></a>
<a name="628"><span class="lineNum">     628 </span><span class="lineNoCov">          0 :           printf (&quot;AST Type Test: typeList.size() = %ld \n&quot;,(long)typeList.size());</span></a>
<a name="629"><span class="lineNum">     629 </span>            : </a>
<a name="630"><span class="lineNum">     630 </span><span class="lineCov">        326 :      if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL )</span></a>
<a name="631"><span class="lineNum">     631 </span><span class="lineNoCov">          0 :           printf (&quot;Type Test Started \n&quot;);</span></a>
<a name="632"><span class="lineNum">     632 </span>            : </a>
<a name="633"><span class="lineNum">     633 </span>            : </a>
<a name="634"><span class="lineNum">     634 </span><span class="lineCov">        326 :         {</span></a>
<a name="635"><span class="lineNum">     635 </span>            :        // DQ (3/7/2007): This is the start of the timer scope</a>
<a name="636"><span class="lineNum">     636 </span><span class="lineCov">        652 :           TimingPerformance timer (&quot;AST type test:&quot;);</span></a>
<a name="637"><span class="lineNum">     637 </span>            : </a>
<a name="638"><span class="lineNum">     638 </span>            :   // DQ (10/6/2004): Add testing of the types found from the NodeQuery::generateListOfTypes() function.</a>
<a name="639"><span class="lineNum">     639 </span>            :   // Until we can traverse the types this is the only way to test these IR nodes.</a>
<a name="640"><span class="lineNum">     640 </span><span class="lineCov">        326 :      Rose_STL_Container&lt;SgNode*&gt;::iterator i = typeList.begin();</span></a>
<a name="641"><span class="lineNum">     641 </span><span class="lineCov">     385422 :      while (i != typeList.end())</span></a>
<a name="642"><span class="lineNum">     642 </span>            :         {</a>
<a name="643"><span class="lineNum">     643 </span>            :        // DQ (8/6/2005): Call this function to test any relevant types (SgNamedType and its derived types)</a>
<a name="644"><span class="lineNum">     644 </span><span class="lineCov">     385096 :           TestAstAccessToDeclarations::test(*i);</span></a>
<a name="645"><span class="lineNum">     645 </span>            : </a>
<a name="646"><span class="lineNum">     646 </span>            :        // test all the types (since they are not traversed yet)</a>
<a name="647"><span class="lineNum">     647 </span><span class="lineCov">     385096 :           switch ( (*i)-&gt;variantT() )</span></a>
<a name="648"><span class="lineNum">     648 </span>            :              {</a>
<a name="649"><span class="lineNum">     649 </span><span class="lineCov">      15118 :                case V_SgClassType:</span></a>
<a name="650"><span class="lineNum">     650 </span>            :             // case V_SgEnumType:</a>
<a name="651"><span class="lineNum">     651 </span>            :             // case V_SgTypedefType:</a>
<a name="652"><span class="lineNum">     652 </span>            :             // case V_SgNamedType:</a>
<a name="653"><span class="lineNum">     653 </span><span class="lineCov">      15118 :                   {</span></a>
<a name="654"><span class="lineNum">     654 </span><span class="lineCov">      15118 :                     SgNamedType* namedType = isSgNamedType(*i);</span></a>
<a name="655"><span class="lineNum">     655 </span><span class="lineCov">      15118 :                     ROSE_ASSERT(namedType != NULL);</span></a>
<a name="656"><span class="lineNum">     656 </span><span class="lineCov">      15118 :                     SgDeclarationStatement* declarationStatement = namedType-&gt;get_declaration();</span></a>
<a name="657"><span class="lineNum">     657 </span><span class="lineCov">      15118 :                     ROSE_ASSERT(declarationStatement != NULL);</span></a>
<a name="658"><span class="lineNum">     658 </span><span class="lineCov">      15118 :                     if (declarationStatement-&gt;get_parent() == NULL)</span></a>
<a name="659"><span class="lineNum">     659 </span>            :                        {</a>
<a name="660"><span class="lineNum">     660 </span><span class="lineCov">          4 :                          if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL )</span></a>
<a name="661"><span class="lineNum">     661 </span>            :                             {</a>
<a name="662"><span class="lineNum">     662 </span><span class="lineNoCov">          0 :                               printf (&quot;     Warning: Found a NULL declarationStatement-&gt;get_parent() value within SgClassType ... \n&quot;);</span></a>
<a name="663"><span class="lineNum">     663 </span>            : #if 0</a>
<a name="664"><span class="lineNum">     664 </span>            :                               declarationStatement-&gt;get_file_info()-&gt;display(&quot;Location of problem declaration in source code&quot;);</a>
<a name="665"><span class="lineNum">     665 </span>            : #endif</a>
<a name="666"><span class="lineNum">     666 </span>            :                             }</a>
<a name="667"><span class="lineNum">     667 </span>            :                        }</a>
<a name="668"><span class="lineNum">     668 </span>            : </a>
<a name="669"><span class="lineNum">     669 </span>            :                  // DQ (10/17/2004): Acturally the defining declaration need not exist (for code to</a>
<a name="670"><span class="lineNum">     670 </span>            :                  // compile and not link). So it is OK to have a NULL value for the definingDeclaration.</a>
<a name="671"><span class="lineNum">     671 </span>            :                  // ROSE_ASSERT(declarationStatement-&gt;get_parent() != NULL);</a>
<a name="672"><span class="lineNum">     672 </span>            :                  // if (declarationStatement-&gt;get_firstNondefiningDeclaration() == NULL ||</a>
<a name="673"><span class="lineNum">     673 </span>            :                  //     declarationStatement-&gt;get_definingDeclaration() == NULL)</a>
<a name="674"><span class="lineNum">     674 </span><span class="lineCov">      15118 :                     if (declarationStatement-&gt;get_firstNondefiningDeclaration() == NULL)</span></a>
<a name="675"><span class="lineNum">     675 </span>            :                        {</a>
<a name="676"><span class="lineNum">     676 </span><span class="lineNoCov">          0 :                          if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL )</span></a>
<a name="677"><span class="lineNum">     677 </span>            :                             {</a>
<a name="678"><span class="lineNum">     678 </span><span class="lineNoCov">          0 :                               printf (&quot;     Warning: At %p = %s found unset definingDeclaration = %p or firstNondefiningDeclaration = %p \n&quot;,</span></a>
<a name="679"><span class="lineNum">     679 </span><span class="lineNoCov">          0 :                                       namedType,namedType-&gt;sage_class_name(), declarationStatement-&gt;get_definingDeclaration(),</span></a>
<a name="680"><span class="lineNum">     680 </span>            :                                       declarationStatement-&gt;get_firstNondefiningDeclaration());</a>
<a name="681"><span class="lineNum">     681 </span>            : #if 0</a>
<a name="682"><span class="lineNum">     682 </span>            :                               printf (&quot;namedType = %p = %s \n&quot;,namedType,namedType-&gt;sage_class_name());</a>
<a name="683"><span class="lineNum">     683 </span>            :                               declarationStatement-&gt;get_file_info()-&gt;</a>
<a name="684"><span class="lineNum">     684 </span>            :                                    display(&quot;Problematic Class Declaration Location in Source Code&quot;);</a>
<a name="685"><span class="lineNum">     685 </span>            : #endif</a>
<a name="686"><span class="lineNum">     686 </span>            :                             }</a>
<a name="687"><span class="lineNum">     687 </span>            :                        }</a>
<a name="688"><span class="lineNum">     688 </span>            : </a>
<a name="689"><span class="lineNum">     689 </span><span class="lineCov">      15118 :                     if (declarationStatement-&gt;get_firstNondefiningDeclaration() == NULL)</span></a>
<a name="690"><span class="lineNum">     690 </span>            :                        {</a>
<a name="691"><span class="lineNum">     691 </span><span class="lineNoCov">          0 :                          printf (&quot;Error: declarationStatement = %p \n&quot;,declarationStatement);</span></a>
<a name="692"><span class="lineNum">     692 </span><span class="lineNoCov">          0 :                          declarationStatement-&gt;get_file_info()-&gt;display(&quot;Error: declarationStatement-&gt;get_firstNondefiningDeclaration() == NULL&quot;);</span></a>
<a name="693"><span class="lineNum">     693 </span>            :                        }</a>
<a name="694"><span class="lineNum">     694 </span><span class="lineCov">      15118 :                     ROSE_ASSERT(declarationStatement-&gt;get_firstNondefiningDeclaration() != NULL);</span></a>
<a name="695"><span class="lineNum">     695 </span>            :                  // ROSE_ASSERT(declarationStatement-&gt;get_definingDeclaration() != NULL);</a>
<a name="696"><span class="lineNum">     696 </span>            : </a>
<a name="697"><span class="lineNum">     697 </span>            :                  // Liao 10/30/2009, We enforce a unique SgClassType node for SgClassDeclaration and its derived classes</a>
<a name="698"><span class="lineNum">     698 </span>            :                  // SgClassType should be associated with the first nondefining class declaration</a>
<a name="699"><span class="lineNum">     699 </span>            :                  // All other relevant declarations (defining and other nondefining declarations) should share this type node</a>
<a name="700"><span class="lineNum">     700 </span><span class="lineCov">      15118 :                     SgClassType* cls_type = isSgClassType (*i);</span></a>
<a name="701"><span class="lineNum">     701 </span><span class="lineCov">      15118 :                     if (cls_type != NULL)</span></a>
<a name="702"><span class="lineNum">     702 </span>            :                        {</a>
<a name="703"><span class="lineNum">     703 </span>            :                       // DQ (12/4/2011): Better to treat this as a test on the SgDeclarationStatement instead of on the SgClassDeclaration.</a>
<a name="704"><span class="lineNum">     704 </span>            :                       // SgClassDeclaration * cls_decl = isSgClassDeclaration (cls_type-&gt;get_declaration());</a>
<a name="705"><span class="lineNum">     705 </span><span class="lineCov">      15118 :                          ROSE_ASSERT (cls_type-&gt;get_declaration() != NULL);</span></a>
<a name="706"><span class="lineNum">     706 </span><span class="lineCov">      15118 :                          SgDeclarationStatement* cls_decl = isSgDeclarationStatement(cls_type-&gt;get_declaration());</span></a>
<a name="707"><span class="lineNum">     707 </span><span class="lineCov">      15118 :                          ROSE_ASSERT (cls_decl != NULL);</span></a>
<a name="708"><span class="lineNum">     708 </span><span class="lineCov">      15118 :                          if (cls_decl != NULL)</span></a>
<a name="709"><span class="lineNum">     709 </span>            :                             {</a>
<a name="710"><span class="lineNum">     710 </span><span class="lineCov">      15118 :                               if (cls_decl-&gt;get_firstNondefiningDeclaration() != NULL)</span></a>
<a name="711"><span class="lineNum">     711 </span>            :                                  {</a>
<a name="712"><span class="lineNum">     712 </span>            :                                 // if (isSgClassDeclaration(cls_decl-&gt;get_firstNondefiningDeclaration()) != cls_decl )</a>
<a name="713"><span class="lineNum">     713 </span><span class="lineCov">      15118 :                                    if (cls_decl-&gt;get_firstNondefiningDeclaration() != cls_decl )</span></a>
<a name="714"><span class="lineNum">     714 </span>            :                                       {</a>
<a name="715"><span class="lineNum">     715 </span><span class="lineNoCov">          0 :                                         printf (&quot;   Warning: cls_decl = %p = %s \n&quot;,cls_decl,cls_decl-&gt;class_name().c_str());</span></a>
<a name="716"><span class="lineNum">     716 </span><span class="lineNoCov">          0 :                                         printf (&quot;   Warning: cls_decl-&gt;get_firstNondefiningDeclaration() = %p = %s \n&quot;,cls_decl-&gt;get_firstNondefiningDeclaration(),cls_decl-&gt;get_firstNondefiningDeclaration()-&gt;class_name().c_str());</span></a>
<a name="717"><span class="lineNum">     717 </span>            : </a>
<a name="718"><span class="lineNum">     718 </span><span class="lineNoCov">          0 :                                         SgClassDeclaration* local_cls_decl = isSgClassDeclaration (cls_decl);</span></a>
<a name="719"><span class="lineNum">     719 </span><span class="lineNoCov">          0 :                                         SgClassDeclaration* local_cls_decl_firstNondefining = isSgClassDeclaration (cls_decl-&gt;get_firstNondefiningDeclaration());</span></a>
<a name="720"><span class="lineNum">     720 </span><span class="lineNoCov">          0 :                                         SgClassDeclaration* local_cls_decl_defining = isSgClassDeclaration (cls_decl-&gt;get_definingDeclaration());</span></a>
<a name="721"><span class="lineNum">     721 </span>            : </a>
<a name="722"><span class="lineNum">     722 </span><span class="lineNoCov">          0 :                                         printf (&quot;local_cls_decl-&gt;get_name()                  = %s \n&quot;,local_cls_decl-&gt;get_name().str());</span></a>
<a name="723"><span class="lineNum">     723 </span><span class="lineNoCov">          0 :                                         printf (&quot;local_cls_decl_firstNondefining-&gt;get_name() = %s \n&quot;,local_cls_decl_firstNondefining-&gt;get_name().str());</span></a>
<a name="724"><span class="lineNum">     724 </span>            : </a>
<a name="725"><span class="lineNum">     725 </span><span class="lineNoCov">          0 :                                         local_cls_decl-&gt;get_startOfConstruct()-&gt;display(&quot;Error in AST Consistancy tests: cls_decl-&gt;get_firstNondefiningDeclaration() != cls_decl&quot;);</span></a>
<a name="726"><span class="lineNum">     726 </span><span class="lineNoCov">          0 :                                         local_cls_decl_firstNondefining-&gt;get_startOfConstruct()-&gt;display(&quot;Error in AST Consistancy tests: cls_decl-&gt;get_firstNondefiningDeclaration() != cls_decl&quot;);</span></a>
<a name="727"><span class="lineNum">     727 </span>            : </a>
<a name="728"><span class="lineNum">     728 </span><span class="lineNoCov">          0 :                                         if (local_cls_decl_defining != NULL)</span></a>
<a name="729"><span class="lineNum">     729 </span>            :                                            {</a>
<a name="730"><span class="lineNum">     730 </span><span class="lineNoCov">          0 :                                              printf (&quot;local_cls_decl_defining-&gt;get_name()         = %s \n&quot;,local_cls_decl_defining-&gt;get_name().str());</span></a>
<a name="731"><span class="lineNum">     731 </span><span class="lineNoCov">          0 :                                              local_cls_decl_defining-&gt;get_startOfConstruct()-&gt;display(&quot;Error in AST Consistancy tests: cls_decl-&gt;get_definingDeclaration() != cls_decl&quot;);</span></a>
<a name="732"><span class="lineNum">     732 </span>            :                                            }</a>
<a name="733"><span class="lineNum">     733 </span>            : </a>
<a name="734"><span class="lineNum">     734 </span><span class="lineNoCov">          0 :                                         printf(&quot;    Warning: found a SgClassType which is NOT associated with the first nondefining class declaration\n&quot;);</span></a>
<a name="735"><span class="lineNum">     735 </span><span class="lineNoCov">          0 :                                         printf(&quot;    Warning: SgClassType = %p name = %s associated with SgClassDeclaration =%p\n&quot;, cls_type, cls_type-&gt;get_name().getString().c_str(), cls_decl);</span></a>
<a name="736"><span class="lineNum">     736 </span><span class="lineNoCov">          0 :                                         ROSE_ABORT ();</span></a>
<a name="737"><span class="lineNum">     737 </span>            :                                        }</a>
<a name="738"><span class="lineNum">     738 </span>            :                                  }</a>
<a name="739"><span class="lineNum">     739 </span>            :                             }</a>
<a name="740"><span class="lineNum">     740 </span>            :                        }</a>
<a name="741"><span class="lineNum">     741 </span>            : </a>
<a name="742"><span class="lineNum">     742 </span>            :                  // DQ (10/20/2004): Added test to find locations where the mangled template</a>
<a name="743"><span class="lineNum">     743 </span>            :                  // class names might be used in unparsing!</a>
<a name="744"><span class="lineNum">     744 </span><span class="lineCov">      15118 :                     SgTemplateInstantiationDecl* templateInstantiationDeclaration =</span></a>
<a name="745"><span class="lineNum">     745 </span><span class="lineCov">      15118 :                          isSgTemplateInstantiationDecl(declarationStatement);</span></a>
<a name="746"><span class="lineNum">     746 </span><span class="lineCov">      15118 :                     if (templateInstantiationDeclaration != NULL)</span></a>
<a name="747"><span class="lineNum">     747 </span>            :                        {</a>
<a name="748"><span class="lineNum">     748 </span>            :                       // if (templateInstantiationDeclaration-&gt;get_nameResetFromMangledForm() != false)</a>
<a name="749"><span class="lineNum">     749 </span><span class="lineCov">       4297 :                          if (templateInstantiationDeclaration-&gt;get_nameResetFromMangledForm() == false)</span></a>
<a name="750"><span class="lineNum">     750 </span>            :                             {</a>
<a name="751"><span class="lineNum">     751 </span>            :                            // ROSE_ASSERT(templateInstantiationDeclaration-&gt;get_nameResetFromMangledForm() == true);</a>
<a name="752"><span class="lineNum">     752 </span><span class="lineNoCov">          0 :                               if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL+1 )</span></a>
<a name="753"><span class="lineNum">     753 </span>            :                                  {</a>
<a name="754"><span class="lineNum">     754 </span><span class="lineNoCov">          0 :                                    printf (&quot;     Warning : At %p = %s found unset templateName (hidden in type) \n&quot;,</span></a>
<a name="755"><span class="lineNum">     755 </span>            :                                         templateInstantiationDeclaration,</a>
<a name="756"><span class="lineNum">     756 </span><span class="lineNoCov">          0 :                                         templateInstantiationDeclaration-&gt;get_name().str());</span></a>
<a name="757"><span class="lineNum">     757 </span>            :                                  }</a>
<a name="758"><span class="lineNum">     758 </span>            :                                 else</a>
<a name="759"><span class="lineNum">     759 </span>            :                                  {</a>
<a name="760"><span class="lineNum">     760 </span>            :                                 // Provide a less verbose level of output, templated types can be very long!</a>
<a name="761"><span class="lineNum">     761 </span><span class="lineNoCov">          0 :                                    if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL )</span></a>
<a name="762"><span class="lineNum">     762 </span>            :                                       {</a>
<a name="763"><span class="lineNum">     763 </span>            :                                      // printf (&quot;     Warning : At %p found unset templateName \n&quot;,templateInstantiationDeclaration);</a>
<a name="764"><span class="lineNum">     764 </span><span class="lineNoCov">          0 :                                         printf (&quot;     Warning (verbose=%d): At %p = %s found unset templateName (hidden in type) \n&quot;,</span></a>
<a name="765"><span class="lineNum">     765 </span>            :                                              SgProject::get_verbose(),templateInstantiationDeclaration,</a>
<a name="766"><span class="lineNum">     766 </span><span class="lineNoCov">          0 :                                              templateInstantiationDeclaration-&gt;get_name().str());</span></a>
<a name="767"><span class="lineNum">     767 </span>            :                                       }</a>
<a name="768"><span class="lineNum">     768 </span>            :                                  }</a>
<a name="769"><span class="lineNum">     769 </span>            : #if 0</a>
<a name="770"><span class="lineNum">     770 </span>            :                               printf (&quot;templateInstantiationDeclaration = %p = %s (hidden in type) \n&quot;,</a>
<a name="771"><span class="lineNum">     771 </span>            :                                    templateInstantiationDeclaration,templateInstantiationDeclaration-&gt;get_name().str());</a>
<a name="772"><span class="lineNum">     772 </span>            :                               templateInstantiationDeclaration-&gt;get_file_info()-&gt;</a>
<a name="773"><span class="lineNum">     773 </span>            :                                    display(&quot;Problematic templateInstantiationDeclaration in Source Code&quot;);</a>
<a name="774"><span class="lineNum">     774 </span>            : #endif</a>
<a name="775"><span class="lineNum">     775 </span>            :                             }</a>
<a name="776"><span class="lineNum">     776 </span>            : </a>
<a name="777"><span class="lineNum">     777 </span>            :                       // DQ (6/30/2005): Comment this out, but leave the warning, while we return to test KULL.</a>
<a name="778"><span class="lineNum">     778 </span>            :                       // DQ (6/20/2005): Reassert this test!</a>
<a name="779"><span class="lineNum">     779 </span>            :                       // ROSE_ASSERT(templateInstantiationDeclaration-&gt;get_nameResetFromMangledForm() == true);</a>
<a name="780"><span class="lineNum">     780 </span>            : </a>
<a name="781"><span class="lineNum">     781 </span>            : #if STRICT_ERROR_CHECKING</a>
<a name="782"><span class="lineNum">     782 </span>            :                       // DQ (10/21/2004): Relax checking to handle SWIG generated file from Kull (1st SWIG files)</a>
<a name="783"><span class="lineNum">     783 </span>            :                          ROSE_ASSERT(templateInstantiationDeclaration-&gt;get_nameResetFromMangledForm() == true);</a>
<a name="784"><span class="lineNum">     784 </span>            : #endif</a>
<a name="785"><span class="lineNum">     785 </span>            :                        }</a>
<a name="786"><span class="lineNum">     786 </span>            :                     break;</a>
<a name="787"><span class="lineNum">     787 </span>            :                   }</a>
<a name="788"><span class="lineNum">     788 </span>            : </a>
<a name="789"><span class="lineNum">     789 </span>            :                default:</a>
<a name="790"><span class="lineNum">     790 </span>            :                   {</a>
<a name="791"><span class="lineNum">     791 </span>            :                  // Ignore other sorts of types for now!</a>
<a name="792"><span class="lineNum">     792 </span>            :                     break;</a>
<a name="793"><span class="lineNum">     793 </span>            :                   }</a>
<a name="794"><span class="lineNum">     794 </span>            :              }</a>
<a name="795"><span class="lineNum">     795 </span><span class="lineCov">     385096 :           i++;</span></a>
<a name="796"><span class="lineNum">     796 </span>            :         }</a>
<a name="797"><span class="lineNum">     797 </span>            : </a>
<a name="798"><span class="lineNum">     798 </span>            : </a>
<a name="799"><span class="lineNum">     799 </span>            :        // DQ (3/7/2010): Identify the fragments of the AST that are disconnected.</a>
<a name="800"><span class="lineNum">     800 </span>            :        // TestForDisconnectedAST::test(sageProject);</a>
<a name="801"><span class="lineNum">     801 </span>            : </a>
<a name="802"><span class="lineNum">     802 </span>            :        // DQ (3/7/2007): This is the end of the timer scope</a>
<a name="803"><span class="lineNum">     803 </span>            :         }</a>
<a name="804"><span class="lineNum">     804 </span>            : </a>
<a name="805"><span class="lineNum">     805 </span><span class="lineCov">        326 :      if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL )</span></a>
<a name="806"><span class="lineNum">     806 </span><span class="lineNoCov">          0 :           printf (&quot;Type Test finished. \n&quot;);</span></a>
<a name="807"><span class="lineNum">     807 </span>            : </a>
<a name="808"><span class="lineNum">     808 </span>            : #else</a>
<a name="809"><span class="lineNum">     809 </span>            :   // if (sageProject-&gt;get_useBackendOnly() == false)</a>
<a name="810"><span class="lineNum">     810 </span>            :      if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL )</a>
<a name="811"><span class="lineNum">     811 </span>            :           printf (&quot;Skipping test of query on types \n&quot;);</a>
<a name="812"><span class="lineNum">     812 </span>            : #endif</a>
<a name="813"><span class="lineNum">     813 </span>            : </a>
<a name="814"><span class="lineNum">     814 </span>            :   // DQ (9/21/2013): Force this to be skipped where ROSE's AST merge feature is active (since the point of</a>
<a name="815"><span class="lineNum">     815 </span>            :   // detect inconsistancy in parent child relationships and these will be present when astMerge is active.</a>
<a name="816"><span class="lineNum">     816 </span>            :   // if (sageProject-&gt;get_astMerge() == false)</a>
<a name="817"><span class="lineNum">     817 </span><span class="lineCov">        326 :      if (sageProject-&gt;get_ast_merge() == false &amp;&amp; sageProject-&gt;get_Fortran_only() == false)</span></a>
<a name="818"><span class="lineNum">     818 </span>            :         {</a>
<a name="819"><span class="lineNum">     819 </span>            :        // DQ (3/19/2012): Added test from Robb for parents of the IR nodes in the AST.</a>
<a name="820"><span class="lineNum">     820 </span><span class="lineCov">        290 :           TestForParentsMatchingASTStructure::test(sageProject);</span></a>
<a name="821"><span class="lineNum">     821 </span>            :         }</a>
<a name="822"><span class="lineNum">     822 </span>            : </a>
<a name="823"><span class="lineNum">     823 </span>            :   // DQ (12/3/2012): Test source position information.</a>
<a name="824"><span class="lineNum">     824 </span><span class="lineCov">        326 :      if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL )</span></a>
<a name="825"><span class="lineNum">     825 </span><span class="lineNoCov">          0 :           cout &lt;&lt; &quot;Test source position information started.&quot; &lt;&lt; endl;</span></a>
<a name="826"><span class="lineNum">     826 </span><span class="lineCov">        326 :         {</span></a>
<a name="827"><span class="lineNum">     827 </span><span class="lineCov">        326 :           TimingPerformance timer (&quot;Test source position information:&quot;);</span></a>
<a name="828"><span class="lineNum">     828 </span>            : </a>
<a name="829"><span class="lineNum">     829 </span><span class="lineCov">        652 :           TestForSourcePosition sourcePositionTest;</span></a>
<a name="830"><span class="lineNum">     830 </span><span class="lineCov">        326 :           sourcePositionTest.traverse(sageProject,preorder);</span></a>
<a name="831"><span class="lineNum">     831 </span>            :         }</a>
<a name="832"><span class="lineNum">     832 </span><span class="lineCov">        326 :      if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL )</span></a>
<a name="833"><span class="lineNum">     833 </span><span class="lineNoCov">          0 :           cout &lt;&lt; &quot;Test source position information finished.&quot; &lt;&lt; endl;</span></a>
<a name="834"><span class="lineNum">     834 </span>            : </a>
<a name="835"><span class="lineNum">     835 </span>            :   // DQ (12/11/2012): Test source position information.</a>
<a name="836"><span class="lineNum">     836 </span><span class="lineCov">        326 :      if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL )</span></a>
<a name="837"><span class="lineNum">     837 </span><span class="lineNoCov">          0 :           cout &lt;&lt; &quot;Test restrict keyword information started.&quot; &lt;&lt; endl;</span></a>
<a name="838"><span class="lineNum">     838 </span><span class="lineCov">        326 :         {</span></a>
<a name="839"><span class="lineNum">     839 </span><span class="lineCov">        326 :           TimingPerformance timer (&quot;Test restrict keyword:&quot;);</span></a>
<a name="840"><span class="lineNum">     840 </span>            : </a>
<a name="841"><span class="lineNum">     841 </span><span class="lineCov">        652 :           TestForMultipleWaysToSpecifyRestrictKeyword restrictKeywordTest;</span></a>
<a name="842"><span class="lineNum">     842 </span><span class="lineCov">        326 :           restrictKeywordTest.traverse(sageProject,preorder);</span></a>
<a name="843"><span class="lineNum">     843 </span>            :         }</a>
<a name="844"><span class="lineNum">     844 </span><span class="lineCov">        326 :      if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL )</span></a>
<a name="845"><span class="lineNum">     845 </span><span class="lineNoCov">          0 :           cout &lt;&lt; &quot;Test restrict keyword information finished.&quot; &lt;&lt; endl;</span></a>
<a name="846"><span class="lineNum">     846 </span>            : </a>
<a name="847"><span class="lineNum">     847 </span>            :   // DQ (12/13/2012): Verify that their are no SgPartialFunctionType IR nodes in the memory pool.</a>
<a name="848"><span class="lineNum">     848 </span><span class="lineCov">        326 :      ROSE_ASSERT(SgPartialFunctionType::numberOfNodes() == 0);</span></a>
<a name="849"><span class="lineNum">     849 </span>            : </a>
<a name="850"><span class="lineNum">     850 </span><span class="lineCov">        326 :      if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL )</span></a>
<a name="851"><span class="lineNum">     851 </span>            :         {</a>
<a name="852"><span class="lineNum">     852 </span><span class="lineCov">        326 :           printf (&quot;At BOTTOM of AstTests::runAllTests() \n&quot;);</span></a>
<a name="853"><span class="lineNum">     853 </span>            :         }</a>
<a name="854"><span class="lineNum">     854 </span>            :    }</a>
<a name="855"><span class="lineNum">     855 </span>            : </a>
<a name="856"><span class="lineNum">     856 </span>            : </a>
<a name="857"><span class="lineNum">     857 </span>            : /*! \page AstProperties AST Properties (Consistency Tests)</a>
<a name="858"><span class="lineNum">     858 </span>            : </a>
<a name="859"><span class="lineNum">     859 </span>            : \section section6 General AST Properties</a>
<a name="860"><span class="lineNum">     860 </span>            : </a>
<a name="861"><span class="lineNum">     861 </span>            :     All IR nodes are tests and verified to name a number of specific properties.</a>
<a name="862"><span class="lineNum">     862 </span>            : </a>
<a name="863"><span class="lineNum">     863 </span>            : \subsection subsection6a Source Code Position</a>
<a name="864"><span class="lineNum">     864 </span>            :     All SgLocatedNode and SgInitializedName IR nodes (and those derieved from them)</a>
<a name="865"><span class="lineNum">     865 </span>            :     are verified to have a valid pointer to a Sg_File_Info object.  Each IR nodes</a>
<a name="866"><span class="lineNum">     866 </span>            :     has a Sg_File_Info object for the start of the language construct and the end of</a>
<a name="867"><span class="lineNum">     867 </span>            :     the language construct.  Note that for scope statements the start and end positions</a>
<a name="868"><span class="lineNum">     868 </span>            :     identify the opening &quot;{&quot; and closing &quot;}&quot; were appropriate.</a>
<a name="869"><span class="lineNum">     869 </span>            :     - All nodes have a vaild Sg_File_Info object for the front and end of the subtree.</a>
<a name="870"><span class="lineNum">     870 </span>            :     - All Sg_File_Info objects are uniques (never shared) \n</a>
<a name="871"><span class="lineNum">     871 </span>            :       This is important to support classification of IR nodes within transformations</a>
<a name="872"><span class="lineNum">     872 </span>            :       (marked as transformed, shared, or compiler generated).</a>
<a name="873"><span class="lineNum">     873 </span>            :     - Any nodes not passing this tests are recorded internall (output with -rose-verbose &gt;= 2)</a>
<a name="874"><span class="lineNum">     874 </span>            : </a>
<a name="875"><span class="lineNum">     875 </span>            : \subsection subsection6b SgFunctionCallExp Properties</a>
<a name="876"><span class="lineNum">     876 </span>            : </a>
<a name="877"><span class="lineNum">     877 </span>            :     The SgFunctionCallExp is tested to verify that the get_function() member function returns</a>
<a name="878"><span class="lineNum">     878 </span>            :     only a specific subset of SgExpressions:</a>
<a name="879"><span class="lineNum">     879 </span>            :        - SgDotExp</a>
<a name="880"><span class="lineNum">     880 </span>            :        - SgDotStarOp</a>
<a name="881"><span class="lineNum">     881 </span>            :        - SgArrowExp</a>
<a name="882"><span class="lineNum">     882 </span>            :        - SgArrowStarOp</a>
<a name="883"><span class="lineNum">     883 </span>            :        - SgPointerDerefExp</a>
<a name="884"><span class="lineNum">     884 </span>            :        - SgFunctionRefExp</a>
<a name="885"><span class="lineNum">     885 </span>            :        - SgMemberFunctionRefExp</a>
<a name="886"><span class="lineNum">     886 </span>            : </a>
<a name="887"><span class="lineNum">     887 </span>            :     The SgType returned from these SgExpression objects is also restricted to the following</a>
<a name="888"><span class="lineNum">     888 </span>            :     subset of SgType objects:</a>
<a name="889"><span class="lineNum">     889 </span>            :        - SgTypedefType \n</a>
<a name="890"><span class="lineNum">     890 </span>            :          This is the case of a function call from a pointer to a function &quot;(object-&gt;*(mFieldAccessorMethod))();&quot;</a>
<a name="891"><span class="lineNum">     891 </span>            :        - SgMemberFunctionType</a>
<a name="892"><span class="lineNum">     892 </span>            :        - SgFunctionType \n</a>
<a name="893"><span class="lineNum">     893 </span>            :          These are the more common cases</a>
<a name="894"><span class="lineNum">     894 </span>            :        - SgPointerMemberType \n</a>
<a name="895"><span class="lineNum">     895 </span>            :          This is an unusual case.</a>
<a name="896"><span class="lineNum">     896 </span>            : </a>
<a name="897"><span class="lineNum">     897 </span>            :     Scopes are stored explicitly on some IR nodes (where the parent pointers in the AST could provide</a>
<a name="898"><span class="lineNum">     898 </span>            :     incorrect evaluation of the scope.  The following IR nodes are tested to verify that their</a>
<a name="899"><span class="lineNum">     899 </span>            :     explicitly represented scope is a valid pointer:</a>
<a name="900"><span class="lineNum">     900 </span>            :        - SgInitializedName</a>
<a name="901"><span class="lineNum">     901 </span>            :        - SgClassDeclaration</a>
<a name="902"><span class="lineNum">     902 </span>            :        - SgTemplateInstantiationDecl</a>
<a name="903"><span class="lineNum">     903 </span>            :        - SgFunctionDeclaration</a>
<a name="904"><span class="lineNum">     904 </span>            :        - SgMemberFunctionDeclaration</a>
<a name="905"><span class="lineNum">     905 </span>            :        - SgTemplateInstantiationFunctionDecl</a>
<a name="906"><span class="lineNum">     906 </span>            :        - SgTemplateInstantiationMemberFunctionDecl</a>
<a name="907"><span class="lineNum">     907 </span>            :        - SgTemplateDeclaration</a>
<a name="908"><span class="lineNum">     908 </span>            :        - SgTypedefDeclaration</a>
<a name="909"><span class="lineNum">     909 </span>            : </a>
<a name="910"><span class="lineNum">     910 </span>            : */</a>
<a name="911"><span class="lineNum">     911 </span>            : </a>
<a name="912"><span class="lineNum">     912 </span><span class="lineCov">        326 : TestAstProperties::TestAstProperties()</span></a>
<a name="913"><span class="lineNum">     913 </span>            :    {</a>
<a name="914"><span class="lineNum">     914 </span>            :   // DQ (10/24/2004): Initialize array of counters used to record frequency of</a>
<a name="915"><span class="lineNum">     915 </span>            :   // problem nodes (without file info object to represent end of construct)!</a>
<a name="916"><span class="lineNum">     916 </span>            :   // for (VariantT i = V_SgModifier; i != V_SgNumVariants; i++)</a>
<a name="917"><span class="lineNum">     917 </span><span class="lineCov">     141810 :      for (int i = V_SgModifier; i != V_SgNumVariants; i++)</span></a>
<a name="918"><span class="lineNum">     918 </span><span class="lineCov">     141484 :           nodeWithoutFileInfoFrequencyCount[i] = 0;</span></a>
<a name="919"><span class="lineNum">     919 </span><span class="lineCov">        326 :    }</span></a>
<a name="920"><span class="lineNum">     920 </span>            : </a>
<a name="921"><span class="lineNum">     921 </span>            : TestAstPropertiesSA</a>
<a name="922"><span class="lineNum">     922 </span><span class="lineCov">    5466810 : TestAstProperties::evaluateSynthesizedAttribute(SgNode* node, SynthesizedAttributesList l)</span></a>
<a name="923"><span class="lineNum">     923 </span>            :    {</a>
<a name="924"><span class="lineNum">     924 </span><span class="lineCov">    5466810 :      assert(node);</span></a>
<a name="925"><span class="lineNum">     925 </span><span class="lineCov">    5466810 :      TestAstPropertiesSA syn;</span></a>
<a name="926"><span class="lineNum">     926 </span>            : </a>
<a name="927"><span class="lineNum">     927 </span>            : #if 0</a>
<a name="928"><span class="lineNum">     928 </span>            :      int lineNumber = -1;</a>
<a name="929"><span class="lineNum">     929 </span>            :      string fileName = &quot;no file&quot;;</a>
<a name="930"><span class="lineNum">     930 </span>            :      ROSE_ASSERT (node != NULL);</a>
<a name="931"><span class="lineNum">     931 </span>            :      if (node-&gt;get_file_info() != NULL)</a>
<a name="932"><span class="lineNum">     932 </span>            :         {</a>
<a name="933"><span class="lineNum">     933 </span>            :           lineNumber = node-&gt;get_file_info()-&gt;get_line();</a>
<a name="934"><span class="lineNum">     934 </span>            :           fileName   = node-&gt;get_file_info()-&gt;get_filename();</a>
<a name="935"><span class="lineNum">     935 </span>            :         }</a>
<a name="936"><span class="lineNum">     936 </span>            :      printf (&quot;TestAstProperties: node = %s at %d of %s \n&quot;,node-&gt;sage_class_name(),lineNumber,fileName.c_str());</a>
<a name="937"><span class="lineNum">     937 </span>            : #endif</a>
<a name="938"><span class="lineNum">     938 </span>            : </a>
<a name="939"><span class="lineNum">     939 </span><span class="lineCov">   16054700 :      for (SynthesizedAttributesList::iterator i=l.begin(); i!=l.end(); i++)</span></a>
<a name="940"><span class="lineNum">     940 </span><span class="lineCov">   10587900 :           syn.val = syn.val &amp;&amp; (*i).val;</span></a>
<a name="941"><span class="lineNum">     941 </span><span class="lineCov">    5466810 :      if (!syn.val)</span></a>
<a name="942"><span class="lineNum">     942 </span>            :         {</a>
<a name="943"><span class="lineNum">     943 </span><span class="lineNoCov">          0 :           cout &lt;&lt; &quot;Children are incorrect@&quot; &lt;&lt; node-&gt; sage_class_name() &lt;&lt; endl;</span></a>
<a name="944"><span class="lineNum">     944 </span><span class="lineNoCov">          0 :           for(SynthesizedAttributesList::iterator i=l.begin(); i!=l.end(); i++)</span></a>
<a name="945"><span class="lineNum">     945 </span><span class="lineNoCov">          0 :                cout &lt;&lt; (*i).val &lt;&lt; &quot;, &quot;;</span></a>
<a name="946"><span class="lineNum">     946 </span><span class="lineNoCov">          0 :           cout &lt;&lt; endl;</span></a>
<a name="947"><span class="lineNum">     947 </span>            :         }</a>
<a name="948"><span class="lineNum">     948 </span>            : </a>
<a name="949"><span class="lineNum">     949 </span><span class="lineCov">    5466810 :      bool problematicNodeFound = AstTests::isProblematic(node);</span></a>
<a name="950"><span class="lineNum">     950 </span>            :   // if (problematicNodeFound)</a>
<a name="951"><span class="lineNum">     951 </span>            :   //      {</a>
<a name="952"><span class="lineNum">     952 </span>            :   //        cout &lt;&lt; &quot;Problematic Node: &quot; &lt;&lt; node-&gt;sage_class_name() &lt;&lt; &quot; found.&quot; &lt;&lt; endl;</a>
<a name="953"><span class="lineNum">     953 </span>            :   //      }</a>
<a name="954"><span class="lineNum">     954 </span><span class="lineCov">    5466810 :      syn.val = syn.val &amp;&amp; !problematicNodeFound;</span></a>
<a name="955"><span class="lineNum">     955 </span>            : </a>
<a name="956"><span class="lineNum">     956 </span>            :   // Test all traversed nodes to make sure that they have a valid file info object</a>
<a name="957"><span class="lineNum">     957 </span>            :   // Note that SgFile and SgProject nodes don't have file info objects (so skip them)</a>
<a name="958"><span class="lineNum">     958 </span>            : </a>
<a name="959"><span class="lineNum">     959 </span>            :   // DQ (11/20/2013): Added SgJavaImportStatementList and SgJavaClassDeclarationList to the exception list since they don't have a source position field.</a>
<a name="960"><span class="lineNum">     960 </span>            :   // if ( !isSgFile(node) &amp;&amp; !isSgProject(node) )</a>
<a name="961"><span class="lineNum">     961 </span>            :   // if ( !isSgFile(node) &amp;&amp; !isSgProject(node) &amp;&amp; !isSgAsmNode(node))</a>
<a name="962"><span class="lineNum">     962 </span>            :   // if ( !isSgFile(node) &amp;&amp; !isSgProject(node) &amp;&amp; !isSgFileList(node) &amp;&amp; !isSgDirectory(node) ) //&amp;&amp; !isSgJavaImportStatementList(node) &amp;&amp; !isSgJavaClassDeclarationList(node) )</a>
<a name="963"><span class="lineNum">     963 </span><span class="lineCov">    5466810 :      bool isFileNode = isSgFile(node) || isSgProject(node) || isSgFileList(node) || isSgDirectory(node);</span></a>
<a name="964"><span class="lineNum">     964 </span><span class="lineCov">    5465830 :      if (!isFileNode)</span></a>
<a name="965"><span class="lineNum">     965 </span>            :         {</a>
<a name="966"><span class="lineNum">     966 </span><span class="lineCov">    5465830 :           Sg_File_Info* fileInfo = node-&gt;get_file_info();</span></a>
<a name="967"><span class="lineNum">     967 </span><span class="lineCov">    5465830 :           if ( fileInfo == NULL )</span></a>
<a name="968"><span class="lineNum">     968 </span>            :              {</a>
<a name="969"><span class="lineNum">     969 </span><span class="lineNoCov">          0 :                printf (&quot;node-&gt;get_file_info() == NULL: node is %s \n&quot;,node-&gt;sage_class_name());</span></a>
<a name="970"><span class="lineNum">     970 </span><span class="lineNoCov">          0 :                ROSE_ABORT ();</span></a>
<a name="971"><span class="lineNum">     971 </span>            :              }</a>
<a name="972"><span class="lineNum">     972 </span>            :             else</a>
<a name="973"><span class="lineNum">     973 </span>            :              {</a>
<a name="974"><span class="lineNum">     974 </span>            :             // A file info object can only be tested for invalid line number</a>
<a name="975"><span class="lineNum">     975 </span>            :             // if it is not compiler generated or part of a transformation.</a>
<a name="976"><span class="lineNum">     976 </span><span class="lineCov">    5465830 :                if ( fileInfo-&gt;isCompilerGenerated() == false &amp;&amp; fileInfo-&gt;isTransformation() == false )</span></a>
<a name="977"><span class="lineNum">     977 </span>            :                   {</a>
<a name="978"><span class="lineNum">     978 </span><span class="lineCov">     461409 :                     if ( fileInfo-&gt;get_line() == 0 &amp;&amp; !isSgGlobal(node) )</span></a>
<a name="979"><span class="lineNum">     979 </span>            :                        {</a>
<a name="980"><span class="lineNum">     980 </span>            :                       // printf (&quot;node-&gt;get_file_info()-&gt;get_line() == 0: node is %s \n&quot;,node-&gt;sage_class_name());</a>
<a name="981"><span class="lineNum">     981 </span><span class="lineCov">      19134 :                          listOfNodesWithoutValidFileInfo.push_back(node);</span></a>
<a name="982"><span class="lineNum">     982 </span>            :                       // ROSE_ASSERT (false);</a>
<a name="983"><span class="lineNum">     983 </span>            :                        }</a>
<a name="984"><span class="lineNum">     984 </span>            :                   }</a>
<a name="985"><span class="lineNum">     985 </span>            :              }</a>
<a name="986"><span class="lineNum">     986 </span>            :         }</a>
<a name="987"><span class="lineNum">     987 </span>            : </a>
<a name="988"><span class="lineNum">     988 </span>            :   // Record the file info objects in all IR nodes traversed (so that we can test for uniqueness)</a>
<a name="989"><span class="lineNum">     989 </span><span class="lineCov">    5466810 :      listOfNodesFileInfo.push_back(node);</span></a>
<a name="990"><span class="lineNum">     990 </span>            : </a>
<a name="991"><span class="lineNum">     991 </span>            :   // Test the use of file info objects to define the start AND end of language</a>
<a name="992"><span class="lineNum">     992 </span>            :   // constructs (statements for now and expressions later on)</a>
<a name="993"><span class="lineNum">     993 </span><span class="lineCov">    5466810 :      SgStatement* statement = isSgStatement(node);</span></a>
<a name="994"><span class="lineNum">     994 </span><span class="lineCov">    5466810 :      if (statement != NULL)</span></a>
<a name="995"><span class="lineNum">     995 </span>            :         {</a>
<a name="996"><span class="lineNum">     996 </span>            :        // printf (&quot;Found a SgStatement, chekc for starting and ending file info objects \n&quot;);</a>
<a name="997"><span class="lineNum">     997 </span><span class="lineCov">    2329430 :           ROSE_ASSERT(statement-&gt;get_file_info() != NULL);</span></a>
<a name="998"><span class="lineNum">     998 </span><span class="lineCov">    2329430 :           Sg_File_Info* startingSourcePosition = statement-&gt;get_startOfConstruct();</span></a>
<a name="999"><span class="lineNum">     999 </span><span class="lineCov">    2329430 :           if (startingSourcePosition == NULL)</span></a>
<a name="1000"><span class="lineNum">    1000 </span>            :              {</a>
<a name="1001"><span class="lineNum">    1001 </span><span class="lineNoCov">          0 :                if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL )</span></a>
<a name="1002"><span class="lineNum">    1002 </span><span class="lineNoCov">          0 :                     printf (&quot;AST Diagnostics: Lacking starting postion info on %s \n&quot;,statement-&gt;sage_class_name());</span></a>
<a name="1003"><span class="lineNum">    1003 </span>            :              }</a>
<a name="1004"><span class="lineNum">    1004 </span>            :        // ROSE_ASSERT(startingSourcePosition != NULL);</a>
<a name="1005"><span class="lineNum">    1005 </span><span class="lineCov">    2329430 :           Sg_File_Info* endingSourcePosition = statement-&gt;get_endOfConstruct();</span></a>
<a name="1006"><span class="lineNum">    1006 </span><span class="lineCov">    2329430 :           if (endingSourcePosition == NULL)</span></a>
<a name="1007"><span class="lineNum">    1007 </span>            :              {</a>
<a name="1008"><span class="lineNum">    1008 </span><span class="lineNoCov">          0 :                nodeWithoutFileInfoFrequencyCount[statement-&gt;variantT()]++;</span></a>
<a name="1009"><span class="lineNum">    1009 </span>            :              }</a>
<a name="1010"><span class="lineNum">    1010 </span>            :        // ROSE_ASSERT(endingSourcePosition != NULL);</a>
<a name="1011"><span class="lineNum">    1011 </span>            :         }</a>
<a name="1012"><span class="lineNum">    1012 </span>            : </a>
<a name="1013"><span class="lineNum">    1013 </span>            :   // temporarily comment out this newly reported bug (from Willcock)</a>
<a name="1014"><span class="lineNum">    1014 </span>            : #if 1</a>
<a name="1015"><span class="lineNum">    1015 </span>            :   // DQ (7/11/2004): Added support for more general tests of the AST</a>
<a name="1016"><span class="lineNum">    1016 </span>            :   // This function now tests general AST properties (as the name implies)</a>
<a name="1017"><span class="lineNum">    1017 </span><span class="lineCov">    5466810 :      switch(node-&gt;variantT())</span></a>
<a name="1018"><span class="lineNum">    1018 </span>            :         {</a>
<a name="1019"><span class="lineNum">    1019 </span>            :        // DQ (7/11/2004): Test that the function in a function call has a valid function type</a>
<a name="1020"><span class="lineNum">    1020 </span><span class="lineCov">      20932 :           case V_SgFunctionCallExp:</span></a>
<a name="1021"><span class="lineNum">    1021 </span><span class="lineCov">      20932 :              {</span></a>
<a name="1022"><span class="lineNum">    1022 </span><span class="lineCov">      20932 :                SgFunctionCallExp* fc = isSgFunctionCallExp(node);</span></a>
<a name="1023"><span class="lineNum">    1023 </span><span class="lineCov">      20932 :                ROSE_ASSERT (fc != NULL);</span></a>
<a name="1024"><span class="lineNum">    1024 </span><span class="lineCov">      20932 :                SgExpression* functionExpression = fc-&gt;get_function();</span></a>
<a name="1025"><span class="lineNum">    1025 </span><span class="lineCov">      20932 :                ROSE_ASSERT (functionExpression != NULL);</span></a>
<a name="1026"><span class="lineNum">    1026 </span>            : </a>
<a name="1027"><span class="lineNum">    1027 </span>            :             // The type of expression is restricted to a subset of all possible expression (check this)</a>
<a name="1028"><span class="lineNum">    1028 </span><span class="lineCov">      20932 :                while (isSgCommaOpExp(functionExpression))</span></a>
<a name="1029"><span class="lineNum">    1029 </span>            :                   {</a>
<a name="1030"><span class="lineNum">    1030 </span><span class="lineNoCov">          0 :                     functionExpression = isSgCommaOpExp(functionExpression)-&gt;get_rhs_operand();</span></a>
<a name="1031"><span class="lineNum">    1031 </span>            :                   }</a>
<a name="1032"><span class="lineNum">    1032 </span>            : </a>
<a name="1033"><span class="lineNum">    1033 </span><span class="lineCov">      20932 :                switch (functionExpression-&gt;variantT())</span></a>
<a name="1034"><span class="lineNum">    1034 </span>            :                   {</a>
<a name="1035"><span class="lineNum">    1035 </span>            :                  // these are the acceptable cases</a>
<a name="1036"><span class="lineNum">    1036 </span>            :                     case V_SgDotExp:</a>
<a name="1037"><span class="lineNum">    1037 </span>            :                     case V_SgDotStarOp:</a>
<a name="1038"><span class="lineNum">    1038 </span>            :                     case V_SgArrowExp:</a>
<a name="1039"><span class="lineNum">    1039 </span>            :                     case V_SgArrowStarOp:</a>
<a name="1040"><span class="lineNum">    1040 </span>            :                     case V_SgPointerDerefExp:</a>
<a name="1041"><span class="lineNum">    1041 </span>            :                        {</a>
<a name="1042"><span class="lineNum">    1042 </span>            :                       // these are the acceptable cases</a>
<a name="1043"><span class="lineNum">    1043 </span>            :                          break;</a>
<a name="1044"><span class="lineNum">    1044 </span>            :                        }</a>
<a name="1045"><span class="lineNum">    1045 </span>            : </a>
<a name="1046"><span class="lineNum">    1046 </span><span class="lineCov">       4970 :                     case V_SgFunctionRefExp:</span></a>
<a name="1047"><span class="lineNum">    1047 </span><span class="lineCov">       4970 :                        {</span></a>
<a name="1048"><span class="lineNum">    1048 </span><span class="lineCov">       4970 :                          SgFunctionRefExp* functionRefExp = isSgFunctionRefExp(functionExpression);</span></a>
<a name="1049"><span class="lineNum">    1049 </span><span class="lineCov">       4970 :                          ROSE_ASSERT(functionRefExp != NULL);</span></a>
<a name="1050"><span class="lineNum">    1050 </span><span class="lineCov">       4970 :                          SgFunctionSymbol* functionSymbol = functionRefExp-&gt;get_symbol();</span></a>
<a name="1051"><span class="lineNum">    1051 </span><span class="lineCov">       4970 :                          ROSE_ASSERT(functionSymbol != NULL);</span></a>
<a name="1052"><span class="lineNum">    1052 </span>            : </a>
<a name="1053"><span class="lineNum">    1053 </span>            :                       // Make sure that the function has a valid declaration</a>
<a name="1054"><span class="lineNum">    1054 </span><span class="lineCov">       4970 :                          ROSE_ASSERT(functionSymbol-&gt;get_declaration() != NULL);</span></a>
<a name="1055"><span class="lineNum">    1055 </span><span class="lineCov">       4970 :                          break;</span></a>
<a name="1056"><span class="lineNum">    1056 </span>            :                        }</a>
<a name="1057"><span class="lineNum">    1057 </span>            : </a>
<a name="1058"><span class="lineNum">    1058 </span>            :                  // DQ (2/23/2013): Added support for SgTemplateFunctionRefExp (required as part of fix for test2013_69.C).</a>
<a name="1059"><span class="lineNum">    1059 </span><span class="lineCov">       1534 :                     case V_SgTemplateFunctionRefExp:</span></a>
<a name="1060"><span class="lineNum">    1060 </span><span class="lineCov">       1534 :                        {</span></a>
<a name="1061"><span class="lineNum">    1061 </span><span class="lineCov">       1534 :                          SgTemplateFunctionRefExp* functionRefExp = isSgTemplateFunctionRefExp(functionExpression);</span></a>
<a name="1062"><span class="lineNum">    1062 </span><span class="lineCov">       1534 :                          ROSE_ASSERT(functionRefExp != NULL);</span></a>
<a name="1063"><span class="lineNum">    1063 </span><span class="lineCov">       1534 :                          SgFunctionSymbol* functionSymbol = functionRefExp-&gt;get_symbol();</span></a>
<a name="1064"><span class="lineNum">    1064 </span><span class="lineCov">       1534 :                          ROSE_ASSERT(functionSymbol != NULL);</span></a>
<a name="1065"><span class="lineNum">    1065 </span>            : </a>
<a name="1066"><span class="lineNum">    1066 </span>            :                       // Make sure that the function has a valid declaration</a>
<a name="1067"><span class="lineNum">    1067 </span><span class="lineCov">       1534 :                          ROSE_ASSERT(functionSymbol-&gt;get_declaration() != NULL);</span></a>
<a name="1068"><span class="lineNum">    1068 </span><span class="lineCov">       1534 :                          break;</span></a>
<a name="1069"><span class="lineNum">    1069 </span>            :                        }</a>
<a name="1070"><span class="lineNum">    1070 </span>            : </a>
<a name="1071"><span class="lineNum">    1071 </span><span class="lineCov">        652 :                     case V_SgMemberFunctionRefExp:</span></a>
<a name="1072"><span class="lineNum">    1072 </span><span class="lineCov">        652 :                        {</span></a>
<a name="1073"><span class="lineNum">    1073 </span><span class="lineCov">        652 :                          SgMemberFunctionRefExp* memberFunctionRefExp = isSgMemberFunctionRefExp(functionExpression);</span></a>
<a name="1074"><span class="lineNum">    1074 </span><span class="lineCov">        652 :                          ROSE_ASSERT(memberFunctionRefExp != NULL);</span></a>
<a name="1075"><span class="lineNum">    1075 </span><span class="lineCov">        652 :                          SgMemberFunctionSymbol* memberFunctionSymbol = memberFunctionRefExp-&gt;get_symbol();</span></a>
<a name="1076"><span class="lineNum">    1076 </span><span class="lineCov">        652 :                          ROSE_ASSERT(memberFunctionSymbol != NULL);</span></a>
<a name="1077"><span class="lineNum">    1077 </span>            : </a>
<a name="1078"><span class="lineNum">    1078 </span>            :                       // Make sure that the function has a valid declaration</a>
<a name="1079"><span class="lineNum">    1079 </span><span class="lineCov">        652 :                          ROSE_ASSERT(memberFunctionSymbol-&gt;get_declaration() != NULL);</span></a>
<a name="1080"><span class="lineNum">    1080 </span><span class="lineCov">        652 :                          SgMemberFunctionDeclaration* memberFunctionDeclaration = memberFunctionSymbol-&gt;get_declaration();</span></a>
<a name="1081"><span class="lineNum">    1081 </span>            : </a>
<a name="1082"><span class="lineNum">    1082 </span>            :                       // DQ (7/29/2005): If there is a non-defining declaration available</a>
<a name="1083"><span class="lineNum">    1083 </span>            :                       // then make sure that it is used for all function calls.</a>
<a name="1084"><span class="lineNum">    1084 </span><span class="lineCov">        652 :                          if (memberFunctionDeclaration-&gt;get_firstNondefiningDeclaration() != NULL)</span></a>
<a name="1085"><span class="lineNum">    1085 </span>            :                             {</a>
<a name="1086"><span class="lineNum">    1086 </span>            :                            // Since this is a non-defining declaration then it should not have a definition</a>
<a name="1087"><span class="lineNum">    1087 </span><span class="lineCov">        652 :                               if (memberFunctionDeclaration-&gt;get_firstNondefiningDeclaration() != NULL)</span></a>
<a name="1088"><span class="lineNum">    1088 </span>            :                                  {</a>
<a name="1089"><span class="lineNum">    1089 </span><span class="lineCov">        652 :                                    SgMemberFunctionDeclaration* firstNondefiningDeclaration =</span></a>
<a name="1090"><span class="lineNum">    1090 </span><span class="lineCov">        652 :                                         isSgMemberFunctionDeclaration(memberFunctionDeclaration-&gt;get_firstNondefiningDeclaration());</span></a>
<a name="1091"><span class="lineNum">    1091 </span><span class="lineCov">        652 :                                    SgTemplateInstantiationMemberFunctionDecl* templateInstantiation =</span></a>
<a name="1092"><span class="lineNum">    1092 </span><span class="lineCov">        652 :                                         isSgTemplateInstantiationMemberFunctionDecl(firstNondefiningDeclaration);</span></a>
<a name="1093"><span class="lineNum">    1093 </span><span class="lineCov">        652 :                                    if (templateInstantiation != NULL)</span></a>
<a name="1094"><span class="lineNum">    1094 </span>            :                                       {</a>
<a name="1095"><span class="lineNum">    1095 </span>            :                                      // Make sure this is a non-defining declaration</a>
<a name="1096"><span class="lineNum">    1096 </span><span class="lineCov">        176 :                                         ROSE_ASSERT(templateInstantiation-&gt;get_definition() == NULL);</span></a>
<a name="1097"><span class="lineNum">    1097 </span>            :                                       }</a>
<a name="1098"><span class="lineNum">    1098 </span>            :                                      else</a>
<a name="1099"><span class="lineNum">    1099 </span>            :                                       {</a>
<a name="1100"><span class="lineNum">    1100 </span>            :                                      // Make sure this is a non-defining declaration</a>
<a name="1101"><span class="lineNum">    1101 </span><span class="lineCov">        476 :                                         ROSE_ASSERT(firstNondefiningDeclaration-&gt;get_definition() == NULL);</span></a>
<a name="1102"><span class="lineNum">    1102 </span>            :                                       }</a>
<a name="1103"><span class="lineNum">    1103 </span>            :                                  }</a>
<a name="1104"><span class="lineNum">    1104 </span>            : </a>
<a name="1105"><span class="lineNum">    1105 </span>            :                            // If this is not a defining declaration then it should match the firstNondefiningDeclaration</a>
<a name="1106"><span class="lineNum">    1106 </span><span class="lineCov">        652 :                               if (memberFunctionDeclaration-&gt;get_definition() == NULL)</span></a>
<a name="1107"><span class="lineNum">    1107 </span>            :                                  {</a>
<a name="1108"><span class="lineNum">    1108 </span>            :                                 // Make sure that the first non-defining declaration is recorded</a>
<a name="1109"><span class="lineNum">    1109 </span>            :                                 // int the AST is the one referenced by the memberFunctionRefExp.</a>
<a name="1110"><span class="lineNum">    1110 </span><span class="lineCov">        652 :                                    if (memberFunctionDeclaration != memberFunctionDeclaration-&gt;get_firstNondefiningDeclaration())</span></a>
<a name="1111"><span class="lineNum">    1111 </span>            :                                       {</a>
<a name="1112"><span class="lineNum">    1112 </span><span class="lineNoCov">          0 :                                         printf (&quot;memberFunctionDeclaration = %p \n&quot;,memberFunctionDeclaration);</span></a>
<a name="1113"><span class="lineNum">    1113 </span><span class="lineNoCov">          0 :                                         printf (&quot;memberFunctionDeclaration-&gt;get_firstNondefiningDeclaration() = %p \n&quot;,</span></a>
<a name="1114"><span class="lineNum">    1114 </span>            :                                              memberFunctionDeclaration-&gt;get_firstNondefiningDeclaration());</a>
<a name="1115"><span class="lineNum">    1115 </span><span class="lineNoCov">          0 :                                         memberFunctionDeclaration-&gt;get_file_info()-&gt;display(&quot;memberFunctionDeclaration&quot;);</span></a>
<a name="1116"><span class="lineNum">    1116 </span><span class="lineNoCov">          0 :                                         memberFunctionDeclaration-&gt;get_firstNondefiningDeclaration()-&gt;get_file_info()-&gt;display(&quot;memberFunctionDeclaration-&gt;get_firstNondefiningDeclaration()&quot;);</span></a>
<a name="1117"><span class="lineNum">    1117 </span><span class="lineNoCov">          0 :                                         memberFunctionDeclaration-&gt;get_firstNondefiningDeclaration()-&gt;get_file_info()-&gt;display(&quot;debug&quot;);</span></a>
<a name="1118"><span class="lineNum">    1118 </span>            :                                       }</a>
<a name="1119"><span class="lineNum">    1119 </span><span class="lineCov">        652 :                                    ROSE_ASSERT(memberFunctionDeclaration == memberFunctionDeclaration-&gt;get_firstNondefiningDeclaration());</span></a>
<a name="1120"><span class="lineNum">    1120 </span>            :                                  }</a>
<a name="1121"><span class="lineNum">    1121 </span>            : </a>
<a name="1122"><span class="lineNum">    1122 </span>            :                            // Check the scope of the member function, make sure that it is a SgClassDefinition</a>
<a name="1123"><span class="lineNum">    1123 </span>            :                            // (could also be a SgTemplateInstantiationDefn).</a>
<a name="1124"><span class="lineNum">    1124 </span><span class="lineCov">        652 :                               ROSE_ASSERT(isSgClassDefinition(memberFunctionDeclaration-&gt;get_scope()) != NULL);</span></a>
<a name="1125"><span class="lineNum">    1125 </span>            : </a>
<a name="1126"><span class="lineNum">    1126 </span>            :                            // printf (&quot;AST Consistency Tests: memberFunctionDeclaration %s definition = %p \n&quot;,</a>
<a name="1127"><span class="lineNum">    1127 </span>            :                            //      memberFunctionDeclaration-&gt;get_name().str(),memberFunctionDeclaration-&gt;get_definition());</a>
<a name="1128"><span class="lineNum">    1128 </span>            :                             }</a>
<a name="1129"><span class="lineNum">    1129 </span>            :                          break;</a>
<a name="1130"><span class="lineNum">    1130 </span>            :                        }</a>
<a name="1131"><span class="lineNum">    1131 </span>            : </a>
<a name="1132"><span class="lineNum">    1132 </span>            :                  // TV (04/16/2019): used to be casses guarded by ROSE_USE_EDG_VERSION_4</a>
<a name="1133"><span class="lineNum">    1133 </span>            :                     case V_SgIntVal:</a>
<a name="1134"><span class="lineNum">    1134 </span>            :                     case V_SgFunctionCallExp:</a>
<a name="1135"><span class="lineNum">    1135 </span>            :                     case V_SgConstructorInitializer:</a>
<a name="1136"><span class="lineNum">    1136 </span>            :                     case V_SgCastExp:</a>
<a name="1137"><span class="lineNum">    1137 </span>            :                     case V_SgConditionalExp:</a>
<a name="1138"><span class="lineNum">    1138 </span>            :                     case V_SgTemplateParameterVal:</a>
<a name="1139"><span class="lineNum">    1139 </span>            :                     case V_SgAddressOfOp:</a>
<a name="1140"><span class="lineNum">    1140 </span>            :                     case V_SgPntrArrRefExp:</a>
<a name="1141"><span class="lineNum">    1141 </span>            :                     case V_SgVarRefExp:</a>
<a name="1142"><span class="lineNum">    1142 </span>            :                     case V_SgTemplateMemberFunctionRefExp:</a>
<a name="1143"><span class="lineNum">    1143 </span>            :                        {</a>
<a name="1144"><span class="lineNum">    1144 </span>            :                          break;</a>
<a name="1145"><span class="lineNum">    1145 </span>            :                        }</a>
<a name="1146"><span class="lineNum">    1146 </span>            : </a>
<a name="1147"><span class="lineNum">    1147 </span>            :                     case V_SgNonrealRefExp:</a>
<a name="1148"><span class="lineNum">    1148 </span>            :                        {</a>
<a name="1149"><span class="lineNum">    1149 </span>            :                       // TV (05/10/2018): FIXME checks ???</a>
<a name="1150"><span class="lineNum">    1150 </span>            :                          break;</a>
<a name="1151"><span class="lineNum">    1151 </span>            :                        }</a>
<a name="1152"><span class="lineNum">    1152 </span>            : </a>
<a name="1153"><span class="lineNum">    1153 </span><span class="lineNoCov">          0 :                     default:</span></a>
<a name="1154"><span class="lineNum">    1154 </span><span class="lineNoCov">          0 :                        {</span></a>
<a name="1155"><span class="lineNum">    1155 </span><span class="lineNoCov">          0 :                          printf (&quot;Error case default in switch (functionExpression = %s) \n&quot;,functionExpression-&gt;class_name().c_str());</span></a>
<a name="1156"><span class="lineNum">    1156 </span><span class="lineNoCov">          0 :                          ROSE_ABORT();</span></a>
<a name="1157"><span class="lineNum">    1157 </span>            :                        }</a>
<a name="1158"><span class="lineNum">    1158 </span>            :                   }</a>
<a name="1159"><span class="lineNum">    1159 </span>            : </a>
<a name="1160"><span class="lineNum">    1160 </span>            :             // DQ(1/16/2006): Removed redundent p_expression_type data member (type now computed, most often from operands)</a>
<a name="1161"><span class="lineNum">    1161 </span>            :             // ROSE_ASSERT (fc-&gt;get_expression_type() != NULL);</a>
<a name="1162"><span class="lineNum">    1162 </span>            : </a>
<a name="1163"><span class="lineNum">    1163 </span>            :             // printf (&quot;Test fc-&gt;get_type() != NULL: functionExpression = %s \n&quot;,functionExpression-&gt;class_name().c_str());</a>
<a name="1164"><span class="lineNum">    1164 </span><span class="lineCov">      20932 :                ROSE_ASSERT (fc-&gt;get_type() != NULL);</span></a>
<a name="1165"><span class="lineNum">    1165 </span><span class="lineCov">      20932 :                ROSE_ASSERT (fc-&gt;get_function()-&gt;get_type() != NULL);</span></a>
<a name="1166"><span class="lineNum">    1166 </span>            : </a>
<a name="1167"><span class="lineNum">    1167 </span>            :             // DQ (6/30/2005): Most often this is a SgFunctionType, but it could be a SgTypedefType if</a>
<a name="1168"><span class="lineNum">    1168 </span>            :             // it is a function call from a pointer to a function which is typedefed (see test2005_10.C).</a>
<a name="1169"><span class="lineNum">    1169 </span><span class="lineCov">      20932 :                SgType* callType = fc-&gt;get_function()-&gt;get_type();</span></a>
<a name="1170"><span class="lineNum">    1170 </span><span class="lineCov">      20932 :                switch (callType-&gt;variantT())</span></a>
<a name="1171"><span class="lineNum">    1171 </span>            :                   {</a>
<a name="1172"><span class="lineNum">    1172 </span>            :                     case V_SgTypedefType:</a>
<a name="1173"><span class="lineNum">    1173 </span>            :                        {</a>
<a name="1174"><span class="lineNum">    1174 </span>            :                       // this is the case of a function call from a pointer to a function &quot;(object-&gt;*(mFieldAccessorMethod))();&quot;</a>
<a name="1175"><span class="lineNum">    1175 </span>            :                          break;</a>
<a name="1176"><span class="lineNum">    1176 </span>            :                        }</a>
<a name="1177"><span class="lineNum">    1177 </span>            : </a>
<a name="1178"><span class="lineNum">    1178 </span>            :                     case V_SgMemberFunctionType:</a>
<a name="1179"><span class="lineNum">    1179 </span>            :                     case V_SgFunctionType:</a>
<a name="1180"><span class="lineNum">    1180 </span>            :                        {</a>
<a name="1181"><span class="lineNum">    1181 </span>            :                       // this is the normal case</a>
<a name="1182"><span class="lineNum">    1182 </span>            :                          break;</a>
<a name="1183"><span class="lineNum">    1183 </span>            :                        }</a>
<a name="1184"><span class="lineNum">    1184 </span>            : </a>
<a name="1185"><span class="lineNum">    1185 </span>            :                     case V_SgPointerMemberType:</a>
<a name="1186"><span class="lineNum">    1186 </span>            :                        {</a>
<a name="1187"><span class="lineNum">    1187 </span>            :                       // this is a rare case (demonstrated by test2005_112.C)</a>
<a name="1188"><span class="lineNum">    1188 </span>            :                          break;</a>
<a name="1189"><span class="lineNum">    1189 </span>            :                        }</a>
<a name="1190"><span class="lineNum">    1190 </span>            : </a>
<a name="1191"><span class="lineNum">    1191 </span>            :                  // This might be requires due to an internal error (then again it does make since that we could have a pointer to a normal function!).</a>
<a name="1192"><span class="lineNum">    1192 </span>            :                     case V_SgPointerType:</a>
<a name="1193"><span class="lineNum">    1193 </span>            :                        {</a>
<a name="1194"><span class="lineNum">    1194 </span>            :                       // DQ (1/16/2006): This is a new case appearing only after reimplementing the get_type() support in SgExpression IR nodes. (demonstrated by test2001_16.C)</a>
<a name="1195"><span class="lineNum">    1195 </span>            : #if PRINT_DEVELOPER_WARNINGS</a>
<a name="1196"><span class="lineNum">    1196 </span>            :                          printf (&quot;This is a new case appearing only after reimplementing the get_type() support in SgExpression IR nodes. \n&quot;);</a>
<a name="1197"><span class="lineNum">    1197 </span>            : #endif</a>
<a name="1198"><span class="lineNum">    1198 </span>            :                          break;</a>
<a name="1199"><span class="lineNum">    1199 </span>            :                        }</a>
<a name="1200"><span class="lineNum">    1200 </span>            : </a>
<a name="1201"><span class="lineNum">    1201 </span>            :                     case V_SgPartialFunctionType:</a>
<a name="1202"><span class="lineNum">    1202 </span>            :                        {</a>
<a name="1203"><span class="lineNum">    1203 </span>            :                       // This case is only present in the new EDG/Sage interface (demonstrated by gzip.c)</a>
<a name="1204"><span class="lineNum">    1204 </span>            :                          break;</a>
<a name="1205"><span class="lineNum">    1205 </span>            :                        }</a>
<a name="1206"><span class="lineNum">    1206 </span>            :                  // TV: these cases were guarded with EDG 4 condition (date from EDG 3)</a>
<a name="1207"><span class="lineNum">    1207 </span>            :                     case V_SgTypeInt:</a>
<a name="1208"><span class="lineNum">    1208 </span>            :                     case V_SgTemplateType:</a>
<a name="1209"><span class="lineNum">    1209 </span>            :                     case V_SgClassType:</a>
<a name="1210"><span class="lineNum">    1210 </span>            :                     case V_SgReferenceType:</a>
<a name="1211"><span class="lineNum">    1211 </span>            :                     case V_SgModifierType:</a>
<a name="1212"><span class="lineNum">    1212 </span>            :                     case V_SgTypeVoid:</a>
<a name="1213"><span class="lineNum">    1213 </span>            :                     case V_SgTypeUnknown:</a>
<a name="1214"><span class="lineNum">    1214 </span>            :                     case V_SgRvalueReferenceType:</a>
<a name="1215"><span class="lineNum">    1215 </span>            :                        {</a>
<a name="1216"><span class="lineNum">    1216 </span>            :                          break;</a>
<a name="1217"><span class="lineNum">    1217 </span>            :                        }</a>
<a name="1218"><span class="lineNum">    1218 </span>            : </a>
<a name="1219"><span class="lineNum">    1219 </span>            :                     case V_SgNonrealType:</a>
<a name="1220"><span class="lineNum">    1220 </span>            :                     case V_SgAutoType:</a>
<a name="1221"><span class="lineNum">    1221 </span>            :                        {</a>
<a name="1222"><span class="lineNum">    1222 </span>            :                          break;</a>
<a name="1223"><span class="lineNum">    1223 </span>            :                        }</a>
<a name="1224"><span class="lineNum">    1224 </span>            : </a>
<a name="1225"><span class="lineNum">    1225 </span>            :                     case V_SgDeclType:</a>
<a name="1226"><span class="lineNum">    1226 </span>            :                        {</a>
<a name="1227"><span class="lineNum">    1227 </span>            : #ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION</a>
<a name="1228"><span class="lineNum">    1228 </span>            :                          printf (&quot;Warning: EDG 4.x specific case, found unusual case of SgDeclType returned from SgFunctionCallExp::get_type() member function \n&quot;);</a>
<a name="1229"><span class="lineNum">    1229 </span>            : #endif</a>
<a name="1230"><span class="lineNum">    1230 </span>            :                          break;</a>
<a name="1231"><span class="lineNum">    1231 </span>            :                        }</a>
<a name="1232"><span class="lineNum">    1232 </span>            : </a>
<a name="1233"><span class="lineNum">    1233 </span>            :                     // PP (01/22/21) used in Ada</a>
<a name="1234"><span class="lineNum">    1234 </span>            :                     case V_SgTypeBool:</a>
<a name="1235"><span class="lineNum">    1235 </span>            :                     case V_SgTypeLongLong:</a>
<a name="1236"><span class="lineNum">    1236 </span>            :                        {</a>
<a name="1237"><span class="lineNum">    1237 </span>            :                          //ROSE_ASSERT(SageInterface::is_Ada_language());</a>
<a name="1238"><span class="lineNum">    1238 </span>            :                          break;</a>
<a name="1239"><span class="lineNum">    1239 </span>            :                        }</a>
<a name="1240"><span class="lineNum">    1240 </span>            : </a>
<a name="1241"><span class="lineNum">    1241 </span><span class="lineNoCov">          0 :                     default:</span></a>
<a name="1242"><span class="lineNum">    1242 </span><span class="lineNoCov">          0 :                        {</span></a>
<a name="1243"><span class="lineNum">    1243 </span><span class="lineNoCov">          0 :                          printf (&quot;Error case default in switch (callType = %s) \n&quot;,callType-&gt;sage_class_name());</span></a>
<a name="1244"><span class="lineNum">    1244 </span><span class="lineNoCov">          0 :                          ROSE_ABORT();</span></a>
<a name="1245"><span class="lineNum">    1245 </span>            :                        }</a>
<a name="1246"><span class="lineNum">    1246 </span>            :                   }</a>
<a name="1247"><span class="lineNum">    1247 </span>            : #if 0</a>
<a name="1248"><span class="lineNum">    1248 </span>            :                SgFunctionType* ft = isSgFunctionType(fc-&gt;get_function()-&gt;get_type());</a>
<a name="1249"><span class="lineNum">    1249 </span>            :                if (ft == NULL)</a>
<a name="1250"><span class="lineNum">    1250 </span>            :                   {</a>
<a name="1251"><span class="lineNum">    1251 </span>            :                  // This is the case of a function call from a pointer to a function &quot;(object-&gt;*(mFieldAccessorMethod))();&quot;</a>
<a name="1252"><span class="lineNum">    1252 </span>            :                     printf (&quot;fc-&gt;get_function()-&gt;get_type() = %p = %s \n&quot;,fc-&gt;get_function()-&gt;get_type(),fc-&gt;get_function()-&gt;get_type()-&gt;sage_class_name());</a>
<a name="1253"><span class="lineNum">    1253 </span>            :                     fc-&gt;get_file_info()-&gt;display(&quot;found SgFunctionCallExp with reference to function who's type is not a SgFunctionType&quot;);</a>
<a name="1254"><span class="lineNum">    1254 </span>            : </a>
<a name="1255"><span class="lineNum">    1255 </span>            :                     if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL )</a>
<a name="1256"><span class="lineNum">    1256 </span>            :                          printf (&quot;Error: internal test found SgFunctionCallExp with reference to function who's type is not a SgFunctionType node \n&quot;);</a>
<a name="1257"><span class="lineNum">    1257 </span>            :                     int lineNumber = -1;</a>
<a name="1258"><span class="lineNum">    1258 </span>            :                     string fileName = &quot;no file&quot;;</a>
<a name="1259"><span class="lineNum">    1259 </span>            :                     if (fc-&gt;get_file_info() != NULL)</a>
<a name="1260"><span class="lineNum">    1260 </span>            :                        {</a>
<a name="1261"><span class="lineNum">    1261 </span>            :                          lineNumber = fc-&gt;get_file_info()-&gt;get_line();</a>
<a name="1262"><span class="lineNum">    1262 </span>            :                          fileName   = fc-&gt;get_file_info()-&gt;get_filename();</a>
<a name="1263"><span class="lineNum">    1263 </span>            :                        }</a>
<a name="1264"><span class="lineNum">    1264 </span>            :                     if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL )</a>
<a name="1265"><span class="lineNum">    1265 </span>            :                        {</a>
<a name="1266"><span class="lineNum">    1266 </span>            :                          printf (&quot;     fc-&gt;get_expression_type() = %s \n&quot;,fc-&gt;get_expression_type()-&gt;sage_class_name());</a>
<a name="1267"><span class="lineNum">    1267 </span>            :                          printf (&quot;     fc == %s at %d of %s  \n&quot;,fc-&gt;sage_class_name(),lineNumber,fileName.c_str());</a>
<a name="1268"><span class="lineNum">    1268 </span>            :                          printf (&quot;     fc-&gt;get_function() == %s \n&quot;,fc-&gt;get_function()-&gt;sage_class_name());</a>
<a name="1269"><span class="lineNum">    1269 </span>            :                        }</a>
<a name="1270"><span class="lineNum">    1270 </span>            : </a>
<a name="1271"><span class="lineNum">    1271 </span>            :                     ROSE_ASSERT (fc-&gt;get_function() != NULL);</a>
<a name="1272"><span class="lineNum">    1272 </span>            :                     ROSE_ASSERT (fc-&gt;get_function()-&gt;get_type() != NULL);</a>
<a name="1273"><span class="lineNum">    1273 </span>            :                     if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL )</a>
<a name="1274"><span class="lineNum">    1274 </span>            :                        {</a>
<a name="1275"><span class="lineNum">    1275 </span>            :                          printf (&quot;     fc-&gt;get_function()-&gt;get_type() == %s \n&quot;,</a>
<a name="1276"><span class="lineNum">    1276 </span>            :                               fc-&gt;get_function()-&gt;get_type()-&gt;sage_class_name());</a>
<a name="1277"><span class="lineNum">    1277 </span>            :                        }</a>
<a name="1278"><span class="lineNum">    1278 </span>            :                     ROSE_ASSERT (fc-&gt;get_args() != NULL);</a>
<a name="1279"><span class="lineNum">    1279 </span>            :                   }</a>
<a name="1280"><span class="lineNum">    1280 </span>            :             // DQ (6/30/2005): Allow to be NULL to support function call from pointer to function.</a>
<a name="1281"><span class="lineNum">    1281 </span>            :             // There may be a better way to support this within the AST (explicitly mark as function call from pointer?).</a>
<a name="1282"><span class="lineNum">    1282 </span>            :             // ROSE_ASSERT (ft != NULL);</a>
<a name="1283"><span class="lineNum">    1283 </span>            : #endif</a>
<a name="1284"><span class="lineNum">    1284 </span>            : </a>
<a name="1285"><span class="lineNum">    1285 </span>            :             // DQ (2/22/2013): Ben Allen has noticed that this will assert fail instead of returning a null pointer.</a>
<a name="1286"><span class="lineNum">    1286 </span>            :             // This should be fixed now.</a>
<a name="1287"><span class="lineNum">    1287 </span><span class="lineCov">      20932 :                SgFunctionDeclaration *declaration = fc-&gt;getAssociatedFunctionDeclaration();</span></a>
<a name="1288"><span class="lineNum">    1288 </span>            :                if (declaration == NULL)</a>
<a name="1289"><span class="lineNum">    1289 </span>            :                   {</a>
<a name="1290"><span class="lineNum">    1290 </span>            : #ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION</a>
<a name="1291"><span class="lineNum">    1291 </span>            :                     printf (&quot;Note that getAssociatedFunctionDeclaration() has returned NULL pointer (OK in certain cases, see test2013_68.C) \n&quot;);</a>
<a name="1292"><span class="lineNum">    1292 </span>            : #endif</a>
<a name="1293"><span class="lineNum">    1293 </span>            :                   }</a>
<a name="1294"><span class="lineNum">    1294 </span>            : </a>
<a name="1295"><span class="lineNum">    1295 </span>            :                break;</a>
<a name="1296"><span class="lineNum">    1296 </span>            :              }</a>
<a name="1297"><span class="lineNum">    1297 </span>            : </a>
<a name="1298"><span class="lineNum">    1298 </span>            :        // DQ (8/3/2004): Added output of problem IR nodes (output when evaluating</a>
<a name="1299"><span class="lineNum">    1299 </span>            :        // the SgFile nodes near the end of the traversal).</a>
<a name="1300"><span class="lineNum">    1300 </span><span class="lineNoCov">          0 :           case V_SgFile:</span></a>
<a name="1301"><span class="lineNum">    1301 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="1302"><span class="lineNum">    1302 </span>            :             // Report the number of IR nodes traversed</a>
<a name="1303"><span class="lineNum">    1303 </span><span class="lineNoCov">          0 :                if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL )</span></a>
<a name="1304"><span class="lineNum">    1304 </span><span class="lineNoCov">          0 :                     printf (&quot;\n     Total number of nodes traversed = %ld \n&quot;,(long)listOfNodesFileInfo.size());</span></a>
<a name="1305"><span class="lineNum">    1305 </span>            : </a>
<a name="1306"><span class="lineNum">    1306 </span>            :             // Only need to output information if there are a nonzero number of nodes without correct file info</a>
<a name="1307"><span class="lineNum">    1307 </span><span class="lineNoCov">          0 :                if (listOfNodesWithoutValidFileInfo.size() &gt; 0)</span></a>
<a name="1308"><span class="lineNum">    1308 </span>            :                   {</a>
<a name="1309"><span class="lineNum">    1309 </span><span class="lineNoCov">          0 :                     listOfNodesWithoutValidFileInfo.sort();</span></a>
<a name="1310"><span class="lineNum">    1310 </span><span class="lineNoCov">          0 :                     listOfNodesWithoutValidFileInfo.unique();</span></a>
<a name="1311"><span class="lineNum">    1311 </span>            : #if 0</a>
<a name="1312"><span class="lineNum">    1312 </span>            :                     list&lt;SgNode*&gt;::iterator i = listOfNodesWithoutValidFileInfo.begin();</a>
<a name="1313"><span class="lineNum">    1313 </span>            : #endif</a>
<a name="1314"><span class="lineNum">    1314 </span><span class="lineNoCov">          0 :                     if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL )</span></a>
<a name="1315"><span class="lineNum">    1315 </span><span class="lineNoCov">          0 :                          printf (&quot;\n     List of %ld IR nodes in the AST with default information in their file info objects: \n&quot;,(long)listOfNodesWithoutValidFileInfo.size());</span></a>
<a name="1316"><span class="lineNum">    1316 </span>            : </a>
<a name="1317"><span class="lineNum">    1317 </span>            :                  // DQ 12/17/2007): Commented these out since there are so many for Fortran right now!</a>
<a name="1318"><span class="lineNum">    1318 </span><span class="lineNoCov">          0 :                     printf (&quot;\n     COMMENTED OUT List of %ld IR nodes in the AST with default information in their file info objects: \n&quot;,(long)listOfNodesWithoutValidFileInfo.size());</span></a>
<a name="1319"><span class="lineNum">    1319 </span>            : #if 0</a>
<a name="1320"><span class="lineNum">    1320 </span>            :                     while (i != listOfNodesWithoutValidFileInfo.end())</a>
<a name="1321"><span class="lineNum">    1321 </span>            :                        {</a>
<a name="1322"><span class="lineNum">    1322 </span>            :                          ROSE_ASSERT((*i)-&gt;get_parent() != NULL);</a>
<a name="1323"><span class="lineNum">    1323 </span>            :                          if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL )</a>
<a name="1324"><span class="lineNum">    1324 </span>            :                               printf (&quot;     IR Nodes with default source position info: %s parent is a %s \n&quot;,</a>
<a name="1325"><span class="lineNum">    1325 </span>            :                                    (*i)-&gt;sage_class_name(),(*i)-&gt;get_parent()-&gt;sage_class_name());</a>
<a name="1326"><span class="lineNum">    1326 </span>            :                       // (*i)-&gt;get_file_info()-&gt;display(&quot;*** default file info ***&quot;);</a>
<a name="1327"><span class="lineNum">    1327 </span>            :                          i++;</a>
<a name="1328"><span class="lineNum">    1328 </span>            :                        }</a>
<a name="1329"><span class="lineNum">    1329 </span>            : #endif</a>
<a name="1330"><span class="lineNum">    1330 </span>            :                   }</a>
<a name="1331"><span class="lineNum">    1331 </span>            : </a>
<a name="1332"><span class="lineNum">    1332 </span>            :             // Report on number of shared Sg_File_Info objects within the AST (should be none)</a>
<a name="1333"><span class="lineNum">    1333 </span><span class="lineNoCov">          0 :                listOfNodesFileInfo.sort();</span></a>
<a name="1334"><span class="lineNum">    1334 </span><span class="lineNoCov">          0 :                int sizeBeforeRemovingRedundantEntries = listOfNodesFileInfo.size();</span></a>
<a name="1335"><span class="lineNum">    1335 </span><span class="lineNoCov">          0 :                listOfNodesFileInfo.unique();</span></a>
<a name="1336"><span class="lineNum">    1336 </span><span class="lineNoCov">          0 :                int sizeAfterRemovingRedundantEntries  = listOfNodesFileInfo.size();</span></a>
<a name="1337"><span class="lineNum">    1337 </span><span class="lineNoCov">          0 :                int redundantEntries = sizeBeforeRemovingRedundantEntries - sizeAfterRemovingRedundantEntries;</span></a>
<a name="1338"><span class="lineNum">    1338 </span><span class="lineNoCov">          0 :                if (redundantEntries != 0)</span></a>
<a name="1339"><span class="lineNum">    1339 </span>            :                   {</a>
<a name="1340"><span class="lineNum">    1340 </span><span class="lineNoCov">          0 :                     if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL )</span></a>
<a name="1341"><span class="lineNum">    1341 </span><span class="lineNoCov">          0 :                          printf (&quot;There are %d IR nodes that share a file info object \n&quot;,redundantEntries);</span></a>
<a name="1342"><span class="lineNum">    1342 </span>            :                   }</a>
<a name="1343"><span class="lineNum">    1343 </span>            :                break;</a>
<a name="1344"><span class="lineNum">    1344 </span>            :              }</a>
<a name="1345"><span class="lineNum">    1345 </span>            : </a>
<a name="1346"><span class="lineNum">    1346 </span><span class="lineCov">    2926070 :           case V_SgInitializedName:</span></a>
<a name="1347"><span class="lineNum">    1347 </span><span class="lineCov">    2926070 :              {</span></a>
<a name="1348"><span class="lineNum">    1348 </span>            :             // DQ (11/28/2004): Verify that newly added explicit scope data members are initialized properly (should be a valid pointer)</a>
<a name="1349"><span class="lineNum">    1349 </span><span class="lineCov">    2926070 :                SgInitializedName* initializedName = isSgInitializedName(node);</span></a>
<a name="1350"><span class="lineNum">    1350 </span><span class="lineCov">    2926070 :                ROSE_ASSERT(initializedName != NULL);</span></a>
<a name="1351"><span class="lineNum">    1351 </span>            :             // printf (&quot;Testing initializedName-&gt;get_scope() \n&quot;);</a>
<a name="1352"><span class="lineNum">    1352 </span>            : </a>
<a name="1353"><span class="lineNum">    1353 </span>            :             // Note that SgInitializedNames in function paremter lists can be NULL if the</a>
<a name="1354"><span class="lineNum">    1354 </span>            :             // function is not a defining declaration (or if no defining declaration exists).</a>
<a name="1355"><span class="lineNum">    1355 </span>            :             // Later work will set the scope to the existing defining declaration's scope (later).</a>
<a name="1356"><span class="lineNum">    1356 </span><span class="lineCov">    2926070 :                SgFunctionParameterList* parentParameterList = isSgFunctionParameterList(initializedName-&gt;get_parent());</span></a>
<a name="1357"><span class="lineNum">    1357 </span><span class="lineCov">    2926070 :                if (parentParameterList != NULL)</span></a>
<a name="1358"><span class="lineNum">    1358 </span>            :                   {</a>
<a name="1359"><span class="lineNum">    1359 </span><span class="lineCov">    2888070 :                     SgFunctionDeclaration* functionDeclaration = isSgFunctionDeclaration(parentParameterList-&gt;get_parent());</span></a>
<a name="1360"><span class="lineNum">    1360 </span>            : </a>
<a name="1361"><span class="lineNum">    1361 </span>            :                  // ROSE_ASSERT(functionDeclaration != NULL);</a>
<a name="1362"><span class="lineNum">    1362 </span><span class="lineCov">    2888070 :                     if (functionDeclaration != NULL)</span></a>
<a name="1363"><span class="lineNum">    1363 </span>            :                        {</a>
<a name="1364"><span class="lineNum">    1364 </span><span class="lineCov">    2888070 :                          bool isFunctionDefinition = (functionDeclaration-&gt;get_definition() != NULL);</span></a>
<a name="1365"><span class="lineNum">    1365 </span>            : </a>
<a name="1366"><span class="lineNum">    1366 </span>            :                       // Only enforce the scope to be valid if this is the defining function declaration</a>
<a name="1367"><span class="lineNum">    1367 </span>            :                       // (later for any function prototype of a defining function declaration!)</a>
<a name="1368"><span class="lineNum">    1368 </span><span class="lineCov">    2888070 :                          if (isFunctionDefinition == true)</span></a>
<a name="1369"><span class="lineNum">    1369 </span>            :                             {</a>
<a name="1370"><span class="lineNum">    1370 </span><span class="lineCov">      20510 :                               ROSE_ASSERT(initializedName-&gt;get_scope() != NULL);</span></a>
<a name="1371"><span class="lineNum">    1371 </span>            :                             }</a>
<a name="1372"><span class="lineNum">    1372 </span>            : </a>
<a name="1373"><span class="lineNum">    1373 </span>            :                       // Cong (10/20/2010): Here we test if the parent of this initialized name does have it as</a>
<a name="1374"><span class="lineNum">    1374 </span>            :                       // an argument. This is to detect if several function parameter lists own the same</a>
<a name="1375"><span class="lineNum">    1375 </span>            :                       // initialized name.</a>
<a name="1376"><span class="lineNum">    1376 </span>            : </a>
<a name="1377"><span class="lineNum">    1377 </span><span class="lineCov">    2888070 :                          const SgInitializedNamePtrList&amp; initNameList = parentParameterList-&gt;get_args();</span></a>
<a name="1378"><span class="lineNum">    1378 </span><span class="lineCov">    2888070 :                          SgInitializedNamePtrList::const_iterator result = std::find(initNameList.begin(), initNameList.end(), initializedName);</span></a>
<a name="1379"><span class="lineNum">    1379 </span><span class="lineCov">    2888070 :                          ROSE_ASSERT(result != initNameList.end());</span></a>
<a name="1380"><span class="lineNum">    1380 </span>            :                        }</a>
<a name="1381"><span class="lineNum">    1381 </span><span class="lineNoCov">          0 :                       else if (isSgTemplateDeclaration(parentParameterList-&gt;get_parent()))</span></a>
<a name="1382"><span class="lineNum">    1382 </span>            :                        {</a>
<a name="1383"><span class="lineNum">    1383 </span>            :                       // DQ (12/6/2011): Now that we have the template declarations in the AST, this could be a SgTemplateDeclaration.</a>
<a name="1384"><span class="lineNum">    1384 </span><span class="lineNoCov">          0 :                          printf (&quot;WARNING: There are tests missing for the case of a parentParameterList-&gt;get_parent() that is a SgTemplateDeclaration \n&quot;);</span></a>
<a name="1385"><span class="lineNum">    1385 </span>            :                        }</a>
<a name="1386"><span class="lineNum">    1386 </span>            :                        else</a>
<a name="1387"><span class="lineNum">    1387 </span>            :                        {</a>
<a name="1388"><span class="lineNum">    1388 </span>            :                          //ROSE_ASSERT(isSgAdaAcceptStmt(parentParameterList-&gt;get_parent()));</a>
<a name="1389"><span class="lineNum">    1389 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(NULL);</span></a>
<a name="1390"><span class="lineNum">    1390 </span>            :                        }</a>
<a name="1391"><span class="lineNum">    1391 </span>            :                   }</a>
<a name="1392"><span class="lineNum">    1392 </span>            :                  else</a>
<a name="1393"><span class="lineNum">    1393 </span>            :                   {</a>
<a name="1394"><span class="lineNum">    1394 </span>            :                  // DQ (2/12/2012): Implement better error diagnostics.</a>
<a name="1395"><span class="lineNum">    1395 </span><span class="lineCov">      37999 :                     if (initializedName-&gt;get_scope() == NULL)</span></a>
<a name="1396"><span class="lineNum">    1396 </span>            :                        {</a>
<a name="1397"><span class="lineNum">    1397 </span><span class="lineNoCov">          0 :                          printf (&quot;Error: initializedName-&gt;get_scope() == NULL \n&quot;);</span></a>
<a name="1398"><span class="lineNum">    1398 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(initializedName-&gt;get_parent() != NULL);</span></a>
<a name="1399"><span class="lineNum">    1399 </span>            : #if 1</a>
<a name="1400"><span class="lineNum">    1400 </span>            :                       // DQ (2/12/2012): Refactoring disagnostic support for detecting where we are when something fails.</a>
<a name="1401"><span class="lineNum">    1401 </span><span class="lineNoCov">          0 :                          SageInterface::whereAmI(initializedName);</span></a>
<a name="1402"><span class="lineNum">    1402 </span>            : #else</a>
<a name="1403"><span class="lineNum">    1403 </span>            :                          SgNode* parent = initializedName-&gt;get_parent();</a>
<a name="1404"><span class="lineNum">    1404 </span>            :                          while (parent != NULL)</a>
<a name="1405"><span class="lineNum">    1405 </span>            :                             {</a>
<a name="1406"><span class="lineNum">    1406 </span>            :                               printf (&quot;parent = %p = %s \n&quot;,parent,parent-&gt;class_name().c_str());</a>
<a name="1407"><span class="lineNum">    1407 </span>            : </a>
<a name="1408"><span class="lineNum">    1408 </span>            :                               ROSE_ASSERT(parent-&gt;get_file_info() != NULL);</a>
<a name="1409"><span class="lineNum">    1409 </span>            :                               parent-&gt;get_file_info()-&gt;display(&quot;Error: initializedName-&gt;get_scope() == NULL&quot;);</a>
<a name="1410"><span class="lineNum">    1410 </span>            : </a>
<a name="1411"><span class="lineNum">    1411 </span>            :                               parent = parent-&gt;get_parent();</a>
<a name="1412"><span class="lineNum">    1412 </span>            :                             }</a>
<a name="1413"><span class="lineNum">    1413 </span>            : #endif</a>
<a name="1414"><span class="lineNum">    1414 </span>            :                        }</a>
<a name="1415"><span class="lineNum">    1415 </span><span class="lineCov">      37999 :                     ROSE_ASSERT(initializedName-&gt;get_scope() != NULL);</span></a>
<a name="1416"><span class="lineNum">    1416 </span>            :                   }</a>
<a name="1417"><span class="lineNum">    1417 </span>            : #if 0</a>
<a name="1418"><span class="lineNum">    1418 </span>            :             // DQ (9/6/2005): This test is to simple: we break out the case of a</a>
<a name="1419"><span class="lineNum">    1419 </span>            :             // SgInitializedName in a parameter list of a function prototype above!</a>
<a name="1420"><span class="lineNum">    1420 </span>            :                if (initializedName-&gt;get_scope() == NULL)</a>
<a name="1421"><span class="lineNum">    1421 </span>            :                   {</a>
<a name="1422"><span class="lineNum">    1422 </span>            :                     printf (&quot;Error: SgInitializedName with explicit scope unset at %p = %s \n&quot;,</a>
<a name="1423"><span class="lineNum">    1423 </span>            :                          initializedName,initializedName-&gt;sage_class_name());</a>
<a name="1424"><span class="lineNum">    1424 </span>            :                     ROSE_ASSERT(initializedName-&gt;get_file_info() != NULL);</a>
<a name="1425"><span class="lineNum">    1425 </span>            :                     initializedName-&gt;get_file_info()-&gt;display(&quot;Error: SgInitializedName with explicit scope unset&quot;);</a>
<a name="1426"><span class="lineNum">    1426 </span>            :                   }</a>
<a name="1427"><span class="lineNum">    1427 </span>            :                ROSE_ASSERT(initializedName-&gt;get_scope() != NULL);</a>
<a name="1428"><span class="lineNum">    1428 </span>            : #endif</a>
<a name="1429"><span class="lineNum">    1429 </span><span class="lineCov">    2926070 :                break;</span></a>
<a name="1430"><span class="lineNum">    1430 </span>            :              }</a>
<a name="1431"><span class="lineNum">    1431 </span>            : </a>
<a name="1432"><span class="lineNum">    1432 </span><span class="lineCov">      13324 :           case V_SgClassDeclaration:</span></a>
<a name="1433"><span class="lineNum">    1433 </span><span class="lineCov">      13324 :           case V_SgDerivedTypeStatement:</span></a>
<a name="1434"><span class="lineNum">    1434 </span><span class="lineCov">      13324 :           case V_SgTemplateInstantiationDecl:</span></a>
<a name="1435"><span class="lineNum">    1435 </span><span class="lineCov">      13324 :              {</span></a>
<a name="1436"><span class="lineNum">    1436 </span>            :             // DQ (11/28/2004): Verify that newly added explicit scope data members are initialized properly (should be a valid pointer)</a>
<a name="1437"><span class="lineNum">    1437 </span><span class="lineCov">      13324 :                SgClassDeclaration* classDeclaration = isSgClassDeclaration(node);</span></a>
<a name="1438"><span class="lineNum">    1438 </span><span class="lineCov">      13324 :                ROSE_ASSERT(classDeclaration != NULL);</span></a>
<a name="1439"><span class="lineNum">    1439 </span><span class="lineCov">      13324 :                if (classDeclaration-&gt;get_scope() == NULL)</span></a>
<a name="1440"><span class="lineNum">    1440 </span>            :                   {</a>
<a name="1441"><span class="lineNum">    1441 </span><span class="lineNoCov">          0 :                     printf (&quot;Error: SgClassDeclaration with explicit scope unset at %p = %s \n&quot;,</span></a>
<a name="1442"><span class="lineNum">    1442 </span><span class="lineNoCov">          0 :                          classDeclaration,classDeclaration-&gt;sage_class_name());</span></a>
<a name="1443"><span class="lineNum">    1443 </span>            :                   }</a>
<a name="1444"><span class="lineNum">    1444 </span><span class="lineCov">      13324 :                ROSE_ASSERT(classDeclaration-&gt;get_scope() != NULL);</span></a>
<a name="1445"><span class="lineNum">    1445 </span><span class="lineCov">      13324 :                break;</span></a>
<a name="1446"><span class="lineNum">    1446 </span>            :              }</a>
<a name="1447"><span class="lineNum">    1447 </span>            : </a>
<a name="1448"><span class="lineNum">    1448 </span><span class="lineCov">    1046260 :           case V_SgFunctionDeclaration:</span></a>
<a name="1449"><span class="lineNum">    1449 </span><span class="lineCov">    1046260 :           case V_SgMemberFunctionDeclaration:</span></a>
<a name="1450"><span class="lineNum">    1450 </span><span class="lineCov">    1046260 :           case V_SgTemplateInstantiationFunctionDecl:</span></a>
<a name="1451"><span class="lineNum">    1451 </span><span class="lineCov">    1046260 :           case V_SgTemplateInstantiationMemberFunctionDecl:</span></a>
<a name="1452"><span class="lineNum">    1452 </span><span class="lineCov">    1046260 :              {</span></a>
<a name="1453"><span class="lineNum">    1453 </span>            :             // DQ (11/28/2004): Verify that newly added explicit scope data members are initialized properly (should be a valid pointer)</a>
<a name="1454"><span class="lineNum">    1454 </span><span class="lineCov">    1046260 :                SgFunctionDeclaration* functionDeclaration = isSgFunctionDeclaration(node);</span></a>
<a name="1455"><span class="lineNum">    1455 </span><span class="lineCov">    1046260 :                ROSE_ASSERT(functionDeclaration != NULL);</span></a>
<a name="1456"><span class="lineNum">    1456 </span><span class="lineCov">    1046260 :                if (functionDeclaration-&gt;get_scope() == NULL)</span></a>
<a name="1457"><span class="lineNum">    1457 </span>            :                   {</a>
<a name="1458"><span class="lineNum">    1458 </span><span class="lineNoCov">          0 :                     printf (&quot;Error: SgFunctionDeclaration with explicit scope unset at %p = %s \n&quot;,</span></a>
<a name="1459"><span class="lineNum">    1459 </span><span class="lineNoCov">          0 :                          functionDeclaration,functionDeclaration-&gt;sage_class_name());</span></a>
<a name="1460"><span class="lineNum">    1460 </span>            :                   }</a>
<a name="1461"><span class="lineNum">    1461 </span><span class="lineCov">    1046260 :                ROSE_ASSERT(functionDeclaration-&gt;get_scope() != NULL);</span></a>
<a name="1462"><span class="lineNum">    1462 </span><span class="lineCov">    1046260 :                break;</span></a>
<a name="1463"><span class="lineNum">    1463 </span>            :              }</a>
<a name="1464"><span class="lineNum">    1464 </span>            : </a>
<a name="1465"><span class="lineNum">    1465 </span><span class="lineNoCov">          0 :           case V_SgTemplateDeclaration:</span></a>
<a name="1466"><span class="lineNum">    1466 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="1467"><span class="lineNum">    1467 </span>            :             // DQ (11/28/2004): Verify that newly added explicit scope data members are initialized properly (should be a valid pointer)</a>
<a name="1468"><span class="lineNum">    1468 </span><span class="lineNoCov">          0 :                SgTemplateDeclaration* templateDeclaration = isSgTemplateDeclaration(node);</span></a>
<a name="1469"><span class="lineNum">    1469 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(templateDeclaration != NULL);</span></a>
<a name="1470"><span class="lineNum">    1470 </span><span class="lineNoCov">          0 :                if (templateDeclaration-&gt;get_scope() == NULL)</span></a>
<a name="1471"><span class="lineNum">    1471 </span>            :                   {</a>
<a name="1472"><span class="lineNum">    1472 </span><span class="lineNoCov">          0 :                     printf (&quot;Error: SgTemplateDeclaration with explicit scope unset at %p = %s \n&quot;,</span></a>
<a name="1473"><span class="lineNum">    1473 </span><span class="lineNoCov">          0 :                          templateDeclaration,templateDeclaration-&gt;sage_class_name());</span></a>
<a name="1474"><span class="lineNum">    1474 </span>            :                   }</a>
<a name="1475"><span class="lineNum">    1475 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(templateDeclaration-&gt;get_scope() != NULL);</span></a>
<a name="1476"><span class="lineNum">    1476 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="1477"><span class="lineNum">    1477 </span>            :              }</a>
<a name="1478"><span class="lineNum">    1478 </span>            : </a>
<a name="1479"><span class="lineNum">    1479 </span><span class="lineCov">      49257 :           case V_SgTypedefDeclaration:</span></a>
<a name="1480"><span class="lineNum">    1480 </span><span class="lineCov">      49257 :              {</span></a>
<a name="1481"><span class="lineNum">    1481 </span>            :             // DQ (11/28/2004): Verify that newly added explicit scope data members are initialized properly (should be a valid pointer)</a>
<a name="1482"><span class="lineNum">    1482 </span><span class="lineCov">      49257 :                SgTypedefDeclaration* typedefDeclaration = isSgTypedefDeclaration(node);</span></a>
<a name="1483"><span class="lineNum">    1483 </span><span class="lineCov">      49257 :                ROSE_ASSERT(typedefDeclaration != NULL);</span></a>
<a name="1484"><span class="lineNum">    1484 </span><span class="lineCov">      49257 :                if (typedefDeclaration-&gt;get_scope() == NULL)</span></a>
<a name="1485"><span class="lineNum">    1485 </span>            :                   {</a>
<a name="1486"><span class="lineNum">    1486 </span><span class="lineNoCov">          0 :                     printf (&quot;Error: SgTypedefDeclaration with explicit scope unset at %p = %s \n&quot;,</span></a>
<a name="1487"><span class="lineNum">    1487 </span><span class="lineNoCov">          0 :                          typedefDeclaration,typedefDeclaration-&gt;sage_class_name());</span></a>
<a name="1488"><span class="lineNum">    1488 </span>            :                   }</a>
<a name="1489"><span class="lineNum">    1489 </span><span class="lineCov">      49257 :                ROSE_ASSERT(typedefDeclaration-&gt;get_scope() != NULL);</span></a>
<a name="1490"><span class="lineNum">    1490 </span><span class="lineCov">      49257 :                break;</span></a>
<a name="1491"><span class="lineNum">    1491 </span>            :              }</a>
<a name="1492"><span class="lineNum">    1492 </span>            : </a>
<a name="1493"><span class="lineNum">    1493 </span><span class="lineCov">      11725 :           case V_SgFunctionDefinition:</span></a>
<a name="1494"><span class="lineNum">    1494 </span><span class="lineCov">      11725 :              {</span></a>
<a name="1495"><span class="lineNum">    1495 </span>            :             // DQ (8/9/2005): Test for existence of body in function definition</a>
<a name="1496"><span class="lineNum">    1496 </span><span class="lineCov">      11725 :                SgFunctionDefinition* functionDefinition = isSgFunctionDefinition(node);</span></a>
<a name="1497"><span class="lineNum">    1497 </span><span class="lineCov">      11725 :                if (functionDefinition-&gt;get_body() == NULL)</span></a>
<a name="1498"><span class="lineNum">    1498 </span>            :                   {</a>
<a name="1499"><span class="lineNum">    1499 </span><span class="lineNoCov">          0 :                     printf (&quot;AST Consistency Test: This function definition violates the rule that every function definition has a function body (even if it is empty) \n&quot;);</span></a>
<a name="1500"><span class="lineNum">    1500 </span><span class="lineNoCov">          0 :                     functionDefinition-&gt;get_file_info()-&gt;display(&quot;debug&quot;);</span></a>
<a name="1501"><span class="lineNum">    1501 </span>            :                   }</a>
<a name="1502"><span class="lineNum">    1502 </span><span class="lineCov">      11725 :                ROSE_ASSERT(functionDefinition-&gt;get_body() != NULL);</span></a>
<a name="1503"><span class="lineNum">    1503 </span>            : </a>
<a name="1504"><span class="lineNum">    1504 </span>            :             // DQ (3/16/2006): Verify that this is true, it should always be true (for Yarden)</a>
<a name="1505"><span class="lineNum">    1505 </span><span class="lineCov">      11725 :                if (functionDefinition-&gt;get_body()-&gt;get_parent() != functionDefinition)</span></a>
<a name="1506"><span class="lineNum">    1506 </span>            :                   {</a>
<a name="1507"><span class="lineNum">    1507 </span><span class="lineNoCov">          0 :                     printf (&quot;Error: functionDefinition = %p functionDefinition-&gt;get_body() = %p functionDefinition-&gt;get_body()-&gt;get_parent() = %p \n&quot;,functionDefinition,functionDefinition-&gt;get_body(),functionDefinition-&gt;get_body()-&gt;get_parent());</span></a>
<a name="1508"><span class="lineNum">    1508 </span>            :                   }</a>
<a name="1509"><span class="lineNum">    1509 </span><span class="lineCov">      11725 :                ROSE_ASSERT(functionDefinition-&gt;get_body()-&gt;get_parent() == functionDefinition);</span></a>
<a name="1510"><span class="lineNum">    1510 </span><span class="lineCov">      11725 :                break;</span></a>
<a name="1511"><span class="lineNum">    1511 </span>            :              }</a>
<a name="1512"><span class="lineNum">    1512 </span>            : </a>
<a name="1513"><span class="lineNum">    1513 </span>            :        // DQ (8/25/2004): Default should be used to avoid compiler warning about not</a>
<a name="1514"><span class="lineNum">    1514 </span>            :        // handling all the cases of the enum VariantT.</a>
<a name="1515"><span class="lineNum">    1515 </span><span class="lineCov">    5466810 :           default:</span></a>
<a name="1516"><span class="lineNum">    1516 </span><span class="lineCov">    5466810 :              {</span></a>
<a name="1517"><span class="lineNum">    1517 </span>            :             // g++ needs an empty block here</a>
<a name="1518"><span class="lineNum">    1518 </span>            :              }</a>
<a name="1519"><span class="lineNum">    1519 </span>            :         }</a>
<a name="1520"><span class="lineNum">    1520 </span>            : #endif</a>
<a name="1521"><span class="lineNum">    1521 </span>            : </a>
<a name="1522"><span class="lineNum">    1522 </span><span class="lineCov">    5466810 :      return syn;</span></a>
<a name="1523"><span class="lineNum">    1523 </span>            :    }</a>
<a name="1524"><span class="lineNum">    1524 </span>            : </a>
<a name="1525"><span class="lineNum">    1525 </span>            : void</a>
<a name="1526"><span class="lineNum">    1526 </span><span class="lineNoCov">          0 : TestAstNullPointers::visitWithAstNodePointersList(SgNode* node, AstNodePointersList l)</span></a>
<a name="1527"><span class="lineNum">    1527 </span>            :    {</a>
<a name="1528"><span class="lineNum">    1528 </span><span class="lineNoCov">          0 :      vector&lt;SgNode*&gt; tsc = node-&gt;get_traversalSuccessorContainer();</span></a>
<a name="1529"><span class="lineNum">    1529 </span><span class="lineNoCov">          0 :      for (unsigned i=0; i &lt; l.size(); i++)</span></a>
<a name="1530"><span class="lineNum">    1530 </span>            :         {</a>
<a name="1531"><span class="lineNum">    1531 </span><span class="lineNoCov">          0 :           if (l[i] != tsc[i])</span></a>
<a name="1532"><span class="lineNum">    1532 </span>            :              {</a>
<a name="1533"><span class="lineNum">    1533 </span><span class="lineNoCov">          0 :                cout &lt;&lt; &quot;AST TRAVERSAL ERROR: &quot; &lt;&lt; node-&gt;sage_class_name() &lt;&lt; &quot;: WE WOULD REVISIT NODES FROM THIS NODE. MEMBER:&quot; &lt;&lt; i &lt;&lt; &quot;.&quot; &lt;&lt; endl;</span></a>
<a name="1534"><span class="lineNum">    1534 </span>            :              }</a>
<a name="1535"><span class="lineNum">    1535 </span>            :         }</a>
<a name="1536"><span class="lineNum">    1536 </span><span class="lineNoCov">          0 :    }</span></a>
<a name="1537"><span class="lineNum">    1537 </span>            : </a>
<a name="1538"><span class="lineNum">    1538 </span>            : </a>
<a name="1539"><span class="lineNum">    1539 </span>            : /*! \page AstProperties AST Properties (Consistency Tests)</a>
<a name="1540"><span class="lineNum">    1540 </span>            : </a>
<a name="1541"><span class="lineNum">    1541 </span>            : \section section5 Template Properties</a>
<a name="1542"><span class="lineNum">    1542 </span>            : </a>
<a name="1543"><span class="lineNum">    1543 </span>            :     Template within SAGE III are tested to verify specific properties:</a>
<a name="1544"><span class="lineNum">    1544 </span>            :      - SgTemplateInstantiationDecl</a>
<a name="1545"><span class="lineNum">    1545 </span>            :         -# get_name() returns a valid C++ string object</a>
<a name="1546"><span class="lineNum">    1546 </span>            :         -# get_templateName() returns a valid C++ string object</a>
<a name="1547"><span class="lineNum">    1547 </span>            :         -# get_templateDeclaration() returns a valid pointer</a>
<a name="1548"><span class="lineNum">    1548 </span>            :         -# All template declarations within template instantiations are never marked as compiler generated.</a>
<a name="1549"><span class="lineNum">    1549 </span>            :      - SgTemplateInstantiationFunctionDecl</a>
<a name="1550"><span class="lineNum">    1550 </span>            :         -# get_name() returns a valid C++ string object</a>
<a name="1551"><span class="lineNum">    1551 </span>            :         -# get_templateName() can have an empty string \n</a>
<a name="1552"><span class="lineNum">    1552 </span>            :            This should be fixed at some point.</a>
<a name="1553"><span class="lineNum">    1553 </span>            :         -# get_templateDeclaration() returns a valid pointer</a>
<a name="1554"><span class="lineNum">    1554 </span>            :         -# All template declarations within template instantiations are never marked as compiler generated.</a>
<a name="1555"><span class="lineNum">    1555 </span>            :      - SgTemplateInstantiationMemberFunctionDecl</a>
<a name="1556"><span class="lineNum">    1556 </span>            :         -# get_name() returns a valid C++ string object</a>
<a name="1557"><span class="lineNum">    1557 </span>            :         -# get_templateName() can have an empty string \n</a>
<a name="1558"><span class="lineNum">    1558 </span>            :            This should be fixed at some point.</a>
<a name="1559"><span class="lineNum">    1559 </span>            :         -# get_templateDeclaration() returns a valid pointer</a>
<a name="1560"><span class="lineNum">    1560 </span>            :         -# Template declarations within template instantiations can be compiler generated. \n</a>
<a name="1561"><span class="lineNum">    1561 </span>            :            Member functions of templated classes that are declared in the class are represented</a>
<a name="1562"><span class="lineNum">    1562 </span>            :            outside the class as template specializations and are marked as compiler generated.</a>
<a name="1563"><span class="lineNum">    1563 </span>            :      - SgClassDefinition</a>
<a name="1564"><span class="lineNum">    1564 </span>            :      - SgTemplateInstantiationDefn \n</a>
<a name="1565"><span class="lineNum">    1565 </span>            :          Base classes within class definitions and template instatiation definitions are searched</a>
<a name="1566"><span class="lineNum">    1566 </span>            :          and verified to have properly reset template names (from original EDG names, see</a>
<a name="1567"><span class="lineNum">    1567 </span>            :          \ref resetTemplateNameTest ).</a>
<a name="1568"><span class="lineNum">    1568 </span>            :      - All possible template instantiations \n</a>
<a name="1569"><span class="lineNum">    1569 </span>            :         -# These are tested to verify that get_specialization() returns a non-default value to verify that</a>
<a name="1570"><span class="lineNum">    1570 </span>            :            some catagory of template specialization has been specified (values verified to have been reset</a>
<a name="1571"><span class="lineNum">    1571 </span>            :            from the defaults).</a>
<a name="1572"><span class="lineNum">    1572 </span>            :         -# contain a valid pointer to a template declaration.</a>
<a name="1573"><span class="lineNum">    1573 </span>            :      - All non-template instantiations</a>
<a name="1574"><span class="lineNum">    1574 </span>            :         -# Are maked with default value SgClassDeclaration::e_no_specialization.</a>
<a name="1575"><span class="lineNum">    1575 </span>            : </a>
<a name="1576"><span class="lineNum">    1576 </span>            : */</a>
<a name="1577"><span class="lineNum">    1577 </span>            : </a>
<a name="1578"><span class="lineNum">    1578 </span>            : </a>
<a name="1579"><span class="lineNum">    1579 </span>            : void</a>
<a name="1580"><span class="lineNum">    1580 </span><span class="lineCov">    5466810 : TestAstTemplateProperties::visit ( SgNode* astNode )</span></a>
<a name="1581"><span class="lineNum">    1581 </span>            :    {</a>
<a name="1582"><span class="lineNum">    1582 </span>            :   // DQ (3/31/2004): Added to support templates</a>
<a name="1583"><span class="lineNum">    1583 </span>            :   // This function tests properties on the new template specific IR nodes</a>
<a name="1584"><span class="lineNum">    1584 </span>            : </a>
<a name="1585"><span class="lineNum">    1585 </span>            :   // printf (&quot;astNode = %s \n&quot;,astNode-&gt;sage_class_name());</a>
<a name="1586"><span class="lineNum">    1586 </span>            : </a>
<a name="1587"><span class="lineNum">    1587 </span>            : #if 0</a>
<a name="1588"><span class="lineNum">    1588 </span>            :      SgNode * parent = astNode-&gt;get_parent();</a>
<a name="1589"><span class="lineNum">    1589 </span>            :      printf (&quot;In TestAstTemplateProperties::visit():\n&quot;);</a>
<a name="1590"><span class="lineNum">    1590 </span>            :      printf (&quot;  --- astNode = %p (%s)\n&quot;, astNode, astNode ? astNode-&gt;class_name().c_str() : &quot;&quot;);</a>
<a name="1591"><span class="lineNum">    1591 </span>            :      printf (&quot;  --- parent = %p (%s)\n&quot;, parent, parent ? parent-&gt;class_name().c_str() : &quot;&quot;);</a>
<a name="1592"><span class="lineNum">    1592 </span>            : #endif</a>
<a name="1593"><span class="lineNum">    1593 </span>            : </a>
<a name="1594"><span class="lineNum">    1594 </span><span class="lineCov">    5466810 :      switch(astNode-&gt;variantT())</span></a>
<a name="1595"><span class="lineNum">    1595 </span>            :         {</a>
<a name="1596"><span class="lineNum">    1596 </span><span class="lineCov">       5837 :           case V_SgTemplateInstantiationDecl:</span></a>
<a name="1597"><span class="lineNum">    1597 </span><span class="lineCov">       5837 :              {</span></a>
<a name="1598"><span class="lineNum">    1598 </span><span class="lineCov">       5837 :                SgTemplateInstantiationDecl* s = isSgTemplateInstantiationDecl(astNode);</span></a>
<a name="1599"><span class="lineNum">    1599 </span><span class="lineCov">       5837 :                ROSE_ASSERT(s != NULL);</span></a>
<a name="1600"><span class="lineNum">    1600 </span>            : #if 0</a>
<a name="1601"><span class="lineNum">    1601 </span>            :                printf (&quot;  --- name = %s\n&quot;, s-&gt;get_name().str());</a>
<a name="1602"><span class="lineNum">    1602 </span>            : #endif</a>
<a name="1603"><span class="lineNum">    1603 </span>            : </a>
<a name="1604"><span class="lineNum">    1604 </span><span class="lineCov">       5837 :                SgDeclarationStatement* templateDeclaration = s-&gt;get_templateDeclaration();</span></a>
<a name="1605"><span class="lineNum">    1605 </span><span class="lineCov">       5837 :                if (templateDeclaration-&gt;get_definingDeclaration()) {</span></a>
<a name="1606"><span class="lineNum">    1606 </span><span class="lineCov">       5610 :                  templateDeclaration = templateDeclaration-&gt;get_definingDeclaration();</span></a>
<a name="1607"><span class="lineNum">    1607 </span>            :                }</a>
<a name="1608"><span class="lineNum">    1608 </span>            : #if 0</a>
<a name="1609"><span class="lineNum">    1609 </span>            :                printf (&quot;  --- templateDeclaration = %p (%s)\n&quot;, templateDeclaration, templateDeclaration ? templateDeclaration-&gt;class_name().c_str() : &quot;&quot;);</a>
<a name="1610"><span class="lineNum">    1610 </span>            : #endif</a>
<a name="1611"><span class="lineNum">    1611 </span>            : </a>
<a name="1612"><span class="lineNum">    1612 </span>            :             // DQ (8/12/2005): There are non-trivial cases where a template declaration can be compiler generated (e.g. when it is a nested class)</a>
<a name="1613"><span class="lineNum">    1613 </span><span class="lineCov">       5837 :                bool couldBeCompilerGenerated = MarkAsCompilerGenerated::templateDeclarationCanBeMarkedAsCompilerGenerated(templateDeclaration);</span></a>
<a name="1614"><span class="lineNum">    1614 </span>            : </a>
<a name="1615"><span class="lineNum">    1615 </span><span class="lineCov">       5837 :                if (couldBeCompilerGenerated == false)</span></a>
<a name="1616"><span class="lineNum">    1616 </span>            :                   {</a>
<a name="1617"><span class="lineNum">    1617 </span>            :                  // DQ (6/17/2005): Template declarations should not be marked as comiler generated</a>
<a name="1618"><span class="lineNum">    1618 </span>            :                  // (only the instantiations are possibly marked as compiler generated).</a>
<a name="1619"><span class="lineNum">    1619 </span><span class="lineCov">       5638 :                     if (templateDeclaration-&gt;get_file_info()-&gt;isCompilerGenerated() == true)</span></a>
<a name="1620"><span class="lineNum">    1620 </span>            :                        {</a>
<a name="1621"><span class="lineNum">    1621 </span><span class="lineNoCov">          0 :                          printf (&quot;Error: SgTemplateInstantiationDecl's original template declaration should not be compiler generated \n&quot;);</span></a>
<a name="1622"><span class="lineNum">    1622 </span><span class="lineNoCov">          0 :                          templateDeclaration-&gt;get_file_info()-&gt;display(&quot;debug&quot;);</span></a>
<a name="1623"><span class="lineNum">    1623 </span>            :                        }</a>
<a name="1624"><span class="lineNum">    1624 </span><span class="lineCov">       5638 :                     ROSE_ASSERT (templateDeclaration-&gt;get_file_info()-&gt;isCompilerGenerated() == false);</span></a>
<a name="1625"><span class="lineNum">    1625 </span>            :                   }</a>
<a name="1626"><span class="lineNum">    1626 </span>            :                break;</a>
<a name="1627"><span class="lineNum">    1627 </span>            :              }</a>
<a name="1628"><span class="lineNum">    1628 </span>            : </a>
<a name="1629"><span class="lineNum">    1629 </span><span class="lineCov">       1472 :           case V_SgTemplateInstantiationFunctionDecl:</span></a>
<a name="1630"><span class="lineNum">    1630 </span><span class="lineCov">       1472 :              {</span></a>
<a name="1631"><span class="lineNum">    1631 </span><span class="lineCov">       1472 :                SgTemplateInstantiationFunctionDecl* s = isSgTemplateInstantiationFunctionDecl(astNode);</span></a>
<a name="1632"><span class="lineNum">    1632 </span>            :             // DQ (5/8/2004): templateName() removed</a>
<a name="1633"><span class="lineNum">    1633 </span>            :             // ROSE_ASSERT (s-&gt;get_templateName().str() != NULL);</a>
<a name="1634"><span class="lineNum">    1634 </span>            : </a>
<a name="1635"><span class="lineNum">    1635 </span>            :             // DQ (4/30/2012): Allow this test to pass for test2012_58.C (condition relaxed as part of new EDG support).</a>
<a name="1636"><span class="lineNum">    1636 </span>            :             // It might be that the function template does not exist but that the class template containing the function template is available.</a>
<a name="1637"><span class="lineNum">    1637 </span><span class="lineCov">       1472 :                if (s-&gt;get_templateDeclaration() == NULL)</span></a>
<a name="1638"><span class="lineNum">    1638 </span>            :                   {</a>
<a name="1639"><span class="lineNum">    1639 </span>            : #ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION</a>
<a name="1640"><span class="lineNum">    1640 </span>            :                     printf (&quot;ERROR: s-&gt;get_templateDeclaration() == NULL (s = %p = SgTemplateInstantiationFunctionDecl) \n&quot;,s);</a>
<a name="1641"><span class="lineNum">    1641 </span>            : #endif</a>
<a name="1642"><span class="lineNum">    1642 </span>            :                   }</a>
<a name="1643"><span class="lineNum">    1643 </span>            :              // ROSE_ASSERT (s-&gt;get_templateDeclaration() != NULL);</a>
<a name="1644"><span class="lineNum">    1644 </span>            : </a>
<a name="1645"><span class="lineNum">    1645 </span><span class="lineCov">       1472 :                if (s-&gt;get_templateDeclaration() != NULL)</span></a>
<a name="1646"><span class="lineNum">    1646 </span>            :                   {</a>
<a name="1647"><span class="lineNum">    1647 </span>            :                  // DQ (6/17/2005): Template declarations should not be marked as compiler generated</a>
<a name="1648"><span class="lineNum">    1648 </span>            :                  // (only the instantiations are possibly marked as compiler generated).</a>
<a name="1649"><span class="lineNum">    1649 </span><span class="lineCov">       1472 :                     if (s-&gt;get_templateDeclaration()-&gt;get_file_info()-&gt;isCompilerGenerated() == true &amp;&amp; SgProject::get_verbose() &gt; 0)</span></a>
<a name="1650"><span class="lineNum">    1650 </span>            :                        {</a>
<a name="1651"><span class="lineNum">    1651 </span>            : #ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION</a>
<a name="1652"><span class="lineNum">    1652 </span>            :                          printf (&quot;Warning: SgTemplateInstantiationFunctionDecl's original template declaration %s is marked as compiler generated: \n&quot;, s-&gt;get_templateDeclaration()-&gt;get_qualified_name().str());</a>
<a name="1653"><span class="lineNum">    1653 </span>            :                          s-&gt;get_startOfConstruct()-&gt;display(&quot;SgTemplateInstantiationFunctionDecl debug&quot;);</a>
<a name="1654"><span class="lineNum">    1654 </span>            :                          s-&gt;get_templateDeclaration()-&gt;get_startOfConstruct()-&gt;display(&quot;SgTemplateDecl debug&quot;);</a>
<a name="1655"><span class="lineNum">    1655 </span>            : #endif</a>
<a name="1656"><span class="lineNum">    1656 </span>            :                        }</a>
<a name="1657"><span class="lineNum">    1657 </span>            :                  // ROSE_ASSERT (s-&gt;get_templateDeclaration()-&gt;get_file_info()-&gt;isCompilerGenerated() == false);</a>
<a name="1658"><span class="lineNum">    1658 </span>            :                   }</a>
<a name="1659"><span class="lineNum">    1659 </span>            :                break;</a>
<a name="1660"><span class="lineNum">    1660 </span>            :              }</a>
<a name="1661"><span class="lineNum">    1661 </span>            : </a>
<a name="1662"><span class="lineNum">    1662 </span><span class="lineCov">      10308 :           case V_SgTemplateInstantiationMemberFunctionDecl:</span></a>
<a name="1663"><span class="lineNum">    1663 </span><span class="lineCov">      10308 :              {</span></a>
<a name="1664"><span class="lineNum">    1664 </span><span class="lineCov">      10308 :                SgTemplateInstantiationMemberFunctionDecl* s = isSgTemplateInstantiationMemberFunctionDecl(astNode);</span></a>
<a name="1665"><span class="lineNum">    1665 </span>            :             // DQ (5/8/2004): templateName() removed</a>
<a name="1666"><span class="lineNum">    1666 </span>            :             // ROSE_ASSERT (s-&gt;get_templateName().str() != NULL);</a>
<a name="1667"><span class="lineNum">    1667 </span>            : </a>
<a name="1668"><span class="lineNum">    1668 </span>            :             // DQ (5/3/2012): Allow this for now, but make it a warning.</a>
<a name="1669"><span class="lineNum">    1669 </span><span class="lineCov">      10308 :                if (s-&gt;get_templateDeclaration() == NULL)</span></a>
<a name="1670"><span class="lineNum">    1670 </span>            :                   {</a>
<a name="1671"><span class="lineNum">    1671 </span>            : // #ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION</a>
<a name="1672"><span class="lineNum">    1672 </span>            : #if 0</a>
<a name="1673"><span class="lineNum">    1673 </span>            :                     printf (&quot;WARNING: case V_SgTemplateInstantiationMemberFunctionDecl: templateDeclaration == NULL (some templates are unavailable in EDG). \n&quot;);</a>
<a name="1674"><span class="lineNum">    1674 </span>            : #endif</a>
<a name="1675"><span class="lineNum">    1675 </span>            :                   }</a>
<a name="1676"><span class="lineNum">    1676 </span>            :             // ROSE_ASSERT (s-&gt;get_templateDeclaration() != NULL);</a>
<a name="1677"><span class="lineNum">    1677 </span>            : </a>
<a name="1678"><span class="lineNum">    1678 </span>            :             // explicit specializations in the source code should not be marked as compiler generated</a>
<a name="1679"><span class="lineNum">    1679 </span><span class="lineCov">      10308 :                if (s-&gt;isSpecialization() == true || s-&gt;isPartialSpecialization() == true)</span></a>
<a name="1680"><span class="lineNum">    1680 </span>            :                   {</a>
<a name="1681"><span class="lineNum">    1681 </span><span class="lineCov">         84 :                     if (s-&gt;get_file_info()-&gt;isCompilerGenerated() == true)</span></a>
<a name="1682"><span class="lineNum">    1682 </span>            :                        {</a>
<a name="1683"><span class="lineNum">    1683 </span><span class="lineNoCov">          0 :                          printf (&quot;SgTemplateInstantiationMemberFunctionDecl (%p) is marked as a specialization and compiler generated (not allowed) \n&quot;,s);</span></a>
<a name="1684"><span class="lineNum">    1684 </span><span class="lineNoCov">          0 :                          s-&gt;get_file_info()-&gt;display(&quot;SgTemplateInstantiationMemberFunctionDecl: debug&quot;);</span></a>
<a name="1685"><span class="lineNum">    1685 </span><span class="lineNoCov">          0 :                          printf (&quot;s-&gt;get_name() = %s \n&quot;,s-&gt;get_name().str());</span></a>
<a name="1686"><span class="lineNum">    1686 </span>            :                        }</a>
<a name="1687"><span class="lineNum">    1687 </span><span class="lineCov">         84 :                     ROSE_ASSERT(s-&gt;get_file_info()-&gt;isCompilerGenerated() == false);</span></a>
<a name="1688"><span class="lineNum">    1688 </span>            :                   }</a>
<a name="1689"><span class="lineNum">    1689 </span>            : </a>
<a name="1690"><span class="lineNum">    1690 </span>            : #if 0</a>
<a name="1691"><span class="lineNum">    1691 </span>            :             // DQ (6/20/2005): This is actually OK, since the template declaration is in the</a>
<a name="1692"><span class="lineNum">    1692 </span>            :             // outer classes template specialization!</a>
<a name="1693"><span class="lineNum">    1693 </span>            :             // DQ (6/17/2005): Template declarations should not be marked as comiler generated</a>
<a name="1694"><span class="lineNum">    1694 </span>            :             // (only the instatiations are posibily marked as compiler generated).</a>
<a name="1695"><span class="lineNum">    1695 </span>            :                if (s-&gt;get_templateDeclaration()-&gt;get_file_info()-&gt;isCompilerGenerated() == true)</a>
<a name="1696"><span class="lineNum">    1696 </span>            :                   {</a>
<a name="1697"><span class="lineNum">    1697 </span>            :                     s-&gt;get_templateDeclaration()-&gt;get_file_info()-&gt;display(&quot;debug&quot;);</a>
<a name="1698"><span class="lineNum">    1698 </span>            :                     printf (&quot;s-&gt;get_templateDeclaration()-&gt;get_name() = %s string = %s \n&quot;,</a>
<a name="1699"><span class="lineNum">    1699 </span>            :                          s-&gt;get_templateDeclaration()-&gt;get_name().str(),</a>
<a name="1700"><span class="lineNum">    1700 </span>            :                          s-&gt;get_templateDeclaration()-&gt;get_string().str());</a>
<a name="1701"><span class="lineNum">    1701 </span>            :                   }</a>
<a name="1702"><span class="lineNum">    1702 </span>            :             // ROSE_ASSERT (s-&gt;get_templateDeclaration()-&gt;get_file_info()-&gt;isCompilerGenerated() == false);</a>
<a name="1703"><span class="lineNum">    1703 </span>            : #endif</a>
<a name="1704"><span class="lineNum">    1704 </span>            :                break;</a>
<a name="1705"><span class="lineNum">    1705 </span>            :              }</a>
<a name="1706"><span class="lineNum">    1706 </span>            : </a>
<a name="1707"><span class="lineNum">    1707 </span><span class="lineCov">      10149 :           case V_SgClassDefinition:</span></a>
<a name="1708"><span class="lineNum">    1708 </span><span class="lineCov">      10149 :           case V_SgTemplateInstantiationDefn:</span></a>
<a name="1709"><span class="lineNum">    1709 </span><span class="lineCov">      10149 :              {</span></a>
<a name="1710"><span class="lineNum">    1710 </span>            :             // DQ (6/22/2005): templated class declarations can be hidden in base class specifications</a>
<a name="1711"><span class="lineNum">    1711 </span><span class="lineCov">      10149 :                SgClassDefinition* classDefinition = isSgClassDefinition(astNode);</span></a>
<a name="1712"><span class="lineNum">    1712 </span><span class="lineCov">      10149 :                ROSE_ASSERT(classDefinition != NULL);</span></a>
<a name="1713"><span class="lineNum">    1713 </span>            : </a>
<a name="1714"><span class="lineNum">    1714 </span><span class="lineCov">      10149 :                SgBaseClassPtrList::iterator i = classDefinition-&gt;get_inheritances().begin();</span></a>
<a name="1715"><span class="lineNum">    1715 </span><span class="lineCov">      12014 :                for ( ; i != classDefinition-&gt;get_inheritances().end(); ++i)</span></a>
<a name="1716"><span class="lineNum">    1716 </span>            :                   {</a>
<a name="1717"><span class="lineNum">    1717 </span>            :                  // Check the parent pointer to make sure it is properly set</a>
<a name="1718"><span class="lineNum">    1718 </span><span class="lineCov">       1865 :                     ROSE_ASSERT( (*i)-&gt;get_parent() != NULL);</span></a>
<a name="1719"><span class="lineNum">    1719 </span><span class="lineCov">       1865 :                     ROSE_ASSERT( (*i)-&gt;get_parent() == classDefinition);</span></a>
<a name="1720"><span class="lineNum">    1720 </span>            : </a>
<a name="1721"><span class="lineNum">    1721 </span>            :                  // skip this check for SgExpBaseClasses, which don't need to define p_base_class</a>
<a name="1722"><span class="lineNum">    1722 </span><span class="lineCov">       1865 :                     if (isSgExpBaseClass(*i) != NULL)</span></a>
<a name="1723"><span class="lineNum">    1723 </span><span class="lineNoCov">          0 :                          continue;</span></a>
<a name="1724"><span class="lineNum">    1724 </span>            : </a>
<a name="1725"><span class="lineNum">    1725 </span>            :                  // Calling resetTemplateName()</a>
<a name="1726"><span class="lineNum">    1726 </span><span class="lineCov">       1865 :                     SgClassDeclaration* baseClassDeclaration = (*i)-&gt;get_base_class();</span></a>
<a name="1727"><span class="lineNum">    1727 </span><span class="lineCov">       1865 :                     ROSE_ASSERT(baseClassDeclaration != NULL);</span></a>
<a name="1728"><span class="lineNum">    1728 </span>            :                  // printf (&quot;In AST Consistancy test: baseClassDeclaration-&gt;get_name() = %s \n&quot;,baseClassDeclaration-&gt;get_name().str());</a>
<a name="1729"><span class="lineNum">    1729 </span><span class="lineCov">       1865 :                     SgTemplateInstantiationDecl* templateInstantiation = isSgTemplateInstantiationDecl(baseClassDeclaration);</span></a>
<a name="1730"><span class="lineNum">    1730 </span><span class="lineCov">       1865 :                     if (templateInstantiation != NULL)</span></a>
<a name="1731"><span class="lineNum">    1731 </span>            :                        {</a>
<a name="1732"><span class="lineNum">    1732 </span>            :                       // DQ (2/12/2012): Implemented some diagnostics (fails for test2004_35.C).</a>
<a name="1733"><span class="lineNum">    1733 </span><span class="lineCov">       1629 :                          if (templateInstantiation-&gt;get_nameResetFromMangledForm() == false)</span></a>
<a name="1734"><span class="lineNum">    1734 </span>            :                             {</a>
<a name="1735"><span class="lineNum">    1735 </span><span class="lineNoCov">          0 :                               printf (&quot;In AST Consistancy test: templateInstantiation = %p = %s \n&quot;,templateInstantiation,templateInstantiation-&gt;class_name().c_str());</span></a>
<a name="1736"><span class="lineNum">    1736 </span><span class="lineNoCov">          0 :                               printf (&quot;In AST Consistancy test: templateInstantiation-&gt;get_templateName() = %s \n&quot;,templateInstantiation-&gt;get_templateName().str());</span></a>
<a name="1737"><span class="lineNum">    1737 </span><span class="lineNoCov">          0 :                               printf (&quot;In AST Consistancy test: templateInstantiation-&gt;get_name()         = %s \n&quot;,templateInstantiation-&gt;get_name().str());</span></a>
<a name="1738"><span class="lineNum">    1738 </span>            :                            // SageInterface::whereAmI(templateInstantiation);</a>
<a name="1739"><span class="lineNum">    1739 </span>            : </a>
<a name="1740"><span class="lineNum">    1740 </span>            :                            // DQ (7/14/2019): Reset the name to see how it would be changed (for debugging)</a>
<a name="1741"><span class="lineNum">    1741 </span>            :                            // The fix was to force the new file built in SageBuilder::buildFile() to call the astPostProcessing()</a>
<a name="1742"><span class="lineNum">    1742 </span>            :                            // function which will internally reset the template names.</a>
<a name="1743"><span class="lineNum">    1743 </span>            : </a>
<a name="1744"><span class="lineNum">    1744 </span>            :                            // This function will reset nameResetFromMangledForm to true, so we want to force the failure below.</a>
<a name="1745"><span class="lineNum">    1745 </span>            :                            // templateInstantiation-&gt;resetTemplateName();</a>
<a name="1746"><span class="lineNum">    1746 </span>            : </a>
<a name="1747"><span class="lineNum">    1747 </span>            :                            // Re-output the template name.</a>
<a name="1748"><span class="lineNum">    1748 </span>            :                            // printf (&quot;In AST Consistancy test: (after resetTemplateName()): templateInstantiation-&gt;get_templateName() = %s \n&quot;,templateInstantiation-&gt;get_templateName().str());</a>
<a name="1749"><span class="lineNum">    1749 </span>            :                            // printf (&quot;In AST Consistancy test: (after resetTemplateName()): templateInstantiation-&gt;get_name()         = %s \n&quot;,templateInstantiation-&gt;get_name().str());</a>
<a name="1750"><span class="lineNum">    1750 </span>            : #if 0</a>
<a name="1751"><span class="lineNum">    1751 </span>            :                            // Force this to fail since the function call above we set nameResetFromMangledForm to true.</a>
<a name="1752"><span class="lineNum">    1752 </span>            :                               printf (&quot;Exiting as a test! \n&quot;);</a>
<a name="1753"><span class="lineNum">    1753 </span>            :                               ROSE_ABORT();</a>
<a name="1754"><span class="lineNum">    1754 </span>            : #endif</a>
<a name="1755"><span class="lineNum">    1755 </span>            :                             }</a>
<a name="1756"><span class="lineNum">    1756 </span><span class="lineCov">       1629 :                          ROSE_ASSERT(templateInstantiation-&gt;get_nameResetFromMangledForm() == true);</span></a>
<a name="1757"><span class="lineNum">    1757 </span>            :                        }</a>
<a name="1758"><span class="lineNum">    1758 </span>            :                   }</a>
<a name="1759"><span class="lineNum">    1759 </span>            :                break;</a>
<a name="1760"><span class="lineNum">    1760 </span>            :              }</a>
<a name="1761"><span class="lineNum">    1761 </span>            : </a>
<a name="1762"><span class="lineNum">    1762 </span><span class="lineCov">    5439040 :           default:</span></a>
<a name="1763"><span class="lineNum">    1763 </span><span class="lineCov">    5439040 :              {</span></a>
<a name="1764"><span class="lineNum">    1764 </span>            :             // DQ (5/9/2005): Make sure that all non-templated IR nodes are marked as SgDeclarationStatement::e_no_specialization.</a>
<a name="1765"><span class="lineNum">    1765 </span><span class="lineCov">    5439040 :                SgVariableDeclaration *variableDeclaration = isSgVariableDeclaration(astNode);</span></a>
<a name="1766"><span class="lineNum">    1766 </span><span class="lineCov">    5439040 :                if (variableDeclaration != NULL)</span></a>
<a name="1767"><span class="lineNum">    1767 </span>            :                   {</a>
<a name="1768"><span class="lineNum">    1768 </span><span class="lineCov">      29852 :                     SgScopeStatement* scope = variableDeclaration-&gt;get_scope();</span></a>
<a name="1769"><span class="lineNum">    1769 </span><span class="lineCov">      29852 :                     SgClassDefinition* classDefinition = isSgClassDefinition(scope);</span></a>
<a name="1770"><span class="lineNum">    1770 </span><span class="lineCov">      29852 :                     if (classDefinition != NULL)</span></a>
<a name="1771"><span class="lineNum">    1771 </span>            :                        {</a>
<a name="1772"><span class="lineNum">    1772 </span><span class="lineCov">      22485 :                          SgTemplateClassDefinition* templateClassDefinition = isSgTemplateClassDefinition(classDefinition);</span></a>
<a name="1773"><span class="lineNum">    1773 </span><span class="lineCov">      22485 :                          if (templateClassDefinition != NULL)</span></a>
<a name="1774"><span class="lineNum">    1774 </span>            :                             {</a>
<a name="1775"><span class="lineNum">    1775 </span>            :                            // Special case...debugging new use of SgTemplateClassDefinition.</a>
<a name="1776"><span class="lineNum">    1776 </span>            : #ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION</a>
<a name="1777"><span class="lineNum">    1777 </span>            :                               printf (&quot;AST ConsistancyTest: TestAstTemplateProperties Found a case of SgTemplateClassDefinition (case not handled) \n&quot;);</a>
<a name="1778"><span class="lineNum">    1778 </span>            : #endif</a>
<a name="1779"><span class="lineNum">    1779 </span>            :                             }</a>
<a name="1780"><span class="lineNum">    1780 </span>            :                            else</a>
<a name="1781"><span class="lineNum">    1781 </span>            :                             {</a>
<a name="1782"><span class="lineNum">    1782 </span><span class="lineCov">      21756 :                               SgClassDeclaration* classDeclaration = classDefinition-&gt;get_declaration();</span></a>
<a name="1783"><span class="lineNum">    1783 </span><span class="lineCov">      21756 :                               ROSE_ASSERT(classDeclaration != NULL);</span></a>
<a name="1784"><span class="lineNum">    1784 </span><span class="lineCov">      21756 :                               if (isSgTemplateInstantiationDecl(classDefinition-&gt;get_declaration()) == NULL)</span></a>
<a name="1785"><span class="lineNum">    1785 </span>            :                                  {</a>
<a name="1786"><span class="lineNum">    1786 </span>            :                                 // This is NOT a data member of the templated class (or nested class of a templated class)</a>
<a name="1787"><span class="lineNum">    1787 </span><span class="lineCov">      20941 :                                    if (variableDeclaration-&gt;get_specialization() != SgClassDeclaration::e_no_specialization)</span></a>
<a name="1788"><span class="lineNum">    1788 </span>            :                                       {</a>
<a name="1789"><span class="lineNum">    1789 </span>            : #ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION</a>
<a name="1790"><span class="lineNum">    1790 </span>            :                                         printf (&quot;Note: AST ConsistancyTest: variableDeclaration-&gt;get_specialization() = %d != SgClassDeclaration::e_no_specialization  (variableDeclaration = %p) \n&quot;,variableDeclaration-&gt;get_specialization(),variableDeclaration);</a>
<a name="1791"><span class="lineNum">    1791 </span>            :                                         variableDeclaration-&gt;get_file_info()-&gt;display(&quot;variableDeclaration-&gt;get_specialization() != SgClassDeclaration::e_no_specialization&quot;);</a>
<a name="1792"><span class="lineNum">    1792 </span>            : #endif</a>
<a name="1793"><span class="lineNum">    1793 </span>            :                                       }</a>
<a name="1794"><span class="lineNum">    1794 </span>            :                                 // DQ (6/30/2005): Commented out to focus more on KULL, output a warning for now!</a>
<a name="1795"><span class="lineNum">    1795 </span>            :                                 // ROSE_ASSERT(variableDeclaration-&gt;get_specialization() == SgClassDeclaration::e_no_specialization);</a>
<a name="1796"><span class="lineNum">    1796 </span>            :                                  }</a>
<a name="1797"><span class="lineNum">    1797 </span>            :                                 else</a>
<a name="1798"><span class="lineNum">    1798 </span>            :                                  {</a>
<a name="1799"><span class="lineNum">    1799 </span>            :                                 // Make sure that all template class declarations are associated with a template definition!</a>
<a name="1800"><span class="lineNum">    1800 </span><span class="lineCov">        815 :                                    if (isSgTemplateInstantiationDefn(classDefinition) == NULL)</span></a>
<a name="1801"><span class="lineNum">    1801 </span>            :                                       {</a>
<a name="1802"><span class="lineNum">    1802 </span><span class="lineNoCov">          0 :                                         printf (&quot;Warning: classDefinition = %p = %s \n&quot;,classDefinition,classDefinition != NULL ? classDefinition-&gt;class_name().c_str() : &quot;null&quot;);</span></a>
<a name="1803"><span class="lineNum">    1803 </span>            :                                       }</a>
<a name="1804"><span class="lineNum">    1804 </span>            : </a>
<a name="1805"><span class="lineNum">    1805 </span>            :                                 // DQ (1/1/2012): I think we can assert that this is only a SgClassDefinition (but leave the warning message above).</a>
<a name="1806"><span class="lineNum">    1806 </span>            :                                 // ROSE_ASSERT(isSgTemplateInstantiationDefn(classDefinition) != NULL);</a>
<a name="1807"><span class="lineNum">    1807 </span><span class="lineCov">        815 :                                    ROSE_ASSERT(isSgClassDefinition(classDefinition) != NULL);</span></a>
<a name="1808"><span class="lineNum">    1808 </span>            :                                  }</a>
<a name="1809"><span class="lineNum">    1809 </span>            :                             }</a>
<a name="1810"><span class="lineNum">    1810 </span>            :                        }</a>
<a name="1811"><span class="lineNum">    1811 </span>            :                   }</a>
<a name="1812"><span class="lineNum">    1812 </span>            : </a>
<a name="1813"><span class="lineNum">    1813 </span>            :             // DQ (5/9/2005): Make sure that all non-templated IR nodes are marked as SgDeclarationStatement::e_no_specialization.</a>
<a name="1814"><span class="lineNum">    1814 </span><span class="lineCov">    5439040 :                SgClassDeclaration *classDeclaration = isSgClassDeclaration(astNode);</span></a>
<a name="1815"><span class="lineNum">    1815 </span><span class="lineCov">    5439040 :                if (classDeclaration != NULL)</span></a>
<a name="1816"><span class="lineNum">    1816 </span>            :                   {</a>
<a name="1817"><span class="lineNum">    1817 </span><span class="lineCov">      11753 :                     if (isSgTemplateInstantiationDecl(classDeclaration) == NULL)</span></a>
<a name="1818"><span class="lineNum">    1818 </span>            :                        {</a>
<a name="1819"><span class="lineNum">    1819 </span>            :                       // this is NOT a data member of the templated class (or nested class of a templated class)</a>
<a name="1820"><span class="lineNum">    1820 </span><span class="lineCov">      11753 :                          if (classDeclaration-&gt;get_specialization() != SgClassDeclaration::e_no_specialization)</span></a>
<a name="1821"><span class="lineNum">    1821 </span>            :                             {</a>
<a name="1822"><span class="lineNum">    1822 </span><span class="lineNoCov">          0 :                               printf (&quot;AST ConsistancyTest: classDeclaration = %p = %s classDeclaration-&gt;get_specialization() = %d != SgClassDeclaration::e_no_specialization \n&quot;,</span></a>
<a name="1823"><span class="lineNum">    1823 </span><span class="lineNoCov">          0 :                                    classDeclaration,classDeclaration-&gt;get_name().str(),classDeclaration-&gt;get_specialization());</span></a>
<a name="1824"><span class="lineNum">    1824 </span><span class="lineNoCov">          0 :                               printf (&quot;     classDeclaration at file %s line = %d \n&quot;,</span></a>
<a name="1825"><span class="lineNum">    1825 </span><span class="lineNoCov">          0 :                                    classDeclaration-&gt;get_file_info()-&gt;get_raw_filename().c_str(),</span></a>
<a name="1826"><span class="lineNum">    1826 </span><span class="lineNoCov">          0 :                                    classDeclaration-&gt;get_file_info()-&gt;get_raw_line());</span></a>
<a name="1827"><span class="lineNum">    1827 </span>            :                             }</a>
<a name="1828"><span class="lineNum">    1828 </span><span class="lineCov">      11753 :                          ROSE_ASSERT(classDeclaration-&gt;get_specialization() == SgClassDeclaration::e_no_specialization);</span></a>
<a name="1829"><span class="lineNum">    1829 </span>            :                        }</a>
<a name="1830"><span class="lineNum">    1830 </span>            :                   }</a>
<a name="1831"><span class="lineNum">    1831 </span>            : </a>
<a name="1832"><span class="lineNum">    1832 </span>            :             // DQ (5/9/2005): Make sure that all non-templated IR nodes are marked as SgDeclarationStatement::e_no_specialization.</a>
<a name="1833"><span class="lineNum">    1833 </span><span class="lineCov">    5439040 :                SgFunctionDeclaration *functionDeclaration = isSgFunctionDeclaration(astNode);</span></a>
<a name="1834"><span class="lineNum">    1834 </span><span class="lineCov">    5439040 :                if (functionDeclaration != NULL)</span></a>
<a name="1835"><span class="lineNum">    1835 </span>            :                   {</a>
<a name="1836"><span class="lineNum">    1836 </span><span class="lineCov">    2096560 :                     if ( isSgTemplateInstantiationFunctionDecl(functionDeclaration) == NULL &amp;&amp;</span></a>
<a name="1837"><span class="lineNum">    1837 </span><span class="lineCov">    1048280 :                          isSgTemplateInstantiationMemberFunctionDecl(functionDeclaration) == NULL )</span></a>
<a name="1838"><span class="lineNum">    1838 </span>            :                        {</a>
<a name="1839"><span class="lineNum">    1839 </span>            :                       // this is NOT a data member of the templated class (or nested class of a templated class)</a>
<a name="1840"><span class="lineNum">    1840 </span><span class="lineCov">    1048280 :                          ROSE_ASSERT(functionDeclaration-&gt;get_specialization() == SgFunctionDeclaration::e_no_specialization);</span></a>
<a name="1841"><span class="lineNum">    1841 </span>            :                        }</a>
<a name="1842"><span class="lineNum">    1842 </span>            :                   }</a>
<a name="1843"><span class="lineNum">    1843 </span>            :              }</a>
<a name="1844"><span class="lineNum">    1844 </span>            :         }</a>
<a name="1845"><span class="lineNum">    1845 </span><span class="lineCov">    5466810 :    }</span></a>
<a name="1846"><span class="lineNum">    1846 </span>            : </a>
<a name="1847"><span class="lineNum">    1847 </span>            : </a>
<a name="1848"><span class="lineNum">    1848 </span>            : void</a>
<a name="1849"><span class="lineNum">    1849 </span><span class="lineCov">    5466810 : TestAstCompilerGeneratedNodes::visit ( SgNode* node )</span></a>
<a name="1850"><span class="lineNum">    1850 </span>            :    {</a>
<a name="1851"><span class="lineNum">    1851 </span>            :   // DQ (6/20/2005):</a>
<a name="1852"><span class="lineNum">    1852 </span>            :   // printf (&quot;node = %s \n&quot;,node-&gt;sage_class_name());</a>
<a name="1853"><span class="lineNum">    1853 </span>            : </a>
<a name="1854"><span class="lineNum">    1854 </span>            :   // DQ (8/17/2005): isOutputInCodeGeneration() is now an orthogonal concept to isCompilerGenerated()</a>
<a name="1855"><span class="lineNum">    1855 </span>            :   // there is no relationship between the two except that some IR nodes that are compiler generated</a>
<a name="1856"><span class="lineNum">    1856 </span>            :   // are also (separately) marked as to be output in the code generation phase.</a>
<a name="1857"><span class="lineNum">    1857 </span>            : </a>
<a name="1858"><span class="lineNum">    1858 </span><span class="lineCov">    5466810 :      Sg_File_Info* fileInfo = node-&gt;get_file_info();</span></a>
<a name="1859"><span class="lineNum">    1859 </span><span class="lineCov">    5466810 :      if (fileInfo != NULL)</span></a>
<a name="1860"><span class="lineNum">    1860 </span>            :         {</a>
<a name="1861"><span class="lineNum">    1861 </span>            :        // If this is a compiler generated node to be unparsed then is should at least be marked as compiler generated</a>
<a name="1862"><span class="lineNum">    1862 </span>            :        // if (fileInfo-&gt;isCompilerGeneratedNodeToBeUnparsed() == true)</a>
<a name="1863"><span class="lineNum">    1863 </span><span class="lineCov">    5466160 :           if (fileInfo-&gt;isOutputInCodeGeneration() == true)</span></a>
<a name="1864"><span class="lineNum">    1864 </span>            :              {</a>
<a name="1865"><span class="lineNum">    1865 </span>            : #if 0</a>
<a name="1866"><span class="lineNum">    1866 </span>            :             // DQ (9/10/2005):</a>
<a name="1867"><span class="lineNum">    1867 </span>            :             // This test is only done for non-template declarations (unclear if</a>
<a name="1868"><span class="lineNum">    1868 </span>            :             // template declarations should be considered compiler generated, it</a>
<a name="1869"><span class="lineNum">    1869 </span>            :             // seems that sume are that should certainly not be so and this was</a>
<a name="1870"><span class="lineNum">    1870 </span>            :             // failing other tests, so we have made non template declaration</a>
<a name="1871"><span class="lineNum">    1871 </span>            :             // compiler generated as a test to see if we can pass KULL)</a>
<a name="1872"><span class="lineNum">    1872 </span>            :                if (isSgTemplateDeclaration(node) == NULL)</a>
<a name="1873"><span class="lineNum">    1873 </span>            :                   {</a>
<a name="1874"><span class="lineNum">    1874 </span>            :                     ROSE_ASSERT(fileInfo-&gt;isCompilerGenerated() == true);</a>
<a name="1875"><span class="lineNum">    1875 </span>            :                   }</a>
<a name="1876"><span class="lineNum">    1876 </span>            : #endif</a>
<a name="1877"><span class="lineNum">    1877 </span>            :              }</a>
<a name="1878"><span class="lineNum">    1878 </span>            :         }</a>
<a name="1879"><span class="lineNum">    1879 </span><span class="lineCov">    5466810 :    }</span></a>
<a name="1880"><span class="lineNum">    1880 </span>            : </a>
<a name="1881"><span class="lineNum">    1881 </span>            : /*! \page AstProperties AST Properties (Consistency Tests)</a>
<a name="1882"><span class="lineNum">    1882 </span>            : </a>
<a name="1883"><span class="lineNum">    1883 </span>            : \section section4 Mangle Name Properties</a>
<a name="1884"><span class="lineNum">    1884 </span>            : </a>
<a name="1885"><span class="lineNum">    1885 </span>            :     Mangled names within SAGE III follow specific rules and are tested:</a>
<a name="1886"><span class="lineNum">    1886 </span>            :      -# May be used as variable names in C and C++ \n</a>
<a name="1887"><span class="lineNum">    1887 </span>            :         This implies that they follow all the rules regarding variable naming within C and C++ (not repeated here).</a>
<a name="1888"><span class="lineNum">    1888 </span>            :      -# There are no EDG generated name fragements from template instantiation \n</a>
<a name="1889"><span class="lineNum">    1889 </span>            :         EDG internally generates unique names (e.g &quot;foo____L1042&quot;) for template instatiations, we convert all such</a>
<a name="1890"><span class="lineNum">    1890 </span>            :         names and use the new names of the form &quot;foo&lt;int&gt;&quot; before name mangling.  Through name mangling, longer</a>
<a name="1891"><span class="lineNum">    1891 </span>            :         names are generated of the form &quot;foo__tas_int__tae&quot;, from which the original template names and arguments</a>
<a name="1892"><span class="lineNum">    1892 </span>            :         can be recognised (&quot;&lt;&quot; -&gt; &quot;__tas&quot; and &quot;&gt;&quot; -&gt; &quot;__tae&quot;, for template argument start (tas) and template</a>
<a name="1893"><span class="lineNum">    1893 </span>            :         argument end (tae).</a>
<a name="1894"><span class="lineNum">    1894 </span>            : </a>
<a name="1895"><span class="lineNum">    1895 </span>            : */</a>
<a name="1896"><span class="lineNum">    1896 </span>            : </a>
<a name="1897"><span class="lineNum">    1897 </span>            : void</a>
<a name="1898"><span class="lineNum">    1898 </span><span class="lineCov">    5466810 : TestAstForProperlyMangledNames::visit ( SgNode* node )</span></a>
<a name="1899"><span class="lineNum">    1899 </span>            :    {</a>
<a name="1900"><span class="lineNum">    1900 </span>            :   // DQ (4/27/2005): Added to verify properties of mangled names (no &lt;&gt;, etc.).</a>
<a name="1901"><span class="lineNum">    1901 </span>            : </a>
<a name="1902"><span class="lineNum">    1902 </span>            :   // printf (&quot;node = %s \n&quot;,node-&gt;sage_class_name());</a>
<a name="1903"><span class="lineNum">    1903 </span>            : </a>
<a name="1904"><span class="lineNum">    1904 </span><span class="lineCov">    5466810 :      string mangledName;</span></a>
<a name="1905"><span class="lineNum">    1905 </span>            : </a>
<a name="1906"><span class="lineNum">    1906 </span>            :   // DQ (4/3/2011): This is used to compute the file if isValidMangledName() fails.</a>
<a name="1907"><span class="lineNum">    1907 </span>            :   // SgFile* file = NULL;</a>
<a name="1908"><span class="lineNum">    1908 </span>            : </a>
<a name="1909"><span class="lineNum">    1909 </span>            : #if 0</a>
<a name="1910"><span class="lineNum">    1910 </span>            :      printf (&quot;In TestAstForProperlyMangledNames::visit(SgNode* node = %p = %s) \n&quot;,node,node-&gt;class_name().c_str());</a>
<a name="1911"><span class="lineNum">    1911 </span>            : #endif</a>
<a name="1912"><span class="lineNum">    1912 </span>            : </a>
<a name="1913"><span class="lineNum">    1913 </span>            :   // DQ (4/28/2005): Check out the mangled name for classes</a>
<a name="1914"><span class="lineNum">    1914 </span><span class="lineCov">    5466810 :      SgClassDeclaration* classDeclaration = isSgClassDeclaration(node);</span></a>
<a name="1915"><span class="lineNum">    1915 </span><span class="lineCov">    5466810 :      if (classDeclaration != NULL)</span></a>
<a name="1916"><span class="lineNum">    1916 </span>            :         {</a>
<a name="1917"><span class="lineNum">    1917 </span>            :        // RV (2/2/2006)</a>
<a name="1918"><span class="lineNum">    1918 </span>            : #if 0</a>
<a name="1919"><span class="lineNum">    1919 </span>            :           int counter = 0; // counts the numbre of scopes back to global scope (not critical, but useful for debugging)</a>
<a name="1920"><span class="lineNum">    1920 </span>            :           mangledName = classDeclaration-&gt;get_mangled_qualified_name(counter).str();</a>
<a name="1921"><span class="lineNum">    1921 </span>            : #else</a>
<a name="1922"><span class="lineNum">    1922 </span><span class="lineCov">      17590 :           mangledName = classDeclaration-&gt;get_mangled_name().getString();</span></a>
<a name="1923"><span class="lineNum">    1923 </span>            : #endif</a>
<a name="1924"><span class="lineNum">    1924 </span>            : </a>
<a name="1925"><span class="lineNum">    1925 </span>            :        // DQ (8/28/2006): Added tests for the length of the mangled names</a>
<a name="1926"><span class="lineNum">    1926 </span><span class="lineCov">      17590 :           unsigned long mangledNameSize = mangledName.size();</span></a>
<a name="1927"><span class="lineNum">    1927 </span><span class="lineCov">      17590 :           saved_totalMangledNameSize += mangledNameSize;</span></a>
<a name="1928"><span class="lineNum">    1928 </span><span class="lineCov">      17590 :           saved_numberOfMangledNames++;</span></a>
<a name="1929"><span class="lineNum">    1929 </span><span class="lineCov">      17590 :           if (saved_maxMangledNameSize &lt; mangledNameSize)</span></a>
<a name="1930"><span class="lineNum">    1930 </span>            :              {</a>
<a name="1931"><span class="lineNum">    1931 </span><span class="lineCov">        502 :                saved_maxMangledNameSize = mangledNameSize;</span></a>
<a name="1932"><span class="lineNum">    1932 </span><span class="lineCov">        502 :                if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL )</span></a>
<a name="1933"><span class="lineNum">    1933 </span>            :                   {</a>
<a name="1934"><span class="lineNum">    1934 </span><span class="lineNoCov">          0 :                     printf (&quot;saved_maxMangledNameSize = %ld average size = %ld \n&quot;,saved_maxMangledNameSize,saved_totalMangledNameSize/saved_numberOfMangledNames);</span></a>
<a name="1935"><span class="lineNum">    1935 </span>            :                   }</a>
<a name="1936"><span class="lineNum">    1936 </span>            :              }</a>
<a name="1937"><span class="lineNum">    1937 </span>            : </a>
<a name="1938"><span class="lineNum">    1938 </span>            : #if 0</a>
<a name="1939"><span class="lineNum">    1939 </span>            :           string name = classDeclaration-&gt;get_name().str();</a>
<a name="1940"><span class="lineNum">    1940 </span>            :           printf (&quot;In TestAstForProperlyMangledNames::visit(SgNode*): \n           unmangled name = %s \n check mangled class name = %s \n&quot;,name.c_str(),mangledName.c_str());</a>
<a name="1941"><span class="lineNum">    1941 </span>            : #endif</a>
<a name="1942"><span class="lineNum">    1942 </span>            : </a>
<a name="1943"><span class="lineNum">    1943 </span>            :        // Make sure that there is no template specific syntax included in the mangled name</a>
<a name="1944"><span class="lineNum">    1944 </span><span class="lineCov">      17590 :           if ( mangledName.find('&lt;') != string::npos )</span></a>
<a name="1945"><span class="lineNum">    1945 </span>            :              {</a>
<a name="1946"><span class="lineNum">    1946 </span><span class="lineNoCov">          0 :                string name = classDeclaration-&gt;get_name().str();</span></a>
<a name="1947"><span class="lineNum">    1947 </span><span class="lineNoCov">          0 :                printf (&quot;In TestAstForProperlyMangledNames::visit(SgNode*): \n           unmangled name = %s \n check mangled class name = %s \n&quot;,</span></a>
<a name="1948"><span class="lineNum">    1948 </span>            :                     name.c_str(),mangledName.c_str());</a>
<a name="1949"><span class="lineNum">    1949 </span>            :              }</a>
<a name="1950"><span class="lineNum">    1950 </span><span class="lineCov">      17590 :           ROSE_ASSERT(mangledName.find('&lt;') == string::npos);</span></a>
<a name="1951"><span class="lineNum">    1951 </span><span class="lineCov">      17590 :           if ( mangledName.find('&gt;') != string::npos )</span></a>
<a name="1952"><span class="lineNum">    1952 </span>            :              {</a>
<a name="1953"><span class="lineNum">    1953 </span><span class="lineNoCov">          0 :                string name = classDeclaration-&gt;get_name().str();</span></a>
<a name="1954"><span class="lineNum">    1954 </span><span class="lineNoCov">          0 :                printf (&quot;In TestAstForProperlyMangledNames::visit(SgNode*): \n           unmangled name = %s \n check mangled class name = %s \n&quot;,</span></a>
<a name="1955"><span class="lineNum">    1955 </span>            :                     name.c_str(),mangledName.c_str());</a>
<a name="1956"><span class="lineNum">    1956 </span>            :              }</a>
<a name="1957"><span class="lineNum">    1957 </span><span class="lineCov">      17590 :           ROSE_ASSERT(mangledName.find('&gt;') == string::npos);</span></a>
<a name="1958"><span class="lineNum">    1958 </span>            : /*</a>
<a name="1959"><span class="lineNum">    1959 </span>            :        // DQ (4/3/2011): This is a fix to permit Java names that can include '$' to be handled properly.</a>
<a name="1960"><span class="lineNum">    1960 </span>            :        // When the simpler test fails we compute what the current langauge is (relatively expensive so</a>
<a name="1961"><span class="lineNum">    1961 </span>            :        // we don't want to do so for each IR node) and the rerun the test with java specified explicitly.</a>
<a name="1962"><span class="lineNum">    1962 </span>            :           bool anErrorHasOccured = false;</a>
<a name="1963"><span class="lineNum">    1963 </span>            :           if (isValidMangledName(mangledName) != true)</a>
<a name="1964"><span class="lineNum">    1964 </span>            :              {</a>
<a name="1965"><span class="lineNum">    1965 </span>            :              // Check first if this is for a Java file and if so then '$' is allowed.</a>
<a name="1966"><span class="lineNum">    1966 </span>            :                 file = TransformationSupport::getFile(classDeclaration);</a>
<a name="1967"><span class="lineNum">    1967 </span>            :                 ROSE_ASSERT(file != NULL);</a>
<a name="1968"><span class="lineNum">    1968 </span>            : </a>
<a name="1969"><span class="lineNum">    1969 </span>            :                 if (file-&gt;get_Java_only() == false)</a>
<a name="1970"><span class="lineNum">    1970 </span>            :                    {</a>
<a name="1971"><span class="lineNum">    1971 </span>            :                      anErrorHasOccured = true;</a>
<a name="1972"><span class="lineNum">    1972 </span>            :                    }</a>
<a name="1973"><span class="lineNum">    1973 </span>            :                   else</a>
<a name="1974"><span class="lineNum">    1974 </span>            :                    {</a>
<a name="1975"><span class="lineNum">    1975 </span>            :                   // printf (&quot;Rerun the test for isValidMangledName() with java langauge specified \n&quot;);</a>
<a name="1976"><span class="lineNum">    1976 </span>            :                      bool javaInUse = true;</a>
<a name="1977"><span class="lineNum">    1977 </span>            :                      anErrorHasOccured = !isValidMangledName(mangledName,javaInUse);</a>
<a name="1978"><span class="lineNum">    1978 </span>            :                    }</a>
<a name="1979"><span class="lineNum">    1979 </span>            : </a>
<a name="1980"><span class="lineNum">    1980 </span>            :                if (anErrorHasOccured == true)</a>
<a name="1981"><span class="lineNum">    1981 </span>            :                   {</a>
<a name="1982"><span class="lineNum">    1982 </span>            :                     printf (&quot;Error: failed isValidMangledName() test classDeclaration = %p = %s = %s --- mangledName = %s \n&quot;,</a>
<a name="1983"><span class="lineNum">    1983 </span>            :                          classDeclaration,classDeclaration-&gt;get_name().str(),classDeclaration-&gt;class_name().c_str(),mangledName.c_str());</a>
<a name="1984"><span class="lineNum">    1984 </span>            :                     classDeclaration-&gt;get_file_info()-&gt;display(&quot;Error: failed isValidMangledName() test&quot;);</a>
<a name="1985"><span class="lineNum">    1985 </span>            :                   }</a>
<a name="1986"><span class="lineNum">    1986 </span>            :              }</a>
<a name="1987"><span class="lineNum">    1987 </span>            :        // ROSE_ASSERT(isValidMangledName(mangledName) == true);</a>
<a name="1988"><span class="lineNum">    1988 </span>            :           ROSE_ASSERT(anErrorHasOccured == false);</a>
<a name="1989"><span class="lineNum">    1989 </span>            : */</a>
<a name="1990"><span class="lineNum">    1990 </span>            :         }</a>
<a name="1991"><span class="lineNum">    1991 </span>            : </a>
<a name="1992"><span class="lineNum">    1992 </span>            :   // DQ (4/27/2005): Check out the mangled name for functions</a>
<a name="1993"><span class="lineNum">    1993 </span><span class="lineCov">    5466810 :      SgFunctionDeclaration* functionDeclaration = isSgFunctionDeclaration(node);</span></a>
<a name="1994"><span class="lineNum">    1994 </span><span class="lineCov">    5466810 :      if (functionDeclaration != NULL)</span></a>
<a name="1995"><span class="lineNum">    1995 </span>            :         {</a>
<a name="1996"><span class="lineNum">    1996 </span><span class="lineCov">    1060060 :           mangledName = functionDeclaration-&gt;get_mangled_name().str();</span></a>
<a name="1997"><span class="lineNum">    1997 </span>            : #if 0</a>
<a name="1998"><span class="lineNum">    1998 </span>            :           string name = functionDeclaration-&gt;get_name().str();</a>
<a name="1999"><span class="lineNum">    1999 </span>            :           printf (&quot;In TestAstForProperlyMangledNames::visit(SgNode*): name = %s check mangled function name = %s \n&quot;,name.c_str(),mangledName.c_str());</a>
<a name="2000"><span class="lineNum">    2000 </span>            : #endif</a>
<a name="2001"><span class="lineNum">    2001 </span>            :        // Make sure that there is no template specific syntax included in the mangled name</a>
<a name="2002"><span class="lineNum">    2002 </span><span class="lineCov">    1060060 :           ROSE_ASSERT(mangledName.find('&lt;') == string::npos);</span></a>
<a name="2003"><span class="lineNum">    2003 </span><span class="lineCov">    1060060 :           ROSE_ASSERT(mangledName.find('&gt;') == string::npos);</span></a>
<a name="2004"><span class="lineNum">    2004 </span>            :         }</a>
<a name="2005"><span class="lineNum">    2005 </span>            :   // Make sure that there is no template specific syntax included in the mangled name</a>
<a name="2006"><span class="lineNum">    2006 </span><span class="lineCov">    5466810 :      ROSE_ASSERT(mangledName.find('`') == string::npos);</span></a>
<a name="2007"><span class="lineNum">    2007 </span><span class="lineCov">    5466810 :      ROSE_ASSERT(mangledName.find('~') == string::npos);</span></a>
<a name="2008"><span class="lineNum">    2008 </span><span class="lineCov">    5466810 :      ROSE_ASSERT(mangledName.find('!') == string::npos);</span></a>
<a name="2009"><span class="lineNum">    2009 </span>            : </a>
<a name="2010"><span class="lineNum">    2010 </span>            :   // ROSE_ASSERT(mangledName.find('@') == string::npos);</a>
<a name="2011"><span class="lineNum">    2011 </span><span class="lineCov">    5466810 :      if (mangledName.find('@') != string::npos)</span></a>
<a name="2012"><span class="lineNum">    2012 </span>            :         {</a>
<a name="2013"><span class="lineNum">    2013 </span><span class="lineNoCov">          0 :           printf (&quot;Error: failed isValidMangledName() test node = %p = %s --- mangledName = %s \n&quot;,node,node-&gt;class_name().c_str(),mangledName.c_str());</span></a>
<a name="2014"><span class="lineNum">    2014 </span>            :         }</a>
<a name="2015"><span class="lineNum">    2015 </span><span class="lineCov">    5466810 :      ROSE_ASSERT(mangledName.find('@') == string::npos);</span></a>
<a name="2016"><span class="lineNum">    2016 </span>            : </a>
<a name="2017"><span class="lineNum">    2017 </span><span class="lineCov">    5466810 :      ROSE_ASSERT(mangledName.find('#') == string::npos);</span></a>
<a name="2018"><span class="lineNum">    2018 </span>            : </a>
<a name="2019"><span class="lineNum">    2019 </span>            : /*</a>
<a name="2020"><span class="lineNum">    2020 </span>            :   // DQ (4/3/2011): Java allows for '$' so we have to exclude this test when Java is used.</a>
<a name="2021"><span class="lineNum">    2021 </span>            :   // note that if it was isValidMangledName() failed (could be many reasons) then file has</a>
<a name="2022"><span class="lineNum">    2022 </span>            :   // been computed and is available.</a>
<a name="2023"><span class="lineNum">    2023 </span>            :   // ROSE_ASSERT(mangledName.find('$') == string::npos);</a>
<a name="2024"><span class="lineNum">    2024 </span>            :      if (file == NULL || (file != NULL &amp;&amp; file-&gt;get_Java_only() == false) )</a>
<a name="2025"><span class="lineNum">    2025 </span>            :         {</a>
<a name="2026"><span class="lineNum">    2026 </span>            :            ROSE_ASSERT(mangledName.find('$') == string::npos);</a>
<a name="2027"><span class="lineNum">    2027 </span>            :         }</a>
<a name="2028"><span class="lineNum">    2028 </span>            :        else</a>
<a name="2029"><span class="lineNum">    2029 </span>            :         {</a>
<a name="2030"><span class="lineNum">    2030 </span>            :        // If this is a Java file and there is a '$' is fould then assert using a weaker test.</a>
<a name="2031"><span class="lineNum">    2031 </span>            :           if (mangledName.find('$') != string::npos)</a>
<a name="2032"><span class="lineNum">    2032 </span>            :              {</a>
<a name="2033"><span class="lineNum">    2033 </span>            :             // A '$' was found, check using a more expensive test.</a>
<a name="2034"><span class="lineNum">    2034 </span>            :                ROSE_ASSERT(file-&gt;get_Java_only() == true);</a>
<a name="2035"><span class="lineNum">    2035 </span>            : </a>
<a name="2036"><span class="lineNum">    2036 </span>            :                bool javaInUse = true;</a>
<a name="2037"><span class="lineNum">    2037 </span>            :                ROSE_ASSERT(isValidMangledName(mangledName,javaInUse) == true);</a>
<a name="2038"><span class="lineNum">    2038 </span>            :              }</a>
<a name="2039"><span class="lineNum">    2039 </span>            :         }</a>
<a name="2040"><span class="lineNum">    2040 </span>            : </a>
<a name="2041"><span class="lineNum">    2041 </span>            :      ROSE_ASSERT(mangledName.find('%') == string::npos);</a>
<a name="2042"><span class="lineNum">    2042 </span>            :      ROSE_ASSERT(mangledName.find('^') == string::npos);</a>
<a name="2043"><span class="lineNum">    2043 </span>            :      ROSE_ASSERT(mangledName.find('&amp;') == string::npos);</a>
<a name="2044"><span class="lineNum">    2044 </span>            :      ROSE_ASSERT(mangledName.find('*') == string::npos);</a>
<a name="2045"><span class="lineNum">    2045 </span>            : */</a>
<a name="2046"><span class="lineNum">    2046 </span>            : </a>
<a name="2047"><span class="lineNum">    2047 </span>            :   // DQ (8/13/2005): this is an error in KULL (use of siloswigtypecheck.cc)</a>
<a name="2048"><span class="lineNum">    2048 </span>            :   // Commented out this tests so that I can defer it to later!</a>
<a name="2049"><span class="lineNum">    2049 </span><span class="lineCov">    5466810 :      if (mangledName.find('(') != string::npos)</span></a>
<a name="2050"><span class="lineNum">    2050 </span>            :         {</a>
<a name="2051"><span class="lineNum">    2051 </span><span class="lineNoCov">          0 :           printf (&quot;AST Consistency Test: found \&quot;(\&quot; in mangledName = %s \n&quot;,mangledName.c_str());</span></a>
<a name="2052"><span class="lineNum">    2052 </span>            : </a>
<a name="2053"><span class="lineNum">    2053 </span><span class="lineNoCov">          0 :           SgDeclarationStatement* declaration = isSgDeclarationStatement(node);</span></a>
<a name="2054"><span class="lineNum">    2054 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(declaration != NULL);</span></a>
<a name="2055"><span class="lineNum">    2055 </span><span class="lineNoCov">          0 :           declaration-&gt;get_file_info()-&gt;display(&quot;debug&quot;);</span></a>
<a name="2056"><span class="lineNum">    2056 </span>            :         }</a>
<a name="2057"><span class="lineNum">    2057 </span>            :   // ROSE_ASSERT(mangledName.find('(') == string::npos);</a>
<a name="2058"><span class="lineNum">    2058 </span>            : </a>
<a name="2059"><span class="lineNum">    2059 </span>            :   // DQ (8/13/2005): this is an error in KULL (use of siloswigtypecheck.cc)</a>
<a name="2060"><span class="lineNum">    2060 </span>            :   // Commented out this tests so that I can defer it to later!</a>
<a name="2061"><span class="lineNum">    2061 </span><span class="lineCov">    5466810 :      if (mangledName.find(')') != string::npos)</span></a>
<a name="2062"><span class="lineNum">    2062 </span>            :         {</a>
<a name="2063"><span class="lineNum">    2063 </span><span class="lineNoCov">          0 :           printf (&quot;AST Consistency Test: found \&quot;)\&quot; in mangledName = %s \n&quot;,mangledName.c_str());</span></a>
<a name="2064"><span class="lineNum">    2064 </span>            : </a>
<a name="2065"><span class="lineNum">    2065 </span><span class="lineNoCov">          0 :           SgDeclarationStatement* declaration = isSgDeclarationStatement(node);</span></a>
<a name="2066"><span class="lineNum">    2066 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(declaration != NULL);</span></a>
<a name="2067"><span class="lineNum">    2067 </span><span class="lineNoCov">          0 :           declaration-&gt;get_file_info()-&gt;display(&quot;debug&quot;);</span></a>
<a name="2068"><span class="lineNum">    2068 </span>            :         }</a>
<a name="2069"><span class="lineNum">    2069 </span>            :   // ROSE_ASSERT(mangledName.find(')') == string::npos);</a>
<a name="2070"><span class="lineNum">    2070 </span>            : </a>
<a name="2071"><span class="lineNum">    2071 </span>            :   // DQ (8/9/2005): this is an error in KULL (use of boost/mpl/if.hpp)</a>
<a name="2072"><span class="lineNum">    2072 </span><span class="lineCov">    5466810 :      if (mangledName.find('-') != string::npos)</span></a>
<a name="2073"><span class="lineNum">    2073 </span>            :         {</a>
<a name="2074"><span class="lineNum">    2074 </span><span class="lineNoCov">          0 :           printf (&quot;AST Consistency Test: found \&quot;-\&quot; in mangledName = %s \n&quot;,mangledName.c_str());</span></a>
<a name="2075"><span class="lineNum">    2075 </span>            : </a>
<a name="2076"><span class="lineNum">    2076 </span><span class="lineNoCov">          0 :           SgDeclarationStatement* declaration = isSgDeclarationStatement(node);</span></a>
<a name="2077"><span class="lineNum">    2077 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(declaration != NULL);</span></a>
<a name="2078"><span class="lineNum">    2078 </span><span class="lineNoCov">          0 :           declaration-&gt;get_file_info()-&gt;display(&quot;debug&quot;);</span></a>
<a name="2079"><span class="lineNum">    2079 </span>            :         }</a>
<a name="2080"><span class="lineNum">    2080 </span><span class="lineCov">    5466810 :      ROSE_ASSERT(mangledName.find('-') == string::npos);</span></a>
<a name="2081"><span class="lineNum">    2081 </span>            : </a>
<a name="2082"><span class="lineNum">    2082 </span><span class="lineCov">    5466810 :      ROSE_ASSERT(mangledName.find('+') == string::npos);</span></a>
<a name="2083"><span class="lineNum">    2083 </span><span class="lineCov">    5466810 :      ROSE_ASSERT(mangledName.find('=') == string::npos);</span></a>
<a name="2084"><span class="lineNum">    2084 </span><span class="lineCov">    5466810 :      ROSE_ASSERT(mangledName.find('{') == string::npos);</span></a>
<a name="2085"><span class="lineNum">    2085 </span><span class="lineCov">    5466810 :      ROSE_ASSERT(mangledName.find('}') == string::npos);</span></a>
<a name="2086"><span class="lineNum">    2086 </span><span class="lineCov">    5466810 :      ROSE_ASSERT(mangledName.find('[') == string::npos);</span></a>
<a name="2087"><span class="lineNum">    2087 </span><span class="lineCov">    5466810 :      ROSE_ASSERT(mangledName.find(']') == string::npos);</span></a>
<a name="2088"><span class="lineNum">    2088 </span><span class="lineCov">    5466810 :      ROSE_ASSERT(mangledName.find('|') == string::npos);</span></a>
<a name="2089"><span class="lineNum">    2089 </span><span class="lineCov">    5466810 :      ROSE_ASSERT(mangledName.find('\\') == string::npos);</span></a>
<a name="2090"><span class="lineNum">    2090 </span>            : </a>
<a name="2091"><span class="lineNum">    2091 </span>            :   // DQ (2/22/2007): Added error checking to report problems found in mangled names</a>
<a name="2092"><span class="lineNum">    2092 </span><span class="lineCov">    5466810 :      if (mangledName.find(&quot;::&quot;) != string::npos)</span></a>
<a name="2093"><span class="lineNum">    2093 </span>            :         {</a>
<a name="2094"><span class="lineNum">    2094 </span><span class="lineNoCov">          0 :           printf (&quot;AST Consistency Test: found \&quot;::\&quot; in mangledName = %s \n&quot;,mangledName.c_str());</span></a>
<a name="2095"><span class="lineNum">    2095 </span>            : </a>
<a name="2096"><span class="lineNum">    2096 </span><span class="lineNoCov">          0 :           SgDeclarationStatement* declaration = isSgDeclarationStatement(node);</span></a>
<a name="2097"><span class="lineNum">    2097 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(declaration != NULL);</span></a>
<a name="2098"><span class="lineNum">    2098 </span><span class="lineNoCov">          0 :           declaration-&gt;get_file_info()-&gt;display(&quot;debug&quot;);</span></a>
<a name="2099"><span class="lineNum">    2099 </span>            :         }</a>
<a name="2100"><span class="lineNum">    2100 </span><span class="lineCov">    5466810 :      ROSE_ASSERT(mangledName.find(&quot;::&quot;) == string::npos);</span></a>
<a name="2101"><span class="lineNum">    2101 </span>            : </a>
<a name="2102"><span class="lineNum">    2102 </span><span class="lineCov">    5466810 :      ROSE_ASSERT(mangledName.find(':') == string::npos);</span></a>
<a name="2103"><span class="lineNum">    2103 </span><span class="lineCov">    5466810 :      ROSE_ASSERT(mangledName.find(';') == string::npos);</span></a>
<a name="2104"><span class="lineNum">    2104 </span><span class="lineCov">    5466810 :      ROSE_ASSERT(mangledName.find('\&quot;') == string::npos);</span></a>
<a name="2105"><span class="lineNum">    2105 </span><span class="lineCov">    5466810 :      ROSE_ASSERT(mangledName.find('?') == string::npos);</span></a>
<a name="2106"><span class="lineNum">    2106 </span><span class="lineCov">    5466810 :      ROSE_ASSERT(mangledName.find('.') == string::npos);</span></a>
<a name="2107"><span class="lineNum">    2107 </span><span class="lineCov">    5466810 :      ROSE_ASSERT(mangledName.find('/') == string::npos);</span></a>
<a name="2108"><span class="lineNum">    2108 </span><span class="lineCov">    5466810 :      ROSE_ASSERT(mangledName.find(',') == string::npos);</span></a>
<a name="2109"><span class="lineNum">    2109 </span>            : </a>
<a name="2110"><span class="lineNum">    2110 </span>            :   // These are the most common cases that fail</a>
<a name="2111"><span class="lineNum">    2111 </span><span class="lineCov">    5466810 :      ROSE_ASSERT(mangledName.find('&lt;') == string::npos);</span></a>
<a name="2112"><span class="lineNum">    2112 </span><span class="lineCov">    5466810 :      ROSE_ASSERT(mangledName.find('&gt;') == string::npos);</span></a>
<a name="2113"><span class="lineNum">    2113 </span><span class="lineCov">    5466810 :    }</span></a>
<a name="2114"><span class="lineNum">    2114 </span>            : </a>
<a name="2115"><span class="lineNum">    2115 </span><span class="lineCov">        326 : TestAstForProperlyMangledNames::TestAstForProperlyMangledNames()</span></a>
<a name="2116"><span class="lineNum">    2116 </span><span class="lineCov">        326 :    : saved_maxMangledNameSize(0),saved_totalMangledNameSize(0),saved_numberOfMangledNames(0)</span></a>
<a name="2117"><span class="lineNum">    2117 </span>            :    {</a>
<a name="2118"><span class="lineNum">    2118 </span>            :   // Nothing to put here!</a>
<a name="2119"><span class="lineNum">    2119 </span><span class="lineCov">        326 :    }</span></a>
<a name="2120"><span class="lineNum">    2120 </span>            : </a>
<a name="2121"><span class="lineNum">    2121 </span>            : bool</a>
<a name="2122"><span class="lineNum">    2122 </span><span class="lineNoCov">          0 : TestAstForProperlyMangledNames::isValidMangledName (string name)</span></a>
<a name="2123"><span class="lineNum">    2123 </span>            :    {</a>
<a name="2124"><span class="lineNum">    2124 </span>            :   // DQ (4/3/2011): This function has been modified to permit Java specific weakened restrictions</a>
<a name="2125"><span class="lineNum">    2125 </span>            :   // on names. The default for java_lang is false.  If a test fails the current language is</a>
<a name="2126"><span class="lineNum">    2126 </span>            :   // determined and java_lang set to true if the current langage is Java for the associated SgFile.</a>
<a name="2127"><span class="lineNum">    2127 </span>            : </a>
<a name="2128"><span class="lineNum">    2128 </span><span class="lineNoCov">          0 :      bool result = true;</span></a>
<a name="2129"><span class="lineNum">    2129 </span>            : </a>
<a name="2130"><span class="lineNum">    2130 </span><span class="lineNoCov">          0 :      if (name.empty () || isdigit (name[0]))</span></a>
<a name="2131"><span class="lineNum">    2131 </span>            :         {</a>
<a name="2132"><span class="lineNum">    2132 </span>            :           result = false;</a>
<a name="2133"><span class="lineNum">    2133 </span>            :         }</a>
<a name="2134"><span class="lineNum">    2134 </span>            : </a>
<a name="2135"><span class="lineNum">    2135 </span>            :         {</a>
<a name="2136"><span class="lineNum">    2136 </span><span class="lineNoCov">          0 :           for (string::size_type i = 0; i &lt; name.size (); ++i)</span></a>
<a name="2137"><span class="lineNum">    2137 </span>            :              {</a>
<a name="2138"><span class="lineNum">    2138 </span>            :             // printf (&quot;java_lang == false: isalnum (name = %s name[i] = %c) = %s \n&quot;,name.c_str(),name[i],isalnum (name[i]) ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="2139"><span class="lineNum">    2139 </span><span class="lineNoCov">          0 :                if (!isalnum (name[i]) &amp;&amp; name[i] != '_')</span></a>
<a name="2140"><span class="lineNum">    2140 </span>            :                   {</a>
<a name="2141"><span class="lineNum">    2141 </span>            :                     result = false;</a>
<a name="2142"><span class="lineNum">    2142 </span>            :                   }</a>
<a name="2143"><span class="lineNum">    2143 </span>            :              }</a>
<a name="2144"><span class="lineNum">    2144 </span>            :         }</a>
<a name="2145"><span class="lineNum">    2145 </span>            : </a>
<a name="2146"><span class="lineNum">    2146 </span>            : #if 0</a>
<a name="2147"><span class="lineNum">    2147 </span>            :      if (result == false)</a>
<a name="2148"><span class="lineNum">    2148 </span>            :         {</a>
<a name="2149"><span class="lineNum">    2149 </span>            :           printf (&quot;ERROR: isValidMangledName(name = %s) == false \n&quot;,name.c_str());</a>
<a name="2150"><span class="lineNum">    2150 </span>            :         }</a>
<a name="2151"><span class="lineNum">    2151 </span>            : #endif</a>
<a name="2152"><span class="lineNum">    2152 </span>            : </a>
<a name="2153"><span class="lineNum">    2153 </span><span class="lineNoCov">          0 :      return result;</span></a>
<a name="2154"><span class="lineNum">    2154 </span>            :    }</a>
<a name="2155"><span class="lineNum">    2155 </span>            : </a>
<a name="2156"><span class="lineNum">    2156 </span>            : /*! \page AstProperties AST Properties (Consistency Tests)</a>
<a name="2157"><span class="lineNum">    2157 </span>            : </a>
<a name="2158"><span class="lineNum">    2158 </span>            : \section section2 Unique Statements in Scope</a>
<a name="2159"><span class="lineNum">    2159 </span>            : </a>
<a name="2160"><span class="lineNum">    2160 </span>            :      This test verifies each statement in a scope is unique. This catches rewrite and general</a>
<a name="2161"><span class="lineNum">    2161 </span>            : transformation errors that might insert a statement twice or relocate in by forget to delete</a>
<a name="2162"><span class="lineNum">    2162 </span>            : it.  Since it only works within a single scope it is not very robust.</a>
<a name="2163"><span class="lineNum">    2163 </span>            : </a>
<a name="2164"><span class="lineNum">    2164 </span>            : */</a>
<a name="2165"><span class="lineNum">    2165 </span>            : </a>
<a name="2166"><span class="lineNum">    2166 </span>            : void</a>
<a name="2167"><span class="lineNum">    2167 </span><span class="lineCov">    5466810 : TestAstForUniqueStatementsInScopes::visit ( SgNode* node )</span></a>
<a name="2168"><span class="lineNum">    2168 </span>            :    {</a>
<a name="2169"><span class="lineNum">    2169 </span>            :   // DQ (3/31/2004): Added to locate scopes that have redundent statements.</a>
<a name="2170"><span class="lineNum">    2170 </span>            :   // This could happen either because of a bug in the EDG/SAGE connection,</a>
<a name="2171"><span class="lineNum">    2171 </span>            :   // or as a result of using the rewrite mechanism inappropriately.</a>
<a name="2172"><span class="lineNum">    2172 </span>            : </a>
<a name="2173"><span class="lineNum">    2173 </span>            :   // printf (&quot;node = %s \n&quot;,node-&gt;sage_class_name());</a>
<a name="2174"><span class="lineNum">    2174 </span>            : </a>
<a name="2175"><span class="lineNum">    2175 </span>            :   // DQ (4/1/2004): Added code to detect redundent statements in a scope!</a>
<a name="2176"><span class="lineNum">    2176 </span><span class="lineCov">    5466810 :      SgScopeStatement* scope = isSgScopeStatement(node);</span></a>
<a name="2177"><span class="lineNum">    2177 </span><span class="lineCov">    5466810 :      if (scope != NULL)</span></a>
<a name="2178"><span class="lineNum">    2178 </span>            :         {</a>
<a name="2179"><span class="lineNum">    2179 </span>            :        // Generate a list of statements in the scope (even if they are really declaration statements)</a>
<a name="2180"><span class="lineNum">    2180 </span><span class="lineCov">     102610 :           SgStatementPtrList statementList;</span></a>
<a name="2181"><span class="lineNum">    2181 </span><span class="lineCov">      51305 :           switch ( scope-&gt;variantT() )</span></a>
<a name="2182"><span class="lineNum">    2182 </span>            :              {</a>
<a name="2183"><span class="lineNum">    2183 </span><span class="lineCov">       3887 :                case V_SgIfStmt:</span></a>
<a name="2184"><span class="lineNum">    2184 </span><span class="lineCov">       3887 :                   {</span></a>
<a name="2185"><span class="lineNum">    2185 </span><span class="lineCov">       3887 :                     SgIfStmt* ifStatement = isSgIfStmt(scope);</span></a>
<a name="2186"><span class="lineNum">    2186 </span><span class="lineCov">       3887 :                     ROSE_ASSERT (ifStatement != NULL);</span></a>
<a name="2187"><span class="lineNum">    2187 </span><span class="lineCov">       3887 :                     statementList = isSgBasicBlock(ifStatement-&gt;get_true_body()) ? isSgBasicBlock(ifStatement-&gt;get_true_body())-&gt;generateStatementList() : SgStatementPtrList(1, ifStatement-&gt;get_true_body());</span></a>
<a name="2188"><span class="lineNum">    2188 </span><span class="lineCov">       7774 :                     SgStatementPtrList falseStatementList = isSgBasicBlock(ifStatement-&gt;get_false_body()) ? isSgBasicBlock(ifStatement-&gt;get_false_body())-&gt;generateStatementList() : ifStatement-&gt;get_false_body() ? SgStatementPtrList(1, ifStatement-&gt;get_false_body()) : SgStatementPtrList();</span></a>
<a name="2189"><span class="lineNum">    2189 </span>            : </a>
<a name="2190"><span class="lineNum">    2190 </span>            :                  // statementList.merge(falseStatementList);</a>
<a name="2191"><span class="lineNum">    2191 </span><span class="lineCov">       3887 :                     statementList.insert(statementList.end(),falseStatementList.begin(),falseStatementList.end());</span></a>
<a name="2192"><span class="lineNum">    2192 </span>            : </a>
<a name="2193"><span class="lineNum">    2193 </span><span class="lineCov">       3887 :                     break;</span></a>
<a name="2194"><span class="lineNum">    2194 </span>            :                   }</a>
<a name="2195"><span class="lineNum">    2195 </span>            :                case V_SgDeclarationScope:</a>
<a name="2196"><span class="lineNum">    2196 </span>            :                   break;</a>
<a name="2197"><span class="lineNum">    2197 </span><span class="lineCov">      47418 :                default:</span></a>
<a name="2198"><span class="lineNum">    2198 </span><span class="lineCov">      94836 :                     statementList = scope-&gt;generateStatementList();</span></a>
<a name="2199"><span class="lineNum">    2199 </span>            :              }</a>
<a name="2200"><span class="lineNum">    2200 </span>            :        // MK (8/3/05) : Rewrote this test to ignore statements which are marked as shared. These may actually exist multiple times in a scope</a>
<a name="2201"><span class="lineNum">    2201 </span>            : </a>
<a name="2202"><span class="lineNum">    2202 </span>            :        // seenStatements is a unique container. Thus, we know that a statement can only go into it once. If</a>
<a name="2203"><span class="lineNum">    2203 </span>            :        // encounter a statement twice, then it will go into duplicateStatements, where we can report it</a>
<a name="2204"><span class="lineNum">    2204 </span>            :        // later, if necessary.</a>
<a name="2205"><span class="lineNum">    2205 </span><span class="lineCov">     102610 :           set&lt;SgStatement *&gt; seenStatements;</span></a>
<a name="2206"><span class="lineNum">    2206 </span><span class="lineCov">     102610 :           list&lt;SgStatement *&gt; duplicateStatements;</span></a>
<a name="2207"><span class="lineNum">    2207 </span><span class="lineCov">      51305 :           seenStatements.clear();</span></a>
<a name="2208"><span class="lineNum">    2208 </span><span class="lineCov">      51305 :           duplicateStatements.clear();</span></a>
<a name="2209"><span class="lineNum">    2209 </span>            : </a>
<a name="2210"><span class="lineNum">    2210 </span>            :        // Set this to false if we should fail the test</a>
<a name="2211"><span class="lineNum">    2211 </span><span class="lineCov">      51305 :           bool pass = true;</span></a>
<a name="2212"><span class="lineNum">    2212 </span>            : </a>
<a name="2213"><span class="lineNum">    2213 </span>            :        // This gives us the total number of statements checked, useful for reporting</a>
<a name="2214"><span class="lineNum">    2214 </span><span class="lineCov">      51305 :           int totalStatements = statementList.size();</span></a>
<a name="2215"><span class="lineNum">    2215 </span><span class="lineCov">      51305 :           int numberOfDuplicates = 0;</span></a>
<a name="2216"><span class="lineNum">    2216 </span><span class="lineCov">      51305 :           int numberOfUniques = 0;</span></a>
<a name="2217"><span class="lineNum">    2217 </span><span class="lineCov">      51305 :           int numberOfShared = 0;</span></a>
<a name="2218"><span class="lineNum">    2218 </span>            : </a>
<a name="2219"><span class="lineNum">    2219 </span>            :        // Go through the statements, and put any duplicates found into duplicateStatements</a>
<a name="2220"><span class="lineNum">    2220 </span><span class="lineCov">    1266070 :           for (SgStatementPtrList::iterator i = statementList.begin(); i != statementList.end(); i++)</span></a>
<a name="2221"><span class="lineNum">    2221 </span>            :              {</a>
<a name="2222"><span class="lineNum">    2222 </span><span class="lineCov">    1214770 :                SgStatement * currStatement = *i;</span></a>
<a name="2223"><span class="lineNum">    2223 </span>            : </a>
<a name="2224"><span class="lineNum">    2224 </span>            :             // ignore shared nodes</a>
<a name="2225"><span class="lineNum">    2225 </span><span class="lineCov">    1214770 :                if (currStatement-&gt;get_file_info()-&gt;isShared())</span></a>
<a name="2226"><span class="lineNum">    2226 </span>            :                   {</a>
<a name="2227"><span class="lineNum">    2227 </span><span class="lineNoCov">          0 :                     numberOfShared++;</span></a>
<a name="2228"><span class="lineNum">    2228 </span>            :                   }</a>
<a name="2229"><span class="lineNum">    2229 </span>            :                  else</a>
<a name="2230"><span class="lineNum">    2230 </span>            :                   {</a>
<a name="2231"><span class="lineNum">    2231 </span>            :                  // DQ (2/22/2007): It is likely that count is more expensive than find since we only want existence.</a>
<a name="2232"><span class="lineNum">    2232 </span><span class="lineCov">    1214770 :                     if (seenStatements.count(currStatement) == 0)</span></a>
<a name="2233"><span class="lineNum">    2233 </span>            :                        {</a>
<a name="2234"><span class="lineNum">    2234 </span><span class="lineCov">    1214770 :                          seenStatements.insert(currStatement);</span></a>
<a name="2235"><span class="lineNum">    2235 </span><span class="lineCov">    1214770 :                          numberOfUniques++;</span></a>
<a name="2236"><span class="lineNum">    2236 </span>            :                        }</a>
<a name="2237"><span class="lineNum">    2237 </span>            :                       else</a>
<a name="2238"><span class="lineNum">    2238 </span>            :                        {</a>
<a name="2239"><span class="lineNum">    2239 </span><span class="lineNoCov">          0 :                          duplicateStatements.push_back(currStatement);</span></a>
<a name="2240"><span class="lineNum">    2240 </span><span class="lineNoCov">          0 :                          numberOfDuplicates++;</span></a>
<a name="2241"><span class="lineNum">    2241 </span>            :                        }</a>
<a name="2242"><span class="lineNum">    2242 </span>            :                   }</a>
<a name="2243"><span class="lineNum">    2243 </span>            :              }</a>
<a name="2244"><span class="lineNum">    2244 </span>            : </a>
<a name="2245"><span class="lineNum">    2245 </span>            :        // If there are duplicate statements, we have an error</a>
<a name="2246"><span class="lineNum">    2246 </span><span class="lineCov">      51305 :           if (numberOfDuplicates != 0)</span></a>
<a name="2247"><span class="lineNum">    2247 </span>            :              {</a>
<a name="2248"><span class="lineNum">    2248 </span><span class="lineNoCov">          0 :                pass = false;</span></a>
<a name="2249"><span class="lineNum">    2249 </span>            :              }</a>
<a name="2250"><span class="lineNum">    2250 </span>            : </a>
<a name="2251"><span class="lineNum">    2251 </span><span class="lineNoCov">          0 :           if (!pass)</span></a>
<a name="2252"><span class="lineNum">    2252 </span>            :              {</a>
<a name="2253"><span class="lineNum">    2253 </span><span class="lineNoCov">          0 :                if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL || true )</span></a>
<a name="2254"><span class="lineNum">    2254 </span>            :                   {</a>
<a name="2255"><span class="lineNum">    2255 </span><span class="lineNoCov">          0 :                     cout &lt;&lt; &quot;Problematic Node: &quot; &lt;&lt; node-&gt;sage_class_name() &lt;&lt; &quot; found. (a statement appears more than once in this scope)&quot; &lt;&lt; endl;</span></a>
<a name="2256"><span class="lineNum">    2256 </span>            : </a>
<a name="2257"><span class="lineNum">    2257 </span><span class="lineNoCov">          0 :                     printf (&quot;Error: number of [non-shared] statements = %d  number of unique statements = %d \n&quot;,</span></a>
<a name="2258"><span class="lineNum">    2258 </span>            :                     totalStatements - numberOfShared, numberOfUniques);</a>
<a name="2259"><span class="lineNum">    2259 </span>            : </a>
<a name="2260"><span class="lineNum">    2260 </span>            :                  // verify that there are duplicates</a>
<a name="2261"><span class="lineNum">    2261 </span><span class="lineNoCov">          0 :                     ROSE_ASSERT(numberOfDuplicates &gt; 0);</span></a>
<a name="2262"><span class="lineNum">    2262 </span>            : </a>
<a name="2263"><span class="lineNum">    2263 </span><span class="lineNoCov">          0 :                     printf (&quot;Number of duplicate statements = %d \n&quot;,numberOfDuplicates);</span></a>
<a name="2264"><span class="lineNum">    2264 </span>            : #if 0</a>
<a name="2265"><span class="lineNum">    2265 </span>            :                     printf (&quot;Exiting as a test ... \n&quot;);</a>
<a name="2266"><span class="lineNum">    2266 </span>            :                     ROSE_ABORT();</a>
<a name="2267"><span class="lineNum">    2267 </span>            : #endif</a>
<a name="2268"><span class="lineNum">    2268 </span><span class="lineNoCov">          0 :                     int counter = 0;</span></a>
<a name="2269"><span class="lineNum">    2269 </span><span class="lineNoCov">          0 :                     for (list&lt;SgStatement *&gt;::iterator j = duplicateStatements.begin(); j != duplicateStatements.end(); j++)</span></a>
<a name="2270"><span class="lineNum">    2270 </span>            :                        {</a>
<a name="2271"><span class="lineNum">    2271 </span><span class="lineNoCov">          0 :                          SgStatement * currDuplicate = *j;</span></a>
<a name="2272"><span class="lineNum">    2272 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(currDuplicate != NULL);</span></a>
<a name="2273"><span class="lineNum">    2273 </span>            : </a>
<a name="2274"><span class="lineNum">    2274 </span>            :                       // DQ (6/26/2016): Debugging a special case that appears with ROSE compiles &quot;rose.h&quot; header file.</a>
<a name="2275"><span class="lineNum">    2275 </span><span class="lineNoCov">          0 :                          SgTemplateInstantiationDefn* templateInstantiationDefn = isSgTemplateInstantiationDefn(node);</span></a>
<a name="2276"><span class="lineNum">    2276 </span><span class="lineNoCov">          0 :                          if (templateInstantiationDefn != NULL)</span></a>
<a name="2277"><span class="lineNum">    2277 </span>            :                             {</a>
<a name="2278"><span class="lineNum">    2278 </span><span class="lineNoCov">          0 :                               SgTemplateInstantiationDecl* templateInstantiationDecl = isSgTemplateInstantiationDecl(templateInstantiationDefn-&gt;get_declaration());</span></a>
<a name="2279"><span class="lineNum">    2279 </span><span class="lineNoCov">          0 :                               ROSE_ASSERT(templateInstantiationDecl != NULL);</span></a>
<a name="2280"><span class="lineNum">    2280 </span><span class="lineNoCov">          0 :                               printf (&quot;ERROR: problem declaration: templateInstantiationDecl = %p = %s \n&quot;,templateInstantiationDecl,templateInstantiationDecl-&gt;get_name().str());</span></a>
<a name="2281"><span class="lineNum">    2281 </span>            :                             }</a>
<a name="2282"><span class="lineNum">    2282 </span>            : </a>
<a name="2283"><span class="lineNum">    2283 </span><span class="lineNoCov">          0 :                          Sg_File_Info * location = currDuplicate-&gt;get_file_info();</span></a>
<a name="2284"><span class="lineNum">    2284 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(location != NULL);</span></a>
<a name="2285"><span class="lineNum">    2285 </span><span class="lineNoCov">          0 :                          printf (&quot;Error: node (%d/%d) = %p = %s at: \n&quot;,counter,numberOfDuplicates,currDuplicate,currDuplicate-&gt;sage_class_name());</span></a>
<a name="2286"><span class="lineNum">    2286 </span>            : </a>
<a name="2287"><span class="lineNum">    2287 </span>            :                       // DQ (3/21/2011): Added more detail to debug duplicate entries...</a>
<a name="2288"><span class="lineNum">    2288 </span><span class="lineNoCov">          0 :                          printf (&quot;currDuplicate name = %s \n&quot;,SageInterface::get_name(currDuplicate).c_str());</span></a>
<a name="2289"><span class="lineNum">    2289 </span>            : </a>
<a name="2290"><span class="lineNum">    2290 </span><span class="lineNoCov">          0 :                          if (location != NULL)</span></a>
<a name="2291"><span class="lineNum">    2291 </span>            :                             {</a>
<a name="2292"><span class="lineNum">    2292 </span><span class="lineNoCov">          0 :                               location-&gt;display(&quot;redundant IR node&quot;);</span></a>
<a name="2293"><span class="lineNum">    2293 </span>            :                             }</a>
<a name="2294"><span class="lineNum">    2294 </span><span class="lineNoCov">          0 :                          counter++;</span></a>
<a name="2295"><span class="lineNum">    2295 </span>            :                        }</a>
<a name="2296"><span class="lineNum">    2296 </span>            :                   }</a>
<a name="2297"><span class="lineNum">    2297 </span>            :              }</a>
<a name="2298"><span class="lineNum">    2298 </span>            : </a>
<a name="2299"><span class="lineNum">    2299 </span><span class="lineCov">      51305 :           if (pass == false)</span></a>
<a name="2300"><span class="lineNum">    2300 </span>            :              {</a>
<a name="2301"><span class="lineNum">    2301 </span><span class="lineNoCov">          0 :                printf (&quot;Error: duplicate statements in scope = %p = %s \n&quot;,scope,scope-&gt;class_name().c_str());</span></a>
<a name="2302"><span class="lineNum">    2302 </span><span class="lineNoCov">          0 :                scope-&gt;get_file_info()-&gt;display(&quot;Error: duplicate statements in scope&quot;);</span></a>
<a name="2303"><span class="lineNum">    2303 </span>            :              }</a>
<a name="2304"><span class="lineNum">    2304 </span>            : #if 1</a>
<a name="2305"><span class="lineNum">    2305 </span><span class="lineCov">      51305 :           ROSE_ASSERT(pass == true);</span></a>
<a name="2306"><span class="lineNum">    2306 </span>            : #else</a>
<a name="2307"><span class="lineNum">    2307 </span>            :        // DQ (6/6/2013): debugging... (test2013_198.C)</a>
<a name="2308"><span class="lineNum">    2308 </span>            :        // DQ (8/9/2012): debugging... (test2012_174.C)</a>
<a name="2309"><span class="lineNum">    2309 </span>            :           if (pass == false)</a>
<a name="2310"><span class="lineNum">    2310 </span>            :              {</a>
<a name="2311"><span class="lineNum">    2311 </span>            :                printf (&quot;****** Commented out this error to view the dot file ****** \n&quot;);</a>
<a name="2312"><span class="lineNum">    2312 </span>            :              }</a>
<a name="2313"><span class="lineNum">    2313 </span>            : #endif</a>
<a name="2314"><span class="lineNum">    2314 </span>            :         }</a>
<a name="2315"><span class="lineNum">    2315 </span><span class="lineCov">    5466810 :    }</span></a>
<a name="2316"><span class="lineNum">    2316 </span>            : </a>
<a name="2317"><span class="lineNum">    2317 </span>            : /*! \page AstProperties AST Properties (Consistency Tests)</a>
<a name="2318"><span class="lineNum">    2318 </span>            : </a>
<a name="2319"><span class="lineNum">    2319 </span>            : \section section2 Unique IR nodes in the AST</a>
<a name="2320"><span class="lineNum">    2320 </span>            : </a>
<a name="2321"><span class="lineNum">    2321 </span>            :      This test verifies each IR nodes visited in the AST is only visited once.</a>
<a name="2322"><span class="lineNum">    2322 </span>            : This is a more robust version of the previous test which checked for shared</a>
<a name="2323"><span class="lineNum">    2323 </span>            : IR nodes in the same scope (which is a more common problem).  This test is</a>
<a name="2324"><span class="lineNum">    2324 </span>            : more expensive in memory since it has to save a reference to ever IR node</a>
<a name="2325"><span class="lineNum">    2325 </span>            : and test if it has been previously seen.</a>
<a name="2326"><span class="lineNum">    2326 </span>            : */</a>
<a name="2327"><span class="lineNum">    2327 </span>            : </a>
<a name="2328"><span class="lineNum">    2328 </span>            : void</a>
<a name="2329"><span class="lineNum">    2329 </span><span class="lineCov">    5569180 : TestAstForUniqueNodesInAST::visit ( SgNode* node )</span></a>
<a name="2330"><span class="lineNum">    2330 </span>            :    {</a>
<a name="2331"><span class="lineNum">    2331 </span>            :   // DQ (4/2/2012): This is a more robust (and expensive) test to check for shared IR nodes in the AST (there should be none).</a>
<a name="2332"><span class="lineNum">    2332 </span><span class="lineCov">    5569180 :      ROSE_ASSERT(node != NULL);</span></a>
<a name="2333"><span class="lineNum">    2333 </span>            : </a>
<a name="2334"><span class="lineNum">    2334 </span>            : #if 0</a>
<a name="2335"><span class="lineNum">    2335 </span>            :      printf (&quot;In TestAstForUniqueNodesInAST::visit (): IR node = %p = %s = %s in the AST. \n&quot;,node,node-&gt;class_name().c_str(),SageInterface::generateUniqueName(node,true).c_str());</a>
<a name="2336"><span class="lineNum">    2336 </span>            :      Sg_File_Info* source_position = node-&gt;get_file_info();</a>
<a name="2337"><span class="lineNum">    2337 </span>            :      if (source_position != NULL)</a>
<a name="2338"><span class="lineNum">    2338 </span>            :         {</a>
<a name="2339"><span class="lineNum">    2339 </span>            :           printf (&quot;   --- line %d \n&quot;,source_position-&gt;get_line());</a>
<a name="2340"><span class="lineNum">    2340 </span>            :         }</a>
<a name="2341"><span class="lineNum">    2341 </span>            : #endif</a>
<a name="2342"><span class="lineNum">    2342 </span>            : </a>
<a name="2343"><span class="lineNum">    2343 </span><span class="lineCov">   11138400 :      if (astNodeSet.find(node) != astNodeSet.end())</span></a>
<a name="2344"><span class="lineNum">    2344 </span>            :         {</a>
<a name="2345"><span class="lineNum">    2345 </span><span class="lineNoCov">          0 :           SgLocatedNode* locatedNode = isSgLocatedNode(node);</span></a>
<a name="2346"><span class="lineNum">    2346 </span><span class="lineNoCov">          0 :           if (locatedNode != NULL)</span></a>
<a name="2347"><span class="lineNum">    2347 </span>            :              {</a>
<a name="2348"><span class="lineNum">    2348 </span>            :             // Note that we must exclude IR nodes marked explicitly as shared by AST merge.</a>
<a name="2349"><span class="lineNum">    2349 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(locatedNode-&gt;get_file_info() != NULL);</span></a>
<a name="2350"><span class="lineNum">    2350 </span><span class="lineNoCov">          0 :                if (locatedNode-&gt;get_file_info()-&gt;isShared() == false)</span></a>
<a name="2351"><span class="lineNum">    2351 </span>            :                   {</a>
<a name="2352"><span class="lineNum">    2352 </span><span class="lineNoCov">          0 :                     if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL )</span></a>
<a name="2353"><span class="lineNum">    2353 </span>            :                        {</a>
<a name="2354"><span class="lineNum">    2354 </span><span class="lineNoCov">          0 :                          printf (&quot;Warning: found a shared IR node = %p = %s in the AST. \n&quot;,node,node-&gt;class_name().c_str());</span></a>
<a name="2355"><span class="lineNum">    2355 </span><span class="lineNoCov">          0 :                          locatedNode-&gt;get_file_info()-&gt;display(&quot;Error: found a shared IR node (might be marked as shared after AST merge; not handled yet)&quot;);</span></a>
<a name="2356"><span class="lineNum">    2356 </span>            :                        }</a>
<a name="2357"><span class="lineNum">    2357 </span>            :                   }</a>
<a name="2358"><span class="lineNum">    2358 </span>            :                  else</a>
<a name="2359"><span class="lineNum">    2359 </span>            :                   {</a>
<a name="2360"><span class="lineNum">    2360 </span>            : #if 0</a>
<a name="2361"><span class="lineNum">    2361 </span>            :                  // DQ (11/3/2016): Comment out this output spew from the AST File I/O testing.</a>
<a name="2362"><span class="lineNum">    2362 </span>            :                     printf (&quot;Note: found a shared IR node = %p = %s in the AST (OK if part of merged AST) \n&quot;,node,node-&gt;class_name().c_str());</a>
<a name="2363"><span class="lineNum">    2363 </span>            : #endif</a>
<a name="2364"><span class="lineNum">    2364 </span>            : #if 0</a>
<a name="2365"><span class="lineNum">    2365 </span>            :                     SgProject* project = TransformationSupport::getProject(locatedNode);</a>
<a name="2366"><span class="lineNum">    2366 </span>            :                     project-&gt;display(&quot;In TestAstForUniqueNodesInAST::visit()&quot;);</a>
<a name="2367"><span class="lineNum">    2367 </span>            : #endif</a>
<a name="2368"><span class="lineNum">    2368 </span>            : #if 0</a>
<a name="2369"><span class="lineNum">    2369 </span>            :                     if (project-&gt;get_astMerge() == true)</a>
<a name="2370"><span class="lineNum">    2370 </span>            :                        {</a>
<a name="2371"><span class="lineNum">    2371 </span>            :                          printf (&quot;In TestAstForUniqueNodesInAST::visit(): We can detect when we want to supress the AST consistancy tests that detect sharing when we are merging ASTs \n&quot;);</a>
<a name="2372"><span class="lineNum">    2372 </span>            :                        }</a>
<a name="2373"><span class="lineNum">    2373 </span>            : #endif</a>
<a name="2374"><span class="lineNum">    2374 </span>            : #if 0</a>
<a name="2375"><span class="lineNum">    2375 </span>            :                     SgSourceFile* file = TransformationSupport::getSourceFile(locatedNode);</a>
<a name="2376"><span class="lineNum">    2376 </span>            :                     file-&gt;display(&quot;In TestAstForUniqueNodesInAST::visit()&quot;);</a>
<a name="2377"><span class="lineNum">    2377 </span>            : #endif</a>
<a name="2378"><span class="lineNum">    2378 </span>            : #if 0</a>
<a name="2379"><span class="lineNum">    2379 </span>            :                     printf (&quot;Exiting as a test! \n&quot;);</a>
<a name="2380"><span class="lineNum">    2380 </span>            :                     ROSE_ABORT();</a>
<a name="2381"><span class="lineNum">    2381 </span>            : #endif</a>
<a name="2382"><span class="lineNum">    2382 </span>            :                   }</a>
<a name="2383"><span class="lineNum">    2383 </span>            :              }</a>
<a name="2384"><span class="lineNum">    2384 </span>            :             else</a>
<a name="2385"><span class="lineNum">    2385 </span>            :              {</a>
<a name="2386"><span class="lineNum">    2386 </span><span class="lineNoCov">          0 :                if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL )</span></a>
<a name="2387"><span class="lineNum">    2387 </span><span class="lineNoCov">          0 :                     printf (&quot;Warning: found a shared IR node = %p = %s in the AST (not a SgLocatedNode) \n&quot;,node,node-&gt;class_name().c_str());</span></a>
<a name="2388"><span class="lineNum">    2388 </span>            :              }</a>
<a name="2389"><span class="lineNum">    2389 </span>            : </a>
<a name="2390"><span class="lineNum">    2390 </span>            : #define ENFORCE_UNIQUE_IR_NODES 0</a>
<a name="2391"><span class="lineNum">    2391 </span>            : </a>
<a name="2392"><span class="lineNum">    2392 </span>            : #if ENFORCE_UNIQUE_IR_NODES</a>
<a name="2393"><span class="lineNum">    2393 </span>            :           if ( SgProject::get_verbose() &gt;= 0 )</a>
<a name="2394"><span class="lineNum">    2394 </span>            : #else</a>
<a name="2395"><span class="lineNum">    2395 </span><span class="lineNoCov">          0 :           if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL )</span></a>
<a name="2396"><span class="lineNum">    2396 </span>            : #endif</a>
<a name="2397"><span class="lineNum">    2397 </span>            :              {</a>
<a name="2398"><span class="lineNum">    2398 </span><span class="lineNoCov">          0 :                printf (&quot;Error: found a shared IR node = %p = %s in the AST. \n&quot;,node,node-&gt;class_name().c_str());</span></a>
<a name="2399"><span class="lineNum">    2399 </span>            : </a>
<a name="2400"><span class="lineNum">    2400 </span><span class="lineNoCov">          0 :                SgDeclarationStatement* declarationStatement = isSgDeclarationStatement(node);</span></a>
<a name="2401"><span class="lineNum">    2401 </span><span class="lineNoCov">          0 :                if (declarationStatement != NULL)</span></a>
<a name="2402"><span class="lineNum">    2402 </span>            :                   {</a>
<a name="2403"><span class="lineNum">    2403 </span><span class="lineNoCov">          0 :                     printf (&quot;*** (possible sharing violation) declarationStatement = %p = %s \n&quot;,declarationStatement,declarationStatement-&gt;class_name().c_str());</span></a>
<a name="2404"><span class="lineNum">    2404 </span><span class="lineNoCov">          0 :                     ROSE_ASSERT(declarationStatement-&gt;get_parent() != NULL);</span></a>
<a name="2405"><span class="lineNum">    2405 </span><span class="lineNoCov">          0 :                     printf (&quot;       --- declarationStatement-&gt;get_parent() = %p = %s \n&quot;,declarationStatement-&gt;get_parent(),declarationStatement-&gt;get_parent()-&gt;class_name().c_str());</span></a>
<a name="2406"><span class="lineNum">    2406 </span><span class="lineNoCov">          0 :                     SgLocatedNode* parent = isSgLocatedNode(declarationStatement-&gt;get_parent());</span></a>
<a name="2407"><span class="lineNum">    2407 </span><span class="lineNoCov">          0 :                     parent-&gt;get_startOfConstruct()-&gt;display(&quot;parent: debug&quot;);</span></a>
<a name="2408"><span class="lineNum">    2408 </span>            : </a>
<a name="2409"><span class="lineNum">    2409 </span><span class="lineNoCov">          0 :                     printf (&quot;       --- declarationStatement-&gt;get_firstNondefiningDeclaration() = %p \n&quot;,declarationStatement-&gt;get_firstNondefiningDeclaration());</span></a>
<a name="2410"><span class="lineNum">    2410 </span><span class="lineNoCov">          0 :                     printf (&quot;       --- declarationStatement-&gt;get_definingDeclaration()         = %p \n&quot;,declarationStatement-&gt;get_definingDeclaration());</span></a>
<a name="2411"><span class="lineNum">    2411 </span><span class="lineNoCov">          0 :                     declarationStatement-&gt;get_startOfConstruct()-&gt;display(&quot;declarationStatement: debug&quot;);</span></a>
<a name="2412"><span class="lineNum">    2412 </span><span class="lineNoCov">          0 :                     SgClassDeclaration* classDeclaration = isSgClassDeclaration(declarationStatement);</span></a>
<a name="2413"><span class="lineNum">    2413 </span><span class="lineNoCov">          0 :                     if (classDeclaration != NULL)</span></a>
<a name="2414"><span class="lineNum">    2414 </span>            :                        {</a>
<a name="2415"><span class="lineNum">    2415 </span><span class="lineNoCov">          0 :                          printf (&quot;       --- classDeclaration name = %s \n&quot;,classDeclaration-&gt;get_name().str());</span></a>
<a name="2416"><span class="lineNum">    2416 </span>            :                        }</a>
<a name="2417"><span class="lineNum">    2417 </span>            :                   }</a>
<a name="2418"><span class="lineNum">    2418 </span>            :              }</a>
<a name="2419"><span class="lineNum">    2419 </span>            : </a>
<a name="2420"><span class="lineNum">    2420 </span>            : #if ENFORCE_UNIQUE_IR_NODES</a>
<a name="2421"><span class="lineNum">    2421 </span>            :        // DQ (11/28/2015): The older failing tests (below) are now fixed; but there</a>
<a name="2422"><span class="lineNum">    2422 </span>            :        // are some newer failing tests (within Boost header files):</a>
<a name="2423"><span class="lineNum">    2423 </span>            :        // test2015_87.C</a>
<a name="2424"><span class="lineNum">    2424 </span>            :        // test2015_90.C</a>
<a name="2425"><span class="lineNum">    2425 </span>            :        // test2015_91.C</a>
<a name="2426"><span class="lineNum">    2426 </span>            :        // test2015_94.C</a>
<a name="2427"><span class="lineNum">    2427 </span>            :        // test2015_95.C</a>
<a name="2428"><span class="lineNum">    2428 </span>            :        // test2015_96.C</a>
<a name="2429"><span class="lineNum">    2429 </span>            :        // test2015_127.C</a>
<a name="2430"><span class="lineNum">    2430 </span>            :        // Also the RoseExample_tests fail (since they include the same boost issues).</a>
<a name="2431"><span class="lineNum">    2431 </span>            :        // So we still can not yet enforce this AST consistancy test.</a>
<a name="2432"><span class="lineNum">    2432 </span>            : </a>
<a name="2433"><span class="lineNum">    2433 </span>            :        // DQ (11/23/2015): As of this date, we can now enforce this test (I think).</a>
<a name="2434"><span class="lineNum">    2434 </span>            :        // DQ (4/8/2014): This now only fails for Boost examples, so I this is the good news,</a>
<a name="2435"><span class="lineNum">    2435 </span>            :        // however, it means that I still can't enforce this everywhere. These tests:</a>
<a name="2436"><span class="lineNum">    2436 </span>            :        // test2013_234.C</a>
<a name="2437"><span class="lineNum">    2437 </span>            :        // test2013_240.C</a>
<a name="2438"><span class="lineNum">    2438 </span>            :        // test2013_242.C</a>
<a name="2439"><span class="lineNum">    2439 </span>            :        // test2013_246.C</a>
<a name="2440"><span class="lineNum">    2440 </span>            :        // test2013_241.C</a>
<a name="2441"><span class="lineNum">    2441 </span>            : </a>
<a name="2442"><span class="lineNum">    2442 </span>            :        // DQ (10/16/2013): Now that we have the token stream support computed correctly,</a>
<a name="2443"><span class="lineNum">    2443 </span>            :        // we have to disable this check to support the C++ tests (e.g. test2004_77.C).</a>
<a name="2444"><span class="lineNum">    2444 </span>            :        // DQ (10/14/2013): Turn this on as part of testing the token stream mapping!</a>
<a name="2445"><span class="lineNum">    2445 </span>            :        // DQ (10/19/2012): This fails for a collection of C++ codes only:</a>
<a name="2446"><span class="lineNum">    2446 </span>            :        // test2011_121.C</a>
<a name="2447"><span class="lineNum">    2447 </span>            :        // test2011_141.C</a>
<a name="2448"><span class="lineNum">    2448 </span>            :        // test2011_142.C</a>
<a name="2449"><span class="lineNum">    2449 </span>            :        // test2005_142.C</a>
<a name="2450"><span class="lineNum">    2450 </span>            :        // test2009_41.C</a>
<a name="2451"><span class="lineNum">    2451 </span>            :        // test2006_124.C</a>
<a name="2452"><span class="lineNum">    2452 </span>            :        // test2005_128.C</a>
<a name="2453"><span class="lineNum">    2453 </span>            :        // test2005_34.C</a>
<a name="2454"><span class="lineNum">    2454 </span>            :        // test2004_129.C</a>
<a name="2455"><span class="lineNum">    2455 </span>            :        // test2004_130.C</a>
<a name="2456"><span class="lineNum">    2456 </span>            :        // test2004_85.C</a>
<a name="2457"><span class="lineNum">    2457 </span>            :        // test2004_127.C</a>
<a name="2458"><span class="lineNum">    2458 </span>            :        // test2005_103.C</a>
<a name="2459"><span class="lineNum">    2459 </span>            :        // test2005_42.C</a>
<a name="2460"><span class="lineNum">    2460 </span>            :        // test2006_84.C</a>
<a name="2461"><span class="lineNum">    2461 </span>            :        // test2005_35.C</a>
<a name="2462"><span class="lineNum">    2462 </span>            :        // test2006_141.C</a>
<a name="2463"><span class="lineNum">    2463 </span>            :        // inputBug317.C</a>
<a name="2464"><span class="lineNum">    2464 </span>            :        // test2005_161.C</a>
<a name="2465"><span class="lineNum">    2465 </span>            :        // test2004_120.C</a>
<a name="2466"><span class="lineNum">    2466 </span>            :        // This is a result of new work to support class/struct/union declarations output in unusual</a>
<a name="2467"><span class="lineNum">    2467 </span>            :        // location in some exmaples from C applications that have been a focus lately.</a>
<a name="2468"><span class="lineNum">    2468 </span>            :        // I might want to fix this up later after the dust settles.  These appear to be unusual cases.</a>
<a name="2469"><span class="lineNum">    2469 </span>            : </a>
<a name="2470"><span class="lineNum">    2470 </span>            :           ROSE_ABORT();</a>
<a name="2471"><span class="lineNum">    2471 </span>            : #else</a>
<a name="2472"><span class="lineNum">    2472 </span>            : </a>
<a name="2473"><span class="lineNum">    2473 </span>            :        // DQ (4/26/2012): debugging... (test2012_67.C)</a>
<a name="2474"><span class="lineNum">    2474 </span>            : #if ENFORCE_UNIQUE_IR_NODES</a>
<a name="2475"><span class="lineNum">    2475 </span>            :           if ( SgProject::get_verbose() &gt;= 0 )</a>
<a name="2476"><span class="lineNum">    2476 </span>            : #else</a>
<a name="2477"><span class="lineNum">    2477 </span><span class="lineNoCov">          0 :           if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL )</span></a>
<a name="2478"><span class="lineNum">    2478 </span>            : #endif</a>
<a name="2479"><span class="lineNum">    2479 </span>            :              {</a>
<a name="2480"><span class="lineNum">    2480 </span><span class="lineNoCov">          0 :                printf (&quot;In TestAstForUniqueNodesInAST::visit (): Rare issue (only effects Boost examples): node = %p = %s \n&quot;,node,node-&gt;class_name().c_str());</span></a>
<a name="2481"><span class="lineNum">    2481 </span>            :              }</a>
<a name="2482"><span class="lineNum">    2482 </span>            : #endif</a>
<a name="2483"><span class="lineNum">    2483 </span>            :         }</a>
<a name="2484"><span class="lineNum">    2484 </span>            : #if 0</a>
<a name="2485"><span class="lineNum">    2485 </span>            :      printf (&quot;In TestAstForUniqueNodesInAST::visit(): astNodeSet.insert(node = %p = %s) \n&quot;,node,node-&gt;class_name().c_str());</a>
<a name="2486"><span class="lineNum">    2486 </span>            : #endif</a>
<a name="2487"><span class="lineNum">    2487 </span>            : </a>
<a name="2488"><span class="lineNum">    2488 </span><span class="lineCov">    5569180 :      astNodeSet.insert(node);</span></a>
<a name="2489"><span class="lineNum">    2489 </span><span class="lineCov">    5569180 :    }</span></a>
<a name="2490"><span class="lineNum">    2490 </span>            : </a>
<a name="2491"><span class="lineNum">    2491 </span>            : </a>
<a name="2492"><span class="lineNum">    2492 </span>            : void</a>
<a name="2493"><span class="lineNum">    2493 </span><span class="lineCov">      32107 : TestAstForUniqueNodesInAST::test ( SgNode* node )</span></a>
<a name="2494"><span class="lineNum">    2494 </span>            :    {</a>
<a name="2495"><span class="lineNum">    2495 </span>            :   // DQ (4/3/2012): Added test to make sure that the pointers are unique.</a>
<a name="2496"><span class="lineNum">    2496 </span><span class="lineCov">      64214 :      TestAstForUniqueNodesInAST redundentNodeTest;</span></a>
<a name="2497"><span class="lineNum">    2497 </span><span class="lineCov">      32107 :      redundentNodeTest.traverse(node,preorder);</span></a>
<a name="2498"><span class="lineNum">    2498 </span><span class="lineCov">      32107 :    }</span></a>
<a name="2499"><span class="lineNum">    2499 </span>            : </a>
<a name="2500"><span class="lineNum">    2500 </span>            : void</a>
<a name="2501"><span class="lineNum">    2501 </span><span class="lineCov">      32107 : testAstForUniqueNodes ( SgNode* node )</span></a>
<a name="2502"><span class="lineNum">    2502 </span>            :    {</a>
<a name="2503"><span class="lineNum">    2503 </span>            :   // DQ (4/3/2012): Added test to make sure that the pointers are unique.</a>
<a name="2504"><span class="lineNum">    2504 </span><span class="lineCov">      32107 :      TestAstForUniqueNodesInAST::test(node);</span></a>
<a name="2505"><span class="lineNum">    2505 </span><span class="lineCov">      32107 :    }</span></a>
<a name="2506"><span class="lineNum">    2506 </span>            : </a>
<a name="2507"><span class="lineNum">    2507 </span>            : </a>
<a name="2508"><span class="lineNum">    2508 </span>            : /*! \page AstProperties AST Properties (Consistency Tests)</a>
<a name="2509"><span class="lineNum">    2509 </span>            : </a>
<a name="2510"><span class="lineNum">    2510 </span>            : \section section3 Rules for Defining and Nondefining Declarations</a>
<a name="2511"><span class="lineNum">    2511 </span>            : </a>
<a name="2512"><span class="lineNum">    2512 </span>            :     We separate defining and non-defining declarations so that many aspects of analysis and transformation are</a>
<a name="2513"><span class="lineNum">    2513 </span>            : simplified, along with code generation. For example, if from any function declaration the function definition is sought,</a>
<a name="2514"><span class="lineNum">    2514 </span>            : it is available from the defining declaration (this applied uniformly to all declarations). These tests</a>
<a name="2515"><span class="lineNum">    2515 </span>            : verify that the handling of defining and non-defining declaration follow specific rules (with a goal toward uniformity</a>
<a name="2516"><span class="lineNum">    2516 </span>            : and intuitive behavior).</a>
<a name="2517"><span class="lineNum">    2517 </span>            : </a>
<a name="2518"><span class="lineNum">    2518 </span>            :     Nondefining declarations appear as forward declarations and references to declarations within types.  These many</a>
<a name="2519"><span class="lineNum">    2519 </span>            : appear many times within the source code and as a result are non unique within the AST.  For example, each forward</a>
<a name="2520"><span class="lineNum">    2520 </span>            : declaration of a function or class within a source code becomes a non-defining declaration.</a>
<a name="2521"><span class="lineNum">    2521 </span>            : </a>
<a name="2522"><span class="lineNum">    2522 </span>            :     Defining declarations contain their definition, and function appearing with its body (implementation) is</a>
<a name="2523"><span class="lineNum">    2523 </span>            : a defined declaration containing a function definition (the scope of the function).  The defining declaration</a>
<a name="2524"><span class="lineNum">    2524 </span>            : should appear only once within the source code, by the One Time Definition rule, (OTD).  Each forward declaration,</a>
<a name="2525"><span class="lineNum">    2525 </span>            : clearly becomes a separate declaration but it may be shared as needed to reduce the total number of non-defining</a>
<a name="2526"><span class="lineNum">    2526 </span>            : declarations, which are also referenced in types.</a>
<a name="2527"><span class="lineNum">    2527 </span>            : </a>
<a name="2528"><span class="lineNum">    2528 </span>            :    Within SAGE III, every declaration has a reference to its first non-defining declaration and its defined declaration</a>
<a name="2529"><span class="lineNum">    2529 </span>            : if it exists (is defined within the current translation unit).  If in processing a defining declaration an reference is</a>
<a name="2530"><span class="lineNum">    2530 </span>            : required, get_declaration() always returns the non-defined declaration.  The defined declaration is only available</a>
<a name="2531"><span class="lineNum">    2531 </span>            : explicitly (via a function call) and is never returned through any other mechanism.  Thus non-defining declarations</a>
<a name="2532"><span class="lineNum">    2532 </span>            : are shared and defining declaration are never shared within the AST.</a>
<a name="2533"><span class="lineNum">    2533 </span>            : </a>
<a name="2534"><span class="lineNum">    2534 </span>            : \subsection subsection3a When defining and non-defining declarations are the same</a>
<a name="2535"><span class="lineNum">    2535 </span>            :     SgEnumDeclaration declarations are not allowed to forward reference their definitions, this they are the same</a>
<a name="2536"><span class="lineNum">    2536 </span>            : and the defining and non-defining declaration for a SgEnumDeclaration are pointer values which are the same.</a>
<a name="2537"><span class="lineNum">    2537 </span>            : </a>
<a name="2538"><span class="lineNum">    2538 </span>            : \example The following assertion is true for all SgEnumDeclaration objects: \n</a>
<a name="2539"><span class="lineNum">    2539 </span>            :      assert (declaration-&gt;get_definingDeclaration() == declaration-&gt;get_firstNondefiningDeclaration());</a>
<a name="2540"><span class="lineNum">    2540 </span>            : </a>
<a name="2541"><span class="lineNum">    2541 </span>            : \subsection subsection3b Scopes of defining and nondefining declarations match (same pointer value)</a>
<a name="2542"><span class="lineNum">    2542 </span>            :    For all defining and nondefining declarations the scopes are the same, however for those that are</a>
<a name="2543"><span class="lineNum">    2543 </span>            : in namespaces the actual SgNamespaceDefinition of a defining and non-defining declaration could be</a>
<a name="2544"><span class="lineNum">    2544 </span>            : different.  To simplify analysis, the namespaces of defining and non-defining declarations are set</a>
<a name="2545"><span class="lineNum">    2545 </span>            : to the SgNamespaceDefinition of the defined declaration.  These test verify the equality of the</a>
<a name="2546"><span class="lineNum">    2546 </span>            : pointers for all scopes of defining and non-defining declarations.</a>
<a name="2547"><span class="lineNum">    2547 </span>            : </a>
<a name="2548"><span class="lineNum">    2548 </span>            : \example The following assertion is always true: \n</a>
<a name="2549"><span class="lineNum">    2549 </span>            :      assert (declaration-&gt;get_definingDeclaration()-&gt;get_scope() == declaration-&gt;get_firstNondefiningDeclaration()-&gt;get_scope());</a>
<a name="2550"><span class="lineNum">    2550 </span>            : </a>
<a name="2551"><span class="lineNum">    2551 </span>            : \subsection subsection3c Defining and nondefining declarations are non-null pointers which never match (different pointer values)</a>
<a name="2552"><span class="lineNum">    2552 </span>            : </a>
<a name="2553"><span class="lineNum">    2553 </span>            :    The following SgDeclarationStatement IR nodes never share the same declaration and are always valid (non-null) pointers.</a>
<a name="2554"><span class="lineNum">    2554 </span>            :        -# SgAsmStmt \n</a>
<a name="2555"><span class="lineNum">    2555 </span>            :           This is a not well tested declaration within Sage III (but I think that any declaration must be a defining declaration)</a>
<a name="2556"><span class="lineNum">    2556 </span>            :        -# SgFunctionParameterList</a>
<a name="2557"><span class="lineNum">    2557 </span>            :        -# SgCtorInitializerList \n</a>
<a name="2558"><span class="lineNum">    2558 </span>            :                These are special case declarations.</a>
<a name="2559"><span class="lineNum">    2559 </span>            :        -# SgVariableDefinition \n</a>
<a name="2560"><span class="lineNum">    2560 </span>            :           A variable definition appears with a variable declaration, but a variable declaration can be a</a>
<a name="2561"><span class="lineNum">    2561 </span>            :           forward reference to the variable declaration containing the variable definitions (e.g. &quot;extern int x;&quot;,</a>
<a name="2562"><span class="lineNum">    2562 </span>            :           is a forward declaration to the declaration of &quot;x&quot;).</a>
<a name="2563"><span class="lineNum">    2563 </span>            :        -# SgPragmaDeclaration \n</a>
<a name="2564"><span class="lineNum">    2564 </span>            :           A pragam can contain no references to it and so it's declaration is also it's definition</a>
<a name="2565"><span class="lineNum">    2565 </span>            :        -# SgUsingDirectiveStatement</a>
<a name="2566"><span class="lineNum">    2566 </span>            :        -# SgUsingDeclarationStatement</a>
<a name="2567"><span class="lineNum">    2567 </span>            :        -# SgNamespaceAliasDeclarationStatement</a>
<a name="2568"><span class="lineNum">    2568 </span>            :        -# SgTemplateInstantiationDirectiveStatement \n</a>
<a name="2569"><span class="lineNum">    2569 </span>            :           These can appear multiple times and are not really associated with definitions</a>
<a name="2570"><span class="lineNum">    2570 </span>            :           (but for consistancy they are consired to be their own defining declaration).</a>
<a name="2571"><span class="lineNum">    2571 </span>            :        -# SgNamespaceDeclarationStatement \n</a>
<a name="2572"><span class="lineNum">    2572 </span>            :           Namespaces can't appear without their definitions (or so it seems, and it is tested).</a>
<a name="2573"><span class="lineNum">    2573 </span>            : </a>
<a name="2574"><span class="lineNum">    2574 </span>            : \example The following assertion is true for all the above listed cases: \n</a>
<a name="2575"><span class="lineNum">    2575 </span>            :      assert (declaration-&gt;get_definingDeclaration() != NULL); \n</a>
<a name="2576"><span class="lineNum">    2576 </span>            :      assert (declaration-&gt;get_firstNondefiningDeclaration() != NULL); \n</a>
<a name="2577"><span class="lineNum">    2577 </span>            :      assert (declaration-&gt;get_definingDeclaration() != declaration-&gt;get_firstNondefiningDeclaration());</a>
<a name="2578"><span class="lineNum">    2578 </span>            : </a>
<a name="2579"><span class="lineNum">    2579 </span>            : \subsection subsection3d Defining and nondefining declarations which never match (non-defining declaration may be NULL)</a>
<a name="2580"><span class="lineNum">    2580 </span>            : </a>
<a name="2581"><span class="lineNum">    2581 </span>            :      This case is similar to \ref subsection3c but the non-defining declaration can be a null values pointer.</a>
<a name="2582"><span class="lineNum">    2582 </span>            : This is because a non-defining declaration may not exist (as in the case of a function defined with its</a>
<a name="2583"><span class="lineNum">    2583 </span>            : definition and without any function prototype)  The following cases are tested for this properly:</a>
<a name="2584"><span class="lineNum">    2584 </span>            : </a>
<a name="2585"><span class="lineNum">    2585 </span>            :        -# SgVariableDeclaration \n</a>
<a name="2586"><span class="lineNum">    2586 </span>            :           This case is a bit special.</a>
<a name="2587"><span class="lineNum">    2587 </span>            :        -# SgTemplateDeclaration</a>
<a name="2588"><span class="lineNum">    2588 </span>            :        -# SgFunctionDeclaration</a>
<a name="2589"><span class="lineNum">    2589 </span>            :           The non-defining declaration is always a valid pointer.</a>
<a name="2590"><span class="lineNum">    2590 </span>            :        -# SgClassDeclaration</a>
<a name="2591"><span class="lineNum">    2591 </span>            :        -# SgTypedefDeclaration</a>
<a name="2592"><span class="lineNum">    2592 </span>            :        -# SgMemberFunctionDeclaration</a>
<a name="2593"><span class="lineNum">    2593 </span>            :        -# SgTemplateInstantiationFunctionDecl</a>
<a name="2594"><span class="lineNum">    2594 </span>            :        -# SgTemplateInstantiationDecl</a>
<a name="2595"><span class="lineNum">    2595 </span>            :        -# SgTemplateInstantiationMemberFunctionDecl \n</a>
<a name="2596"><span class="lineNum">    2596 </span>            :           These can have forward declarations separated from their definitions</a>
<a name="2597"><span class="lineNum">    2597 </span>            :           so a declaration may be either a defining or non-defining declaration.</a>
<a name="2598"><span class="lineNum">    2598 </span>            :           All declarations, except the defining declaration, are the same object</a>
<a name="2599"><span class="lineNum">    2599 </span>            :           as the non-defining declaration if it is non-null.</a>
<a name="2600"><span class="lineNum">    2600 </span>            : </a>
<a name="2601"><span class="lineNum">    2601 </span>            : \example The following assertion is true for all the above listed cases: \n</a>
<a name="2602"><span class="lineNum">    2602 </span>            :      assert (declaration-&gt;get_definingDeclaration() != NULL); \n</a>
<a name="2603"><span class="lineNum">    2603 </span>            :      assert (declaration-&gt;get_definingDeclaration() != declaration-&gt;get_firstNondefiningDeclaration());</a>
<a name="2604"><span class="lineNum">    2604 </span>            : </a>
<a name="2605"><span class="lineNum">    2605 </span>            :  */</a>
<a name="2606"><span class="lineNum">    2606 </span>            : void</a>
<a name="2607"><span class="lineNum">    2607 </span><span class="lineCov">    5466810 : TestAstForProperlySetDefiningAndNondefiningDeclarations::visit ( SgNode* node )</span></a>
<a name="2608"><span class="lineNum">    2608 </span>            :    {</a>
<a name="2609"><span class="lineNum">    2609 </span>            :   // DQ (6/24/2005): Test setup of defining and non-defining declaration pointers for each SgDeclarationStatement</a>
<a name="2610"><span class="lineNum">    2610 </span>            : </a>
<a name="2611"><span class="lineNum">    2611 </span>            :   // printf (&quot;In TestAstForProperlySetDefiningAndNondefiningDeclarations::visit(node = %p = %s) \n&quot;,node,node-&gt;sage_class_name());</a>
<a name="2612"><span class="lineNum">    2612 </span>            : </a>
<a name="2613"><span class="lineNum">    2613 </span><span class="lineCov">    5466810 :      SgDeclarationStatement* declaration = isSgDeclarationStatement(node);</span></a>
<a name="2614"><span class="lineNum">    2614 </span><span class="lineCov">    5466810 :      SgDeclarationStatement* definingDeclaration         = NULL;</span></a>
<a name="2615"><span class="lineNum">    2615 </span><span class="lineCov">    5466810 :      SgDeclarationStatement* firstNondefiningDeclaration = NULL;</span></a>
<a name="2616"><span class="lineNum">    2616 </span><span class="lineCov">    5466810 :      if (declaration != NULL)</span></a>
<a name="2617"><span class="lineNum">    2617 </span>            :         {</a>
<a name="2618"><span class="lineNum">    2618 </span><span class="lineCov">    2248380 :           ROSE_ASSERT(declaration != NULL);</span></a>
<a name="2619"><span class="lineNum">    2619 </span>            : </a>
<a name="2620"><span class="lineNum">    2620 </span><span class="lineCov">    2248380 :           definingDeclaration         = declaration-&gt;get_definingDeclaration();</span></a>
<a name="2621"><span class="lineNum">    2621 </span><span class="lineCov">    2248380 :           firstNondefiningDeclaration = declaration-&gt;get_firstNondefiningDeclaration();</span></a>
<a name="2622"><span class="lineNum">    2622 </span>            : </a>
<a name="2623"><span class="lineNum">    2623 </span><span class="lineCov">    2248380 :           if (definingDeclaration == NULL &amp;&amp; firstNondefiningDeclaration == NULL)</span></a>
<a name="2624"><span class="lineNum">    2624 </span>            :              {</a>
<a name="2625"><span class="lineNum">    2625 </span><span class="lineNoCov">          0 :                printf (&quot;Error: TestAstForProperlySetDefiningAndNondefiningDeclarations::visit() --- declaration = %p = %s \n&quot;,declaration,declaration-&gt;class_name().c_str());</span></a>
<a name="2626"><span class="lineNum">    2626 </span>            :              }</a>
<a name="2627"><span class="lineNum">    2627 </span><span class="lineCov">    2248380 :           ROSE_ASSERT(definingDeclaration != NULL || firstNondefiningDeclaration != NULL);</span></a>
<a name="2628"><span class="lineNum">    2628 </span>            : </a>
<a name="2629"><span class="lineNum">    2629 </span>            :        // DQ (7/23/2005): The scopes should match!</a>
<a name="2630"><span class="lineNum">    2630 </span><span class="lineCov">    2248380 :           if (definingDeclaration != NULL &amp;&amp; firstNondefiningDeclaration != NULL)</span></a>
<a name="2631"><span class="lineNum">    2631 </span>            :              {</a>
<a name="2632"><span class="lineNum">    2632 </span>            :             // DQ (5/5/2007): A merged AST can have many SgGlobal (global scope) objects and we have to allow this.</a>
<a name="2633"><span class="lineNum">    2633 </span>            :             // Thus a function with a prototype declaration in one file but and both a prototype and function definition</a>
<a name="2634"><span class="lineNum">    2634 </span>            :             // in another file, will have references to different scopes (from get_scope()).  I think this is OK, but</a>
<a name="2635"><span class="lineNum">    2635 </span>            :             // output a warning for now.  And it applys more broadly to all declarations with secondary forms (defining</a>
<a name="2636"><span class="lineNum">    2636 </span>            :             // and non-defining declarations).</a>
<a name="2637"><span class="lineNum">    2637 </span>            : </a>
<a name="2638"><span class="lineNum">    2638 </span><span class="lineCov">      66756 :                SgScopeStatement* definingDeclarationScope         = definingDeclaration-&gt;get_scope();</span></a>
<a name="2639"><span class="lineNum">    2639 </span><span class="lineCov">      66756 :                SgScopeStatement* firstNondefiningDeclarationScope = firstNondefiningDeclaration-&gt;get_scope();</span></a>
<a name="2640"><span class="lineNum">    2640 </span>            : </a>
<a name="2641"><span class="lineNum">    2641 </span>            :             // DQ (10/22/2016): If these are a namespace definition then we want to check the global definition.</a>
<a name="2642"><span class="lineNum">    2642 </span><span class="lineCov">      66756 :                SgNamespaceDefinitionStatement* namespaceDefinition_defining          = isSgNamespaceDefinitionStatement(definingDeclarationScope);</span></a>
<a name="2643"><span class="lineNum">    2643 </span><span class="lineCov">      66756 :                SgNamespaceDefinitionStatement* namespaceDefinition_firstNondefining  = isSgNamespaceDefinitionStatement(firstNondefiningDeclarationScope);</span></a>
<a name="2644"><span class="lineNum">    2644 </span><span class="lineCov">      66756 :                if (namespaceDefinition_defining != NULL &amp;&amp; namespaceDefinition_firstNondefining != NULL)</span></a>
<a name="2645"><span class="lineNum">    2645 </span>            :                   {</a>
<a name="2646"><span class="lineNum">    2646 </span><span class="lineCov">      16354 :                     definingDeclarationScope         = namespaceDefinition_defining-&gt;get_global_definition();</span></a>
<a name="2647"><span class="lineNum">    2647 </span><span class="lineCov">      16354 :                     firstNondefiningDeclarationScope = namespaceDefinition_firstNondefining-&gt;get_global_definition();</span></a>
<a name="2648"><span class="lineNum">    2648 </span>            : </a>
<a name="2649"><span class="lineNum">    2649 </span>            :                  // printf (&quot;In TestAstForProperlySetDefiningAndNondefiningDeclarations::visit(): definingDeclarationScope = %p firstNondefiningDeclarationScope = %p \n&quot;,</a>
<a name="2650"><span class="lineNum">    2650 </span>            :                  //      definingDeclarationScope,firstNondefiningDeclarationScope);</a>
<a name="2651"><span class="lineNum">    2651 </span>            :                   }</a>
<a name="2652"><span class="lineNum">    2652 </span>            : </a>
<a name="2653"><span class="lineNum">    2653 </span><span class="lineCov">      66756 :                if (definingDeclarationScope != firstNondefiningDeclarationScope)</span></a>
<a name="2654"><span class="lineNum">    2654 </span>            :                   {</a>
<a name="2655"><span class="lineNum">    2655 </span>            :                  // DQ (5/10/2007): With a merged AST the primary and secondary declarations can be in different global scopes</a>
<a name="2656"><span class="lineNum">    2656 </span>            :                  // since we don't merge to a unique global scope.  So when we are checking a merged AST this is OK.</a>
<a name="2657"><span class="lineNum">    2657 </span><span class="lineNoCov">          0 :                     if (isSgGlobal(definingDeclarationScope) != NULL &amp;&amp; isSgGlobal(firstNondefiningDeclarationScope) != NULL)</span></a>
<a name="2658"><span class="lineNum">    2658 </span>            :                        {</a>
<a name="2659"><span class="lineNum">    2659 </span>            :                       // This is a case of the primary and secondary declaration in the global scope, but from different files</a>
<a name="2660"><span class="lineNum">    2660 </span>            :                       // (associated with a result of a merged AST).</a>
<a name="2661"><span class="lineNum">    2661 </span>            :                       // printf (&quot;Note: Case of definingDeclaration and firstNondefiningDeclarationScope in different SgGlobal scopes \n&quot;);</a>
<a name="2662"><span class="lineNum">    2662 </span>            :                        }</a>
<a name="2663"><span class="lineNum">    2663 </span>            :                       else</a>
<a name="2664"><span class="lineNum">    2664 </span>            :                        {</a>
<a name="2665"><span class="lineNum">    2665 </span>            :                       // But if they are not global scopes then we want to report this because it could be an error.</a>
<a name="2666"><span class="lineNum">    2666 </span><span class="lineNoCov">          0 :                          printf (&quot;\n\n******************************************************\n&quot;);</span></a>
<a name="2667"><span class="lineNum">    2667 </span><span class="lineNoCov">          0 :                          printf (&quot;Error in scope: declaration = %p = %s \n&quot;,declaration,declaration-&gt;class_name().c_str());</span></a>
<a name="2668"><span class="lineNum">    2668 </span><span class="lineNoCov">          0 :                          printf (&quot;definingDeclaration ========= %p = %s = %s: get_scope() = %p = %s = %s \n&quot;,</span></a>
<a name="2669"><span class="lineNum">    2669 </span>            :                               definingDeclaration,</a>
<a name="2670"><span class="lineNum">    2670 </span><span class="lineNoCov">          0 :                               SageInterface::get_name(definingDeclaration).c_str(),</span></a>
<a name="2671"><span class="lineNum">    2671 </span><span class="lineNoCov">          0 :                               definingDeclaration-&gt;class_name().c_str(),</span></a>
<a name="2672"><span class="lineNum">    2672 </span><span class="lineNoCov">          0 :                               definingDeclaration-&gt;get_scope(),definingDeclaration-&gt;get_scope()-&gt;class_name().c_str(),</span></a>
<a name="2673"><span class="lineNum">    2673 </span><span class="lineNoCov">          0 :                               SageInterface::get_name(definingDeclaration-&gt;get_scope()).c_str());</span></a>
<a name="2674"><span class="lineNum">    2674 </span><span class="lineNoCov">          0 :                          printf (&quot;firstNondefiningDeclaration = %p = %s = %s: get_scope() = %p = %s = %s \n&quot;,</span></a>
<a name="2675"><span class="lineNum">    2675 </span>            :                               firstNondefiningDeclaration,</a>
<a name="2676"><span class="lineNum">    2676 </span><span class="lineNoCov">          0 :                               SageInterface::get_name(firstNondefiningDeclaration).c_str(),</span></a>
<a name="2677"><span class="lineNum">    2677 </span><span class="lineNoCov">          0 :                               firstNondefiningDeclaration-&gt;class_name().c_str(),</span></a>
<a name="2678"><span class="lineNum">    2678 </span><span class="lineNoCov">          0 :                               firstNondefiningDeclaration-&gt;get_scope(),firstNondefiningDeclaration-&gt;get_scope()-&gt;class_name().c_str(),</span></a>
<a name="2679"><span class="lineNum">    2679 </span><span class="lineNoCov">          0 :                               SageInterface::get_name(firstNondefiningDeclaration-&gt;get_scope()).c_str());</span></a>
<a name="2680"><span class="lineNum">    2680 </span>            : </a>
<a name="2681"><span class="lineNum">    2681 </span><span class="lineNoCov">          0 :                          printf (&quot;definingDeclaration parent = %p = %s = %s \n&quot;,</span></a>
<a name="2682"><span class="lineNum">    2682 </span>            :                               definingDeclaration-&gt;get_parent(),</a>
<a name="2683"><span class="lineNum">    2683 </span><span class="lineNoCov">          0 :                               definingDeclaration-&gt;get_parent()-&gt;class_name().c_str(),</span></a>
<a name="2684"><span class="lineNum">    2684 </span><span class="lineNoCov">          0 :                               SageInterface::get_name(definingDeclaration-&gt;get_parent()).c_str());</span></a>
<a name="2685"><span class="lineNum">    2685 </span>            : </a>
<a name="2686"><span class="lineNum">    2686 </span>            :                       // SgFunctionDeclaration* functionDeclaration = isSgFunctionDeclaration(definingDeclaration-&gt;get_parent());</a>
<a name="2687"><span class="lineNum">    2687 </span><span class="lineNoCov">          0 :                          declaration-&gt;get_file_info()-&gt;display(&quot;location of problem declaaration&quot;);</span></a>
<a name="2688"><span class="lineNum">    2688 </span>            : </a>
<a name="2689"><span class="lineNum">    2689 </span>            :                       // DQ (3/4/3009): This test fails for test2005_118.C when run from the copyAST_tests directory (AST Copy tests).</a>
<a name="2690"><span class="lineNum">    2690 </span><span class="lineNoCov">          0 :                          if (definingDeclarationScope != firstNondefiningDeclarationScope)</span></a>
<a name="2691"><span class="lineNum">    2691 </span>            :                             {</a>
<a name="2692"><span class="lineNum">    2692 </span>            :                            // I think this might be reasonable to fail for this test of the AST Copy mechanism, but it needs to be looked into deeper.</a>
<a name="2693"><span class="lineNum">    2693 </span><span class="lineNoCov">          0 :                               printf (&quot;This test fails for test2005_118.C when run from the copyAST_tests directory (AST Copy tests) \n&quot;);</span></a>
<a name="2694"><span class="lineNum">    2694 </span>            :                             }</a>
<a name="2695"><span class="lineNum">    2695 </span>            :                       // ROSE_ASSERT(definingDeclarationScope == firstNondefiningDeclarationScope);</a>
<a name="2696"><span class="lineNum">    2696 </span>            :                        }</a>
<a name="2697"><span class="lineNum">    2697 </span>            :                   }</a>
<a name="2698"><span class="lineNum">    2698 </span>            : </a>
<a name="2699"><span class="lineNum">    2699 </span>            :            // ROSE_ASSERT(definingDeclarationScope == firstNondefiningDeclarationScope);</a>
<a name="2700"><span class="lineNum">    2700 </span>            : </a>
<a name="2701"><span class="lineNum">    2701 </span>            :            // DQ (3/1/2013): Adding test for access specification (public, protected, private).  First we need to argue that these should be the same</a>
<a name="2702"><span class="lineNum">    2702 </span>            :            // for the non-defining and defining declaration.  I am not clear that they should be the same.</a>
<a name="2703"><span class="lineNum">    2703 </span><span class="lineCov">      66756 :                SgAccessModifier::access_modifier_enum definingDeclaration_access_modifier         = definingDeclaration-&gt;get_declarationModifier().get_accessModifier().get_modifier();</span></a>
<a name="2704"><span class="lineNum">    2704 </span><span class="lineCov">      66756 :                SgAccessModifier::access_modifier_enum firstNondefiningDeclaration_access_modifier = firstNondefiningDeclaration-&gt;get_declarationModifier().get_accessModifier().get_modifier();</span></a>
<a name="2705"><span class="lineNum">    2705 </span><span class="lineCov">      66756 :                if (definingDeclaration_access_modifier != firstNondefiningDeclaration_access_modifier)</span></a>
<a name="2706"><span class="lineNum">    2706 </span>            :                   {</a>
<a name="2707"><span class="lineNum">    2707 </span>            :                  // DQ (6/30/2014): I think this is not an error for SgTemplateInstantiationDecl.</a>
<a name="2708"><span class="lineNum">    2708 </span><span class="lineCov">      13362 :                     if (isSgTemplateInstantiationDecl(definingDeclaration) != NULL)</span></a>
<a name="2709"><span class="lineNum">    2709 </span>            :                        {</a>
<a name="2710"><span class="lineNum">    2710 </span>            :                       // DQ (3/11/2017): Fixed to use message streams.</a>
<a name="2711"><span class="lineNum">    2711 </span><span class="lineCov">       2571 :                          mprintf (&quot;Warning: (different access modifiers used) definingDeclaration = %p firstNondefiningDeclaration = %p = %s  \n&quot;,definingDeclaration,firstNondefiningDeclaration,firstNondefiningDeclaration-&gt;class_name().c_str());</span></a>
<a name="2712"><span class="lineNum">    2712 </span><span class="lineCov">       2571 :                          mprintf (&quot;Warning: definingDeclaration_access_modifier         = %d \n&quot;,definingDeclaration_access_modifier);</span></a>
<a name="2713"><span class="lineNum">    2713 </span><span class="lineCov">       2571 :                          mprintf (&quot;Warning: firstNondefiningDeclaration_access_modifier = %d \n&quot;,firstNondefiningDeclaration_access_modifier);</span></a>
<a name="2714"><span class="lineNum">    2714 </span>            :                        }</a>
<a name="2715"><span class="lineNum">    2715 </span>            :                       else</a>
<a name="2716"><span class="lineNum">    2716 </span>            :                        {</a>
<a name="2717"><span class="lineNum">    2717 </span>            : #if 0</a>
<a name="2718"><span class="lineNum">    2718 </span>            :                       // DQ (1/12/2019): This is is output spew but only from Cxx_tests/rose-1541-0.C, as best I can tell.</a>
<a name="2719"><span class="lineNum">    2719 </span>            :                          printf (&quot;Error: definingDeclaration = %p firstNondefiningDeclaration = %p = %s  \n&quot;,definingDeclaration,firstNondefiningDeclaration,firstNondefiningDeclaration-&gt;class_name().c_str());</a>
<a name="2720"><span class="lineNum">    2720 </span>            : </a>
<a name="2721"><span class="lineNum">    2721 </span>            :                          firstNondefiningDeclaration-&gt;get_file_info()-&gt;display(&quot;firstNondefiningDeclaration&quot;);</a>
<a name="2722"><span class="lineNum">    2722 </span>            :                          definingDeclaration-&gt;get_file_info()-&gt;display(&quot;definingDeclaration&quot;);</a>
<a name="2723"><span class="lineNum">    2723 </span>            : </a>
<a name="2724"><span class="lineNum">    2724 </span>            :                          printf (&quot;Error: definingDeclaration_access_modifier         = %d \n&quot;,definingDeclaration_access_modifier);</a>
<a name="2725"><span class="lineNum">    2725 </span>            :                          printf (&quot;Error: firstNondefiningDeclaration_access_modifier = %d \n&quot;,firstNondefiningDeclaration_access_modifier);</a>
<a name="2726"><span class="lineNum">    2726 </span>            : #endif</a>
<a name="2727"><span class="lineNum">    2727 </span>            :                        }</a>
<a name="2728"><span class="lineNum">    2728 </span>            :                   }</a>
<a name="2729"><span class="lineNum">    2729 </span>            : </a>
<a name="2730"><span class="lineNum">    2730 </span>            : #if 0</a>
<a name="2731"><span class="lineNum">    2731 </span>            :             // DQ (8/14/2020): After redesiging how access modifiers are set, we want to allow the defining and non-defigning declarations to have different access specifications.</a>
<a name="2732"><span class="lineNum">    2732 </span>            :             // DQ (6/30/2014): I think this is not an error for SgTemplateInstantiationDecl.</a>
<a name="2733"><span class="lineNum">    2733 </span>            :             // ROSE_ASSERT(definingDeclaration_access_modifier == firstNondefiningDeclaration_access_modifier);</a>
<a name="2734"><span class="lineNum">    2734 </span>            :                if (isSgTemplateInstantiationDecl(definingDeclaration) == NULL &amp;&amp; firstNondefiningDeclaration-&gt;get_parent() == definingDeclaration-&gt;get_parent())</a>
<a name="2735"><span class="lineNum">    2735 </span>            :                   {</a>
<a name="2736"><span class="lineNum">    2736 </span>            :                  // DQ (8/11/2020): Debugging new change to e_default = e_public was changed from e_default = 4.</a>
<a name="2737"><span class="lineNum">    2737 </span>            :                     if (definingDeclaration_access_modifier != firstNondefiningDeclaration_access_modifier)</a>
<a name="2738"><span class="lineNum">    2738 </span>            :                        {</a>
<a name="2739"><span class="lineNum">    2739 </span>            : #if 0</a>
<a name="2740"><span class="lineNum">    2740 </span>            :                          printf (&quot;Error: in AST consistancy tests: definingDeclaration_access_modifier != firstNondefiningDeclaration_access_modifier \n&quot;);</a>
<a name="2741"><span class="lineNum">    2741 </span>            : #endif</a>
<a name="2742"><span class="lineNum">    2742 </span>            : #if 0</a>
<a name="2743"><span class="lineNum">    2743 </span>            :                          printf (&quot; --- definingDeclaration = %p = %s \n&quot;,definingDeclaration,definingDeclaration-&gt;class_name().c_str());</a>
<a name="2744"><span class="lineNum">    2744 </span>            :                          printf (&quot; --- definingDeclaration_access_modifier         = %d \n&quot;,definingDeclaration_access_modifier);</a>
<a name="2745"><span class="lineNum">    2745 </span>            :                          definingDeclaration-&gt;get_declarationModifier().get_accessModifier().display(&quot;definingDeclaration: definingDeclaration_access_modifier != firstNondefiningDeclaration_access_modifier&quot;);</a>
<a name="2746"><span class="lineNum">    2746 </span>            :                          definingDeclaration-&gt;get_file_info()-&gt;display(&quot;definingDeclaration&quot;);</a>
<a name="2747"><span class="lineNum">    2747 </span>            :                          printf (&quot; --- firstNondefiningDeclaration_access_modifier = %d \n&quot;,firstNondefiningDeclaration_access_modifier);</a>
<a name="2748"><span class="lineNum">    2748 </span>            :                          printf (&quot; --- firstNondefiningDeclaration = %p = %s \n&quot;,firstNondefiningDeclaration,firstNondefiningDeclaration-&gt;class_name().c_str());</a>
<a name="2749"><span class="lineNum">    2749 </span>            :                          firstNondefiningDeclaration-&gt;get_declarationModifier().get_accessModifier().display(&quot;firstNondefiningDeclaration: definingDeclaration_access_modifier != firstNondefiningDeclaration_access_modifier&quot;);</a>
<a name="2750"><span class="lineNum">    2750 </span>            :                          firstNondefiningDeclaration-&gt;get_file_info()-&gt;display(&quot;firstNondefiningDeclaration&quot;);</a>
<a name="2751"><span class="lineNum">    2751 </span>            :                       // definingDeclaration_access_modifier.display(&quot;definingDeclaration: definingDeclaration_access_modifier != firstNondefiningDeclaration_access_modifier&quot;);</a>
<a name="2752"><span class="lineNum">    2752 </span>            :                       // firstNondefiningDeclaration_access_modifier.display(&quot;firstNondefiningDeclaration: definingDeclaration_access_modifier != firstNondefiningDeclaration_access_modifier&quot;);</a>
<a name="2753"><span class="lineNum">    2753 </span>            : #endif</a>
<a name="2754"><span class="lineNum">    2754 </span>            :                        }</a>
<a name="2755"><span class="lineNum">    2755 </span>            : </a>
<a name="2756"><span class="lineNum">    2756 </span>            :                  // DQ (8/11/2020): Test by commenting this out.  It might not make since to enforce this.</a>
<a name="2757"><span class="lineNum">    2757 </span>            :                  // ROSE_ASSERT(definingDeclaration_access_modifier == firstNondefiningDeclaration_access_modifier);</a>
<a name="2758"><span class="lineNum">    2758 </span>            :                   }</a>
<a name="2759"><span class="lineNum">    2759 </span>            : #endif</a>
<a name="2760"><span class="lineNum">    2760 </span>            :              }</a>
<a name="2761"><span class="lineNum">    2761 </span>            :         }</a>
<a name="2762"><span class="lineNum">    2762 </span>            : </a>
<a name="2763"><span class="lineNum">    2763 </span><span class="lineCov">    5466810 :      switch (node-&gt;variantT())</span></a>
<a name="2764"><span class="lineNum">    2764 </span>            :         {</a>
<a name="2765"><span class="lineNum">    2765 </span>            :           case V_SgEnumDeclaration:</a>
<a name="2766"><span class="lineNum">    2766 </span>            :              {</a>
<a name="2767"><span class="lineNum">    2767 </span>            :             // DQ (6/26/2005): Special case of enum declarations (no forward</a>
<a name="2768"><span class="lineNum">    2768 </span>            :             // enum declarations are allowed in the C or C++ standard).</a>
<a name="2769"><span class="lineNum">    2769 </span>            :             // ROSE_ASSERT(declaration == definingDeclaration);</a>
<a name="2770"><span class="lineNum">    2770 </span>            :                if (declaration != definingDeclaration)</a>
<a name="2771"><span class="lineNum">    2771 </span>            :                   {</a>
<a name="2772"><span class="lineNum">    2772 </span>            : #if PRINT_DEVELOPER_WARNINGS</a>
<a name="2773"><span class="lineNum">    2773 </span>            :                     printf (&quot;Note in AstConsistencyTests.C, enum declaration not a defining declaration \n&quot;);</a>
<a name="2774"><span class="lineNum">    2774 </span>            :                  // declaration-&gt;get_startOfConstruct()-&gt;display(&quot;declaration != definingDeclaration for enum declaration&quot;);</a>
<a name="2775"><span class="lineNum">    2775 </span>            : #endif</a>
<a name="2776"><span class="lineNum">    2776 </span>            :                   }</a>
<a name="2777"><span class="lineNum">    2777 </span>            :                break;</a>
<a name="2778"><span class="lineNum">    2778 </span>            :              }</a>
<a name="2779"><span class="lineNum">    2779 </span>            : </a>
<a name="2780"><span class="lineNum">    2780 </span>            :        // DQ (9/6/2005): Ignoring this case!</a>
<a name="2781"><span class="lineNum">    2781 </span>            :           case V_SgFunctionParameterList:</a>
<a name="2782"><span class="lineNum">    2782 </span>            :              {</a>
<a name="2783"><span class="lineNum">    2783 </span>            :                break;</a>
<a name="2784"><span class="lineNum">    2784 </span>            :              }</a>
<a name="2785"><span class="lineNum">    2785 </span>            : </a>
<a name="2786"><span class="lineNum">    2786 </span>            :        // DQ (6/26/2005): These are likely somewhat special and such that they should be their own defining declarations, I think</a>
<a name="2787"><span class="lineNum">    2787 </span>            : </a>
<a name="2788"><span class="lineNum">    2788 </span>            :        // This is a not well tested declaration within Sage III (but I think that any declaration must be a defining declaration)</a>
<a name="2789"><span class="lineNum">    2789 </span><span class="lineCov">      28163 :           case V_SgAsmStmt:</span></a>
<a name="2790"><span class="lineNum">    2790 </span>            : </a>
<a name="2791"><span class="lineNum">    2791 </span>            :        // These are special case declarations</a>
<a name="2792"><span class="lineNum">    2792 </span>            :        // case V_SgFunctionParameterList:</a>
<a name="2793"><span class="lineNum">    2793 </span><span class="lineCov">      28163 :           case V_SgCtorInitializerList:</span></a>
<a name="2794"><span class="lineNum">    2794 </span><span class="lineCov">      28163 :           case V_SgFortranIncludeLine:</span></a>
<a name="2795"><span class="lineNum">    2795 </span>            : </a>
<a name="2796"><span class="lineNum">    2796 </span>            :        // A variable definition appears with a variable declaration, but a variable declaration can be a</a>
<a name="2797"><span class="lineNum">    2797 </span>            :        // forward reference to the variable declaration containing the variable definitions (e.g. &quot;extern int x;&quot;,</a>
<a name="2798"><span class="lineNum">    2798 </span>            :        // is a forward declaration to the declaration of &quot;x&quot;).</a>
<a name="2799"><span class="lineNum">    2799 </span><span class="lineCov">      28163 :           case V_SgVariableDefinition:</span></a>
<a name="2800"><span class="lineNum">    2800 </span>            : </a>
<a name="2801"><span class="lineNum">    2801 </span>            :        // A pragam can contain no references to it and so it's declaration is also it's definition</a>
<a name="2802"><span class="lineNum">    2802 </span><span class="lineCov">      28163 :           case V_SgPragmaDeclaration:</span></a>
<a name="2803"><span class="lineNum">    2803 </span>            : </a>
<a name="2804"><span class="lineNum">    2804 </span>            :        // These can appear multiple times and are not really associated with definitions</a>
<a name="2805"><span class="lineNum">    2805 </span>            :        // (but for consistency they are considered to be their own defining declaration).</a>
<a name="2806"><span class="lineNum">    2806 </span><span class="lineCov">      28163 :           case V_SgUsingDirectiveStatement:</span></a>
<a name="2807"><span class="lineNum">    2807 </span><span class="lineCov">      28163 :           case V_SgUsingDeclarationStatement:</span></a>
<a name="2808"><span class="lineNum">    2808 </span><span class="lineCov">      28163 :           case V_SgNamespaceAliasDeclarationStatement:</span></a>
<a name="2809"><span class="lineNum">    2809 </span><span class="lineCov">      28163 :           case V_SgTemplateInstantiationDirectiveStatement:</span></a>
<a name="2810"><span class="lineNum">    2810 </span>            : </a>
<a name="2811"><span class="lineNum">    2811 </span>            :        // Shared by all the above cases!</a>
<a name="2812"><span class="lineNum">    2812 </span><span class="lineCov">      28163 :              {</span></a>
<a name="2813"><span class="lineNum">    2813 </span>            :             // DQ (6/26/2005): I think that the C++ standard does not allow forward declarations for these either!</a>
<a name="2814"><span class="lineNum">    2814 </span>            :             // So the defining declaration should be the declaration itself (I think).  either that or we need to</a>
<a name="2815"><span class="lineNum">    2815 </span>            :             // build a special non-defining declaration for these declarations.</a>
<a name="2816"><span class="lineNum">    2816 </span><span class="lineCov">      28163 :                if (declaration != definingDeclaration)</span></a>
<a name="2817"><span class="lineNum">    2817 </span>            :                   {</a>
<a name="2818"><span class="lineNum">    2818 </span><span class="lineNoCov">          0 :                     printf (&quot;declaration = %p (%s)\n&quot;,</span></a>
<a name="2819"><span class="lineNum">    2819 </span>            :                                  declaration,</a>
<a name="2820"><span class="lineNum">    2820 </span><span class="lineNoCov">          0 :                                  declaration-&gt;class_name().c_str());</span></a>
<a name="2821"><span class="lineNum">    2821 </span><span class="lineNoCov">          0 :                     if (definingDeclaration) {</span></a>
<a name="2822"><span class="lineNum">    2822 </span><span class="lineNoCov">          0 :                       printf (&quot;definingDeclaration = %p (%s)\n&quot;,</span></a>
<a name="2823"><span class="lineNum">    2823 </span>            :                                    definingDeclaration,</a>
<a name="2824"><span class="lineNum">    2824 </span><span class="lineNoCov">          0 :                                    definingDeclaration-&gt;class_name().c_str());</span></a>
<a name="2825"><span class="lineNum">    2825 </span>            :                     }</a>
<a name="2826"><span class="lineNum">    2826 </span><span class="lineNoCov">          0 :                     if (declaration-&gt;get_definingDeclaration()) {</span></a>
<a name="2827"><span class="lineNum">    2827 </span><span class="lineNoCov">          0 :                       printf (&quot;declaration-&gt;get_definingDeclaration() = %p (%s)\n&quot;,</span></a>
<a name="2828"><span class="lineNum">    2828 </span>            :                                    declaration-&gt;get_definingDeclaration(),</a>
<a name="2829"><span class="lineNum">    2829 </span><span class="lineNoCov">          0 :                                    declaration-&gt;get_definingDeclaration()-&gt;class_name().c_str());</span></a>
<a name="2830"><span class="lineNum">    2830 </span>            :                     }</a>
<a name="2831"><span class="lineNum">    2831 </span><span class="lineNoCov">          0 :                     if (declaration-&gt;get_firstNondefiningDeclaration()) {</span></a>
<a name="2832"><span class="lineNum">    2832 </span><span class="lineNoCov">          0 :                       printf (&quot;declaration-&gt;get_firstNondefiningDeclaration() = %p (%s)\n&quot;,</span></a>
<a name="2833"><span class="lineNum">    2833 </span>            :                                    declaration-&gt;get_firstNondefiningDeclaration(),</a>
<a name="2834"><span class="lineNum">    2834 </span><span class="lineNoCov">          0 :                                    declaration-&gt;get_firstNondefiningDeclaration()-&gt;class_name().c_str());</span></a>
<a name="2835"><span class="lineNum">    2835 </span>            :                     }</a>
<a name="2836"><span class="lineNum">    2836 </span>            :                   }</a>
<a name="2837"><span class="lineNum">    2837 </span><span class="lineCov">      28163 :                ROSE_ASSERT(declaration == definingDeclaration);</span></a>
<a name="2838"><span class="lineNum">    2838 </span><span class="lineCov">      28163 :                break;</span></a>
<a name="2839"><span class="lineNum">    2839 </span>            :              }</a>
<a name="2840"><span class="lineNum">    2840 </span>            : </a>
<a name="2841"><span class="lineNum">    2841 </span>            :        // Namespaces can't appear without their definitions (or so it seems, tested).</a>
<a name="2842"><span class="lineNum">    2842 </span>            :        // Since there can be many declarations of the same namespace the definingDeclaration</a>
<a name="2843"><span class="lineNum">    2843 </span>            :        // is always NULL (only for SgNamespaceDeclarationStatement)</a>
<a name="2844"><span class="lineNum">    2844 </span><span class="lineCov">        815 :           case V_SgNamespaceDeclarationStatement:</span></a>
<a name="2845"><span class="lineNum">    2845 </span><span class="lineCov">        815 :              {</span></a>
<a name="2846"><span class="lineNum">    2846 </span><span class="lineCov">        815 :                ROSE_ASSERT(declaration != NULL);</span></a>
<a name="2847"><span class="lineNum">    2847 </span><span class="lineCov">        815 :                ROSE_ASSERT(definingDeclaration == NULL);</span></a>
<a name="2848"><span class="lineNum">    2848 </span><span class="lineCov">        815 :                ROSE_ASSERT(firstNondefiningDeclaration != NULL);</span></a>
<a name="2849"><span class="lineNum">    2849 </span><span class="lineCov">        815 :                break;</span></a>
<a name="2850"><span class="lineNum">    2850 </span>            :              }</a>
<a name="2851"><span class="lineNum">    2851 </span>            : </a>
<a name="2852"><span class="lineNum">    2852 </span>            :        // This case is a bit special</a>
<a name="2853"><span class="lineNum">    2853 </span><span class="lineCov">    1138080 :           case V_SgVariableDeclaration:</span></a>
<a name="2854"><span class="lineNum">    2854 </span>            : </a>
<a name="2855"><span class="lineNum">    2855 </span>            :        // These can have forward declarations separated from their definitions</a>
<a name="2856"><span class="lineNum">    2856 </span>            :        // so a declaration may be either a defining or non-defining declaration.</a>
<a name="2857"><span class="lineNum">    2857 </span><span class="lineCov">    1138080 :           case V_SgTemplateDeclaration:</span></a>
<a name="2858"><span class="lineNum">    2858 </span><span class="lineCov">    1138080 :           case V_SgFunctionDeclaration:</span></a>
<a name="2859"><span class="lineNum">    2859 </span><span class="lineCov">    1138080 :           case V_SgClassDeclaration:</span></a>
<a name="2860"><span class="lineNum">    2860 </span><span class="lineCov">    1138080 :           case V_SgDerivedTypeStatement:</span></a>
<a name="2861"><span class="lineNum">    2861 </span><span class="lineCov">    1138080 :           case V_SgTypedefDeclaration:</span></a>
<a name="2862"><span class="lineNum">    2862 </span><span class="lineCov">    1138080 :           case V_SgMemberFunctionDeclaration:</span></a>
<a name="2863"><span class="lineNum">    2863 </span><span class="lineCov">    1138080 :           case V_SgTemplateInstantiationFunctionDecl:</span></a>
<a name="2864"><span class="lineNum">    2864 </span><span class="lineCov">    1138080 :           case V_SgTemplateInstantiationDecl:</span></a>
<a name="2865"><span class="lineNum">    2865 </span><span class="lineCov">    1138080 :           case V_SgTemplateInstantiationMemberFunctionDecl:</span></a>
<a name="2866"><span class="lineNum">    2866 </span>            :           // Liao 12/2/2010, add new Fortran function nodes</a>
<a name="2867"><span class="lineNum">    2867 </span><span class="lineCov">    1138080 :           case V_SgProcedureHeaderStatement:</span></a>
<a name="2868"><span class="lineNum">    2868 </span><span class="lineCov">    1138080 :           case V_SgProgramHeaderStatement:</span></a>
<a name="2869"><span class="lineNum">    2869 </span><span class="lineCov">    1138080 :              {</span></a>
<a name="2870"><span class="lineNum">    2870 </span>            :             // For some declarations, the only declaration is a defining declaration, in which case the</a>
<a name="2871"><span class="lineNum">    2871 </span>            :             // non-defining declaration is NULL (except in the case of SgClassDeclarations, where a</a>
<a name="2872"><span class="lineNum">    2872 </span>            :             // non-defining declarations in generated internally).</a>
<a name="2873"><span class="lineNum">    2873 </span><span class="lineCov">    1138080 :                if (firstNondefiningDeclaration == NULL)</span></a>
<a name="2874"><span class="lineNum">    2874 </span>            :                   {</a>
<a name="2875"><span class="lineNum">    2875 </span>            :                  // DQ (8/11/2020): Fixed compiler warning.</a>
<a name="2876"><span class="lineNum">    2876 </span>            :                  // ROSE_ASSERT(declaration-&gt;variantT() != NULL);</a>
<a name="2877"><span class="lineNum">    2877 </span><span class="lineCov">        434 :                     ROSE_ASSERT(declaration != NULL);</span></a>
<a name="2878"><span class="lineNum">    2878 </span><span class="lineCov">        434 :                     switch (declaration-&gt;variantT())</span></a>
<a name="2879"><span class="lineNum">    2879 </span>            :                        {</a>
<a name="2880"><span class="lineNum">    2880 </span>            :                       // These nodes should have a non-defining declaration even if only a defining</a>
<a name="2881"><span class="lineNum">    2881 </span>            :                       // declaration is present in the source code.  It may be that the other IR</a>
<a name="2882"><span class="lineNum">    2882 </span>            :                       // nodes below should be treated similarly.</a>
<a name="2883"><span class="lineNum">    2883 </span><span class="lineNoCov">          0 :                          case V_SgClassDeclaration:</span></a>
<a name="2884"><span class="lineNum">    2884 </span><span class="lineNoCov">          0 :                          case V_SgDerivedTypeStatement:</span></a>
<a name="2885"><span class="lineNum">    2885 </span><span class="lineNoCov">          0 :                          case V_SgTemplateInstantiationDecl:</span></a>
<a name="2886"><span class="lineNum">    2886 </span><span class="lineNoCov">          0 :                             {</span></a>
<a name="2887"><span class="lineNum">    2887 </span><span class="lineNoCov">          0 :                               printf (&quot;Warning AST Consistancy Test: declaration %p = %s has no firstNondefiningDeclaration = %p \n&quot;,</span></a>
<a name="2888"><span class="lineNum">    2888 </span><span class="lineNoCov">          0 :                                    declaration,declaration-&gt;sage_class_name(),firstNondefiningDeclaration);</span></a>
<a name="2889"><span class="lineNum">    2889 </span><span class="lineNoCov">          0 :                               declaration-&gt;get_file_info()-&gt;display(&quot;has no firstNondefiningDeclaration&quot;);</span></a>
<a name="2890"><span class="lineNum">    2890 </span><span class="lineNoCov">          0 :                               break;</span></a>
<a name="2891"><span class="lineNum">    2891 </span>            :                             }</a>
<a name="2892"><span class="lineNum">    2892 </span>            : </a>
<a name="2893"><span class="lineNum">    2893 </span>            :                          case V_SgTemplateDeclaration:</a>
<a name="2894"><span class="lineNum">    2894 </span>            :                          case V_SgTypedefDeclaration:</a>
<a name="2895"><span class="lineNum">    2895 </span>            :                             {</a>
<a name="2896"><span class="lineNum">    2896 </span>            :                            // These are special cases</a>
<a name="2897"><span class="lineNum">    2897 </span>            :                               break;</a>
<a name="2898"><span class="lineNum">    2898 </span>            :                             }</a>
<a name="2899"><span class="lineNum">    2899 </span>            : </a>
<a name="2900"><span class="lineNum">    2900 </span><span class="lineCov">         36 :                          case V_SgFunctionDeclaration:</span></a>
<a name="2901"><span class="lineNum">    2901 </span><span class="lineCov">         36 :                          case V_SgMemberFunctionDeclaration:</span></a>
<a name="2902"><span class="lineNum">    2902 </span><span class="lineCov">         36 :                          case V_SgTemplateInstantiationFunctionDecl:</span></a>
<a name="2903"><span class="lineNum">    2903 </span><span class="lineCov">         36 :                          case V_SgTemplateInstantiationMemberFunctionDecl:</span></a>
<a name="2904"><span class="lineNum">    2904 </span><span class="lineCov">         36 :                          case V_SgProcedureHeaderStatement:</span></a>
<a name="2905"><span class="lineNum">    2905 </span><span class="lineCov">         36 :                          case V_SgProgramHeaderStatement:</span></a>
<a name="2906"><span class="lineNum">    2906 </span><span class="lineCov">         36 :                             {</span></a>
<a name="2907"><span class="lineNum">    2907 </span>            :                            // This is the reasonable case, where a function or template or typedef is</a>
<a name="2908"><span class="lineNum">    2908 </span>            :                            // declared once (and only once and contains its definition).  Verify that</a>
<a name="2909"><span class="lineNum">    2909 </span>            :                            // the definition is present!</a>
<a name="2910"><span class="lineNum">    2910 </span><span class="lineCov">         36 :                               SgFunctionDeclaration* functionDeclaration = isSgFunctionDeclaration(declaration);</span></a>
<a name="2911"><span class="lineNum">    2911 </span><span class="lineCov">         36 :                               ROSE_ASSERT(functionDeclaration != NULL);</span></a>
<a name="2912"><span class="lineNum">    2912 </span>            : #if PRINT_DEVELOPER_WARNINGS</a>
<a name="2913"><span class="lineNum">    2913 </span>            :                            // DQ (4/23/2006): See PolyhedralSideBaseMethods.cc for example of where this happens.</a>
<a name="2914"><span class="lineNum">    2914 </span>            :                               if (functionDeclaration-&gt;get_definition() == NULL)</a>
<a name="2915"><span class="lineNum">    2915 </span>            :                                  {</a>
<a name="2916"><span class="lineNum">    2916 </span>            :                                    printf (&quot;This declaration (%p %s) has no non-defining declaration and thus should be a defining declaration, but it has no definition \n&quot;,</a>
<a name="2917"><span class="lineNum">    2917 </span>            :                                         functionDeclaration,functionDeclaration-&gt;class_name().c_str());</a>
<a name="2918"><span class="lineNum">    2918 </span>            :                                    functionDeclaration-&gt;get_file_info()-&gt;display(&quot;defining declaration lacking definition&quot;);</a>
<a name="2919"><span class="lineNum">    2919 </span>            :                                  }</a>
<a name="2920"><span class="lineNum">    2920 </span>            : #endif</a>
<a name="2921"><span class="lineNum">    2921 </span>            :                            // DQ (8/10/2005): Commented out to compile KULL</a>
<a name="2922"><span class="lineNum">    2922 </span>            :                            // ROSE_ASSERT(functionDeclaration-&gt;get_definition() != NULL);</a>
<a name="2923"><span class="lineNum">    2923 </span><span class="lineCov">         36 :                               break;</span></a>
<a name="2924"><span class="lineNum">    2924 </span>            :                             }</a>
<a name="2925"><span class="lineNum">    2925 </span>            : </a>
<a name="2926"><span class="lineNum">    2926 </span><span class="lineCov">        398 :                          default:</span></a>
<a name="2927"><span class="lineNum">    2927 </span><span class="lineCov">        398 :                             {</span></a>
<a name="2928"><span class="lineNum">    2928 </span>            :                            // Nothing to do here!</a>
<a name="2929"><span class="lineNum">    2929 </span>            :                             }</a>
<a name="2930"><span class="lineNum">    2930 </span>            : </a>
<a name="2931"><span class="lineNum">    2931 </span>            :                       // And the defining declaration is the current definition</a>
<a name="2932"><span class="lineNum">    2932 </span><span class="lineCov">        398 :                          ROSE_ASSERT(declaration == definingDeclaration);</span></a>
<a name="2933"><span class="lineNum">    2933 </span>            :                        }</a>
<a name="2934"><span class="lineNum">    2934 </span>            : #if 0</a>
<a name="2935"><span class="lineNum">    2935 </span>            :                     SgFunctionDeclaration* functionDeclaration = isSgFunctionDeclaration(declaration);</a>
<a name="2936"><span class="lineNum">    2936 </span>            :                     if (functionDeclaration != NULL)</a>
<a name="2937"><span class="lineNum">    2937 </span>            :                        {</a>
<a name="2938"><span class="lineNum">    2938 </span>            :                       // This is the reasonable case, where a function is declared once (and only once and</a>
<a name="2939"><span class="lineNum">    2939 </span>            :                       // contains it's definition).  Verify that the function definition is present!</a>
<a name="2940"><span class="lineNum">    2940 </span>            :                          ROSE_ASSERT(functionDeclaration-&gt;get_definition() != NULL);</a>
<a name="2941"><span class="lineNum">    2941 </span>            :                        }</a>
<a name="2942"><span class="lineNum">    2942 </span>            :                       else</a>
<a name="2943"><span class="lineNum">    2943 </span>            :                        {</a>
<a name="2944"><span class="lineNum">    2944 </span>            : #if 1</a>
<a name="2945"><span class="lineNum">    2945 </span>            :                          printf (&quot;Warning AST Consistancy Test: declaration %p = %s has no firstNondefiningDeclaration = %p \n&quot;,</a>
<a name="2946"><span class="lineNum">    2946 </span>            :                               declaration,declaration-&gt;sage_class_name(),firstNondefiningDeclaration);</a>
<a name="2947"><span class="lineNum">    2947 </span>            :                          declaration-&gt;get_file_info()-&gt;display(&quot;has no firstNondefiningDeclaration&quot;);</a>
<a name="2948"><span class="lineNum">    2948 </span>            : #endif</a>
<a name="2949"><span class="lineNum">    2949 </span>            :                        }</a>
<a name="2950"><span class="lineNum">    2950 </span>            : #endif</a>
<a name="2951"><span class="lineNum">    2951 </span>            :                   }</a>
<a name="2952"><span class="lineNum">    2952 </span>            :             // ROSE_ASSERT(firstNondefiningDeclaration != NULL);</a>
<a name="2953"><span class="lineNum">    2953 </span><span class="lineCov">    1138080 :                if (firstNondefiningDeclaration == definingDeclaration)</span></a>
<a name="2954"><span class="lineNum">    2954 </span>            :                   {</a>
<a name="2955"><span class="lineNum">    2955 </span>            :                  // DQ (12/12/2009): Suppress the warning about this for the case of a</a>
<a name="2956"><span class="lineNum">    2956 </span>            :                  // SgTypedefDeclaration if not set to verbose mode. This is important to</a>
<a name="2957"><span class="lineNum">    2957 </span>            :                  // reducing the output from the tests of AST merge in the mergeAST_tests</a>
<a name="2958"><span class="lineNum">    2958 </span>            :                  // directory.</a>
<a name="2959"><span class="lineNum">    2959 </span><span class="lineNoCov">          0 :                     SgTypedefDeclaration* typedefDeclaration = isSgTypedefDeclaration(declaration);</span></a>
<a name="2960"><span class="lineNum">    2960 </span><span class="lineNoCov">          0 :                     if (typedefDeclaration == NULL || (SgProject::get_verbose() &gt; 0) )</span></a>
<a name="2961"><span class="lineNum">    2961 </span>            :                        {</a>
<a name="2962"><span class="lineNum">    2962 </span><span class="lineNoCov">          0 :                          printf (&quot;Warning AST Consistency Test: declaration %p = %s = %s has equal firstNondefiningDeclaration and definingDeclaration = %p \n&quot;,</span></a>
<a name="2963"><span class="lineNum">    2963 </span><span class="lineNoCov">          0 :                               declaration,declaration-&gt;class_name().c_str(),SageInterface::get_name(declaration).c_str(),firstNondefiningDeclaration);</span></a>
<a name="2964"><span class="lineNum">    2964 </span><span class="lineNoCov">          0 :                          printf (&quot;declaration-&gt;get_definingDeclaration() = %p declaration-&gt;get_firstNondefiningDeclaration() = %p \n&quot;,</span></a>
<a name="2965"><span class="lineNum">    2965 </span>            :                               declaration-&gt;get_definingDeclaration(),declaration-&gt;get_firstNondefiningDeclaration());</a>
<a name="2966"><span class="lineNum">    2966 </span><span class="lineNoCov">          0 :                          declaration-&gt;get_file_info()-&gt;display(&quot;firstNondefiningDeclaration == definingDeclaration: debug&quot;);</span></a>
<a name="2967"><span class="lineNum">    2967 </span>            : </a>
<a name="2968"><span class="lineNum">    2968 </span>            :                          // Liao 12/2/2010</a>
<a name="2969"><span class="lineNum">    2969 </span>            :                          //  A test to see if the first nondefining declaration is set to self for a defining function declaration</a>
<a name="2970"><span class="lineNum">    2970 </span><span class="lineNoCov">          0 :                          SgFunctionDeclaration * func = isSgFunctionDeclaration(declaration);</span></a>
<a name="2971"><span class="lineNum">    2971 </span><span class="lineNoCov">          0 :                          if(func != NULL)</span></a>
<a name="2972"><span class="lineNum">    2972 </span>            :                          {</a>
<a name="2973"><span class="lineNum">    2973 </span><span class="lineNoCov">          0 :                            printf (&quot;Error: found a defining function declaration with its first nondefining declaration set to itself/(or a defining declaration).\n&quot;);</span></a>
<a name="2974"><span class="lineNum">    2974 </span>            :                            //ROSE_ASSERT (false);</a>
<a name="2975"><span class="lineNum">    2975 </span>            :                          }</a>
<a name="2976"><span class="lineNum">    2976 </span>            : </a>
<a name="2977"><span class="lineNum">    2977 </span>            :                        }</a>
<a name="2978"><span class="lineNum">    2978 </span>            :                   } // end if nondefining == defining</a>
<a name="2979"><span class="lineNum">    2979 </span>            : </a>
<a name="2980"><span class="lineNum">    2980 </span>            :             // DQ (8/6/2007): Comment this out, at least for SgTypedefDeclaration it should be OK, MAYBE.</a>
<a name="2981"><span class="lineNum">    2981 </span>            :             // DQ (3/4/2007): Temporarily commented out (now uncommented)</a>
<a name="2982"><span class="lineNum">    2982 </span>            :             // ROSE_ASSERT(firstNondefiningDeclaration != definingDeclaration);</a>
<a name="2983"><span class="lineNum">    2983 </span>            :                break;</a>
<a name="2984"><span class="lineNum">    2984 </span>            :              }</a>
<a name="2985"><span class="lineNum">    2985 </span>            : </a>
<a name="2986"><span class="lineNum">    2986 </span><span class="lineCov">    5466810 :           default:</span></a>
<a name="2987"><span class="lineNum">    2987 </span><span class="lineCov">    5466810 :              {</span></a>
<a name="2988"><span class="lineNum">    2988 </span>            :             // Nothing to do here!</a>
<a name="2989"><span class="lineNum">    2989 </span>            :              }</a>
<a name="2990"><span class="lineNum">    2990 </span>            :         }</a>
<a name="2991"><span class="lineNum">    2991 </span>            : </a>
<a name="2992"><span class="lineNum">    2992 </span><span class="lineCov">    5466810 :    }</span></a>
<a name="2993"><span class="lineNum">    2993 </span>            : </a>
<a name="2994"><span class="lineNum">    2994 </span>            : void</a>
<a name="2995"><span class="lineNum">    2995 </span><span class="lineCov">    5466810 : TestAstSymbolTables::visit ( SgNode* node )</span></a>
<a name="2996"><span class="lineNum">    2996 </span>            :    {</a>
<a name="2997"><span class="lineNum">    2997 </span>            : #if 0</a>
<a name="2998"><span class="lineNum">    2998 </span>            :      printf (&quot;At TOP of TestAstSymbolTables::visit(): node = %p = %s \n&quot;,node,node-&gt;class_name().c_str());</a>
<a name="2999"><span class="lineNum">    2999 </span>            : #endif</a>
<a name="3000"><span class="lineNum">    3000 </span>            : </a>
<a name="3001"><span class="lineNum">    3001 </span><span class="lineCov">    5466810 :      SgScopeStatement* scope = isSgScopeStatement(node);</span></a>
<a name="3002"><span class="lineNum">    3002 </span><span class="lineCov">    5466810 :      if (scope != NULL)</span></a>
<a name="3003"><span class="lineNum">    3003 </span>            :         {</a>
<a name="3004"><span class="lineNum">    3004 </span><span class="lineCov">      51305 :           SgSymbolTable* symbolTable = scope-&gt;get_symbol_table();</span></a>
<a name="3005"><span class="lineNum">    3005 </span><span class="lineCov">      51305 :           if (symbolTable == NULL)</span></a>
<a name="3006"><span class="lineNum">    3006 </span>            :              {</a>
<a name="3007"><span class="lineNum">    3007 </span><span class="lineNoCov">          0 :                printf (&quot;Error: symbolTable == NULL, no symbol table found at node = %p = %s \n&quot;,node,node-&gt;class_name().c_str());</span></a>
<a name="3008"><span class="lineNum">    3008 </span>            :              }</a>
<a name="3009"><span class="lineNum">    3009 </span><span class="lineCov">      51305 :           ROSE_ASSERT(symbolTable != NULL);</span></a>
<a name="3010"><span class="lineNum">    3010 </span><span class="lineCov">      51305 :           if (symbolTable-&gt;get_table() == NULL)</span></a>
<a name="3011"><span class="lineNum">    3011 </span>            :              {</a>
<a name="3012"><span class="lineNum">    3012 </span><span class="lineNoCov">          0 :                printf (&quot;Error: symbolTable-&gt;get_table() == NULL, no symbol table found at node = %p = %s \n&quot;,node,node-&gt;class_name().c_str());</span></a>
<a name="3013"><span class="lineNum">    3013 </span>            :              }</a>
<a name="3014"><span class="lineNum">    3014 </span><span class="lineCov">      51305 :           ROSE_ASSERT(symbolTable-&gt;get_table() != NULL);</span></a>
<a name="3015"><span class="lineNum">    3015 </span>            : </a>
<a name="3016"><span class="lineNum">    3016 </span><span class="lineCov">      51305 :           SgSymbolTable::BaseHashType* internalTable = symbolTable-&gt;get_table();</span></a>
<a name="3017"><span class="lineNum">    3017 </span><span class="lineCov">      51305 :           ROSE_ASSERT(internalTable != NULL);</span></a>
<a name="3018"><span class="lineNum">    3018 </span>            : </a>
<a name="3019"><span class="lineNum">    3019 </span>            :        // Iterate over each symbol in the table and test it separately!</a>
<a name="3020"><span class="lineNum">    3020 </span><span class="lineCov">      51305 :           SgSymbolTable::hash_iterator i = internalTable-&gt;begin();</span></a>
<a name="3021"><span class="lineNum">    3021 </span><span class="lineCov">     991054 :           while (i != internalTable-&gt;end())</span></a>
<a name="3022"><span class="lineNum">    3022 </span>            :              {</a>
<a name="3023"><span class="lineNum">    3023 </span>            :             // DQ: removed SgName casting operator to char*</a>
<a name="3024"><span class="lineNum">    3024 </span>            :             // cout &lt;&lt; &quot;[&quot; &lt;&lt; idx &lt;&lt; &quot;] &quot; &lt;&lt; (*i).first.str();</a>
<a name="3025"><span class="lineNum">    3025 </span>            : </a>
<a name="3026"><span class="lineNum">    3026 </span>            :             // DQ (5/2/2013): Added to support test2013_141.C.</a>
<a name="3027"><span class="lineNum">    3027 </span><span class="lineCov">     939749 :                ROSE_ASSERT ( (*i).second != NULL );</span></a>
<a name="3028"><span class="lineNum">    3028 </span>            : #if 0</a>
<a name="3029"><span class="lineNum">    3029 </span>            :                printf (&quot;In symbol table = %p symbol name = i-&gt;first = %s i-&gt;second = %p = %s \n&quot;,symbolTable,i-&gt;first.str(),i-&gt;second,i-&gt;second-&gt;class_name().c_str());</a>
<a name="3030"><span class="lineNum">    3030 </span>            : #endif</a>
<a name="3031"><span class="lineNum">    3031 </span><span class="lineCov">     939749 :                ROSE_ASSERT ( isSgSymbol( (*i).second ) != NULL );</span></a>
<a name="3032"><span class="lineNum">    3032 </span>            : </a>
<a name="3033"><span class="lineNum">    3033 </span>            :             // printf (&quot;Symbol number: %d (pair.first (SgName) = %s) pair.second (SgSymbol) sage_class_name() = %s \n&quot;,</a>
<a name="3034"><span class="lineNum">    3034 </span>            :             //      idx,(*i).first.str(),(*i).second-&gt;sage_class_name());</a>
<a name="3035"><span class="lineNum">    3035 </span>            : </a>
<a name="3036"><span class="lineNum">    3036 </span><span class="lineCov">     939749 :                SgSymbol* symbol = isSgSymbol((*i).second);</span></a>
<a name="3037"><span class="lineNum">    3037 </span><span class="lineCov">     939749 :                ROSE_ASSERT ( symbol != NULL );</span></a>
<a name="3038"><span class="lineNum">    3038 </span>            : </a>
<a name="3039"><span class="lineNum">    3039 </span>            :             // DQ (5/24/2006): Added this test to the AST</a>
<a name="3040"><span class="lineNum">    3040 </span><span class="lineCov">     939749 :                if ( symbol-&gt;get_parent() == NULL )</span></a>
<a name="3041"><span class="lineNum">    3041 </span>            :                   {</a>
<a name="3042"><span class="lineNum">    3042 </span><span class="lineNoCov">          0 :                     printf (&quot;Error: symbol = %p = %s has parent == NULL \n&quot;,symbol,symbol-&gt;class_name().c_str());</span></a>
<a name="3043"><span class="lineNum">    3043 </span>            :                   }</a>
<a name="3044"><span class="lineNum">    3044 </span><span class="lineCov">     939749 :                ROSE_ASSERT ( symbol-&gt;get_parent() != NULL );</span></a>
<a name="3045"><span class="lineNum">    3045 </span>            : </a>
<a name="3046"><span class="lineNum">    3046 </span>            :             // DQ (8/6/2005): Test the get_declaration() function on all symbols</a>
<a name="3047"><span class="lineNum">    3047 </span><span class="lineCov">     939749 :                TestAstAccessToDeclarations::test(symbol);</span></a>
<a name="3048"><span class="lineNum">    3048 </span>            : </a>
<a name="3049"><span class="lineNum">    3049 </span>            :             // DQ (7/3/2007): This is a common point of failure in the AST merge mechanism.</a>
<a name="3050"><span class="lineNum">    3050 </span><span class="lineCov">     939749 :                SgNode* declarationNode = symbol-&gt;get_symbol_basis();</span></a>
<a name="3051"><span class="lineNum">    3051 </span><span class="lineCov">     939749 :                ROSE_ASSERT(declarationNode != NULL);</span></a>
<a name="3052"><span class="lineNum">    3052 </span><span class="lineCov">     939749 :                SgDeclarationStatement* declarationStatement = isSgDeclarationStatement(declarationNode);</span></a>
<a name="3053"><span class="lineNum">    3053 </span>            : #if 0</a>
<a name="3054"><span class="lineNum">    3054 </span>            :                if (declarationStatement != NULL)</a>
<a name="3055"><span class="lineNum">    3055 </span>            :                   {</a>
<a name="3056"><span class="lineNum">    3056 </span>            :                     printf (&quot;declarationStatement = %p = %s definingDeclaration = %p \n&quot;,declarationStatement,declarationStatement-&gt;class_name().c_str(),declarationStatement-&gt;get_definingDeclaration());</a>
<a name="3057"><span class="lineNum">    3057 </span>            :                   }</a>
<a name="3058"><span class="lineNum">    3058 </span>            : #endif</a>
<a name="3059"><span class="lineNum">    3059 </span>            : #if 0</a>
<a name="3060"><span class="lineNum">    3060 </span>            :                printf (&quot;AST consistency test: symbol = %p = %s = %s \n&quot;,symbol,symbol-&gt;class_name().c_str(),SageInterface::get_name(symbol).c_str());</a>
<a name="3061"><span class="lineNum">    3061 </span>            : #endif</a>
<a name="3062"><span class="lineNum">    3062 </span>            : </a>
<a name="3063"><span class="lineNum">    3063 </span>            :             // DQ (12/9/2007): Skip symbols that come from labels since they are often</a>
<a name="3064"><span class="lineNum">    3064 </span>            :             // numeric labels and need to be tested in a Fortran specific way.</a>
<a name="3065"><span class="lineNum">    3065 </span>            :             // if (declarationStatement != NULL)</a>
<a name="3066"><span class="lineNum">    3066 </span><span class="lineCov">     939749 :                if (declarationStatement != NULL &amp;&amp; isSgLabelSymbol(symbol) == NULL)</span></a>
<a name="3067"><span class="lineNum">    3067 </span>            :                   {</a>
<a name="3068"><span class="lineNum">    3068 </span>            :                  // DQ (8/21/2013): Test added by Tristan are a problem for Fortran code...</a>
<a name="3069"><span class="lineNum">    3069 </span>            : #if 0</a>
<a name="3070"><span class="lineNum">    3070 </span>            :                     assert(declarationStatement-&gt;get_firstNondefiningDeclaration() != NULL);</a>
<a name="3071"><span class="lineNum">    3071 </span>            :                     assert(declarationStatement-&gt;get_firstNondefiningDeclaration() == declarationStatement);</a>
<a name="3072"><span class="lineNum">    3072 </span>            : #endif</a>
<a name="3073"><span class="lineNum">    3073 </span>            :                  // DQ (7/25/2013): Tristan reports that this assertion is false for test2001_06.C.</a>
<a name="3074"><span class="lineNum">    3074 </span>            :                  // ROSE_ASSERT(declarationStatement-&gt;get_firstNondefiningDeclaration() == declarationStatement);</a>
<a name="3075"><span class="lineNum">    3075 </span>            : </a>
<a name="3076"><span class="lineNum">    3076 </span><span class="lineCov">     877992 :                     SgSymbol* local_symbol = declarationStatement-&gt;get_symbol_from_symbol_table();</span></a>
<a name="3077"><span class="lineNum">    3077 </span>            : #if 0</a>
<a name="3078"><span class="lineNum">    3078 </span>            :                     if (local_symbol == NULL)</a>
<a name="3079"><span class="lineNum">    3079 </span>            :                        {</a>
<a name="3080"><span class="lineNum">    3080 </span>            :                          printf (&quot;The declarationStatement = %p = %s = %s in symbol = %p = %s = %s can't locate it's symbol in scope = %p = %s = %s \n&quot;,</a>
<a name="3081"><span class="lineNum">    3081 </span>            :                               declarationStatement,declarationStatement-&gt;class_name().c_str(),SageInterface::get_name(declarationStatement).c_str(),</a>
<a name="3082"><span class="lineNum">    3082 </span>            :                               symbol,symbol-&gt;class_name().c_str(),SageInterface::get_name(scope).c_str(),</a>
<a name="3083"><span class="lineNum">    3083 </span>            :                               scope,scope-&gt;class_name().c_str(),SageInterface::get_name(scope).c_str());</a>
<a name="3084"><span class="lineNum">    3084 </span>            :                          declarationStatement-&gt;get_startOfConstruct()-&gt;display(&quot;declarationStatement-&gt;get_symbol_from_symbol_table() == NULL&quot;);</a>
<a name="3085"><span class="lineNum">    3085 </span>            :                        }</a>
<a name="3086"><span class="lineNum">    3086 </span>            : #endif</a>
<a name="3087"><span class="lineNum">    3087 </span>            : </a>
<a name="3088"><span class="lineNum">    3088 </span>            :                  // DQ (7/26/2007): Not all declarations have an associated symbol, but those declaration found in symbols should have symbols.</a>
<a name="3089"><span class="lineNum">    3089 </span>            :                  // ROSE_ASSERT(local_symbol != NULL);</a>
<a name="3090"><span class="lineNum">    3090 </span><span class="lineCov">     877992 :                     SgMemberFunctionDeclaration* memberFunctionDeclaration = isSgMemberFunctionDeclaration(declarationStatement);</span></a>
<a name="3091"><span class="lineNum">    3091 </span><span class="lineCov">     877992 :                     if (memberFunctionDeclaration != NULL &amp;&amp; memberFunctionDeclaration-&gt;get_associatedClassDeclaration() != NULL)</span></a>
<a name="3092"><span class="lineNum">    3092 </span>            :                        {</a>
<a name="3093"><span class="lineNum">    3093 </span>            :                       // See test2007_116.C.</a>
<a name="3094"><span class="lineNum">    3094 </span>            : #if PRINT_DEVELOPER_WARNINGS</a>
<a name="3095"><span class="lineNum">    3095 </span>            :                          printf (&quot;memberFunctionDeclaration scope has no associated symbol (case of pointer to member function): local_symbol = %p \n&quot;,local_symbol);</a>
<a name="3096"><span class="lineNum">    3096 </span>            : #endif</a>
<a name="3097"><span class="lineNum">    3097 </span>            :                       // ROSE_ASSERT(local_symbol == NULL);</a>
<a name="3098"><span class="lineNum">    3098 </span><span class="lineCov">      31635 :                          ROSE_ASSERT(memberFunctionDeclaration-&gt;get_scope() != NULL);</span></a>
<a name="3099"><span class="lineNum">    3099 </span>            :                        }</a>
<a name="3100"><span class="lineNum">    3100 </span>            :                       else</a>
<a name="3101"><span class="lineNum">    3101 </span>            :                        {</a>
<a name="3102"><span class="lineNum">    3102 </span><span class="lineCov">     846357 :                          if (local_symbol == NULL)</span></a>
<a name="3103"><span class="lineNum">    3103 </span>            :                             {</a>
<a name="3104"><span class="lineNum">    3104 </span>            : </a>
<a name="3105"><span class="lineNum">    3105 </span>            :                            // It appears this is an issue because the name is slightly different between:</a>
<a name="3106"><span class="lineNum">    3106 </span>            :                            //      name = template_class2 &lt; int  , double  &gt;  SgSymbol = 0x150ac90 = SgTemplateTypedefSymbol type = 0x7fdc28051098 = SgTypedefType = template_class2 &lt; int , double &gt;</a>
<a name="3107"><span class="lineNum">    3107 </span>            :                            // and</a>
<a name="3108"><span class="lineNum">    3108 </span>            :                            //      get_symbol_basis() = 0x7fdc27d94010 = SgTemplateInstantiationTypedefDeclaration = template_class2 &lt; int , double &gt;</a>
<a name="3109"><span class="lineNum">    3109 </span>            :                            //</a>
<a name="3110"><span class="lineNum">    3110 </span>            :                            // Specifically:</a>
<a name="3111"><span class="lineNum">    3111 </span>            :                            //      name = template_class2 &lt; int  , double  &gt;</a>
<a name="3112"><span class="lineNum">    3112 </span>            :                            //             template_class2 &lt; int , double &gt;</a>
<a name="3113"><span class="lineNum">    3113 </span>            : </a>
<a name="3114"><span class="lineNum">    3114 </span><span class="lineNoCov">          0 :                               printf (&quot;Error (AST consistency test): The declarationStatement = %p = %s = %s in symbol = %p = %s = %s can't locate it's symbol in scope = %p = %s = %s \n&quot;,</span></a>
<a name="3115"><span class="lineNum">    3115 </span><span class="lineNoCov">          0 :                                    declarationStatement,declarationStatement-&gt;class_name().c_str(),SageInterface::get_name(declarationStatement).c_str(),</span></a>
<a name="3116"><span class="lineNum">    3116 </span><span class="lineNoCov">          0 :                                    symbol,symbol-&gt;class_name().c_str(),SageInterface::get_name(scope).c_str(),</span></a>
<a name="3117"><span class="lineNum">    3117 </span><span class="lineNoCov">          0 :                                    scope,scope-&gt;class_name().c_str(),SageInterface::get_name(scope).c_str());</span></a>
<a name="3118"><span class="lineNum">    3118 </span>            : #if 0</a>
<a name="3119"><span class="lineNum">    3119 </span>            :                               declarationStatement-&gt;get_startOfConstruct()-&gt;display(&quot;declarationStatement-&gt;get_symbol_from_symbol_table() == NULL: debug&quot;);</a>
<a name="3120"><span class="lineNum">    3120 </span>            : #endif</a>
<a name="3121"><span class="lineNum">    3121 </span>            : #if 0</a>
<a name="3122"><span class="lineNum">    3122 </span>            :                               printf (&quot;******************** START **********************\n&quot;);</a>
<a name="3123"><span class="lineNum">    3123 </span>            :                               printf (&quot;In AST Consistantcy tests: Output the symbol table for scope = %p = %s: \n&quot;,scope,scope-&gt;class_name().c_str());</a>
<a name="3124"><span class="lineNum">    3124 </span>            :                               SageInterface::outputLocalSymbolTables(scope);</a>
<a name="3125"><span class="lineNum">    3125 </span>            :                               printf (&quot;******************** DONE ***********************\n&quot;);</a>
<a name="3126"><span class="lineNum">    3126 </span>            : #endif</a>
<a name="3127"><span class="lineNum">    3127 </span>            : #if 1</a>
<a name="3128"><span class="lineNum">    3128 </span>            :                            // DQ (2/28/2018): Added testing (Tristan indicates that this is a problem for Fortran, above).</a>
<a name="3129"><span class="lineNum">    3129 </span><span class="lineNoCov">          0 :                               ROSE_ASSERT(declarationStatement-&gt;get_firstNondefiningDeclaration() != NULL);</span></a>
<a name="3130"><span class="lineNum">    3130 </span>            : </a>
<a name="3131"><span class="lineNum">    3131 </span>            :                            // DQ (2/14/2019): For C++11 this need no longer be true, because enum prototypes can exist.</a>
<a name="3132"><span class="lineNum">    3132 </span>            :                            // ROSE_ASSERT(declarationStatement-&gt;get_firstNondefiningDeclaration() == declarationStatement);</a>
<a name="3133"><span class="lineNum">    3133 </span>            : #endif</a>
<a name="3134"><span class="lineNum">    3134 </span>            :                             }</a>
<a name="3135"><span class="lineNum">    3135 </span>            : </a>
<a name="3136"><span class="lineNum">    3136 </span>            :                       // DQ (11/7/2007): Allow this, with a warning, I think!</a>
<a name="3137"><span class="lineNum">    3137 </span><span class="lineCov">     846357 :                          SgFunctionDeclaration* functionDeclaration = isSgFunctionDeclaration(declarationStatement);</span></a>
<a name="3138"><span class="lineNum">    3138 </span><span class="lineCov">     846357 :                          if (local_symbol == NULL &amp;&amp; functionDeclaration != NULL &amp;&amp; functionDeclaration-&gt;get_name() == &quot;__default_function_pointer_name&quot;)</span></a>
<a name="3139"><span class="lineNum">    3139 </span>            :                             {</a>
<a name="3140"><span class="lineNum">    3140 </span>            : // #if PRINT_DEVELOPER_WARNINGS</a>
<a name="3141"><span class="lineNum">    3141 </span><span class="lineNoCov">          0 :                               printf (&quot;Warning: functionDeclaration = %s without symbol is OK in this case. \n&quot;,functionDeclaration-&gt;get_name().str());</span></a>
<a name="3142"><span class="lineNum">    3142 </span>            : // #endif</a>
<a name="3143"><span class="lineNum">    3143 </span>            :                             }</a>
<a name="3144"><span class="lineNum">    3144 </span>            :                            else</a>
<a name="3145"><span class="lineNum">    3145 </span>            :                             {</a>
<a name="3146"><span class="lineNum">    3146 </span>            : #if 0</a>
<a name="3147"><span class="lineNum">    3147 </span>            :                            // DQ (2/28/2015): previous older code.</a>
<a name="3148"><span class="lineNum">    3148 </span>            :                               ROSE_ASSERT(local_symbol != NULL);</a>
<a name="3149"><span class="lineNum">    3149 </span>            : #else</a>
<a name="3150"><span class="lineNum">    3150 </span>            :                            // DQ (2/28/2015): This fails for copyAST_tests/copytest2007_40.C and a few other files.</a>
<a name="3151"><span class="lineNum">    3151 </span>            :                            // I think this is related to the support for the EDN normalized template declarations.</a>
<a name="3152"><span class="lineNum">    3152 </span><span class="lineCov">     846357 :                               if (local_symbol == NULL)</span></a>
<a name="3153"><span class="lineNum">    3153 </span>            :                                  {</a>
<a name="3154"><span class="lineNum">    3154 </span><span class="lineNoCov">          0 :                                    printf (&quot;WARNING: local_symbol == NULL: this can happen in the copyAST_tests directory files. \n&quot;);</span></a>
<a name="3155"><span class="lineNum">    3155 </span>            :                                  }</a>
<a name="3156"><span class="lineNum">    3156 </span>            :                            // ROSE_ASSERT(local_symbol != NULL);</a>
<a name="3157"><span class="lineNum">    3157 </span>            : #endif</a>
<a name="3158"><span class="lineNum">    3158 </span>            :                             }</a>
<a name="3159"><span class="lineNum">    3159 </span>            :                        }</a>
<a name="3160"><span class="lineNum">    3160 </span>            :                  // ROSE_ASSERT(declarationStatement-&gt;hasAssociatedSymbol() == false || local_symbol != NULL);</a>
<a name="3161"><span class="lineNum">    3161 </span>            : </a>
<a name="3162"><span class="lineNum">    3162 </span>            : #if 0</a>
<a name="3163"><span class="lineNum">    3163 </span>            :                  // DQ (11/21/2013): Adding test as a result of debugging with Philippe.</a>
<a name="3164"><span class="lineNum">    3164 </span>            :                  // This test is not a test for a bug, since we require that symbols in base classes be aliased in the derived classes.</a>
<a name="3165"><span class="lineNum">    3165 </span>            :                     SgClassDeclaration* classDeclaration = isSgClassDeclaration(declarationStatement);</a>
<a name="3166"><span class="lineNum">    3166 </span>            :                     if (classDeclaration != NULL)</a>
<a name="3167"><span class="lineNum">    3167 </span>            :                        {</a>
<a name="3168"><span class="lineNum">    3168 </span>            :                          if (classDeclaration-&gt;get_scope() != scope)</a>
<a name="3169"><span class="lineNum">    3169 </span>            :                             {</a>
<a name="3170"><span class="lineNum">    3170 </span>            :                               printf (&quot;Error (AST consistency test): classDeclaration-&gt;get_scope() != scope of symbol table (classDeclaration-&gt;get_scope() = %p = %s scope = %p = %s) \n&quot;,</a>
<a name="3171"><span class="lineNum">    3171 </span>            :                                    classDeclaration-&gt;get_scope(),classDeclaration-&gt;get_scope()-&gt;class_name().c_str(),scope,scope-&gt;class_name().c_str());</a>
<a name="3172"><span class="lineNum">    3172 </span>            :                               printf (&quot;   --- classDeclaration = %p = %s \n&quot;,classDeclaration,classDeclaration-&gt;class_name().c_str());</a>
<a name="3173"><span class="lineNum">    3173 </span>            : </a>
<a name="3174"><span class="lineNum">    3174 </span>            :                               classDeclaration-&gt;get_file_info()-&gt;display(&quot;classDeclaration: debug&quot;);</a>
<a name="3175"><span class="lineNum">    3175 </span>            :                               scope-&gt;get_file_info()-&gt;display(&quot;scope: debug&quot;);</a>
<a name="3176"><span class="lineNum">    3176 </span>            :                             }</a>
<a name="3177"><span class="lineNum">    3177 </span>            :                       // ROSE_ASSERT(classDeclaration-&gt;get_scope() == scope);</a>
<a name="3178"><span class="lineNum">    3178 </span>            :                          if (isSgNamespaceDefinitionStatement(classDeclaration-&gt;get_scope()) == NULL)</a>
<a name="3179"><span class="lineNum">    3179 </span>            :                             {</a>
<a name="3180"><span class="lineNum">    3180 </span>            :                               ROSE_ASSERT(classDeclaration-&gt;get_scope() == scope);</a>
<a name="3181"><span class="lineNum">    3181 </span>            :                             }</a>
<a name="3182"><span class="lineNum">    3182 </span>            :                        }</a>
<a name="3183"><span class="lineNum">    3183 </span>            : #endif</a>
<a name="3184"><span class="lineNum">    3184 </span>            :                   }</a>
<a name="3185"><span class="lineNum">    3185 </span>            :                  else</a>
<a name="3186"><span class="lineNum">    3186 </span>            :                   {</a>
<a name="3187"><span class="lineNum">    3187 </span><span class="lineCov">      61757 :                     SgInitializedName* initializedName = isSgInitializedName(declarationNode);</span></a>
<a name="3188"><span class="lineNum">    3188 </span><span class="lineCov">      61757 :                     if (initializedName != NULL)</span></a>
<a name="3189"><span class="lineNum">    3189 </span>            :                        {</a>
<a name="3190"><span class="lineNum">    3190 </span>            : #if 0</a>
<a name="3191"><span class="lineNum">    3191 </span>            :                          printf (&quot;In TestAstSymbolTables::visit(): initializedName = %p = %s \n&quot;,initializedName,initializedName-&gt;get_name().str());</a>
<a name="3192"><span class="lineNum">    3192 </span>            : #endif</a>
<a name="3193"><span class="lineNum">    3193 </span><span class="lineCov">      61748 :                          SgSymbol* local_symbol = initializedName-&gt;get_symbol_from_symbol_table();</span></a>
<a name="3194"><span class="lineNum">    3194 </span><span class="lineCov">      61748 :                          if (local_symbol == NULL)</span></a>
<a name="3195"><span class="lineNum">    3195 </span>            :                             {</a>
<a name="3196"><span class="lineNum">    3196 </span><span class="lineNoCov">          0 :                               printf (&quot;Error: initializedName-&gt;get_symbol_from_symbol_table() == NULL initializedName = %p = %s \n&quot;,initializedName,initializedName-&gt;get_name().str());</span></a>
<a name="3197"><span class="lineNum">    3197 </span><span class="lineNoCov">          0 :                               initializedName-&gt;get_startOfConstruct()-&gt;display(&quot;Error: initializedName-&gt;get_symbol_from_symbol_table() == NULL&quot;);</span></a>
<a name="3198"><span class="lineNum">    3198 </span><span class="lineNoCov">          0 :                               SgLocatedNode* locatedNodeParent = isSgLocatedNode(initializedName-&gt;get_parent());</span></a>
<a name="3199"><span class="lineNum">    3199 </span><span class="lineNoCov">          0 :                               ROSE_ASSERT(locatedNodeParent != NULL);</span></a>
<a name="3200"><span class="lineNum">    3200 </span><span class="lineNoCov">          0 :                               locatedNodeParent-&gt;get_startOfConstruct()-&gt;display(&quot;Error: initializedName-&gt;get_symbol_from_symbol_table() == NULL: locatedNodeParent&quot;);</span></a>
<a name="3201"><span class="lineNum">    3201 </span>            : </a>
<a name="3202"><span class="lineNum">    3202 </span><span class="lineNoCov">          0 :                               SgScopeStatement* scope = initializedName-&gt;get_scope();</span></a>
<a name="3203"><span class="lineNum">    3203 </span><span class="lineNoCov">          0 :                               ROSE_ASSERT(scope != NULL);</span></a>
<a name="3204"><span class="lineNum">    3204 </span><span class="lineNoCov">          0 :                               ROSE_ASSERT(scope-&gt;get_symbol_table() != NULL);</span></a>
<a name="3205"><span class="lineNum">    3205 </span>            : </a>
<a name="3206"><span class="lineNum">    3206 </span><span class="lineNoCov">          0 :                               printf (&quot;In TestAstSymbolTables::visit(): output the symbol tables for the scope = %p = %s \n&quot;,scope,scope-&gt;class_name().c_str());</span></a>
<a name="3207"><span class="lineNum">    3207 </span><span class="lineNoCov">          0 :                               scope-&gt;get_symbol_table()-&gt;print();</span></a>
<a name="3208"><span class="lineNum">    3208 </span>            :                             }</a>
<a name="3209"><span class="lineNum">    3209 </span>            : #if 0</a>
<a name="3210"><span class="lineNum">    3210 </span>            :                          printf (&quot;In TestAstSymbolTables::visit(): local_symbol = %p = %s \n&quot;,local_symbol,local_symbol != NULL ? local_symbol-&gt;class_name().c_str() : &quot;null&quot;);</a>
<a name="3211"><span class="lineNum">    3211 </span>            : #endif</a>
<a name="3212"><span class="lineNum">    3212 </span><span class="lineCov">      61748 :                          ROSE_ASSERT(local_symbol != NULL);</span></a>
<a name="3213"><span class="lineNum">    3213 </span>            :                        }</a>
<a name="3214"><span class="lineNum">    3214 </span>            :                       else</a>
<a name="3215"><span class="lineNum">    3215 </span>            :                        {</a>
<a name="3216"><span class="lineNum">    3216 </span><span class="lineCov">          9 :                          if (isSgLabelStatement(declarationNode))</span></a>
<a name="3217"><span class="lineNum">    3217 </span>            :                             {</a>
<a name="3218"><span class="lineNum">    3218 </span><span class="lineCov">          7 :                               SgLabelStatement* labelStatement = (SgLabelStatement *) declarationNode;</span></a>
<a name="3219"><span class="lineNum">    3219 </span><span class="lineCov">          7 :                               SgSymbol* local_symbol = labelStatement-&gt;get_symbol_from_symbol_table();</span></a>
<a name="3220"><span class="lineNum">    3220 </span><span class="lineCov">          7 :                               if (local_symbol == NULL)</span></a>
<a name="3221"><span class="lineNum">    3221 </span>            :                                  {</a>
<a name="3222"><span class="lineNum">    3222 </span><span class="lineNoCov">          0 :                                    printf (&quot;Error: labelStatement-&gt;get_symbol_from_symbol_table() == NULL labelStatement = %p = %s \n&quot;,labelStatement,labelStatement-&gt;get_label().str());</span></a>
<a name="3223"><span class="lineNum">    3223 </span><span class="lineNoCov">          0 :                                    ROSE_ASSERT(labelStatement-&gt;get_scope() != NULL);</span></a>
<a name="3224"><span class="lineNum">    3224 </span><span class="lineNoCov">          0 :                                    labelStatement-&gt;get_scope()-&gt;get_symbol_table()-&gt;print(&quot;debug labelStatement scope&quot;);</span></a>
<a name="3225"><span class="lineNum">    3225 </span>            :                                  }</a>
<a name="3226"><span class="lineNum">    3226 </span><span class="lineCov">          7 :                               ROSE_ASSERT(local_symbol != NULL);</span></a>
<a name="3227"><span class="lineNum">    3227 </span>            :                             }</a>
<a name="3228"><span class="lineNum">    3228 </span>            :                            else</a>
<a name="3229"><span class="lineNum">    3229 </span>            :                             {</a>
<a name="3230"><span class="lineNum">    3230 </span>            :                            // DQ (12/9/2007): Added support for fortran in SgLabelSymbol.</a>
<a name="3231"><span class="lineNum">    3231 </span><span class="lineCov">          2 :                               SgLabelSymbol* labelSymbol = isSgLabelSymbol(symbol);</span></a>
<a name="3232"><span class="lineNum">    3232 </span><span class="lineCov">          2 :                               if (labelSymbol != NULL)</span></a>
<a name="3233"><span class="lineNum">    3233 </span>            :                                  {</a>
<a name="3234"><span class="lineNum">    3234 </span><span class="lineCov">          2 :                                    ROSE_ASSERT(labelSymbol-&gt;get_fortran_statement() != NULL);</span></a>
<a name="3235"><span class="lineNum">    3235 </span>            :                                  }</a>
<a name="3236"><span class="lineNum">    3236 </span>            :                                 else</a>
<a name="3237"><span class="lineNum">    3237 </span>            :                                  {</a>
<a name="3238"><span class="lineNum">    3238 </span><span class="lineNoCov">          0 :                                    printf (&quot;Error: declaration found in symbol not handled (declarationNode = %s) \n&quot;,declarationNode-&gt;class_name().c_str());</span></a>
<a name="3239"><span class="lineNum">    3239 </span><span class="lineNoCov">          0 :                                    ROSE_ABORT();</span></a>
<a name="3240"><span class="lineNum">    3240 </span>            :                                  }</a>
<a name="3241"><span class="lineNum">    3241 </span>            :                             }</a>
<a name="3242"><span class="lineNum">    3242 </span>            :                        }</a>
<a name="3243"><span class="lineNum">    3243 </span>            :                   }</a>
<a name="3244"><span class="lineNum">    3244 </span>            : </a>
<a name="3245"><span class="lineNum">    3245 </span>            :             // DQ (12/16/2007): Added test</a>
<a name="3246"><span class="lineNum">    3246 </span><span class="lineCov">     939749 :                ROSE_ASSERT(symbol != NULL);</span></a>
<a name="3247"><span class="lineNum">    3247 </span>            : </a>
<a name="3248"><span class="lineNum">    3248 </span>            :             // We have to look at each type of symbol separately!  This is because there is no virtual function,</a>
<a name="3249"><span class="lineNum">    3249 </span>            :             // the reason for this is that each get_declaration() function returns a different type!</a>
<a name="3250"><span class="lineNum">    3250 </span>            :             // ROSE_ASSERT ( symbol-&gt;get_declaration() != NULL );</a>
<a name="3251"><span class="lineNum">    3251 </span><span class="lineCov">     939749 :                switch(symbol-&gt;variantT())</span></a>
<a name="3252"><span class="lineNum">    3252 </span>            :                   {</a>
<a name="3253"><span class="lineNum">    3253 </span><span class="lineCov">      11376 :                     case V_SgClassSymbol:</span></a>
<a name="3254"><span class="lineNum">    3254 </span><span class="lineCov">      11376 :                        {</span></a>
<a name="3255"><span class="lineNum">    3255 </span><span class="lineCov">      11376 :                          SgClassSymbol* classSymbol = isSgClassSymbol(symbol);</span></a>
<a name="3256"><span class="lineNum">    3256 </span><span class="lineCov">      11376 :                          ROSE_ASSERT(classSymbol != NULL);</span></a>
<a name="3257"><span class="lineNum">    3257 </span><span class="lineCov">      11376 :                          ROSE_ASSERT(classSymbol-&gt;get_declaration() != NULL);</span></a>
<a name="3258"><span class="lineNum">    3258 </span>            : </a>
<a name="3259"><span class="lineNum">    3259 </span>            :                       // DQ (12/27/2011): Make sure this is not a SgClassSymbol that is incorrectly associated with a SgTemplateClassDeclaration.</a>
<a name="3260"><span class="lineNum">    3260 </span><span class="lineCov">      11376 :                          ROSE_ASSERT(isSgTemplateClassDeclaration(classSymbol-&gt;get_declaration()) == NULL);</span></a>
<a name="3261"><span class="lineNum">    3261 </span><span class="lineCov">      11376 :                          break;</span></a>
<a name="3262"><span class="lineNum">    3262 </span>            :                        }</a>
<a name="3263"><span class="lineNum">    3263 </span>            : </a>
<a name="3264"><span class="lineNum">    3264 </span>            :                  // DQ (12/27/2011): Added new symbol (and required support).</a>
<a name="3265"><span class="lineNum">    3265 </span><span class="lineCov">       3903 :                     case V_SgTemplateClassSymbol:</span></a>
<a name="3266"><span class="lineNum">    3266 </span><span class="lineCov">       3903 :                        {</span></a>
<a name="3267"><span class="lineNum">    3267 </span><span class="lineCov">       3903 :                          SgTemplateClassSymbol* templateClassSymbol = isSgTemplateClassSymbol(symbol);</span></a>
<a name="3268"><span class="lineNum">    3268 </span><span class="lineCov">       3903 :                          ROSE_ASSERT(templateClassSymbol != NULL);</span></a>
<a name="3269"><span class="lineNum">    3269 </span><span class="lineCov">       3903 :                          ROSE_ASSERT(templateClassSymbol-&gt;get_declaration() != NULL);</span></a>
<a name="3270"><span class="lineNum">    3270 </span>            : </a>
<a name="3271"><span class="lineNum">    3271 </span>            :                       // DQ (12/27/2011): Make sure this is correctly associated with a SgTemplateClassDeclaration.</a>
<a name="3272"><span class="lineNum">    3272 </span><span class="lineCov">       3903 :                          ROSE_ASSERT(isSgTemplateClassDeclaration(templateClassSymbol-&gt;get_declaration()) != NULL);</span></a>
<a name="3273"><span class="lineNum">    3273 </span><span class="lineCov">       3903 :                          break;</span></a>
<a name="3274"><span class="lineNum">    3274 </span>            :                        }</a>
<a name="3275"><span class="lineNum">    3275 </span>            : </a>
<a name="3276"><span class="lineNum">    3276 </span><span class="lineNoCov">          0 :                     case V_SgDefaultSymbol:</span></a>
<a name="3277"><span class="lineNum">    3277 </span><span class="lineNoCov">          0 :                        {</span></a>
<a name="3278"><span class="lineNum">    3278 </span><span class="lineNoCov">          0 :                          printf (&quot;The SgDefaultSymbol should not be present in the AST \n&quot;);</span></a>
<a name="3279"><span class="lineNum">    3279 </span><span class="lineNoCov">          0 :                          ROSE_ABORT();</span></a>
<a name="3280"><span class="lineNum">    3280 </span>            :                        }</a>
<a name="3281"><span class="lineNum">    3281 </span>            : </a>
<a name="3282"><span class="lineNum">    3282 </span><span class="lineCov">       5916 :                     case V_SgEnumFieldSymbol:</span></a>
<a name="3283"><span class="lineNum">    3283 </span><span class="lineCov">       5916 :                        {</span></a>
<a name="3284"><span class="lineNum">    3284 </span>            :                       // Note that the type returned by get_declaration is SgInitializedName and not any sort of SgDeclaration</a>
<a name="3285"><span class="lineNum">    3285 </span><span class="lineCov">       5916 :                          SgEnumFieldSymbol* enumFieldSymbol = isSgEnumFieldSymbol(symbol);</span></a>
<a name="3286"><span class="lineNum">    3286 </span><span class="lineCov">       5916 :                          ROSE_ASSERT(enumFieldSymbol != NULL);</span></a>
<a name="3287"><span class="lineNum">    3287 </span><span class="lineCov">       5916 :                          ROSE_ASSERT(enumFieldSymbol-&gt;get_declaration() != NULL);</span></a>
<a name="3288"><span class="lineNum">    3288 </span><span class="lineCov">       5916 :                          break;</span></a>
<a name="3289"><span class="lineNum">    3289 </span>            :                        }</a>
<a name="3290"><span class="lineNum">    3290 </span>            : </a>
<a name="3291"><span class="lineNum">    3291 </span><span class="lineCov">       1264 :                     case V_SgEnumSymbol:</span></a>
<a name="3292"><span class="lineNum">    3292 </span><span class="lineCov">       1264 :                        {</span></a>
<a name="3293"><span class="lineNum">    3293 </span><span class="lineCov">       1264 :                          SgEnumSymbol* enumSymbol = isSgEnumSymbol(symbol);</span></a>
<a name="3294"><span class="lineNum">    3294 </span><span class="lineCov">       1264 :                          ROSE_ASSERT(enumSymbol != NULL);</span></a>
<a name="3295"><span class="lineNum">    3295 </span><span class="lineCov">       1264 :                          ROSE_ASSERT(enumSymbol-&gt;get_declaration() != NULL);</span></a>
<a name="3296"><span class="lineNum">    3296 </span><span class="lineCov">       1264 :                          break;</span></a>
<a name="3297"><span class="lineNum">    3297 </span>            :                        }</a>
<a name="3298"><span class="lineNum">    3298 </span>            : </a>
<a name="3299"><span class="lineNum">    3299 </span>            :                  // DQ (12/28/2011): These can be handled using the same case.</a>
<a name="3300"><span class="lineNum">    3300 </span><span class="lineCov">     777968 :                     case V_SgTemplateFunctionSymbol:</span></a>
<a name="3301"><span class="lineNum">    3301 </span><span class="lineCov">     777968 :                     case V_SgTemplateMemberFunctionSymbol:</span></a>
<a name="3302"><span class="lineNum">    3302 </span>            : </a>
<a name="3303"><span class="lineNum">    3303 </span>            :                  // These can be handled by the same case</a>
<a name="3304"><span class="lineNum">    3304 </span><span class="lineCov">     777968 :                     case V_SgFunctionSymbol:</span></a>
<a name="3305"><span class="lineNum">    3305 </span><span class="lineCov">     777968 :                     case V_SgMemberFunctionSymbol:</span></a>
<a name="3306"><span class="lineNum">    3306 </span><span class="lineCov">     777968 :                        {</span></a>
<a name="3307"><span class="lineNum">    3307 </span><span class="lineCov">     777968 :                          SgFunctionSymbol* functionSymbol = isSgFunctionSymbol(symbol);</span></a>
<a name="3308"><span class="lineNum">    3308 </span><span class="lineCov">     777968 :                          ROSE_ASSERT(functionSymbol != NULL);</span></a>
<a name="3309"><span class="lineNum">    3309 </span><span class="lineCov">     777968 :                          ROSE_ASSERT(functionSymbol-&gt;get_declaration() != NULL);</span></a>
<a name="3310"><span class="lineNum">    3310 </span><span class="lineCov">     777968 :                          break;</span></a>
<a name="3311"><span class="lineNum">    3311 </span>            :                        }</a>
<a name="3312"><span class="lineNum">    3312 </span>            : </a>
<a name="3313"><span class="lineNum">    3313 </span>            :                  // DQ (10/11/2008): Added to support renaming of functions using the Fortran 90 interface statement.</a>
<a name="3314"><span class="lineNum">    3314 </span>            :                  // Note that the SgRenameSymbol is derived from the SgFunctionSymbol. Unclear if any other symbols</a>
<a name="3315"><span class="lineNum">    3315 </span>            :                  // should have a similar renamed version (e.g. SgMemberFunctionSymbol).  If this technique is uesd</a>
<a name="3316"><span class="lineNum">    3316 </span>            :                  // for C++ then the target of C++ aliases might be supported.  It is not clear if this technique will</a>
<a name="3317"><span class="lineNum">    3317 </span>            :                  // be used outside of the Fortran support.</a>
<a name="3318"><span class="lineNum">    3318 </span><span class="lineNoCov">          0 :                     case V_SgRenameSymbol:</span></a>
<a name="3319"><span class="lineNum">    3319 </span><span class="lineNoCov">          0 :                        {</span></a>
<a name="3320"><span class="lineNum">    3320 </span>            :                       // This is an alias for a symbol injected from another scope as part of a Fortran &quot;use&quot; statement</a>
<a name="3321"><span class="lineNum">    3321 </span>            :                       // (or perhaps eventually a C++ using declaration or using directive).</a>
<a name="3322"><span class="lineNum">    3322 </span><span class="lineNoCov">          0 :                          SgRenameSymbol* renameSymbol = isSgRenameSymbol(symbol);</span></a>
<a name="3323"><span class="lineNum">    3323 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(renameSymbol != NULL);</span></a>
<a name="3324"><span class="lineNum">    3324 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(renameSymbol-&gt;get_original_symbol() != NULL);</span></a>
<a name="3325"><span class="lineNum">    3325 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(renameSymbol-&gt;get_declaration() != NULL);</span></a>
<a name="3326"><span class="lineNum">    3326 </span><span class="lineNoCov">          0 :                          break;</span></a>
<a name="3327"><span class="lineNum">    3327 </span>            :                        }</a>
<a name="3328"><span class="lineNum">    3328 </span>            : </a>
<a name="3329"><span class="lineNum">    3329 </span><span class="lineNoCov">          0 :                     case V_SgFunctionTypeSymbol:</span></a>
<a name="3330"><span class="lineNum">    3330 </span><span class="lineNoCov">          0 :                        {</span></a>
<a name="3331"><span class="lineNum">    3331 </span>            :                       // Note that we check the get_type() function here and not get_declaration()</a>
<a name="3332"><span class="lineNum">    3332 </span><span class="lineNoCov">          0 :                          SgFunctionTypeSymbol* functionTypeSymbol = isSgFunctionTypeSymbol(symbol);</span></a>
<a name="3333"><span class="lineNum">    3333 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(functionTypeSymbol != NULL);</span></a>
<a name="3334"><span class="lineNum">    3334 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(functionTypeSymbol-&gt;get_type() != NULL);</span></a>
<a name="3335"><span class="lineNum">    3335 </span><span class="lineNoCov">          0 :                          break;</span></a>
<a name="3336"><span class="lineNum">    3336 </span>            :                        }</a>
<a name="3337"><span class="lineNum">    3337 </span>            : </a>
<a name="3338"><span class="lineNum">    3338 </span><span class="lineCov">          9 :                     case V_SgLabelSymbol:</span></a>
<a name="3339"><span class="lineNum">    3339 </span><span class="lineCov">          9 :                        {</span></a>
<a name="3340"><span class="lineNum">    3340 </span><span class="lineCov">          9 :                          SgLabelSymbol* labelSymbol = isSgLabelSymbol(symbol);</span></a>
<a name="3341"><span class="lineNum">    3341 </span><span class="lineCov">          9 :                          ROSE_ASSERT(labelSymbol != NULL);</span></a>
<a name="3342"><span class="lineNum">    3342 </span>            : </a>
<a name="3343"><span class="lineNum">    3343 </span>            :                       // DQ (12/9/2007): Modified to reflect added support for fortran statement numeric labels.</a>
<a name="3344"><span class="lineNum">    3344 </span>            :                       // ROSE_ASSERT(labelSymbol-&gt;get_declaration() != NULL);</a>
<a name="3345"><span class="lineNum">    3345 </span><span class="lineCov">          9 :                          if (labelSymbol-&gt;get_declaration() == NULL)</span></a>
<a name="3346"><span class="lineNum">    3346 </span>            :                             {</a>
<a name="3347"><span class="lineNum">    3347 </span>            : #if 0</a>
<a name="3348"><span class="lineNum">    3348 </span>            :                               ROSE_ASSERT(labelSymbol-&gt;get_fortran_statement() != NULL);</a>
<a name="3349"><span class="lineNum">    3349 </span>            : #else</a>
<a name="3350"><span class="lineNum">    3350 </span>            :                            // DQ (2/2/2011): Added support in SgLabelSymbol for Fortran alternative return parameters (see test2010_164.f90).</a>
<a name="3351"><span class="lineNum">    3351 </span><span class="lineCov">          4 :                               if (labelSymbol-&gt;get_fortran_statement() == NULL)</span></a>
<a name="3352"><span class="lineNum">    3352 </span>            :                                  {</a>
<a name="3353"><span class="lineNum">    3353 </span><span class="lineNoCov">          0 :                                    ROSE_ASSERT(labelSymbol-&gt;get_fortran_alternate_return_parameter() != NULL);</span></a>
<a name="3354"><span class="lineNum">    3354 </span>            :                                  }</a>
<a name="3355"><span class="lineNum">    3355 </span>            : #endif</a>
<a name="3356"><span class="lineNum">    3356 </span>            :                             }</a>
<a name="3357"><span class="lineNum">    3357 </span>            :                          break;</a>
<a name="3358"><span class="lineNum">    3358 </span>            :                        }</a>
<a name="3359"><span class="lineNum">    3359 </span>            : </a>
<a name="3360"><span class="lineNum">    3360 </span><span class="lineCov">        107 :                     case V_SgNamespaceSymbol:</span></a>
<a name="3361"><span class="lineNum">    3361 </span><span class="lineCov">        107 :                        {</span></a>
<a name="3362"><span class="lineNum">    3362 </span><span class="lineCov">        107 :                          SgNamespaceSymbol* namespaceSymbol = isSgNamespaceSymbol(symbol);</span></a>
<a name="3363"><span class="lineNum">    3363 </span><span class="lineCov">        107 :                          ROSE_ASSERT(namespaceSymbol != NULL);</span></a>
<a name="3364"><span class="lineNum">    3364 </span>            : </a>
<a name="3365"><span class="lineNum">    3365 </span>            :                       // DQ (8/30/2009): Added namespace alias support.</a>
<a name="3366"><span class="lineNum">    3366 </span>            :                       // ROSE_ASSERT(namespaceSymbol-&gt;get_declaration() != NULL);</a>
<a name="3367"><span class="lineNum">    3367 </span><span class="lineCov">        107 :                          ROSE_ASSERT( (namespaceSymbol-&gt;get_declaration() != NULL &amp;&amp; namespaceSymbol-&gt;get_isAlias() == false) || (namespaceSymbol-&gt;get_aliasDeclaration() != NULL &amp;&amp; namespaceSymbol-&gt;get_isAlias() == true) );</span></a>
<a name="3368"><span class="lineNum">    3368 </span><span class="lineCov">        107 :                          break;</span></a>
<a name="3369"><span class="lineNum">    3369 </span>            :                        }</a>
<a name="3370"><span class="lineNum">    3370 </span>            : </a>
<a name="3371"><span class="lineNum">    3371 </span><span class="lineNoCov">          0 :                     case V_SgTemplateSymbol:</span></a>
<a name="3372"><span class="lineNum">    3372 </span><span class="lineNoCov">          0 :                        {</span></a>
<a name="3373"><span class="lineNum">    3373 </span><span class="lineNoCov">          0 :                          SgTemplateSymbol* templateSymbol = isSgTemplateSymbol(symbol);</span></a>
<a name="3374"><span class="lineNum">    3374 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(templateSymbol != NULL);</span></a>
<a name="3375"><span class="lineNum">    3375 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(templateSymbol-&gt;get_declaration() != NULL);</span></a>
<a name="3376"><span class="lineNum">    3376 </span><span class="lineNoCov">          0 :                          break;</span></a>
<a name="3377"><span class="lineNum">    3377 </span>            :                        }</a>
<a name="3378"><span class="lineNum">    3378 </span>            : </a>
<a name="3379"><span class="lineNum">    3379 </span>            :                  // DQ (11/4/2014): Adding support for template typedef declarations.</a>
<a name="3380"><span class="lineNum">    3380 </span><span class="lineCov">      50615 :                     case V_SgTemplateTypedefSymbol:</span></a>
<a name="3381"><span class="lineNum">    3381 </span><span class="lineCov">      50615 :                     case V_SgTypedefSymbol:</span></a>
<a name="3382"><span class="lineNum">    3382 </span><span class="lineCov">      50615 :                        {</span></a>
<a name="3383"><span class="lineNum">    3383 </span><span class="lineCov">      50615 :                          SgTypedefSymbol* typedefSymbol = isSgTypedefSymbol(symbol);</span></a>
<a name="3384"><span class="lineNum">    3384 </span><span class="lineCov">      50615 :                          ROSE_ASSERT(typedefSymbol != NULL);</span></a>
<a name="3385"><span class="lineNum">    3385 </span><span class="lineCov">      50615 :                          ROSE_ASSERT(typedefSymbol-&gt;get_declaration() != NULL);</span></a>
<a name="3386"><span class="lineNum">    3386 </span><span class="lineCov">      50615 :                          break;</span></a>
<a name="3387"><span class="lineNum">    3387 </span>            :                        }</a>
<a name="3388"><span class="lineNum">    3388 </span><span class="lineCov">      49692 :                     case V_SgTemplateVariableSymbol:</span></a>
<a name="3389"><span class="lineNum">    3389 </span><span class="lineCov">      49692 :                     case V_SgVariableSymbol:</span></a>
<a name="3390"><span class="lineNum">    3390 </span><span class="lineCov">      49692 :                        {</span></a>
<a name="3391"><span class="lineNum">    3391 </span>            :                       // Note that the type returned by get_declaration is SgInitializedName and not any sort of SgDeclaration</a>
<a name="3392"><span class="lineNum">    3392 </span><span class="lineCov">      49692 :                          SgVariableSymbol* variableSymbol = isSgVariableSymbol(symbol);</span></a>
<a name="3393"><span class="lineNum">    3393 </span><span class="lineCov">      49692 :                          ROSE_ASSERT(variableSymbol != NULL);</span></a>
<a name="3394"><span class="lineNum">    3394 </span><span class="lineCov">      49692 :                          ROSE_ASSERT(variableSymbol-&gt;get_declaration() != NULL);</span></a>
<a name="3395"><span class="lineNum">    3395 </span><span class="lineCov">      49692 :                          break;</span></a>
<a name="3396"><span class="lineNum">    3396 </span>            :                        }</a>
<a name="3397"><span class="lineNum">    3397 </span>            : </a>
<a name="3398"><span class="lineNum">    3398 </span>            :                  // DQ (9/29/2008): Added support for symbols that are alias for other symbol from othe scopes.</a>
<a name="3399"><span class="lineNum">    3399 </span><span class="lineCov">      38899 :                     case V_SgAliasSymbol:</span></a>
<a name="3400"><span class="lineNum">    3400 </span><span class="lineCov">      38899 :                        {</span></a>
<a name="3401"><span class="lineNum">    3401 </span>            :                       // This is an alias for a symbol injected from another scope as part of a Fortran &quot;use&quot; statement</a>
<a name="3402"><span class="lineNum">    3402 </span>            :                       // (or perhaps eventually a C++ using declaration or using directive).</a>
<a name="3403"><span class="lineNum">    3403 </span><span class="lineCov">      38899 :                          SgAliasSymbol* aliasSymbol = isSgAliasSymbol(symbol);</span></a>
<a name="3404"><span class="lineNum">    3404 </span><span class="lineCov">      38899 :                          ROSE_ASSERT(aliasSymbol != NULL);</span></a>
<a name="3405"><span class="lineNum">    3405 </span><span class="lineCov">      38899 :                          ROSE_ASSERT(aliasSymbol-&gt;get_alias() != NULL);</span></a>
<a name="3406"><span class="lineNum">    3406 </span><span class="lineCov">      38899 :                          break;</span></a>
<a name="3407"><span class="lineNum">    3407 </span>            :                        }</a>
<a name="3408"><span class="lineNum">    3408 </span>            : </a>
<a name="3409"><span class="lineNum">    3409 </span><span class="lineNoCov">          0 :                     case V_SgNonrealSymbol:</span></a>
<a name="3410"><span class="lineNum">    3410 </span><span class="lineNoCov">          0 :                        {</span></a>
<a name="3411"><span class="lineNum">    3411 </span><span class="lineNoCov">          0 :                          SgNonrealSymbol * nrsymbol = isSgNonrealSymbol(symbol);</span></a>
<a name="3412"><span class="lineNum">    3412 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(nrsymbol != NULL);</span></a>
<a name="3413"><span class="lineNum">    3413 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(nrsymbol-&gt;get_declaration() != NULL);</span></a>
<a name="3414"><span class="lineNum">    3414 </span><span class="lineNoCov">          0 :                          break;</span></a>
<a name="3415"><span class="lineNum">    3415 </span>            :                        }</a>
<a name="3416"><span class="lineNum">    3416 </span>            : </a>
<a name="3417"><span class="lineNum">    3417 </span><span class="lineNoCov">          0 :                     default:</span></a>
<a name="3418"><span class="lineNum">    3418 </span><span class="lineNoCov">          0 :                        {</span></a>
<a name="3419"><span class="lineNum">    3419 </span><span class="lineNoCov">          0 :                          printf (&quot;Error: default reached in switch (AstFixes.C) symbol = %s \n&quot;,symbol-&gt;class_name().c_str());</span></a>
<a name="3420"><span class="lineNum">    3420 </span><span class="lineNoCov">          0 :                          ROSE_ABORT();</span></a>
<a name="3421"><span class="lineNum">    3421 </span>            :                        }</a>
<a name="3422"><span class="lineNum">    3422 </span>            :                   }</a>
<a name="3423"><span class="lineNum">    3423 </span>            : </a>
<a name="3424"><span class="lineNum">    3424 </span>            :             // DQ (12/16/2007): Added test</a>
<a name="3425"><span class="lineNum">    3425 </span><span class="lineCov">     939749 :                ROSE_ASSERT(symbol != NULL);</span></a>
<a name="3426"><span class="lineNum">    3426 </span>            : </a>
<a name="3427"><span class="lineNum">    3427 </span>            :             // DQ (6/10/2007): Test if the scopes match!</a>
<a name="3428"><span class="lineNum">    3428 </span>            :             // This also test the SgSymbol::get_symbol_basis() member function</a>
<a name="3429"><span class="lineNum">    3429 </span><span class="lineCov">     939749 :                SgScopeStatement* decl_scope = symbol-&gt;get_scope();</span></a>
<a name="3430"><span class="lineNum">    3430 </span><span class="lineCov">     939749 :                if (decl_scope != NULL &amp;&amp; decl_scope != scope)</span></a>
<a name="3431"><span class="lineNum">    3431 </span>            :                   {</a>
<a name="3432"><span class="lineNum">    3432 </span>            : #if PRINT_DEVELOPER_WARNINGS</a>
<a name="3433"><span class="lineNum">    3433 </span>            :                  // DQ (10/22/2007) Unclear if this is a serious problem.</a>
<a name="3434"><span class="lineNum">    3434 </span>            :                     printf (&quot;Warning: scope of declaration = %p = %s in symbol does not match input scope = %p = %s \n&quot;,decl_scope,decl_scope-&gt;class_name().c_str(),scope,scope-&gt;class_name().c_str());</a>
<a name="3435"><span class="lineNum">    3435 </span>            : #endif</a>
<a name="3436"><span class="lineNum">    3436 </span>            :                  // ROSE_ASSERT(false);</a>
<a name="3437"><span class="lineNum">    3437 </span>            :                   }</a>
<a name="3438"><span class="lineNum">    3438 </span>            :                  else</a>
<a name="3439"><span class="lineNum">    3439 </span>            :                   {</a>
<a name="3440"><span class="lineNum">    3440 </span>            :                  // DQ (7/26/2007): Test for the special case of a member function pointer to a class without a definition</a>
<a name="3441"><span class="lineNum">    3441 </span>            :                  // see test2007_116.C</a>
<a name="3442"><span class="lineNum">    3442 </span><span class="lineCov">     893439 :                     if (decl_scope == NULL)</span></a>
<a name="3443"><span class="lineNum">    3443 </span>            :                        {</a>
<a name="3444"><span class="lineNum">    3444 </span><span class="lineNoCov">          0 :                          SgMemberFunctionSymbol* memberFunctionSymbol = isSgMemberFunctionSymbol(symbol);</span></a>
<a name="3445"><span class="lineNum">    3445 </span><span class="lineNoCov">          0 :                          if (memberFunctionSymbol != NULL)</span></a>
<a name="3446"><span class="lineNum">    3446 </span>            :                             {</a>
<a name="3447"><span class="lineNum">    3447 </span><span class="lineNoCov">          0 :                               ROSE_ASSERT(memberFunctionSymbol-&gt;get_declaration() != NULL);</span></a>
<a name="3448"><span class="lineNum">    3448 </span><span class="lineNoCov">          0 :                               SgMemberFunctionDeclaration* memberFunctionDeclaration = isSgMemberFunctionDeclaration(memberFunctionSymbol-&gt;get_declaration());</span></a>
<a name="3449"><span class="lineNum">    3449 </span><span class="lineNoCov">          0 :                               ROSE_ASSERT(memberFunctionDeclaration-&gt;get_associatedClassDeclaration() != NULL);</span></a>
<a name="3450"><span class="lineNum">    3450 </span>            :                             }</a>
<a name="3451"><span class="lineNum">    3451 </span>            :                            else</a>
<a name="3452"><span class="lineNum">    3452 </span>            :                             {</a>
<a name="3453"><span class="lineNum">    3453 </span><span class="lineNoCov">          0 :                               printf (&quot;Error: symbol declaration's scope not set! symbol = %p = %s \n&quot;,symbol,symbol-&gt;class_name().c_str());</span></a>
<a name="3454"><span class="lineNum">    3454 </span><span class="lineNoCov">          0 :                               ROSE_ABORT();</span></a>
<a name="3455"><span class="lineNum">    3455 </span>            :                             }</a>
<a name="3456"><span class="lineNum">    3456 </span>            :                        }</a>
<a name="3457"><span class="lineNum">    3457 </span>            :                   }</a>
<a name="3458"><span class="lineNum">    3458 </span>            : </a>
<a name="3459"><span class="lineNum">    3459 </span>            :             // Increment iterator!</a>
<a name="3460"><span class="lineNum">    3460 </span><span class="lineCov">     939749 :                i++;</span></a>
<a name="3461"><span class="lineNum">    3461 </span>            :              }</a>
<a name="3462"><span class="lineNum">    3462 </span>            : </a>
<a name="3463"><span class="lineNum">    3463 </span>            : #if 0</a>
<a name="3464"><span class="lineNum">    3464 </span>            :        // debugging</a>
<a name="3465"><span class="lineNum">    3465 </span>            :           symbolTable-&gt;print();</a>
<a name="3466"><span class="lineNum">    3466 </span>            : #endif</a>
<a name="3467"><span class="lineNum">    3467 </span>            :         }</a>
<a name="3468"><span class="lineNum">    3468 </span>            : #if 0</a>
<a name="3469"><span class="lineNum">    3469 </span>            :     // for each namespace declaration: there are at least two SgNamespaceDefinitionStatement nodes:</a>
<a name="3470"><span class="lineNum">    3470 </span>            :     // global definition and firstNondefinining declaration's definition</a>
<a name="3471"><span class="lineNum">    3471 </span>            :      SgNamespaceDeclarationStatement *nsd = isSgNamespaceDeclarationStatement(node);</a>
<a name="3472"><span class="lineNum">    3472 </span>            :        // global_definition should have the same alias symbol count as the first definition's symbol table</a>
<a name="3473"><span class="lineNum">    3473 </span>            :        // check first nondefinining declaration</a>
<a name="3474"><span class="lineNum">    3474 </span>            :      if (nsd&amp;&amp; nsd-&gt;get_firstNondefiningDeclaration() == nsd)</a>
<a name="3475"><span class="lineNum">    3475 </span>            :      {</a>
<a name="3476"><span class="lineNum">    3476 </span>            :        SgNamespaceDefinitionStatement* local_def = nsd-&gt;get_definition();</a>
<a name="3477"><span class="lineNum">    3477 </span>            :        SgNamespaceDefinitionStatement* global_def = local_def-&gt;get_global_definition();</a>
<a name="3478"><span class="lineNum">    3478 </span>            : </a>
<a name="3479"><span class="lineNum">    3479 </span>            :        ROSE_ASSERT(local_def &amp;&amp; global_def &amp;&amp; (local_def!=global_def));</a>
<a name="3480"><span class="lineNum">    3480 </span>            : </a>
<a name="3481"><span class="lineNum">    3481 </span>            :        size_t countL= local_def-&gt;get_symbol_table()-&gt;get_symbols().size();</a>
<a name="3482"><span class="lineNum">    3482 </span>            :        size_t countG= global_def-&gt;get_symbol_table()-&gt;get_symbols().size();</a>
<a name="3483"><span class="lineNum">    3483 </span>            :        if (countG &lt; countL)</a>
<a name="3484"><span class="lineNum">    3484 </span>            :        {</a>
<a name="3485"><span class="lineNum">    3485 </span>            :          printf (&quot;Error: namespace definitions: global definition =%p alias symbol count %zd is smaller than local definition=%p symbol count %zd\n&quot;,</a>
<a name="3486"><span class="lineNum">    3486 </span>            :             global_def, countG, local_def, countL);</a>
<a name="3487"><span class="lineNum">    3487 </span>            :          ROSE_ABORT();</a>
<a name="3488"><span class="lineNum">    3488 </span>            :        }</a>
<a name="3489"><span class="lineNum">    3489 </span>            :      }</a>
<a name="3490"><span class="lineNum">    3490 </span>            : #endif</a>
<a name="3491"><span class="lineNum">    3491 </span><span class="lineCov">    5466810 :    }</span></a>
<a name="3492"><span class="lineNum">    3492 </span>            : </a>
<a name="3493"><span class="lineNum">    3493 </span>            : </a>
<a name="3494"><span class="lineNum">    3494 </span>            : void</a>
<a name="3495"><span class="lineNum">    3495 </span><span class="lineCov">    5466810 : TestAstAccessToDeclarations::visit ( SgNode* node )</span></a>
<a name="3496"><span class="lineNum">    3496 </span>            :    {</a>
<a name="3497"><span class="lineNum">    3497 </span>            :   // DQ (8/5/2005): Test the get_declaration() member function which is common on many IR nodes</a>
<a name="3498"><span class="lineNum">    3498 </span>            :   // printf (&quot;node = %s \n&quot;,node-&gt;sage_class_name());</a>
<a name="3499"><span class="lineNum">    3499 </span>            : </a>
<a name="3500"><span class="lineNum">    3500 </span><span class="lineCov">    5466810 :      TestAstAccessToDeclarations::test(node);</span></a>
<a name="3501"><span class="lineNum">    3501 </span><span class="lineCov">    5466810 :    }</span></a>
<a name="3502"><span class="lineNum">    3502 </span>            : </a>
<a name="3503"><span class="lineNum">    3503 </span>            : void</a>
<a name="3504"><span class="lineNum">    3504 </span><span class="lineCov">    6791650 : TestAstAccessToDeclarations::test ( SgNode* node )</span></a>
<a name="3505"><span class="lineNum">    3505 </span>            :    {</a>
<a name="3506"><span class="lineNum">    3506 </span>            :   // DQ (8/5/2005): Test the get_declaration() member function which is common on many IR nodes</a>
<a name="3507"><span class="lineNum">    3507 </span>            :   // printf (&quot;node = %s \n&quot;,node-&gt;sage_class_name());</a>
<a name="3508"><span class="lineNum">    3508 </span>            : </a>
<a name="3509"><span class="lineNum">    3509 </span><span class="lineCov">    6791650 :      switch (node-&gt;variantT())</span></a>
<a name="3510"><span class="lineNum">    3510 </span>            :         {</a>
<a name="3511"><span class="lineNum">    3511 </span>            :        // IR nodes that have a get_declaration member function</a>
<a name="3512"><span class="lineNum">    3512 </span><span class="lineCov">    2926070 :           case V_SgInitializedName:</span></a>
<a name="3513"><span class="lineNum">    3513 </span><span class="lineCov">    2926070 :              {</span></a>
<a name="3514"><span class="lineNum">    3514 </span><span class="lineCov">    2926070 :                SgInitializedName* initializedName = isSgInitializedName(node);</span></a>
<a name="3515"><span class="lineNum">    3515 </span>            :             // Every variable should have a declaration (but initialized name objects</a>
<a name="3516"><span class="lineNum">    3516 </span>            :             // are used in many ways, so it is not clear if this is always true)</a>
<a name="3517"><span class="lineNum">    3517 </span>            : </a>
<a name="3518"><span class="lineNum">    3518 </span>            :             // DQ (9/6/2005): This can be NULL when in a function parameter list of a</a>
<a name="3519"><span class="lineNum">    3519 </span>            :             // forward function declaration (but only if the parent has not been set)</a>
<a name="3520"><span class="lineNum">    3520 </span><span class="lineCov">    2926070 :                if (initializedName-&gt;get_declaration() == NULL)</span></a>
<a name="3521"><span class="lineNum">    3521 </span>            :                   {</a>
<a name="3522"><span class="lineNum">    3522 </span><span class="lineNoCov">          0 :                     printf (&quot;initializedName with NULL declaration at %p name = %s (seems to apply to function parameters) \n&quot;,</span></a>
<a name="3523"><span class="lineNum">    3523 </span><span class="lineNoCov">          0 :                          initializedName,initializedName-&gt;get_name().str());</span></a>
<a name="3524"><span class="lineNum">    3524 </span><span class="lineNoCov">          0 :                     initializedName-&gt;get_file_info()-&gt;display(&quot;initializedName with NULL declaration&quot;);</span></a>
<a name="3525"><span class="lineNum">    3525 </span>            :                   }</a>
<a name="3526"><span class="lineNum">    3526 </span>            :             // DQ (6/18/2006): Commented out as a test.</a>
<a name="3527"><span class="lineNum">    3527 </span>            :             // ROSE_ASSERT(initializedName-&gt;get_declaration() != NULL);</a>
<a name="3528"><span class="lineNum">    3528 </span>            :                break;</a>
<a name="3529"><span class="lineNum">    3529 </span>            :              }</a>
<a name="3530"><span class="lineNum">    3530 </span>            : </a>
<a name="3531"><span class="lineNum">    3531 </span><span class="lineNoCov">          0 :           case V_SgVariableDefinition:</span></a>
<a name="3532"><span class="lineNum">    3532 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="3533"><span class="lineNum">    3533 </span><span class="lineNoCov">          0 :                SgVariableDefinition* variableDefinition = isSgVariableDefinition(node);</span></a>
<a name="3534"><span class="lineNum">    3534 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(variableDefinition-&gt;get_declaration() != NULL);</span></a>
<a name="3535"><span class="lineNum">    3535 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="3536"><span class="lineNum">    3536 </span>            :              }</a>
<a name="3537"><span class="lineNum">    3537 </span>            : </a>
<a name="3538"><span class="lineNum">    3538 </span><span class="lineCov">      49257 :           case V_SgTypedefDeclaration:</span></a>
<a name="3539"><span class="lineNum">    3539 </span><span class="lineCov">      49257 :              {</span></a>
<a name="3540"><span class="lineNum">    3540 </span><span class="lineCov">      49257 :                SgTypedefDeclaration* typedefDeclaration = isSgTypedefDeclaration(node);</span></a>
<a name="3541"><span class="lineNum">    3541 </span>            :             // I can't tell that the declaration stored in the typedef declaration is used for</a>
<a name="3542"><span class="lineNum">    3542 </span>            :             // anything, it appears to often be NULL, but also it seems to not be ever used.</a>
<a name="3543"><span class="lineNum">    3543 </span>            :             // The value is valid or NULL about an equal percentage of the time in many applications.</a>
<a name="3544"><span class="lineNum">    3544 </span><span class="lineCov">      49257 :                if (typedefDeclaration-&gt;get_declaration() == NULL)</span></a>
<a name="3545"><span class="lineNum">    3545 </span>            :                   {</a>
<a name="3546"><span class="lineNum">    3546 </span>            :                  // printf (&quot;SgTypedefDeclaration::get_declaration returns NULL \n&quot;);</a>
<a name="3547"><span class="lineNum">    3547 </span>            :                   }</a>
<a name="3548"><span class="lineNum">    3548 </span>            :                  else</a>
<a name="3549"><span class="lineNum">    3549 </span>            :                   {</a>
<a name="3550"><span class="lineNum">    3550 </span>            :                  // printf (&quot;SgTypedefDeclaration::get_declaration returns VALID POINTER \n&quot;);</a>
<a name="3551"><span class="lineNum">    3551 </span>            :                   }</a>
<a name="3552"><span class="lineNum">    3552 </span>            :             // ROSE_ASSERT(typedefDeclaration-&gt;get_declaration() != NULL);</a>
<a name="3553"><span class="lineNum">    3553 </span>            :                break;</a>
<a name="3554"><span class="lineNum">    3554 </span>            :              }</a>
<a name="3555"><span class="lineNum">    3555 </span>            : </a>
<a name="3556"><span class="lineNum">    3556 </span><span class="lineCov">        746 :           case V_SgTemplateInstantiationDirectiveStatement:</span></a>
<a name="3557"><span class="lineNum">    3557 </span><span class="lineCov">        746 :              {</span></a>
<a name="3558"><span class="lineNum">    3558 </span><span class="lineCov">        746 :                SgTemplateInstantiationDirectiveStatement* templateInstantiationDirective = isSgTemplateInstantiationDirectiveStatement(node);</span></a>
<a name="3559"><span class="lineNum">    3559 </span><span class="lineCov">        746 :                ROSE_ASSERT(templateInstantiationDirective-&gt;get_declaration() != NULL);</span></a>
<a name="3560"><span class="lineNum">    3560 </span><span class="lineCov">        746 :                break;</span></a>
<a name="3561"><span class="lineNum">    3561 </span>            :              }</a>
<a name="3562"><span class="lineNum">    3562 </span>            : </a>
<a name="3563"><span class="lineNum">    3563 </span><span class="lineCov">       2240 :           case V_SgUsingDeclarationStatement:</span></a>
<a name="3564"><span class="lineNum">    3564 </span><span class="lineCov">       2240 :              {</span></a>
<a name="3565"><span class="lineNum">    3565 </span><span class="lineCov">       2240 :                SgUsingDeclarationStatement* tmp = isSgUsingDeclarationStatement(node);</span></a>
<a name="3566"><span class="lineNum">    3566 </span>            :             // struct T { enum c { i }; }; struct U : T { using T::i; };</a>
<a name="3567"><span class="lineNum">    3567 </span>            :             // causes get_declaration() to return NULL, since the object in the using</a>
<a name="3568"><span class="lineNum">    3568 </span>            :             // declaration is a SgInitializedName.</a>
<a name="3569"><span class="lineNum">    3569 </span><span class="lineCov">       2240 :                if (tmp-&gt;get_declaration() == NULL &amp;&amp; tmp-&gt;get_initializedName() == NULL)</span></a>
<a name="3570"><span class="lineNum">    3570 </span>            :                   {</a>
<a name="3571"><span class="lineNum">    3571 </span><span class="lineNoCov">          0 :                     printf (&quot;SgUsingDeclarationStatement::get_declaration() and get_initializedName() both return NULL \n&quot;);</span></a>
<a name="3572"><span class="lineNum">    3572 </span>            :                   }</a>
<a name="3573"><span class="lineNum">    3573 </span><span class="lineCov">       2240 :                ROSE_ASSERT( (tmp-&gt;get_declaration() != NULL) || (tmp-&gt;get_initializedName() != NULL) );</span></a>
<a name="3574"><span class="lineNum">    3574 </span><span class="lineCov">       2240 :                break;</span></a>
<a name="3575"><span class="lineNum">    3575 </span>            :              }</a>
<a name="3576"><span class="lineNum">    3576 </span>            : </a>
<a name="3577"><span class="lineNum">    3577 </span><span class="lineCov">      11725 :           case V_SgFunctionDefinition:</span></a>
<a name="3578"><span class="lineNum">    3578 </span><span class="lineCov">      11725 :              {</span></a>
<a name="3579"><span class="lineNum">    3579 </span><span class="lineCov">      11725 :                SgFunctionDefinition* tmp = isSgFunctionDefinition(node);</span></a>
<a name="3580"><span class="lineNum">    3580 </span><span class="lineCov">      11725 :                ROSE_ASSERT(tmp != NULL);</span></a>
<a name="3581"><span class="lineNum">    3581 </span><span class="lineCov">      11725 :                ROSE_ASSERT(tmp-&gt;get_declaration() != NULL);</span></a>
<a name="3582"><span class="lineNum">    3582 </span><span class="lineCov">      11725 :                break;</span></a>
<a name="3583"><span class="lineNum">    3583 </span>            :              }</a>
<a name="3584"><span class="lineNum">    3584 </span>            : </a>
<a name="3585"><span class="lineNum">    3585 </span><span class="lineCov">        815 :           case V_SgNamespaceDefinitionStatement:</span></a>
<a name="3586"><span class="lineNum">    3586 </span><span class="lineCov">        815 :              {</span></a>
<a name="3587"><span class="lineNum">    3587 </span><span class="lineCov">        815 :                SgNamespaceDefinitionStatement* tmp = isSgNamespaceDefinitionStatement(node);</span></a>
<a name="3588"><span class="lineNum">    3588 </span>            :             // Note that this class uses a different name since it has another member function</a>
<a name="3589"><span class="lineNum">    3589 </span>            :             // &quot;get_declarations()&quot; which returns a list of the declarations in the namespace.</a>
<a name="3590"><span class="lineNum">    3590 </span>            :             // the issue was that two member function should not be differentiated by a single</a>
<a name="3591"><span class="lineNum">    3591 </span>            :             // letter &quot;s&quot; at the end of the name!</a>
<a name="3592"><span class="lineNum">    3592 </span><span class="lineCov">        815 :                ROSE_ASSERT(tmp-&gt;get_namespaceDeclaration() != NULL);</span></a>
<a name="3593"><span class="lineNum">    3593 </span><span class="lineCov">        815 :                break;</span></a>
<a name="3594"><span class="lineNum">    3594 </span>            :              }</a>
<a name="3595"><span class="lineNum">    3595 </span>            : </a>
<a name="3596"><span class="lineNum">    3596 </span><span class="lineCov">       6337 :           case V_SgClassDefinition:</span></a>
<a name="3597"><span class="lineNum">    3597 </span><span class="lineCov">       6337 :              {</span></a>
<a name="3598"><span class="lineNum">    3598 </span><span class="lineCov">       6337 :                SgClassDefinition* tmp = isSgClassDefinition(node);</span></a>
<a name="3599"><span class="lineNum">    3599 </span><span class="lineCov">       6337 :                ROSE_ASSERT(tmp-&gt;get_declaration() != NULL);</span></a>
<a name="3600"><span class="lineNum">    3600 </span><span class="lineCov">       6337 :                break;</span></a>
<a name="3601"><span class="lineNum">    3601 </span>            :              }</a>
<a name="3602"><span class="lineNum">    3602 </span>            : </a>
<a name="3603"><span class="lineNum">    3603 </span><span class="lineCov">       2932 :           case V_SgConstructorInitializer:</span></a>
<a name="3604"><span class="lineNum">    3604 </span><span class="lineCov">       2932 :              {</span></a>
<a name="3605"><span class="lineNum">    3605 </span><span class="lineCov">       2932 :                SgConstructorInitializer* tmp = isSgConstructorInitializer(node);</span></a>
<a name="3606"><span class="lineNum">    3606 </span>            :             // constructor initializers are used for representation of casts from function return</a>
<a name="3607"><span class="lineNum">    3607 </span>            :             // types within initializers (if required).  When this happens the get_declaration()</a>
<a name="3608"><span class="lineNum">    3608 </span>            :             // (member function declaration) is NULL and get_class_decl() (the class declaration)</a>
<a name="3609"><span class="lineNum">    3609 </span>            :             // is NULL.</a>
<a name="3610"><span class="lineNum">    3610 </span>            :             // if (tmp-&gt;get_declaration() == NULL)</a>
<a name="3611"><span class="lineNum">    3611 </span>            : </a>
<a name="3612"><span class="lineNum">    3612 </span>            :             // DQ (1/16/2019): Check if this is associated with a SgNewExp with and SgArrayType type.</a>
<a name="3613"><span class="lineNum">    3613 </span><span class="lineCov">       2932 :                bool associatedWithArrayType = false;</span></a>
<a name="3614"><span class="lineNum">    3614 </span><span class="lineCov">       2932 :                if ( (tmp-&gt;get_declaration() == NULL) &amp;&amp; (tmp-&gt;get_class_decl() == NULL) &amp;&amp; (tmp-&gt;get_associated_class_unknown() == false) )</span></a>
<a name="3615"><span class="lineNum">    3615 </span>            :                   {</a>
<a name="3616"><span class="lineNum">    3616 </span>            : #if 0</a>
<a name="3617"><span class="lineNum">    3617 </span>            :                     printf (&quot;SgConstructorInitializer::get_declaration() and get_class_decl() both return NULL and get_associated_class_unknown() == false \n&quot;);</a>
<a name="3618"><span class="lineNum">    3618 </span>            : #endif</a>
<a name="3619"><span class="lineNum">    3619 </span>            :                  // DQ (1/16/2019): Check if this is associated with a SgNewExp with and SgArrayType type.</a>
<a name="3620"><span class="lineNum">    3620 </span><span class="lineNoCov">          0 :                     ROSE_ASSERT(tmp-&gt;get_parent() != NULL);</span></a>
<a name="3621"><span class="lineNum">    3621 </span>            : #if 0</a>
<a name="3622"><span class="lineNum">    3622 </span>            :                     printf (&quot;tmp-&gt;get_parent() = %p = %s \n&quot;,tmp-&gt;get_parent(),tmp-&gt;get_parent()-&gt;class_name().c_str());</a>
<a name="3623"><span class="lineNum">    3623 </span>            : #endif</a>
<a name="3624"><span class="lineNum">    3624 </span><span class="lineNoCov">          0 :                     SgNewExp* newExp = isSgNewExp(tmp-&gt;get_parent());</span></a>
<a name="3625"><span class="lineNum">    3625 </span><span class="lineNoCov">          0 :                     if (newExp != NULL)</span></a>
<a name="3626"><span class="lineNum">    3626 </span>            :                        {</a>
<a name="3627"><span class="lineNum">    3627 </span>            :                       // SgType* newExpType = newExp-&gt;get_type();</a>
<a name="3628"><span class="lineNum">    3628 </span><span class="lineNoCov">          0 :                          SgType* newExpType = newExp-&gt;get_specified_type();</span></a>
<a name="3629"><span class="lineNum">    3629 </span>            : #if 0</a>
<a name="3630"><span class="lineNum">    3630 </span>            :                          printf (&quot;newExpType = %p = %s \n&quot;,newExpType,newExpType-&gt;class_name().c_str());</a>
<a name="3631"><span class="lineNum">    3631 </span>            : #endif</a>
<a name="3632"><span class="lineNum">    3632 </span>            :                       // DQ (1/17/2019): If this is just a typedef of an array then check that.</a>
<a name="3633"><span class="lineNum">    3633 </span><span class="lineNoCov">          0 :                          SgTypedefType* typedefType = isSgTypedefType(newExpType);</span></a>
<a name="3634"><span class="lineNum">    3634 </span><span class="lineNoCov">          0 :                          if (typedefType != NULL)</span></a>
<a name="3635"><span class="lineNum">    3635 </span>            :                             {</a>
<a name="3636"><span class="lineNum">    3636 </span>            : #if 0</a>
<a name="3637"><span class="lineNum">    3637 </span>            :                               printf (&quot;typedefType-&gt;get_base_type() = %s \n&quot;,typedefType-&gt;get_base_type()-&gt;class_name().c_str());</a>
<a name="3638"><span class="lineNum">    3638 </span>            : #endif</a>
<a name="3639"><span class="lineNum">    3639 </span><span class="lineNoCov">          0 :                               newExpType = typedefType-&gt;get_base_type();</span></a>
<a name="3640"><span class="lineNum">    3640 </span>            :                             }</a>
<a name="3641"><span class="lineNum">    3641 </span>            : </a>
<a name="3642"><span class="lineNum">    3642 </span><span class="lineNoCov">          0 :                          SgArrayType* arrayType = isSgArrayType(newExpType);</span></a>
<a name="3643"><span class="lineNum">    3643 </span><span class="lineNoCov">          0 :                          if (arrayType != NULL)</span></a>
<a name="3644"><span class="lineNum">    3644 </span>            :                             {</a>
<a name="3645"><span class="lineNum">    3645 </span>            :                               associatedWithArrayType = true;</a>
<a name="3646"><span class="lineNum">    3646 </span>            :                             }</a>
<a name="3647"><span class="lineNum">    3647 </span>            :                            else</a>
<a name="3648"><span class="lineNum">    3648 </span>            :                             {</a>
<a name="3649"><span class="lineNum">    3649 </span>            :                            // DQ (1/17/2019): This case fails for Cxx11_tests/test2016_90.C.</a>
<a name="3650"><span class="lineNum">    3650 </span>            : #if 0</a>
<a name="3651"><span class="lineNum">    3651 </span>            :                               printf (&quot;Unclear how to handle this case! \n&quot;);</a>
<a name="3652"><span class="lineNum">    3652 </span>            :                               newExp-&gt;get_file_info()-&gt;display(&quot;&quot;);</a>
<a name="3653"><span class="lineNum">    3653 </span>            : #endif</a>
<a name="3654"><span class="lineNum">    3654 </span>            :                            // DQ (1/17/2019): Allow everything and debug this later!</a>
<a name="3655"><span class="lineNum">    3655 </span>            :                               associatedWithArrayType = true;</a>
<a name="3656"><span class="lineNum">    3656 </span>            :                             }</a>
<a name="3657"><span class="lineNum">    3657 </span>            :                        }</a>
<a name="3658"><span class="lineNum">    3658 </span>            :                   }</a>
<a name="3659"><span class="lineNum">    3659 </span>            : </a>
<a name="3660"><span class="lineNum">    3660 </span>            :             // DQ (1/16/2019): Check if this is associated with a SgNewExp with and SgArrayType type.</a>
<a name="3661"><span class="lineNum">    3661 </span>            :             // ROSE_ASSERT(tmp-&gt;get_declaration() != NULL);</a>
<a name="3662"><span class="lineNum">    3662 </span>            :             // ROSE_ASSERT ( (tmp-&gt;get_declaration() != NULL) || (tmp-&gt;get_class_decl() != NULL) || (tmp-&gt;get_associated_class_unknown() == true) );</a>
<a name="3663"><span class="lineNum">    3663 </span><span class="lineCov">       2932 :                ROSE_ASSERT ( (tmp-&gt;get_declaration() != NULL) || (tmp-&gt;get_class_decl() != NULL) || (tmp-&gt;get_associated_class_unknown() == true) || (associatedWithArrayType == true) );</span></a>
<a name="3664"><span class="lineNum">    3664 </span><span class="lineCov">       2932 :                break;</span></a>
<a name="3665"><span class="lineNum">    3665 </span>            :              }</a>
<a name="3666"><span class="lineNum">    3666 </span>            : </a>
<a name="3667"><span class="lineNum">    3667 </span><span class="lineCov">       7940 :           case V_SgEnumVal:</span></a>
<a name="3668"><span class="lineNum">    3668 </span><span class="lineCov">       7940 :              {</span></a>
<a name="3669"><span class="lineNum">    3669 </span><span class="lineCov">       7940 :                SgEnumVal* tmp = isSgEnumVal(node);</span></a>
<a name="3670"><span class="lineNum">    3670 </span><span class="lineCov">       7940 :                if (tmp-&gt;get_declaration() == NULL)</span></a>
<a name="3671"><span class="lineNum">    3671 </span>            :                   {</a>
<a name="3672"><span class="lineNum">    3672 </span><span class="lineNoCov">          0 :                     printf (&quot;### Error: Need to fixup declaration in SgEnumVal node = %p ### \n&quot;,node);</span></a>
<a name="3673"><span class="lineNum">    3673 </span>            :                   }</a>
<a name="3674"><span class="lineNum">    3674 </span>            :             // ROSE_ASSERT(tmp-&gt;get_declaration() != NULL);</a>
<a name="3675"><span class="lineNum">    3675 </span>            :                break;</a>
<a name="3676"><span class="lineNum">    3676 </span>            :              }</a>
<a name="3677"><span class="lineNum">    3677 </span>            : </a>
<a name="3678"><span class="lineNum">    3678 </span>            :        // This function is called from the symbol table tests (so that symbols are tested)</a>
<a name="3679"><span class="lineNum">    3679 </span><span class="lineCov">      49140 :           case V_SgVariableSymbol:</span></a>
<a name="3680"><span class="lineNum">    3680 </span><span class="lineCov">      49140 :              {</span></a>
<a name="3681"><span class="lineNum">    3681 </span><span class="lineCov">      49140 :                SgVariableSymbol* tmp = isSgVariableSymbol(node);</span></a>
<a name="3682"><span class="lineNum">    3682 </span><span class="lineCov">      49140 :                ROSE_ASSERT(tmp-&gt;get_declaration() != NULL);</span></a>
<a name="3683"><span class="lineNum">    3683 </span><span class="lineCov">      49140 :                break;</span></a>
<a name="3684"><span class="lineNum">    3684 </span>            :              }</a>
<a name="3685"><span class="lineNum">    3685 </span>            : </a>
<a name="3686"><span class="lineNum">    3686 </span>            :        // This function is called from the symbol table tests (so that symbols are tested)</a>
<a name="3687"><span class="lineNum">    3687 </span><span class="lineCov">      11376 :           case V_SgClassSymbol:</span></a>
<a name="3688"><span class="lineNum">    3688 </span><span class="lineCov">      11376 :              {</span></a>
<a name="3689"><span class="lineNum">    3689 </span><span class="lineCov">      11376 :                SgClassSymbol* tmp = isSgClassSymbol(node);</span></a>
<a name="3690"><span class="lineNum">    3690 </span><span class="lineCov">      11376 :                ROSE_ASSERT(tmp-&gt;get_declaration() != NULL);</span></a>
<a name="3691"><span class="lineNum">    3691 </span><span class="lineCov">      11376 :                break;</span></a>
<a name="3692"><span class="lineNum">    3692 </span>            :              }</a>
<a name="3693"><span class="lineNum">    3693 </span>            : </a>
<a name="3694"><span class="lineNum">    3694 </span>            :        // This function is called from the symbol table tests (so that symbols are tested)</a>
<a name="3695"><span class="lineNum">    3695 </span><span class="lineNoCov">          0 :           case V_SgTemplateSymbol:</span></a>
<a name="3696"><span class="lineNum">    3696 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="3697"><span class="lineNum">    3697 </span><span class="lineNoCov">          0 :                SgTemplateSymbol* tmp = isSgTemplateSymbol(node);</span></a>
<a name="3698"><span class="lineNum">    3698 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(tmp-&gt;get_declaration() != NULL);</span></a>
<a name="3699"><span class="lineNum">    3699 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="3700"><span class="lineNum">    3700 </span>            :              }</a>
<a name="3701"><span class="lineNum">    3701 </span>            : </a>
<a name="3702"><span class="lineNum">    3702 </span>            :        // This function is called from the symbol table tests (so that symbols are tested)</a>
<a name="3703"><span class="lineNum">    3703 </span><span class="lineCov">       1264 :           case V_SgEnumSymbol:</span></a>
<a name="3704"><span class="lineNum">    3704 </span><span class="lineCov">       1264 :              {</span></a>
<a name="3705"><span class="lineNum">    3705 </span><span class="lineCov">       1264 :                SgEnumSymbol* tmp = isSgEnumSymbol(node);</span></a>
<a name="3706"><span class="lineNum">    3706 </span><span class="lineCov">       1264 :                ROSE_ASSERT(tmp-&gt;get_declaration() != NULL);</span></a>
<a name="3707"><span class="lineNum">    3707 </span><span class="lineCov">       1264 :                break;</span></a>
<a name="3708"><span class="lineNum">    3708 </span>            :              }</a>
<a name="3709"><span class="lineNum">    3709 </span>            : </a>
<a name="3710"><span class="lineNum">    3710 </span>            :        // This function is called from the symbol table tests (so that symbols are tested)</a>
<a name="3711"><span class="lineNum">    3711 </span><span class="lineCov">       5916 :           case V_SgEnumFieldSymbol:</span></a>
<a name="3712"><span class="lineNum">    3712 </span><span class="lineCov">       5916 :              {</span></a>
<a name="3713"><span class="lineNum">    3713 </span><span class="lineCov">       5916 :                SgEnumFieldSymbol* tmp = isSgEnumFieldSymbol(node);</span></a>
<a name="3714"><span class="lineNum">    3714 </span><span class="lineCov">       5916 :                ROSE_ASSERT(tmp-&gt;get_declaration() != NULL);</span></a>
<a name="3715"><span class="lineNum">    3715 </span><span class="lineCov">       5916 :                break;</span></a>
<a name="3716"><span class="lineNum">    3716 </span>            :              }</a>
<a name="3717"><span class="lineNum">    3717 </span>            : </a>
<a name="3718"><span class="lineNum">    3718 </span>            :        // This function is called from the symbol table tests (so that symbols are tested)</a>
<a name="3719"><span class="lineNum">    3719 </span><span class="lineCov">      49550 :           case V_SgTypedefSymbol:</span></a>
<a name="3720"><span class="lineNum">    3720 </span><span class="lineCov">      49550 :              {</span></a>
<a name="3721"><span class="lineNum">    3721 </span><span class="lineCov">      49550 :                SgTypedefSymbol* tmp = isSgTypedefSymbol(node);</span></a>
<a name="3722"><span class="lineNum">    3722 </span><span class="lineCov">      49550 :                if (tmp-&gt;get_declaration() == NULL)</span></a>
<a name="3723"><span class="lineNum">    3723 </span>            :                   {</a>
<a name="3724"><span class="lineNum">    3724 </span><span class="lineNoCov">          0 :                     printf (&quot;SgTypedefSymbol::get_declaration returns NULL \n&quot;);</span></a>
<a name="3725"><span class="lineNum">    3725 </span>            :                   }</a>
<a name="3726"><span class="lineNum">    3726 </span><span class="lineCov">      49550 :                ROSE_ASSERT(tmp-&gt;get_declaration() != NULL);</span></a>
<a name="3727"><span class="lineNum">    3727 </span><span class="lineCov">      49550 :                break;</span></a>
<a name="3728"><span class="lineNum">    3728 </span>            :              }</a>
<a name="3729"><span class="lineNum">    3729 </span>            : </a>
<a name="3730"><span class="lineNum">    3730 </span>            :        // This function is called from the symbol table tests (so that symbols are tested)</a>
<a name="3731"><span class="lineNum">    3731 </span><span class="lineCov">          9 :           case V_SgLabelSymbol:</span></a>
<a name="3732"><span class="lineNum">    3732 </span><span class="lineCov">          9 :              {</span></a>
<a name="3733"><span class="lineNum">    3733 </span><span class="lineCov">          9 :                SgLabelSymbol* tmp = isSgLabelSymbol(node);</span></a>
<a name="3734"><span class="lineNum">    3734 </span>            : </a>
<a name="3735"><span class="lineNum">    3735 </span>            :             // DQ (12/9/2007): Modified to reflect added support for fortran statement numeric labels.</a>
<a name="3736"><span class="lineNum">    3736 </span>            :             // ROSE_ASSERT(tmp-&gt;get_declaration() != NULL);</a>
<a name="3737"><span class="lineNum">    3737 </span><span class="lineCov">          9 :                if (tmp-&gt;get_declaration() == NULL)</span></a>
<a name="3738"><span class="lineNum">    3738 </span>            :                   {</a>
<a name="3739"><span class="lineNum">    3739 </span>            : #if 0</a>
<a name="3740"><span class="lineNum">    3740 </span>            :                     ROSE_ASSERT(tmp-&gt;get_fortran_statement() != NULL);</a>
<a name="3741"><span class="lineNum">    3741 </span>            : #else</a>
<a name="3742"><span class="lineNum">    3742 </span>            :                  // DQ (2/2/2011): Added support in SgLabelSymbol for Fortran alternative return parameters (see test2010_164.f90).</a>
<a name="3743"><span class="lineNum">    3743 </span><span class="lineCov">          4 :                     if (tmp-&gt;get_fortran_statement() == NULL)</span></a>
<a name="3744"><span class="lineNum">    3744 </span>            :                        {</a>
<a name="3745"><span class="lineNum">    3745 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(tmp-&gt;get_fortran_alternate_return_parameter() != NULL);</span></a>
<a name="3746"><span class="lineNum">    3746 </span>            :                        }</a>
<a name="3747"><span class="lineNum">    3747 </span>            : #endif</a>
<a name="3748"><span class="lineNum">    3748 </span>            :                   }</a>
<a name="3749"><span class="lineNum">    3749 </span>            :                break;</a>
<a name="3750"><span class="lineNum">    3750 </span>            :              }</a>
<a name="3751"><span class="lineNum">    3751 </span>            : </a>
<a name="3752"><span class="lineNum">    3752 </span>            :        // This function is called from the symbol table tests (so that symbols are tested)</a>
<a name="3753"><span class="lineNum">    3753 </span><span class="lineCov">        107 :           case V_SgNamespaceSymbol:</span></a>
<a name="3754"><span class="lineNum">    3754 </span><span class="lineCov">        107 :              {</span></a>
<a name="3755"><span class="lineNum">    3755 </span><span class="lineCov">        107 :                SgNamespaceSymbol* tmp = isSgNamespaceSymbol(node);</span></a>
<a name="3756"><span class="lineNum">    3756 </span>            : </a>
<a name="3757"><span class="lineNum">    3757 </span>            :             // DQ (8/30/2009): Added namespace alias support.</a>
<a name="3758"><span class="lineNum">    3758 </span>            :             // ROSE_ASSERT(tmp-&gt;get_declaration() != NULL);</a>
<a name="3759"><span class="lineNum">    3759 </span><span class="lineCov">        107 :                ROSE_ASSERT( (tmp-&gt;get_declaration() != NULL &amp;&amp; tmp-&gt;get_isAlias() == false) || (tmp-&gt;get_aliasDeclaration() != NULL &amp;&amp; tmp-&gt;get_isAlias() == true) );</span></a>
<a name="3760"><span class="lineNum">    3760 </span><span class="lineCov">        107 :                break;</span></a>
<a name="3761"><span class="lineNum">    3761 </span>            :              }</a>
<a name="3762"><span class="lineNum">    3762 </span>            : </a>
<a name="3763"><span class="lineNum">    3763 </span>            :        // This function is called from the symbol table tests (so that symbols are tested)</a>
<a name="3764"><span class="lineNum">    3764 </span><span class="lineCov">     757557 :           case V_SgFunctionSymbol:</span></a>
<a name="3765"><span class="lineNum">    3765 </span><span class="lineCov">     757557 :              {</span></a>
<a name="3766"><span class="lineNum">    3766 </span><span class="lineCov">     757557 :                SgFunctionSymbol* tmp = isSgFunctionSymbol(node);</span></a>
<a name="3767"><span class="lineNum">    3767 </span><span class="lineCov">     757557 :                ROSE_ASSERT(tmp-&gt;get_declaration() != NULL);</span></a>
<a name="3768"><span class="lineNum">    3768 </span><span class="lineCov">     757557 :                break;</span></a>
<a name="3769"><span class="lineNum">    3769 </span>            :              }</a>
<a name="3770"><span class="lineNum">    3770 </span>            : </a>
<a name="3771"><span class="lineNum">    3771 </span>            :        // This function is called from the symbol table tests (so that symbols are tested)</a>
<a name="3772"><span class="lineNum">    3772 </span><span class="lineCov">      12092 :           case V_SgMemberFunctionSymbol:</span></a>
<a name="3773"><span class="lineNum">    3773 </span><span class="lineCov">      12092 :              {</span></a>
<a name="3774"><span class="lineNum">    3774 </span><span class="lineCov">      12092 :                SgMemberFunctionSymbol* tmp = isSgMemberFunctionSymbol(node);</span></a>
<a name="3775"><span class="lineNum">    3775 </span><span class="lineCov">      12092 :                ROSE_ASSERT(tmp-&gt;get_declaration() != NULL);</span></a>
<a name="3776"><span class="lineNum">    3776 </span><span class="lineCov">      12092 :                break;</span></a>
<a name="3777"><span class="lineNum">    3777 </span>            :              }</a>
<a name="3778"><span class="lineNum">    3778 </span>            : </a>
<a name="3779"><span class="lineNum">    3779 </span>            :        // This function is called from the type tests (so that these types are tested)</a>
<a name="3780"><span class="lineNum">    3780 </span><span class="lineCov">      63326 :           case V_SgNamedType:</span></a>
<a name="3781"><span class="lineNum">    3781 </span><span class="lineCov">      63326 :           case V_SgClassType:</span></a>
<a name="3782"><span class="lineNum">    3782 </span><span class="lineCov">      63326 :           case V_SgEnumType:</span></a>
<a name="3783"><span class="lineNum">    3783 </span><span class="lineCov">      63326 :           case V_SgTypedefType:</span></a>
<a name="3784"><span class="lineNum">    3784 </span><span class="lineCov">      63326 :              {</span></a>
<a name="3785"><span class="lineNum">    3785 </span><span class="lineCov">      63326 :                SgNamedType* tmp = isSgNamedType(node);</span></a>
<a name="3786"><span class="lineNum">    3786 </span><span class="lineCov">      63326 :                ROSE_ASSERT(tmp-&gt;get_declaration() != NULL);</span></a>
<a name="3787"><span class="lineNum">    3787 </span><span class="lineCov">      63326 :                break;</span></a>
<a name="3788"><span class="lineNum">    3788 </span>            :              }</a>
<a name="3789"><span class="lineNum">    3789 </span>            : </a>
<a name="3790"><span class="lineNum">    3790 </span><span class="lineCov">    6791650 :           default:</span></a>
<a name="3791"><span class="lineNum">    3791 </span><span class="lineCov">    6791650 :              {</span></a>
<a name="3792"><span class="lineNum">    3792 </span>            :             // Numerous IR nodes don't have a get_declaration member function and these are ignored!</a>
<a name="3793"><span class="lineNum">    3793 </span>            :              }</a>
<a name="3794"><span class="lineNum">    3794 </span>            :         }</a>
<a name="3795"><span class="lineNum">    3795 </span><span class="lineCov">    6791650 :    }</span></a>
<a name="3796"><span class="lineNum">    3796 </span>            : </a>
<a name="3797"><span class="lineNum">    3797 </span>            : </a>
<a name="3798"><span class="lineNum">    3798 </span><span class="lineCov">        326 : TestExpressionTypes::TestExpressionTypes()</span></a>
<a name="3799"><span class="lineNum">    3799 </span>            :    {</a>
<a name="3800"><span class="lineNum">    3800 </span>            :   // DQ (10/31/2016): Use this mechanism to make traversals transformation-safe (it works).</a>
<a name="3801"><span class="lineNum">    3801 </span>            :   // myProcessingObject-&gt;set_useDefaultIndexBasedTraversal(false);</a>
<a name="3802"><span class="lineNum">    3802 </span><span class="lineCov">        326 :      set_useDefaultIndexBasedTraversal(false);</span></a>
<a name="3803"><span class="lineNum">    3803 </span><span class="lineCov">        326 :    }</span></a>
<a name="3804"><span class="lineNum">    3804 </span>            : </a>
<a name="3805"><span class="lineNum">    3805 </span>            : void</a>
<a name="3806"><span class="lineNum">    3806 </span><span class="lineCov">    5466810 : TestExpressionTypes::visit ( SgNode* node )</span></a>
<a name="3807"><span class="lineNum">    3807 </span>            :    {</a>
<a name="3808"><span class="lineNum">    3808 </span>            :   // DQ (2/21/2006): Test the get_type() member function which is common on many IR nodes</a>
<a name="3809"><span class="lineNum">    3809 </span>            :   // printf (&quot;In TestExpressionTypes::visit(): node = %s \n&quot;,node-&gt;class_name().c_str());</a>
<a name="3810"><span class="lineNum">    3810 </span><span class="lineCov">    5466810 :      SgExpression* expression = isSgExpression(node);</span></a>
<a name="3811"><span class="lineNum">    3811 </span>            : </a>
<a name="3812"><span class="lineNum">    3812 </span>            :   // DQ(11/6/2016): Debugging failing mergeTest_133.C that is only demonstrated using Address Sanitizer</a>
<a name="3813"><span class="lineNum">    3813 </span>            :   // and setting the memory pool length to be 1.  Using this value below to control calling the</a>
<a name="3814"><span class="lineNum">    3814 </span>            :   // SgStringVal::get_type() function appears to be all the is required to fix the memory error.</a>
<a name="3815"><span class="lineNum">    3815 </span>            :   // At present I still don't understand the problem, but it apears to have to do with the</a>
<a name="3816"><span class="lineNum">    3816 </span>            :   // allocation of the SgIntVal object used within the SgStringType.  Note that at present</a>
<a name="3817"><span class="lineNum">    3817 </span>            :   // this is a memory error associated only with the regression tests in the mergeAST_tests</a>
<a name="3818"><span class="lineNum">    3818 </span>            :   // directory.  The failing tests are reproducable, but only on an odd subset of machines</a>
<a name="3819"><span class="lineNum">    3819 </span>            :   // and at present (before this fix) only in tests run using CMake.</a>
<a name="3820"><span class="lineNum">    3820 </span><span class="lineCov">    5466810 :      bool skipProblemExpresion = (isSgStringVal(expression) != NULL);</span></a>
<a name="3821"><span class="lineNum">    3821 </span>            : </a>
<a name="3822"><span class="lineNum">    3822 </span>            :   // DQ(11/6/2016): Debugging failing mergeTest_133.C: restrict to exclude calling SgStringVal::get_type().</a>
<a name="3823"><span class="lineNum">    3823 </span>            :   // if (expression != NULL)</a>
<a name="3824"><span class="lineNum">    3824 </span><span class="lineCov">    5466810 :      if (expression != NULL &amp;&amp; skipProblemExpresion == false)</span></a>
<a name="3825"><span class="lineNum">    3825 </span>            :         {</a>
<a name="3826"><span class="lineNum">    3826 </span>            : #if 1</a>
<a name="3827"><span class="lineNum">    3827 </span>            :        // DQ (10/31/2016): Testing to debug mergeTest_04.C and mergeTest_111.C.</a>
<a name="3828"><span class="lineNum">    3828 </span>            : </a>
<a name="3829"><span class="lineNum">    3829 </span>            :        // printf (&quot;TestExpressionTypes::visit(): before calling expression-&gt;get_type() on expression = %p = %s call TestNodes::test() \n&quot;,expression,expression-&gt;class_name().c_str());</a>
<a name="3830"><span class="lineNum">    3830 </span>            : </a>
<a name="3831"><span class="lineNum">    3831 </span>            :        // DQ (10/25/2016): Testing IR node integrity. This test makes the traversla order (n^2).</a>
<a name="3832"><span class="lineNum">    3832 </span>            :        // TestNodes::test();</a>
<a name="3833"><span class="lineNum">    3833 </span>            : </a>
<a name="3834"><span class="lineNum">    3834 </span>            :        // printf (&quot;TestExpressionTypes::visit(): calling expression-&gt;get_type() on expression = %p = %s (after TestNodes::test()) \n&quot;,expression,expression-&gt;class_name().c_str());</a>
<a name="3835"><span class="lineNum">    3835 </span>            : </a>
<a name="3836"><span class="lineNum">    3836 </span><span class="lineCov">     208100 :           SgType* type = expression-&gt;get_type();</span></a>
<a name="3837"><span class="lineNum">    3837 </span><span class="lineCov">     208100 :           ROSE_ASSERT(type != NULL);</span></a>
<a name="3838"><span class="lineNum">    3838 </span>            : </a>
<a name="3839"><span class="lineNum">    3839 </span>            :        // DQ (10/25/2016): Testing IR node integrity. This test makes the traversla order (n^2).</a>
<a name="3840"><span class="lineNum">    3840 </span>            :        // TestNodes::test();</a>
<a name="3841"><span class="lineNum">    3841 </span>            : #endif</a>
<a name="3842"><span class="lineNum">    3842 </span>            : #if 1</a>
<a name="3843"><span class="lineNum">    3843 </span>            :        // DQ (10/31/2016): Testing to debug mergeTest_04.C and mergeTest_111.C.</a>
<a name="3844"><span class="lineNum">    3844 </span>            : </a>
<a name="3845"><span class="lineNum">    3845 </span>            :        // printf (&quot;TestExpressionTypes::visit(): calling expression-&gt;get_type() on expression = %p = %s type = %s \n&quot;,expression,expression-&gt;class_name().c_str(),type-&gt;class_name().c_str());</a>
<a name="3846"><span class="lineNum">    3846 </span>            :        // PC (10/12/2009): The following test verifies that array types properly decay to pointer types</a>
<a name="3847"><span class="lineNum">    3847 </span>            :        //  From C99 6.3.2.1p3:</a>
<a name="3848"><span class="lineNum">    3848 </span>            :        /* Except when it is the operand of the sizeof operator or the unary &amp; operator, or is a</a>
<a name="3849"><span class="lineNum">    3849 </span>            :           string literal used to initialize an array, an expression that has type array of type is</a>
<a name="3850"><span class="lineNum">    3850 </span>            :           converted to an expression with type pointer to type that points to the initial element of</a>
<a name="3851"><span class="lineNum">    3851 </span>            :           the array object and is not an lvalue. */</a>
<a name="3852"><span class="lineNum">    3852 </span><span class="lineCov">     208100 :           type = type-&gt;stripTypedefsAndModifiers();</span></a>
<a name="3853"><span class="lineNum">    3853 </span><span class="lineCov">     208100 :           ROSE_ASSERT(type != NULL);</span></a>
<a name="3854"><span class="lineNum">    3854 </span><span class="lineCov">     208100 :           if (type-&gt;variantT() == V_SgArrayType || type-&gt;variantT() == V_SgTypeString)</span></a>
<a name="3855"><span class="lineNum">    3855 </span>            :              {</a>
<a name="3856"><span class="lineNum">    3856 </span><span class="lineCov">       1254 :                SgExpression *parentExpr = isSgExpression(expression-&gt;get_parent());</span></a>
<a name="3857"><span class="lineNum">    3857 </span><span class="lineCov">       3311 :                if (parentExpr != NULL &amp;&amp; !(</span></a>
<a name="3858"><span class="lineNum">    3858 </span>            : #if 0</a>
<a name="3859"><span class="lineNum">    3859 </span>            :                                     // DQ (10/27/2015): Fixed warning from GNU 4.8.3 compiler.</a>
<a name="3860"><span class="lineNum">    3860 </span>            :                                     // parentExpr-&gt;variantT() == V_SgAssignInitializer &amp;&amp; expression-&gt;variantT() == V_SgStringVal</a>
<a name="3861"><span class="lineNum">    3861 </span>            :                                       (parentExpr-&gt;variantT() == V_SgAssignInitializer &amp;&amp; expression-&gt;variantT() == V_SgStringVal)</a>
<a name="3862"><span class="lineNum">    3862 </span>            :                                     || parentExpr-&gt;variantT() == V_SgDotExp</a>
<a name="3863"><span class="lineNum">    3863 </span>            :                                     || parentExpr-&gt;variantT() == V_SgArrowExp</a>
<a name="3864"><span class="lineNum">    3864 </span>            :                                  // DQ (10/27/2015): Fixed warning from GNU 4.8.3 compiler.</a>
<a name="3865"><span class="lineNum">    3865 </span>            :                                  // || isSgInitializer(parentExpr) &amp;&amp; isSgInitializer(expression)))</a>
<a name="3866"><span class="lineNum">    3866 </span>            : #else</a>
<a name="3867"><span class="lineNum">    3867 </span>            :                                  // DQ (10/31/2015): I think this is fixing the same issue (and resulted in a conflict).</a>
<a name="3868"><span class="lineNum">    3868 </span><span class="lineCov">       1167 :                                     (parentExpr-&gt;variantT() == V_SgAssignInitializer &amp;&amp; expression-&gt;variantT() == V_SgStringVal)</span></a>
<a name="3869"><span class="lineNum">    3869 </span><span class="lineCov">       1167 :                                     || parentExpr-&gt;variantT() == V_SgDotExp</span></a>
<a name="3870"><span class="lineNum">    3870 </span><span class="lineCov">       1076 :                                     || parentExpr-&gt;variantT() == V_SgArrowExp</span></a>
<a name="3871"><span class="lineNum">    3871 </span>            : #endif</a>
<a name="3872"><span class="lineNum">    3872 </span><span class="lineCov">        890 :                                     || (isSgInitializer(parentExpr) &amp;&amp; isSgInitializer(expression))))</span></a>
<a name="3873"><span class="lineNum">    3873 </span>            :                   {</a>
<a name="3874"><span class="lineNum">    3874 </span><span class="lineCov">        890 :                     SgType* parentType = parentExpr-&gt;get_type();</span></a>
<a name="3875"><span class="lineNum">    3875 </span><span class="lineCov">        890 :                     parentType = parentType-&gt;stripTypedefsAndModifiers();</span></a>
<a name="3876"><span class="lineNum">    3876 </span><span class="lineCov">        890 :                     if (SageInterface::getDimensionCount(type) == SageInterface::getDimensionCount(parentType)</span></a>
<a name="3877"><span class="lineNum">    3877 </span><span class="lineCov">        890 :                      &amp;&amp; SageInterface::getArrayElementType(type) == SageInterface::getArrayElementType(parentType))</span></a>
<a name="3878"><span class="lineNum">    3878 </span>            :                        {</a>
<a name="3879"><span class="lineNum">    3879 </span><span class="lineNoCov">          0 :                          SgValueExp *parentValueExpr = isSgValueExp(parentExpr);</span></a>
<a name="3880"><span class="lineNum">    3880 </span><span class="lineNoCov">          0 :                          if (parentValueExpr == NULL || expression != parentValueExpr-&gt;get_originalExpressionTree())</span></a>
<a name="3881"><span class="lineNum">    3881 </span>            :                             {</a>
<a name="3882"><span class="lineNum">    3882 </span>            :                            // DQ (9/14/2010): Make this a level 1 warning. It is common for Fortran code but never see for C++ code.</a>
<a name="3883"><span class="lineNum">    3883 </span><span class="lineNoCov">          0 :                               if ( SgProject::get_verbose() &gt; 0 )</span></a>
<a name="3884"><span class="lineNum">    3884 </span>            :                                  {</a>
<a name="3885"><span class="lineNum">    3885 </span><span class="lineNoCov">          0 :                                    printf (&quot;Warning: encountered a case where an array type did not decay to a pointer type\n&quot;</span></a>
<a name="3886"><span class="lineNum">    3886 </span>            :                                            &quot;  parentExpr = %p = %s, expression = %p = %s, parentType = %p = %s, type = %p = %s\n&quot;,</a>
<a name="3887"><span class="lineNum">    3887 </span><span class="lineNoCov">          0 :                                                    parentExpr, parentExpr-&gt;sage_class_name(),</span></a>
<a name="3888"><span class="lineNum">    3888 </span><span class="lineNoCov">          0 :                                                    expression, expression-&gt;sage_class_name(),</span></a>
<a name="3889"><span class="lineNum">    3889 </span><span class="lineNoCov">          0 :                                                    parentType, parentType-&gt;sage_class_name(),</span></a>
<a name="3890"><span class="lineNum">    3890 </span><span class="lineNoCov">          0 :                                                    type, type-&gt;sage_class_name());</span></a>
<a name="3891"><span class="lineNum">    3891 </span>            :                                  }</a>
<a name="3892"><span class="lineNum">    3892 </span>            :                            // ROSE_ASSERT(false);</a>
<a name="3893"><span class="lineNum">    3893 </span>            :                             }</a>
<a name="3894"><span class="lineNum">    3894 </span>            :                        }</a>
<a name="3895"><span class="lineNum">    3895 </span>            :                   }</a>
<a name="3896"><span class="lineNum">    3896 </span>            :              }</a>
<a name="3897"><span class="lineNum">    3897 </span>            : #endif</a>
<a name="3898"><span class="lineNum">    3898 </span>            :         }</a>
<a name="3899"><span class="lineNum">    3899 </span>            : </a>
<a name="3900"><span class="lineNum">    3900 </span>            : #if 1</a>
<a name="3901"><span class="lineNum">    3901 </span>            :   // DQ (10/31/2016): Testing to debug mergeTest_04.C and mergeTest_111.C.</a>
<a name="3902"><span class="lineNum">    3902 </span>            : </a>
<a name="3903"><span class="lineNum">    3903 </span><span class="lineCov">    5466810 :      SgType* type = NULL;</span></a>
<a name="3904"><span class="lineNum">    3904 </span><span class="lineCov">    5466810 :      switch (node-&gt;variantT())</span></a>
<a name="3905"><span class="lineNum">    3905 </span>            :         {</a>
<a name="3906"><span class="lineNum">    3906 </span>            :        // IR nodes that have a get_type member function</a>
<a name="3907"><span class="lineNum">    3907 </span><span class="lineCov">    2926070 :           case V_SgInitializedName:</span></a>
<a name="3908"><span class="lineNum">    3908 </span><span class="lineCov">    2926070 :              {</span></a>
<a name="3909"><span class="lineNum">    3909 </span><span class="lineCov">    2926070 :                SgInitializedName* initializedName = isSgInitializedName(node);</span></a>
<a name="3910"><span class="lineNum">    3910 </span><span class="lineCov">    2926070 :                ROSE_ASSERT(initializedName-&gt;get_type() != NULL);</span></a>
<a name="3911"><span class="lineNum">    3911 </span><span class="lineCov">    2926070 :                type = initializedName-&gt;get_type();</span></a>
<a name="3912"><span class="lineNum">    3912 </span><span class="lineCov">    2926070 :                break;</span></a>
<a name="3913"><span class="lineNum">    3913 </span>            :              }</a>
<a name="3914"><span class="lineNum">    3914 </span><span class="lineNoCov">          0 :           case V_SgTemplateParameter:</span></a>
<a name="3915"><span class="lineNum">    3915 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="3916"><span class="lineNum">    3916 </span><span class="lineNoCov">          0 :                SgTemplateParameter* x = isSgTemplateParameter(node);</span></a>
<a name="3917"><span class="lineNum">    3917 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(x-&gt;get_type() != NULL);</span></a>
<a name="3918"><span class="lineNum">    3918 </span><span class="lineNoCov">          0 :                type = x-&gt;get_type();</span></a>
<a name="3919"><span class="lineNum">    3919 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="3920"><span class="lineNum">    3920 </span>            :              }</a>
<a name="3921"><span class="lineNum">    3921 </span><span class="lineNoCov">          0 :           case V_SgTemplateArgument:</span></a>
<a name="3922"><span class="lineNum">    3922 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="3923"><span class="lineNum">    3923 </span><span class="lineNoCov">          0 :                SgTemplateArgument* x = isSgTemplateArgument(node);</span></a>
<a name="3924"><span class="lineNum">    3924 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(x-&gt;get_type() != NULL);</span></a>
<a name="3925"><span class="lineNum">    3925 </span><span class="lineNoCov">          0 :                type = x-&gt;get_type();</span></a>
<a name="3926"><span class="lineNum">    3926 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="3927"><span class="lineNum">    3927 </span>            :              }</a>
<a name="3928"><span class="lineNum">    3928 </span><span class="lineNoCov">          0 :           case V_SgVariableDefinition:</span></a>
<a name="3929"><span class="lineNum">    3929 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="3930"><span class="lineNum">    3930 </span><span class="lineNoCov">          0 :                SgVariableDefinition* x = isSgVariableDefinition(node);</span></a>
<a name="3931"><span class="lineNum">    3931 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(x-&gt;get_type() != NULL);</span></a>
<a name="3932"><span class="lineNum">    3932 </span><span class="lineNoCov">          0 :                type = x-&gt;get_type();</span></a>
<a name="3933"><span class="lineNum">    3933 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="3934"><span class="lineNum">    3934 </span>            :              }</a>
<a name="3935"><span class="lineNum">    3935 </span><span class="lineCov">       1264 :           case V_SgEnumDeclaration:</span></a>
<a name="3936"><span class="lineNum">    3936 </span><span class="lineCov">       1264 :              {</span></a>
<a name="3937"><span class="lineNum">    3937 </span><span class="lineCov">       1264 :                SgEnumDeclaration* x = isSgEnumDeclaration(node);</span></a>
<a name="3938"><span class="lineNum">    3938 </span><span class="lineCov">       1264 :                ROSE_ASSERT(x-&gt;get_type() != NULL);</span></a>
<a name="3939"><span class="lineNum">    3939 </span><span class="lineCov">       1264 :                type = x-&gt;get_type();</span></a>
<a name="3940"><span class="lineNum">    3940 </span><span class="lineCov">       1264 :                break;</span></a>
<a name="3941"><span class="lineNum">    3941 </span>            :              }</a>
<a name="3942"><span class="lineNum">    3942 </span><span class="lineCov">      49257 :           case V_SgTypedefDeclaration:</span></a>
<a name="3943"><span class="lineNum">    3943 </span><span class="lineCov">      49257 :              {</span></a>
<a name="3944"><span class="lineNum">    3944 </span><span class="lineCov">      49257 :                SgTypedefDeclaration* x = isSgTypedefDeclaration(node);</span></a>
<a name="3945"><span class="lineNum">    3945 </span><span class="lineCov">      49257 :                ROSE_ASSERT(x-&gt;get_type() != NULL);</span></a>
<a name="3946"><span class="lineNum">    3946 </span><span class="lineCov">      49257 :                type = x-&gt;get_type();</span></a>
<a name="3947"><span class="lineNum">    3947 </span><span class="lineCov">      49257 :                break;</span></a>
<a name="3948"><span class="lineNum">    3948 </span>            :              }</a>
<a name="3949"><span class="lineNum">    3949 </span><span class="lineCov">       7487 :           case V_SgClassDeclaration:</span></a>
<a name="3950"><span class="lineNum">    3950 </span><span class="lineCov">       7487 :           case V_SgDerivedTypeStatement:</span></a>
<a name="3951"><span class="lineNum">    3951 </span><span class="lineCov">       7487 :              {</span></a>
<a name="3952"><span class="lineNum">    3952 </span><span class="lineCov">       7487 :                SgClassDeclaration* x = isSgClassDeclaration(node);</span></a>
<a name="3953"><span class="lineNum">    3953 </span><span class="lineCov">       7487 :                ROSE_ASSERT(x-&gt;get_type() != NULL);</span></a>
<a name="3954"><span class="lineNum">    3954 </span><span class="lineCov">       7487 :                type = x-&gt;get_type();</span></a>
<a name="3955"><span class="lineNum">    3955 </span><span class="lineCov">       7487 :                break;</span></a>
<a name="3956"><span class="lineNum">    3956 </span>            :              }</a>
<a name="3957"><span class="lineNum">    3957 </span><span class="lineCov">    1031370 :           case V_SgFunctionDeclaration:</span></a>
<a name="3958"><span class="lineNum">    3958 </span><span class="lineCov">    1031370 :              {</span></a>
<a name="3959"><span class="lineNum">    3959 </span><span class="lineCov">    1031370 :                SgFunctionDeclaration* x = isSgFunctionDeclaration(node);</span></a>
<a name="3960"><span class="lineNum">    3960 </span><span class="lineCov">    1031370 :                ROSE_ASSERT(x-&gt;get_type() != NULL);</span></a>
<a name="3961"><span class="lineNum">    3961 </span><span class="lineCov">    1031370 :                type = x-&gt;get_type();</span></a>
<a name="3962"><span class="lineNum">    3962 </span><span class="lineCov">    1031370 :                break;</span></a>
<a name="3963"><span class="lineNum">    3963 </span>            :              }</a>
<a name="3964"><span class="lineNum">    3964 </span>            : </a>
<a name="3965"><span class="lineNum">    3965 </span><span class="lineCov">    5466810 :           default:</span></a>
<a name="3966"><span class="lineNum">    3966 </span><span class="lineCov">    5466810 :              {</span></a>
<a name="3967"><span class="lineNum">    3967 </span>            :             // noting to do</a>
<a name="3968"><span class="lineNum">    3968 </span>            :              }</a>
<a name="3969"><span class="lineNum">    3969 </span>            :         }</a>
<a name="3970"><span class="lineNum">    3970 </span>            : </a>
<a name="3971"><span class="lineNum">    3971 </span><span class="lineCov">    5466810 :      SgNamedType* namedType = isSgNamedType(type);</span></a>
<a name="3972"><span class="lineNum">    3972 </span><span class="lineCov">    5466810 :      if (namedType != NULL)</span></a>
<a name="3973"><span class="lineNum">    3973 </span>            :         {</a>
<a name="3974"><span class="lineNum">    3974 </span><span class="lineCov">    2419150 :           SgDeclarationStatement* declaration = namedType-&gt;get_declaration();</span></a>
<a name="3975"><span class="lineNum">    3975 </span><span class="lineCov">    2419150 :           ROSE_ASSERT(declaration != NULL);</span></a>
<a name="3976"><span class="lineNum">    3976 </span><span class="lineCov">    2419150 :           SgDeclarationStatement* nondefiningDeclaration = declaration-&gt;get_firstNondefiningDeclaration();</span></a>
<a name="3977"><span class="lineNum">    3977 </span>            :        // ROSE_ASSERT(declaration == nondefiningDeclaration);</a>
<a name="3978"><span class="lineNum">    3978 </span>            :        // ROSE_ASSERT(nondefiningDeclaration != NULL);</a>
<a name="3979"><span class="lineNum">    3979 </span><span class="lineCov">    2419150 :           SgDeclarationStatement* definingDeclaration    = declaration-&gt;get_definingDeclaration();</span></a>
<a name="3980"><span class="lineNum">    3980 </span><span class="lineCov">    2419150 :           if (definingDeclaration != NULL)</span></a>
<a name="3981"><span class="lineNum">    3981 </span>            :              {</a>
<a name="3982"><span class="lineNum">    3982 </span><span class="lineCov">      17376 :                switch(definingDeclaration-&gt;variantT())</span></a>
<a name="3983"><span class="lineNum">    3983 </span>            :                   {</a>
<a name="3984"><span class="lineNum">    3984 </span>            :                  // DQ (1/1/2012): Added support for templates in the AST.</a>
<a name="3985"><span class="lineNum">    3985 </span><span class="lineCov">       9587 :                     case V_SgTemplateClassDeclaration:</span></a>
<a name="3986"><span class="lineNum">    3986 </span>            : </a>
<a name="3987"><span class="lineNum">    3987 </span>            :                  // This case applies to template or non-template classes</a>
<a name="3988"><span class="lineNum">    3988 </span><span class="lineCov">       9587 :                     case V_SgClassDeclaration:</span></a>
<a name="3989"><span class="lineNum">    3989 </span><span class="lineCov">       9587 :                     case V_SgDerivedTypeStatement:</span></a>
<a name="3990"><span class="lineNum">    3990 </span><span class="lineCov">       9587 :                     case V_SgTemplateInstantiationDecl:</span></a>
<a name="3991"><span class="lineNum">    3991 </span><span class="lineCov">       9587 :                        {</span></a>
<a name="3992"><span class="lineNum">    3992 </span><span class="lineCov">       9587 :                          SgClassDeclaration* definingClassDeclaration = isSgClassDeclaration(definingDeclaration);</span></a>
<a name="3993"><span class="lineNum">    3993 </span><span class="lineCov">       9587 :                          ROSE_ASSERT(definingClassDeclaration-&gt;get_definition() != NULL);</span></a>
<a name="3994"><span class="lineNum">    3994 </span>            :                       // SgClassDeclaration* generalClassDeclaration = isSgClassDeclaration(declaration);</a>
<a name="3995"><span class="lineNum">    3995 </span><span class="lineCov">       9587 :                          ROSE_ASSERT(nondefiningDeclaration != NULL);</span></a>
<a name="3996"><span class="lineNum">    3996 </span>            : #if 0</a>
<a name="3997"><span class="lineNum">    3997 </span>            :                          if (declaration == nondefiningDeclaration)</a>
<a name="3998"><span class="lineNum">    3998 </span>            :                             {</a>
<a name="3999"><span class="lineNum">    3999 </span>            :                               printf (&quot;SAME: declaration and nondefiningDeclaration = %p = %s = %s \n&quot;,</a>
<a name="4000"><span class="lineNum">    4000 </span>            :                                    nondefiningDeclaration,nondefiningDeclaration-&gt;class_name().c_str(),definingClassDeclaration-&gt;get_name().str());</a>
<a name="4001"><span class="lineNum">    4001 </span>            :                             }</a>
<a name="4002"><span class="lineNum">    4002 </span>            :                            else</a>
<a name="4003"><span class="lineNum">    4003 </span>            :                             {</a>
<a name="4004"><span class="lineNum">    4004 </span>            :                               printf (&quot;DIFFERENT: declaration = %p = %s nondefiningDeclaration = %p = %s = %s \n&quot;,</a>
<a name="4005"><span class="lineNum">    4005 </span>            :                                    declaration,declaration-&gt;class_name().c_str(),nondefiningDeclaration,</a>
<a name="4006"><span class="lineNum">    4006 </span>            :                                    nondefiningDeclaration-&gt;class_name().c_str(),definingClassDeclaration-&gt;get_name().str());</a>
<a name="4007"><span class="lineNum">    4007 </span>            :                             }</a>
<a name="4008"><span class="lineNum">    4008 </span>            : #endif</a>
<a name="4009"><span class="lineNum">    4009 </span>            : #if 0</a>
<a name="4010"><span class="lineNum">    4010 </span>            :                          if (declaration != nondefiningDeclaration)</a>
<a name="4011"><span class="lineNum">    4011 </span>            :                             {</a>
<a name="4012"><span class="lineNum">    4012 </span>            :                               printf (&quot;declaration            = %p = %s \n&quot;,declaration,declaration-&gt;class_name().c_str());</a>
<a name="4013"><span class="lineNum">    4013 </span>            :                               printf (&quot;nondefiningDeclaration = %p = %s \n&quot;,nondefiningDeclaration,nondefiningDeclaration-&gt;class_name().c_str());</a>
<a name="4014"><span class="lineNum">    4014 </span>            :                             }</a>
<a name="4015"><span class="lineNum">    4015 </span>            :                       // ROSE_ASSERT(declaration == nondefiningDeclaration);</a>
<a name="4016"><span class="lineNum">    4016 </span>            : #endif</a>
<a name="4017"><span class="lineNum">    4017 </span><span class="lineCov">       9587 :                          break;</span></a>
<a name="4018"><span class="lineNum">    4018 </span>            :                        }</a>
<a name="4019"><span class="lineNum">    4019 </span>            : </a>
<a name="4020"><span class="lineNum">    4020 </span><span class="lineNoCov">          0 :                     case V_SgTypedefDeclaration:</span></a>
<a name="4021"><span class="lineNum">    4021 </span><span class="lineNoCov">          0 :                        {</span></a>
<a name="4022"><span class="lineNum">    4022 </span><span class="lineNoCov">          0 :                          SgTypedefDeclaration* typedefDeclaration = isSgTypedefDeclaration(definingDeclaration);</span></a>
<a name="4023"><span class="lineNum">    4023 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(typedefDeclaration-&gt;get_base_type() != NULL);</span></a>
<a name="4024"><span class="lineNum">    4024 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(typedefDeclaration-&gt;get_type() != NULL);</span></a>
<a name="4025"><span class="lineNum">    4025 </span>            : #if 0</a>
<a name="4026"><span class="lineNum">    4026 </span>            :                          if (typedefDeclaration-&gt;get_parent_scope() == NULL)</a>
<a name="4027"><span class="lineNum">    4027 </span>            :                             {</a>
<a name="4028"><span class="lineNum">    4028 </span>            :                               printf (&quot;Found a case where the typedefDeclaration-&gt;get_parent_scope() == NULL \n&quot;);</a>
<a name="4029"><span class="lineNum">    4029 </span>            :                             }</a>
<a name="4030"><span class="lineNum">    4030 </span>            :                            else</a>
<a name="4031"><span class="lineNum">    4031 </span>            :                             {</a>
<a name="4032"><span class="lineNum">    4032 </span>            :                               printf (&quot;Found a case where the typedefDeclaration-&gt;get_parent_scope() != NULL \n&quot;);</a>
<a name="4033"><span class="lineNum">    4033 </span>            :                             }</a>
<a name="4034"><span class="lineNum">    4034 </span>            : #endif</a>
<a name="4035"><span class="lineNum">    4035 </span>            :                       // DQ (2/25/2006): It appears that this is always NULL (except for test2005_188.C,</a>
<a name="4036"><span class="lineNum">    4036 </span>            :                       // where it points to the symbol of the class if it is a member type)</a>
<a name="4037"><span class="lineNum">    4037 </span>            :                       // ROSE_ASSERT(typedefDeclaration-&gt;get_parent_scope() == NULL);</a>
<a name="4038"><span class="lineNum">    4038 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(typedefDeclaration-&gt;get_scope() != NULL);</span></a>
<a name="4039"><span class="lineNum">    4039 </span>            : </a>
<a name="4040"><span class="lineNum">    4040 </span>            :                       // This is to handle declarations that appear directly in the typedef (most often NULL)</a>
<a name="4041"><span class="lineNum">    4041 </span><span class="lineNoCov">          0 :                          if (typedefDeclaration-&gt;get_typedefBaseTypeContainsDefiningDeclaration() == true)</span></a>
<a name="4042"><span class="lineNum">    4042 </span><span class="lineNoCov">          0 :                               ROSE_ASSERT(typedefDeclaration-&gt;get_declaration() != NULL);</span></a>
<a name="4043"><span class="lineNum">    4043 </span>            :                            else</a>
<a name="4044"><span class="lineNum">    4044 </span><span class="lineNoCov">          0 :                               ROSE_ASSERT(typedefDeclaration-&gt;get_declaration() == NULL);</span></a>
<a name="4045"><span class="lineNum">    4045 </span>            :                          break;</a>
<a name="4046"><span class="lineNum">    4046 </span>            :                        }</a>
<a name="4047"><span class="lineNum">    4047 </span>            : </a>
<a name="4048"><span class="lineNum">    4048 </span><span class="lineCov">       7789 :                     case V_SgEnumDeclaration:</span></a>
<a name="4049"><span class="lineNum">    4049 </span><span class="lineCov">       7789 :                        {</span></a>
<a name="4050"><span class="lineNum">    4050 </span><span class="lineCov">       7789 :                          SgEnumDeclaration* enumDeclaration = isSgEnumDeclaration(definingDeclaration);</span></a>
<a name="4051"><span class="lineNum">    4051 </span><span class="lineCov">       7789 :                          ROSE_ASSERT(enumDeclaration-&gt;get_type() != NULL);</span></a>
<a name="4052"><span class="lineNum">    4052 </span><span class="lineCov">       7789 :                          ROSE_ASSERT(enumDeclaration-&gt;get_scope() != NULL);</span></a>
<a name="4053"><span class="lineNum">    4053 </span><span class="lineCov">       7789 :                          break;</span></a>
<a name="4054"><span class="lineNum">    4054 </span>            :                        }</a>
<a name="4055"><span class="lineNum">    4055 </span>            : </a>
<a name="4056"><span class="lineNum">    4056 </span><span class="lineNoCov">          0 :                      default:</span></a>
<a name="4057"><span class="lineNum">    4057 </span><span class="lineNoCov">          0 :                        {</span></a>
<a name="4058"><span class="lineNum">    4058 </span><span class="lineNoCov">          0 :                          printf (&quot;Error: default reached in switch: definingDeclaration not tested = %p = %s \n&quot;,definingDeclaration,definingDeclaration-&gt;class_name().c_str());</span></a>
<a name="4059"><span class="lineNum">    4059 </span><span class="lineNoCov">          0 :                          ROSE_ABORT();</span></a>
<a name="4060"><span class="lineNum">    4060 </span>            :                        }</a>
<a name="4061"><span class="lineNum">    4061 </span>            :                   }</a>
<a name="4062"><span class="lineNum">    4062 </span>            :              }</a>
<a name="4063"><span class="lineNum">    4063 </span>            :         }</a>
<a name="4064"><span class="lineNum">    4064 </span>            : #endif</a>
<a name="4065"><span class="lineNum">    4065 </span>            : </a>
<a name="4066"><span class="lineNum">    4066 </span>            : #if 0</a>
<a name="4067"><span class="lineNum">    4067 </span>            :      SgFunctionType* namedType = isNamedType(type);</a>
<a name="4068"><span class="lineNum">    4068 </span>            :      if (namedType != NULL)</a>
<a name="4069"><span class="lineNum">    4069 </span>            :         {</a>
<a name="4070"><span class="lineNum">    4070 </span>            :           SgDeclarationStatement* declaration = namedType-&gt;get_declaration();</a>
<a name="4071"><span class="lineNum">    4071 </span>            :           ROSE_ASSERT(declaration != NULL);</a>
<a name="4072"><span class="lineNum">    4072 </span>            :           SgDeclarationStatement* nondefiningDeclaration = declaration-&gt;get_firstNondefiningDeclaration();</a>
<a name="4073"><span class="lineNum">    4073 </span>            :           SgDeclarationStatement* definingDeclaration    = declaration-&gt;get_definingDeclaration();</a>
<a name="4074"><span class="lineNum">    4074 </span>            :           if (definingDeclaration != NULL)</a>
<a name="4075"><span class="lineNum">    4075 </span>            :              {</a>
<a name="4076"><span class="lineNum">    4076 </span>            :                switch(definingDeclaration-&gt;variantT())</a>
<a name="4077"><span class="lineNum">    4077 </span>            :                   {</a>
<a name="4078"><span class="lineNum">    4078 </span>            :                     case V_SgFunctionDeclaration:</a>
<a name="4079"><span class="lineNum">    4079 </span>            :                        {</a>
<a name="4080"><span class="lineNum">    4080 </span>            :                          SgFunctionDeclaration* functionDeclaration = isSgFunctionDeclaration(definingDeclaration);</a>
<a name="4081"><span class="lineNum">    4081 </span>            :                          ROSE_ASSERT(functionDeclaration-&gt;get_definition() != NULL);</a>
<a name="4082"><span class="lineNum">    4082 </span>            :                          break;</a>
<a name="4083"><span class="lineNum">    4083 </span>            :                        }</a>
<a name="4084"><span class="lineNum">    4084 </span>            : </a>
<a name="4085"><span class="lineNum">    4085 </span>            :                      default:</a>
<a name="4086"><span class="lineNum">    4086 </span>            :                        {</a>
<a name="4087"><span class="lineNum">    4087 </span>            :                          printf (&quot;definingDeclaration not tested = %s \n&quot;,definingDeclaration-&gt;class_name().c_str());</a>
<a name="4088"><span class="lineNum">    4088 </span>            :                        }</a>
<a name="4089"><span class="lineNum">    4089 </span>            :                   }</a>
<a name="4090"><span class="lineNum">    4090 </span>            :              }</a>
<a name="4091"><span class="lineNum">    4091 </span>            :         }</a>
<a name="4092"><span class="lineNum">    4092 </span>            : #endif</a>
<a name="4093"><span class="lineNum">    4093 </span><span class="lineCov">    5466810 :    }</span></a>
<a name="4094"><span class="lineNum">    4094 </span>            : </a>
<a name="4095"><span class="lineNum">    4095 </span>            : void</a>
<a name="4096"><span class="lineNum">    4096 </span><span class="lineNoCov">          0 : TestLValues::visit ( SgNode* node )</span></a>
<a name="4097"><span class="lineNum">    4097 </span>            : {</a>
<a name="4098"><span class="lineNum">    4098 </span><span class="lineNoCov">          0 :         SgExpression* expression = isSgExpression(node);</span></a>
<a name="4099"><span class="lineNum">    4099 </span><span class="lineNoCov">          0 :         if (expression != NULL)</span></a>
<a name="4100"><span class="lineNum">    4100 </span>            :         {</a>
<a name="4101"><span class="lineNum">    4101 </span>            :                 return;</a>
<a name="4102"><span class="lineNum">    4102 </span>            :         }</a>
<a name="4103"><span class="lineNum">    4103 </span>            : </a>
<a name="4104"><span class="lineNum">    4104 </span>            :         //</a>
<a name="4105"><span class="lineNum">    4105 </span>            :         // Test isLValue()</a>
<a name="4106"><span class="lineNum">    4106 </span>            :         //</a>
<a name="4107"><span class="lineNum">    4107 </span>            :         if (expression != NULL)</a>
<a name="4108"><span class="lineNum">    4108 </span>            :         {</a>
<a name="4109"><span class="lineNum">    4109 </span>            :                 bool verifiedLValue = false;</a>
<a name="4110"><span class="lineNum">    4110 </span>            :                 bool verifiedDefinable = false;</a>
<a name="4111"><span class="lineNum">    4111 </span>            :                 switch (node-&gt;variantT())</a>
<a name="4112"><span class="lineNum">    4112 </span>            :                 {</a>
<a name="4113"><span class="lineNum">    4113 </span>            :                         case V_SgScopeOp:</a>
<a name="4114"><span class="lineNum">    4114 </span>            :                         {</a>
<a name="4115"><span class="lineNum">    4115 </span>            :                                 SgScopeOp* scopeOp = isSgScopeOp(node);</a>
<a name="4116"><span class="lineNum">    4116 </span>            :                                 ROSE_ASSERT(scopeOp);</a>
<a name="4117"><span class="lineNum">    4117 </span>            :                                 verifiedLValue = scopeOp-&gt;get_rhs_operand()-&gt;isLValue();</a>
<a name="4118"><span class="lineNum">    4118 </span>            :                                 break;</a>
<a name="4119"><span class="lineNum">    4119 </span>            :                         }</a>
<a name="4120"><span class="lineNum">    4120 </span>            :                         case V_SgPntrArrRefExp:</a>
<a name="4121"><span class="lineNum">    4121 </span>            :                         {</a>
<a name="4122"><span class="lineNum">    4122 </span>            :                                 verifiedLValue = true;</a>
<a name="4123"><span class="lineNum">    4123 </span>            :                                 break;</a>
<a name="4124"><span class="lineNum">    4124 </span>            :                         }</a>
<a name="4125"><span class="lineNum">    4125 </span>            :                         case V_SgPointerDerefExp:</a>
<a name="4126"><span class="lineNum">    4126 </span>            :                         {</a>
<a name="4127"><span class="lineNum">    4127 </span>            :                                 verifiedLValue = true;</a>
<a name="4128"><span class="lineNum">    4128 </span>            :                                 break;</a>
<a name="4129"><span class="lineNum">    4129 </span>            :                         }</a>
<a name="4130"><span class="lineNum">    4130 </span>            :                         case V_SgAddressOfOp:</a>
<a name="4131"><span class="lineNum">    4131 </span>            :                         {</a>
<a name="4132"><span class="lineNum">    4132 </span>            :                                 /*! std:5.2.6 par:1 */</a>
<a name="4133"><span class="lineNum">    4133 </span>            :                                 // TODO: king84: false?  char x[4];  x is lvalue; (x + 1) is rvalue; *(x+1) is lvalue; *(x+1) = x[1]</a>
<a name="4134"><span class="lineNum">    4134 </span>            :                                 if (!isSgAddressOfOp(expression)-&gt;get_operand()-&gt;isLValue()) // must also be mutable</a>
<a name="4135"><span class="lineNum">    4135 </span>            :                                 {</a>
<a name="4136"><span class="lineNum">    4136 </span>            :                                         ROSE_ASSERT(!&quot;Child operand of an address-of operator must be an lvalue in isLValue on SgAddressOfOp&quot;);</a>
<a name="4137"><span class="lineNum">    4137 </span>            :                                 }</a>
<a name="4138"><span class="lineNum">    4138 </span>            :                                 verifiedLValue = true;</a>
<a name="4139"><span class="lineNum">    4139 </span>            :                                 break;</a>
<a name="4140"><span class="lineNum">    4140 </span>            :                         }</a>
<a name="4141"><span class="lineNum">    4141 </span>            :                         case V_SgArrowExp:</a>
<a name="4142"><span class="lineNum">    4142 </span>            :                         {</a>
<a name="4143"><span class="lineNum">    4143 </span>            :                                 // TODO: king84: is this true?</a>
<a name="4144"><span class="lineNum">    4144 </span>            :                                 if (!isSgArrowExp(expression)-&gt;get_rhs_operand()-&gt;isLValue())</a>
<a name="4145"><span class="lineNum">    4145 </span>            :                                 {</a>
<a name="4146"><span class="lineNum">    4146 </span>            :                                         ROSE_ASSERT(!&quot;Right-hand-side must be an lvalue as a data member or member function in isLValue for SgArrowExp&quot;);</a>
<a name="4147"><span class="lineNum">    4147 </span>            :                                 }</a>
<a name="4148"><span class="lineNum">    4148 </span>            :                                 verifiedLValue = true;</a>
<a name="4149"><span class="lineNum">    4149 </span>            :                                 break;</a>
<a name="4150"><span class="lineNum">    4150 </span>            :                         }</a>
<a name="4151"><span class="lineNum">    4151 </span>            :                         case V_SgDotExp:</a>
<a name="4152"><span class="lineNum">    4152 </span>            :                         {</a>
<a name="4153"><span class="lineNum">    4153 </span>            :                                 // TODO: king84: is this true?</a>
<a name="4154"><span class="lineNum">    4154 </span>            :                                 if (!isSgDotExp(expression)-&gt;get_rhs_operand()-&gt;isLValue())</a>
<a name="4155"><span class="lineNum">    4155 </span>            :                                 {</a>
<a name="4156"><span class="lineNum">    4156 </span>            :                                         ROSE_ASSERT(!&quot;Right-hand-side must be an lvalue as a data member or member function in isLValue for SgDotExp&quot;);</a>
<a name="4157"><span class="lineNum">    4157 </span>            :                                 }</a>
<a name="4158"><span class="lineNum">    4158 </span>            :                                 verifiedLValue = true;</a>
<a name="4159"><span class="lineNum">    4159 </span>            :                                 break;</a>
<a name="4160"><span class="lineNum">    4160 </span>            :                         }</a>
<a name="4161"><span class="lineNum">    4161 </span>            :                         case V_SgDotStarOp:</a>
<a name="4162"><span class="lineNum">    4162 </span>            :                         {</a>
<a name="4163"><span class="lineNum">    4163 </span>            :                                 // TODO: king84: is this true?</a>
<a name="4164"><span class="lineNum">    4164 </span>            :                                 if (!isSgDotStarOp(expression)-&gt;get_lhs_operand()-&gt;isLValue())</a>
<a name="4165"><span class="lineNum">    4165 </span>            :                                 {</a>
<a name="4166"><span class="lineNum">    4166 </span>            :                                         ROSE_ASSERT(!&quot;Left-hand-side must be an lvalue in isLValue for SgDotStarOp&quot;);</a>
<a name="4167"><span class="lineNum">    4167 </span>            :                                 }</a>
<a name="4168"><span class="lineNum">    4168 </span>            :                                 verifiedLValue = true;</a>
<a name="4169"><span class="lineNum">    4169 </span>            :                                 break;</a>
<a name="4170"><span class="lineNum">    4170 </span>            :                         }</a>
<a name="4171"><span class="lineNum">    4171 </span>            :                         case V_SgArrowStarOp:</a>
<a name="4172"><span class="lineNum">    4172 </span>            :                         {</a>
<a name="4173"><span class="lineNum">    4173 </span>            :                                 // TODO: king84: is this true? consider 'this': class A {int A::*pf();} this-&gt;*pf();</a>
<a name="4174"><span class="lineNum">    4174 </span>            :                                 if (!isSgArrowStarOp(expression)-&gt;get_lhs_operand()-&gt;isLValue())</a>
<a name="4175"><span class="lineNum">    4175 </span>            :                                 {</a>
<a name="4176"><span class="lineNum">    4176 </span>            :                                         ROSE_ASSERT(!&quot;Left-hand-side must be an lvalue in isLValue for SgArrowStarOp&quot;);</a>
<a name="4177"><span class="lineNum">    4177 </span>            :                                 }</a>
<a name="4178"><span class="lineNum">    4178 </span>            :                                 verifiedLValue = true;</a>
<a name="4179"><span class="lineNum">    4179 </span>            :                                 break;</a>
<a name="4180"><span class="lineNum">    4180 </span>            :                         }</a>
<a name="4181"><span class="lineNum">    4181 </span>            :                         case V_SgMinusMinusOp:</a>
<a name="4182"><span class="lineNum">    4182 </span>            :                         {</a>
<a name="4183"><span class="lineNum">    4183 </span>            :                                 SgMinusMinusOp* mmo = isSgMinusMinusOp(node);</a>
<a name="4184"><span class="lineNum">    4184 </span>            :                                 if (mmo-&gt;get_mode() == SgUnaryOp::postfix)</a>
<a name="4185"><span class="lineNum">    4185 </span>            :                                         verifiedLValue = false;</a>
<a name="4186"><span class="lineNum">    4186 </span>            :                                 else</a>
<a name="4187"><span class="lineNum">    4187 </span>            :                                 {</a>
<a name="4188"><span class="lineNum">    4188 </span>            :                                         /*! std:5.3.2 par:2 */</a>
<a name="4189"><span class="lineNum">    4189 </span>            :                                         if (!mmo-&gt;get_operand()-&gt;isLValue()) // must also be mutable</a>
<a name="4190"><span class="lineNum">    4190 </span>            :                                         {</a>
<a name="4191"><span class="lineNum">    4191 </span>            :                                                 ROSE_ASSERT(!&quot;Child operand of a prefix-increment must be an lvalue in isLValue on SgMinusMinusOp&quot;);</a>
<a name="4192"><span class="lineNum">    4192 </span>            :                                         }</a>
<a name="4193"><span class="lineNum">    4193 </span>            :                                         verifiedLValue = true;</a>
<a name="4194"><span class="lineNum">    4194 </span>            :                                 }</a>
<a name="4195"><span class="lineNum">    4195 </span>            :                                 break;</a>
<a name="4196"><span class="lineNum">    4196 </span>            :                         }</a>
<a name="4197"><span class="lineNum">    4197 </span>            :                         case V_SgPlusPlusOp:</a>
<a name="4198"><span class="lineNum">    4198 </span>            :                         {</a>
<a name="4199"><span class="lineNum">    4199 </span>            :                                 SgPlusPlusOp* ppo = isSgPlusPlusOp(node);</a>
<a name="4200"><span class="lineNum">    4200 </span>            :                                 if (ppo-&gt;get_mode() == SgUnaryOp::postfix)</a>
<a name="4201"><span class="lineNum">    4201 </span>            :                                         verifiedLValue = false;</a>
<a name="4202"><span class="lineNum">    4202 </span>            :                                 else</a>
<a name="4203"><span class="lineNum">    4203 </span>            :                                 {</a>
<a name="4204"><span class="lineNum">    4204 </span>            :                                         /*! std:5.3.2 par:1 */</a>
<a name="4205"><span class="lineNum">    4205 </span>            :                                         if (!ppo-&gt;get_operand()-&gt;isLValue()) // must also be mutable</a>
<a name="4206"><span class="lineNum">    4206 </span>            :                                         {</a>
<a name="4207"><span class="lineNum">    4207 </span>            :                                                 ROSE_ASSERT(!&quot;Child operand of a prefix-increment must be an lvalue in isLValue on SgPlusPlusOp&quot;);</a>
<a name="4208"><span class="lineNum">    4208 </span>            :                                         }</a>
<a name="4209"><span class="lineNum">    4209 </span>            :                                         verifiedLValue = true;</a>
<a name="4210"><span class="lineNum">    4210 </span>            :                                 }</a>
<a name="4211"><span class="lineNum">    4211 </span>            :                                 break;</a>
<a name="4212"><span class="lineNum">    4212 </span>            :                         }</a>
<a name="4213"><span class="lineNum">    4213 </span>            :                         case V_SgCastExp:</a>
<a name="4214"><span class="lineNum">    4214 </span>            :                         {</a>
<a name="4215"><span class="lineNum">    4215 </span>            :                                 SgCastExp* castExp = isSgCastExp(node);</a>
<a name="4216"><span class="lineNum">    4216 </span>            :                                 ROSE_ASSERT(castExp);</a>
<a name="4217"><span class="lineNum">    4217 </span>            :                                 switch (castExp-&gt;cast_type())</a>
<a name="4218"><span class="lineNum">    4218 </span>            :                                 {</a>
<a name="4219"><span class="lineNum">    4219 </span>            :                                         case SgCastExp::e_C_style_cast:</a>
<a name="4220"><span class="lineNum">    4220 </span>            :                                         case SgCastExp::e_const_cast:</a>
<a name="4221"><span class="lineNum">    4221 </span>            :                                         case SgCastExp::e_static_cast:</a>
<a name="4222"><span class="lineNum">    4222 </span>            :                                         case SgCastExp::e_dynamic_cast:</a>
<a name="4223"><span class="lineNum">    4223 </span>            :                                         case SgCastExp::e_reinterpret_cast:</a>
<a name="4224"><span class="lineNum">    4224 </span>            :                                                 verifiedLValue = SageInterface::isReferenceType(castExp-&gt;get_type());</a>
<a name="4225"><span class="lineNum">    4225 </span>            :                                                 break;</a>
<a name="4226"><span class="lineNum">    4226 </span>            :                                         case SgCastExp::e_unknown:</a>
<a name="4227"><span class="lineNum">    4227 </span>            :                                         case SgCastExp::e_default:</a>
<a name="4228"><span class="lineNum">    4228 </span>            :                                         default:</a>
<a name="4229"><span class="lineNum">    4229 </span>            :                                                 verifiedLValue = false;</a>
<a name="4230"><span class="lineNum">    4230 </span>            :                                                 break;</a>
<a name="4231"><span class="lineNum">    4231 </span>            :                                 }</a>
<a name="4232"><span class="lineNum">    4232 </span>            :                                 break;</a>
<a name="4233"><span class="lineNum">    4233 </span>            :                         }</a>
<a name="4234"><span class="lineNum">    4234 </span>            :                         case V_SgCommaOpExp:</a>
<a name="4235"><span class="lineNum">    4235 </span>            :                         {</a>
<a name="4236"><span class="lineNum">    4236 </span>            :                                 SgCommaOpExp* comma = isSgCommaOpExp(node);</a>
<a name="4237"><span class="lineNum">    4237 </span>            :                                 ROSE_ASSERT(comma);</a>
<a name="4238"><span class="lineNum">    4238 </span>            :                                 verifiedLValue = comma-&gt;get_rhs_operand()-&gt;isLValue();</a>
<a name="4239"><span class="lineNum">    4239 </span>            :                                 break;</a>
<a name="4240"><span class="lineNum">    4240 </span>            :                         }</a>
<a name="4241"><span class="lineNum">    4241 </span>            :                         case V_SgAssignOp:</a>
<a name="4242"><span class="lineNum">    4242 </span>            :                         {</a>
<a name="4243"><span class="lineNum">    4243 </span>            :                                 verifiedLValue = true;</a>
<a name="4244"><span class="lineNum">    4244 </span>            :                                 break;</a>
<a name="4245"><span class="lineNum">    4245 </span>            :                         }</a>
<a name="4246"><span class="lineNum">    4246 </span>            :                         case V_SgPlusAssignOp:</a>
<a name="4247"><span class="lineNum">    4247 </span>            :                         {</a>
<a name="4248"><span class="lineNum">    4248 </span>            :                                 verifiedLValue = true;</a>
<a name="4249"><span class="lineNum">    4249 </span>            :                                 break;</a>
<a name="4250"><span class="lineNum">    4250 </span>            :                         }</a>
<a name="4251"><span class="lineNum">    4251 </span>            :                         case V_SgMinusAssignOp:</a>
<a name="4252"><span class="lineNum">    4252 </span>            :                         {</a>
<a name="4253"><span class="lineNum">    4253 </span>            :                                 verifiedLValue = true;</a>
<a name="4254"><span class="lineNum">    4254 </span>            :                                 break;</a>
<a name="4255"><span class="lineNum">    4255 </span>            :                         }</a>
<a name="4256"><span class="lineNum">    4256 </span>            :                         case V_SgAndAssignOp:</a>
<a name="4257"><span class="lineNum">    4257 </span>            :                         {</a>
<a name="4258"><span class="lineNum">    4258 </span>            :                                 verifiedLValue = true;</a>
<a name="4259"><span class="lineNum">    4259 </span>            :                                 break;</a>
<a name="4260"><span class="lineNum">    4260 </span>            :                         }</a>
<a name="4261"><span class="lineNum">    4261 </span>            :                         case V_SgIorAssignOp:</a>
<a name="4262"><span class="lineNum">    4262 </span>            :                         {</a>
<a name="4263"><span class="lineNum">    4263 </span>            :                                 verifiedLValue = true;</a>
<a name="4264"><span class="lineNum">    4264 </span>            :                                 break;</a>
<a name="4265"><span class="lineNum">    4265 </span>            :                         }</a>
<a name="4266"><span class="lineNum">    4266 </span>            :                         case V_SgMultAssignOp:</a>
<a name="4267"><span class="lineNum">    4267 </span>            :                         {</a>
<a name="4268"><span class="lineNum">    4268 </span>            :                                 verifiedLValue = true;</a>
<a name="4269"><span class="lineNum">    4269 </span>            :                                 break;</a>
<a name="4270"><span class="lineNum">    4270 </span>            :                         }</a>
<a name="4271"><span class="lineNum">    4271 </span>            :                         case V_SgDivAssignOp:</a>
<a name="4272"><span class="lineNum">    4272 </span>            :                         {</a>
<a name="4273"><span class="lineNum">    4273 </span>            :                                 verifiedLValue = true;</a>
<a name="4274"><span class="lineNum">    4274 </span>            :                                 break;</a>
<a name="4275"><span class="lineNum">    4275 </span>            :                         }</a>
<a name="4276"><span class="lineNum">    4276 </span>            :                         case V_SgModAssignOp:</a>
<a name="4277"><span class="lineNum">    4277 </span>            :                         {</a>
<a name="4278"><span class="lineNum">    4278 </span>            :                                 verifiedLValue = true;</a>
<a name="4279"><span class="lineNum">    4279 </span>            :                                 break;</a>
<a name="4280"><span class="lineNum">    4280 </span>            :                         }</a>
<a name="4281"><span class="lineNum">    4281 </span>            :                         case V_SgXorAssignOp:</a>
<a name="4282"><span class="lineNum">    4282 </span>            :                         {</a>
<a name="4283"><span class="lineNum">    4283 </span>            :                                 verifiedLValue = true;</a>
<a name="4284"><span class="lineNum">    4284 </span>            :                                 break;</a>
<a name="4285"><span class="lineNum">    4285 </span>            :                         }</a>
<a name="4286"><span class="lineNum">    4286 </span>            :                         case V_SgLshiftAssignOp:</a>
<a name="4287"><span class="lineNum">    4287 </span>            :                         {</a>
<a name="4288"><span class="lineNum">    4288 </span>            :                                 verifiedLValue = true;</a>
<a name="4289"><span class="lineNum">    4289 </span>            :                                 break;</a>
<a name="4290"><span class="lineNum">    4290 </span>            :                         }</a>
<a name="4291"><span class="lineNum">    4291 </span>            :                         case V_SgRshiftAssignOp:</a>
<a name="4292"><span class="lineNum">    4292 </span>            :                         {</a>
<a name="4293"><span class="lineNum">    4293 </span>            :                                 verifiedLValue = true;</a>
<a name="4294"><span class="lineNum">    4294 </span>            :                                 break;</a>
<a name="4295"><span class="lineNum">    4295 </span>            :                         }</a>
<a name="4296"><span class="lineNum">    4296 </span>            :                         case V_SgPointerAssignOp:</a>
<a name="4297"><span class="lineNum">    4297 </span>            :                         {</a>
<a name="4298"><span class="lineNum">    4298 </span>            :                                 verifiedDefinable = true;</a>
<a name="4299"><span class="lineNum">    4299 </span>            :                                 break;</a>
<a name="4300"><span class="lineNum">    4300 </span>            :                         }</a>
<a name="4301"><span class="lineNum">    4301 </span>            :                         case V_SgStringVal:</a>
<a name="4302"><span class="lineNum">    4302 </span>            :                         {</a>
<a name="4303"><span class="lineNum">    4303 </span>            :                                 verifiedLValue = true;</a>
<a name="4304"><span class="lineNum">    4304 </span>            :                                 break;</a>
<a name="4305"><span class="lineNum">    4305 </span>            :                         }</a>
<a name="4306"><span class="lineNum">    4306 </span>            :                         case V_SgVarRefExp:</a>
<a name="4307"><span class="lineNum">    4307 </span>            :                         {</a>
<a name="4308"><span class="lineNum">    4308 </span>            :                                 verifiedLValue = true;</a>
<a name="4309"><span class="lineNum">    4309 </span>            :                                 SgVarRefExp* var = isSgVarRefExp(node);</a>
<a name="4310"><span class="lineNum">    4310 </span>            :                                 verifiedDefinable = !SageInterface::isConstType(var-&gt;get_type());</a>
<a name="4311"><span class="lineNum">    4311 </span>            :                                 break;</a>
<a name="4312"><span class="lineNum">    4312 </span>            :                         }</a>
<a name="4313"><span class="lineNum">    4313 </span>            :                         case V_SgFunctionRefExp:</a>
<a name="4314"><span class="lineNum">    4314 </span>            :                         {</a>
<a name="4315"><span class="lineNum">    4315 </span>            :                                 break;</a>
<a name="4316"><span class="lineNum">    4316 </span>            :                         }</a>
<a name="4317"><span class="lineNum">    4317 </span>            :                         case V_SgMemberFunctionRefExp:</a>
<a name="4318"><span class="lineNum">    4318 </span>            :                         {</a>
<a name="4319"><span class="lineNum">    4319 </span>            :                                 verifiedLValue = true;</a>
<a name="4320"><span class="lineNum">    4320 </span>            :                                 break;</a>
<a name="4321"><span class="lineNum">    4321 </span>            :                         }</a>
<a name="4322"><span class="lineNum">    4322 </span>            :                         case V_SgFunctionCallExp:</a>
<a name="4323"><span class="lineNum">    4323 </span>            :                         {</a>
<a name="4324"><span class="lineNum">    4324 </span>            :                                 SgFunctionCallExp* funOp = isSgFunctionCallExp(node);</a>
<a name="4325"><span class="lineNum">    4325 </span>            :                                 ROSE_ASSERT(funOp);</a>
<a name="4326"><span class="lineNum">    4326 </span>            :                                 SgType* type = funOp-&gt;get_function()-&gt;get_type();</a>
<a name="4327"><span class="lineNum">    4327 </span>            :                                 while (SgTypedefType* type2 = isSgTypedefType(type))</a>
<a name="4328"><span class="lineNum">    4328 </span>            :                                         type = type2-&gt;get_base_type();</a>
<a name="4329"><span class="lineNum">    4329 </span>            :                                 SgFunctionType* ftype = isSgFunctionType(type);</a>
<a name="4330"><span class="lineNum">    4330 </span>            :                                 verifiedLValue = SageInterface::isReferenceType(ftype-&gt;get_return_type());</a>
<a name="4331"><span class="lineNum">    4331 </span>            :                                 break;</a>
<a name="4332"><span class="lineNum">    4332 </span>            :                         }</a>
<a name="4333"><span class="lineNum">    4333 </span>            :                         case V_SgTypeIdOp:</a>
<a name="4334"><span class="lineNum">    4334 </span>            :                         {</a>
<a name="4335"><span class="lineNum">    4335 </span>            :                                 verifiedLValue = true;</a>
<a name="4336"><span class="lineNum">    4336 </span>            :                                 break;</a>
<a name="4337"><span class="lineNum">    4337 </span>            :                         }</a>
<a name="4338"><span class="lineNum">    4338 </span>            :                         case V_SgConditionalExp:</a>
<a name="4339"><span class="lineNum">    4339 </span>            :                         {</a>
<a name="4340"><span class="lineNum">    4340 </span>            :                                 SgConditionalExp* cond = isSgConditionalExp(node);</a>
<a name="4341"><span class="lineNum">    4341 </span>            :                                 verifiedLValue = (cond-&gt;get_true_exp()-&gt;isLValue() &amp;&amp; cond-&gt;get_false_exp()-&gt;isLValue()) &amp;&amp; (cond-&gt;get_true_exp()-&gt;get_type() == cond-&gt;get_false_exp()-&gt;get_type());</a>
<a name="4342"><span class="lineNum">    4342 </span>            :                                 break;</a>
<a name="4343"><span class="lineNum">    4343 </span>            :                         }</a>
<a name="4344"><span class="lineNum">    4344 </span>            :                         case V_SgShortVal:</a>
<a name="4345"><span class="lineNum">    4345 </span>            :                         case V_SgCharVal:</a>
<a name="4346"><span class="lineNum">    4346 </span>            :                         case V_SgUnsignedCharVal:</a>
<a name="4347"><span class="lineNum">    4347 </span>            :                         case V_SgWcharVal:</a>
<a name="4348"><span class="lineNum">    4348 </span>            :                         case V_SgUnsignedShortVal:</a>
<a name="4349"><span class="lineNum">    4349 </span>            :                         case V_SgIntVal:</a>
<a name="4350"><span class="lineNum">    4350 </span>            :                         case V_SgEnumVal:</a>
<a name="4351"><span class="lineNum">    4351 </span>            :                         case V_SgUnsignedIntVal:</a>
<a name="4352"><span class="lineNum">    4352 </span>            :                         case V_SgLongIntVal:</a>
<a name="4353"><span class="lineNum">    4353 </span>            :                         case V_SgLongLongIntVal:</a>
<a name="4354"><span class="lineNum">    4354 </span>            :                         case V_SgUnsignedLongLongIntVal:</a>
<a name="4355"><span class="lineNum">    4355 </span>            :                         case V_SgUnsignedLongVal:</a>
<a name="4356"><span class="lineNum">    4356 </span>            :                         case V_SgFloatVal:</a>
<a name="4357"><span class="lineNum">    4357 </span>            :                         case V_SgDoubleVal:</a>
<a name="4358"><span class="lineNum">    4358 </span>            :                         case V_SgLongDoubleVal:</a>
<a name="4359"><span class="lineNum">    4359 </span>            :                         case V_SgComplexVal:</a>
<a name="4360"><span class="lineNum">    4360 </span>            :                         case V_SgUpcThreads:</a>
<a name="4361"><span class="lineNum">    4361 </span>            :                         case V_SgUpcMythread:</a>
<a name="4362"><span class="lineNum">    4362 </span>            :                         case V_SgUnaryOp:</a>
<a name="4363"><span class="lineNum">    4363 </span>            :                         case V_SgBinaryOp:</a>
<a name="4364"><span class="lineNum">    4364 </span>            :                         case V_SgExprListExp:</a>
<a name="4365"><span class="lineNum">    4365 </span>            :                         case V_SgUserDefinedBinaryOp:</a>
<a name="4366"><span class="lineNum">    4366 </span>            :                         case V_SgBoolValExp:</a>
<a name="4367"><span class="lineNum">    4367 </span>            :                         case V_SgExponentiationOp:</a>
<a name="4368"><span class="lineNum">    4368 </span>            :                         case V_SgConcatenationOp:</a>
<a name="4369"><span class="lineNum">    4369 </span>            :                         case V_SgLshiftOp:</a>
<a name="4370"><span class="lineNum">    4370 </span>            :                         case V_SgRshiftOp:</a>
<a name="4371"><span class="lineNum">    4371 </span>            :                         case V_SgEqualityOp:</a>
<a name="4372"><span class="lineNum">    4372 </span>            :                         case V_SgLessThanOp:</a>
<a name="4373"><span class="lineNum">    4373 </span>            :                         case V_SgGreaterThanOp:</a>
<a name="4374"><span class="lineNum">    4374 </span>            :                         case V_SgNotEqualOp:</a>
<a name="4375"><span class="lineNum">    4375 </span>            :                         case V_SgLessOrEqualOp:</a>
<a name="4376"><span class="lineNum">    4376 </span>            :                         case V_SgGreaterOrEqualOp:</a>
<a name="4377"><span class="lineNum">    4377 </span>            :                         case V_SgAddOp:</a>
<a name="4378"><span class="lineNum">    4378 </span>            :                         case V_SgSubtractOp:</a>
<a name="4379"><span class="lineNum">    4379 </span>            :                         case V_SgMultiplyOp:</a>
<a name="4380"><span class="lineNum">    4380 </span>            :                         case V_SgDivideOp:</a>
<a name="4381"><span class="lineNum">    4381 </span>            :                         case V_SgIntegerDivideOp:</a>
<a name="4382"><span class="lineNum">    4382 </span>            :                         case V_SgModOp:</a>
<a name="4383"><span class="lineNum">    4383 </span>            :                         case V_SgAndOp:</a>
<a name="4384"><span class="lineNum">    4384 </span>            :                         case V_SgOrOp:</a>
<a name="4385"><span class="lineNum">    4385 </span>            :                         case V_SgBitXorOp:</a>
<a name="4386"><span class="lineNum">    4386 </span>            :                         case V_SgBitAndOp:</a>
<a name="4387"><span class="lineNum">    4387 </span>            :                         case V_SgBitOrOp:</a>
<a name="4388"><span class="lineNum">    4388 </span>            :                         case V_SgThrowOp:</a>
<a name="4389"><span class="lineNum">    4389 </span>            :                         case V_SgRealPartOp:</a>
<a name="4390"><span class="lineNum">    4390 </span>            :                         case V_SgImagPartOp:</a>
<a name="4391"><span class="lineNum">    4391 </span>            :                         case V_SgConjugateOp:</a>
<a name="4392"><span class="lineNum">    4392 </span>            :                         case V_SgUserDefinedUnaryOp:</a>
<a name="4393"><span class="lineNum">    4393 </span>            :                         case V_SgExpressionRoot:</a>
<a name="4394"><span class="lineNum">    4394 </span>            :                         case V_SgMinusOp:</a>
<a name="4395"><span class="lineNum">    4395 </span>            :                         case V_SgUnaryAddOp:</a>
<a name="4396"><span class="lineNum">    4396 </span>            :                         case V_SgNotOp:</a>
<a name="4397"><span class="lineNum">    4397 </span>            :                         case V_SgBitComplementOp:</a>
<a name="4398"><span class="lineNum">    4398 </span>            :                         case V_SgClassNameRefExp:</a>
<a name="4399"><span class="lineNum">    4399 </span>            :                         case V_SgValueExp:</a>
<a name="4400"><span class="lineNum">    4400 </span>            :                         case V_SgSizeOfOp:</a>
<a name="4401"><span class="lineNum">    4401 </span>            :                         case V_SgUpcLocalsizeofExpression:</a>
<a name="4402"><span class="lineNum">    4402 </span>            :                         case V_SgUpcBlocksizeofExpression:</a>
<a name="4403"><span class="lineNum">    4403 </span>            :                         case V_SgUpcElemsizeofExpression:</a>
<a name="4404"><span class="lineNum">    4404 </span>            :                         case V_SgNewExp:</a>
<a name="4405"><span class="lineNum">    4405 </span>            :                         case V_SgDeleteExp:</a>
<a name="4406"><span class="lineNum">    4406 </span>            :                         case V_SgThisExp:</a>
<a name="4407"><span class="lineNum">    4407 </span>            :                         case V_SgRefExp:</a>
<a name="4408"><span class="lineNum">    4408 </span>            :                         case V_SgInitializer:</a>
<a name="4409"><span class="lineNum">    4409 </span>            :                         case V_SgVarArgStartOp:</a>
<a name="4410"><span class="lineNum">    4410 </span>            :                         case V_SgVarArgOp:</a>
<a name="4411"><span class="lineNum">    4411 </span>            :                         case V_SgVarArgEndOp:</a>
<a name="4412"><span class="lineNum">    4412 </span>            :                         case V_SgVarArgCopyOp:</a>
<a name="4413"><span class="lineNum">    4413 </span>            :                         case V_SgVarArgStartOneOperandOp:</a>
<a name="4414"><span class="lineNum">    4414 </span>            :                         case V_SgNullExpression:</a>
<a name="4415"><span class="lineNum">    4415 </span>            :                         case V_SgVariantExpression:</a>
<a name="4416"><span class="lineNum">    4416 </span>            :                         case V_SgSubscriptExpression:</a>
<a name="4417"><span class="lineNum">    4417 </span>            :                         case V_SgColonShapeExp:</a>
<a name="4418"><span class="lineNum">    4418 </span>            :                         case V_SgAsteriskShapeExp:</a>
<a name="4419"><span class="lineNum">    4419 </span>            :                         case V_SgImpliedDo:</a>
<a name="4420"><span class="lineNum">    4420 </span>            :                         case V_SgIOItemExpression:</a>
<a name="4421"><span class="lineNum">    4421 </span>            :                         case V_SgStatementExpression:</a>
<a name="4422"><span class="lineNum">    4422 </span>            :                         case V_SgAsmOp:</a>
<a name="4423"><span class="lineNum">    4423 </span>            :                         case V_SgLabelRefExp:</a>
<a name="4424"><span class="lineNum">    4424 </span>            :                         case V_SgActualArgumentExpression:</a>
<a name="4425"><span class="lineNum">    4425 </span>            :                         case V_SgUnknownArrayOrFunctionReference:</a>
<a name="4426"><span class="lineNum">    4426 </span>            :                         case V_SgPseudoDestructorRefExp:</a>
<a name="4427"><span class="lineNum">    4427 </span>            :                         case V_SgCudaKernelCallExp:</a>
<a name="4428"><span class="lineNum">    4428 </span>            :                         case V_SgCudaKernelExecConfig:</a>
<a name="4429"><span class="lineNum">    4429 </span>            :                                 break;</a>
<a name="4430"><span class="lineNum">    4430 </span>            :                         /*UseRenameExpression*/</a>
<a name="4431"><span class="lineNum">    4431 </span>            :                         /*UseOnlyExpression*/</a>
<a name="4432"><span class="lineNum">    4432 </span>            :                         default:</a>
<a name="4433"><span class="lineNum">    4433 </span>            :                                 break;</a>
<a name="4434"><span class="lineNum">    4434 </span>            :                 }</a>
<a name="4435"><span class="lineNum">    4435 </span>            :                 if (expression-&gt;isLValue() != verifiedLValue)</a>
<a name="4436"><span class="lineNum">    4436 </span>            :                         std::cout &lt;&lt; &quot;Node at &quot; &lt;&lt; node &lt;&lt; &quot; is sgtype &quot; &lt;&lt; node-&gt;variantT() &lt;&lt; &quot; : &quot; &lt;&lt; node-&gt;class_name() &lt;&lt; std::endl;</a>
<a name="4437"><span class="lineNum">    4437 </span>            :                 ROSE_ASSERT (expression-&gt;isLValue() == verifiedLValue);</a>
<a name="4438"><span class="lineNum">    4438 </span>            :                 if (expression-&gt;isDefinable() != verifiedDefinable)</a>
<a name="4439"><span class="lineNum">    4439 </span>            :                         std::cout &lt;&lt; &quot;Node at &quot; &lt;&lt; node &lt;&lt; &quot; is sgtype &quot; &lt;&lt; node-&gt;variantT() &lt;&lt; &quot; : &quot; &lt;&lt; node-&gt;class_name() &lt;&lt; std::endl;</a>
<a name="4440"><span class="lineNum">    4440 </span>            :                 ROSE_ASSERT (expression-&gt;isDefinable() == verifiedDefinable);</a>
<a name="4441"><span class="lineNum">    4441 </span>            :         }</a>
<a name="4442"><span class="lineNum">    4442 </span>            : }</a>
<a name="4443"><span class="lineNum">    4443 </span>            : </a>
<a name="4444"><span class="lineNum">    4444 </span>            : </a>
<a name="4445"><span class="lineNum">    4445 </span>            : </a>
<a name="4446"><span class="lineNum">    4446 </span>            : </a>
<a name="4447"><span class="lineNum">    4447 </span>            : void</a>
<a name="4448"><span class="lineNum">    4448 </span><span class="lineCov">   55910000 : TestMangledNames::visit ( SgNode* node )</span></a>
<a name="4449"><span class="lineNum">    4449 </span>            :    {</a>
<a name="4450"><span class="lineNum">    4450 </span><span class="lineCov">   55910000 :      ROSE_ASSERT(node != NULL);</span></a>
<a name="4451"><span class="lineNum">    4451 </span>            : </a>
<a name="4452"><span class="lineNum">    4452 </span>            : #if 0</a>
<a name="4453"><span class="lineNum">    4453 </span>            :      printf (&quot;In TestMangledNames::visit(): node = %p = %s \n&quot;,node,node-&gt;class_name().c_str());</a>
<a name="4454"><span class="lineNum">    4454 </span>            : #endif</a>
<a name="4455"><span class="lineNum">    4455 </span>            : </a>
<a name="4456"><span class="lineNum">    4456 </span>            :   // DQ (1/12/13): Added to support detection of scopes that have been deleted.</a>
<a name="4457"><span class="lineNum">    4457 </span><span class="lineCov">   55910000 :      bool isDeletedNode = false;</span></a>
<a name="4458"><span class="lineNum">    4458 </span>            : </a>
<a name="4459"><span class="lineNum">    4459 </span>            :   // DQ (5/26/2013): This is the signature in the IR node held by the memory pool for an IR node that has been previously deleted.</a>
<a name="4460"><span class="lineNum">    4460 </span>            :   // This node is being traversed by the AST traversal following a dangling pointer.  This was a problem that was previously</a>
<a name="4461"><span class="lineNum">    4461 </span>            :   // difficult to detect but now appears to be more easily reproduced in ROSE (at least with the gnu 4.2.4 compiler).</a>
<a name="4462"><span class="lineNum">    4462 </span><span class="lineCov">   55910000 :      ROSE_ASSERT(node != NULL);</span></a>
<a name="4463"><span class="lineNum">    4463 </span><span class="lineCov">  128747000 :      if (node-&gt;class_name() == &quot;SgNode&quot;)</span></a>
<a name="4464"><span class="lineNum">    4464 </span>            :         {</a>
<a name="4465"><span class="lineNum">    4465 </span><span class="lineNoCov">          0 :           printf (&quot;ERROR: This node = %p has been previously deleted \n&quot;,node);</span></a>
<a name="4466"><span class="lineNum">    4466 </span><span class="lineNoCov">          0 :           ROSE_ABORT();</span></a>
<a name="4467"><span class="lineNum">    4467 </span>            :         }</a>
<a name="4468"><span class="lineNum">    4468 </span>            : </a>
<a name="4469"><span class="lineNum">    4469 </span>            : </a>
<a name="4470"><span class="lineNum">    4470 </span><span class="lineCov">   55910000 :      string mangledName;</span></a>
<a name="4471"><span class="lineNum">    4471 </span>            : #if 0</a>
<a name="4472"><span class="lineNum">    4472 </span>            :      SgGlobal* global = isSgGlobal(node);</a>
<a name="4473"><span class="lineNum">    4473 </span>            :      if (global != NULL)</a>
<a name="4474"><span class="lineNum">    4474 </span>            :         {</a>
<a name="4475"><span class="lineNum">    4475 </span>            :           const std::map&lt;std::string, int&gt;&amp; shortMangledNameCache = global-&gt;get_shortMangledNameCache();</a>
<a name="4476"><span class="lineNum">    4476 </span>            :           for (std::map&lt;std::string, int&gt;::const_iterator i = shortMangledNameCache.begin(); i != shortMangledNameCache.end(); ++i) {</a>
<a name="4477"><span class="lineNum">    4477 </span>            :             this-&gt;totalLongMangledNameSize += i-&gt;first.size();</a>
<a name="4478"><span class="lineNum">    4478 </span>            :             ++this-&gt;totalNumberOfLongMangledNames;</a>
<a name="4479"><span class="lineNum">    4479 </span>            :           }</a>
<a name="4480"><span class="lineNum">    4480 </span>            :         }</a>
<a name="4481"><span class="lineNum">    4481 </span>            : #endif</a>
<a name="4482"><span class="lineNum">    4482 </span><span class="lineCov">   55910000 :      SgDeclarationStatement* declarationStatement = isSgDeclarationStatement(node);</span></a>
<a name="4483"><span class="lineNum">    4483 </span><span class="lineCov">   55910000 :      SgNonrealDecl * nrdecl = isSgNonrealDecl(node);</span></a>
<a name="4484"><span class="lineNum">    4484 </span><span class="lineCov">   55910000 :      if (declarationStatement != NULL)</span></a>
<a name="4485"><span class="lineNum">    4485 </span>            :         {</a>
<a name="4486"><span class="lineNum">    4486 </span>            :        // DQ (1/12/13): Added fix for scopes that may have been deleted (happens where astDelete mechanism is used)</a>
<a name="4487"><span class="lineNum">    4487 </span>            :        // mangledName = declarationStatement-&gt;get_mangled_name().getString();</a>
<a name="4488"><span class="lineNum">    4488 </span><span class="lineCov">    3464300 :           if (nrdecl == NULL &amp;&amp; declarationStatement-&gt;get_scope() == NULL)</span></a>
<a name="4489"><span class="lineNum">    4489 </span>            :              {</a>
<a name="4490"><span class="lineNum">    4490 </span><span class="lineNoCov">          0 :                printf (&quot;ERROR: TestMangledNames::visit(): declarationStatement = %p = %s \n&quot;,declarationStatement,declarationStatement-&gt;class_name().c_str());</span></a>
<a name="4491"><span class="lineNum">    4491 </span>            :              }</a>
<a name="4492"><span class="lineNum">    4492 </span><span class="lineCov">    3464300 :           ROSE_ASSERT( nrdecl != NULL || declarationStatement-&gt;get_scope() != NULL );</span></a>
<a name="4493"><span class="lineNum">    4493 </span>            : #if 0</a>
<a name="4494"><span class="lineNum">    4494 </span>            :           printf (&quot;TestMangledNames::visit(): declarationStatement-&gt;get_scope() = %p = %s \n&quot;,declarationStatement-&gt;get_scope(),declarationStatement-&gt;get_scope()-&gt;class_name().c_str());</a>
<a name="4495"><span class="lineNum">    4495 </span>            : #endif</a>
<a name="4496"><span class="lineNum">    4496 </span><span class="lineCov">    6894030 :           if (nrdecl == NULL &amp;&amp; declarationStatement-&gt;get_scope()-&gt;class_name() == &quot;SgNode&quot;)</span></a>
<a name="4497"><span class="lineNum">    4497 </span>            :              {</a>
<a name="4498"><span class="lineNum">    4498 </span><span class="lineNoCov">          0 :                isDeletedNode = true;</span></a>
<a name="4499"><span class="lineNum">    4499 </span>            :              }</a>
<a name="4500"><span class="lineNum">    4500 </span>            : </a>
<a name="4501"><span class="lineNum">    4501 </span><span class="lineCov">    3464300 :           if (isDeletedNode == false)</span></a>
<a name="4502"><span class="lineNum">    4502 </span>            :              {</a>
<a name="4503"><span class="lineNum">    4503 </span><span class="lineCov">    3464300 :                mangledName = declarationStatement-&gt;get_mangled_name().getString();</span></a>
<a name="4504"><span class="lineNum">    4504 </span>            :              }</a>
<a name="4505"><span class="lineNum">    4505 </span>            :             else</a>
<a name="4506"><span class="lineNum">    4506 </span>            :              {</a>
<a name="4507"><span class="lineNum">    4507 </span><span class="lineNoCov">          0 :                printf (&quot;WARNING: evaluation of the mangled name for a declaration in a scope = %p that has been deleted is being skipped! \n&quot;,declarationStatement-&gt;get_scope());</span></a>
<a name="4508"><span class="lineNum">    4508 </span>            :              }</a>
<a name="4509"><span class="lineNum">    4509 </span>            : </a>
<a name="4510"><span class="lineNum">    4510 </span>            :        // printf (&quot;Test generated mangledName for node = %p = %s = %s \n&quot;,node,node-&gt;class_name().c_str(),mangledName.c_str());</a>
<a name="4511"><span class="lineNum">    4511 </span>            :         }</a>
<a name="4512"><span class="lineNum">    4512 </span>            : </a>
<a name="4513"><span class="lineNum">    4513 </span><span class="lineCov">   55910000 :      SgInitializedName* initializedName = isSgInitializedName(node);</span></a>
<a name="4514"><span class="lineNum">    4514 </span><span class="lineCov">   55910000 :      if (initializedName != NULL)</span></a>
<a name="4515"><span class="lineNum">    4515 </span>            :         {</a>
<a name="4516"><span class="lineNum">    4516 </span>            :        // mangledName = initializedName-&gt;get_mangled_name().getString();</a>
<a name="4517"><span class="lineNum">    4517 </span>            : #if 0</a>
<a name="4518"><span class="lineNum">    4518 </span>            :           printf (&quot;TestMangledNames::visit(): initializedName-&gt;get_scope() = %p = %s \n&quot;,initializedName-&gt;get_scope(),initializedName-&gt;get_scope()-&gt;class_name().c_str());</a>
<a name="4519"><span class="lineNum">    4519 </span>            : #endif</a>
<a name="4520"><span class="lineNum">    4520 </span>            :        // ROSE_ASSERT (initializedName-&gt;get_scope() != NULL);</a>
<a name="4521"><span class="lineNum">    4521 </span><span class="lineCov">    5937460 :           if (initializedName-&gt;get_scope() != NULL)</span></a>
<a name="4522"><span class="lineNum">    4522 </span>            :              {</a>
<a name="4523"><span class="lineNum">    4523 </span><span class="lineCov">   11978600 :                if (initializedName-&gt;get_scope()-&gt;class_name() == &quot;SgNode&quot;)</span></a>
<a name="4524"><span class="lineNum">    4524 </span>            :                   {</a>
<a name="4525"><span class="lineNum">    4525 </span>            :                     isDeletedNode = true;</a>
<a name="4526"><span class="lineNum">    4526 </span>            :                   }</a>
<a name="4527"><span class="lineNum">    4527 </span>            : </a>
<a name="4528"><span class="lineNum">    4528 </span><span class="lineCov">    5937460 :                if (isDeletedNode == false)</span></a>
<a name="4529"><span class="lineNum">    4529 </span>            :                   {</a>
<a name="4530"><span class="lineNum">    4530 </span><span class="lineCov">    5937460 :                     mangledName = initializedName-&gt;get_mangled_name().getString();</span></a>
<a name="4531"><span class="lineNum">    4531 </span>            :                   }</a>
<a name="4532"><span class="lineNum">    4532 </span>            :                  else</a>
<a name="4533"><span class="lineNum">    4533 </span>            :                   {</a>
<a name="4534"><span class="lineNum">    4534 </span><span class="lineNoCov">          0 :                     printf (&quot;WARNING: evaluation of the mangled name for a SgInitializedName in a scope = %p that has been deleted is being skipped! \n&quot;,initializedName-&gt;get_scope());</span></a>
<a name="4535"><span class="lineNum">    4535 </span>            :                   }</a>
<a name="4536"><span class="lineNum">    4536 </span>            :              }</a>
<a name="4537"><span class="lineNum">    4537 </span>            :             else</a>
<a name="4538"><span class="lineNum">    4538 </span>            :              {</a>
<a name="4539"><span class="lineNum">    4539 </span>            : #if 0</a>
<a name="4540"><span class="lineNum">    4540 </span>            :             // DQ (1/25/2020): Output spew when using tool_G on target applications.</a>
<a name="4541"><span class="lineNum">    4541 </span>            :                printf (&quot;NOTE: In TestMangledNames::visit(): initializedName-&gt;get_scope() == NULL: initializedName = %p name = %s \n&quot;,initializedName,initializedName-&gt;get_name().str());</a>
<a name="4542"><span class="lineNum">    4542 </span>            : #endif</a>
<a name="4543"><span class="lineNum">    4543 </span>            :              }</a>
<a name="4544"><span class="lineNum">    4544 </span>            : </a>
<a name="4545"><span class="lineNum">    4545 </span>            :        // printf (&quot;Test generated mangledName for node = %p = %s = %s \n&quot;,node,node-&gt;class_name().c_str(),mangledName.c_str());</a>
<a name="4546"><span class="lineNum">    4546 </span>            :         }</a>
<a name="4547"><span class="lineNum">    4547 </span>            : #if 1</a>
<a name="4548"><span class="lineNum">    4548 </span><span class="lineCov">   55910000 :      SgFunctionDefinition* functionDefinition = isSgFunctionDefinition(node);</span></a>
<a name="4549"><span class="lineNum">    4549 </span><span class="lineCov">   55910000 :      if (functionDefinition != NULL)</span></a>
<a name="4550"><span class="lineNum">    4550 </span>            :         {</a>
<a name="4551"><span class="lineNum">    4551 </span>            :        // DQ (11/27/2011): Adding more support for template declarations in the AST.</a>
<a name="4552"><span class="lineNum">    4552 </span>            :        // mangledName = functionDefinition-&gt;get_mangled_name().getString();</a>
<a name="4553"><span class="lineNum">    4553 </span><span class="lineCov">      13962 :           SgTemplateFunctionDefinition* templateFunctionDefinition = isSgTemplateFunctionDefinition(functionDefinition);</span></a>
<a name="4554"><span class="lineNum">    4554 </span><span class="lineCov">      13962 :           if (templateFunctionDefinition != NULL)</span></a>
<a name="4555"><span class="lineNum">    4555 </span>            :              {</a>
<a name="4556"><span class="lineNum">    4556 </span><span class="lineCov">       2206 :                mangledName = templateFunctionDefinition-&gt;get_mangled_name().getString();</span></a>
<a name="4557"><span class="lineNum">    4557 </span>            :              }</a>
<a name="4558"><span class="lineNum">    4558 </span>            :             else</a>
<a name="4559"><span class="lineNum">    4559 </span>            :              {</a>
<a name="4560"><span class="lineNum">    4560 </span><span class="lineCov">      11756 :                mangledName = functionDefinition-&gt;get_mangled_name().getString();</span></a>
<a name="4561"><span class="lineNum">    4561 </span>            :              }</a>
<a name="4562"><span class="lineNum">    4562 </span>            :        // printf (&quot;Test generated mangledName for node = %p = %s = %s \n&quot;,node,node-&gt;class_name().c_str(),mangledName.c_str());</a>
<a name="4563"><span class="lineNum">    4563 </span>            :         }</a>
<a name="4564"><span class="lineNum">    4564 </span>            : #endif</a>
<a name="4565"><span class="lineNum">    4565 </span>            : #if 1</a>
<a name="4566"><span class="lineNum">    4566 </span><span class="lineCov">   55910000 :      SgClassDefinition* classDefinition = isSgClassDefinition(node);</span></a>
<a name="4567"><span class="lineNum">    4567 </span><span class="lineCov">   55910000 :      if (classDefinition != NULL)</span></a>
<a name="4568"><span class="lineNum">    4568 </span>            :         {</a>
<a name="4569"><span class="lineNum">    4569 </span><span class="lineCov">      13703 :           mangledName = classDefinition-&gt;get_mangled_name().getString();</span></a>
<a name="4570"><span class="lineNum">    4570 </span>            :        // printf (&quot;Test generated mangledName for node = %p = %s = %s \n&quot;,node,node-&gt;class_name().c_str(),mangledName.c_str());</a>
<a name="4571"><span class="lineNum">    4571 </span>            :         }</a>
<a name="4572"><span class="lineNum">    4572 </span>            : #endif</a>
<a name="4573"><span class="lineNum">    4573 </span>            : #if 1</a>
<a name="4574"><span class="lineNum">    4574 </span><span class="lineCov">   55910000 :      SgNamespaceDefinitionStatement* namespaceDefinition = isSgNamespaceDefinitionStatement(node);</span></a>
<a name="4575"><span class="lineNum">    4575 </span><span class="lineCov">   55910000 :      if (namespaceDefinition != NULL)</span></a>
<a name="4576"><span class="lineNum">    4576 </span>            :         {</a>
<a name="4577"><span class="lineNum">    4577 </span><span class="lineCov">        922 :           mangledName = namespaceDefinition-&gt;get_mangled_name().getString();</span></a>
<a name="4578"><span class="lineNum">    4578 </span>            :        // printf (&quot;Test generated mangledName for node = %p = %s = %s \n&quot;,node,node-&gt;class_name().c_str(),mangledName.c_str());</a>
<a name="4579"><span class="lineNum">    4579 </span>            :         }</a>
<a name="4580"><span class="lineNum">    4580 </span>            : #endif</a>
<a name="4581"><span class="lineNum">    4581 </span>            : #if 1</a>
<a name="4582"><span class="lineNum">    4582 </span><span class="lineCov">   55910000 :      SgTemplateArgument* templateArgument = isSgTemplateArgument(node);</span></a>
<a name="4583"><span class="lineNum">    4583 </span><span class="lineCov">   55910000 :      if (templateArgument != NULL)</span></a>
<a name="4584"><span class="lineNum">    4584 </span>            :         {</a>
<a name="4585"><span class="lineNum">    4585 </span><span class="lineCov">      44871 :           mangledName = templateArgument-&gt;get_mangled_name().getString();</span></a>
<a name="4586"><span class="lineNum">    4586 </span>            :        // printf (&quot;Test generated mangledName for node = %p = %s = %s \n&quot;,node,node-&gt;class_name().c_str(),mangledName.c_str());</a>
<a name="4587"><span class="lineNum">    4587 </span>            :         }</a>
<a name="4588"><span class="lineNum">    4588 </span>            : #endif</a>
<a name="4589"><span class="lineNum">    4589 </span><span class="lineCov">   55910000 :      SgType* type = isSgType(node);</span></a>
<a name="4590"><span class="lineNum">    4590 </span><span class="lineCov">   55910000 :      if (type != NULL)</span></a>
<a name="4591"><span class="lineNum">    4591 </span>            :         {</a>
<a name="4592"><span class="lineNum">    4592 </span>            :        // DQ (1/12/13): Need to test for declarations in scopes that might have been deleted (part of astCopy and astDelete support).</a>
<a name="4593"><span class="lineNum">    4593 </span>            :        // If there is a declaration, then the scope of that declaration might have been deleted (we need to detect this).</a>
<a name="4594"><span class="lineNum">    4594 </span>            :        // If this is a type in a scope that has been deleted then we should remove the scope (bug in the astDelete support, I think).</a>
<a name="4595"><span class="lineNum">    4595 </span><span class="lineCov">     385096 :           SgDeclarationStatement* decl = type-&gt;getAssociatedDeclaration();</span></a>
<a name="4596"><span class="lineNum">    4596 </span>            :        // ROSE_ASSERT(decl != NULL);</a>
<a name="4597"><span class="lineNum">    4597 </span>            : #if 0</a>
<a name="4598"><span class="lineNum">    4598 </span>            :           printf (&quot;TestMangledNames::visit(): decl = %p = %s \n&quot;,decl,decl != NULL ? decl-&gt;class_name().c_str() : &quot;null&quot;);</a>
<a name="4599"><span class="lineNum">    4599 </span>            : #endif</a>
<a name="4600"><span class="lineNum">    4600 </span><span class="lineCov">     385096 :           if (decl != NULL)</span></a>
<a name="4601"><span class="lineNum">    4601 </span>            :              {</a>
<a name="4602"><span class="lineNum">    4602 </span><span class="lineCov">     759180 :                if (decl-&gt;class_name() == &quot;SgNode&quot;)</span></a>
<a name="4603"><span class="lineNum">    4603 </span>            :                   {</a>
<a name="4604"><span class="lineNum">    4604 </span><span class="lineNoCov">          0 :                     printf (&quot;ERROR: decl = %p was previously deleted \n&quot;,decl);</span></a>
<a name="4605"><span class="lineNum">    4605 </span><span class="lineNoCov">          0 :                     ROSE_ABORT();</span></a>
<a name="4606"><span class="lineNum">    4606 </span>            :                   }</a>
<a name="4607"><span class="lineNum">    4607 </span>            :             // DQ (5/25/2013): This is failing for the astInterface tests: deepDelete.C</a>
<a name="4608"><span class="lineNum">    4608 </span><span class="lineCov">     267668 :                if (decl-&gt;get_scope() == NULL)</span></a>
<a name="4609"><span class="lineNum">    4609 </span>            :                   {</a>
<a name="4610"><span class="lineNum">    4610 </span>            :                  // printf (&quot;ERROR: TestMangledNames::visit(): decl = %p = %s \n&quot;,decl,decl != NULL ? decl-&gt;class_name().c_str() : &quot;null&quot;);</a>
<a name="4611"><span class="lineNum">    4611 </span><span class="lineNoCov">          0 :                     printf (&quot;ERROR: TestMangledNames::visit(): decl = %p \n&quot;,decl);</span></a>
<a name="4612"><span class="lineNum">    4612 </span>            :                   }</a>
<a name="4613"><span class="lineNum">    4613 </span><span class="lineCov">     267668 :                ROSE_ASSERT(decl-&gt;get_scope() != NULL);</span></a>
<a name="4614"><span class="lineNum">    4614 </span>            : #if 0</a>
<a name="4615"><span class="lineNum">    4615 </span>            :                printf (&quot;TestMangledNames::visit(): decl-&gt;get_scope() = %p = %s \n&quot;,decl-&gt;get_scope(),decl-&gt;get_scope()-&gt;class_name().c_str());</a>
<a name="4616"><span class="lineNum">    4616 </span>            : #endif</a>
<a name="4617"><span class="lineNum">    4617 </span>            :             // ROSE_ASSERT(decl-&gt;get_scope()-&gt;class_name() != &quot;SgNode&quot;);</a>
<a name="4618"><span class="lineNum">    4618 </span><span class="lineCov">     613550 :                if (decl-&gt;get_scope()-&gt;class_name() == &quot;SgNode&quot;)</span></a>
<a name="4619"><span class="lineNum">    4619 </span>            :                   {</a>
<a name="4620"><span class="lineNum">    4620 </span>            :                     isDeletedNode = true;</a>
<a name="4621"><span class="lineNum">    4621 </span>            :                   }</a>
<a name="4622"><span class="lineNum">    4622 </span>            :              }</a>
<a name="4623"><span class="lineNum">    4623 </span>            :             else</a>
<a name="4624"><span class="lineNum">    4624 </span>            :              {</a>
<a name="4625"><span class="lineNum">    4625 </span>            :             // DQ (5/25/2013): Added this case to set isDeletedNode = true when decl == NULL.</a>
<a name="4626"><span class="lineNum">    4626 </span>            :                isDeletedNode = true;</a>
<a name="4627"><span class="lineNum">    4627 </span>            :              }</a>
<a name="4628"><span class="lineNum">    4628 </span>            : </a>
<a name="4629"><span class="lineNum">    4629 </span>            :        // SgScopeStatement* scope = type-&gt;getCurrentScope();</a>
<a name="4630"><span class="lineNum">    4630 </span>            :        // printf (&quot;TestMangledNames::visit(): scope = %p \n&quot;,scope);</a>
<a name="4631"><span class="lineNum">    4631 </span>            :        // if (scope != NULL)</a>
<a name="4632"><span class="lineNum">    4632 </span>            :        //    {</a>
<a name="4633"><span class="lineNum">    4633 </span>            :        //      ROSE_ASSERT(scope-&gt;class_name() != &quot;SgNode&quot;);</a>
<a name="4634"><span class="lineNum">    4634 </span>            :        //    }</a>
<a name="4635"><span class="lineNum">    4635 </span>            : </a>
<a name="4636"><span class="lineNum">    4636 </span>            :        // Notice that this has a different name get_mangled() instead of get_mangled_name()</a>
<a name="4637"><span class="lineNum">    4637 </span>            : </a>
<a name="4638"><span class="lineNum">    4638 </span>            :        // DQ (1/12/13): For now, we want to ignore tests on IR nodes for types that are associated with declarations in scopes that have been deleted as part of the astDelete mechanism.</a>
<a name="4639"><span class="lineNum">    4639 </span>            :        // mangledName = type-&gt;get_mangled().getString();</a>
<a name="4640"><span class="lineNum">    4640 </span>            : #if 0</a>
<a name="4641"><span class="lineNum">    4641 </span>            :           printf (&quot;TestMangledNames::visit(): isDeletedNode = %s \n&quot;,isDeletedNode ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="4642"><span class="lineNum">    4642 </span>            : #endif</a>
<a name="4643"><span class="lineNum">    4643 </span><span class="lineCov">     267668 :           if (isDeletedNode == false)</span></a>
<a name="4644"><span class="lineNum">    4644 </span>            :              {</a>
<a name="4645"><span class="lineNum">    4645 </span><span class="lineCov">     267668 :                mangledName = type-&gt;get_mangled().getString();</span></a>
<a name="4646"><span class="lineNum">    4646 </span>            :              }</a>
<a name="4647"><span class="lineNum">    4647 </span>            :             else</a>
<a name="4648"><span class="lineNum">    4648 </span>            :              {</a>
<a name="4649"><span class="lineNum">    4649 </span>            :             // DQ (5/25/2013): Fixed SgType::getAssociatedDeclaration() to return NULL when we detect that the declaration was deleted (e.g. when decl-&gt;class_name() == &quot;SgNode&quot;).</a>
<a name="4650"><span class="lineNum">    4650 </span>            :             // ROSE_ASSERT(decl != NULL);</a>
<a name="4651"><span class="lineNum">    4651 </span>            :             // printf (&quot;WARNING: evaluation of the mangled name for a declaration in a scope = %p that has been deleted is being skipped! \n&quot;,decl-&gt;get_scope());</a>
<a name="4652"><span class="lineNum">    4652 </span><span class="lineCov">     117428 :                if (decl != NULL)</span></a>
<a name="4653"><span class="lineNum">    4653 </span>            :                   {</a>
<a name="4654"><span class="lineNum">    4654 </span><span class="lineNoCov">          0 :                     printf (&quot;WARNING: evaluation of the mangled name for a declaration in a scope = %p that has been deleted is being skipped! \n&quot;,decl-&gt;get_scope());</span></a>
<a name="4655"><span class="lineNum">    4655 </span>            :                   }</a>
<a name="4656"><span class="lineNum">    4656 </span>            :              }</a>
<a name="4657"><span class="lineNum">    4657 </span>            :        // printf (&quot;Test generated mangledName for node = %p = %s = %s \n&quot;,node,node-&gt;class_name().c_str(),mangledName.c_str());</a>
<a name="4658"><span class="lineNum">    4658 </span>            :         }</a>
<a name="4659"><span class="lineNum">    4659 </span>            : </a>
<a name="4660"><span class="lineNum">    4660 </span>            :   // printf (&quot;Test generated mangledName for node = %p = %s = %s \n&quot;,node,node-&gt;class_name().c_str(),mangledName.c_str());</a>
<a name="4661"><span class="lineNum">    4661 </span>            : </a>
<a name="4662"><span class="lineNum">    4662 </span>            :   // DQ (8/28/2006): Added tests for the length of the mangled names</a>
<a name="4663"><span class="lineNum">    4663 </span><span class="lineCov">   55910000 :      unsigned long mangledNameSize = mangledName.size();</span></a>
<a name="4664"><span class="lineNum">    4664 </span><span class="lineCov">   55910000 :      saved_totalMangledNameSize += mangledNameSize;</span></a>
<a name="4665"><span class="lineNum">    4665 </span><span class="lineCov">   55910000 :      saved_numberOfMangledNames++;</span></a>
<a name="4666"><span class="lineNum">    4666 </span><span class="lineCov">   55910000 :      if (saved_maxMangledNameSize &lt; mangledNameSize)</span></a>
<a name="4667"><span class="lineNum">    4667 </span>            :         {</a>
<a name="4668"><span class="lineNum">    4668 </span><span class="lineCov">       5598 :           saved_maxMangledNameSize = mangledNameSize;</span></a>
<a name="4669"><span class="lineNum">    4669 </span><span class="lineCov">       5598 :           if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL )</span></a>
<a name="4670"><span class="lineNum">    4670 </span>            :              {</a>
<a name="4671"><span class="lineNum">    4671 </span><span class="lineCov">   55910000 :                printf (&quot;saved_maxMangledNameSize = %ld average size = %ld \n&quot;,saved_maxMangledNameSize,saved_totalMangledNameSize/saved_numberOfMangledNames);</span></a>
<a name="4672"><span class="lineNum">    4672 </span>            :              }</a>
<a name="4673"><span class="lineNum">    4673 </span>            :         }</a>
<a name="4674"><span class="lineNum">    4674 </span><span class="lineCov">   55910000 :    }</span></a>
<a name="4675"><span class="lineNum">    4675 </span>            : </a>
<a name="4676"><span class="lineNum">    4676 </span><span class="lineCov">        326 : TestMangledNames::TestMangledNames()</span></a>
<a name="4677"><span class="lineNum">    4677 </span><span class="lineCov">        326 :    : saved_maxMangledNameSize(0),saved_totalMangledNameSize(0),saved_numberOfMangledNames(0),totalLongMangledNameSize(0),totalNumberOfLongMangledNames(0)</span></a>
<a name="4678"><span class="lineNum">    4678 </span>            :    {</a>
<a name="4679"><span class="lineNum">    4679 </span>            :   // Nothing to do here!</a>
<a name="4680"><span class="lineNum">    4680 </span><span class="lineCov">        326 :    }</span></a>
<a name="4681"><span class="lineNum">    4681 </span>            : </a>
<a name="4682"><span class="lineNum">    4682 </span>            : void</a>
<a name="4683"><span class="lineNum">    4683 </span><span class="lineCov">        326 : TestMangledNames::test()</span></a>
<a name="4684"><span class="lineNum">    4684 </span>            :    {</a>
<a name="4685"><span class="lineNum">    4685 </span><span class="lineCov">        326 :      TestMangledNames t;</span></a>
<a name="4686"><span class="lineNum">    4686 </span>            : </a>
<a name="4687"><span class="lineNum">    4687 </span>            :   // DQ (6/26/2007): Added code by Jeremiah for shorter mangled names</a>
<a name="4688"><span class="lineNum">    4688 </span><span class="lineCov">        326 :      const std::map&lt;std::string, int&gt;&amp; shortMangledNameCache = SgNode::get_shortMangledNameCache();</span></a>
<a name="4689"><span class="lineNum">    4689 </span><span class="lineCov">    1486250 :      for (std::map&lt;std::string, int&gt;::const_iterator i = shortMangledNameCache.begin(); i != shortMangledNameCache.end(); ++i)</span></a>
<a name="4690"><span class="lineNum">    4690 </span>            :         {</a>
<a name="4691"><span class="lineNum">    4691 </span><span class="lineCov">    1485920 :           t.totalLongMangledNameSize += i-&gt;first.size();</span></a>
<a name="4692"><span class="lineNum">    4692 </span><span class="lineCov">    1485920 :           ++(t.totalNumberOfLongMangledNames);</span></a>
<a name="4693"><span class="lineNum">    4693 </span>            :         }</a>
<a name="4694"><span class="lineNum">    4694 </span>            : </a>
<a name="4695"><span class="lineNum">    4695 </span>            :   // t.traverse(node,preorder);</a>
<a name="4696"><span class="lineNum">    4696 </span><span class="lineCov">        326 :      t.traverseMemoryPool();</span></a>
<a name="4697"><span class="lineNum">    4697 </span><span class="lineCov">        326 :      if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL )</span></a>
<a name="4698"><span class="lineNum">    4698 </span>            :         {</a>
<a name="4699"><span class="lineNum">    4699 </span><span class="lineNoCov">          0 :           printf (&quot;saved_numberOfMangledNames = %ld \n&quot;,t.saved_numberOfMangledNames);</span></a>
<a name="4700"><span class="lineNum">    4700 </span><span class="lineNoCov">          0 :           printf (&quot;saved_maxMangledNameSize   = %ld \n&quot;,t.saved_maxMangledNameSize);</span></a>
<a name="4701"><span class="lineNum">    4701 </span><span class="lineNoCov">          0 :           printf (&quot;saved_totalMangledNameSize = %ld avarage size = %lf \n&quot;,t.saved_totalMangledNameSize,t.saved_totalMangledNameSize*1.0/t.saved_numberOfMangledNames);</span></a>
<a name="4702"><span class="lineNum">    4702 </span><span class="lineNoCov">          0 :           printf (&quot;Total long mangled name size = %lu for %lu name(s), average is %lf\n&quot;, t.totalLongMangledNameSize, t.totalNumberOfLongMangledNames, t.totalLongMangledNameSize * 1. / t.totalNumberOfLongMangledNames);</span></a>
<a name="4703"><span class="lineNum">    4703 </span>            :         }</a>
<a name="4704"><span class="lineNum">    4704 </span><span class="lineCov">        326 :    }</span></a>
<a name="4705"><span class="lineNum">    4705 </span>            : </a>
<a name="4706"><span class="lineNum">    4706 </span>            : #if 0</a>
<a name="4707"><span class="lineNum">    4707 </span>            : // DQ (6/26/2006): This is not included in the more general TestParentPointersInMemoryPool tests</a>
<a name="4708"><span class="lineNum">    4708 </span>            : void</a>
<a name="4709"><span class="lineNum">    4709 </span>            : TestParentPointersOfSymbols::visit ( SgNode* node )</a>
<a name="4710"><span class="lineNum">    4710 </span>            :    {</a>
<a name="4711"><span class="lineNum">    4711 </span>            :      SgSymbol* symbol = isSgSymbol(node);</a>
<a name="4712"><span class="lineNum">    4712 </span>            :      if (symbol != NULL)</a>
<a name="4713"><span class="lineNum">    4713 </span>            :         {</a>
<a name="4714"><span class="lineNum">    4714 </span>            :           if (symbol-&gt;get_parent() == NULL)</a>
<a name="4715"><span class="lineNum">    4715 </span>            :              {</a>
<a name="4716"><span class="lineNum">    4716 </span>            :                printf (&quot;Error: symbol with NULL parent pointer at node = %p = %s \n&quot;,node,node-&gt;class_name().c_str());</a>
<a name="4717"><span class="lineNum">    4717 </span>            :              }</a>
<a name="4718"><span class="lineNum">    4718 </span>            :           ROSE_ASSERT(symbol-&gt;get_parent() != NULL);</a>
<a name="4719"><span class="lineNum">    4719 </span>            :         }</a>
<a name="4720"><span class="lineNum">    4720 </span>            :    }</a>
<a name="4721"><span class="lineNum">    4721 </span>            : </a>
<a name="4722"><span class="lineNum">    4722 </span>            : void</a>
<a name="4723"><span class="lineNum">    4723 </span>            : TestParentPointersOfSymbols::test()</a>
<a name="4724"><span class="lineNum">    4724 </span>            :    {</a>
<a name="4725"><span class="lineNum">    4725 </span>            :      TestParentPointersOfSymbols t;</a>
<a name="4726"><span class="lineNum">    4726 </span>            :   // t.traverse(node,preorder);</a>
<a name="4727"><span class="lineNum">    4727 </span>            :      t.traverseMemoryPool();</a>
<a name="4728"><span class="lineNum">    4728 </span>            :    }</a>
<a name="4729"><span class="lineNum">    4729 </span>            : #endif</a>
<a name="4730"><span class="lineNum">    4730 </span>            : #if 0</a>
<a name="4731"><span class="lineNum">    4731 </span>            : // Build a global function to simplify testing</a>
<a name="4732"><span class="lineNum">    4732 </span>            : void testParentPointersOfSymbols()</a>
<a name="4733"><span class="lineNum">    4733 </span>            :    {</a>
<a name="4734"><span class="lineNum">    4734 </span>            :      TestParentPointersOfSymbols::test();</a>
<a name="4735"><span class="lineNum">    4735 </span>            :    }</a>
<a name="4736"><span class="lineNum">    4736 </span>            : #endif</a>
<a name="4737"><span class="lineNum">    4737 </span>            : </a>
<a name="4738"><span class="lineNum">    4738 </span>            : </a>
<a name="4739"><span class="lineNum">    4739 </span>            : void</a>
<a name="4740"><span class="lineNum">    4740 </span><span class="lineCov">        326 : TestParentPointersInMemoryPool::test()</span></a>
<a name="4741"><span class="lineNum">    4741 </span>            :    {</a>
<a name="4742"><span class="lineNum">    4742 </span><span class="lineCov">        652 :      TestParentPointersInMemoryPool t;</span></a>
<a name="4743"><span class="lineNum">    4743 </span><span class="lineCov">        326 :      t.traverseMemoryPool();</span></a>
<a name="4744"><span class="lineNum">    4744 </span><span class="lineCov">        326 :    }</span></a>
<a name="4745"><span class="lineNum">    4745 </span>            : </a>
<a name="4746"><span class="lineNum">    4746 </span>            : void</a>
<a name="4747"><span class="lineNum">    4747 </span><span class="lineCov">   55910000 : TestParentPointersInMemoryPool::visit(SgNode* node)</span></a>
<a name="4748"><span class="lineNum">    4748 </span>            :    {</a>
<a name="4749"><span class="lineNum">    4749 </span>            : #if 0</a>
<a name="4750"><span class="lineNum">    4750 </span>            :      printf (&quot;##### TestParentPointersInMemoryPool::visit(node = %p = %s) \n&quot;,node,node-&gt;sage_class_name());</a>
<a name="4751"><span class="lineNum">    4751 </span>            : #endif</a>
<a name="4752"><span class="lineNum">    4752 </span>            : </a>
<a name="4753"><span class="lineNum">    4753 </span><span class="lineCov">   55910000 :      SgSymbol*      symbol      = isSgSymbol(node);</span></a>
<a name="4754"><span class="lineNum">    4754 </span><span class="lineCov">   55910000 :      SgLocatedNode* locatedNode = isSgLocatedNode(node);</span></a>
<a name="4755"><span class="lineNum">    4755 </span><span class="lineCov">   55910000 :      SgSupport*     support     = isSgSupport(node);</span></a>
<a name="4756"><span class="lineNum">    4756 </span>            : </a>
<a name="4757"><span class="lineNum">    4757 </span>            :   // Symbols can be shared within a single file but are not yet shared across files in the AST merge</a>
<a name="4758"><span class="lineNum">    4758 </span><span class="lineCov">   55910000 :      if (symbol != NULL)</span></a>
<a name="4759"><span class="lineNum">    4759 </span>            :         {</a>
<a name="4760"><span class="lineNum">    4760 </span><span class="lineCov">    2133630 :           if (symbol-&gt;get_parent() == NULL)</span></a>
<a name="4761"><span class="lineNum">    4761 </span><span class="lineNoCov">          0 :             printf(&quot;Error: symbol named %s has no parent set\n&quot;,symbol-&gt;get_name().getString().c_str());</span></a>
<a name="4762"><span class="lineNum">    4762 </span><span class="lineCov">    2133630 :           ROSE_ASSERT(symbol-&gt;get_parent() != NULL);</span></a>
<a name="4763"><span class="lineNum">    4763 </span>            :         }</a>
<a name="4764"><span class="lineNum">    4764 </span>            : #if 0</a>
<a name="4765"><span class="lineNum">    4765 </span>            :      if (isSgExpression(locatedNode) != NULL)</a>
<a name="4766"><span class="lineNum">    4766 </span>            :         {</a>
<a name="4767"><span class="lineNum">    4767 </span>            :           printf (&quot;TestParentPointersInMemoryPool::visit(): Skipping SgExpression IR Node \n&quot;);</a>
<a name="4768"><span class="lineNum">    4768 </span>            :         }</a>
<a name="4769"><span class="lineNum">    4769 </span>            : #endif</a>
<a name="4770"><span class="lineNum">    4770 </span>            : </a>
<a name="4771"><span class="lineNum">    4771 </span>            :   // Skip SgExpression object for now!</a>
<a name="4772"><span class="lineNum">    4772 </span><span class="lineCov">   55910000 :      locatedNode = isSgStatement(locatedNode);</span></a>
<a name="4773"><span class="lineNum">    4773 </span>            : </a>
<a name="4774"><span class="lineNum">    4774 </span>            :   // SgStatement and SgExpression IR nodes should always have a valid parent (except for the SgProject)</a>
<a name="4775"><span class="lineNum">    4775 </span><span class="lineCov">   55910000 :      if (locatedNode != NULL)</span></a>
<a name="4776"><span class="lineNum">    4776 </span>            :         {</a>
<a name="4777"><span class="lineNum">    4777 </span><span class="lineCov">    3595970 :           if (locatedNode-&gt;get_parent() == NULL)</span></a>
<a name="4778"><span class="lineNum">    4778 </span>            :              {</a>
<a name="4779"><span class="lineNum">    4779 </span>            : #ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION</a>
<a name="4780"><span class="lineNum">    4780 </span>            :                printf (&quot;Error: locatedNode-&gt;get_parent() == NULL locatedNode = %p = %s \n&quot;,locatedNode,locatedNode-&gt;class_name().c_str());</a>
<a name="4781"><span class="lineNum">    4781 </span>            :             // printf (&quot;Error: locatedNode-&gt;get_parent() == NULL locatedNode = %p = %s = %s \n&quot;,locatedNode,locatedNode-&gt;class_name().c_str(),SageInterface::get_name(locatedNode));</a>
<a name="4782"><span class="lineNum">    4782 </span>            : #endif</a>
<a name="4783"><span class="lineNum">    4783 </span>            :              }</a>
<a name="4784"><span class="lineNum">    4784 </span>            : </a>
<a name="4785"><span class="lineNum">    4785 </span>            :        // DQ (3/3/2012): Commented this out test (for debugging purposes only).</a>
<a name="4786"><span class="lineNum">    4786 </span>            :        // printf (&quot;In TestParentPointersInMemoryPool::visit(): Commented test for locatedNode-&gt;get_parent() != NULL \n&quot;);</a>
<a name="4787"><span class="lineNum">    4787 </span>            :        // ROSE_ASSERT(locatedNode-&gt;get_parent() != NULL);</a>
<a name="4788"><span class="lineNum">    4788 </span>            :         }</a>
<a name="4789"><span class="lineNum">    4789 </span>            : </a>
<a name="4790"><span class="lineNum">    4790 </span>            :   // Some SgSupport IR nodes have a valid parent and others are always NULL</a>
<a name="4791"><span class="lineNum">    4791 </span><span class="lineCov">   55910000 :      if (support != NULL)</span></a>
<a name="4792"><span class="lineNum">    4792 </span>            :         {</a>
<a name="4793"><span class="lineNum">    4793 </span><span class="lineCov">   43616500 :           switch (support-&gt;variantT())</span></a>
<a name="4794"><span class="lineNum">    4794 </span>            :              {</a>
<a name="4795"><span class="lineNum">    4795 </span><span class="lineCov">        330 :                case V_SgProject:</span></a>
<a name="4796"><span class="lineNum">    4796 </span><span class="lineCov">        330 :                   {</span></a>
<a name="4797"><span class="lineNum">    4797 </span><span class="lineCov">        330 :                     ROSE_ASSERT(support-&gt;get_parent() == NULL);</span></a>
<a name="4798"><span class="lineNum">    4798 </span><span class="lineCov">        330 :                     break;</span></a>
<a name="4799"><span class="lineNum">    4799 </span>            :                   }</a>
<a name="4800"><span class="lineNum">    4800 </span>            : </a>
<a name="4801"><span class="lineNum">    4801 </span>            :             // DQ (2/20/2007): Added SgTemplateArgument to the list of IR nodes that should have a valid parent set!</a>
<a name="4802"><span class="lineNum">    4802 </span>            :             // case V_SgTemplateArgument:</a>
<a name="4803"><span class="lineNum">    4803 </span><span class="lineCov">    6783700 :                case V_SgStorageModifier:</span></a>
<a name="4804"><span class="lineNum">    4804 </span>            :             // case V_SgInitializedName:</a>
<a name="4805"><span class="lineNum">    4805 </span><span class="lineCov">    6783700 :                case V_SgSymbolTable:</span></a>
<a name="4806"><span class="lineNum">    4806 </span>            :             // case V_SgFile:</a>
<a name="4807"><span class="lineNum">    4807 </span><span class="lineCov">    6783700 :                case V_SgSourceFile:</span></a>
<a name="4808"><span class="lineNum">    4808 </span><span class="lineCov">    6783700 :                case V_SgUnknownFile:</span></a>
<a name="4809"><span class="lineNum">    4809 </span><span class="lineCov">    6783700 :                case V_SgTypedefSeq:</span></a>
<a name="4810"><span class="lineNum">    4810 </span><span class="lineCov">    6783700 :                case V_SgFunctionParameterTypeList:</span></a>
<a name="4811"><span class="lineNum">    4811 </span><span class="lineCov">    6783700 :                case V_SgPragma:</span></a>
<a name="4812"><span class="lineNum">    4812 </span><span class="lineCov">    6783700 :                case V_SgBaseClass:</span></a>
<a name="4813"><span class="lineNum">    4813 </span><span class="lineCov">    6783700 :                case V_SgExpBaseClass:</span></a>
<a name="4814"><span class="lineNum">    4814 </span><span class="lineCov">    6783700 :                case V_SgNonrealBaseClass:</span></a>
<a name="4815"><span class="lineNum">    4815 </span><span class="lineCov">    6783700 :                   {</span></a>
<a name="4816"><span class="lineNum">    4816 </span><span class="lineCov">    6783700 :                     SgNode* parent = support-&gt;get_parent();</span></a>
<a name="4817"><span class="lineNum">    4817 </span><span class="lineCov">    6783700 :                     if (parent == NULL)</span></a>
<a name="4818"><span class="lineNum">    4818 </span>            :                        {</a>
<a name="4819"><span class="lineNum">    4819 </span>            : #if 0</a>
<a name="4820"><span class="lineNum">    4820 </span>            :                          printf (&quot;Case of SgSupport support = %p = %s parent = %p = %s \n&quot;,</a>
<a name="4821"><span class="lineNum">    4821 </span>            :                               support,support-&gt;class_name().c_str(),parent,(parent != NULL) ? parent-&gt;class_name().c_str() : &quot;Null&quot;);</a>
<a name="4822"><span class="lineNum">    4822 </span>            : #endif</a>
<a name="4823"><span class="lineNum">    4823 </span>            :                       // printf (&quot;Error: NULL parent found \n&quot;);</a>
<a name="4824"><span class="lineNum">    4824 </span>            :                       // ROSE_ASSERT(support-&gt;get_file_info() != NULL);</a>
<a name="4825"><span class="lineNum">    4825 </span>            :                       // support-&gt;get_file_info()-&gt;display(&quot;Error: NULL parent found&quot;);</a>
<a name="4826"><span class="lineNum">    4826 </span>            :                        }</a>
<a name="4827"><span class="lineNum">    4827 </span>            :                  // ROSE_ASSERT(support-&gt;get_parent() != NULL);</a>
<a name="4828"><span class="lineNum">    4828 </span>            :                     break;</a>
<a name="4829"><span class="lineNum">    4829 </span>            :                   }</a>
<a name="4830"><span class="lineNum">    4830 </span>            : </a>
<a name="4831"><span class="lineNum">    4831 </span><span class="lineCov">   36655000 :                case V_Sg_File_Info:</span></a>
<a name="4832"><span class="lineNum">    4832 </span><span class="lineCov">   36655000 :                   {</span></a>
<a name="4833"><span class="lineNum">    4833 </span><span class="lineCov">   36655000 :                     SgNode* parent = support-&gt;get_parent();</span></a>
<a name="4834"><span class="lineNum">    4834 </span><span class="lineCov">   36655000 :                     if (parent == NULL)</span></a>
<a name="4835"><span class="lineNum">    4835 </span>            :                        {</a>
<a name="4836"><span class="lineNum">    4836 </span>            : #if PRINT_DEVELOPER_WARNINGS</a>
<a name="4837"><span class="lineNum">    4837 </span>            :                          printf (&quot;Warning: detected Sg_File_Info without parent set properly at %p = %s parent is currently NULL \n&quot;,support,support-&gt;class_name().c_str());</a>
<a name="4838"><span class="lineNum">    4838 </span>            : #endif</a>
<a name="4839"><span class="lineNum">    4839 </span>            :                       // printf (&quot;Error: NULL parent found \n&quot;);</a>
<a name="4840"><span class="lineNum">    4840 </span>            :                       // ROSE_ASSERT(support-&gt;get_file_info() != NULL);</a>
<a name="4841"><span class="lineNum">    4841 </span>            :                       // support-&gt;get_file_info()-&gt;display(&quot;Error: NULL parent found&quot;);</a>
<a name="4842"><span class="lineNum">    4842 </span>            :                        }</a>
<a name="4843"><span class="lineNum">    4843 </span>            :                  // ROSE_ASSERT(support-&gt;get_parent() != NULL);</a>
<a name="4844"><span class="lineNum">    4844 </span>            : </a>
<a name="4845"><span class="lineNum">    4845 </span>            : #if 0</a>
<a name="4846"><span class="lineNum">    4846 </span>            :                  // DQ (1/22/2008): I have turned this on to catch Fortran statements that don't have properly set source positions.</a>
<a name="4847"><span class="lineNum">    4847 </span>            :                  // This is useful for internal testing to make sure that source position is properly set where possible.</a>
<a name="4848"><span class="lineNum">    4848 </span>            : </a>
<a name="4849"><span class="lineNum">    4849 </span>            :                  // DQ (6/11/2007): This test causes the file I/O to fail.  test2001_03.C can not be read in,</a>
<a name="4850"><span class="lineNum">    4850 </span>            :                  // but only when reading all threee files in: astFileRead test2001_01 test2001_02 test2001_03</a>
<a name="4851"><span class="lineNum">    4851 </span>            :                     Sg_File_Info* fileInfo = isSg_File_Info(support);</a>
<a name="4852"><span class="lineNum">    4852 </span>            : #if 1</a>
<a name="4853"><span class="lineNum">    4853 </span>            :                  // DQ (6/11/2007): This test causes the file I/O to fail.  test2001_03.C can not be read in,</a>
<a name="4854"><span class="lineNum">    4854 </span>            :                  // but only when reading all threee files in: astFileRead test2001_01 test2001_02 test2001_03</a>
<a name="4855"><span class="lineNum">    4855 </span>            :                  // I think this is because the static data in the Sg_File_Info can not be set properly when any two files have different values.</a>
<a name="4856"><span class="lineNum">    4856 </span>            :                     if (fileInfo-&gt;get_filenameString() == &quot;NULL_FILE&quot;)</a>
<a name="4857"><span class="lineNum">    4857 </span>            :                        {</a>
<a name="4858"><span class="lineNum">    4858 </span>            :                       // printf (&quot;Found a Sg_File_Info using filename == NULL_FILE \n&quot;);</a>
<a name="4859"><span class="lineNum">    4859 </span>            : </a>
<a name="4860"><span class="lineNum">    4860 </span>            :                          if (parent != NULL)</a>
<a name="4861"><span class="lineNum">    4861 </span>            :                             {</a>
<a name="4862"><span class="lineNum">    4862 </span>            :                            // printf (&quot;Found a Sg_File_Info using filename == NULL_FILE: parent = %p = %s = %s \n&quot;,parent,parent-&gt;class_name().c_str(),SageInterface::get_name(parent).c_str());</a>
<a name="4863"><span class="lineNum">    4863 </span>            :                            // if (isSgStatement(parent) != NULL &amp;&amp; isSgVariableDefinition(parent) == NULL)</a>
<a name="4864"><span class="lineNum">    4864 </span>            :                               if (isSgLocatedNode(parent) != NULL &amp;&amp; isSgVariableDefinition(parent) == NULL)</a>
<a name="4865"><span class="lineNum">    4865 </span>            :                                  {</a>
<a name="4866"><span class="lineNum">    4866 </span>            :                                    ROSE_ASSERT(parent-&gt;get_parent() != NULL);</a>
<a name="4867"><span class="lineNum">    4867 </span>            :                                    SgClassDeclaration* classDeclaration = isSgClassDeclaration(parent);</a>
<a name="4868"><span class="lineNum">    4868 </span>            :                                    if (classDeclaration != NULL &amp;&amp; classDeclaration != classDeclaration-&gt;get_definingDeclaration())</a>
<a name="4869"><span class="lineNum">    4869 </span>            :                                       {</a>
<a name="4870"><span class="lineNum">    4870 </span>            :                                      // Skip this case since we don't require source position information on nondefining declarations!</a>
<a name="4871"><span class="lineNum">    4871 </span>            :                                       }</a>
<a name="4872"><span class="lineNum">    4872 </span>            :                                      else</a>
<a name="4873"><span class="lineNum">    4873 </span>            :                                       {</a>
<a name="4874"><span class="lineNum">    4874 </span>            :                                         printf (&quot;Found a Sg_File_Info using filename == NULL_FILE: fileInfo = %p parent = %p = %s = %s in %p = %s = %s \n&quot;,</a>
<a name="4875"><span class="lineNum">    4875 </span>            :                                              fileInfo,parent,parent-&gt;class_name().c_str(),SageInterface::get_name(parent).c_str(),</a>
<a name="4876"><span class="lineNum">    4876 </span>            :                                              parent-&gt;get_parent(),parent-&gt;get_parent()-&gt;class_name().c_str(),SageInterface::get_name(parent-&gt;get_parent()).c_str());</a>
<a name="4877"><span class="lineNum">    4877 </span>            :                                       }</a>
<a name="4878"><span class="lineNum">    4878 </span>            :                                  }</a>
<a name="4879"><span class="lineNum">    4879 </span>            :                                 else</a>
<a name="4880"><span class="lineNum">    4880 </span>            :                                  {</a>
<a name="4881"><span class="lineNum">    4881 </span>            :                                 // printf (&quot;Found a Sg_File_Info using filename == NULL_FILE: parent = %p = %s = %s \n&quot;,parent,parent-&gt;class_name().c_str(),SageInterface::get_name(parent).c_str());</a>
<a name="4882"><span class="lineNum">    4882 </span>            :                                  }</a>
<a name="4883"><span class="lineNum">    4883 </span>            :                             }</a>
<a name="4884"><span class="lineNum">    4884 </span>            :                            else</a>
<a name="4885"><span class="lineNum">    4885 </span>            :                             {</a>
<a name="4886"><span class="lineNum">    4886 </span>            :                               printf (&quot;Found a Sg_File_Info using filename == NULL_FILE: parent == NULL \n&quot;);</a>
<a name="4887"><span class="lineNum">    4887 </span>            :                             }</a>
<a name="4888"><span class="lineNum">    4888 </span>            : </a>
<a name="4889"><span class="lineNum">    4889 </span>            :                       // ROSE_ASSERT(false);</a>
<a name="4890"><span class="lineNum">    4890 </span>            :                        }</a>
<a name="4891"><span class="lineNum">    4891 </span>            : #endif</a>
<a name="4892"><span class="lineNum">    4892 </span>            : #if 0</a>
<a name="4893"><span class="lineNum">    4893 </span>            :                  // DQ (6/11/2007): This test causes the file I/O to fail.  test2001_03.C can not be read in,</a>
<a name="4894"><span class="lineNum">    4894 </span>            :                  // but only when reading all threee files in: astFileRead test2001_01 test2001_02 test2001_03</a>
<a name="4895"><span class="lineNum">    4895 </span>            :                  // I think this is because the static data in the Sg_File_Info can not be set properly when any two files have different values.</a>
<a name="4896"><span class="lineNum">    4896 </span>            :                     if (fileInfo-&gt;get_file_id() &gt;= fileInfo-&gt;get_max_file_id())</a>
<a name="4897"><span class="lineNum">    4897 </span>            :                        {</a>
<a name="4898"><span class="lineNum">    4898 </span>            :                          printf (&quot;Found a Sg_File_Info with file_id out of range: file_id = %d max_file_id = %d \n&quot;,fileInfo-&gt;get_file_id(),fileInfo-&gt;get_max_file_id());</a>
<a name="4899"><span class="lineNum">    4899 </span>            :                          ROSE_ABORT();</a>
<a name="4900"><span class="lineNum">    4900 </span>            :                        }</a>
<a name="4901"><span class="lineNum">    4901 </span>            : #endif</a>
<a name="4902"><span class="lineNum">    4902 </span>            : #endif</a>
<a name="4903"><span class="lineNum">    4903 </span>            :                     break;</a>
<a name="4904"><span class="lineNum">    4904 </span>            :                   }</a>
<a name="4905"><span class="lineNum">    4905 </span>            : </a>
<a name="4906"><span class="lineNum">    4906 </span>            :             // DQ (6/11/2007): Added this case</a>
<a name="4907"><span class="lineNum">    4907 </span><span class="lineNoCov">          0 :                case V_SgInitializedName:</span></a>
<a name="4908"><span class="lineNum">    4908 </span><span class="lineNoCov">          0 :                   {</span></a>
<a name="4909"><span class="lineNum">    4909 </span><span class="lineNoCov">          0 :                     SgNode* parent = support-&gt;get_parent();</span></a>
<a name="4910"><span class="lineNum">    4910 </span><span class="lineNoCov">          0 :                     if (parent == NULL)</span></a>
<a name="4911"><span class="lineNum">    4911 </span>            :                        {</a>
<a name="4912"><span class="lineNum">    4912 </span>            : #if 1</a>
<a name="4913"><span class="lineNum">    4913 </span><span class="lineNoCov">          0 :                          printf (&quot;Warning: detected SgInitializedName without parent set properly at %p = %s parent is currently NULL \n&quot;,support,support-&gt;class_name().c_str());</span></a>
<a name="4914"><span class="lineNum">    4914 </span>            : #endif</a>
<a name="4915"><span class="lineNum">    4915 </span>            :                       // printf (&quot;Error: NULL parent found \n&quot;);</a>
<a name="4916"><span class="lineNum">    4916 </span>            :                       // ROSE_ASSERT(support-&gt;get_file_info() != NULL);</a>
<a name="4917"><span class="lineNum">    4917 </span>            :                       // support-&gt;get_file_info()-&gt;display(&quot;Error: NULL parent found&quot;);</a>
<a name="4918"><span class="lineNum">    4918 </span>            :                        }</a>
<a name="4919"><span class="lineNum">    4919 </span>            :                  // ROSE_ASSERT(support-&gt;get_parent() != NULL);</a>
<a name="4920"><span class="lineNum">    4920 </span>            :                     break;</a>
<a name="4921"><span class="lineNum">    4921 </span>            :                   }</a>
<a name="4922"><span class="lineNum">    4922 </span>            : </a>
<a name="4923"><span class="lineNum">    4923 </span>            :             // DQ (6/11/2007): Added this case</a>
<a name="4924"><span class="lineNum">    4924 </span><span class="lineCov">      44871 :                case V_SgTemplateArgument:</span></a>
<a name="4925"><span class="lineNum">    4925 </span><span class="lineCov">      44871 :                   {</span></a>
<a name="4926"><span class="lineNum">    4926 </span><span class="lineCov">      44871 :                     SgNode* parent = support-&gt;get_parent();</span></a>
<a name="4927"><span class="lineNum">    4927 </span><span class="lineCov">      44871 :                     if (parent == NULL)</span></a>
<a name="4928"><span class="lineNum">    4928 </span>            :                        {</a>
<a name="4929"><span class="lineNum">    4929 </span>            : #if 1</a>
<a name="4930"><span class="lineNum">    4930 </span><span class="lineNoCov">          0 :                          printf (&quot;Warning: detected SgTemplateArgument without parent set properly at %p = %s parent is currently NULL \n&quot;,support,support-&gt;class_name().c_str());</span></a>
<a name="4931"><span class="lineNum">    4931 </span>            : #endif</a>
<a name="4932"><span class="lineNum">    4932 </span>            :                       // printf (&quot;Error: NULL parent found \n&quot;);</a>
<a name="4933"><span class="lineNum">    4933 </span>            :                       // ROSE_ASSERT(support-&gt;get_file_info() != NULL);</a>
<a name="4934"><span class="lineNum">    4934 </span>            :                       // support-&gt;get_file_info()-&gt;display(&quot;Error: NULL parent found&quot;);</a>
<a name="4935"><span class="lineNum">    4935 </span>            :                        }</a>
<a name="4936"><span class="lineNum">    4936 </span>            :                  // ROSE_ASSERT(support-&gt;get_parent() != NULL);</a>
<a name="4937"><span class="lineNum">    4937 </span>            :                     break;</a>
<a name="4938"><span class="lineNum">    4938 </span>            :                   }</a>
<a name="4939"><span class="lineNum">    4939 </span>            : </a>
<a name="4940"><span class="lineNum">    4940 </span>            :             // DQ (11/21/2011): Added support for template declarations in the AST.</a>
<a name="4941"><span class="lineNum">    4941 </span><span class="lineCov">      14729 :                case V_SgTemplateParameter:</span></a>
<a name="4942"><span class="lineNum">    4942 </span><span class="lineCov">      14729 :                   {</span></a>
<a name="4943"><span class="lineNum">    4943 </span><span class="lineCov">      14729 :                     SgNode* parent = support-&gt;get_parent();</span></a>
<a name="4944"><span class="lineNum">    4944 </span><span class="lineCov">      14729 :                     if (parent == NULL)</span></a>
<a name="4945"><span class="lineNum">    4945 </span>            :                        {</a>
<a name="4946"><span class="lineNum">    4946 </span>            : // DQ (5/25/2013): Commented out for now, too much output spew.</a>
<a name="4947"><span class="lineNum">    4947 </span>            : // #ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION</a>
<a name="4948"><span class="lineNum">    4948 </span>            : #if 0</a>
<a name="4949"><span class="lineNum">    4949 </span>            :                          printf (&quot;Warning: detected SgTemplateParameter without parent set properly at %p = %s parent is currently NULL \n&quot;,support,support-&gt;class_name().c_str());</a>
<a name="4950"><span class="lineNum">    4950 </span>            : #endif</a>
<a name="4951"><span class="lineNum">    4951 </span>            :                        }</a>
<a name="4952"><span class="lineNum">    4952 </span>            :                     break;</a>
<a name="4953"><span class="lineNum">    4953 </span>            :                   }</a>
<a name="4954"><span class="lineNum">    4954 </span>            : </a>
<a name="4955"><span class="lineNum">    4955 </span>            : </a>
<a name="4956"><span class="lineNum">    4956 </span>            :             // DQ (6/11/2007): Added this case</a>
<a name="4957"><span class="lineNum">    4957 </span><span class="lineNoCov">          0 :                case V_SgCommonBlockObject:</span></a>
<a name="4958"><span class="lineNum">    4958 </span><span class="lineNoCov">          0 :                   {</span></a>
<a name="4959"><span class="lineNum">    4959 </span><span class="lineNoCov">          0 :                     SgNode* parent = support-&gt;get_parent();</span></a>
<a name="4960"><span class="lineNum">    4960 </span><span class="lineNoCov">          0 :                     if (parent == NULL)</span></a>
<a name="4961"><span class="lineNum">    4961 </span>            :                        {</a>
<a name="4962"><span class="lineNum">    4962 </span>            : #if 1</a>
<a name="4963"><span class="lineNum">    4963 </span><span class="lineNoCov">          0 :                          printf (&quot;Warning: detected SgCommonBlockObject without parent set properly at %p = %s parent is currently NULL \n&quot;,support,support-&gt;class_name().c_str());</span></a>
<a name="4964"><span class="lineNum">    4964 </span>            : #endif</a>
<a name="4965"><span class="lineNum">    4965 </span>            :                        }</a>
<a name="4966"><span class="lineNum">    4966 </span>            :                     break;</a>
<a name="4967"><span class="lineNum">    4967 </span>            :                   }</a>
<a name="4968"><span class="lineNum">    4968 </span>            : </a>
<a name="4969"><span class="lineNum">    4969 </span>            :             // DQ (1/23/2010): Added this case</a>
<a name="4970"><span class="lineNum">    4970 </span><span class="lineCov">        660 :                case V_SgFileList:</span></a>
<a name="4971"><span class="lineNum">    4971 </span><span class="lineCov">        660 :                case V_SgDirectoryList:</span></a>
<a name="4972"><span class="lineNum">    4972 </span>            : </a>
<a name="4973"><span class="lineNum">    4973 </span>            :             // DQ (10/4/2008): Added this case</a>
<a name="4974"><span class="lineNum">    4974 </span><span class="lineCov">        660 :                case V_SgRenamePair:</span></a>
<a name="4975"><span class="lineNum">    4975 </span>            : </a>
<a name="4976"><span class="lineNum">    4976 </span>            :             // DQ (12/23/2007): Added this case</a>
<a name="4977"><span class="lineNum">    4977 </span><span class="lineCov">        660 :                case V_SgFormatItem:</span></a>
<a name="4978"><span class="lineNum">    4978 </span><span class="lineCov">        660 :                case V_SgFormatItemList:</span></a>
<a name="4979"><span class="lineNum">    4979 </span><span class="lineCov">        660 :                   {</span></a>
<a name="4980"><span class="lineNum">    4980 </span><span class="lineCov">        660 :                     SgNode* parent = support-&gt;get_parent();</span></a>
<a name="4981"><span class="lineNum">    4981 </span><span class="lineCov">        660 :                     if (parent == NULL)</span></a>
<a name="4982"><span class="lineNum">    4982 </span>            :                        {</a>
<a name="4983"><span class="lineNum">    4983 </span>            : #if 1</a>
<a name="4984"><span class="lineNum">    4984 </span><span class="lineNoCov">          0 :                          printf (&quot;Warning: detected SgSupport IR node without parent set properly at %p = %s parent is currently NULL \n&quot;,support,support-&gt;class_name().c_str());</span></a>
<a name="4985"><span class="lineNum">    4985 </span>            : #endif</a>
<a name="4986"><span class="lineNum">    4986 </span>            :                        }</a>
<a name="4987"><span class="lineNum">    4987 </span>            :                     break;</a>
<a name="4988"><span class="lineNum">    4988 </span>            :                   }</a>
<a name="4989"><span class="lineNum">    4989 </span>            : </a>
<a name="4990"><span class="lineNum">    4990 </span>            :             // DQ (7/23/2010): Added this case</a>
<a name="4991"><span class="lineNum">    4991 </span><span class="lineCov">     100470 :                case V_SgTypeTable:</span></a>
<a name="4992"><span class="lineNum">    4992 </span><span class="lineCov">     100470 :                   {</span></a>
<a name="4993"><span class="lineNum">    4993 </span>            :                  // The parent is not always set here except for when it is in the SgScopeStatement.</a>
<a name="4994"><span class="lineNum">    4994 </span><span class="lineCov">     100470 :                     SgNode* parent = support-&gt;get_parent();</span></a>
<a name="4995"><span class="lineNum">    4995 </span><span class="lineCov">     100470 :                     if (parent != NULL)</span></a>
<a name="4996"><span class="lineNum">    4996 </span>            :                        {</a>
<a name="4997"><span class="lineNum">    4997 </span>            :                       // DQ (7/30/2010): Commented out this test that fails in tests/nonsmoke/functional/CompilerOptionsTests/testCpreprocessorOption</a>
<a name="4998"><span class="lineNum">    4998 </span>            :                       // ROSE_ASSERT( isSgScopeStatement(parent) != NULL || isSgProject(parent) != NULL);</a>
<a name="4999"><span class="lineNum">    4999 </span><span class="lineCov">     100470 :                          if ( !(isSgScopeStatement(parent) != NULL || isSgProject(parent) != NULL) )</span></a>
<a name="5000"><span class="lineNum">    5000 </span>            :                             {</a>
<a name="5001"><span class="lineNum">    5001 </span>            :                            // printf (&quot;In AST Consistancy tests: Warning: !(isSgScopeStatement(parent) != NULL || isSgProject(parent) != NULL) \n&quot;);</a>
<a name="5002"><span class="lineNum">    5002 </span>            :                             }</a>
<a name="5003"><span class="lineNum">    5003 </span>            :                        }</a>
<a name="5004"><span class="lineNum">    5004 </span>            :                     break;</a>
<a name="5005"><span class="lineNum">    5005 </span>            :                   }</a>
<a name="5006"><span class="lineNum">    5006 </span>            : </a>
<a name="5007"><span class="lineNum">    5007 </span>            :                // driscoll6 (01/03/2011): Added this case.</a>
<a name="5008"><span class="lineNum">    5008 </span><span class="lineNoCov">          0 :                case V_SgGraphEdge:</span></a>
<a name="5009"><span class="lineNum">    5009 </span><span class="lineNoCov">          0 :                case V_SgDirectedGraphEdge:</span></a>
<a name="5010"><span class="lineNum">    5010 </span><span class="lineNoCov">          0 :                case V_SgUndirectedGraphEdge:</span></a>
<a name="5011"><span class="lineNum">    5011 </span><span class="lineNoCov">          0 :                case V_SgGraphNode:</span></a>
<a name="5012"><span class="lineNum">    5012 </span><span class="lineNoCov">          0 :                   {</span></a>
<a name="5013"><span class="lineNum">    5013 </span><span class="lineNoCov">          0 :                       if (! isSgGraph(support-&gt;get_parent()) ) {</span></a>
<a name="5014"><span class="lineNum">    5014 </span><span class="lineNoCov">          0 :                           std::cerr &lt;&lt; &quot;Graph component &quot; &lt;&lt; support-&gt;class_name() &lt;&lt; &quot; requires SgGraph as parent&quot; &lt;&lt; std::endl;</span></a>
<a name="5015"><span class="lineNum">    5015 </span><span class="lineNoCov">          0 :                           ROSE_ABORT();</span></a>
<a name="5016"><span class="lineNum">    5016 </span>            :                       }</a>
<a name="5017"><span class="lineNum">    5017 </span>            :                       break;</a>
<a name="5018"><span class="lineNum">    5018 </span>            :                   }</a>
<a name="5019"><span class="lineNum">    5019 </span>            : </a>
<a name="5020"><span class="lineNum">    5020 </span>            :             // DQ (6/3/2019): Added support for SgIncludeFile (parent is a SgIncludeDirectiveStatement).</a>
<a name="5021"><span class="lineNum">    5021 </span>            :             // case V_SgIncludeDirectiveStatement:</a>
<a name="5022"><span class="lineNum">    5022 </span>            :                case V_SgIncludeFile:</a>
<a name="5023"><span class="lineNum">    5023 </span>            :                   {</a>
<a name="5024"><span class="lineNum">    5024 </span>            :                  // DQ (10/22/2019): Note that there is no parent pointer defined for this IR node, so no warning message really make sense, I think.</a>
<a name="5025"><span class="lineNum">    5025 </span>            : #if 0</a>
<a name="5026"><span class="lineNum">    5026 </span>            :                     printf (&quot;NOTE: In AST Consistancy tests: TestParentPointersInMemoryPool::visit(): case SgIncludeFile: parent == NULL \n&quot;);</a>
<a name="5027"><span class="lineNum">    5027 </span>            : #endif</a>
<a name="5028"><span class="lineNum">    5028 </span>            :                  // ROSE_ASSERT(support-&gt;get_parent() != NULL);</a>
<a name="5029"><span class="lineNum">    5029 </span>            :                     break;</a>
<a name="5030"><span class="lineNum">    5030 </span>            :                   }</a>
<a name="5031"><span class="lineNum">    5031 </span>            : </a>
<a name="5032"><span class="lineNum">    5032 </span><span class="lineCov">       4112 :                default:</span></a>
<a name="5033"><span class="lineNum">    5033 </span><span class="lineCov">       4112 :                   {</span></a>
<a name="5034"><span class="lineNum">    5034 </span><span class="lineCov">       4112 :                     if (support-&gt;get_parent() != NULL)</span></a>
<a name="5035"><span class="lineNum">    5035 </span>            :                        {</a>
<a name="5036"><span class="lineNum">    5036 </span><span class="lineNoCov">          0 :                          printf (&quot;##### TestParentPointersInMemoryPool::visit(node = %p = %s), support-&gt;get_parent() != NULL == %s\n&quot;,node,node-&gt;sage_class_name(),support-&gt;get_parent()-&gt;sage_class_name());</span></a>
<a name="5037"><span class="lineNum">    5037 </span>            :                        }</a>
<a name="5038"><span class="lineNum">    5038 </span><span class="lineCov">       4112 :                     ROSE_ASSERT(support-&gt;get_parent() == NULL);</span></a>
<a name="5039"><span class="lineNum">    5039 </span><span class="lineCov">       4112 :                     break;</span></a>
<a name="5040"><span class="lineNum">    5040 </span>            :                   }</a>
<a name="5041"><span class="lineNum">    5041 </span>            :              }</a>
<a name="5042"><span class="lineNum">    5042 </span>            :         }</a>
<a name="5043"><span class="lineNum">    5043 </span><span class="lineCov">   55910000 :    }</span></a>
<a name="5044"><span class="lineNum">    5044 </span>            : </a>
<a name="5045"><span class="lineNum">    5045 </span>            : </a>
<a name="5046"><span class="lineNum">    5046 </span>            : // DQ (9/13/2006): Implemented by Ghassan to verify that for</a>
<a name="5047"><span class="lineNum">    5047 </span>            : // each node, it appears in its parent's list of children.</a>
<a name="5048"><span class="lineNum">    5048 </span>            : void</a>
<a name="5049"><span class="lineNum">    5049 </span><span class="lineCov">        326 : TestChildPointersInMemoryPool::test()</span></a>
<a name="5050"><span class="lineNum">    5050 </span>            :    {</a>
<a name="5051"><span class="lineNum">    5051 </span><span class="lineCov">        652 :      TestChildPointersInMemoryPool t;</span></a>
<a name="5052"><span class="lineNum">    5052 </span><span class="lineCov">        326 :      t.traverseMemoryPool();</span></a>
<a name="5053"><span class="lineNum">    5053 </span><span class="lineCov">        326 :    }</span></a>
<a name="5054"><span class="lineNum">    5054 </span>            : </a>
<a name="5055"><span class="lineNum">    5055 </span><span class="lineCov">        356 : void TestChildPointersInMemoryPool::initDiagnostics()</span></a>
<a name="5056"><span class="lineNum">    5056 </span>            :    {</a>
<a name="5057"><span class="lineNum">    5057 </span><span class="lineCov">        356 :      static bool initialized = false;</span></a>
<a name="5058"><span class="lineNum">    5058 </span><span class="lineCov">        356 :      if (!initialized)</span></a>
<a name="5059"><span class="lineNum">    5059 </span>            :         {</a>
<a name="5060"><span class="lineNum">    5060 </span><span class="lineCov">        356 :           initialized = true;</span></a>
<a name="5061"><span class="lineNum">    5061 </span><span class="lineCov">        356 :           Rose::Diagnostics::initAndRegister(&amp;mlog, &quot;Rose::TestChildPointersInMemoryPool&quot;);</span></a>
<a name="5062"><span class="lineNum">    5062 </span><span class="lineCov">        712 :           mlog.comment(&quot;testing AST child pointers in memory pools&quot;);</span></a>
<a name="5063"><span class="lineNum">    5063 </span>            :         }</a>
<a name="5064"><span class="lineNum">    5064 </span><span class="lineCov">        356 :    }</span></a>
<a name="5065"><span class="lineNum">    5065 </span>            : </a>
<a name="5066"><span class="lineNum">    5066 </span>            : </a>
<a name="5067"><span class="lineNum">    5067 </span>            : // DQ (9/13/2006): Implemented by Ghassan to verify that for</a>
<a name="5068"><span class="lineNum">    5068 </span>            : // each node, it appears in its parent's list of children.</a>
<a name="5069"><span class="lineNum">    5069 </span>            : // This is a test requested by Jeremiah.</a>
<a name="5070"><span class="lineNum">    5070 </span>            : void</a>
<a name="5071"><span class="lineNum">    5071 </span><span class="lineCov">   55910000 : TestChildPointersInMemoryPool::visit( SgNode *node )</span></a>
<a name="5072"><span class="lineNum">    5072 </span>            :    {</a>
<a name="5073"><span class="lineNum">    5073 </span><span class="lineCov">   55910000 :      static std::map&lt;SgNode*,std::set&lt;SgNode*&gt; &gt; childMap;</span></a>
<a name="5074"><span class="lineNum">    5074 </span>            : </a>
<a name="5075"><span class="lineNum">    5075 </span><span class="lineCov">   55910000 :      ROSE_ASSERT(node != NULL);</span></a>
<a name="5076"><span class="lineNum">    5076 </span>            : </a>
<a name="5077"><span class="lineNum">    5077 </span><span class="lineCov">   55910000 :      if (node-&gt;get_freepointer() != AST_FileIO::IS_VALID_POINTER() )</span></a>
<a name="5078"><span class="lineNum">    5078 </span>            :      {</a>
<a name="5079"><span class="lineNum">    5079 </span><span class="lineNoCov">          0 :           printf (&quot;Error: In TestChildPointersInMemoryPool::visit() for node = %s at %p \n&quot;,node-&gt;class_name().c_str(),node);</span></a>
<a name="5080"><span class="lineNum">    5080 </span><span class="lineNoCov">          0 :                   ROSE_ABORT();</span></a>
<a name="5081"><span class="lineNum">    5081 </span>            :      }</a>
<a name="5082"><span class="lineNum">    5082 </span>            : </a>
<a name="5083"><span class="lineNum">    5083 </span><span class="lineCov">   55910000 :      SgNode *parent = node-&gt;get_parent();</span></a>
<a name="5084"><span class="lineNum">    5084 </span>            : </a>
<a name="5085"><span class="lineNum">    5085 </span>            : #if ROSE_USE_VALGRIND</a>
<a name="5086"><span class="lineNum">    5086 </span>            :      VALGRIND_CHECK_DEFINED(parent);</a>
<a name="5087"><span class="lineNum">    5087 </span>            : #endif</a>
<a name="5088"><span class="lineNum">    5088 </span>            : </a>
<a name="5089"><span class="lineNum">    5089 </span><span class="lineCov">   55910000 :      if (parent != NULL)</span></a>
<a name="5090"><span class="lineNum">    5090 </span>            :         {</a>
<a name="5091"><span class="lineNum">    5091 </span><span class="lineCov">   38786600 :           bool nodeFound = false;</span></a>
<a name="5092"><span class="lineNum">    5092 </span>            : </a>
<a name="5093"><span class="lineNum">    5093 </span>            :        // DQ (3/12/2007): This is the latest implementation, here we look for the child set</a>
<a name="5094"><span class="lineNum">    5094 </span>            :        // in a statically defined childMap. This should be a more efficient implementation.</a>
<a name="5095"><span class="lineNum">    5095 </span>            :        // Since it uses a static map it is a problem when the function is called twice.</a>
<a name="5096"><span class="lineNum">    5096 </span><span class="lineCov">   38786600 :           std::map&lt;SgNode*,std::set&lt;SgNode*&gt; &gt;::iterator it = childMap.find(parent);</span></a>
<a name="5097"><span class="lineNum">    5097 </span>            : </a>
<a name="5098"><span class="lineNum">    5098 </span><span class="lineCov">   38786600 :           if (it != childMap.end())</span></a>
<a name="5099"><span class="lineNum">    5099 </span>            :              {</a>
<a name="5100"><span class="lineNum">    5100 </span>            :             // Reuse the set that was built the first time</a>
<a name="5101"><span class="lineNum">    5101 </span><span class="lineCov">   57268000 :                nodeFound = it-&gt;second.find(node) != it-&gt;second.end();</span></a>
<a name="5102"><span class="lineNum">    5102 </span>            : </a>
<a name="5103"><span class="lineNum">    5103 </span>            :             // DQ (7/1/2008): When this function is called a second time, (typically as part</a>
<a name="5104"><span class="lineNum">    5104 </span>            :             // of calling AstTests::runAllTests (SgProject*); with a modified AST,</a>
<a name="5105"><span class="lineNum">    5105 </span>            :             // the childMap has already been set and any new declaration that was added and</a>
<a name="5106"><span class="lineNum">    5106 </span>            :             // which generated a symbol is not in the previously defined static childMap.</a>
<a name="5107"><span class="lineNum">    5107 </span>            :             // So the test above fails and we need to use the more expensive dynamic test.</a>
<a name="5108"><span class="lineNum">    5108 </span>            :                // George Vulov (4/22/2011): Restrict this test to only memory pool entries that are valid</a>
<a name="5109"><span class="lineNum">    5109 </span><span class="lineCov">   28634000 :                if (nodeFound == false &amp;&amp; parent-&gt;get_freepointer() == AST_FileIO::IS_VALID_POINTER())</span></a>
<a name="5110"><span class="lineNum">    5110 </span><span class="lineCov">     147833 :                     nodeFound = parent-&gt;isChild(node);</span></a>
<a name="5111"><span class="lineNum">    5111 </span>            :              }</a>
<a name="5112"><span class="lineNum">    5112 </span>            :             else</a>
<a name="5113"><span class="lineNum">    5113 </span>            :              {</a>
<a name="5114"><span class="lineNum">    5114 </span>            :             // DQ (6/6/2010): Restrict this test to only memory pool entries that are valid</a>
<a name="5115"><span class="lineNum">    5115 </span><span class="lineCov">   10152600 :                if (parent-&gt;get_freepointer() == AST_FileIO::IS_VALID_POINTER() )</span></a>
<a name="5116"><span class="lineNum">    5116 </span>            :                {</a>
<a name="5117"><span class="lineNum">    5117 </span>            :                 // build the set (and do the test)</a>
<a name="5118"><span class="lineNum">    5118 </span><span class="lineCov">   10152600 :                    childMap[parent] = std::set&lt;SgNode*&gt;();</span></a>
<a name="5119"><span class="lineNum">    5119 </span><span class="lineCov">   10152600 :                    it = childMap.find(parent);</span></a>
<a name="5120"><span class="lineNum">    5120 </span><span class="lineCov">   10152600 :                    ROSE_ASSERT (it != childMap.end());</span></a>
<a name="5121"><span class="lineNum">    5121 </span>            : </a>
<a name="5122"><span class="lineNum">    5122 </span>            :                 // Later we can make this more efficient by building a set directly</a>
<a name="5123"><span class="lineNum">    5123 </span>            :                 // This style is quite inefficient since we are not making use of</a>
<a name="5124"><span class="lineNum">    5124 </span>            :                 // the string type date in the pair&lt;SgNode*,string&gt;</a>
<a name="5125"><span class="lineNum">    5125 </span>            : #if ROSE_USE_VALGRIND</a>
<a name="5126"><span class="lineNum">    5126 </span>            :                    if (VALGRIND_CHECK_WRITABLE(parent, sizeof(SgNode))) {</a>
<a name="5127"><span class="lineNum">    5127 </span>            :                      fprintf(stderr, &quot;Parent %p of child %p (a %s) has been deleted.\n&quot;, parent, node, node-&gt;class_name().c_str());</a>
<a name="5128"><span class="lineNum">    5128 </span>            :                    }</a>
<a name="5129"><span class="lineNum">    5129 </span>            : #endif</a>
<a name="5130"><span class="lineNum">    5130 </span>            : </a>
<a name="5131"><span class="lineNum">    5131 </span>            : #if 0</a>
<a name="5132"><span class="lineNum">    5132 </span>            :                  // DQ (6/5/2010): Turn this on to support debugging of the AST File I/O support for reading files (tests/nonsmoke/functional/testAstFileRead.C).</a>
<a name="5133"><span class="lineNum">    5133 </span>            : </a>
<a name="5134"><span class="lineNum">    5134 </span>            :                    /* DEBUGGING (RPM 2008-10-10)</a>
<a name="5135"><span class="lineNum">    5135 </span>            :                     * If the call to parent-&gt;returnDataMemberPointers() fails it could be due to the fact that the parent has been</a>
<a name="5136"><span class="lineNum">    5136 </span>            :                     * deleted without deleting its children. This can happen if the parent's definition in one of the *.C files</a>
<a name="5137"><span class="lineNum">    5137 </span>            :                     * in src/ROSETTA/src (such as binaryInstruction.C) has a call to setAutomaticGenerationOfDestructor with false</a>
<a name="5138"><span class="lineNum">    5138 </span>            :                     * to turn off the ROSETTA-generated destructor and the explicitly coded destructor does not destroy child</a>
<a name="5139"><span class="lineNum">    5139 </span>            :                     * nodes. */</a>
<a name="5140"><span class="lineNum">    5140 </span>            :                    printf (&quot;DEBUG: node: %p = %s = %s parent: %p = %s \n&quot;,</a>
<a name="5141"><span class="lineNum">    5141 </span>            :                            node, node-&gt;class_name().c_str(), SageInterface::get_name(node).c_str(),</a>
<a name="5142"><span class="lineNum">    5142 </span>            :                            parent, parent-&gt;class_name().c_str());</a>
<a name="5143"><span class="lineNum">    5143 </span>            : #endif</a>
<a name="5144"><span class="lineNum">    5144 </span>            : </a>
<a name="5145"><span class="lineNum">    5145 </span><span class="lineCov">   20305300 :                    vector&lt;pair&lt;SgNode*,string&gt; &gt; v = parent-&gt;returnDataMemberPointers();</span></a>
<a name="5146"><span class="lineNum">    5146 </span>            : </a>
<a name="5147"><span class="lineNum">    5147 </span><span class="lineCov">  122775000 :                    for (unsigned long i = 0; i &lt; v.size(); i++)</span></a>
<a name="5148"><span class="lineNum">    5148 </span>            :                       {</a>
<a name="5149"><span class="lineNum">    5149 </span>            :                      // Add the child to the set in the map</a>
<a name="5150"><span class="lineNum">    5150 </span><span class="lineCov">  112623000 :                         it-&gt;second.insert(v[i].first);</span></a>
<a name="5151"><span class="lineNum">    5151 </span>            : </a>
<a name="5152"><span class="lineNum">    5152 </span>            :                      // DQ (10/2/2010): Debugging SgType :: type_kind  data member.</a>
<a name="5153"><span class="lineNum">    5153 </span><span class="lineCov">  112623000 :                         ROSE_ASSERT(node != NULL);</span></a>
<a name="5154"><span class="lineNum">    5154 </span>            :                      // ROSE_ASSERT(v[i].first != NULL);</a>
<a name="5155"><span class="lineNum">    5155 </span>            : </a>
<a name="5156"><span class="lineNum">    5156 </span><span class="lineCov">  112623000 :                         if (v[i].first == node)</span></a>
<a name="5157"><span class="lineNum">    5157 </span>            :                              {</a>
<a name="5158"><span class="lineNum">    5158 </span><span class="lineCov">   10152100 :                                nodeFound = true;</span></a>
<a name="5159"><span class="lineNum">    5159 </span>            :                              }</a>
<a name="5160"><span class="lineNum">    5160 </span>            :                       }</a>
<a name="5161"><span class="lineNum">    5161 </span>            :                   }</a>
<a name="5162"><span class="lineNum">    5162 </span>            :              }</a>
<a name="5163"><span class="lineNum">    5163 </span>            : </a>
<a name="5164"><span class="lineNum">    5164 </span>            :        // DQ (3/3/2007): Note that some IR nodes are not to be found in the parent list (e.g. &quot;typedef struct {} X;&quot;)</a>
<a name="5165"><span class="lineNum">    5165 </span>            :        // The special cases are listed explicitly below.  Anything else will at some point be an error.</a>
<a name="5166"><span class="lineNum">    5166 </span>            : </a>
<a name="5167"><span class="lineNum">    5167 </span>            :        // These are errors that we want to always report.</a>
<a name="5168"><span class="lineNum">    5168 </span>            :        // if ( nodeFound == false &amp;&amp; SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL )</a>
<a name="5169"><span class="lineNum">    5169 </span><span class="lineCov">   38786600 :           if ( nodeFound == false )</span></a>
<a name="5170"><span class="lineNum">    5170 </span>            :              {</a>
<a name="5171"><span class="lineNum">    5171 </span>            : </a>
<a name="5172"><span class="lineNum">    5172 </span><span class="lineCov">     148245 :                switch(node-&gt;variantT())</span></a>
<a name="5173"><span class="lineNum">    5173 </span>            :                   {</a>
<a name="5174"><span class="lineNum">    5174 </span>            :                     case V_SgTemplateInstantiationDecl:</a>
<a name="5175"><span class="lineNum">    5175 </span>            :                     case V_SgClassDeclaration:</a>
<a name="5176"><span class="lineNum">    5176 </span>            :                     case V_SgDerivedTypeStatement:</a>
<a name="5177"><span class="lineNum">    5177 </span>            :                        {</a>
<a name="5178"><span class="lineNum">    5178 </span>            :                       // Ignore this case, there a lots of cases where non-defining declarations</a>
<a name="5179"><span class="lineNum">    5179 </span>            :                       // are built and they are assigned parents where they are not children.</a>
<a name="5180"><span class="lineNum">    5180 </span>            :                          break;</a>
<a name="5181"><span class="lineNum">    5181 </span>            :                        }</a>
<a name="5182"><span class="lineNum">    5182 </span>            : </a>
<a name="5183"><span class="lineNum">    5183 </span>            :                     case V_SgTemplateDeclaration:</a>
<a name="5184"><span class="lineNum">    5184 </span>            :                        {</a>
<a name="5185"><span class="lineNum">    5185 </span>            :                       // Ignore this case, at least numerous non-defining declarations will fail to appear in the parent' child list.</a>
<a name="5186"><span class="lineNum">    5186 </span>            :                          break;</a>
<a name="5187"><span class="lineNum">    5187 </span>            :                        }</a>
<a name="5188"><span class="lineNum">    5188 </span>            : </a>
<a name="5189"><span class="lineNum">    5189 </span>            :                  // DQ (7/23/2010): Added case of SgTypeTable</a>
<a name="5190"><span class="lineNum">    5190 </span>            :                  // case V_SgTypeTable:</a>
<a name="5191"><span class="lineNum">    5191 </span>            :                     case V_SgFunctionTypeTable:</a>
<a name="5192"><span class="lineNum">    5192 </span>            :                        {</a>
<a name="5193"><span class="lineNum">    5193 </span>            :                       // Ignore this case, the pointer to the SgFunctionTypeTable is a static data member</a>
<a name="5194"><span class="lineNum">    5194 </span>            :                       // and not returned by the returnDataMemberPointers() function on the parent (SgNode).</a>
<a name="5195"><span class="lineNum">    5195 </span>            :                          break;</a>
<a name="5196"><span class="lineNum">    5196 </span>            :                        }</a>
<a name="5197"><span class="lineNum">    5197 </span>            : </a>
<a name="5198"><span class="lineNum">    5198 </span><span class="lineCov">        300 :                     case V_SgTypedefDeclaration:</span></a>
<a name="5199"><span class="lineNum">    5199 </span><span class="lineCov">        300 :                        {</span></a>
<a name="5200"><span class="lineNum">    5200 </span><span class="lineCov">        300 :                          SgTypedefDeclaration* typedefDeclaration = isSgTypedefDeclaration(node);</span></a>
<a name="5201"><span class="lineNum">    5201 </span>            : </a>
<a name="5202"><span class="lineNum">    5202 </span>            :                       // By forcing the evaluation of isCompilerGenerated() we improve the performance by using short-circuit evaluation</a>
<a name="5203"><span class="lineNum">    5203 </span><span class="lineCov">        300 :                          if ((typedefDeclaration-&gt;get_file_info()-&gt;isCompilerGenerated() == true) &amp;&amp; (typedefDeclaration-&gt;get_name() == &quot;__builtin_va_list&quot;) )</span></a>
<a name="5204"><span class="lineNum">    5204 </span>            :                             {</a>
<a name="5205"><span class="lineNum">    5205 </span>            :                            // This is the special case of __builtin_va_list used as a typedef (it is compiler generated and will not appear in the parent's child list).</a>
<a name="5206"><span class="lineNum">    5206 </span>            :                             }</a>
<a name="5207"><span class="lineNum">    5207 </span>            :                            else</a>
<a name="5208"><span class="lineNum">    5208 </span>            :                             {</a>
<a name="5209"><span class="lineNum">    5209 </span><span class="lineCov">        300 :                               ROSE_ASSERT(typedefDeclaration-&gt;get_parent() != NULL);</span></a>
<a name="5210"><span class="lineNum">    5210 </span><span class="lineCov">        300 :                               SgTemplateArgument* templateArgument = isSgTemplateArgument(typedefDeclaration-&gt;get_parent());</span></a>
<a name="5211"><span class="lineNum">    5211 </span><span class="lineCov">        300 :                               if (templateArgument != NULL)</span></a>
<a name="5212"><span class="lineNum">    5212 </span>            :                                  {</a>
<a name="5213"><span class="lineNum">    5213 </span>            :                                 // DQ (3/6/2007): SgTypedefDeclaration can sometimes be built as part of template argument processing,</a>
<a name="5214"><span class="lineNum">    5214 </span>            :                                 // when this is done the SgTypedefDeclaration is not in the child list of any scope, it has a scope</a>
<a name="5215"><span class="lineNum">    5215 </span>            :                                 // of the template for which it is an argument and a parent which is assigned to the associated</a>
<a name="5216"><span class="lineNum">    5216 </span>            :                                 // SgTemplateArgument.  To get access to the declaration from the SgTemplateArgument one must go</a>
<a name="5217"><span class="lineNum">    5217 </span>            :                                 // through the associated typedefType.  The following is a test that should pass when this happens.</a>
<a name="5218"><span class="lineNum">    5218 </span><span class="lineNoCov">          0 :                                    SgTypedefType* typedefType = isSgTypedefType(templateArgument-&gt;get_type());</span></a>
<a name="5219"><span class="lineNum">    5219 </span><span class="lineNoCov">          0 :                                    ROSE_ASSERT(typedefType != NULL);</span></a>
<a name="5220"><span class="lineNum">    5220 </span><span class="lineNoCov">          0 :                                    ROSE_ASSERT(typedefType-&gt;get_declaration() == typedefDeclaration);</span></a>
<a name="5221"><span class="lineNum">    5221 </span>            :                                 // printf (&quot;Found the typedefDeclaration in the declaration of its parent's SgTypedefType in its SgTemplateArgument \n&quot;);</a>
<a name="5222"><span class="lineNum">    5222 </span>            :                                  }</a>
<a name="5223"><span class="lineNum">    5223 </span>            :                                 else</a>
<a name="5224"><span class="lineNum">    5224 </span>            :                                  {</a>
<a name="5225"><span class="lineNum">    5225 </span>            : #if PRINT_DEVELOPER_WARNINGS</a>
<a name="5226"><span class="lineNum">    5226 </span>            :                                    printf (&quot;This SgTypedefDeclaration is not in parent's child list, node: %p = %s = %s parent: %p = %s \n&quot;,</a>
<a name="5227"><span class="lineNum">    5227 </span>            :                                         node,node-&gt;class_name().c_str(),SageInterface::get_name(node).c_str(),parent,parent-&gt;class_name().c_str());</a>
<a name="5228"><span class="lineNum">    5228 </span>            : #endif</a>
<a name="5229"><span class="lineNum">    5229 </span>            :                                  }</a>
<a name="5230"><span class="lineNum">    5230 </span>            :                             }</a>
<a name="5231"><span class="lineNum">    5231 </span>            :                          break;</a>
<a name="5232"><span class="lineNum">    5232 </span>            :                        }</a>
<a name="5233"><span class="lineNum">    5233 </span>            : </a>
<a name="5234"><span class="lineNum">    5234 </span><span class="lineCov">         67 :                     case V_SgInitializedName:</span></a>
<a name="5235"><span class="lineNum">    5235 </span><span class="lineCov">         67 :                        {</span></a>
<a name="5236"><span class="lineNum">    5236 </span><span class="lineCov">         67 :                          SgInitializedName* initializedName             = isSgInitializedName(node);</span></a>
<a name="5237"><span class="lineNum">    5237 </span>            : #if 0</a>
<a name="5238"><span class="lineNum">    5238 </span>            :                       // DQ (9/26/2011): Older version of code.</a>
<a name="5239"><span class="lineNum">    5239 </span>            :                          SgVarRefExp*       variableReferenceExpression = isSgVarRefExp(node-&gt;get_parent());</a>
<a name="5240"><span class="lineNum">    5240 </span>            :                          if (initializedName != NULL &amp;&amp; variableReferenceExpression != NULL &amp;&amp; variableReferenceExpression-&gt;get_symbol()-&gt;get_declaration() == node)</a>
<a name="5241"><span class="lineNum">    5241 </span>            :                             {</a>
<a name="5242"><span class="lineNum">    5242 </span>            :                            // This is the special case of &quot;void foo(const char*); foo(__PRETTY_FUNCTION__);&quot;</a>
<a name="5243"><span class="lineNum">    5243 </span>            :                            // Note that __PRETTY_FUNCTION__ is a compiler generated const char* (C string).</a>
<a name="5244"><span class="lineNum">    5244 </span>            : #if 0</a>
<a name="5245"><span class="lineNum">    5245 </span>            :                               printf (&quot;This is a SgInitializedName %p = %s = %s with a SgVarRefExp parent = %p = %s and in this case the node is not in the child list \n&quot;,</a>
<a name="5246"><span class="lineNum">    5246 </span>            :                                    node,node-&gt;class_name().c_str(),SageInterface::get_name(node).c_str(),parent,parent-&gt;class_name().c_str());</a>
<a name="5247"><span class="lineNum">    5247 </span>            :                               printf (&quot;variableReferenceExpression-&gt;get_symbol()-&gt;get_declaration() = %p = %s \n&quot;,</a>
<a name="5248"><span class="lineNum">    5248 </span>            :                                    variableReferenceExpression-&gt;get_symbol()-&gt;get_declaration(),</a>
<a name="5249"><span class="lineNum">    5249 </span>            :                                    variableReferenceExpression-&gt;get_symbol()-&gt;get_declaration()-&gt;class_name().c_str());</a>
<a name="5250"><span class="lineNum">    5250 </span>            : #endif</a>
<a name="5251"><span class="lineNum">    5251 </span>            :                             }</a>
<a name="5252"><span class="lineNum">    5252 </span>            :                            else</a>
<a name="5253"><span class="lineNum">    5253 </span>            :                             {</a>
<a name="5254"><span class="lineNum">    5254 </span>            :                               if (SgProject::get_verbose() &gt; 0)</a>
<a name="5255"><span class="lineNum">    5255 </span>            :                                  {</a>
<a name="5256"><span class="lineNum">    5256 </span>            :                                    mprintf (&quot;Warning: TestChildPointersInMemoryPool::visit(): Node is not in parent's child list, node: %p = %s = %s parent: %p = %s \n&quot;,</a>
<a name="5257"><span class="lineNum">    5257 </span>            :                                         node,node-&gt;class_name().c_str(),SageInterface::get_name(node).c_str(),parent,parent-&gt;class_name().c_str());</a>
<a name="5258"><span class="lineNum">    5258 </span>            :                                  }</a>
<a name="5259"><span class="lineNum">    5259 </span>            :                             }</a>
<a name="5260"><span class="lineNum">    5260 </span>            : #else</a>
<a name="5261"><span class="lineNum">    5261 </span>            :                       // DQ (9/26/2011): Trying to handle this via a better implementation of this test.</a>
<a name="5262"><span class="lineNum">    5262 </span><span class="lineCov">         67 :                          if (initializedName != NULL)</span></a>
<a name="5263"><span class="lineNum">    5263 </span>            :                             {</a>
<a name="5264"><span class="lineNum">    5264 </span>            :                            // Check for &quot;__PRETTY_FUNCTION__&quot; and &quot;__func__&quot; since these are implicit variables and</a>
<a name="5265"><span class="lineNum">    5265 </span>            :                            // are defined in ROSE to have a parent pointing to the associated SgFunctionDefinition.</a>
<a name="5266"><span class="lineNum">    5266 </span>            :                            // This is a change where it used to point to the associated SgVarRefExp, but this can be</a>
<a name="5267"><span class="lineNum">    5267 </span>            :                            // deleted if the constant folded value is subsituted with the original expression tree.</a>
<a name="5268"><span class="lineNum">    5268 </span>            :                            // It also never made since to have it be associated with anything but the SgFunctionDefinition</a>
<a name="5269"><span class="lineNum">    5269 </span>            :                            // also both of these are handled uniformally now.  This fix permits more passing tests of</a>
<a name="5270"><span class="lineNum">    5270 </span>            :                            // the AST merge and the AST File I/O support in ROSE.  This fix is a part of the move in ROSE</a>
<a name="5271"><span class="lineNum">    5271 </span>            :                            // to support either the constant folded values (optional) or the original expression trees (default).</a>
<a name="5272"><span class="lineNum">    5272 </span><span class="lineCov">         67 :                               if (initializedName-&gt;get_name() == &quot;__PRETTY_FUNCTION__&quot; || initializedName-&gt;get_name() == &quot;__func__&quot;)</span></a>
<a name="5273"><span class="lineNum">    5273 </span>            :                                  {</a>
<a name="5274"><span class="lineNum">    5274 </span>            :                                 // This not is not in the child list of the parent, this is expected.</a>
<a name="5275"><span class="lineNum">    5275 </span><span class="lineNoCov">          0 :                                    ROSE_ASSERT(node-&gt;get_parent() != NULL);</span></a>
<a name="5276"><span class="lineNum">    5276 </span>            :                                 // printf (&quot;In TestChildPointersInMemoryPool::visit(): (__PRETTY_FUNCTION__ || __func__) node-&gt;get_parent() = %p = %s \n&quot;,node-&gt;get_parent(),node-&gt;get_parent()-&gt;class_name().c_str());</a>
<a name="5277"><span class="lineNum">    5277 </span><span class="lineNoCov">          0 :                                    ROSE_ASSERT(isSgFunctionDefinition(node-&gt;get_parent()) != NULL);</span></a>
<a name="5278"><span class="lineNum">    5278 </span>            :                                  }</a>
<a name="5279"><span class="lineNum">    5279 </span>            :                                 else</a>
<a name="5280"><span class="lineNum">    5280 </span>            :                                  {</a>
<a name="5281"><span class="lineNum">    5281 </span><span class="lineCov">        134 :                                    mprintf (&quot;Warning: TestChildPointersInMemoryPool::visit(): Node is not in parent's child list, node: %p = %s = %s parent: %p = %s \n&quot;,</span></a>
<a name="5282"><span class="lineNum">    5282 </span><span class="lineCov">        243 :                                         node,node-&gt;class_name().c_str(),SageInterface::get_name(node).c_str(),parent,parent-&gt;class_name().c_str());</span></a>
<a name="5283"><span class="lineNum">    5283 </span>            :                                  }</a>
<a name="5284"><span class="lineNum">    5284 </span>            :                             }</a>
<a name="5285"><span class="lineNum">    5285 </span>            : #endif</a>
<a name="5286"><span class="lineNum">    5286 </span>            :                          break;</a>
<a name="5287"><span class="lineNum">    5287 </span>            :                        }</a>
<a name="5288"><span class="lineNum">    5288 </span>            : </a>
<a name="5289"><span class="lineNum">    5289 </span><span class="lineCov">       5040 :                     case V_SgFunctionDeclaration:</span></a>
<a name="5290"><span class="lineNum">    5290 </span><span class="lineCov">       5040 :                     case V_SgMemberFunctionDeclaration:</span></a>
<a name="5291"><span class="lineNum">    5291 </span><span class="lineCov">       5040 :                     case V_SgTemplateInstantiationFunctionDecl:</span></a>
<a name="5292"><span class="lineNum">    5292 </span><span class="lineCov">       5040 :                     case V_SgTemplateInstantiationMemberFunctionDecl:</span></a>
<a name="5293"><span class="lineNum">    5293 </span><span class="lineCov">       5040 :                        {</span></a>
<a name="5294"><span class="lineNum">    5294 </span><span class="lineCov">       5040 :                          SgFunctionDeclaration* functionDeclaration = isSgFunctionDeclaration(node);</span></a>
<a name="5295"><span class="lineNum">    5295 </span>            : </a>
<a name="5296"><span class="lineNum">    5296 </span>            :                       // By forcing the evaluation of isCompilerGenerated() we improve the performance by using short-circuit evaluation</a>
<a name="5297"><span class="lineNum">    5297 </span><span class="lineCov">       5593 :                          if ( (functionDeclaration-&gt;get_file_info()-&gt;isCompilerGenerated() == true) &amp;&amp;</span></a>
<a name="5298"><span class="lineNum">    5298 </span><span class="lineCov">       5593 :                               ( (functionDeclaration-&gt;get_name() == &quot;__default_function_pointer_name&quot;) || (functionDeclaration-&gt;get_name() == &quot;__default_member_function_pointer_name&quot;) ) )</span></a>
<a name="5299"><span class="lineNum">    5299 </span>            :                             {</a>
<a name="5300"><span class="lineNum">    5300 </span>            :                            // This is the case of a function (or member function) declaration built to support a function pointer (or member function pointer)</a>
<a name="5301"><span class="lineNum">    5301 </span>            : #if 0</a>
<a name="5302"><span class="lineNum">    5302 </span>            :                            // DQ (3/3/2007): isolated out case where we don't want to issue a warning!</a>
<a name="5303"><span class="lineNum">    5303 </span>            :                               printf (&quot;This is a function declaration built to support a function pointer declaration and should not be in the parent list: node: %p = %s = %s parent: %p = %s = %s \n&quot;,</a>
<a name="5304"><span class="lineNum">    5304 </span>            :                                    node,node-&gt;class_name().c_str(),SageInterface::get_name(node).c_str(),parent,parent-&gt;class_name().c_str(),SageInterface::get_name(parent).c_str());</a>
<a name="5305"><span class="lineNum">    5305 </span>            : #endif</a>
<a name="5306"><span class="lineNum">    5306 </span>            :                             }</a>
<a name="5307"><span class="lineNum">    5307 </span>            :                            else</a>
<a name="5308"><span class="lineNum">    5308 </span>            :                             {</a>
<a name="5309"><span class="lineNum">    5309 </span>            :                            // DQ (3/4/2007): Constructors for class without declared constructors will have a compiler generated constructor built</a>
<a name="5310"><span class="lineNum">    5310 </span>            :                            // internally and added to the symbol table, since it is not explicit in the source code it has a scope but the parent</a>
<a name="5311"><span class="lineNum">    5311 </span>            :                            // is set to SgGlobal (global scope). Since the declaration deso not really exist in global scope it's parent does not</a>
<a name="5312"><span class="lineNum">    5312 </span>            :                            // have it in it's child list.  This is an acceptable case and so we filter this specific case out.</a>
<a name="5313"><span class="lineNum">    5313 </span><span class="lineCov">       5040 :                               if ( (functionDeclaration-&gt;get_file_info()-&gt;isCompilerGenerated() == true) &amp;&amp; (functionDeclaration-&gt;get_specialFunctionModifier().isConstructor() == true) )</span></a>
<a name="5314"><span class="lineNum">    5314 </span>            :                                  {</a>
<a name="5315"><span class="lineNum">    5315 </span>            :                                 // Ignore this case of a compiler generated constructor for a class without one</a>
<a name="5316"><span class="lineNum">    5316 </span>            :                                  }</a>
<a name="5317"><span class="lineNum">    5317 </span>            :                                 else</a>
<a name="5318"><span class="lineNum">    5318 </span>            :                                  {</a>
<a name="5319"><span class="lineNum">    5319 </span><span class="lineCov">       4976 :                                    SgMemberFunctionDeclaration* memberFunctionDeclaration = isSgMemberFunctionDeclaration(functionDeclaration);</span></a>
<a name="5320"><span class="lineNum">    5320 </span><span class="lineCov">       4976 :                                    if (memberFunctionDeclaration != NULL)</span></a>
<a name="5321"><span class="lineNum">    5321 </span>            :                                       {</a>
<a name="5322"><span class="lineNum">    5322 </span>            :                                      // For member function declaration the function could be referenced before it was defined in which case if this is not the defining declaration it may not exist in the child list of the class scope.</a>
<a name="5323"><span class="lineNum">    5323 </span>            :                                      // if (memberFunctionDeclaration != memberFunctionDeclaration-&gt;get_definingDeclaration())</a>
<a name="5324"><span class="lineNum">    5324 </span><span class="lineCov">       2190 :                                         if (memberFunctionDeclaration == memberFunctionDeclaration-&gt;get_definingDeclaration() &amp;&amp; memberFunctionDeclaration-&gt;get_parent() == memberFunctionDeclaration-&gt;get_scope())</span></a>
<a name="5325"><span class="lineNum">    5325 </span>            :                                            {</a>
<a name="5326"><span class="lineNum">    5326 </span>            :                                           // This is the defining function declared inside the class, so there will be no non-defining member function</a>
<a name="5327"><span class="lineNum">    5327 </span>            :                                           // in the class (this declaration is all that will be in the parent list).</a>
<a name="5328"><span class="lineNum">    5328 </span>            :                                           // printf (&quot;Error: this member fucntion is the defining declaration and defined in the class so it should have been in the parent list. \n&quot;);</a>
<a name="5329"><span class="lineNum">    5329 </span>            :                                           // ROSE_ASSERT(false);</a>
<a name="5330"><span class="lineNum">    5330 </span>            :                                            }</a>
<a name="5331"><span class="lineNum">    5331 </span>            :                                           else</a>
<a name="5332"><span class="lineNum">    5332 </span>            :                                            {</a>
<a name="5333"><span class="lineNum">    5333 </span><span class="lineCov">       2190 :                                              if (memberFunctionDeclaration != memberFunctionDeclaration-&gt;get_definingDeclaration() &amp;&amp; memberFunctionDeclaration-&gt;get_parent() == memberFunctionDeclaration-&gt;get_scope())</span></a>
<a name="5334"><span class="lineNum">    5334 </span>            :                                                 {</a>
<a name="5335"><span class="lineNum">    5335 </span>            :                                                // This is a non-defining declaration that is declared in the class and it should have been in the parent list.</a>
<a name="5336"><span class="lineNum">    5336 </span>            :                                                // This is currently the case for all non-definng declarations since the parent is artificially set to the class</a>
<a name="5337"><span class="lineNum">    5337 </span>            :                                                // scope (is there a better idea of howto set it?).</a>
<a name="5338"><span class="lineNum">    5338 </span>            :                                                // printf (&quot;Error: this member fucntion is the defining declaration and defined in the class so it should have been in the parent list. \n&quot;);</a>
<a name="5339"><span class="lineNum">    5339 </span>            :                                                // ROSE_ASSERT(false);</a>
<a name="5340"><span class="lineNum">    5340 </span>            :                                                 }</a>
<a name="5341"><span class="lineNum">    5341 </span>            :                                                else</a>
<a name="5342"><span class="lineNum">    5342 </span>            :                                                 {</a>
<a name="5343"><span class="lineNum">    5343 </span>            :                                                // DQ (10/12/2007): Non defining member declarations can appear outside of the class, at least if they are</a>
<a name="5344"><span class="lineNum">    5344 </span>            :                                                // template instantiation member function declarations.  So this has been changed to a note instead of an error.</a>
<a name="5345"><span class="lineNum">    5345 </span>            : </a>
<a name="5346"><span class="lineNum">    5346 </span>            :                                                // This is a defining declaration that is not defined in the parent scope.  Currently all member functions</a>
<a name="5347"><span class="lineNum">    5347 </span>            :                                                // are assigned the class scope as a parent (independent of if they are first used in a function). So this</a>
<a name="5348"><span class="lineNum">    5348 </span>            :                                                // case should not appear.</a>
<a name="5349"><span class="lineNum">    5349 </span>            :                                                // printf (&quot;Error: non-defining memberFunctionDeclaration with parent not set to class scope \n&quot;);</a>
<a name="5350"><span class="lineNum">    5350 </span>            : </a>
<a name="5351"><span class="lineNum">    5351 </span>            : #if 0</a>
<a name="5352"><span class="lineNum">    5352 </span>            :                                                // DQ (11/10/2019): Cleanup output spew for demo.</a>
<a name="5353"><span class="lineNum">    5353 </span>            : </a>
<a name="5354"><span class="lineNum">    5354 </span>            :                                                   printf (&quot;Note: non-defining memberFunctionDeclaration with parent not set to class scope \n&quot;);</a>
<a name="5355"><span class="lineNum">    5355 </span>            :                                                   printf (&quot;     memberFunctionDeclaration = %p = %s = %s \n&quot;,memberFunctionDeclaration,memberFunctionDeclaration-&gt;class_name().c_str(),SageInterface::get_name(memberFunctionDeclaration).c_str());</a>
<a name="5356"><span class="lineNum">    5356 </span>            :                                                   SgNode* memberFunctionDeclarationParent = memberFunctionDeclaration-&gt;get_parent();</a>
<a name="5357"><span class="lineNum">    5357 </span>            :                                                   printf (&quot;     memberFunctionDeclaration-&gt;get_parent() = %p = %s = %s \n&quot;,memberFunctionDeclarationParent,memberFunctionDeclarationParent-&gt;class_name().c_str(),SageInterface::get_name(memberFunctionDeclarationParent).c_str());</a>
<a name="5358"><span class="lineNum">    5358 </span>            : </a>
<a name="5359"><span class="lineNum">    5359 </span>            :                                                   memberFunctionDeclaration-&gt;get_startOfConstruct()-&gt;display(&quot;Note: non-defining memberFunctionDeclaration with parent not set to class scope&quot;);</a>
<a name="5360"><span class="lineNum">    5360 </span>            : #endif</a>
<a name="5361"><span class="lineNum">    5361 </span>            :                                                 }</a>
<a name="5362"><span class="lineNum">    5362 </span>            :                                            }</a>
<a name="5363"><span class="lineNum">    5363 </span>            :                                       }</a>
<a name="5364"><span class="lineNum">    5364 </span>            :                                      else</a>
<a name="5365"><span class="lineNum">    5365 </span>            :                                       {</a>
<a name="5366"><span class="lineNum">    5366 </span>            : #if PRINT_DEVELOPER_WARNINGS</a>
<a name="5367"><span class="lineNum">    5367 </span>            :                                         printf (&quot;This SgFunctionDeclaration is not in parent's child list, node: %p = %s = %s parent: %p = %s = %s \n&quot;,</a>
<a name="5368"><span class="lineNum">    5368 </span>            :                                              node,node-&gt;class_name().c_str(),SageInterface::get_name(node).c_str(),parent,parent-&gt;class_name().c_str(),SageInterface::get_name(parent).c_str());</a>
<a name="5369"><span class="lineNum">    5369 </span>            : #endif</a>
<a name="5370"><span class="lineNum">    5370 </span>            : #if 0</a>
<a name="5371"><span class="lineNum">    5371 </span>            :                                         printf (&quot;functionDeclaration-&gt;get_definingDeclaration() = %p functionDeclaration-&gt;get_firstNondefiningDeclaration() = %p \n&quot;,</a>
<a name="5372"><span class="lineNum">    5372 </span>            :                                              functionDeclaration-&gt;get_definingDeclaration(),functionDeclaration-&gt;get_firstNondefiningDeclaration());</a>
<a name="5373"><span class="lineNum">    5373 </span>            :                                         printf (&quot;Is this a constructor: functionDeclaration-&gt;get_specialFunctionModifier().isConstructor() = %s \n&quot;,functionDeclaration-&gt;get_specialFunctionModifier().isConstructor() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="5374"><span class="lineNum">    5374 </span>            :                                         functionDeclaration-&gt;get_file_info()-&gt;display(&quot;functionDeclaration location: debug&quot;);</a>
<a name="5375"><span class="lineNum">    5375 </span>            :                                         if (functionDeclaration-&gt;get_definingDeclaration() != NULL)</a>
<a name="5376"><span class="lineNum">    5376 </span>            :                                              functionDeclaration-&gt;get_definingDeclaration()-&gt;get_file_info()-&gt;display(&quot;functionDeclaration defining location: debug&quot;);</a>
<a name="5377"><span class="lineNum">    5377 </span>            :                                         if (functionDeclaration-&gt;get_firstNondefiningDeclaration() != NULL)</a>
<a name="5378"><span class="lineNum">    5378 </span>            :                                              functionDeclaration-&gt;get_firstNondefiningDeclaration()-&gt;get_file_info()-&gt;display(&quot;functionDeclaration first non-defining location: debug&quot;);</a>
<a name="5379"><span class="lineNum">    5379 </span>            : #endif</a>
<a name="5380"><span class="lineNum">    5380 </span>            :                                       }</a>
<a name="5381"><span class="lineNum">    5381 </span>            :                                  }</a>
<a name="5382"><span class="lineNum">    5382 </span>            :                             }</a>
<a name="5383"><span class="lineNum">    5383 </span>            :                          break;</a>
<a name="5384"><span class="lineNum">    5384 </span>            :                        }</a>
<a name="5385"><span class="lineNum">    5385 </span>            : </a>
<a name="5386"><span class="lineNum">    5386 </span><span class="lineCov">         42 :                     case V_SgVariableSymbol:</span></a>
<a name="5387"><span class="lineNum">    5387 </span><span class="lineCov">         42 :                        {</span></a>
<a name="5388"><span class="lineNum">    5388 </span><span class="lineCov">         42 :                          SgVariableSymbol* variableSymbol = isSgVariableSymbol(node);</span></a>
<a name="5389"><span class="lineNum">    5389 </span>            :                       // SgInitializedName* initializedName             = isSgInitializedName(variableSymbol-&gt;get_declaration());</a>
<a name="5390"><span class="lineNum">    5390 </span><span class="lineCov">         42 :                          SgInitializedName* initializedName             = variableSymbol-&gt;get_declaration();</span></a>
<a name="5391"><span class="lineNum">    5391 </span>            :                       // if (initializedName != NULL &amp;&amp; initializedName-&gt;get_file_info()-&gt;isCompilerGenerated() == true &amp;&amp; initializedName-&gt;get_name() == &quot;__PRETTY_FUNCTION__&quot;)</a>
<a name="5392"><span class="lineNum">    5392 </span><span class="lineCov">         42 :                          if ( initializedName != NULL &amp;&amp; initializedName-&gt;get_file_info()-&gt;isCompilerGenerated() == true &amp;&amp; (initializedName-&gt;get_name() == &quot;__PRETTY_FUNCTION__&quot; || initializedName-&gt;get_name() == &quot;__func__&quot;) )</span></a>
<a name="5393"><span class="lineNum">    5393 </span>            :                             {</a>
<a name="5394"><span class="lineNum">    5394 </span>            :                            // This is the special case of the SgVariableSymbol generated for &quot;void foo(const char*); foo(__PRETTY_FUNCTION__);&quot;</a>
<a name="5395"><span class="lineNum">    5395 </span>            :                            // Note that __PRETTY_FUNCTION__ is a compiler generated const char* (C string).</a>
<a name="5396"><span class="lineNum">    5396 </span>            : #if 0</a>
<a name="5397"><span class="lineNum">    5397 </span>            :                               printf (&quot;This is a SgVariableSymbol %p = %s = %s and in this case the SgVariableSymbol is not in the child list of the parent symbol table \n&quot;,</a>
<a name="5398"><span class="lineNum">    5398 </span>            :                                    variableSymbol,variableSymbol-&gt;class_name().c_str(),SageInterface::get_name(variableSymbol).c_str());</a>
<a name="5399"><span class="lineNum">    5399 </span>            : #endif</a>
<a name="5400"><span class="lineNum">    5400 </span>            :                             }</a>
<a name="5401"><span class="lineNum">    5401 </span>            :                            else</a>
<a name="5402"><span class="lineNum">    5402 </span>            :                             {</a>
<a name="5403"><span class="lineNum">    5403 </span>            :                            // DQ (3/19/2017): Added support for using message logging.</a>
<a name="5404"><span class="lineNum">    5404 </span><span class="lineCov">         84 :                               mprintf (&quot;Warning: TestChildPointersInMemoryPool::visit(). SgVariableSymbol is not in parent's child list, node: %p = %s = %s parent: %p = %s \n&quot;,</span></a>
<a name="5405"><span class="lineNum">    5405 </span><span class="lineCov">        108 :                                    node,node-&gt;class_name().c_str(),SageInterface::get_name(node).c_str(),parent,parent-&gt;class_name().c_str());</span></a>
<a name="5406"><span class="lineNum">    5406 </span>            :                             }</a>
<a name="5407"><span class="lineNum">    5407 </span>            :                          break;</a>
<a name="5408"><span class="lineNum">    5408 </span>            :                        }</a>
<a name="5409"><span class="lineNum">    5409 </span>            : </a>
<a name="5410"><span class="lineNum">    5410 </span><span class="lineNoCov">          0 :                     case V_SgClassSymbol:</span></a>
<a name="5411"><span class="lineNum">    5411 </span><span class="lineNoCov">          0 :                        {</span></a>
<a name="5412"><span class="lineNum">    5412 </span><span class="lineNoCov">          0 :                          SgClassSymbol* classSymbol = isSgClassSymbol(node);</span></a>
<a name="5413"><span class="lineNum">    5413 </span><span class="lineNoCov">          0 :                          SgClassDeclaration* classDeclaration = classSymbol-&gt;get_declaration();</span></a>
<a name="5414"><span class="lineNum">    5414 </span>            : </a>
<a name="5415"><span class="lineNum">    5415 </span>            :                       // DQ (3/3/2007): This is always a case we want to warn about!</a>
<a name="5416"><span class="lineNum">    5416 </span><span class="lineNoCov">          0 :                          printf (&quot;SgClassSymbol is not in parent's child list, node: %p = %s = %s parent: %p = %s = %s \n&quot;,</span></a>
<a name="5417"><span class="lineNum">    5417 </span><span class="lineNoCov">          0 :                               node,node-&gt;class_name().c_str(),SageInterface::get_name(node).c_str(),parent,parent-&gt;class_name().c_str(),SageInterface::get_name(parent).c_str());</span></a>
<a name="5418"><span class="lineNum">    5418 </span><span class="lineNoCov">          0 :                          classDeclaration-&gt;get_file_info()-&gt;display(&quot;case V_SgClassSymbol: location: debug&quot;);</span></a>
<a name="5419"><span class="lineNum">    5419 </span><span class="lineNoCov">          0 :                          break;</span></a>
<a name="5420"><span class="lineNum">    5420 </span>            :                        }</a>
<a name="5421"><span class="lineNum">    5421 </span>            : </a>
<a name="5422"><span class="lineNum">    5422 </span><span class="lineNoCov">          0 :                     case V_SgFunctionSymbol:</span></a>
<a name="5423"><span class="lineNum">    5423 </span><span class="lineNoCov">          0 :                        {</span></a>
<a name="5424"><span class="lineNum">    5424 </span><span class="lineNoCov">          0 :                          SgFunctionSymbol* functionSymbol = isSgFunctionSymbol(node);</span></a>
<a name="5425"><span class="lineNum">    5425 </span><span class="lineNoCov">          0 :                          SgFunctionDeclaration* functionDeclaration = functionSymbol-&gt;get_declaration();</span></a>
<a name="5426"><span class="lineNum">    5426 </span>            : </a>
<a name="5427"><span class="lineNum">    5427 </span>            :                       // DQ (3/3/2007): This is always a case we want to warn about!</a>
<a name="5428"><span class="lineNum">    5428 </span><span class="lineNoCov">          0 :                          printf (&quot;SgFunctionSymbol is not in parent's child list, node: %p = %s = %s parent: %p = %s = %s \n&quot;,</span></a>
<a name="5429"><span class="lineNum">    5429 </span><span class="lineNoCov">          0 :                               node,node-&gt;class_name().c_str(),SageInterface::get_name(node).c_str(),parent,parent-&gt;class_name().c_str(),SageInterface::get_name(parent).c_str());</span></a>
<a name="5430"><span class="lineNum">    5430 </span><span class="lineNoCov">          0 :                          functionDeclaration-&gt;get_file_info()-&gt;display(&quot;case V_SgFunctionSymbol: location: debug&quot;);</span></a>
<a name="5431"><span class="lineNum">    5431 </span><span class="lineNoCov">          0 :                          break;</span></a>
<a name="5432"><span class="lineNum">    5432 </span>            :                        }</a>
<a name="5433"><span class="lineNum">    5433 </span>            : </a>
<a name="5434"><span class="lineNum">    5434 </span><span class="lineNoCov">          0 :                     case V_SgStorageModifier:</span></a>
<a name="5435"><span class="lineNum">    5435 </span><span class="lineNoCov">          0 :                        {</span></a>
<a name="5436"><span class="lineNum">    5436 </span><span class="lineNoCov">          0 :                          SgStorageModifier* storageModifier = isSgStorageModifier(node);</span></a>
<a name="5437"><span class="lineNum">    5437 </span><span class="lineNoCov">          0 :                          SgInitializedName* initializedName = isSgInitializedName(storageModifier-&gt;get_parent());</span></a>
<a name="5438"><span class="lineNum">    5438 </span><span class="lineNoCov">          0 :                          if (initializedName != NULL)</span></a>
<a name="5439"><span class="lineNum">    5439 </span>            :                             {</a>
<a name="5440"><span class="lineNum">    5440 </span><span class="lineNoCov">          0 :                               printf (&quot;SgStorageModifier is not in parent's child list, SgInitializedName: %p = %s = %s parent: %p = %s = %s \n&quot;,</span></a>
<a name="5441"><span class="lineNum">    5441 </span><span class="lineNoCov">          0 :                                    storageModifier,storageModifier-&gt;class_name().c_str(),SageInterface::get_name(storageModifier).c_str(),</span></a>
<a name="5442"><span class="lineNum">    5442 </span><span class="lineNoCov">          0 :                                    initializedName,initializedName-&gt;class_name().c_str(),SageInterface::get_name(initializedName).c_str());</span></a>
<a name="5443"><span class="lineNum">    5443 </span><span class="lineNoCov">          0 :                               SgNode* parent1 = initializedName-&gt;get_parent();</span></a>
<a name="5444"><span class="lineNum">    5444 </span><span class="lineNoCov">          0 :                               printf (&quot;parent1 IR node = %p = %s \n&quot;,parent1,parent1-&gt;class_name().c_str());</span></a>
<a name="5445"><span class="lineNum">    5445 </span><span class="lineNoCov">          0 :                               SgNode* parent2 = parent1-&gt;get_parent();</span></a>
<a name="5446"><span class="lineNum">    5446 </span><span class="lineNoCov">          0 :                               printf (&quot;parent2 IR node = %p = %s \n&quot;,parent2,parent2-&gt;class_name().c_str());</span></a>
<a name="5447"><span class="lineNum">    5447 </span><span class="lineNoCov">          0 :                               SgNode* parent3 = parent2-&gt;get_parent();</span></a>
<a name="5448"><span class="lineNum">    5448 </span><span class="lineNoCov">          0 :                               printf (&quot;parent3 IR node = %p = %s \n&quot;,parent3,parent3-&gt;class_name().c_str());</span></a>
<a name="5449"><span class="lineNum">    5449 </span><span class="lineNoCov">          0 :                               SgNode* parent4 = parent3-&gt;get_parent();</span></a>
<a name="5450"><span class="lineNum">    5450 </span><span class="lineNoCov">          0 :                               printf (&quot;parent4 IR node = %p = %s \n&quot;,parent4,parent4-&gt;class_name().c_str());</span></a>
<a name="5451"><span class="lineNum">    5451 </span><span class="lineNoCov">          0 :                               initializedName-&gt;get_file_info()-&gt;display(&quot;case V_SgStorageModifier: location: debug&quot;);</span></a>
<a name="5452"><span class="lineNum">    5452 </span>            :                             }</a>
<a name="5453"><span class="lineNum">    5453 </span>            :                            else</a>
<a name="5454"><span class="lineNum">    5454 </span>            :                             {</a>
<a name="5455"><span class="lineNum">    5455 </span>            :                            // DQ (3/3/2007): This is always a case we want to warn about!</a>
<a name="5456"><span class="lineNum">    5456 </span><span class="lineNoCov">          0 :                               printf (&quot;SgStorageModifier is not in parent's child list, node: %p = %s = %s parent: %p = %s \n&quot;,</span></a>
<a name="5457"><span class="lineNum">    5457 </span><span class="lineNoCov">          0 :                                    node,node-&gt;class_name().c_str(),SageInterface::get_name(node).c_str(),parent,parent-&gt;class_name().c_str());</span></a>
<a name="5458"><span class="lineNum">    5458 </span>            :                             }</a>
<a name="5459"><span class="lineNum">    5459 </span>            :                          break;</a>
<a name="5460"><span class="lineNum">    5460 </span>            :                        }</a>
<a name="5461"><span class="lineNum">    5461 </span>            : </a>
<a name="5462"><span class="lineNum">    5462 </span><span class="lineCov">      32575 :                     case V_SgTemplateArgument:</span></a>
<a name="5463"><span class="lineNum">    5463 </span><span class="lineCov">      32575 :                        {</span></a>
<a name="5464"><span class="lineNum">    5464 </span><span class="lineCov">      32575 :                          SgTemplateArgument* templateArgument = isSgTemplateArgument(node);</span></a>
<a name="5465"><span class="lineNum">    5465 </span><span class="lineCov">      32575 :                          SgTemplateInstantiationDecl* templateInstantiationDecl = isSgTemplateInstantiationDecl(templateArgument-&gt;get_parent());</span></a>
<a name="5466"><span class="lineNum">    5466 </span>            :                          if (templateInstantiationDecl != NULL)</a>
<a name="5467"><span class="lineNum">    5467 </span>            :                             {</a>
<a name="5468"><span class="lineNum">    5468 </span>            :                            // DQ (3/6/2007): This is somwthing to investigate.</a>
<a name="5469"><span class="lineNum">    5469 </span>            : // DQ (5/25/2013): Commented out for now, too much output spew.</a>
<a name="5470"><span class="lineNum">    5470 </span>            : // #ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION</a>
<a name="5471"><span class="lineNum">    5471 </span>            : #if 0</a>
<a name="5472"><span class="lineNum">    5472 </span>            :                               printf (&quot;SgTemplateArgument is not in parent's child list, node: %p = %s = %s parent: %p = %s = %s \n&quot;,</a>
<a name="5473"><span class="lineNum">    5473 </span>            :                                    node,node-&gt;class_name().c_str(),SageInterface::get_name(node).c_str(),parent,parent-&gt;class_name().c_str(),SageInterface::get_name(parent).c_str());</a>
<a name="5474"><span class="lineNum">    5474 </span>            :                               printf (&quot;templateInstantiationDecl-&gt;get_definingDeclaration() = %p templateInstantiationDecl-&gt;get_firstNondefiningDeclaration() = %p \n&quot;,</a>
<a name="5475"><span class="lineNum">    5475 </span>            :                                    templateInstantiationDecl-&gt;get_definingDeclaration(),templateInstantiationDecl-&gt;get_firstNondefiningDeclaration());</a>
<a name="5476"><span class="lineNum">    5476 </span>            :                            // templateInstantiationDecl-&gt;get_file_info()-&gt;display(&quot;case V_SgTemplateArgument: location: debug&quot;);</a>
<a name="5477"><span class="lineNum">    5477 </span>            : #endif</a>
<a name="5478"><span class="lineNum">    5478 </span>            :                             }</a>
<a name="5479"><span class="lineNum">    5479 </span>            :                            else</a>
<a name="5480"><span class="lineNum">    5480 </span>            :                             {</a>
<a name="5481"><span class="lineNum">    5481 </span>            :                            // DQ (8/19/2014): Since these are shared (by design, so that the symbol table use is optimal) it is less important to warn about these.</a>
<a name="5482"><span class="lineNum">    5482 </span>            :                            // DQ (3/6/2007): This is always a case we want to warn about!</a>
<a name="5483"><span class="lineNum">    5483 </span>            : // #ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION</a>
<a name="5484"><span class="lineNum">    5484 </span>            : #if 0</a>
<a name="5485"><span class="lineNum">    5485 </span>            :                               printf (&quot;SgTemplateArgument is not in parent's child list, node: %p = %s = %s parent: %p = %s = %s \n&quot;,</a>
<a name="5486"><span class="lineNum">    5486 </span>            :                                    node,node-&gt;class_name().c_str(),SageInterface::get_name(node).c_str(),parent,parent-&gt;class_name().c_str(),SageInterface::get_name(parent).c_str());</a>
<a name="5487"><span class="lineNum">    5487 </span>            : #endif</a>
<a name="5488"><span class="lineNum">    5488 </span>            :                             }</a>
<a name="5489"><span class="lineNum">    5489 </span>            :                          break;</a>
<a name="5490"><span class="lineNum">    5490 </span>            :                        }</a>
<a name="5491"><span class="lineNum">    5491 </span>            : </a>
<a name="5492"><span class="lineNum">    5492 </span>            :                     case V_SgTypedefSeq:</a>
<a name="5493"><span class="lineNum">    5493 </span>            :                        {</a>
<a name="5494"><span class="lineNum">    5494 </span>            : #if PRINT_DEVELOPER_WARNINGS</a>
<a name="5495"><span class="lineNum">    5495 </span>            :                          SgTypedefSeq* typedefSequence = isSgTypedefSeq(node);</a>
<a name="5496"><span class="lineNum">    5496 </span>            :                          SgNode* parent = typedefSequence-&gt;get_parent();</a>
<a name="5497"><span class="lineNum">    5497 </span>            :                          SgNode* parentParent = parent-&gt;get_parent();</a>
<a name="5498"><span class="lineNum">    5498 </span>            : </a>
<a name="5499"><span class="lineNum">    5499 </span>            :                          printf (&quot;Node is not in parent's child list, typedefSequence = %p parent = %p = %s parentParent = %p \n&quot;,typedefSequence,parent,parent-&gt;class_name().c_str(),parentParent);</a>
<a name="5500"><span class="lineNum">    5500 </span>            : #endif</a>
<a name="5501"><span class="lineNum">    5501 </span>            :                          break;</a>
<a name="5502"><span class="lineNum">    5502 </span>            :                        }</a>
<a name="5503"><span class="lineNum">    5503 </span>            : </a>
<a name="5504"><span class="lineNum">    5504 </span>            :                  // DQ (6/13/2007): Added case to avoid warnings where Sg_File_Info objects are used in comments and cpp directives.</a>
<a name="5505"><span class="lineNum">    5505 </span><span class="lineCov">       2982 :                     case V_Sg_File_Info:</span></a>
<a name="5506"><span class="lineNum">    5506 </span><span class="lineCov">       2982 :                        {</span></a>
<a name="5507"><span class="lineNum">    5507 </span><span class="lineCov">       2982 :                          Sg_File_Info* fileInfo = isSg_File_Info(node);</span></a>
<a name="5508"><span class="lineNum">    5508 </span><span class="lineCov">       2982 :                          SgNode* parent = fileInfo-&gt;get_parent();</span></a>
<a name="5509"><span class="lineNum">    5509 </span>            :                       // if (parent == NULL &amp;&amp; fileInfo-&gt;isCommentOrDirective() == true)</a>
<a name="5510"><span class="lineNum">    5510 </span><span class="lineCov">       2982 :                          if (fileInfo-&gt;isCommentOrDirective() == true)</span></a>
<a name="5511"><span class="lineNum">    5511 </span>            :                                {</a>
<a name="5512"><span class="lineNum">    5512 </span>            :                               // This is the one case where the parent will always be NULL, it is OK.</a>
<a name="5513"><span class="lineNum">    5513 </span>            :                                }</a>
<a name="5514"><span class="lineNum">    5514 </span>            :                               else</a>
<a name="5515"><span class="lineNum">    5515 </span>            :                                {</a>
<a name="5516"><span class="lineNum">    5516 </span><span class="lineCov">        923 :                                  ROSE_ASSERT(parent != NULL);</span></a>
<a name="5517"><span class="lineNum">    5517 </span>            : #if PRINT_DEVELOPER_WARNINGS</a>
<a name="5518"><span class="lineNum">    5518 </span>            :                                  SgNode* parentParent = parent-&gt;get_parent();</a>
<a name="5519"><span class="lineNum">    5519 </span>            : </a>
<a name="5520"><span class="lineNum">    5520 </span>            :                               // DQ (10/22/2007): Modified to put out the class name of the parentParent (not tested).</a>
<a name="5521"><span class="lineNum">    5521 </span>            :                                  printf (&quot;Node is not in parent's child list, fileInfo = %p parent = %p = %s parentParent = %p = %s \n&quot;,</a>
<a name="5522"><span class="lineNum">    5522 </span>            :                                       fileInfo,parent,parent-&gt;class_name().c_str(),parentParent,parentParent == NULL ? &quot;NULL&quot; : parentParent-&gt;class_name().c_str());</a>
<a name="5523"><span class="lineNum">    5523 </span>            : #endif</a>
<a name="5524"><span class="lineNum">    5524 </span>            :                                }</a>
<a name="5525"><span class="lineNum">    5525 </span>            :                          break;</a>
<a name="5526"><span class="lineNum">    5526 </span>            :                        }</a>
<a name="5527"><span class="lineNum">    5527 </span>            : </a>
<a name="5528"><span class="lineNum">    5528 </span><span class="lineCov">     148245 :                     default:</span></a>
<a name="5529"><span class="lineNum">    5529 </span><span class="lineCov">     148245 :                        {</span></a>
<a name="5530"><span class="lineNum">    5530 </span>            :                       // In the default case we issue a warning ...</a>
<a name="5531"><span class="lineNum">    5531 </span>            : #if PRINT_DEVELOPER_WARNINGS</a>
<a name="5532"><span class="lineNum">    5532 </span>            :                          printf (&quot;Node is not in parent's child list (default case), node: %p = %s = %s parent: %p = %s \n&quot;,</a>
<a name="5533"><span class="lineNum">    5533 </span>            :                               node,node-&gt;class_name().c_str(),SageInterface::get_name(node).c_str(),parent,parent-&gt;class_name().c_str());</a>
<a name="5534"><span class="lineNum">    5534 </span>            : #endif</a>
<a name="5535"><span class="lineNum">    5535 </span>            :                        }</a>
<a name="5536"><span class="lineNum">    5536 </span>            :                   }</a>
<a name="5537"><span class="lineNum">    5537 </span>            : </a>
<a name="5538"><span class="lineNum">    5538 </span>            :             // Additional information!</a>
<a name="5539"><span class="lineNum">    5539 </span><span class="lineCov">     148245 :                if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL+1 )</span></a>
<a name="5540"><span class="lineNum">    5540 </span>            :                   {</a>
<a name="5541"><span class="lineNum">    5541 </span>            :                  // DQ (1/22/2008): Detect the case where node is a Sg_File_Info IR nodes (which should not have a valid get_file_info() pointer)</a>
<a name="5542"><span class="lineNum">    5542 </span><span class="lineNoCov">          0 :                     Sg_File_Info* fileInfo = isSg_File_Info(node);</span></a>
<a name="5543"><span class="lineNum">    5543 </span><span class="lineNoCov">          0 :                     if (node-&gt;get_file_info() == NULL)</span></a>
<a name="5544"><span class="lineNum">    5544 </span>            :                        {</a>
<a name="5545"><span class="lineNum">    5545 </span>            :                       // DQ (5/17/2008): It is OK for a SgSymbol to have a NULL fileInfo pointer</a>
<a name="5546"><span class="lineNum">    5546 </span>            :                       // DQ (1/22/2008): Ignore that the get_file_info() for a Sg_File_Info IR node is NULL</a>
<a name="5547"><span class="lineNum">    5547 </span>            :                       // if (fileInfo == NULL &amp;&amp; isSgType(node) == NULL )</a>
<a name="5548"><span class="lineNum">    5548 </span><span class="lineNoCov">          0 :                          if (fileInfo == NULL &amp;&amp; (isSgType(node) == NULL &amp;&amp; isSgSymbol(node) == NULL))</span></a>
<a name="5549"><span class="lineNum">    5549 </span><span class="lineNoCov">          0 :                               printf (&quot;Warning: node-&gt;get_file_info() is NULL on node = %p = %s \n&quot;,node,node-&gt;class_name().c_str());</span></a>
<a name="5550"><span class="lineNum">    5550 </span>            :                        }</a>
<a name="5551"><span class="lineNum">    5551 </span>            :                       else</a>
<a name="5552"><span class="lineNum">    5552 </span>            :                        {</a>
<a name="5553"><span class="lineNum">    5553 </span>            :                       // node-&gt;get_file_info()-&gt;display(&quot;node location: debug&quot;);</a>
<a name="5554"><span class="lineNum">    5554 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT( fileInfo == NULL );</span></a>
<a name="5555"><span class="lineNum">    5555 </span>            :                        }</a>
<a name="5556"><span class="lineNum">    5556 </span>            :                  // ROSE_ASSERT(node-&gt;get_file_info() != NULL);</a>
<a name="5557"><span class="lineNum">    5557 </span>            : </a>
<a name="5558"><span class="lineNum">    5558 </span><span class="lineNoCov">          0 :                     if (parent != NULL)</span></a>
<a name="5559"><span class="lineNum">    5559 </span>            :                        {</a>
<a name="5560"><span class="lineNum">    5560 </span><span class="lineNoCov">          0 :                          if (parent-&gt;get_file_info() == NULL)</span></a>
<a name="5561"><span class="lineNum">    5561 </span>            :                             {</a>
<a name="5562"><span class="lineNum">    5562 </span>            :                            // DQ (5/17/2008): It is OK for a SgSymbol to have a parent which is a symbol table without a valid fileInfo pointer</a>
<a name="5563"><span class="lineNum">    5563 </span>            :                            // DQ (1/22/2008): Ignore SgType IR nodes (since they never have a valid get_file_info())</a>
<a name="5564"><span class="lineNum">    5564 </span>            :                            // if (isSgType(parent) == NULL )</a>
<a name="5565"><span class="lineNum">    5565 </span><span class="lineNoCov">          0 :                               if (isSgType(parent) == NULL &amp;&amp; isSgSymbolTable(parent) == NULL)</span></a>
<a name="5566"><span class="lineNum">    5566 </span><span class="lineNoCov">          0 :                                    printf (&quot;Warning: parent-&gt;get_file_info() is NULL on node = %p = %s \n&quot;,parent,parent-&gt;class_name().c_str());</span></a>
<a name="5567"><span class="lineNum">    5567 </span>            :                             }</a>
<a name="5568"><span class="lineNum">    5568 </span>            :                            else</a>
<a name="5569"><span class="lineNum">    5569 </span>            :                             {</a>
<a name="5570"><span class="lineNum">    5570 </span>            :                            // parent-&gt;get_file_info()-&gt;display(&quot;parent location: debug&quot;);</a>
<a name="5571"><span class="lineNum">    5571 </span>            :                             }</a>
<a name="5572"><span class="lineNum">    5572 </span>            :                        }</a>
<a name="5573"><span class="lineNum">    5573 </span>            :                       else</a>
<a name="5574"><span class="lineNum">    5574 </span>            :                        {</a>
<a name="5575"><span class="lineNum">    5575 </span><span class="lineNoCov">          0 :                          printf (&quot;Warning: parent of node-&gt;get_file_info() is NULL on node = %p = %s \n&quot;,node,node-&gt;class_name().c_str());</span></a>
<a name="5576"><span class="lineNum">    5576 </span>            :                        }</a>
<a name="5577"><span class="lineNum">    5577 </span>            :                   }</a>
<a name="5578"><span class="lineNum">    5578 </span>            : </a>
<a name="5579"><span class="lineNum">    5579 </span>            :             // DQ (9/14/2006): This causes the ROSE/tests/nonsmoke/functional/roseTests/astMergeTests/testMerge.C test to fail!</a>
<a name="5580"><span class="lineNum">    5580 </span>            :             // cout &lt;&lt; node-&gt;unparseToString() &lt;&lt; endl;</a>
<a name="5581"><span class="lineNum">    5581 </span>            :             // cout &lt;&lt; endl;</a>
<a name="5582"><span class="lineNum">    5582 </span>            :              }</a>
<a name="5583"><span class="lineNum">    5583 </span>            :         }</a>
<a name="5584"><span class="lineNum">    5584 </span><span class="lineCov">   55910000 :    }</span></a>
<a name="5585"><span class="lineNum">    5585 </span>            : </a>
<a name="5586"><span class="lineNum">    5586 </span>            : </a>
<a name="5587"><span class="lineNum">    5587 </span>            : void</a>
<a name="5588"><span class="lineNum">    5588 </span><span class="lineNoCov">          0 : TestFirstNondefiningDeclarationsForForwardMarking::test()</span></a>
<a name="5589"><span class="lineNum">    5589 </span>            :    {</a>
<a name="5590"><span class="lineNum">    5590 </span><span class="lineNoCov">          0 :       TestFirstNondefiningDeclarationsForForwardMarking t;</span></a>
<a name="5591"><span class="lineNum">    5591 </span><span class="lineNoCov">          0 :       t.traverseMemoryPool();</span></a>
<a name="5592"><span class="lineNum">    5592 </span><span class="lineNoCov">          0 :    }</span></a>
<a name="5593"><span class="lineNum">    5593 </span>            : </a>
<a name="5594"><span class="lineNum">    5594 </span>            : </a>
<a name="5595"><span class="lineNum">    5595 </span>            : void</a>
<a name="5596"><span class="lineNum">    5596 </span><span class="lineNoCov">          0 : TestFirstNondefiningDeclarationsForForwardMarking::visit( SgNode* node)</span></a>
<a name="5597"><span class="lineNum">    5597 </span>            :    {</a>
<a name="5598"><span class="lineNum">    5598 </span><span class="lineNoCov">          0 :      SgDeclarationStatement* declaration = isSgDeclarationStatement(node);</span></a>
<a name="5599"><span class="lineNum">    5599 </span><span class="lineNoCov">          0 :      if (declaration != NULL)</span></a>
<a name="5600"><span class="lineNum">    5600 </span>            :         {</a>
<a name="5601"><span class="lineNum">    5601 </span><span class="lineNoCov">          0 :           SgDeclarationStatement* firstDefiningDeclaration = declaration-&gt;get_firstNondefiningDeclaration();</span></a>
<a name="5602"><span class="lineNum">    5602 </span><span class="lineNoCov">          0 :           if(firstDefiningDeclaration-&gt;isForward() == true)</span></a>
<a name="5603"><span class="lineNum">    5603 </span>            :              {</a>
<a name="5604"><span class="lineNum">    5604 </span><span class="lineNoCov">          0 :                printf (&quot;Error: firstDefiningDeclaration-&gt;isForward() == true: node = %p = %s = %s \n&quot;,</span></a>
<a name="5605"><span class="lineNum">    5605 </span><span class="lineNoCov">          0 :                     node,node-&gt;class_name().c_str(),SageInterface::get_name(node).c_str());</span></a>
<a name="5606"><span class="lineNum">    5606 </span><span class="lineNoCov">          0 :                firstDefiningDeclaration-&gt;get_file_info()-&gt;display(&quot;Error: firstDefiningDeclaration-&gt;isForward() == true: debug&quot;);</span></a>
<a name="5607"><span class="lineNum">    5607 </span>            :              }</a>
<a name="5608"><span class="lineNum">    5608 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(firstDefiningDeclaration-&gt;isForward() == false);</span></a>
<a name="5609"><span class="lineNum">    5609 </span>            :         }</a>
<a name="5610"><span class="lineNum">    5610 </span><span class="lineNoCov">          0 :    }</span></a>
<a name="5611"><span class="lineNum">    5611 </span>            : </a>
<a name="5612"><span class="lineNum">    5612 </span>            : </a>
<a name="5613"><span class="lineNum">    5613 </span>            : </a>
<a name="5614"><span class="lineNum">    5614 </span>            : </a>
<a name="5615"><span class="lineNum">    5615 </span>            : </a>
<a name="5616"><span class="lineNum">    5616 </span>            : void</a>
<a name="5617"><span class="lineNum">    5617 </span><span class="lineCov">        326 : TestMappingOfDeclarationsInMemoryPoolToSymbols::test()</span></a>
<a name="5618"><span class="lineNum">    5618 </span>            :    {</a>
<a name="5619"><span class="lineNum">    5619 </span><span class="lineCov">        652 :       TestMappingOfDeclarationsInMemoryPoolToSymbols t;</span></a>
<a name="5620"><span class="lineNum">    5620 </span><span class="lineCov">        326 :       t.traverseMemoryPool();</span></a>
<a name="5621"><span class="lineNum">    5621 </span><span class="lineCov">        326 :    }</span></a>
<a name="5622"><span class="lineNum">    5622 </span>            : </a>
<a name="5623"><span class="lineNum">    5623 </span>            : #if 0</a>
<a name="5624"><span class="lineNum">    5624 </span>            : // DQ (7/22/2007): This should be a member function of SgDeclarationStatement</a>
<a name="5625"><span class="lineNum">    5625 </span>            : bool hasAssociatedSymbol(SgDeclarationStatement* declarationStatement)</a>
<a name="5626"><span class="lineNum">    5626 </span>            :    {</a>
<a name="5627"><span class="lineNum">    5627 </span>            :      bool returnValue = true;</a>
<a name="5628"><span class="lineNum">    5628 </span>            : </a>
<a name="5629"><span class="lineNum">    5629 </span>            :   // SgFunctionParameterList should likely not even be a declaration, but at least it has</a>
<a name="5630"><span class="lineNum">    5630 </span>            :   // not associated symbol in the symbol table. SgVariableDeclaration contain a list of</a>
<a name="5631"><span class="lineNum">    5631 </span>            :   // SgInitializedName objects and those have associated symbols, the SgVariableDeclaration</a>
<a name="5632"><span class="lineNum">    5632 </span>            :   // does not have an associated symbol.</a>
<a name="5633"><span class="lineNum">    5633 </span>            :      if (isSgFunctionParameterList(declarationStatement) != NULL ||</a>
<a name="5634"><span class="lineNum">    5634 </span>            :          isSgCtorInitializerList(declarationStatement)   != NULL ||</a>
<a name="5635"><span class="lineNum">    5635 </span>            :          isSgPragmaDeclaration(declarationStatement)     != NULL ||</a>
<a name="5636"><span class="lineNum">    5636 </span>            :          isSgVariableDeclaration(declarationStatement)   != NULL ||</a>
<a name="5637"><span class="lineNum">    5637 </span>            :          isSgVariableDefinition(declarationStatement)    != NULL )</a>
<a name="5638"><span class="lineNum">    5638 </span>            :         {</a>
<a name="5639"><span class="lineNum">    5639 </span>            :           returnValue = false;</a>
<a name="5640"><span class="lineNum">    5640 </span>            :         }</a>
<a name="5641"><span class="lineNum">    5641 </span>            : </a>
<a name="5642"><span class="lineNum">    5642 </span>            :      return returnValue;</a>
<a name="5643"><span class="lineNum">    5643 </span>            :    }</a>
<a name="5644"><span class="lineNum">    5644 </span>            : #endif</a>
<a name="5645"><span class="lineNum">    5645 </span>            : </a>
<a name="5646"><span class="lineNum">    5646 </span>            : void</a>
<a name="5647"><span class="lineNum">    5647 </span><span class="lineCov">   55910000 : TestMappingOfDeclarationsInMemoryPoolToSymbols::visit( SgNode* node)</span></a>
<a name="5648"><span class="lineNum">    5648 </span>            :    {</a>
<a name="5649"><span class="lineNum">    5649 </span><span class="lineCov">   55910000 :      SgDeclarationStatement* declarationStatement = isSgDeclarationStatement(node);</span></a>
<a name="5650"><span class="lineNum">    5650 </span>            : </a>
<a name="5651"><span class="lineNum">    5651 </span>            :   // Note: not all declarations have an associated symbol</a>
<a name="5652"><span class="lineNum">    5652 </span><span class="lineCov">   55910000 :      if (declarationStatement != NULL &amp;&amp; declarationStatement-&gt;hasAssociatedSymbol() == true)</span></a>
<a name="5653"><span class="lineNum">    5653 </span>            :         {</a>
<a name="5654"><span class="lineNum">    5654 </span>            : #if 0</a>
<a name="5655"><span class="lineNum">    5655 </span>            :           printf (&quot;This is a declarationStatement = %p = %s = %s \n&quot;,</a>
<a name="5656"><span class="lineNum">    5656 </span>            :                declarationStatement,declarationStatement-&gt;class_name().c_str(),SageInterface::get_name(declarationStatement).c_str());</a>
<a name="5657"><span class="lineNum">    5657 </span>            :           ROSE_ASSERT(declarationStatement-&gt;get_scope() != NULL);</a>
<a name="5658"><span class="lineNum">    5658 </span>            :           printf (&quot;   The scope is = %p = %s = %s \n&quot;,</a>
<a name="5659"><span class="lineNum">    5659 </span>            :                declarationStatement-&gt;get_scope(),declarationStatement-&gt;get_scope()-&gt;class_name().c_str(),SageInterface::get_name(declarationStatement-&gt;get_scope()).c_str());</a>
<a name="5660"><span class="lineNum">    5660 </span>            : #endif</a>
<a name="5661"><span class="lineNum">    5661 </span>            : </a>
<a name="5662"><span class="lineNum">    5662 </span>            :        // printf (&quot;Exiting to test this! \n&quot;);</a>
<a name="5663"><span class="lineNum">    5663 </span>            :        // ROSE_ASSERT(false);</a>
<a name="5664"><span class="lineNum">    5664 </span>            : </a>
<a name="5665"><span class="lineNum">    5665 </span>            : </a>
<a name="5666"><span class="lineNum">    5666 </span>            : // DQ (8/1/2007): Temp control of use of this test</a>
<a name="5667"><span class="lineNum">    5667 </span>            : #if 0</a>
<a name="5668"><span class="lineNum">    5668 </span>            :           SgSymbol* symbol = declarationStatement-&gt;get_symbol_from_symbol_table();</a>
<a name="5669"><span class="lineNum">    5669 </span>            :           if (symbol == NULL)</a>
<a name="5670"><span class="lineNum">    5670 </span>            :              {</a>
<a name="5671"><span class="lineNum">    5671 </span>            : #if 0</a>
<a name="5672"><span class="lineNum">    5672 </span>            :                printf (&quot;symbol not found for declarationStatement = %p, looking at firstNondefiningDeclaration \n&quot;,declarationStatement);</a>
<a name="5673"><span class="lineNum">    5673 </span>            : #endif</a>
<a name="5674"><span class="lineNum">    5674 </span>            :                SgDeclarationStatement* firstNondefiningDeclaration = declarationStatement-&gt;get_firstNondefiningDeclaration();</a>
<a name="5675"><span class="lineNum">    5675 </span>            :                if (firstNondefiningDeclaration != NULL)</a>
<a name="5676"><span class="lineNum">    5676 </span>            :                     symbol = firstNondefiningDeclaration-&gt;get_symbol_from_symbol_table();</a>
<a name="5677"><span class="lineNum">    5677 </span>            : </a>
<a name="5678"><span class="lineNum">    5678 </span>            :                if (symbol == NULL)</a>
<a name="5679"><span class="lineNum">    5679 </span>            :                   {</a>
<a name="5680"><span class="lineNum">    5680 </span>            :                     SgDeclarationStatement* definingDeclaration = declarationStatement-&gt;get_definingDeclaration();</a>
<a name="5681"><span class="lineNum">    5681 </span>            : #if 1</a>
<a name="5682"><span class="lineNum">    5682 </span>            :                     printf (&quot;symbol not found for firstNondefiningDeclaration = %p, looking at firstNondefiningDeclaration \n&quot;,firstNondefiningDeclaration);</a>
<a name="5683"><span class="lineNum">    5683 </span>            :                     if (firstNondefiningDeclaration != NULL)</a>
<a name="5684"><span class="lineNum">    5684 </span>            :                        {</a>
<a name="5685"><span class="lineNum">    5685 </span>            :                          printf (&quot;     firstNondefiningDeclaration = %p = %s = %s \n&quot;,</a>
<a name="5686"><span class="lineNum">    5686 </span>            :                               firstNondefiningDeclaration,firstNondefiningDeclaration-&gt;class_name().c_str(),SageInterface::get_name(firstNondefiningDeclaration).c_str());</a>
<a name="5687"><span class="lineNum">    5687 </span>            :                          printf (&quot;     definingDeclaration = %p \n&quot;,definingDeclaration);</a>
<a name="5688"><span class="lineNum">    5688 </span>            :                          firstNondefiningDeclaration-&gt;get_startOfConstruct()-&gt;display(&quot;firstNondefiningDeclaration: debug&quot;);</a>
<a name="5689"><span class="lineNum">    5689 </span>            :                        }</a>
<a name="5690"><span class="lineNum">    5690 </span>            : #endif</a>
<a name="5691"><span class="lineNum">    5691 </span>            :                     if (definingDeclaration != NULL)</a>
<a name="5692"><span class="lineNum">    5692 </span>            :                          symbol = definingDeclaration-&gt;get_symbol_from_symbol_table();</a>
<a name="5693"><span class="lineNum">    5693 </span>            : </a>
<a name="5694"><span class="lineNum">    5694 </span>            :                  // DQ (7/30/2007): This is an exception to this rule!</a>
<a name="5695"><span class="lineNum">    5695 </span>            :                  // ROSE_ASSERT(symbol != NULL);</a>
<a name="5696"><span class="lineNum">    5696 </span>            :                     ROSE_ASSERT(symbol != NULL || SageInterface::get_name(firstNondefiningDeclaration) == &quot;__default_member_function_pointer_name&quot;);</a>
<a name="5697"><span class="lineNum">    5697 </span>            :                   }</a>
<a name="5698"><span class="lineNum">    5698 </span>            :             // ROSE_ASSERT(symbol != NULL);</a>
<a name="5699"><span class="lineNum">    5699 </span>            :                ROSE_ASSERT(symbol != NULL || SageInterface::get_name(declarationStatement) == &quot;__default_member_function_pointer_name&quot;);</a>
<a name="5700"><span class="lineNum">    5700 </span>            :              }</a>
<a name="5701"><span class="lineNum">    5701 </span>            : </a>
<a name="5702"><span class="lineNum">    5702 </span>            :        // ROSE_ASSERT(symbol != NULL);</a>
<a name="5703"><span class="lineNum">    5703 </span>            :           ROSE_ASSERT(symbol != NULL || SageInterface::get_name(declarationStatement) == &quot;__default_member_function_pointer_name&quot;);</a>
<a name="5704"><span class="lineNum">    5704 </span>            : </a>
<a name="5705"><span class="lineNum">    5705 </span>            :           SgDeclarationStatement* declarationAssociatedWithSymbol = NULL;</a>
<a name="5706"><span class="lineNum">    5706 </span>            : </a>
<a name="5707"><span class="lineNum">    5707 </span>            :        // DQ (7/4/2007): New function to refactor code and provide basis for internal testing.</a>
<a name="5708"><span class="lineNum">    5708 </span>            :           declarationAssociatedWithSymbol = declarationStatement-&gt;get_declaration_associated_with_symbol();</a>
<a name="5709"><span class="lineNum">    5709 </span>            :        // ROSE_ASSERT(declarationAssociatedWithSymbol != NULL);</a>
<a name="5710"><span class="lineNum">    5710 </span>            :           ROSE_ASSERT(declarationAssociatedWithSymbol != NULL || SageInterface::get_name(declarationStatement) == &quot;__default_member_function_pointer_name&quot;);</a>
<a name="5711"><span class="lineNum">    5711 </span>            : </a>
<a name="5712"><span class="lineNum">    5712 </span>            :        // DQ (7/5/2007): Test that we can get a symbol (this should not pass for all declarations).</a>
<a name="5713"><span class="lineNum">    5713 </span>            :        // ROSE_ASSERT(declarationAssociatedWithSymbol-&gt;get_symbol_from_symbol_table() != NULL);</a>
<a name="5714"><span class="lineNum">    5714 </span>            :           ROSE_ASSERT(declarationAssociatedWithSymbol != NULL || SageInterface::get_name(declarationStatement) == &quot;__default_member_function_pointer_name&quot;);</a>
<a name="5715"><span class="lineNum">    5715 </span>            : </a>
<a name="5716"><span class="lineNum">    5716 </span>            :        // Test that we can always find a symbol (this should always pass).</a>
<a name="5717"><span class="lineNum">    5717 </span>            :           if (isSgVariableDeclaration(declarationStatement) == NULL &amp;&amp;</a>
<a name="5718"><span class="lineNum">    5718 </span>            :               isSgVariableDefinition(declarationStatement)  == NULL &amp;&amp;</a>
<a name="5719"><span class="lineNum">    5719 </span>            :               isSgPragmaDeclaration(declarationStatement)   == NULL &amp;&amp;</a>
<a name="5720"><span class="lineNum">    5720 </span>            :               isSgMemberFunctionDeclaration(declarationStatement) == NULL || SageInterface::get_name(declarationStatement) != &quot;__default_member_function_pointer_name&quot;)</a>
<a name="5721"><span class="lineNum">    5721 </span>            :              {</a>
<a name="5722"><span class="lineNum">    5722 </span>            :                ROSE_ASSERT(declarationStatement-&gt;search_for_symbol_from_symbol_table() != NULL);</a>
<a name="5723"><span class="lineNum">    5723 </span>            :              }</a>
<a name="5724"><span class="lineNum">    5724 </span>            : </a>
<a name="5725"><span class="lineNum">    5725 </span>            : // DQ (8/1/2007): Temp control of use of this test</a>
<a name="5726"><span class="lineNum">    5726 </span>            : #endif</a>
<a name="5727"><span class="lineNum">    5727 </span>            :         }</a>
<a name="5728"><span class="lineNum">    5728 </span><span class="lineCov">   55910000 :    }</span></a>
<a name="5729"><span class="lineNum">    5729 </span>            : </a>
<a name="5730"><span class="lineNum">    5730 </span>            : </a>
<a name="5731"><span class="lineNum">    5731 </span>            : </a>
<a name="5732"><span class="lineNum">    5732 </span>            : void</a>
<a name="5733"><span class="lineNum">    5733 </span><span class="lineCov">    5466810 : TestLValueExpressions::visit ( SgNode* node )</span></a>
<a name="5734"><span class="lineNum">    5734 </span>            :    {</a>
<a name="5735"><span class="lineNum">    5735 </span>            :   // DQ (1/12/2008): Test the get_lvalue() member function which is common on expressions.</a>
<a name="5736"><span class="lineNum">    5736 </span>            :   // printf (&quot;In TestLValueExpressions::visit(): node = %s \n&quot;,node-&gt;class_name().c_str());</a>
<a name="5737"><span class="lineNum">    5737 </span>            : </a>
<a name="5738"><span class="lineNum">    5738 </span><span class="lineCov">    5466810 :      SgExpression* expression = isSgExpression(node);</span></a>
<a name="5739"><span class="lineNum">    5739 </span><span class="lineCov">    5466810 :      if (expression != NULL)</span></a>
<a name="5740"><span class="lineNum">    5740 </span>            :         {</a>
<a name="5741"><span class="lineNum">    5741 </span>            : #if 0</a>
<a name="5742"><span class="lineNum">    5742 </span>            :           printf (&quot;TestLValueExpressions::visit(): calling expression-&gt;get_lvalue() on expression = %p = %s \n&quot;,expression,expression-&gt;class_name().c_str());</a>
<a name="5743"><span class="lineNum">    5743 </span>            : #endif</a>
<a name="5744"><span class="lineNum">    5744 </span><span class="lineCov">     209268 :           SgBinaryOp* binaryOperator = isSgBinaryOp(expression);</span></a>
<a name="5745"><span class="lineNum">    5745 </span>            : </a>
<a name="5746"><span class="lineNum">    5746 </span><span class="lineCov">     209268 :           if (binaryOperator != NULL)</span></a>
<a name="5747"><span class="lineNum">    5747 </span>            :              {</a>
<a name="5748"><span class="lineNum">    5748 </span><span class="lineCov">      29987 :                switch (expression-&gt;variantT())</span></a>
<a name="5749"><span class="lineNum">    5749 </span>            :                   {</a>
<a name="5750"><span class="lineNum">    5750 </span>            :                  // IR nodes that have an l-value</a>
<a name="5751"><span class="lineNum">    5751 </span><span class="lineCov">       4345 :                     case V_SgAssignOp:</span></a>
<a name="5752"><span class="lineNum">    5752 </span><span class="lineCov">       4345 :                     case V_SgAndAssignOp:</span></a>
<a name="5753"><span class="lineNum">    5753 </span><span class="lineCov">       4345 :                     case V_SgDivAssignOp:</span></a>
<a name="5754"><span class="lineNum">    5754 </span><span class="lineCov">       4345 :                     case V_SgIorAssignOp:</span></a>
<a name="5755"><span class="lineNum">    5755 </span><span class="lineCov">       4345 :                     case V_SgLshiftAssignOp:</span></a>
<a name="5756"><span class="lineNum">    5756 </span><span class="lineCov">       4345 :                     case V_SgMinusAssignOp:</span></a>
<a name="5757"><span class="lineNum">    5757 </span><span class="lineCov">       4345 :                     case V_SgModAssignOp:</span></a>
<a name="5758"><span class="lineNum">    5758 </span><span class="lineCov">       4345 :                     case V_SgMultAssignOp:</span></a>
<a name="5759"><span class="lineNum">    5759 </span><span class="lineCov">       4345 :                     case V_SgPlusAssignOp:</span></a>
<a name="5760"><span class="lineNum">    5760 </span><span class="lineCov">       4345 :                     case V_SgRshiftAssignOp:</span></a>
<a name="5761"><span class="lineNum">    5761 </span><span class="lineCov">       4345 :                     case V_SgXorAssignOp:</span></a>
<a name="5762"><span class="lineNum">    5762 </span><span class="lineCov">       4345 :                        {</span></a>
<a name="5763"><span class="lineNum">    5763 </span><span class="lineCov">       4345 :                          SgExpression* lhs = binaryOperator-&gt;get_lhs_operand();</span></a>
<a name="5764"><span class="lineNum">    5764 </span><span class="lineCov">       4345 :                          ROSE_ASSERT(lhs != NULL);</span></a>
<a name="5765"><span class="lineNum">    5765 </span>            : </a>
<a name="5766"><span class="lineNum">    5766 </span>            :                       // DQ (1/22/2008): Jeremiah has provided a patch for this.  This used to be violated by the</a>
<a name="5767"><span class="lineNum">    5767 </span>            :                       // ROSE/tests/nonsmoke/functional/roseTests/astInliningTests/pass16.C test code!  This is now violated by</a>
<a name="5768"><span class="lineNum">    5768 </span>            :                       // the ./preTest</a>
<a name="5769"><span class="lineNum">    5769 </span>            :                       // /home/dquinlan/ROSE/NEW_ROSE/tests/nonsmoke/functional/roseTests/programTransformationTests/pass1.C</a>
<a name="5770"><span class="lineNum">    5770 </span>            :                       // test code!</a>
<a name="5771"><span class="lineNum">    5771 </span><span class="lineCov">       4345 :                          if (lhs-&gt;get_lvalue() == false)</span></a>
<a name="5772"><span class="lineNum">    5772 </span>            :                             {</a>
<a name="5773"><span class="lineNum">    5773 </span><span class="lineNoCov">          0 :                               printf (&quot;ERROR (lvalue for Assign operator not marked): for lhs = %p = %s = %s in binary expression = %s \n&quot;,</span></a>
<a name="5774"><span class="lineNum">    5774 </span><span class="lineNoCov">          0 :                                    lhs,lhs-&gt;class_name().c_str(),SageInterface::get_name(lhs).c_str(),expression-&gt;class_name().c_str());</span></a>
<a name="5775"><span class="lineNum">    5775 </span><span class="lineNoCov">          0 :                               binaryOperator-&gt;get_startOfConstruct()-&gt;display(&quot;Error for lhs: lhs-&gt;get_lvalue() == true: debug&quot;);</span></a>
<a name="5776"><span class="lineNum">    5776 </span>            :                             }</a>
<a name="5777"><span class="lineNum">    5777 </span>            : </a>
<a name="5778"><span class="lineNum">    5778 </span>            :                       // I don't want to comment this out, it is always set correctly except in the inlining transformation!</a>
<a name="5779"><span class="lineNum">    5779 </span>            :                       // It now passes the inliner tests, but fails in the</a>
<a name="5780"><span class="lineNum">    5780 </span>            :                       // tests/nonsmoke/functional/roseTests/programTransformationTests, so I have to comment it out again!</a>
<a name="5781"><span class="lineNum">    5781 </span><span class="lineCov">       4345 :                          ROSE_ASSERT(lhs-&gt;get_lvalue() == true);</span></a>
<a name="5782"><span class="lineNum">    5782 </span><span class="lineCov">       4345 :                          break;</span></a>
<a name="5783"><span class="lineNum">    5783 </span>            :                        }</a>
<a name="5784"><span class="lineNum">    5784 </span>            : </a>
<a name="5785"><span class="lineNum">    5785 </span><span class="lineCov">      13506 :                     case V_SgDotExp:</span></a>
<a name="5786"><span class="lineNum">    5786 </span><span class="lineCov">      13506 :                     case V_SgArrowExp:</span></a>
<a name="5787"><span class="lineNum">    5787 </span><span class="lineCov">      13506 :                        {</span></a>
<a name="5788"><span class="lineNum">    5788 </span><span class="lineCov">      13506 :                          SgExpression* lhs = binaryOperator-&gt;get_lhs_operand();</span></a>
<a name="5789"><span class="lineNum">    5789 </span><span class="lineCov">      13506 :                          ROSE_ASSERT(lhs != NULL);</span></a>
<a name="5790"><span class="lineNum">    5790 </span>            : #if WARN_ABOUT_ATYPICAL_LVALUES</a>
<a name="5791"><span class="lineNum">    5791 </span>            :                          printf (&quot;L-value test for SgBinaryOp = %s: not clear how to assert value -- lhs-&gt;get_lvalue() = %s \n&quot;,binaryOperator-&gt;class_name().c_str(),lhs-&gt;get_lvalue() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="5792"><span class="lineNum">    5792 </span>            : #endif</a>
<a name="5793"><span class="lineNum">    5793 </span>            :                       // ROSE_ASSERT(lhs-&gt;get_lvalue() == true);</a>
<a name="5794"><span class="lineNum">    5794 </span><span class="lineCov">      13506 :                          break;</span></a>
<a name="5795"><span class="lineNum">    5795 </span>            :                        }</a>
<a name="5796"><span class="lineNum">    5796 </span>            : </a>
<a name="5797"><span class="lineNum">    5797 </span><span class="lineCov">      12136 :                     default:</span></a>
<a name="5798"><span class="lineNum">    5798 </span><span class="lineCov">      12136 :                        {</span></a>
<a name="5799"><span class="lineNum">    5799 </span>            :                       // Make sure that the lhs is not an L-value</a>
<a name="5800"><span class="lineNum">    5800 </span><span class="lineCov">      12136 :                          SgExpression* lhs = binaryOperator-&gt;get_lhs_operand();</span></a>
<a name="5801"><span class="lineNum">    5801 </span><span class="lineCov">      12136 :                          ROSE_ASSERT(lhs != NULL);</span></a>
<a name="5802"><span class="lineNum">    5802 </span>            : </a>
<a name="5803"><span class="lineNum">    5803 </span>            : #if WARN_ABOUT_ATYPICAL_LVALUES</a>
<a name="5804"><span class="lineNum">    5804 </span>            :                          if (lhs-&gt;get_lvalue() == true)</a>
<a name="5805"><span class="lineNum">    5805 </span>            :                             {</a>
<a name="5806"><span class="lineNum">    5806 </span>            :                               printf (&quot;Error for lhs = %p = %s = %s in binary expression = %s \n&quot;,</a>
<a name="5807"><span class="lineNum">    5807 </span>            :                                    lhs,lhs-&gt;class_name().c_str(),SageInterface::get_name(lhs).c_str(),expression-&gt;class_name().c_str());</a>
<a name="5808"><span class="lineNum">    5808 </span>            :                               binaryOperator-&gt;get_startOfConstruct()-&gt;display(&quot;Error for lhs: lhs-&gt;get_lvalue() == true: debug&quot;);</a>
<a name="5809"><span class="lineNum">    5809 </span>            :                             }</a>
<a name="5810"><span class="lineNum">    5810 </span>            : #endif</a>
<a name="5811"><span class="lineNum">    5811 </span>            :                       // ROSE_ASSERT(lhs-&gt;get_lvalue() == false);</a>
<a name="5812"><span class="lineNum">    5812 </span>            :                        }</a>
<a name="5813"><span class="lineNum">    5813 </span>            :                   }</a>
<a name="5814"><span class="lineNum">    5814 </span>            : </a>
<a name="5815"><span class="lineNum">    5815 </span><span class="lineCov">      29987 :                SgExpression* rhs = binaryOperator-&gt;get_rhs_operand();</span></a>
<a name="5816"><span class="lineNum">    5816 </span><span class="lineCov">      29987 :                ROSE_ASSERT(rhs != NULL);</span></a>
<a name="5817"><span class="lineNum">    5817 </span>            : </a>
<a name="5818"><span class="lineNum">    5818 </span>            : #if WARN_ABOUT_ATYPICAL_LVALUES</a>
<a name="5819"><span class="lineNum">    5819 </span>            :                if (rhs-&gt;get_lvalue() == true)</a>
<a name="5820"><span class="lineNum">    5820 </span>            :                   {</a>
<a name="5821"><span class="lineNum">    5821 </span>            :                     printf (&quot;Error for rhs = %p = %s = %s in binary expression = %s \n&quot;,</a>
<a name="5822"><span class="lineNum">    5822 </span>            :                          rhs,rhs-&gt;class_name().c_str(),SageInterface::get_name(rhs).c_str(),expression-&gt;class_name().c_str());</a>
<a name="5823"><span class="lineNum">    5823 </span>            :                     binaryOperator-&gt;get_startOfConstruct()-&gt;display(&quot;Error for rhs: rhs-&gt;get_lvalue() == true: debug&quot;);</a>
<a name="5824"><span class="lineNum">    5824 </span>            :                   }</a>
<a name="5825"><span class="lineNum">    5825 </span>            : #endif</a>
<a name="5826"><span class="lineNum">    5826 </span>            :             // ROSE_ASSERT(rhs-&gt;get_lvalue() == false);</a>
<a name="5827"><span class="lineNum">    5827 </span>            :              }</a>
<a name="5828"><span class="lineNum">    5828 </span>            : </a>
<a name="5829"><span class="lineNum">    5829 </span><span class="lineCov">     209268 :           SgUnaryOp* unaryOperator = isSgUnaryOp(expression);</span></a>
<a name="5830"><span class="lineNum">    5830 </span><span class="lineCov">     209268 :           if (unaryOperator != NULL)</span></a>
<a name="5831"><span class="lineNum">    5831 </span>            :              {</a>
<a name="5832"><span class="lineNum">    5832 </span><span class="lineCov">      20681 :                switch (expression-&gt;variantT())</span></a>
<a name="5833"><span class="lineNum">    5833 </span>            :                   {</a>
<a name="5834"><span class="lineNum">    5834 </span>            :                  // IR nodes that should have a valid lvalue</a>
<a name="5835"><span class="lineNum">    5835 </span>            :                  // What about SgAddressOfOp?</a>
<a name="5836"><span class="lineNum">    5836 </span>            : </a>
<a name="5837"><span class="lineNum">    5837 </span><span class="lineCov">       1574 :                     case V_SgMinusMinusOp:</span></a>
<a name="5838"><span class="lineNum">    5838 </span><span class="lineCov">       1574 :                     case V_SgPlusPlusOp:</span></a>
<a name="5839"><span class="lineNum">    5839 </span><span class="lineCov">       1574 :                        {</span></a>
<a name="5840"><span class="lineNum">    5840 </span><span class="lineCov">       1574 :                          SgExpression* operand = unaryOperator-&gt;get_operand();</span></a>
<a name="5841"><span class="lineNum">    5841 </span><span class="lineCov">       1574 :                          ROSE_ASSERT(operand != NULL);</span></a>
<a name="5842"><span class="lineNum">    5842 </span>            : </a>
<a name="5843"><span class="lineNum">    5843 </span>            : #if WARN_ABOUT_ATYPICAL_LVALUES</a>
<a name="5844"><span class="lineNum">    5844 </span>            :                          if (operand-&gt;get_lvalue() == false) {</a>
<a name="5845"><span class="lineNum">    5845 </span>            :                               std::cerr &lt;&lt;&quot;Error for operand&quot;</a>
<a name="5846"><span class="lineNum">    5846 </span>            :                                         &lt;&lt;&quot; (&quot; &lt;&lt;operand-&gt;class_name() &lt;&lt;&quot;*)&quot; &lt;&lt;&quot; = &quot; &lt;&lt;SageInterface::get_name(operand)</a>
<a name="5847"><span class="lineNum">    5847 </span>            :                                         &lt;&lt;&quot; in unary &quot; &lt;&lt;expression-&gt;class_name() &lt;&lt;&quot; expression&quot;</a>
<a name="5848"><span class="lineNum">    5848 </span>            :                                         &lt;&lt;&quot;: operand-&gt;get_lvalue() == false but should be true\n&quot;;</a>
<a name="5849"><span class="lineNum">    5849 </span>            :                               std::cerr &lt;&lt;&quot;ancestors of (&quot; &lt;&lt;operand-&gt;class_name() &lt;&lt;&quot;*)&quot; &lt;&lt;operand &lt;&lt;&quot; are:&quot;;</a>
<a name="5850"><span class="lineNum">    5850 </span>            :                               for (SgNode *p=operand-&gt;get_parent(); p; p=p-&gt;get_parent())</a>
<a name="5851"><span class="lineNum">    5851 </span>            :                                   std::cerr &lt;&lt;&quot; (&quot; &lt;&lt;p-&gt;class_name() &lt;&lt;&quot;*)&quot; &lt;&lt;p;</a>
<a name="5852"><span class="lineNum">    5852 </span>            :                               std::cerr &lt;&lt;&quot;\n&quot;;</a>
<a name="5853"><span class="lineNum">    5853 </span>            :                               unaryOperator-&gt;get_startOfConstruct()</a>
<a name="5854"><span class="lineNum">    5854 </span>            :                                   -&gt;display(&quot;Error for operand: operand-&gt;get_lvalue() == false: debug&quot;);</a>
<a name="5855"><span class="lineNum">    5855 </span>            :                          }</a>
<a name="5856"><span class="lineNum">    5856 </span>            : #endif</a>
<a name="5857"><span class="lineNum">    5857 </span><span class="lineCov">       1574 :                          ROSE_ASSERT(operand-&gt;get_lvalue() == true);</span></a>
<a name="5858"><span class="lineNum">    5858 </span><span class="lineCov">       1574 :                          break;</span></a>
<a name="5859"><span class="lineNum">    5859 </span>            :                        }</a>
<a name="5860"><span class="lineNum">    5860 </span>            : </a>
<a name="5861"><span class="lineNum">    5861 </span>            :                     case V_SgThrowOp:</a>
<a name="5862"><span class="lineNum">    5862 </span>            :                        {</a>
<a name="5863"><span class="lineNum">    5863 </span>            : #if WARN_ABOUT_ATYPICAL_LVALUES</a>
<a name="5864"><span class="lineNum">    5864 </span>            :                       // Note that the gnu &quot; __throw_exception_again;&quot; can cause a SgThrowOp to now have an operand!</a>
<a name="5865"><span class="lineNum">    5865 </span>            :                          SgExpression* operand = unaryOperator-&gt;get_operand();</a>
<a name="5866"><span class="lineNum">    5866 </span>            :                          if (operand == NULL)</a>
<a name="5867"><span class="lineNum">    5867 </span>            :                             {</a>
<a name="5868"><span class="lineNum">    5868 </span>            :                               printf (&quot;Warning: operand == NULL in SgUnaryOp = %s (likely caused by __throw_exception_again) \n&quot;,expression-&gt;class_name().c_str());</a>
<a name="5869"><span class="lineNum">    5869 </span>            :                            // unaryOperator-&gt;get_startOfConstruct()-&gt;display(&quot;Error: operand == NULL in SgUnaryOp: debug&quot;);</a>
<a name="5870"><span class="lineNum">    5870 </span>            :                             }</a>
<a name="5871"><span class="lineNum">    5871 </span>            : #endif</a>
<a name="5872"><span class="lineNum">    5872 </span>            :                       // ROSE_ASSERT(operand != NULL);</a>
<a name="5873"><span class="lineNum">    5873 </span>            :                          break;</a>
<a name="5874"><span class="lineNum">    5874 </span>            :                        }</a>
<a name="5875"><span class="lineNum">    5875 </span>            : </a>
<a name="5876"><span class="lineNum">    5876 </span>            :                  // Added to address problem on Qing's machine using g++ 4.0.2</a>
<a name="5877"><span class="lineNum">    5877 </span><span class="lineCov">      18192 :                     case V_SgNotOp:</span></a>
<a name="5878"><span class="lineNum">    5878 </span>            : </a>
<a name="5879"><span class="lineNum">    5879 </span>            :                  // These are where some error occur.  I want to isolate then so that I know the current status of where lvalues are not marked correctly!</a>
<a name="5880"><span class="lineNum">    5880 </span><span class="lineCov">      18192 :                     case V_SgPointerDerefExp:</span></a>
<a name="5881"><span class="lineNum">    5881 </span><span class="lineCov">      18192 :                     case V_SgCastExp:</span></a>
<a name="5882"><span class="lineNum">    5882 </span><span class="lineCov">      18192 :                     case V_SgMinusOp:</span></a>
<a name="5883"><span class="lineNum">    5883 </span><span class="lineCov">      18192 :                     case V_SgBitComplementOp:</span></a>
<a name="5884"><span class="lineNum">    5884 </span>            :                  // case V_SgPlusOp:</a>
<a name="5885"><span class="lineNum">    5885 </span><span class="lineCov">      18192 :                        {</span></a>
<a name="5886"><span class="lineNum">    5886 </span><span class="lineCov">      18192 :                          SgExpression* operand = unaryOperator-&gt;get_operand();</span></a>
<a name="5887"><span class="lineNum">    5887 </span><span class="lineCov">      18192 :                          ROSE_ASSERT(operand != NULL);</span></a>
<a name="5888"><span class="lineNum">    5888 </span>            : </a>
<a name="5889"><span class="lineNum">    5889 </span>            : #if WARN_ABOUT_ATYPICAL_LVALUES</a>
<a name="5890"><span class="lineNum">    5890 </span>            :                       // Most of the time this is false, we only want to know when it is true</a>
<a name="5891"><span class="lineNum">    5891 </span>            :                          if (operand-&gt;get_lvalue() == true)</a>
<a name="5892"><span class="lineNum">    5892 </span>            :                             {</a>
<a name="5893"><span class="lineNum">    5893 </span>            :                               printf (&quot;L-value test for SgUnaryOp = %s: not clear how to assert value -- operand-&gt;get_lvalue() = %s \n&quot;,unaryOperator-&gt;class_name().c_str(),operand-&gt;get_lvalue() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="5894"><span class="lineNum">    5894 </span>            :                            // unaryOperator-&gt;get_startOfConstruct()-&gt;display(&quot;L-value test for SgUnaryOp: operand-&gt;get_lvalue() == true: debug&quot;);</a>
<a name="5895"><span class="lineNum">    5895 </span>            :                             }</a>
<a name="5896"><span class="lineNum">    5896 </span>            : #endif</a>
<a name="5897"><span class="lineNum">    5897 </span>            :                       // ROSE_ASSERT(operand-&gt;get_lvalue() == false);</a>
<a name="5898"><span class="lineNum">    5898 </span><span class="lineCov">      18192 :                          break;</span></a>
<a name="5899"><span class="lineNum">    5899 </span>            :                        }</a>
<a name="5900"><span class="lineNum">    5900 </span>            : </a>
<a name="5901"><span class="lineNum">    5901 </span><span class="lineCov">        576 :                     default:</span></a>
<a name="5902"><span class="lineNum">    5902 </span><span class="lineCov">        576 :                        {</span></a>
<a name="5903"><span class="lineNum">    5903 </span><span class="lineCov">        576 :                          SgExpression* operand = unaryOperator-&gt;get_operand();</span></a>
<a name="5904"><span class="lineNum">    5904 </span><span class="lineCov">        576 :                          ROSE_ASSERT(operand != NULL);</span></a>
<a name="5905"><span class="lineNum">    5905 </span>            : </a>
<a name="5906"><span class="lineNum">    5906 </span>            : #if WARN_ABOUT_ATYPICAL_LVALUES</a>
<a name="5907"><span class="lineNum">    5907 </span>            :                          if (operand-&gt;get_lvalue() == true)</a>
<a name="5908"><span class="lineNum">    5908 </span>            :                             {</a>
<a name="5909"><span class="lineNum">    5909 </span>            :                               printf (&quot;Error for operand = %p = %s = %s in unary expression = %s \n&quot;,</a>
<a name="5910"><span class="lineNum">    5910 </span>            :                                    operand,operand-&gt;class_name().c_str(),SageInterface::get_name(operand).c_str(),expression-&gt;class_name().c_str());</a>
<a name="5911"><span class="lineNum">    5911 </span>            :                               unaryOperator-&gt;get_startOfConstruct()-&gt;display(&quot;Error for operand: operand-&gt;get_lvalue() == true: debug&quot;);</a>
<a name="5912"><span class="lineNum">    5912 </span>            :                             }</a>
<a name="5913"><span class="lineNum">    5913 </span>            : #endif</a>
<a name="5914"><span class="lineNum">    5914 </span><span class="lineCov">        576 :                          ROSE_ASSERT(operand-&gt;get_lvalue() == false);</span></a>
<a name="5915"><span class="lineNum">    5915 </span>            :                        }</a>
<a name="5916"><span class="lineNum">    5916 </span>            :                   }</a>
<a name="5917"><span class="lineNum">    5917 </span>            :              }</a>
<a name="5918"><span class="lineNum">    5918 </span>            :         }</a>
<a name="5919"><span class="lineNum">    5919 </span><span class="lineCov">    5466810 :    }</span></a>
<a name="5920"><span class="lineNum">    5920 </span>            : </a>
<a name="5921"><span class="lineNum">    5921 </span>            : </a>
<a name="5922"><span class="lineNum">    5922 </span>            : </a>
<a name="5923"><span class="lineNum">    5923 </span>            : </a>
<a name="5924"><span class="lineNum">    5924 </span>            : void</a>
<a name="5925"><span class="lineNum">    5925 </span><span class="lineCov">        326 : TestMultiFileConsistancy::test()</span></a>
<a name="5926"><span class="lineNum">    5926 </span>            :    {</a>
<a name="5927"><span class="lineNum">    5927 </span>            :   // DQ (2/23/2009): Note that AST Merge might fail this test...</a>
<a name="5928"><span class="lineNum">    5928 </span>            : </a>
<a name="5929"><span class="lineNum">    5929 </span><span class="lineCov">        326 :      if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL )</span></a>
<a name="5930"><span class="lineNum">    5930 </span><span class="lineNoCov">          0 :           cout &lt;&lt; &quot;Test declarations for file consistancy (tests outlining in a separate file) started.&quot; &lt;&lt; endl;</span></a>
<a name="5931"><span class="lineNum">    5931 </span>            : </a>
<a name="5932"><span class="lineNum">    5932 </span><span class="lineCov">        326 :         {</span></a>
<a name="5933"><span class="lineNum">    5933 </span><span class="lineCov">        326 :           TimingPerformance timer (&quot;Test declarations for file consistancy:&quot;);</span></a>
<a name="5934"><span class="lineNum">    5934 </span>            : </a>
<a name="5935"><span class="lineNum">    5935 </span><span class="lineCov">        326 :           TestMultiFileConsistancy t;</span></a>
<a name="5936"><span class="lineNum">    5936 </span><span class="lineCov">        652 :           t.traverseMemoryPool();</span></a>
<a name="5937"><span class="lineNum">    5937 </span>            :         }</a>
<a name="5938"><span class="lineNum">    5938 </span>            : </a>
<a name="5939"><span class="lineNum">    5939 </span><span class="lineCov">        326 :      if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL )</span></a>
<a name="5940"><span class="lineNum">    5940 </span><span class="lineNoCov">          0 :           cout &lt;&lt; &quot;Test declarations for file consistancy finished.&quot; &lt;&lt; endl;</span></a>
<a name="5941"><span class="lineNum">    5941 </span><span class="lineCov">        326 :    }</span></a>
<a name="5942"><span class="lineNum">    5942 </span>            : </a>
<a name="5943"><span class="lineNum">    5943 </span>            : </a>
<a name="5944"><span class="lineNum">    5944 </span>            : void</a>
<a name="5945"><span class="lineNum">    5945 </span><span class="lineCov">   55910000 : TestMultiFileConsistancy::visit( SgNode* node)</span></a>
<a name="5946"><span class="lineNum">    5946 </span>            :    {</a>
<a name="5947"><span class="lineNum">    5947 </span>            :   // TV (09/15/2018): Nothing really happens in there anymore. Commented everything out as &quot;declaration-&gt;get_scope() != NULL&quot; fails for some non-real declarations</a>
<a name="5948"><span class="lineNum">    5948 </span>            : #if 0</a>
<a name="5949"><span class="lineNum">    5949 </span>            :   // DQ (2/23/2009): added testing to support outlining to a separate file.</a>
<a name="5950"><span class="lineNum">    5950 </span>            :   // This test is helpful for the outlining to a separate file, where we want to make sure</a>
<a name="5951"><span class="lineNum">    5951 </span>            :   // that the transformations required do not build a locally inconsistant AST for each file.</a>
<a name="5952"><span class="lineNum">    5952 </span>            :      SgDeclarationStatement* declaration = isSgDeclarationStatement(node);</a>
<a name="5953"><span class="lineNum">    5953 </span>            : </a>
<a name="5954"><span class="lineNum">    5954 </span>            :      if (declaration != NULL)</a>
<a name="5955"><span class="lineNum">    5955 </span>            :         {</a>
<a name="5956"><span class="lineNum">    5956 </span>            :           SgDeclarationStatement* firstDefiningDeclaration = declaration-&gt;get_firstNondefiningDeclaration();</a>
<a name="5957"><span class="lineNum">    5957 </span>            : #if 1</a>
<a name="5958"><span class="lineNum">    5958 </span>            :           ROSE_ASSERT(declaration != NULL);</a>
<a name="5959"><span class="lineNum">    5959 </span>            :        // ROSE_ASSERT(declaration-&gt;get_firstNondefiningDeclaration() != NULL);</a>
<a name="5960"><span class="lineNum">    5960 </span>            :           if (firstDefiningDeclaration != NULL)</a>
<a name="5961"><span class="lineNum">    5961 </span>            :              {</a>
<a name="5962"><span class="lineNum">    5962 </span>            :                ROSE_ASSERT(declaration-&gt;get_scope() != NULL);</a>
<a name="5963"><span class="lineNum">    5963 </span>            :                SgSourceFile* declarationFile              = TransformationSupport::getSourceFile(declaration);</a>
<a name="5964"><span class="lineNum">    5964 </span>            :                SgSourceFile* declarationScopeFile         = TransformationSupport::getSourceFile(declaration-&gt;get_scope());</a>
<a name="5965"><span class="lineNum">    5965 </span>            :                SgSourceFile* firstDefiningDeclarationFile = TransformationSupport::getSourceFile(firstDefiningDeclaration);</a>
<a name="5966"><span class="lineNum">    5966 </span>            :                if (declarationScopeFile != firstDefiningDeclarationFile || declarationFile != firstDefiningDeclarationFile)</a>
<a name="5967"><span class="lineNum">    5967 </span>            :                   {</a>
<a name="5968"><span class="lineNum">    5968 </span>            : #if 0</a>
<a name="5969"><span class="lineNum">    5969 </span>            :                  // DQ (3/4/2009): Supporess the output here so we can pass the tests in tests/nonsmoke/functional/CompilerOptionsTests/testForSpuriousOutput</a>
<a name="5970"><span class="lineNum">    5970 </span>            :                     printf (&quot;TestMultiFileConsistancy::visit(): declaration              = %p = %s = %s \n&quot;,declaration,declaration-&gt;class_name().c_str(),SageInterface::get_name(declaration).c_str());</a>
<a name="5971"><span class="lineNum">    5971 </span>            :                     printf (&quot;TestMultiFileConsistancy::visit(): declaration-&gt;get_scope() = %p = %s = %s \n&quot;,declaration-&gt;get_scope(),declaration-&gt;get_scope()-&gt;class_name().c_str(),SageInterface::get_name(declaration-&gt;get_scope()).c_str());</a>
<a name="5972"><span class="lineNum">    5972 </span>            :                     printf (&quot;TestMultiFileConsistancy::visit(): firstDefiningDeclaration = %p = %s = %s \n&quot;,firstDefiningDeclaration,firstDefiningDeclaration-&gt;class_name().c_str(),SageInterface::get_name(firstDefiningDeclaration).c_str());</a>
<a name="5973"><span class="lineNum">    5973 </span>            :                     printf (&quot;TestMultiFileConsistancy::visit(): firstDefiningDeclaration = %p = %s = %s \n&quot;,firstDefiningDeclaration,firstDefiningDeclaration-&gt;class_name().c_str(),SageInterface::get_name(firstDefiningDeclaration).c_str());</a>
<a name="5974"><span class="lineNum">    5974 </span>            : </a>
<a name="5975"><span class="lineNum">    5975 </span>            :                  // DQ (3/3/2009): Some template arguments are setting off these new tests (e.g. test2004_35.C), need to look into this.</a>
<a name="5976"><span class="lineNum">    5976 </span>            :                     if (declarationFile != NULL)</a>
<a name="5977"><span class="lineNum">    5977 </span>            :                          printf (&quot;TestMultiFileConsistancy::visit(): declarationFile              = %p = %s = %s \n&quot;,declarationFile,declarationFile-&gt;class_name().c_str(),SageInterface::get_name(declarationFile).c_str());</a>
<a name="5978"><span class="lineNum">    5978 </span>            :                     if (declarationScopeFile != NULL)</a>
<a name="5979"><span class="lineNum">    5979 </span>            :                          printf (&quot;TestMultiFileConsistancy::visit(): declarationScopeFile         = %p = %s = %s \n&quot;,declarationScopeFile,declarationScopeFile-&gt;class_name().c_str(),SageInterface::get_name(declarationScopeFile).c_str());</a>
<a name="5980"><span class="lineNum">    5980 </span>            :                     if (firstDefiningDeclarationFile != NULL)</a>
<a name="5981"><span class="lineNum">    5981 </span>            :                          printf (&quot;TestMultiFileConsistancy::visit(): firstDefiningDeclarationFile = %p = %s = %s \n&quot;,firstDefiningDeclarationFile,firstDefiningDeclarationFile-&gt;class_name().c_str(),SageInterface::get_name(firstDefiningDeclarationFile).c_str());</a>
<a name="5982"><span class="lineNum">    5982 </span>            : #endif</a>
<a name="5983"><span class="lineNum">    5983 </span>            :                   }</a>
<a name="5984"><span class="lineNum">    5984 </span>            : #if 0</a>
<a name="5985"><span class="lineNum">    5985 </span>            :             // DQ (3/3/2009): Some template arguments are setting off these new tests (e.g. test2004_35.C), need to look into this.</a>
<a name="5986"><span class="lineNum">    5986 </span>            :                ROSE_ASSERT(declarationFile == firstDefiningDeclarationFile);</a>
<a name="5987"><span class="lineNum">    5987 </span>            : </a>
<a name="5988"><span class="lineNum">    5988 </span>            :             // DQ (3/3/2009): Some template arguments are setting off these new tests (e.g. test2004_35.C), need to look into this.</a>
<a name="5989"><span class="lineNum">    5989 </span>            :                if (firstDefiningDeclarationFile != NULL)</a>
<a name="5990"><span class="lineNum">    5990 </span>            :                     ROSE_ASSERT(declarationScopeFile == firstDefiningDeclarationFile);</a>
<a name="5991"><span class="lineNum">    5991 </span>            : #endif</a>
<a name="5992"><span class="lineNum">    5992 </span>            :              }</a>
<a name="5993"><span class="lineNum">    5993 </span>            : #if 0</a>
<a name="5994"><span class="lineNum">    5994 </span>            :        // DQ (3/3/2009): Some template arguments are setting off these new tests (e.g. test2004_35.C), need to look into this.</a>
<a name="5995"><span class="lineNum">    5995 </span>            :           if (firstDefiningDeclaration != NULL)</a>
<a name="5996"><span class="lineNum">    5996 </span>            :              {</a>
<a name="5997"><span class="lineNum">    5997 </span>            :                ROSE_ASSERT(TransformationSupport::getSourceFile(firstDefiningDeclaration) == TransformationSupport::getSourceFile(firstDefiningDeclaration-&gt;get_firstNondefiningDeclaration()));</a>
<a name="5998"><span class="lineNum">    5998 </span>            :                ROSE_ASSERT(TransformationSupport::getSourceFile(firstDefiningDeclaration-&gt;get_scope()) == TransformationSupport::getSourceFile(firstDefiningDeclaration-&gt;get_firstNondefiningDeclaration()));</a>
<a name="5999"><span class="lineNum">    5999 </span>            :              }</a>
<a name="6000"><span class="lineNum">    6000 </span>            : #endif</a>
<a name="6001"><span class="lineNum">    6001 </span>            : #if 0</a>
<a name="6002"><span class="lineNum">    6002 </span>            :        // DQ (3/3/2009): Some template arguments are setting off these new tests (e.g. test2004_35.C), need to look into this.</a>
<a name="6003"><span class="lineNum">    6003 </span>            :           SgDeclarationStatement* definingDeclaration      = declaration-&gt;get_definingDeclaration();</a>
<a name="6004"><span class="lineNum">    6004 </span>            :           if (definingDeclaration != NULL)</a>
<a name="6005"><span class="lineNum">    6005 </span>            :              {</a>
<a name="6006"><span class="lineNum">    6006 </span>            :                SgDeclarationStatement* alt_firstDefiningDeclaration = definingDeclaration-&gt;get_firstNondefiningDeclaration();</a>
<a name="6007"><span class="lineNum">    6007 </span>            :                if (alt_firstDefiningDeclaration != NULL)</a>
<a name="6008"><span class="lineNum">    6008 </span>            :                   {</a>
<a name="6009"><span class="lineNum">    6009 </span>            :                     ROSE_ASSERT(TransformationSupport::getSourceFile(definingDeclaration) == TransformationSupport::getSourceFile(definingDeclaration-&gt;get_firstNondefiningDeclaration()));</a>
<a name="6010"><span class="lineNum">    6010 </span>            :                     ROSE_ASSERT(TransformationSupport::getSourceFile(definingDeclaration-&gt;get_scope()) == TransformationSupport::getSourceFile(definingDeclaration-&gt;get_firstNondefiningDeclaration()));</a>
<a name="6011"><span class="lineNum">    6011 </span>            : </a>
<a name="6012"><span class="lineNum">    6012 </span>            :                     ROSE_ASSERT(TransformationSupport::getSourceFile(alt_firstDefiningDeclaration) == TransformationSupport::getSourceFile(alt_firstDefiningDeclaration-&gt;get_firstNondefiningDeclaration()));</a>
<a name="6013"><span class="lineNum">    6013 </span>            :                     ROSE_ASSERT(TransformationSupport::getSourceFile(alt_firstDefiningDeclaration-&gt;get_scope()) == TransformationSupport::getSourceFile(alt_firstDefiningDeclaration-&gt;get_firstNondefiningDeclaration()));</a>
<a name="6014"><span class="lineNum">    6014 </span>            :                   }</a>
<a name="6015"><span class="lineNum">    6015 </span>            :              }</a>
<a name="6016"><span class="lineNum">    6016 </span>            : #endif</a>
<a name="6017"><span class="lineNum">    6017 </span>            : #endif</a>
<a name="6018"><span class="lineNum">    6018 </span>            :         }</a>
<a name="6019"><span class="lineNum">    6019 </span>            : #endif</a>
<a name="6020"><span class="lineNum">    6020 </span><span class="lineCov">   55910000 :    }</span></a>
<a name="6021"><span class="lineNum">    6021 </span>            : </a>
<a name="6022"><span class="lineNum">    6022 </span>            : </a>
<a name="6023"><span class="lineNum">    6023 </span>            : </a>
<a name="6024"><span class="lineNum">    6024 </span><span class="lineNoCov">          0 : BuildListOfConnectedNodesInAST::BuildListOfConnectedNodesInAST(set&lt;SgNode*&gt; &amp; s)</span></a>
<a name="6025"><span class="lineNum">    6025 </span><span class="lineNoCov">          0 :    : nodeSet(s)</span></a>
<a name="6026"><span class="lineNum">    6026 </span>            :    {</a>
<a name="6027"><span class="lineNum">    6027 </span><span class="lineNoCov">          0 :    }</span></a>
<a name="6028"><span class="lineNum">    6028 </span>            : </a>
<a name="6029"><span class="lineNum">    6029 </span>            : void</a>
<a name="6030"><span class="lineNum">    6030 </span><span class="lineNoCov">          0 : BuildListOfConnectedNodesInAST::visit(SgNode * node)</span></a>
<a name="6031"><span class="lineNum">    6031 </span>            :    {</a>
<a name="6032"><span class="lineNum">    6032 </span>            :   // printf (&quot;Node = %p = %s \n&quot;,node,node-&gt;class_name().c_str());</a>
<a name="6033"><span class="lineNum">    6033 </span>            : </a>
<a name="6034"><span class="lineNum">    6034 </span><span class="lineNoCov">          0 :      if (nodeSet.find(node) == nodeSet.end())</span></a>
<a name="6035"><span class="lineNum">    6035 </span>            :         {</a>
<a name="6036"><span class="lineNum">    6036 </span>            :        // Not found in the set, add to the set and call visit function on all children.</a>
<a name="6037"><span class="lineNum">    6037 </span>            : #if 0</a>
<a name="6038"><span class="lineNum">    6038 </span>            :           printf (&quot;Adding to nodeSet = %p = %s \n&quot;,node,node-&gt;class_name().c_str());</a>
<a name="6039"><span class="lineNum">    6039 </span>            : #endif</a>
<a name="6040"><span class="lineNum">    6040 </span><span class="lineNoCov">          0 :           nodeSet.insert(node);</span></a>
<a name="6041"><span class="lineNum">    6041 </span>            : </a>
<a name="6042"><span class="lineNum">    6042 </span><span class="lineNoCov">          0 :           typedef vector&lt;pair&lt;SgNode*,string&gt; &gt; DataMemberMapType;</span></a>
<a name="6043"><span class="lineNum">    6043 </span><span class="lineNoCov">          0 :           DataMemberMapType dataMemberMap = node-&gt;returnDataMemberPointers();</span></a>
<a name="6044"><span class="lineNum">    6044 </span>            : </a>
<a name="6045"><span class="lineNum">    6045 </span><span class="lineNoCov">          0 :           DataMemberMapType::iterator i = dataMemberMap.begin();</span></a>
<a name="6046"><span class="lineNum">    6046 </span><span class="lineNoCov">          0 :           while (i != dataMemberMap.end())</span></a>
<a name="6047"><span class="lineNum">    6047 </span>            :              {</a>
<a name="6048"><span class="lineNum">    6048 </span>            :             // Ignore the parent pointer since it will be reset differently if required</a>
<a name="6049"><span class="lineNum">    6049 </span><span class="lineNoCov">          0 :                SgNode* childPointer = i-&gt;first;</span></a>
<a name="6050"><span class="lineNum">    6050 </span><span class="lineNoCov">          0 :                string  debugString  = i-&gt;second;</span></a>
<a name="6051"><span class="lineNum">    6051 </span>            : </a>
<a name="6052"><span class="lineNum">    6052 </span><span class="lineNoCov">          0 :                if (childPointer != NULL)</span></a>
<a name="6053"><span class="lineNum">    6053 </span>            :                   {</a>
<a name="6054"><span class="lineNum">    6054 </span>            :                  // printf (&quot;visit node = %p = %s on edge %s found child %p = %s \n&quot;,node,node-&gt;class_name().c_str(),debugString.c_str(),childPointer,childPointer-&gt;class_name().c_str());</a>
<a name="6055"><span class="lineNum">    6055 </span>            : </a>
<a name="6056"><span class="lineNum">    6056 </span>            :                  // Make the recursive call</a>
<a name="6057"><span class="lineNum">    6057 </span><span class="lineNoCov">          0 :                     visit(childPointer);</span></a>
<a name="6058"><span class="lineNum">    6058 </span>            : </a>
<a name="6059"><span class="lineNum">    6059 </span><span class="lineNoCov">          0 :                     SgLocatedNode* locatedNode = isSgLocatedNode(childPointer);</span></a>
<a name="6060"><span class="lineNum">    6060 </span><span class="lineNoCov">          0 :                     if (locatedNode != NULL)</span></a>
<a name="6061"><span class="lineNum">    6061 </span>            :                        {</a>
<a name="6062"><span class="lineNum">    6062 </span><span class="lineNoCov">          0 :                          AttachedPreprocessingInfoType* comments = locatedNode-&gt;getAttachedPreprocessingInfo();</span></a>
<a name="6063"><span class="lineNum">    6063 </span>            : </a>
<a name="6064"><span class="lineNum">    6064 </span><span class="lineNoCov">          0 :                          if (comments != NULL)</span></a>
<a name="6065"><span class="lineNum">    6065 </span>            :                             {</a>
<a name="6066"><span class="lineNum">    6066 </span>            :                            // printf (&quot;Found attached comments (at %p of type: %s): \n&quot;,locatedNode,locatedNode-&gt;sage_class_name());</a>
<a name="6067"><span class="lineNum">    6067 </span><span class="lineNoCov">          0 :                               AttachedPreprocessingInfoType::iterator i;</span></a>
<a name="6068"><span class="lineNum">    6068 </span><span class="lineNoCov">          0 :                               for (i = comments-&gt;begin(); i != comments-&gt;end(); i++)</span></a>
<a name="6069"><span class="lineNum">    6069 </span>            :                                  {</a>
<a name="6070"><span class="lineNum">    6070 </span><span class="lineNoCov">          0 :                                    ROSE_ASSERT ( (*i) != NULL );</span></a>
<a name="6071"><span class="lineNum">    6071 </span><span class="lineNoCov">          0 :                                    visit((*i)-&gt;get_file_info());</span></a>
<a name="6072"><span class="lineNum">    6072 </span>            : </a>
<a name="6073"><span class="lineNum">    6073 </span>            : #if 0</a>
<a name="6074"><span class="lineNum">    6074 </span>            :                                    printf (&quot;          Attached Comment (relativePosition=%s): %s\n&quot;,</a>
<a name="6075"><span class="lineNum">    6075 </span>            :                                         ((*i)-&gt;getRelativePosition() == PreprocessingInfo::before) ? &quot;before&quot; : &quot;after&quot;,</a>
<a name="6076"><span class="lineNum">    6076 </span>            :                                         (*i)-&gt;getString().c_str());</a>
<a name="6077"><span class="lineNum">    6077 </span>            :                                    printf (&quot;Comment/Directive getNumberOfLines = %d getColumnNumberOfEndOfString = %d \n&quot;,(*i)-&gt;getNumberOfLines(),(*i)-&gt;getColumnNumberOfEndOfString());</a>
<a name="6078"><span class="lineNum">    6078 </span>            :                                         (*i)-&gt;get_file_info()-&gt;display(&quot;comment/directive location&quot;);</a>
<a name="6079"><span class="lineNum">    6079 </span>            : #endif</a>
<a name="6080"><span class="lineNum">    6080 </span>            :                                  }</a>
<a name="6081"><span class="lineNum">    6081 </span>            :                             }</a>
<a name="6082"><span class="lineNum">    6082 </span>            :                        }</a>
<a name="6083"><span class="lineNum">    6083 </span>            :                   }</a>
<a name="6084"><span class="lineNum">    6084 </span><span class="lineNoCov">          0 :                i++;</span></a>
<a name="6085"><span class="lineNum">    6085 </span>            :              }</a>
<a name="6086"><span class="lineNum">    6086 </span>            :         }</a>
<a name="6087"><span class="lineNum">    6087 </span>            :        else</a>
<a name="6088"><span class="lineNum">    6088 </span>            :         {</a>
<a name="6089"><span class="lineNum">    6089 </span>            :        // Found in the set, nothing to do.</a>
<a name="6090"><span class="lineNum">    6090 </span>            :         }</a>
<a name="6091"><span class="lineNum">    6091 </span><span class="lineNoCov">          0 :    }</span></a>
<a name="6092"><span class="lineNum">    6092 </span>            : </a>
<a name="6093"><span class="lineNum">    6093 </span><span class="lineNoCov">          0 : BuildListOfNodesInAST::BuildListOfNodesInAST(const set&lt;SgNode*&gt; &amp; s1, set&lt;SgNode*&gt; &amp; s2)</span></a>
<a name="6094"><span class="lineNum">    6094 </span><span class="lineNoCov">          0 :    : constNodeSet(s1), nodeSet(s2)</span></a>
<a name="6095"><span class="lineNum">    6095 </span>            :    {</a>
<a name="6096"><span class="lineNum">    6096 </span><span class="lineNoCov">          0 :    }</span></a>
<a name="6097"><span class="lineNum">    6097 </span>            : </a>
<a name="6098"><span class="lineNum">    6098 </span>            : void</a>
<a name="6099"><span class="lineNum">    6099 </span><span class="lineNoCov">          0 : BuildListOfNodesInAST::visit(SgNode * node)</span></a>
<a name="6100"><span class="lineNum">    6100 </span>            :    {</a>
<a name="6101"><span class="lineNum">    6101 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(node != NULL);</span></a>
<a name="6102"><span class="lineNum">    6102 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(nodeSet.find(node) == nodeSet.end());</span></a>
<a name="6103"><span class="lineNum">    6103 </span>            : </a>
<a name="6104"><span class="lineNum">    6104 </span><span class="lineNoCov">          0 :      if (constNodeSet.find(node) == constNodeSet.end())</span></a>
<a name="6105"><span class="lineNum">    6105 </span>            :         {</a>
<a name="6106"><span class="lineNum">    6106 </span><span class="lineNoCov">          0 :           SgNode* parent = node-&gt;get_parent();</span></a>
<a name="6107"><span class="lineNum">    6107 </span><span class="lineNoCov">          0 :           string parentName = parent == NULL ? &quot;null&quot; : parent-&gt;class_name();</span></a>
<a name="6108"><span class="lineNum">    6108 </span>            : </a>
<a name="6109"><span class="lineNum">    6109 </span><span class="lineNoCov">          0 :           printf (&quot;Node not found %p = %s (parent = %p = %s)\n&quot;,node,node-&gt;class_name().c_str(),parent,parentName.c_str());</span></a>
<a name="6110"><span class="lineNum">    6110 </span>            : </a>
<a name="6111"><span class="lineNum">    6111 </span>            : #if 1</a>
<a name="6112"><span class="lineNum">    6112 </span><span class="lineNoCov">          0 :           Sg_File_Info* fileInfo = isSg_File_Info(node);</span></a>
<a name="6113"><span class="lineNum">    6113 </span><span class="lineNoCov">          0 :           if (fileInfo != NULL)</span></a>
<a name="6114"><span class="lineNum">    6114 </span>            :              {</a>
<a name="6115"><span class="lineNum">    6115 </span>            :             // This will help us know where this came from.</a>
<a name="6116"><span class="lineNum">    6116 </span><span class="lineNoCov">          0 :                fileInfo-&gt;display(&quot;Node disconected from AST&quot;);</span></a>
<a name="6117"><span class="lineNum">    6117 </span>            :              }</a>
<a name="6118"><span class="lineNum">    6118 </span>            : #endif</a>
<a name="6119"><span class="lineNum">    6119 </span><span class="lineNoCov">          0 :           printf (&quot;Deleting %p = %s (parent = %p = %s)\n&quot;,node,node-&gt;class_name().c_str(),parent,parentName.c_str());</span></a>
<a name="6120"><span class="lineNum">    6120 </span><span class="lineNoCov">          0 :           delete node;</span></a>
<a name="6121"><span class="lineNum">    6121 </span>            :         }</a>
<a name="6122"><span class="lineNum">    6122 </span>            : </a>
<a name="6123"><span class="lineNum">    6123 </span><span class="lineNoCov">          0 :      nodeSet.insert(node);</span></a>
<a name="6124"><span class="lineNum">    6124 </span><span class="lineNoCov">          0 :    }</span></a>
<a name="6125"><span class="lineNum">    6125 </span>            : </a>
<a name="6126"><span class="lineNum">    6126 </span>            : void</a>
<a name="6127"><span class="lineNum">    6127 </span><span class="lineNoCov">          0 : TestForDisconnectedAST::test(SgNode * node)</span></a>
<a name="6128"><span class="lineNum">    6128 </span>            :    {</a>
<a name="6129"><span class="lineNum">    6129 </span>            :   // DQ (3/7/2010): Identify the fragments of the AST that are disconnected.</a>
<a name="6130"><span class="lineNum">    6130 </span>            : </a>
<a name="6131"><span class="lineNum">    6131 </span><span class="lineNoCov">          0 :      if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL )</span></a>
<a name="6132"><span class="lineNum">    6132 </span><span class="lineNoCov">          0 :           cout &lt;&lt; &quot;Test declarations for disconnected parts of the AST started.&quot; &lt;&lt; endl;</span></a>
<a name="6133"><span class="lineNum">    6133 </span>            : </a>
<a name="6134"><span class="lineNum">    6134 </span><span class="lineNoCov">          0 :      set&lt;SgNode*&gt; AST_set;</span></a>
<a name="6135"><span class="lineNum">    6135 </span><span class="lineNoCov">          0 :      set&lt;SgNode*&gt; All_IR_Nodes_set;</span></a>
<a name="6136"><span class="lineNum">    6136 </span>            : </a>
<a name="6137"><span class="lineNum">    6137 </span><span class="lineNoCov">          0 :         {</span></a>
<a name="6138"><span class="lineNum">    6138 </span><span class="lineNoCov">          0 :           TimingPerformance timer (&quot;Test for disconnected parts of the AST:&quot;);</span></a>
<a name="6139"><span class="lineNum">    6139 </span>            : </a>
<a name="6140"><span class="lineNum">    6140 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="6141"><span class="lineNum">    6141 </span><span class="lineNoCov">          0 :                TimingPerformance timer (&quot;Test for disconnected parts of the AST:&quot;);</span></a>
<a name="6142"><span class="lineNum">    6142 </span>            : </a>
<a name="6143"><span class="lineNum">    6143 </span><span class="lineNoCov">          0 :                BuildListOfConnectedNodesInAST t1 (AST_set);</span></a>
<a name="6144"><span class="lineNum">    6144 </span>            : </a>
<a name="6145"><span class="lineNum">    6145 </span>            :             // Traverse the global function type table to preload the AST_set</a>
<a name="6146"><span class="lineNum">    6146 </span><span class="lineNoCov">          0 :                t1.visit(SgNode::get_globalFunctionTypeTable()); // SgFunctionTypeTable</span></a>
<a name="6147"><span class="lineNum">    6147 </span>            : </a>
<a name="6148"><span class="lineNum">    6148 </span><span class="lineNoCov">          0 :                t1.traverse(node,preorder);</span></a>
<a name="6149"><span class="lineNum">    6149 </span>            :              }</a>
<a name="6150"><span class="lineNum">    6150 </span>            : </a>
<a name="6151"><span class="lineNum">    6151 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="6152"><span class="lineNum">    6152 </span><span class="lineNoCov">          0 :                TimingPerformance timer (&quot;Test for disconnected parts of the AST:&quot;);</span></a>
<a name="6153"><span class="lineNum">    6153 </span>            : </a>
<a name="6154"><span class="lineNum">    6154 </span><span class="lineNoCov">          0 :                BuildListOfNodesInAST t1(AST_set,All_IR_Nodes_set);</span></a>
<a name="6155"><span class="lineNum">    6155 </span><span class="lineNoCov">          0 :                t1.traverseMemoryPool();</span></a>
<a name="6156"><span class="lineNum">    6156 </span>            :              }</a>
<a name="6157"><span class="lineNum">    6157 </span>            : </a>
<a name="6158"><span class="lineNum">    6158 </span><span class="lineNoCov">          0 :           if (AST_set.size() != All_IR_Nodes_set.size())</span></a>
<a name="6159"><span class="lineNum">    6159 </span>            :              {</a>
<a name="6160"><span class="lineNum">    6160 </span><span class="lineNoCov">          0 :                printf (&quot;AST_set          = %&quot; PRIuPTR &quot; \n&quot;,AST_set.size());</span></a>
<a name="6161"><span class="lineNum">    6161 </span><span class="lineNoCov">          0 :                printf (&quot;All_IR_Nodes_set = %&quot; PRIuPTR &quot; \n&quot;,All_IR_Nodes_set.size());</span></a>
<a name="6162"><span class="lineNum">    6162 </span>            :              }</a>
<a name="6163"><span class="lineNum">    6163 </span>            :         }</a>
<a name="6164"><span class="lineNum">    6164 </span>            : </a>
<a name="6165"><span class="lineNum">    6165 </span><span class="lineNoCov">          0 :      if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL )</span></a>
<a name="6166"><span class="lineNum">    6166 </span><span class="lineNoCov">          0 :           cout &lt;&lt; &quot;Test declarations for disconnected parts of the AST finished.&quot; &lt;&lt; endl;</span></a>
<a name="6167"><span class="lineNum">    6167 </span><span class="lineNoCov">          0 :    }</span></a>
<a name="6168"><span class="lineNum">    6168 </span>            : </a>
<a name="6169"><span class="lineNum">    6169 </span>            : </a>
<a name="6170"><span class="lineNum">    6170 </span>            : void</a>
<a name="6171"><span class="lineNum">    6171 </span><span class="lineNoCov">          0 : MemoryCheckingTraversalForAstFileIO::visit ( SgNode* node )</span></a>
<a name="6172"><span class="lineNum">    6172 </span>            :    {</a>
<a name="6173"><span class="lineNum">    6173 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(node != NULL);</span></a>
<a name="6174"><span class="lineNum">    6174 </span>            :   // printf (&quot;MemoryCheckingTraversalForAstFileIO::visit: node = %s \n&quot;,node-&gt;class_name().c_str());</a>
<a name="6175"><span class="lineNum">    6175 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(node-&gt;get_freepointer() == AST_FileIO::IS_VALID_POINTER());</span></a>
<a name="6176"><span class="lineNum">    6176 </span><span class="lineNoCov">          0 :      node-&gt;checkDataMemberPointersIfInMemoryPool();</span></a>
<a name="6177"><span class="lineNum">    6177 </span><span class="lineNoCov">          0 :    }</span></a>
<a name="6178"><span class="lineNum">    6178 </span>            : </a>
<a name="6179"><span class="lineNum">    6179 </span>            : </a>
<a name="6180"><span class="lineNum">    6180 </span>            : </a>
<a name="6181"><span class="lineNum">    6181 </span>            : </a>
<a name="6182"><span class="lineNum">    6182 </span><span class="lineCov">        326 : TestForProperLanguageAndSymbolTableCaseSensitivity_InheritedAttribute::</span></a>
<a name="6183"><span class="lineNum">    6183 </span><span class="lineCov">        326 : TestForProperLanguageAndSymbolTableCaseSensitivity_InheritedAttribute(bool b)</span></a>
<a name="6184"><span class="lineNum">    6184 </span>            :    : sourceFile(NULL),</a>
<a name="6185"><span class="lineNum">    6185 </span><span class="lineCov">        326 :      caseInsensitive(b)</span></a>
<a name="6186"><span class="lineNum">    6186 </span>            :    {</a>
<a name="6187"><span class="lineNum">    6187 </span><span class="lineCov">        326 :    }</span></a>
<a name="6188"><span class="lineNum">    6188 </span>            : </a>
<a name="6189"><span class="lineNum">    6189 </span><span class="lineCov">   32456100 : TestForProperLanguageAndSymbolTableCaseSensitivity_InheritedAttribute::</span></a>
<a name="6190"><span class="lineNum">    6190 </span><span class="lineCov">   32456100 : TestForProperLanguageAndSymbolTableCaseSensitivity_InheritedAttribute(const TestForProperLanguageAndSymbolTableCaseSensitivity_InheritedAttribute &amp; X)</span></a>
<a name="6191"><span class="lineNum">    6191 </span>            :    {</a>
<a name="6192"><span class="lineNum">    6192 </span><span class="lineCov">   32456100 :      sourceFile      = X.sourceFile;</span></a>
<a name="6193"><span class="lineNum">    6193 </span><span class="lineCov">   32456100 :      caseInsensitive = X.caseInsensitive;</span></a>
<a name="6194"><span class="lineNum">    6194 </span><span class="lineCov">   32456100 :    }</span></a>
<a name="6195"><span class="lineNum">    6195 </span>            : </a>
<a name="6196"><span class="lineNum">    6196 </span>            : namespace</a>
<a name="6197"><span class="lineNum">    6197 </span>            : {</a>
<a name="6198"><span class="lineNum">    6198 </span><span class="lineCov">        329 :   bool isCaseInsensitive(SgSourceFile* sourceFile)</span></a>
<a name="6199"><span class="lineNum">    6199 </span>            :   {</a>
<a name="6200"><span class="lineNum">    6200 </span><span class="lineCov">        329 :     return (  sourceFile-&gt;get_Fortran_only()</span></a>
<a name="6201"><span class="lineNum">    6201 </span>            :            );</a>
<a name="6202"><span class="lineNum">    6202 </span>            :   }</a>
<a name="6203"><span class="lineNum">    6203 </span>            : }</a>
<a name="6204"><span class="lineNum">    6204 </span>            : </a>
<a name="6205"><span class="lineNum">    6205 </span>            : TestForProperLanguageAndSymbolTableCaseSensitivity_InheritedAttribute</a>
<a name="6206"><span class="lineNum">    6206 </span><span class="lineCov">    5466810 : TestForProperLanguageAndSymbolTableCaseSensitivity::evaluateInheritedAttribute(SgNode* node, TestForProperLanguageAndSymbolTableCaseSensitivity_InheritedAttribute inheritedAttribute)</span></a>
<a name="6207"><span class="lineNum">    6207 </span>            :    {</a>
<a name="6208"><span class="lineNum">    6208 </span>            :   // The default is to make all symbol tables (scopes) case sensitive, and then detect use of Fortran</a>
<a name="6209"><span class="lineNum">    6209 </span>            :   // files (SgSourceFile IR nodes) and make all of their symbol tables (scopes) case insensitive.</a>
<a name="6210"><span class="lineNum">    6210 </span><span class="lineCov">    5466810 :      TestForProperLanguageAndSymbolTableCaseSensitivity_InheritedAttribute return_inheritedAttribute(inheritedAttribute);</span></a>
<a name="6211"><span class="lineNum">    6211 </span>            : </a>
<a name="6212"><span class="lineNum">    6212 </span><span class="lineCov">    5466810 :      SgSourceFile* sourceFile = isSgSourceFile(node);</span></a>
<a name="6213"><span class="lineNum">    6213 </span><span class="lineCov">    5466810 :      if (sourceFile != NULL)</span></a>
<a name="6214"><span class="lineNum">    6214 </span>            :         {</a>
<a name="6215"><span class="lineNum">    6215 </span>            :        // printf (&quot;Found SgSourceFile for %s get_Fortran_only() = %s \n&quot;,sourceFile-&gt;getFileName().c_str(),sourceFile-&gt;get_Fortran_only() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="6216"><span class="lineNum">    6216 </span>            : </a>
<a name="6217"><span class="lineNum">    6217 </span><span class="lineCov">        329 :           return_inheritedAttribute.sourceFile = sourceFile;</span></a>
<a name="6218"><span class="lineNum">    6218 </span><span class="lineCov">        329 :           if (isCaseInsensitive(sourceFile))</span></a>
<a name="6219"><span class="lineNum">    6219 </span>            :              {</a>
<a name="6220"><span class="lineNum">    6220 </span><span class="lineCov">         36 :                return_inheritedAttribute.caseInsensitive = true;</span></a>
<a name="6221"><span class="lineNum">    6221 </span>            :              }</a>
<a name="6222"><span class="lineNum">    6222 </span>            :         }</a>
<a name="6223"><span class="lineNum">    6223 </span>            : </a>
<a name="6224"><span class="lineNum">    6224 </span><span class="lineCov">    5466810 :      SgScopeStatement* scope = isSgScopeStatement(node);</span></a>
<a name="6225"><span class="lineNum">    6225 </span><span class="lineCov">    5466810 :      if (scope != NULL)</span></a>
<a name="6226"><span class="lineNum">    6226 </span>            :         {</a>
<a name="6227"><span class="lineNum">    6227 </span>            :        // This is a scope, now check if it matches the case sensitivity from the file (stored in the inherited attribute).</a>
<a name="6228"><span class="lineNum">    6228 </span>            :        // printf (&quot;Note: scope = %p = %s scope-&gt;isCaseInsensitive() = %s inheritedAttribute.caseInsensitive = %s \n&quot;,scope,scope-&gt;class_name().c_str(),scope-&gt;isCaseInsensitive() ? &quot;true&quot; : &quot;false&quot;,return_inheritedAttribute.caseInsensitive ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="6229"><span class="lineNum">    6229 </span>            : </a>
<a name="6230"><span class="lineNum">    6230 </span><span class="lineCov">      51305 :           if (scope-&gt;isCaseInsensitive() != return_inheritedAttribute.caseInsensitive)</span></a>
<a name="6231"><span class="lineNum">    6231 </span>            :              {</a>
<a name="6232"><span class="lineNum">    6232 </span><span class="lineNoCov">          0 :                printf (&quot;Error: scope-&gt;isCaseInsensitive() = %s inheritedAttribute.caseInsensitive = %s \n&quot;,scope-&gt;isCaseInsensitive() ? &quot;true&quot; : &quot;false&quot;,return_inheritedAttribute.caseInsensitive ? &quot;true&quot; : &quot;false&quot;);</span></a>
<a name="6233"><span class="lineNum">    6233 </span><span class="lineNoCov">          0 :                printf (&quot;       type of scope = %s\n&quot;, scope-&gt;class_name().c_str());</span></a>
<a name="6234"><span class="lineNum">    6234 </span><span class="lineNoCov">          0 :                scope-&gt;get_startOfConstruct()-&gt;display(&quot;scope-&gt;isCaseInsensitive() incorrectly set&quot;);</span></a>
<a name="6235"><span class="lineNum">    6235 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(return_inheritedAttribute.sourceFile != NULL);</span></a>
<a name="6236"><span class="lineNum">    6236 </span><span class="lineNoCov">          0 :                SgSourceFile* sourceFile = inheritedAttribute.sourceFile;</span></a>
<a name="6237"><span class="lineNum">    6237 </span>            : </a>
<a name="6238"><span class="lineNum">    6238 </span><span class="lineNoCov">          0 :                if (isCaseInsensitive(sourceFile))</span></a>
<a name="6239"><span class="lineNum">    6239 </span>            :                   {</a>
<a name="6240"><span class="lineNum">    6240 </span><span class="lineNoCov">          0 :                     printf (&quot;Fortran file %s should have an AST with scopes marked as case insensitive \n&quot;,sourceFile-&gt;getFileName().c_str());</span></a>
<a name="6241"><span class="lineNum">    6241 </span>            :                   }</a>
<a name="6242"><span class="lineNum">    6242 </span>            :                  else</a>
<a name="6243"><span class="lineNum">    6243 </span>            :                   {</a>
<a name="6244"><span class="lineNum">    6244 </span><span class="lineNoCov">          0 :                     printf (&quot;Non-fortran file %s should have an AST with scopes marked as case sensitive \n&quot;,sourceFile-&gt;getFileName().c_str());</span></a>
<a name="6245"><span class="lineNum">    6245 </span>            :                   }</a>
<a name="6246"><span class="lineNum">    6246 </span>            :              }</a>
<a name="6247"><span class="lineNum">    6247 </span><span class="lineCov">      51305 :           ROSE_ASSERT(scope-&gt;isCaseInsensitive() == return_inheritedAttribute.caseInsensitive);</span></a>
<a name="6248"><span class="lineNum">    6248 </span>            :         }</a>
<a name="6249"><span class="lineNum">    6249 </span>            : </a>
<a name="6250"><span class="lineNum">    6250 </span>            :   // Return the inherited attribue (will call the implemented copy constructor).</a>
<a name="6251"><span class="lineNum">    6251 </span><span class="lineCov">    5466810 :      return return_inheritedAttribute;</span></a>
<a name="6252"><span class="lineNum">    6252 </span>            :    }</a>
<a name="6253"><span class="lineNum">    6253 </span>            : </a>
<a name="6254"><span class="lineNum">    6254 </span>            : </a>
<a name="6255"><span class="lineNum">    6255 </span>            : void</a>
<a name="6256"><span class="lineNum">    6256 </span><span class="lineCov">        326 : TestForProperLanguageAndSymbolTableCaseSensitivity::test(SgNode* node)</span></a>
<a name="6257"><span class="lineNum">    6257 </span>            :    {</a>
<a name="6258"><span class="lineNum">    6258 </span>            :   // Inherited attribute with caseInsensitive marked as false.</a>
<a name="6259"><span class="lineNum">    6259 </span><span class="lineCov">        326 :      bool caseInsensitive = false;</span></a>
<a name="6260"><span class="lineNum">    6260 </span><span class="lineCov">        326 :      TestForProperLanguageAndSymbolTableCaseSensitivity_InheritedAttribute IH(caseInsensitive);</span></a>
<a name="6261"><span class="lineNum">    6261 </span>            : </a>
<a name="6262"><span class="lineNum">    6262 </span><span class="lineCov">        326 :      TestForProperLanguageAndSymbolTableCaseSensitivity traversal; // (node,IH);</span></a>
<a name="6263"><span class="lineNum">    6263 </span>            : </a>
<a name="6264"><span class="lineNum">    6264 </span>            :   // printf (&quot;Traversing AST to support TestForProperLanguageAndSymbolTableCaseSensitivity::test() \n&quot;);</a>
<a name="6265"><span class="lineNum">    6265 </span>            :   // ROSE_ASSERT(false);</a>
<a name="6266"><span class="lineNum">    6266 </span>            : </a>
<a name="6267"><span class="lineNum">    6267 </span>            :   // This should be a SgProject or SgFile so that we can evaluate the language type (obtained from the SgFile).</a>
<a name="6268"><span class="lineNum">    6268 </span><span class="lineCov">        326 :      ROSE_ASSERT(isSgProject(node) != NULL || isSgFile(node) != NULL);</span></a>
<a name="6269"><span class="lineNum">    6269 </span>            : </a>
<a name="6270"><span class="lineNum">    6270 </span><span class="lineCov">        652 :      traversal.traverse(node,IH);</span></a>
<a name="6271"><span class="lineNum">    6271 </span>            : </a>
<a name="6272"><span class="lineNum">    6272 </span>            :   // printf (&quot;DONE: Traversing AST to support TestForProperLanguageAndSymbolTableCaseSensitivity::test() \n&quot;);</a>
<a name="6273"><span class="lineNum">    6273 </span><span class="lineCov">        326 :    }</span></a>
<a name="6274"><span class="lineNum">    6274 </span>            : </a>
<a name="6275"><span class="lineNum">    6275 </span>            : </a>
<a name="6276"><span class="lineNum">    6276 </span><span class="lineCov">        326 : TestForReferencesToDeletedNodes::TestForReferencesToDeletedNodes(int input_detect_dangling_pointers, const string &amp; s )</span></a>
<a name="6277"><span class="lineNum">    6277 </span><span class="lineCov">        326 :    : detect_dangling_pointers(input_detect_dangling_pointers), filename(s)</span></a>
<a name="6278"><span class="lineNum">    6278 </span>            :    {</a>
<a name="6279"><span class="lineNum">    6279 </span>            :   // Nothing to do here!</a>
<a name="6280"><span class="lineNum">    6280 </span><span class="lineCov">        326 :    }</span></a>
<a name="6281"><span class="lineNum">    6281 </span>            : </a>
<a name="6282"><span class="lineNum">    6282 </span>            : </a>
<a name="6283"><span class="lineNum">    6283 </span>            : void</a>
<a name="6284"><span class="lineNum">    6284 </span><span class="lineCov">   55910000 : TestForReferencesToDeletedNodes::visit ( SgNode* node )</span></a>
<a name="6285"><span class="lineNum">    6285 </span>            :    {</a>
<a name="6286"><span class="lineNum">    6286 </span>            :   // DQ (9/26/2011): This is a new test for possible references to deleted IR nodes in the AST (dangling pointers).</a>
<a name="6287"><span class="lineNum">    6287 </span>            :   // It works as a byproduct of the way that memory pool works.  It might work better if we also added an option</a>
<a name="6288"><span class="lineNum">    6288 </span>            :   // to prevent previously deleted IR nodes from reusing memory in the memory pool.  This can be considered for</a>
<a name="6289"><span class="lineNum">    6289 </span>            :   // future work.</a>
<a name="6290"><span class="lineNum">    6290 </span>            : </a>
<a name="6291"><span class="lineNum">    6291 </span><span class="lineCov">   55910000 :      ROSE_ASSERT(node != NULL);</span></a>
<a name="6292"><span class="lineNum">    6292 </span>            :   // printf (&quot;TestForReferencesToDeletedNodes::visit: node = %s \n&quot;,node-&gt;class_name().c_str());</a>
<a name="6293"><span class="lineNum">    6293 </span>            : </a>
<a name="6294"><span class="lineNum">    6294 </span>            :   // Only output information about this test if set to value greater than zero (this avoids anoying output for existing translators, e.g. CAF2 work).</a>
<a name="6295"><span class="lineNum">    6295 </span><span class="lineCov">   55910000 :      if (detect_dangling_pointers &gt; 0)</span></a>
<a name="6296"><span class="lineNum">    6296 </span>            :         {</a>
<a name="6297"><span class="lineNum">    6297 </span><span class="lineNoCov">          0 :           vector&lt;pair&lt;SgNode*,string&gt; &gt; v = node-&gt;returnDataMemberPointers();</span></a>
<a name="6298"><span class="lineNum">    6298 </span>            : </a>
<a name="6299"><span class="lineNum">    6299 </span><span class="lineNoCov">          0 :           for (unsigned long i = 0; i &lt; v.size(); i++)</span></a>
<a name="6300"><span class="lineNum">    6300 </span>            :              {</a>
<a name="6301"><span class="lineNum">    6301 </span><span class="lineNoCov">          0 :                SgNode* child = v[i].first;</span></a>
<a name="6302"><span class="lineNum">    6302 </span>            : </a>
<a name="6303"><span class="lineNum">    6303 </span><span class="lineNoCov">          0 :                if (child != NULL &amp;&amp; child-&gt;variantT() == V_SgNode)</span></a>
<a name="6304"><span class="lineNum">    6304 </span>            :                   {</a>
<a name="6305"><span class="lineNum">    6305 </span>            :                  // This is a deleted IR node</a>
<a name="6306"><span class="lineNum">    6306 </span>            :                  // SgFile* file = TransformationSupport::getFile(node);</a>
<a name="6307"><span class="lineNum">    6307 </span>            :                  // string filename = (file != NULL) ? file-&gt;getFileName() : &quot;unknown file&quot;;</a>
<a name="6308"><span class="lineNum">    6308 </span><span class="lineNoCov">          0 :                     printf (&quot;Error in AST consistancy detect_dangling_pointers test for file %s: Found a child = %p = %s child name = %s of node = %p = %s that was previously deleted \n&quot;,filename.c_str(),child,child-&gt;class_name().c_str(),v[i].second.c_str(),node,node-&gt;class_name().c_str());</span></a>
<a name="6309"><span class="lineNum">    6309 </span>            :                   }</a>
<a name="6310"><span class="lineNum">    6310 </span>            : </a>
<a name="6311"><span class="lineNum">    6311 </span>            :             // DQ (9/26/2011): This fails for the projects/UpcTranslation upc_shared_2.upc file...figure this out once we see what elase might file.</a>
<a name="6312"><span class="lineNum">    6312 </span>            :             // Other fialing tests include:</a>
<a name="6313"><span class="lineNum">    6313 </span>            :             //    projects/backstroke/tests/expNormalizationTest/test2006_74.C</a>
<a name="6314"><span class="lineNum">    6314 </span>            :             //    projects/backstroke/tests/expNormalizationTest/test2006_87.C</a>
<a name="6315"><span class="lineNum">    6315 </span>            :             // Large percentage of Fortran tests fail this test!</a>
<a name="6316"><span class="lineNum">    6316 </span><span class="lineNoCov">          0 :                if (detect_dangling_pointers &gt; 1)</span></a>
<a name="6317"><span class="lineNum">    6317 </span>            :                   {</a>
<a name="6318"><span class="lineNum">    6318 </span><span class="lineNoCov">          0 :                     ROSE_ASSERT( (child == NULL) || (child != NULL &amp;&amp; child-&gt;variantT() != V_SgNode) );</span></a>
<a name="6319"><span class="lineNum">    6319 </span>            :                   }</a>
<a name="6320"><span class="lineNum">    6320 </span>            :              }</a>
<a name="6321"><span class="lineNum">    6321 </span>            :         }</a>
<a name="6322"><span class="lineNum">    6322 </span><span class="lineCov">   55910000 :    }</span></a>
<a name="6323"><span class="lineNum">    6323 </span>            : </a>
<a name="6324"><span class="lineNum">    6324 </span>            : void</a>
<a name="6325"><span class="lineNum">    6325 </span><span class="lineCov">        326 : TestForReferencesToDeletedNodes::test( SgProject* project )</span></a>
<a name="6326"><span class="lineNum">    6326 </span>            :    {</a>
<a name="6327"><span class="lineNum">    6327 </span>            :   // See documentation in the header file for this test.</a>
<a name="6328"><span class="lineNum">    6328 </span>            : </a>
<a name="6329"><span class="lineNum">    6329 </span>            :   // I was having trouble generating a file name for where the problem was happening, so this should work better.</a>
<a name="6330"><span class="lineNum">    6330 </span>            :   // might be that the problem IR nodes were contained in expressions in the index of a SgArrayType, or something</a>
<a name="6331"><span class="lineNum">    6331 </span>            :   // like that.</a>
<a name="6332"><span class="lineNum">    6332 </span>            :   // Generate a name from all the files on the command line</a>
<a name="6333"><span class="lineNum">    6333 </span><span class="lineCov">        326 :      string filename = SageInterface::generateProjectName(project, /* supressSuffix = */ false );</span></a>
<a name="6334"><span class="lineNum">    6334 </span>            : </a>
<a name="6335"><span class="lineNum">    6335 </span><span class="lineCov">        652 :      TestForReferencesToDeletedNodes traversal(project-&gt;get_detect_dangling_pointers(),filename);</span></a>
<a name="6336"><span class="lineNum">    6336 </span>            : </a>
<a name="6337"><span class="lineNum">    6337 </span><span class="lineCov">        652 :      traversal.traverseMemoryPool();</span></a>
<a name="6338"><span class="lineNum">    6338 </span><span class="lineCov">        326 :    }</span></a>
<a name="6339"><span class="lineNum">    6339 </span>            : </a>
<a name="6340"><span class="lineNum">    6340 </span>            : </a>
<a name="6341"><span class="lineNum">    6341 </span>            : // explicit</a>
<a name="6342"><span class="lineNum">    6342 </span><span class="lineCov">        290 : TestForParentsMatchingASTStructure::</span></a>
<a name="6343"><span class="lineNum">    6343 </span><span class="lineCov">        290 : TestForParentsMatchingASTStructure(std::ostream &amp;output, const std::string &amp;prefix)</span></a>
<a name="6344"><span class="lineNum">    6344 </span><span class="lineCov">        290 :    : output(output), nproblems(0), limit(0), prefix(prefix)</span></a>
<a name="6345"><span class="lineNum">    6345 </span>            :    {</a>
<a name="6346"><span class="lineNum">    6346 </span><span class="lineCov">        290 :    }</span></a>
<a name="6347"><span class="lineNum">    6347 </span>            : </a>
<a name="6348"><span class="lineNum">    6348 </span>            : bool</a>
<a name="6349"><span class="lineNum">    6349 </span><span class="lineCov">        290 : TestForParentsMatchingASTStructure::check(SgNode *ast, size_t limit)</span></a>
<a name="6350"><span class="lineNum">    6350 </span>            :    {</a>
<a name="6351"><span class="lineNum">    6351 </span><span class="lineCov">        290 :      this-&gt;limit = limit;</span></a>
<a name="6352"><span class="lineNum">    6352 </span><span class="lineCov">        290 :      nproblems = 0;</span></a>
<a name="6353"><span class="lineNum">    6353 </span><span class="lineCov">        290 :      try</span></a>
<a name="6354"><span class="lineNum">    6354 </span>            :         {</a>
<a name="6355"><span class="lineNum">    6355 </span><span class="lineCov">        290 :           traverse(ast);</span></a>
<a name="6356"><span class="lineNum">    6356 </span>            :         }</a>
<a name="6357"><span class="lineNum">    6357 </span><span class="lineCov">         14 :      catch (const TestForParentsMatchingASTStructure*)</span></a>
<a name="6358"><span class="lineNum">    6358 </span>            :         {</a>
<a name="6359"><span class="lineNum">    6359 </span><span class="lineCov">         14 :           return false;</span></a>
<a name="6360"><span class="lineNum">    6360 </span>            :         }</a>
<a name="6361"><span class="lineNum">    6361 </span>            : </a>
<a name="6362"><span class="lineNum">    6362 </span><span class="lineCov">        276 :      return 0 == nproblems;</span></a>
<a name="6363"><span class="lineNum">    6363 </span>            :    }</a>
<a name="6364"><span class="lineNum">    6364 </span>            : </a>
<a name="6365"><span class="lineNum">    6365 </span>            : void</a>
<a name="6366"><span class="lineNum">    6366 </span><span class="lineCov">    5460010 : TestForParentsMatchingASTStructure::preOrderVisit(SgNode *node)</span></a>
<a name="6367"><span class="lineNum">    6367 </span>            :    {</a>
<a name="6368"><span class="lineNum">    6368 </span><span class="lineCov">    5460010 :      if (!stack.empty())</span></a>
<a name="6369"><span class="lineNum">    6369 </span>            :         {</a>
<a name="6370"><span class="lineNum">    6370 </span><span class="lineCov">    5459720 :           if (NULL == node-&gt;get_parent())</span></a>
<a name="6371"><span class="lineNum">    6371 </span>            :              {</a>
<a name="6372"><span class="lineNum">    6372 </span>            :             // output &lt;&lt; prefix &lt;&lt; &quot;node has null parent property but was reached by AST traversal\n&quot;;</a>
<a name="6373"><span class="lineNum">    6373 </span><span class="lineCov">         40 :                printf (&quot;In TestForParentsMatchingASTStructure::preOrderVisit(): (NULL == node-&gt;get_parent()): node class_name = %s , prefix = %s node's parent property is NULL\n&quot;,node-&gt;class_name().c_str(), prefix.c_str());</span></a>
<a name="6374"><span class="lineNum">    6374 </span>            : </a>
<a name="6375"><span class="lineNum">    6375 </span><span class="lineCov">         40 :                show_details_and_maybe_fail(node);</span></a>
<a name="6376"><span class="lineNum">    6376 </span>            :              }</a>
<a name="6377"><span class="lineNum">    6377 </span>            :             else</a>
<a name="6378"><span class="lineNum">    6378 </span>            :              {</a>
<a name="6379"><span class="lineNum">    6379 </span><span class="lineCov">    5459680 :                if (node-&gt;get_parent() != stack.back())</span></a>
<a name="6380"><span class="lineNum">    6380 </span>            :                   {</a>
<a name="6381"><span class="lineNum">    6381 </span>            :                  // output &lt;&lt; prefix &lt;&lt; &quot;node's parent property does not match traversal parent\n&quot;;</a>
<a name="6382"><span class="lineNum">    6382 </span><span class="lineCov">        378 :                     if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL )</span></a>
<a name="6383"><span class="lineNum">    6383 </span>            :                        {</a>
<a name="6384"><span class="lineNum">    6384 </span><span class="lineNoCov">          0 :                          printf (&quot;In TestForParentsMatchingASTStructure::preOrderVisit(): (node-&gt;get_parent() != stack.back()): prefix = %s node's parent property does not match traversal parent\n&quot;,prefix.c_str());</span></a>
<a name="6385"><span class="lineNum">    6385 </span><span class="lineNoCov">          0 :                          printf (&quot;traversal parent = %p = %s \n&quot;,stack.back(),stack.back()-&gt;class_name().c_str());</span></a>
<a name="6386"><span class="lineNum">    6386 </span>            :                        }</a>
<a name="6387"><span class="lineNum">    6387 </span><span class="lineCov">        378 :                     SgNamespaceDefinitionStatement* namespaceDefinition = isSgNamespaceDefinitionStatement(stack.back());</span></a>
<a name="6388"><span class="lineNum">    6388 </span>            : </a>
<a name="6389"><span class="lineNum">    6389 </span><span class="lineCov">        378 :                     if (namespaceDefinition != NULL)</span></a>
<a name="6390"><span class="lineNum">    6390 </span>            :                        {</a>
<a name="6391"><span class="lineNum">    6391 </span><span class="lineNoCov">          0 :                          if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL )</span></a>
<a name="6392"><span class="lineNum">    6392 </span>            :                             {</a>
<a name="6393"><span class="lineNum">    6393 </span><span class="lineNoCov">          0 :                               printf (&quot;node = %p = %s node-&gt;get_parent() = %p = %s \n&quot;,node,node-&gt;class_name().c_str(),node-&gt;get_parent(),node-&gt;get_parent()-&gt;class_name().c_str());</span></a>
<a name="6394"><span class="lineNum">    6394 </span>            :                             }</a>
<a name="6395"><span class="lineNum">    6395 </span>            : </a>
<a name="6396"><span class="lineNum">    6396 </span><span class="lineNoCov">          0 :                          SgNamespaceDeclarationStatement* namespaceDeclaration = namespaceDefinition-&gt;get_namespaceDeclaration();</span></a>
<a name="6397"><span class="lineNum">    6397 </span><span class="lineNoCov">          0 :                          if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL )</span></a>
<a name="6398"><span class="lineNum">    6398 </span>            :                             {</a>
<a name="6399"><span class="lineNum">    6399 </span><span class="lineNoCov">          0 :                               printf (&quot;Found a namespaceDefinition = %p = %s \n&quot;,namespaceDefinition,namespaceDeclaration-&gt;get_name().str());</span></a>
<a name="6400"><span class="lineNum">    6400 </span>            :                             }</a>
<a name="6401"><span class="lineNum">    6401 </span>            : </a>
<a name="6402"><span class="lineNum">    6402 </span>            :                          SgNamespaceDefinitionStatement* previousNamespaceDefinition = namespaceDefinition;</a>
<a name="6403"><span class="lineNum">    6403 </span><span class="lineNoCov">          0 :                          while (previousNamespaceDefinition != NULL)</span></a>
<a name="6404"><span class="lineNum">    6404 </span>            :                             {</a>
<a name="6405"><span class="lineNum">    6405 </span><span class="lineNoCov">          0 :                               if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL )</span></a>
<a name="6406"><span class="lineNum">    6406 </span>            :                                  {</a>
<a name="6407"><span class="lineNum">    6407 </span><span class="lineNoCov">          0 :                                    printf (&quot;previousNamespaceDefinition = %p \n&quot;,previousNamespaceDefinition);</span></a>
<a name="6408"><span class="lineNum">    6408 </span>            :                                  }</a>
<a name="6409"><span class="lineNum">    6409 </span>            : </a>
<a name="6410"><span class="lineNum">    6410 </span><span class="lineNoCov">          0 :                               previousNamespaceDefinition = previousNamespaceDefinition-&gt;get_previousNamespaceDefinition();</span></a>
<a name="6411"><span class="lineNum">    6411 </span>            :                             }</a>
<a name="6412"><span class="lineNum">    6412 </span>            :                        }</a>
<a name="6413"><span class="lineNum">    6413 </span>            : </a>
<a name="6414"><span class="lineNum">    6414 </span><span class="lineCov">        378 :                     show_details_and_maybe_fail(node);</span></a>
<a name="6415"><span class="lineNum">    6415 </span>            :                   }</a>
<a name="6416"><span class="lineNum">    6416 </span>            :              }</a>
<a name="6417"><span class="lineNum">    6417 </span>            :         }</a>
<a name="6418"><span class="lineNum">    6418 </span>            : </a>
<a name="6419"><span class="lineNum">    6419 </span><span class="lineCov">    5459990 :      stack.push_back(node);</span></a>
<a name="6420"><span class="lineNum">    6420 </span><span class="lineCov">    5459990 :    }</span></a>
<a name="6421"><span class="lineNum">    6421 </span>            : </a>
<a name="6422"><span class="lineNum">    6422 </span>            : void</a>
<a name="6423"><span class="lineNum">    6423 </span><span class="lineCov">    5459840 : TestForParentsMatchingASTStructure::postOrderVisit(SgNode *node)</span></a>
<a name="6424"><span class="lineNum">    6424 </span>            :    {</a>
<a name="6425"><span class="lineNum">    6425 </span><span class="lineCov">    5459840 :      assert(!stack.empty());</span></a>
<a name="6426"><span class="lineNum">    6426 </span><span class="lineCov">    5459840 :      assert(node==stack.back());</span></a>
<a name="6427"><span class="lineNum">    6427 </span><span class="lineCov">    5459840 :      stack.pop_back();</span></a>
<a name="6428"><span class="lineNum">    6428 </span><span class="lineCov">    5459840 :    }</span></a>
<a name="6429"><span class="lineNum">    6429 </span>            : </a>
<a name="6430"><span class="lineNum">    6430 </span>            : void</a>
<a name="6431"><span class="lineNum">    6431 </span><span class="lineCov">        418 : TestForParentsMatchingASTStructure::show_details_and_maybe_fail(SgNode *node)</span></a>
<a name="6432"><span class="lineNum">    6432 </span>            :    {</a>
<a name="6433"><span class="lineNum">    6433 </span><span class="lineCov">        418 :      if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL )</span></a>
<a name="6434"><span class="lineNum">    6434 </span>            :         {</a>
<a name="6435"><span class="lineNum">    6435 </span><span class="lineNoCov">          0 :           output &lt;&lt;prefix &lt;&lt;&quot;AST path (including node) when inconsistency was detected:\n&quot;;</span></a>
<a name="6436"><span class="lineNum">    6436 </span>            :         }</a>
<a name="6437"><span class="lineNum">    6437 </span>            : </a>
<a name="6438"><span class="lineNum">    6438 </span><span class="lineCov">       4799 :      for (size_t i = 0; i &lt; stack.size(); ++i)</span></a>
<a name="6439"><span class="lineNum">    6439 </span>            :         {</a>
<a name="6440"><span class="lineNum">    6440 </span><span class="lineCov">       4381 :           if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL )</span></a>
<a name="6441"><span class="lineNum">    6441 </span>            :              {</a>
<a name="6442"><span class="lineNum">    6442 </span><span class="lineNoCov">          0 :                output &lt;&lt; prefix</span></a>
<a name="6443"><span class="lineNum">    6443 </span><span class="lineNoCov">          0 :                  &lt;&lt; &quot;    #&quot; &lt;&lt; std::setw(4) &lt;&lt; std::left &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; stringifyVariantT(stack[i]-&gt;variantT(), &quot;V_&quot;)</span></a>
<a name="6444"><span class="lineNum">    6444 </span><span class="lineNoCov">          0 :                  &lt;&lt; &quot; &quot; &lt;&lt; stack[i] &lt;&lt; &quot;; parent=&quot; &lt;&lt; stack[i]-&gt;get_parent()</span></a>
<a name="6445"><span class="lineNum">    6445 </span><span class="lineNoCov">          0 :                  &lt;&lt; &quot;\n&quot;;</span></a>
<a name="6446"><span class="lineNum">    6446 </span>            : </a>
<a name="6447"><span class="lineNum">    6447 </span>            :             // DQ (9/21/2013): Avoid redundant output of debug info.</a>
<a name="6448"><span class="lineNum">    6448 </span>            :             // printf (&quot;   stack[i]-&gt;get_parent() = %p \n&quot;,stack[i]-&gt;get_parent());</a>
<a name="6449"><span class="lineNum">    6449 </span><span class="lineNoCov">          0 :                if (stack[i]-&gt;get_parent() != NULL)</span></a>
<a name="6450"><span class="lineNum">    6450 </span>            :                   {</a>
<a name="6451"><span class="lineNum">    6451 </span><span class="lineNoCov">          0 :                     printf (&quot;   stack[i]-&gt;get_parent() = %p = %s \n&quot;,stack[i]-&gt;get_parent(),stack[i]-&gt;get_parent()-&gt;class_name().c_str());</span></a>
<a name="6452"><span class="lineNum">    6452 </span>            :                   }</a>
<a name="6453"><span class="lineNum">    6453 </span>            :                  else</a>
<a name="6454"><span class="lineNum">    6454 </span>            :                   {</a>
<a name="6455"><span class="lineNum">    6455 </span><span class="lineCov">       4381 :                     printf (&quot;   stack[i]-&gt;get_parent() = %p \n&quot;,stack[i]-&gt;get_parent());</span></a>
<a name="6456"><span class="lineNum">    6456 </span>            :                   }</a>
<a name="6457"><span class="lineNum">    6457 </span>            :              }</a>
<a name="6458"><span class="lineNum">    6458 </span>            :         }</a>
<a name="6459"><span class="lineNum">    6459 </span>            : </a>
<a name="6460"><span class="lineNum">    6460 </span>            :   // DQ (3/4/2016): Klocworks reports a problem with &quot;node-&gt;get_parent() != NULL&quot;.</a>
<a name="6461"><span class="lineNum">    6461 </span><span class="lineCov">        418 :      ROSE_ASSERT(node != NULL);</span></a>
<a name="6462"><span class="lineNum">    6462 </span>            : </a>
<a name="6463"><span class="lineNum">    6463 </span><span class="lineCov">        418 :      if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL )</span></a>
<a name="6464"><span class="lineNum">    6464 </span>            :         {</a>
<a name="6465"><span class="lineNum">    6465 </span><span class="lineNoCov">          0 :           output &lt;&lt; prefix</span></a>
<a name="6466"><span class="lineNum">    6466 </span><span class="lineNoCov">          0 :             &lt;&lt; &quot;    #&quot; &lt;&lt; std::setw(4) &lt;&lt; std::left &lt;&lt; stack.size() &lt;&lt; &quot; &quot; &lt;&lt; stringifyVariantT(node-&gt;variantT(), &quot;V_&quot;)</span></a>
<a name="6467"><span class="lineNum">    6467 </span><span class="lineNoCov">          0 :             &lt;&lt; &quot; &quot; &lt;&lt; node &lt;&lt; &quot;; parent=&quot; &lt;&lt; node-&gt;get_parent()</span></a>
<a name="6468"><span class="lineNum">    6468 </span><span class="lineNoCov">          0 :             &lt;&lt; &quot; = &quot; &lt;&lt; ((node-&gt;get_parent() != NULL) ? node-&gt;get_parent()-&gt;class_name() : string(&quot;null&quot;))</span></a>
<a name="6469"><span class="lineNum">    6469 </span><span class="lineNoCov">          0 :             &lt;&lt; &quot;\n&quot;;</span></a>
<a name="6470"><span class="lineNum">    6470 </span>            :         }</a>
<a name="6471"><span class="lineNum">    6471 </span>            : </a>
<a name="6472"><span class="lineNum">    6472 </span><span class="lineCov">        418 :      if (++nproblems &gt;= limit)</span></a>
<a name="6473"><span class="lineNum">    6473 </span>            :         {</a>
<a name="6474"><span class="lineNum">    6474 </span><span class="lineCov">         14 :           throw this;</span></a>
<a name="6475"><span class="lineNum">    6475 </span>            :         }</a>
<a name="6476"><span class="lineNum">    6476 </span><span class="lineCov">        404 :    }</span></a>
<a name="6477"><span class="lineNum">    6477 </span>            : </a>
<a name="6478"><span class="lineNum">    6478 </span>            : void</a>
<a name="6479"><span class="lineNum">    6479 </span><span class="lineCov">        290 : TestForParentsMatchingASTStructure::test( SgProject* project )</span></a>
<a name="6480"><span class="lineNum">    6480 </span>            :    {</a>
<a name="6481"><span class="lineNum">    6481 </span>            :   // See documentation in the header file for this test.</a>
<a name="6482"><span class="lineNum">    6482 </span>            : </a>
<a name="6483"><span class="lineNum">    6483 </span>            :   // End in an error if any are detected.</a>
<a name="6484"><span class="lineNum">    6484 </span><span class="lineCov">        580 :      std::ostringstream ss;</span></a>
<a name="6485"><span class="lineNum">    6485 </span><span class="lineCov">        290 :      if (!TestForParentsMatchingASTStructure(ss, &quot;    &quot;).check(project, 10))</span></a>
<a name="6486"><span class="lineNum">    6486 </span>            :         {</a>
<a name="6487"><span class="lineNum">    6487 </span><span class="lineCov">        124 :           if ( SgProject::get_verbose() &gt;= DIAGNOSTICS_VERBOSE_LEVEL )</span></a>
<a name="6488"><span class="lineNum">    6488 </span>            :              {</a>
<a name="6489"><span class="lineNum">    6489 </span><span class="lineNoCov">          0 :                std::cerr &lt;&lt;&quot;Detected AST parent/child relationship problems after AST post processing:\n&quot; &lt;&lt;ss.str();</span></a>
<a name="6490"><span class="lineNum">    6490 </span>            :              }</a>
<a name="6491"><span class="lineNum">    6491 </span>            : #if 0</a>
<a name="6492"><span class="lineNum">    6492 </span>            :           ROSE_ABORT();</a>
<a name="6493"><span class="lineNum">    6493 </span>            : #endif</a>
<a name="6494"><span class="lineNum">    6494 </span>            :         }</a>
<a name="6495"><span class="lineNum">    6495 </span>            : </a>
<a name="6496"><span class="lineNum">    6496 </span>            :   // TestForParentsMatchingASTStructure traversal(project);</a>
<a name="6497"><span class="lineNum">    6497 </span>            :   // traversal.traverse();</a>
<a name="6498"><span class="lineNum">    6498 </span><span class="lineCov">        290 :    }</span></a>
<a name="6499"><span class="lineNum">    6499 </span>            : </a>
<a name="6500"><span class="lineNum">    6500 </span>            : </a>
<a name="6501"><span class="lineNum">    6501 </span>            : void</a>
<a name="6502"><span class="lineNum">    6502 </span><span class="lineCov">   16605800 : TestForSourcePosition::testFileInfo( Sg_File_Info* fileInfo )</span></a>
<a name="6503"><span class="lineNum">    6503 </span>            :    {</a>
<a name="6504"><span class="lineNum">    6504 </span>            :   // The get_file_info() function maps to get_operator_position() for SgExpression IR nodes and to</a>
<a name="6505"><span class="lineNum">    6505 </span>            :   // get_startOfConstruct() for SgStatement and some other IR nodes in SgSupport that have not yet</a>
<a name="6506"><span class="lineNum">    6506 </span>            :   // been moved to be in SgLocatedNode.</a>
<a name="6507"><span class="lineNum">    6507 </span>            : </a>
<a name="6508"><span class="lineNum">    6508 </span><span class="lineCov">   16605800 :      bool isCompilerGenerated                   = (fileInfo-&gt;isCompilerGenerated() == true);</span></a>
<a name="6509"><span class="lineNum">    6509 </span><span class="lineCov">   16605800 :      bool isFrontendSpecific                    = (fileInfo-&gt;isFrontendSpecific() == true);</span></a>
<a name="6510"><span class="lineNum">    6510 </span><span class="lineCov">   16605800 :      bool isTransformation                      = (fileInfo-&gt;isTransformation() == true);</span></a>
<a name="6511"><span class="lineNum">    6511 </span><span class="lineCov">   16605800 :      bool isShared                              = (fileInfo-&gt;isShared() == true);</span></a>
<a name="6512"><span class="lineNum">    6512 </span><span class="lineCov">   16605800 :      bool isSourcePositionUnavailableInFrontend = (fileInfo-&gt;isSourcePositionUnavailableInFrontend() == true);</span></a>
<a name="6513"><span class="lineNum">    6513 </span>            : </a>
<a name="6514"><span class="lineNum">    6514 </span><span class="lineCov">   16605800 :      if (isCompilerGenerated == false &amp;&amp; isFrontendSpecific == false &amp;&amp; isShared == false &amp;&amp; isSourcePositionUnavailableInFrontend == false &amp;&amp; isTransformation == false)</span></a>
<a name="6515"><span class="lineNum">    6515 </span>            :         {</a>
<a name="6516"><span class="lineNum">    6516 </span><span class="lineCov">    1592300 :           if (fileInfo-&gt;get_filenameString() == &quot;&quot;)</span></a>
<a name="6517"><span class="lineNum">    6517 </span>            :              {</a>
<a name="6518"><span class="lineNum">    6518 </span><span class="lineNoCov">          0 :                fileInfo-&gt;display(&quot;In TestForSourcePosition::visit(): debug&quot;);</span></a>
<a name="6519"><span class="lineNum">    6519 </span>            : </a>
<a name="6520"><span class="lineNum">    6520 </span><span class="lineNoCov">          0 :                SgNode* node = fileInfo-&gt;get_parent();</span></a>
<a name="6521"><span class="lineNum">    6521 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(node != NULL);</span></a>
<a name="6522"><span class="lineNum">    6522 </span>            : </a>
<a name="6523"><span class="lineNum">    6523 </span><span class="lineNoCov">          0 :                printf (&quot;Error: detected a source position with empty filename: node = %p = %s \n&quot;,node,node-&gt;class_name().c_str());</span></a>
<a name="6524"><span class="lineNum">    6524 </span><span class="lineNoCov">          0 :                ROSE_ABORT();</span></a>
<a name="6525"><span class="lineNum">    6525 </span>            :              }</a>
<a name="6526"><span class="lineNum">    6526 </span>            : </a>
<a name="6527"><span class="lineNum">    6527 </span>            : #if 0</a>
<a name="6528"><span class="lineNum">    6528 </span>            :        // Debugging code for special case.</a>
<a name="6529"><span class="lineNum">    6529 </span>            :           if (fileInfo-&gt;get_parent() != NULL &amp;&amp; fileInfo-&gt;get_parent()-&gt;variantT() == V_SgFunctionDefinition)</a>
<a name="6530"><span class="lineNum">    6530 </span>            :              {</a>
<a name="6531"><span class="lineNum">    6531 </span>            :                fileInfo-&gt;display(&quot;In TestForSourcePosition::visit(): case of SgFunctionDefinition: debug&quot;);</a>
<a name="6532"><span class="lineNum">    6532 </span>            :              }</a>
<a name="6533"><span class="lineNum">    6533 </span>            : #endif</a>
<a name="6534"><span class="lineNum">    6534 </span>            : </a>
<a name="6535"><span class="lineNum">    6535 </span><span class="lineCov">    1592300 :           if (fileInfo-&gt;get_physical_file_id() &lt; 0)</span></a>
<a name="6536"><span class="lineNum">    6536 </span>            :              {</a>
<a name="6537"><span class="lineNum">    6537 </span><span class="lineNoCov">          0 :                fileInfo-&gt;display(&quot;In TestForSourcePosition::visit(): debug&quot;);</span></a>
<a name="6538"><span class="lineNum">    6538 </span>            : </a>
<a name="6539"><span class="lineNum">    6539 </span><span class="lineNoCov">          0 :                SgNode* node = fileInfo-&gt;get_parent();</span></a>
<a name="6540"><span class="lineNum">    6540 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(node != NULL);</span></a>
<a name="6541"><span class="lineNum">    6541 </span>            : </a>
<a name="6542"><span class="lineNum">    6542 </span><span class="lineNoCov">          0 :                printf (&quot;Error: detected a source position with inconsistant physical file id: node = %p = %s \n&quot;,node,node-&gt;class_name().c_str());</span></a>
<a name="6543"><span class="lineNum">    6543 </span><span class="lineNoCov">          0 :                ROSE_ABORT();</span></a>
<a name="6544"><span class="lineNum">    6544 </span>            :              }</a>
<a name="6545"><span class="lineNum">    6545 </span>            :         }</a>
<a name="6546"><span class="lineNum">    6546 </span><span class="lineCov">   16605800 :    }</span></a>
<a name="6547"><span class="lineNum">    6547 </span>            : </a>
<a name="6548"><span class="lineNum">    6548 </span>            : </a>
<a name="6549"><span class="lineNum">    6549 </span>            : void</a>
<a name="6550"><span class="lineNum">    6550 </span><span class="lineCov">    5466810 : TestForSourcePosition::visit ( SgNode* node )</span></a>
<a name="6551"><span class="lineNum">    6551 </span>            :    {</a>
<a name="6552"><span class="lineNum">    6552 </span><span class="lineCov">    5466810 :      Sg_File_Info* fileInfo = node-&gt;get_file_info();</span></a>
<a name="6553"><span class="lineNum">    6553 </span><span class="lineCov">    5466810 :      if (fileInfo != NULL)</span></a>
<a name="6554"><span class="lineNum">    6554 </span>            :         {</a>
<a name="6555"><span class="lineNum">    6555 </span><span class="lineCov">    5466160 :           testFileInfo(fileInfo);</span></a>
<a name="6556"><span class="lineNum">    6556 </span>            :         }</a>
<a name="6557"><span class="lineNum">    6557 </span>            : </a>
<a name="6558"><span class="lineNum">    6558 </span><span class="lineCov">    5466810 :      SgLocatedNode* locatedNode = isSgLocatedNode(node);</span></a>
<a name="6559"><span class="lineNum">    6559 </span><span class="lineCov">    5466810 :      if (locatedNode != NULL)</span></a>
<a name="6560"><span class="lineNum">    6560 </span>            :         {</a>
<a name="6561"><span class="lineNum">    6561 </span>            :        // This is a redundant test (with get_file_info()) for SgStatement, but not for SgExpression.</a>
<a name="6562"><span class="lineNum">    6562 </span><span class="lineCov">    5465190 :           Sg_File_Info* startOfConstruct = node-&gt;get_startOfConstruct();</span></a>
<a name="6563"><span class="lineNum">    6563 </span><span class="lineCov">    5465190 :           if (startOfConstruct != NULL)</span></a>
<a name="6564"><span class="lineNum">    6564 </span>            :              {</a>
<a name="6565"><span class="lineNum">    6565 </span><span class="lineCov">    5465190 :                testFileInfo(startOfConstruct);</span></a>
<a name="6566"><span class="lineNum">    6566 </span>            :              }</a>
<a name="6567"><span class="lineNum">    6567 </span>            : </a>
<a name="6568"><span class="lineNum">    6568 </span><span class="lineCov">    5465190 :           Sg_File_Info* endOfConstruct = node-&gt;get_endOfConstruct();</span></a>
<a name="6569"><span class="lineNum">    6569 </span><span class="lineCov">    5465190 :           if (endOfConstruct != NULL)</span></a>
<a name="6570"><span class="lineNum">    6570 </span>            :              {</a>
<a name="6571"><span class="lineNum">    6571 </span><span class="lineCov">    5465190 :                testFileInfo(endOfConstruct);</span></a>
<a name="6572"><span class="lineNum">    6572 </span>            :              }</a>
<a name="6573"><span class="lineNum">    6573 </span>            : </a>
<a name="6574"><span class="lineNum">    6574 </span>            :        // This is a redundant test (with get_file_info()) for SgExpression.</a>
<a name="6575"><span class="lineNum">    6575 </span><span class="lineCov">    5465190 :           SgExpression* expressionNode = isSgExpression(locatedNode);</span></a>
<a name="6576"><span class="lineNum">    6576 </span><span class="lineCov">    5465190 :           if (expressionNode != NULL)</span></a>
<a name="6577"><span class="lineNum">    6577 </span>            :              {</a>
<a name="6578"><span class="lineNum">    6578 </span><span class="lineCov">     209268 :                Sg_File_Info* operatorPosition = expressionNode-&gt;get_operatorPosition();</span></a>
<a name="6579"><span class="lineNum">    6579 </span><span class="lineCov">     209268 :                if (operatorPosition != NULL)</span></a>
<a name="6580"><span class="lineNum">    6580 </span>            :                   {</a>
<a name="6581"><span class="lineNum">    6581 </span><span class="lineCov">     209268 :                     testFileInfo(operatorPosition);</span></a>
<a name="6582"><span class="lineNum">    6582 </span>            :                   }</a>
<a name="6583"><span class="lineNum">    6583 </span>            :              }</a>
<a name="6584"><span class="lineNum">    6584 </span>            :         }</a>
<a name="6585"><span class="lineNum">    6585 </span><span class="lineCov">    5466810 :    }</span></a>
<a name="6586"><span class="lineNum">    6586 </span>            : </a>
<a name="6587"><span class="lineNum">    6587 </span>            : </a>
<a name="6588"><span class="lineNum">    6588 </span>            : </a>
<a name="6589"><span class="lineNum">    6589 </span>            : void</a>
<a name="6590"><span class="lineNum">    6590 </span><span class="lineCov">    5466810 : TestForMultipleWaysToSpecifyRestrictKeyword::visit ( SgNode* node )</span></a>
<a name="6591"><span class="lineNum">    6591 </span>            :    {</a>
<a name="6592"><span class="lineNum">    6592 </span>            :   // DQ (12/11/2012): Added new consistancy test.</a>
<a name="6593"><span class="lineNum">    6593 </span>            :   // This consistancy test only tests for consistant setting of the restrict keyword.  But it might be useful</a>
<a name="6594"><span class="lineNum">    6594 </span>            :   // to enforce consistant setting of both &quot;const&quot; and volatile&quot; keywords as well.  I'm not clear on this</a>
<a name="6595"><span class="lineNum">    6595 </span>            :   // design point.  There are notes about this in the Unparse_ExprStmt::unparseMFuncDeclStmt() hnadling of</a>
<a name="6596"><span class="lineNum">    6596 </span>            :   // the &quot;restrict&quot; keywork (in the unparser).</a>
<a name="6597"><span class="lineNum">    6597 </span>            : </a>
<a name="6598"><span class="lineNum">    6598 </span><span class="lineCov">    5466810 :      SgDeclarationStatement* declarationStatement = isSgDeclarationStatement(node);</span></a>
<a name="6599"><span class="lineNum">    6599 </span><span class="lineCov">    5466810 :      if (declarationStatement != NULL)</span></a>
<a name="6600"><span class="lineNum">    6600 </span>            :         {</a>
<a name="6601"><span class="lineNum">    6601 </span>            : #if 0</a>
<a name="6602"><span class="lineNum">    6602 </span>            :           printf (&quot;In TestForMultipleWaysToSpecifyRestrictKeyword::visit(): Found a declaration = %p = %s \n&quot;,declarationStatement,declarationStatement-&gt;class_name().c_str());</a>
<a name="6603"><span class="lineNum">    6603 </span>            : #endif</a>
<a name="6604"><span class="lineNum">    6604 </span><span class="lineCov">    2248380 :           SgDeclarationModifier &amp; declarationModifier = declarationStatement-&gt;get_declarationModifier();</span></a>
<a name="6605"><span class="lineNum">    6605 </span><span class="lineCov">    2248380 :           SgTypeModifier &amp; typeModifierFromDeclarationModifier = declarationModifier.get_typeModifier();</span></a>
<a name="6606"><span class="lineNum">    6606 </span>            : </a>
<a name="6607"><span class="lineNum">    6607 </span><span class="lineCov">    2248380 :           SgFunctionDeclaration* functionDeclaration = isSgFunctionDeclaration(declarationStatement);</span></a>
<a name="6608"><span class="lineNum">    6608 </span><span class="lineCov">    2248380 :           if (functionDeclaration != NULL)</span></a>
<a name="6609"><span class="lineNum">    6609 </span>            :              {</a>
<a name="6610"><span class="lineNum">    6610 </span><span class="lineCov">    1060060 :                SgType* type = functionDeclaration-&gt;get_type();</span></a>
<a name="6611"><span class="lineNum">    6611 </span><span class="lineCov">    1060060 :                ROSE_ASSERT(type != NULL);</span></a>
<a name="6612"><span class="lineNum">    6612 </span>            : #if 0</a>
<a name="6613"><span class="lineNum">    6613 </span>            :                printf (&quot;In TestForMultipleWaysToSpecifyRestrictKeyword::visit(): Found a function type = %p = %s \n&quot;,type,type-&gt;class_name().c_str());</a>
<a name="6614"><span class="lineNum">    6614 </span>            : #endif</a>
<a name="6615"><span class="lineNum">    6615 </span>            :             // DQ (12/11/2012): This should never be a SgModifierType.</a>
<a name="6616"><span class="lineNum">    6616 </span><span class="lineCov">    1060060 :                SgModifierType* modifierType = isSgModifierType(type);</span></a>
<a name="6617"><span class="lineNum">    6617 </span><span class="lineCov">    1060060 :                ROSE_ASSERT(modifierType == NULL);</span></a>
<a name="6618"><span class="lineNum">    6618 </span>            : </a>
<a name="6619"><span class="lineNum">    6619 </span>            :             // SgFunctionType* functionType       = isSgFunctionType(type);</a>
<a name="6620"><span class="lineNum">    6620 </span><span class="lineCov">    1060060 :                SgMemberFunctionType* memberFunctionType = isSgMemberFunctionType(type);</span></a>
<a name="6621"><span class="lineNum">    6621 </span><span class="lineCov">    1060060 :                if (memberFunctionType != NULL)</span></a>
<a name="6622"><span class="lineNum">    6622 </span>            :                   {</a>
<a name="6623"><span class="lineNum">    6623 </span><span class="lineCov">      24499 :                     if (memberFunctionType-&gt;isRestrictFunc() != typeModifierFromDeclarationModifier.isRestrict())</span></a>
<a name="6624"><span class="lineNum">    6624 </span>            :                        {</a>
<a name="6625"><span class="lineNum">    6625 </span><span class="lineNoCov">          0 :                          printf (&quot;Error: restrict is not consistantly set in the two SgTypeModifier IR nodes memberFunctionType-&gt;isRestrict() = %s typeModifierFromDeclarationModifier.isRestrict() = %s \n&quot;,</span></a>
<a name="6626"><span class="lineNum">    6626 </span><span class="lineNoCov">          0 :                               memberFunctionType-&gt;isRestrictFunc() ? &quot;true&quot; : &quot;false&quot;,typeModifierFromDeclarationModifier.isRestrict() ? &quot;true&quot; : &quot;false&quot;);</span></a>
<a name="6627"><span class="lineNum">    6627 </span><span class="lineNoCov">          0 :                          ROSE_ABORT();</span></a>
<a name="6628"><span class="lineNum">    6628 </span>            :                        }</a>
<a name="6629"><span class="lineNum">    6629 </span>            :                   }</a>
<a name="6630"><span class="lineNum">    6630 </span>            :                  else</a>
<a name="6631"><span class="lineNum">    6631 </span>            :                   {</a>
<a name="6632"><span class="lineNum">    6632 </span>            : #if 0</a>
<a name="6633"><span class="lineNum">    6633 </span>            :                     printf (&quot;Not a SgMemberFunctionType! \n&quot;);</a>
<a name="6634"><span class="lineNum">    6634 </span>            : #endif</a>
<a name="6635"><span class="lineNum">    6635 </span>            :                   }</a>
<a name="6636"><span class="lineNum">    6636 </span>            :              }</a>
<a name="6637"><span class="lineNum">    6637 </span>            :         }</a>
<a name="6638"><span class="lineNum">    6638 </span><span class="lineCov">    5466810 :    }</span></a>
<a name="6639"><span class="lineNum">    6639 </span>            : </a>
<a name="6640"><span class="lineNum">    6640 </span>            : </a>
<a name="6641"><span class="lineNum">    6641 </span>            : void</a>
<a name="6642"><span class="lineNum">    6642 </span><span class="lineCov">        326 : TestAstForCyclesInTypedefs::test()</span></a>
<a name="6643"><span class="lineNum">    6643 </span>            :    {</a>
<a name="6644"><span class="lineNum">    6644 </span><span class="lineCov">        652 :      TestAstForCyclesInTypedefs t;</span></a>
<a name="6645"><span class="lineNum">    6645 </span><span class="lineCov">        326 :      t.traverseMemoryPool();</span></a>
<a name="6646"><span class="lineNum">    6646 </span><span class="lineCov">        326 :    }</span></a>
<a name="6647"><span class="lineNum">    6647 </span>            : </a>
<a name="6648"><span class="lineNum">    6648 </span>            : </a>
<a name="6649"><span class="lineNum">    6649 </span>            : void</a>
<a name="6650"><span class="lineNum">    6650 </span><span class="lineCov">   55910000 : TestAstForCyclesInTypedefs::visit ( SgNode* node )</span></a>
<a name="6651"><span class="lineNum">    6651 </span>            :    {</a>
<a name="6652"><span class="lineNum">    6652 </span>            :   // DQ (10/27/2015): This test checks for cycles in typedef types.</a>
<a name="6653"><span class="lineNum">    6653 </span>            :   // It might be expanded to include testing for cycles in other kinds of types as well.</a>
<a name="6654"><span class="lineNum">    6654 </span>            : </a>
<a name="6655"><span class="lineNum">    6655 </span><span class="lineCov">   55910000 :      ROSE_ASSERT(node != NULL);</span></a>
<a name="6656"><span class="lineNum">    6656 </span>            : </a>
<a name="6657"><span class="lineNum">    6657 </span>            : #if 0</a>
<a name="6658"><span class="lineNum">    6658 </span>            :      printf (&quot;TestAstForCyclesInTypedefs::visit: node = %s \n&quot;,node-&gt;class_name().c_str());</a>
<a name="6659"><span class="lineNum">    6659 </span>            : #endif</a>
<a name="6660"><span class="lineNum">    6660 </span>            : </a>
<a name="6661"><span class="lineNum">    6661 </span>            :   // DQ (10/27/2015): Added test for specific cycle in typedef types.</a>
<a name="6662"><span class="lineNum">    6662 </span>            :   // SgType* currentType = isSgType(node);</a>
<a name="6663"><span class="lineNum">    6663 </span><span class="lineCov">   55910000 :      SgTypedefType* currentType = isSgTypedefType(node);</span></a>
<a name="6664"><span class="lineNum">    6664 </span>            : </a>
<a name="6665"><span class="lineNum">    6665 </span>            : #if 1</a>
<a name="6666"><span class="lineNum">    6666 </span><span class="lineCov">   55910000 :      if (currentType != NULL)</span></a>
<a name="6667"><span class="lineNum">    6667 </span>            :         {</a>
<a name="6668"><span class="lineNum">    6668 </span><span class="lineCov">      46950 :           ROSE_ASSERT( (isSgModifierType(isSgTypedefType(currentType)-&gt;get_base_type()) == NULL) ||</span></a>
<a name="6669"><span class="lineNum">    6669 </span>            :                        ( (isSgModifierType(isSgTypedefType(currentType)-&gt;get_base_type()) != NULL) &amp;&amp;</a>
<a name="6670"><span class="lineNum">    6670 </span>            :                          (isSgModifierType(isSgTypedefType(currentType)-&gt;get_base_type())-&gt;get_base_type() != currentType) ) );</a>
<a name="6671"><span class="lineNum">    6671 </span>            :         }</a>
<a name="6672"><span class="lineNum">    6672 </span>            : #endif</a>
<a name="6673"><span class="lineNum">    6673 </span><span class="lineCov">   55910000 :    }</span></a>
<a name="6674"><span class="lineNum">    6674 </span>            : </a>
<a name="6675"><span class="lineNum">    6675 </span>            : </a>
<a name="6676"><span class="lineNum">    6676 </span>            : #if 0</a>
<a name="6677"><span class="lineNum">    6677 </span>            : void</a>
<a name="6678"><span class="lineNum">    6678 </span>            : TestNodes::visit ( SgNode* node )</a>
<a name="6679"><span class="lineNum">    6679 </span>            :    {</a>
<a name="6680"><span class="lineNum">    6680 </span>            :   // DQ (10/25/2016): This test is to access each node in the memory pool to look for where an error occures.</a>
<a name="6681"><span class="lineNum">    6681 </span>            :   // It is part of debugging an erro in mergeTest_04.C</a>
<a name="6682"><span class="lineNum">    6682 </span>            : #if 0</a>
<a name="6683"><span class="lineNum">    6683 </span>            :      printf (&quot;TestNodes: node = %p \n&quot;,node);</a>
<a name="6684"><span class="lineNum">    6684 </span>            :      if (node != NULL)</a>
<a name="6685"><span class="lineNum">    6685 </span>            :         {</a>
<a name="6686"><span class="lineNum">    6686 </span>            :           printf (&quot;TestNodes: node = %p = %s \n&quot;,node,node-&gt;class_name().c_str());</a>
<a name="6687"><span class="lineNum">    6687 </span>            :         }</a>
<a name="6688"><span class="lineNum">    6688 </span>            : #else</a>
<a name="6689"><span class="lineNum">    6689 </span>            :      if (node != NULL)</a>
<a name="6690"><span class="lineNum">    6690 </span>            :         {</a>
<a name="6691"><span class="lineNum">    6691 </span>            :        // node-&gt;get_parent();</a>
<a name="6692"><span class="lineNum">    6692 </span>            :        // if (node-&gt;p_freepointer == IS_VALID_POINTER)</a>
<a name="6693"><span class="lineNum">    6693 </span>            :        // if (AST_FileIO::IS_VALID_POINTER() == true)</a>
<a name="6694"><span class="lineNum">    6694 </span>            :           if (node-&gt;get_freepointer() == AST_FileIO::IS_VALID_POINTER())</a>
<a name="6695"><span class="lineNum">    6695 </span>            :              {</a>
<a name="6696"><span class="lineNum">    6696 </span>            :                node-&gt;variantT();</a>
<a name="6697"><span class="lineNum">    6697 </span>            :              }</a>
<a name="6698"><span class="lineNum">    6698 </span>            :         }</a>
<a name="6699"><span class="lineNum">    6699 </span>            : #endif</a>
<a name="6700"><span class="lineNum">    6700 </span>            : </a>
<a name="6701"><span class="lineNum">    6701 </span>            :    }</a>
<a name="6702"><span class="lineNum">    6702 </span>            : </a>
<a name="6703"><span class="lineNum">    6703 </span>            : void</a>
<a name="6704"><span class="lineNum">    6704 </span>            : TestNodes::test()</a>
<a name="6705"><span class="lineNum">    6705 </span>            :    {</a>
<a name="6706"><span class="lineNum">    6706 </span>            :      TestNodes t;</a>
<a name="6707"><span class="lineNum">    6707 </span>            :   // t.traverse(node,preorder);</a>
<a name="6708"><span class="lineNum">    6708 </span>            :      t.traverseMemoryPool();</a>
<a name="6709"><span class="lineNum">    6709 </span>            :    }</a>
<a name="6710"><span class="lineNum">    6710 </span>            : #endif</a>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.14</a></td></tr>
  </table>
  <br>

</body>
</html>
