<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - ROSE - /home/yyan7/compiler/rexompiler/src/frontend/SageIII/sage_support/sage_support.cpp</title>
  <link rel="stylesheet" type="text/css" href="../../../../../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../../../../../index.html">top level</a> - <a href="index.html">home/yyan7/compiler/rexompiler/src/frontend/SageIII/sage_support</a> - sage_support.cpp<span style="font-size: 80%;"> (source / <a href="sage_support.cpp.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">ROSE</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">744</td>
            <td class="headerCovTableEntry">1638</td>
            <td class="headerCovTableEntryLo">45.4 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2022-12-08 13:48:47</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">34</td>
            <td class="headerCovTableEntry">63</td>
            <td class="headerCovTableEntryLo">54.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /**</a>
<a name="2"><span class="lineNum">       2 </span>            :  * \file    sage_support.cpp</a>
<a name="3"><span class="lineNum">       3 </span>            :  * \author  Justin Too &lt;too1@llnl.gov&gt;</a>
<a name="4"><span class="lineNum">       4 </span>            :  * \date    April 4, 2012</a>
<a name="5"><span class="lineNum">       5 </span>            :  */</a>
<a name="6"><span class="lineNum">       6 </span>            : </a>
<a name="7"><span class="lineNum">       7 </span>            : /*-----------------------------------------------------------------------------</a>
<a name="8"><span class="lineNum">       8 </span>            :  *  Dependencies</a>
<a name="9"><span class="lineNum">       9 </span>            :  *---------------------------------------------------------------------------*/</a>
<a name="10"><span class="lineNum">      10 </span>            : #include &quot;sage3basic.h&quot;</a>
<a name="11"><span class="lineNum">      11 </span>            : #include &quot;sage_support.h&quot;</a>
<a name="12"><span class="lineNum">      12 </span>            : #include &quot;keep_going.h&quot;</a>
<a name="13"><span class="lineNum">      13 </span>            : #include &quot;cmdline.h&quot;</a>
<a name="14"><span class="lineNum">      14 </span>            : #include &lt;Rose/FileSystem.h&gt;</a>
<a name="15"><span class="lineNum">      15 </span>            : #include &lt;Rose/CommandLine.h&gt;</a>
<a name="16"><span class="lineNum">      16 </span>            : </a>
<a name="17"><span class="lineNum">      17 </span>            : #ifdef ROSE_BUILD_FORTRAN_LANGUAGE_SUPPORT</a>
<a name="18"><span class="lineNum">      18 </span>            : #   include &quot;FortranModuleInfo.h&quot;</a>
<a name="19"><span class="lineNum">      19 </span>            : #   include &quot;FortranParserState.h&quot;</a>
<a name="20"><span class="lineNum">      20 </span>            : #   include &quot;unparseFortran_modfile.h&quot;</a>
<a name="21"><span class="lineNum">      21 </span>            : #endif</a>
<a name="22"><span class="lineNum">      22 </span>            : </a>
<a name="23"><span class="lineNum">      23 </span>            : #include &lt;algorithm&gt;</a>
<a name="24"><span class="lineNum">      24 </span>            : </a>
<a name="25"><span class="lineNum">      25 </span>            : #include &lt;boost/algorithm/string/join.hpp&gt;</a>
<a name="26"><span class="lineNum">      26 </span>            : #include &lt;boost/filesystem.hpp&gt;</a>
<a name="27"><span class="lineNum">      27 </span>            : #include &lt;boost/foreach.hpp&gt;</a>
<a name="28"><span class="lineNum">      28 </span>            : #include &lt;Sawyer/FileSystem.h&gt;</a>
<a name="29"><span class="lineNum">      29 </span>            : </a>
<a name="30"><span class="lineNum">      30 </span>            : // DQ (12/22/2019): I don't need this now, and it is an issue for some compilers (e.g. GNU 4.9.4).</a>
<a name="31"><span class="lineNum">      31 </span>            : // DQ (12/21/2019): Require hash table support for determining the shared nodes in the ASTs.</a>
<a name="32"><span class="lineNum">      32 </span>            : // #include &lt;unordered_map&gt;</a>
<a name="33"><span class="lineNum">      33 </span>            : </a>
<a name="34"><span class="lineNum">      34 </span>            : </a>
<a name="35"><span class="lineNum">      35 </span>            : #ifdef __INSURE__</a>
<a name="36"><span class="lineNum">      36 </span>            : // Provide a dummy function definition to support linking with Insure++.</a>
<a name="37"><span class="lineNum">      37 </span>            : // We have not identified why this is required.  This fixes the problem of</a>
<a name="38"><span class="lineNum">      38 </span>            : // a link error for the &quot;std::ostream &amp; operator&lt;&lt;()&quot; used with &quot;std::vector&lt;bool&gt;&quot;.</a>
<a name="39"><span class="lineNum">      39 </span>            : std::ostream &amp;</a>
<a name="40"><span class="lineNum">      40 </span>            : operator&lt;&lt;(std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp; os, std::vector&lt;bool, std::allocator&lt;bool&gt; &gt;&amp; m)</a>
<a name="41"><span class="lineNum">      41 </span>            :    {</a>
<a name="42"><span class="lineNum">      42 </span>            :      printf (&quot;Inside of std::ostream &amp; operator&lt;&lt;(std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp; os, std::vector&lt;bool, std::allocator&lt;bool&gt; &gt;&amp; m): A test! \n&quot;);</a>
<a name="43"><span class="lineNum">      43 </span>            :   // ROSE_ASSERT(false);</a>
<a name="44"><span class="lineNum">      44 </span>            :      return os;</a>
<a name="45"><span class="lineNum">      45 </span>            :    }</a>
<a name="46"><span class="lineNum">      46 </span>            : #endif</a>
<a name="47"><span class="lineNum">      47 </span>            : </a>
<a name="48"><span class="lineNum">      48 </span>            : // DQ (9/26/2018): Added so that we can call the display function for TokenStreamSequenceToNodeMapping (for debugging).</a>
<a name="49"><span class="lineNum">      49 </span>            : #include &quot;tokenStreamMapping.h&quot;</a>
<a name="50"><span class="lineNum">      50 </span>            : </a>
<a name="51"><span class="lineNum">      51 </span>            : using namespace std;</a>
<a name="52"><span class="lineNum">      52 </span>            : using namespace Rose;</a>
<a name="53"><span class="lineNum">      53 </span>            : using namespace SageInterface;</a>
<a name="54"><span class="lineNum">      54 </span>            : using namespace SageBuilder;</a>
<a name="55"><span class="lineNum">      55 </span>            : using namespace OmpSupport;</a>
<a name="56"><span class="lineNum">      56 </span>            : using namespace Sawyer::Message::Common;</a>
<a name="57"><span class="lineNum">      57 </span>            : </a>
<a name="58"><span class="lineNum">      58 </span>            : const string FileHelper::pathDelimiter = &quot;/&quot;;</a>
<a name="59"><span class="lineNum">      59 </span>            : </a>
<a name="60"><span class="lineNum">      60 </span>            : /* These symbols are defined when we include sage_support.h above - ZG (4/5/2013)</a>
<a name="61"><span class="lineNum">      61 </span>            : // DQ (9/17/2009): This appears to only be required for the GNU 4.1.x compiler (not for any earlier or later versions).</a>
<a name="62"><span class="lineNum">      62 </span>            : extern const std::string ROSE_GFORTRAN_PATH;</a>
<a name="63"><span class="lineNum">      63 </span>            : </a>
<a name="64"><span class="lineNum">      64 </span>            : // CER (10/11/2011): Added to allow OFP jar file to depend on version number based on date.</a>
<a name="65"><span class="lineNum">      65 </span>            : extern const std::string ROSE_OFP_VERSION_STRING;</a>
<a name="66"><span class="lineNum">      66 </span>            : */</a>
<a name="67"><span class="lineNum">      67 </span>            : </a>
<a name="68"><span class="lineNum">      68 </span>            : // DQ (12/6/2014): Moved this from the unparser.C fle to here so that it can</a>
<a name="69"><span class="lineNum">      69 </span>            : // be called before any processing of the AST (so that it relates to the original</a>
<a name="70"><span class="lineNum">      70 </span>            : // AST before transformations).</a>
<a name="71"><span class="lineNum">      71 </span>            : // void buildTokenStreamMapping(SgSourceFile* sourceFile);</a>
<a name="72"><span class="lineNum">      72 </span>            : // void buildTokenStreamMapping(SgSourceFile* sourceFile, vector&lt;stream_element*&gt; &amp; tokenVector);</a>
<a name="73"><span class="lineNum">      73 </span>            : </a>
<a name="74"><span class="lineNum">      74 </span>            : // DQ (11/30/2015): Adding general support fo the detection of macro expansions and include file expansions.</a>
<a name="75"><span class="lineNum">      75 </span>            : void detectMacroOrIncludeFileExpansions(SgSourceFile* sourceFile);</a>
<a name="76"><span class="lineNum">      76 </span>            : </a>
<a name="77"><span class="lineNum">      77 </span>            : </a>
<a name="78"><span class="lineNum">      78 </span>            : #ifdef _MSC_VER</a>
<a name="79"><span class="lineNum">      79 </span>            : // DQ (11/29/2009): MSVC does not support sprintf, but &quot;_snprintf&quot; is equivalent</a>
<a name="80"><span class="lineNum">      80 </span>            : // (note: printf_S is the safer version but with a different function argument list).</a>
<a name="81"><span class="lineNum">      81 </span>            : // We can use a macro to handle this portability issue for now.</a>
<a name="82"><span class="lineNum">      82 </span>            : #define snprintf _snprintf</a>
<a name="83"><span class="lineNum">      83 </span>            : #endif</a>
<a name="84"><span class="lineNum">      84 </span>            : </a>
<a name="85"><span class="lineNum">      85 </span>            : // DQ (2/12/2011): Added const so that this could be called in get_mangled() (and more generally).</a>
<a name="86"><span class="lineNum">      86 </span>            : // std::string SgValueExp::get_constant_folded_value_as_string()</a>
<a name="87"><span class="lineNum">      87 </span>            : std::string</a>
<a name="88"><span class="lineNum">      88 </span><span class="lineCov">        179 : SgValueExp::get_constant_folded_value_as_string() const</span></a>
<a name="89"><span class="lineNum">      89 </span>            :    {</a>
<a name="90"><span class="lineNum">      90 </span>            :   // DQ (8/18/2009): Added support for generating a string from a SgValueExp.</a>
<a name="91"><span class="lineNum">      91 </span>            :   // Note that the point is not to call unparse since that would provide the</a>
<a name="92"><span class="lineNum">      92 </span>            :   // expression tree and we want the constant folded value.</a>
<a name="93"><span class="lineNum">      93 </span>            : </a>
<a name="94"><span class="lineNum">      94 </span>            :   // DQ (7/24/2012): Added a test.</a>
<a name="95"><span class="lineNum">      95 </span><span class="lineCov">        179 :      ASSERT_not_null(this);</span></a>
<a name="96"><span class="lineNum">      96 </span>            : </a>
<a name="97"><span class="lineNum">      97 </span><span class="lineCov">        179 :      string s;</span></a>
<a name="98"><span class="lineNum">      98 </span><span class="lineCov">        179 :      const int max_buffer_size = 500;</span></a>
<a name="99"><span class="lineNum">      99 </span><span class="lineCov">        179 :      char buffer[max_buffer_size];</span></a>
<a name="100"><span class="lineNum">     100 </span><span class="lineCov">        179 :      switch (variantT())</span></a>
<a name="101"><span class="lineNum">     101 </span>            :         {</a>
<a name="102"><span class="lineNum">     102 </span><span class="lineCov">        178 :           case V_SgIntVal:</span></a>
<a name="103"><span class="lineNum">     103 </span><span class="lineCov">        178 :              {</span></a>
<a name="104"><span class="lineNum">     104 </span><span class="lineCov">        178 :                const SgIntVal* integerValueExpression = isSgIntVal(this);</span></a>
<a name="105"><span class="lineNum">     105 </span><span class="lineCov">        178 :                ASSERT_not_null(integerValueExpression);</span></a>
<a name="106"><span class="lineNum">     106 </span><span class="lineCov">        178 :                int numericValue = integerValueExpression-&gt;get_value();</span></a>
<a name="107"><span class="lineNum">     107 </span>            :             // printf (&quot;numericValue of constant folded expression = %d \n&quot;,numericValue);</a>
<a name="108"><span class="lineNum">     108 </span><span class="lineCov">        178 :                snprintf (buffer,max_buffer_size,&quot;%d&quot;,numericValue);</span></a>
<a name="109"><span class="lineNum">     109 </span><span class="lineCov">        178 :                s = buffer;</span></a>
<a name="110"><span class="lineNum">     110 </span>            :                break;</a>
<a name="111"><span class="lineNum">     111 </span>            :              }</a>
<a name="112"><span class="lineNum">     112 </span>            : </a>
<a name="113"><span class="lineNum">     113 </span>            :        // DQ (10/4/2010): Added case</a>
<a name="114"><span class="lineNum">     114 </span><span class="lineNoCov">          0 :           case V_SgLongIntVal:</span></a>
<a name="115"><span class="lineNum">     115 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="116"><span class="lineNum">     116 </span><span class="lineNoCov">          0 :                const SgLongIntVal* integerValueExpression = isSgLongIntVal(this);</span></a>
<a name="117"><span class="lineNum">     117 </span><span class="lineNoCov">          0 :                ASSERT_not_null(integerValueExpression);</span></a>
<a name="118"><span class="lineNum">     118 </span><span class="lineNoCov">          0 :                long int numericValue = integerValueExpression-&gt;get_value();</span></a>
<a name="119"><span class="lineNum">     119 </span>            :             // printf (&quot;numericValue of constant folded expression = %ld \n&quot;,numericValue);</a>
<a name="120"><span class="lineNum">     120 </span><span class="lineNoCov">          0 :                snprintf (buffer,max_buffer_size,&quot;%ld&quot;,numericValue);</span></a>
<a name="121"><span class="lineNum">     121 </span><span class="lineNoCov">          0 :                s = buffer;</span></a>
<a name="122"><span class="lineNum">     122 </span>            :                break;</a>
<a name="123"><span class="lineNum">     123 </span>            :              }</a>
<a name="124"><span class="lineNum">     124 </span>            : </a>
<a name="125"><span class="lineNum">     125 </span><span class="lineNoCov">          0 :          case V_SgLongLongIntVal:</span></a>
<a name="126"><span class="lineNum">     126 </span><span class="lineNoCov">          0 :          {</span></a>
<a name="127"><span class="lineNum">     127 </span><span class="lineNoCov">          0 :             const SgLongLongIntVal* integerValueExpression = isSgLongLongIntVal(this);</span></a>
<a name="128"><span class="lineNum">     128 </span><span class="lineNoCov">          0 :             ASSERT_not_null(integerValueExpression);</span></a>
<a name="129"><span class="lineNum">     129 </span><span class="lineNoCov">          0 :             long long int numericValue = integerValueExpression-&gt;get_value();</span></a>
<a name="130"><span class="lineNum">     130 </span>            :             // printf (&quot;numericValue of constant folded expression = %ld \n&quot;,numericValue);</a>
<a name="131"><span class="lineNum">     131 </span><span class="lineNoCov">          0 :             snprintf (buffer,max_buffer_size,&quot;%lld&quot;,numericValue);</span></a>
<a name="132"><span class="lineNum">     132 </span><span class="lineNoCov">          0 :             s = buffer;</span></a>
<a name="133"><span class="lineNum">     133 </span>            :             break;</a>
<a name="134"><span class="lineNum">     134 </span>            :          }</a>
<a name="135"><span class="lineNum">     135 </span>            : </a>
<a name="136"><span class="lineNum">     136 </span>            :        // DQ (10/5/2010): Added case</a>
<a name="137"><span class="lineNum">     137 </span><span class="lineNoCov">          0 :           case V_SgShortVal:</span></a>
<a name="138"><span class="lineNum">     138 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="139"><span class="lineNum">     139 </span><span class="lineNoCov">          0 :                const SgShortVal* integerValueExpression = isSgShortVal(this);</span></a>
<a name="140"><span class="lineNum">     140 </span><span class="lineNoCov">          0 :                ASSERT_not_null(integerValueExpression);</span></a>
<a name="141"><span class="lineNum">     141 </span><span class="lineNoCov">          0 :                short int numericValue = integerValueExpression-&gt;get_value();</span></a>
<a name="142"><span class="lineNum">     142 </span>            :             // printf (&quot;numericValue of constant folded expression = %ld \n&quot;,numericValue);</a>
<a name="143"><span class="lineNum">     143 </span><span class="lineNoCov">          0 :                snprintf (buffer,max_buffer_size,&quot;%d&quot;,numericValue);</span></a>
<a name="144"><span class="lineNum">     144 </span><span class="lineNoCov">          0 :                s = buffer;</span></a>
<a name="145"><span class="lineNum">     145 </span>            :                break;</a>
<a name="146"><span class="lineNum">     146 </span>            :              }</a>
<a name="147"><span class="lineNum">     147 </span>            : </a>
<a name="148"><span class="lineNum">     148 </span><span class="lineNoCov">          0 :           case V_SgUnsignedShortVal:</span></a>
<a name="149"><span class="lineNum">     149 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="150"><span class="lineNum">     150 </span><span class="lineNoCov">          0 :                const SgUnsignedShortVal* integerValueExpression = isSgUnsignedShortVal(this);</span></a>
<a name="151"><span class="lineNum">     151 </span><span class="lineNoCov">          0 :                ASSERT_not_null(integerValueExpression);</span></a>
<a name="152"><span class="lineNum">     152 </span><span class="lineNoCov">          0 :                unsigned short int numericValue = integerValueExpression-&gt;get_value();</span></a>
<a name="153"><span class="lineNum">     153 </span>            :             // printf (&quot;numericValue of constant folded expression = %ld \n&quot;,numericValue);</a>
<a name="154"><span class="lineNum">     154 </span><span class="lineNoCov">          0 :                snprintf (buffer,max_buffer_size,&quot;%u&quot;,numericValue);</span></a>
<a name="155"><span class="lineNum">     155 </span><span class="lineNoCov">          0 :                s = buffer;</span></a>
<a name="156"><span class="lineNum">     156 </span>            :                break;</a>
<a name="157"><span class="lineNum">     157 </span>            :              }</a>
<a name="158"><span class="lineNum">     158 </span>            : </a>
<a name="159"><span class="lineNum">     159 </span><span class="lineNoCov">          0 :           case V_SgUnsignedLongLongIntVal:</span></a>
<a name="160"><span class="lineNum">     160 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="161"><span class="lineNum">     161 </span><span class="lineNoCov">          0 :                const SgUnsignedLongLongIntVal* integerValueExpression = isSgUnsignedLongLongIntVal(this);</span></a>
<a name="162"><span class="lineNum">     162 </span><span class="lineNoCov">          0 :                ASSERT_not_null(integerValueExpression);</span></a>
<a name="163"><span class="lineNum">     163 </span><span class="lineNoCov">          0 :                unsigned long long int numericValue = integerValueExpression-&gt;get_value();</span></a>
<a name="164"><span class="lineNum">     164 </span>            :             // printf (&quot;numericValue of constant folded expression = %llu \n&quot;,numericValue);</a>
<a name="165"><span class="lineNum">     165 </span><span class="lineNoCov">          0 :                snprintf (buffer,max_buffer_size,&quot;%llu&quot;,numericValue);</span></a>
<a name="166"><span class="lineNum">     166 </span><span class="lineNoCov">          0 :                s = buffer;</span></a>
<a name="167"><span class="lineNum">     167 </span>            :                break;</a>
<a name="168"><span class="lineNum">     168 </span>            :              }</a>
<a name="169"><span class="lineNum">     169 </span>            : </a>
<a name="170"><span class="lineNum">     170 </span>            :        // DQ (8/19/2009): Added case</a>
<a name="171"><span class="lineNum">     171 </span><span class="lineNoCov">          0 :           case V_SgUnsignedLongVal:</span></a>
<a name="172"><span class="lineNum">     172 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="173"><span class="lineNum">     173 </span><span class="lineNoCov">          0 :                const SgUnsignedLongVal* integerValueExpression = isSgUnsignedLongVal(this);</span></a>
<a name="174"><span class="lineNum">     174 </span><span class="lineNoCov">          0 :                ASSERT_not_null(integerValueExpression);</span></a>
<a name="175"><span class="lineNum">     175 </span><span class="lineNoCov">          0 :                unsigned long int numericValue = integerValueExpression-&gt;get_value();</span></a>
<a name="176"><span class="lineNum">     176 </span>            :             // printf (&quot;numericValue of constant folded expression = %llu \n&quot;,numericValue);</a>
<a name="177"><span class="lineNum">     177 </span><span class="lineNoCov">          0 :                snprintf (buffer,max_buffer_size,&quot;%lu&quot;,numericValue);</span></a>
<a name="178"><span class="lineNum">     178 </span><span class="lineNoCov">          0 :                s = buffer;</span></a>
<a name="179"><span class="lineNum">     179 </span>            :                break;</a>
<a name="180"><span class="lineNum">     180 </span>            :              }</a>
<a name="181"><span class="lineNum">     181 </span>            : </a>
<a name="182"><span class="lineNum">     182 </span>            :        // DQ (8/19/2009): Added case</a>
<a name="183"><span class="lineNum">     183 </span><span class="lineNoCov">          0 :           case V_SgUnsignedIntVal:</span></a>
<a name="184"><span class="lineNum">     184 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="185"><span class="lineNum">     185 </span><span class="lineNoCov">          0 :                const SgUnsignedIntVal* integerValueExpression = isSgUnsignedIntVal(this);</span></a>
<a name="186"><span class="lineNum">     186 </span><span class="lineNoCov">          0 :                ASSERT_not_null(integerValueExpression);</span></a>
<a name="187"><span class="lineNum">     187 </span><span class="lineNoCov">          0 :                unsigned int numericValue = integerValueExpression-&gt;get_value();</span></a>
<a name="188"><span class="lineNum">     188 </span>            :             // printf (&quot;numericValue of constant folded expression = %llu \n&quot;,numericValue);</a>
<a name="189"><span class="lineNum">     189 </span><span class="lineNoCov">          0 :                snprintf (buffer,max_buffer_size,&quot;%u&quot;,numericValue);</span></a>
<a name="190"><span class="lineNum">     190 </span><span class="lineNoCov">          0 :                s = buffer;</span></a>
<a name="191"><span class="lineNum">     191 </span>            :                break;</a>
<a name="192"><span class="lineNum">     192 </span>            :              }</a>
<a name="193"><span class="lineNum">     193 </span>            : </a>
<a name="194"><span class="lineNum">     194 </span>            :        // DQ (8/19/2009): Added case</a>
<a name="195"><span class="lineNum">     195 </span><span class="lineNoCov">          0 :           case V_SgBoolValExp:</span></a>
<a name="196"><span class="lineNum">     196 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="197"><span class="lineNum">     197 </span><span class="lineNoCov">          0 :                const SgBoolValExp* booleanValueExpression = isSgBoolValExp(this);</span></a>
<a name="198"><span class="lineNum">     198 </span><span class="lineNoCov">          0 :                ASSERT_not_null(booleanValueExpression);</span></a>
<a name="199"><span class="lineNum">     199 </span><span class="lineNoCov">          0 :                bool booleanValue = booleanValueExpression-&gt;get_value();</span></a>
<a name="200"><span class="lineNum">     200 </span><span class="lineNoCov">          0 :                snprintf (buffer,max_buffer_size,&quot;%s&quot;,booleanValue == true ? &quot;true&quot; : &quot;false&quot;);</span></a>
<a name="201"><span class="lineNum">     201 </span><span class="lineNoCov">          0 :                s = buffer;</span></a>
<a name="202"><span class="lineNum">     202 </span>            :                break;</a>
<a name="203"><span class="lineNum">     203 </span>            :              }</a>
<a name="204"><span class="lineNum">     204 </span>            : </a>
<a name="205"><span class="lineNum">     205 </span>            :        // DQ (8/19/2009): Added case</a>
<a name="206"><span class="lineNum">     206 </span><span class="lineNoCov">          0 :           case V_SgStringVal:</span></a>
<a name="207"><span class="lineNum">     207 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="208"><span class="lineNum">     208 </span><span class="lineNoCov">          0 :                const SgStringVal* stringValueExpression = isSgStringVal(this);</span></a>
<a name="209"><span class="lineNum">     209 </span><span class="lineNoCov">          0 :                ASSERT_not_null(stringValueExpression);</span></a>
<a name="210"><span class="lineNum">     210 </span><span class="lineNoCov">          0 :                s = stringValueExpression-&gt;get_value();</span></a>
<a name="211"><span class="lineNum">     211 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="212"><span class="lineNum">     212 </span>            :              }</a>
<a name="213"><span class="lineNum">     213 </span>            : </a>
<a name="214"><span class="lineNum">     214 </span>            :        // DQ (8/19/2009): Added case</a>
<a name="215"><span class="lineNum">     215 </span><span class="lineNoCov">          0 :           case V_SgCharVal:</span></a>
<a name="216"><span class="lineNum">     216 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="217"><span class="lineNum">     217 </span><span class="lineNoCov">          0 :                const SgCharVal* charValueExpression = isSgCharVal(this);</span></a>
<a name="218"><span class="lineNum">     218 </span><span class="lineNoCov">          0 :                ASSERT_not_null(charValueExpression);</span></a>
<a name="219"><span class="lineNum">     219 </span>            :             // DQ (9/24/2011): Handle case where this is non-printable character (see test2011_140.C, where</a>
<a name="220"><span class="lineNum">     220 </span>            :             // the bug was the the dot file had a non-printable character and caused zgrviewer to crash).</a>
<a name="221"><span class="lineNum">     221 </span>            :             // s = charValueExpression-&gt;get_value();</a>
<a name="222"><span class="lineNum">     222 </span><span class="lineNoCov">          0 :                char value = charValueExpression-&gt;get_value();</span></a>
<a name="223"><span class="lineNum">     223 </span><span class="lineNoCov">          0 :                if (isalnum(value) == true)</span></a>
<a name="224"><span class="lineNum">     224 </span>            :                   {</a>
<a name="225"><span class="lineNum">     225 </span>            :                  // Leave this as a alpha or numeric value where possible.</a>
<a name="226"><span class="lineNum">     226 </span><span class="lineNoCov">          0 :                     s = charValueExpression-&gt;get_value();</span></a>
<a name="227"><span class="lineNum">     227 </span>            :                   }</a>
<a name="228"><span class="lineNum">     228 </span>            :                  else</a>
<a name="229"><span class="lineNum">     229 </span>            :                   {</a>
<a name="230"><span class="lineNum">     230 </span>            :                  // Convert this to be a string of the numeric value so that it will print.</a>
<a name="231"><span class="lineNum">     231 </span><span class="lineNoCov">          0 :                     snprintf (buffer,max_buffer_size,&quot;%d&quot;,value);</span></a>
<a name="232"><span class="lineNum">     232 </span><span class="lineNoCov">          0 :                     s = buffer;</span></a>
<a name="233"><span class="lineNum">     233 </span>            :                   }</a>
<a name="234"><span class="lineNum">     234 </span>            :                break;</a>
<a name="235"><span class="lineNum">     235 </span>            :              }</a>
<a name="236"><span class="lineNum">     236 </span>            : </a>
<a name="237"><span class="lineNum">     237 </span>            :        // DQ (10/4/2010): Added case</a>
<a name="238"><span class="lineNum">     238 </span><span class="lineCov">          1 :           case V_SgFloatVal:</span></a>
<a name="239"><span class="lineNum">     239 </span><span class="lineCov">          1 :              {</span></a>
<a name="240"><span class="lineNum">     240 </span><span class="lineCov">          1 :                const SgFloatVal* floatValueExpression = isSgFloatVal(this);</span></a>
<a name="241"><span class="lineNum">     241 </span><span class="lineCov">          1 :                ASSERT_not_null(floatValueExpression);</span></a>
<a name="242"><span class="lineNum">     242 </span><span class="lineCov">          1 :                float numericValue = floatValueExpression-&gt;get_value();</span></a>
<a name="243"><span class="lineNum">     243 </span>            :             // printf (&quot;numericValue of constant folded expression = %f \n&quot;,numericValue);</a>
<a name="244"><span class="lineNum">     244 </span><span class="lineCov">          1 :                snprintf (buffer,max_buffer_size,&quot;%f&quot;,numericValue);</span></a>
<a name="245"><span class="lineNum">     245 </span><span class="lineCov">          1 :                s = buffer;</span></a>
<a name="246"><span class="lineNum">     246 </span>            :                break;</a>
<a name="247"><span class="lineNum">     247 </span>            :              }</a>
<a name="248"><span class="lineNum">     248 </span>            : </a>
<a name="249"><span class="lineNum">     249 </span>            :        // DQ (10/4/2010): Added case</a>
<a name="250"><span class="lineNum">     250 </span><span class="lineNoCov">          0 :           case V_SgDoubleVal:</span></a>
<a name="251"><span class="lineNum">     251 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="252"><span class="lineNum">     252 </span><span class="lineNoCov">          0 :                const SgDoubleVal* floatValueExpression = isSgDoubleVal(this);</span></a>
<a name="253"><span class="lineNum">     253 </span><span class="lineNoCov">          0 :                ASSERT_not_null(floatValueExpression);</span></a>
<a name="254"><span class="lineNum">     254 </span><span class="lineNoCov">          0 :                double numericValue = floatValueExpression-&gt;get_value();</span></a>
<a name="255"><span class="lineNum">     255 </span>            :             // printf (&quot;numericValue of constant folded expression = %f \n&quot;,numericValue);</a>
<a name="256"><span class="lineNum">     256 </span><span class="lineNoCov">          0 :                snprintf (buffer,max_buffer_size,&quot;%lf&quot;,numericValue);</span></a>
<a name="257"><span class="lineNum">     257 </span><span class="lineNoCov">          0 :                s = buffer;</span></a>
<a name="258"><span class="lineNum">     258 </span>            :                break;</a>
<a name="259"><span class="lineNum">     259 </span>            :              }</a>
<a name="260"><span class="lineNum">     260 </span>            : </a>
<a name="261"><span class="lineNum">     261 </span>            :        // DQ (10/4/2010): Added case</a>
<a name="262"><span class="lineNum">     262 </span><span class="lineNoCov">          0 :           case V_SgLongDoubleVal:</span></a>
<a name="263"><span class="lineNum">     263 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="264"><span class="lineNum">     264 </span><span class="lineNoCov">          0 :                const SgLongDoubleVal* floatValueExpression = isSgLongDoubleVal(this);</span></a>
<a name="265"><span class="lineNum">     265 </span><span class="lineNoCov">          0 :                ASSERT_not_null(floatValueExpression);</span></a>
<a name="266"><span class="lineNum">     266 </span><span class="lineNoCov">          0 :                long double numericValue = floatValueExpression-&gt;get_value();</span></a>
<a name="267"><span class="lineNum">     267 </span>            :             // printf (&quot;numericValue of constant folded expression = %f \n&quot;,numericValue);</a>
<a name="268"><span class="lineNum">     268 </span><span class="lineNoCov">          0 :                snprintf (buffer,max_buffer_size,&quot;%Lf&quot;,numericValue);</span></a>
<a name="269"><span class="lineNum">     269 </span><span class="lineNoCov">          0 :                s = buffer;</span></a>
<a name="270"><span class="lineNum">     270 </span>            :                break;</a>
<a name="271"><span class="lineNum">     271 </span>            :              }</a>
<a name="272"><span class="lineNum">     272 </span>            : </a>
<a name="273"><span class="lineNum">     273 </span>            :        // DQ (10/4/2010): Added case</a>
<a name="274"><span class="lineNum">     274 </span><span class="lineNoCov">          0 :           case V_SgEnumVal:</span></a>
<a name="275"><span class="lineNum">     275 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="276"><span class="lineNum">     276 </span><span class="lineNoCov">          0 :                const SgEnumVal* enumValueExpression = isSgEnumVal(this);</span></a>
<a name="277"><span class="lineNum">     277 </span><span class="lineNoCov">          0 :                ASSERT_not_null(enumValueExpression);</span></a>
<a name="278"><span class="lineNum">     278 </span><span class="lineNoCov">          0 :                int numericValue = enumValueExpression-&gt;get_value();</span></a>
<a name="279"><span class="lineNum">     279 </span>            :             // printf (&quot;numericValue of constant folded expression = %d \n&quot;,numericValue);</a>
<a name="280"><span class="lineNum">     280 </span><span class="lineNoCov">          0 :                snprintf (buffer,max_buffer_size,&quot;%d&quot;,numericValue);</span></a>
<a name="281"><span class="lineNum">     281 </span><span class="lineNoCov">          0 :                s = string(&quot;_enum_&quot;) + string(buffer);</span></a>
<a name="282"><span class="lineNum">     282 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="283"><span class="lineNum">     283 </span>            :              }</a>
<a name="284"><span class="lineNum">     284 </span>            : </a>
<a name="285"><span class="lineNum">     285 </span>            :         // \pp (03/15/2011): Added case</a>
<a name="286"><span class="lineNum">     286 </span><span class="lineNoCov">          0 :           case V_SgUpcThreads:</span></a>
<a name="287"><span class="lineNum">     287 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="288"><span class="lineNum">     288 </span><span class="lineNoCov">          0 :                s = &quot;_upc_threads_&quot;;</span></a>
<a name="289"><span class="lineNum">     289 </span>            :                break;</a>
<a name="290"><span class="lineNum">     290 </span>            :              }</a>
<a name="291"><span class="lineNum">     291 </span>            : </a>
<a name="292"><span class="lineNum">     292 </span>            :        // DQ (9/24/2011): Added support for complex values to be output as strings.</a>
<a name="293"><span class="lineNum">     293 </span><span class="lineNoCov">          0 :           case V_SgComplexVal:</span></a>
<a name="294"><span class="lineNum">     294 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="295"><span class="lineNum">     295 </span><span class="lineNoCov">          0 :                const SgComplexVal* complexValueExpression = isSgComplexVal(this);</span></a>
<a name="296"><span class="lineNum">     296 </span><span class="lineNoCov">          0 :                ASSERT_not_null(complexValueExpression);</span></a>
<a name="297"><span class="lineNum">     297 </span>            : </a>
<a name="298"><span class="lineNum">     298 </span><span class="lineNoCov">          0 :                string real_string = &quot;null&quot;;</span></a>
<a name="299"><span class="lineNum">     299 </span><span class="lineNoCov">          0 :                if (complexValueExpression-&gt;get_real_value() != nullptr)</span></a>
<a name="300"><span class="lineNum">     300 </span><span class="lineNoCov">          0 :                     real_string = complexValueExpression-&gt;get_real_value()-&gt;get_constant_folded_value_as_string();</span></a>
<a name="301"><span class="lineNum">     301 </span>            : </a>
<a name="302"><span class="lineNum">     302 </span><span class="lineNoCov">          0 :                string imaginary_string = &quot;null&quot;;</span></a>
<a name="303"><span class="lineNum">     303 </span><span class="lineNoCov">          0 :                if (complexValueExpression-&gt;get_imaginary_value() != nullptr)</span></a>
<a name="304"><span class="lineNum">     304 </span><span class="lineNoCov">          0 :                     imaginary_string = complexValueExpression-&gt;get_imaginary_value()-&gt;get_constant_folded_value_as_string();</span></a>
<a name="305"><span class="lineNum">     305 </span>            : </a>
<a name="306"><span class="lineNum">     306 </span><span class="lineNoCov">          0 :                s = &quot;(&quot; + real_string + &quot;,&quot; + imaginary_string + &quot;)&quot;;</span></a>
<a name="307"><span class="lineNum">     307 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="308"><span class="lineNum">     308 </span>            :              }</a>
<a name="309"><span class="lineNum">     309 </span>            : </a>
<a name="310"><span class="lineNum">     310 </span>            :        // DQ (11/28/2011): Adding support for template declarations in the AST.</a>
<a name="311"><span class="lineNum">     311 </span><span class="lineNoCov">          0 :           case V_SgTemplateParameterVal:</span></a>
<a name="312"><span class="lineNum">     312 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="313"><span class="lineNum">     313 </span>            :             // Note that constant folding on SgTemplateParameterVal expressions does not make any sense!</a>
<a name="314"><span class="lineNum">     314 </span><span class="lineNoCov">          0 :                const SgTemplateParameterVal* templateParameterValueExpression = isSgTemplateParameterVal(this);</span></a>
<a name="315"><span class="lineNum">     315 </span><span class="lineNoCov">          0 :                ASSERT_not_null(templateParameterValueExpression);</span></a>
<a name="316"><span class="lineNum">     316 </span><span class="lineNoCov">          0 :                string stringName = templateParameterValueExpression-&gt;get_template_parameter_name();</span></a>
<a name="317"><span class="lineNum">     317 </span><span class="lineNoCov">          0 :                s = stringName;</span></a>
<a name="318"><span class="lineNum">     318 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="319"><span class="lineNum">     319 </span>            :              }</a>
<a name="320"><span class="lineNum">     320 </span>            : </a>
<a name="321"><span class="lineNum">     321 </span>            :        // DQ (11/10/2014): Adding support for C++11 value &quot;nullptr&quot;.</a>
<a name="322"><span class="lineNum">     322 </span><span class="lineNoCov">          0 :           case V_SgNullptrValExp:</span></a>
<a name="323"><span class="lineNum">     323 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="324"><span class="lineNum">     324 </span><span class="lineNoCov">          0 :                s = &quot;_nullptr_&quot;;</span></a>
<a name="325"><span class="lineNum">     325 </span>            :                break;</a>
<a name="326"><span class="lineNum">     326 </span>            :              }</a>
<a name="327"><span class="lineNum">     327 </span>            : </a>
<a name="328"><span class="lineNum">     328 </span>            :        // DQ (2/12/2019): Adding support for SgWcharVal.</a>
<a name="329"><span class="lineNum">     329 </span><span class="lineNoCov">          0 :           case V_SgWcharVal:</span></a>
<a name="330"><span class="lineNum">     330 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="331"><span class="lineNum">     331 </span><span class="lineNoCov">          0 :                const SgWcharVal* wideCharValueExpression = isSgWcharVal(this);</span></a>
<a name="332"><span class="lineNum">     332 </span><span class="lineNoCov">          0 :                ASSERT_not_null(wideCharValueExpression);</span></a>
<a name="333"><span class="lineNum">     333 </span>            :             // DQ (9/24/2011): Handle case where this is non-printable character (see test2011_140.C, where</a>
<a name="334"><span class="lineNum">     334 </span>            :             // the bug was the the dot file had a non-printable character and caused zgrviewer to crash).</a>
<a name="335"><span class="lineNum">     335 </span>            :             // s = charValueExpression-&gt;get_value();</a>
<a name="336"><span class="lineNum">     336 </span><span class="lineNoCov">          0 :                char value = wideCharValueExpression-&gt;get_value();</span></a>
<a name="337"><span class="lineNum">     337 </span><span class="lineNoCov">          0 :                if (isalnum(value) == true)</span></a>
<a name="338"><span class="lineNum">     338 </span>            :                   {</a>
<a name="339"><span class="lineNum">     339 </span>            :                  // Leave this as a alpha or numeric value where possible.</a>
<a name="340"><span class="lineNum">     340 </span><span class="lineNoCov">          0 :                     s = wideCharValueExpression-&gt;get_value();</span></a>
<a name="341"><span class="lineNum">     341 </span>            :                   }</a>
<a name="342"><span class="lineNum">     342 </span>            :                  else</a>
<a name="343"><span class="lineNum">     343 </span>            :                   {</a>
<a name="344"><span class="lineNum">     344 </span>            :                  // Convert this to be a string of the numeric value so that it will print.</a>
<a name="345"><span class="lineNum">     345 </span><span class="lineNoCov">          0 :                     snprintf (buffer,max_buffer_size,&quot;%d&quot;,value);</span></a>
<a name="346"><span class="lineNum">     346 </span><span class="lineNoCov">          0 :                     s = buffer;</span></a>
<a name="347"><span class="lineNum">     347 </span>            :                   }</a>
<a name="348"><span class="lineNum">     348 </span>            :                break;</a>
<a name="349"><span class="lineNum">     349 </span>            :              }</a>
<a name="350"><span class="lineNum">     350 </span>            : </a>
<a name="351"><span class="lineNum">     351 </span><span class="lineNoCov">          0 :           default:</span></a>
<a name="352"><span class="lineNum">     352 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="353"><span class="lineNum">     353 </span><span class="lineNoCov">          0 :                printf (&quot;Error SgValueExp::get_constant_folded_value_as_string(): case of value = %s not handled \n&quot;,this-&gt;class_name().c_str());</span></a>
<a name="354"><span class="lineNum">     354 </span><span class="lineNoCov">          0 :                ROSE_ABORT();</span></a>
<a name="355"><span class="lineNum">     355 </span>            :              }</a>
<a name="356"><span class="lineNum">     356 </span>            :         }</a>
<a name="357"><span class="lineNum">     357 </span>            : </a>
<a name="358"><span class="lineNum">     358 </span><span class="lineCov">        179 :      return s;</span></a>
<a name="359"><span class="lineNum">     359 </span>            :    }</a>
<a name="360"><span class="lineNum">     360 </span>            : </a>
<a name="361"><span class="lineNum">     361 </span>            : void</a>
<a name="362"><span class="lineNum">     362 </span><span class="lineNoCov">          0 : whatTypeOfFileIsThis( const string &amp; name )</span></a>
<a name="363"><span class="lineNum">     363 </span>            :    {</a>
<a name="364"><span class="lineNum">     364 </span>            :   // DQ (2/3/2009): It is helpful to report what type of file this is where possible.</a>
<a name="365"><span class="lineNum">     365 </span>            :   // Call the Unix &quot;file&quot; command, it would be great if this was an available</a>
<a name="366"><span class="lineNum">     366 </span>            :   // system call (but Robb thinks it might not always be available).</a>
<a name="367"><span class="lineNum">     367 </span>            : </a>
<a name="368"><span class="lineNum">     368 </span><span class="lineNoCov">          0 :      vector&lt;string&gt; commandLineVector;</span></a>
<a name="369"><span class="lineNum">     369 </span><span class="lineNoCov">          0 :      commandLineVector.push_back(&quot;file -b &quot; + name);</span></a>
<a name="370"><span class="lineNum">     370 </span>            : </a>
<a name="371"><span class="lineNum">     371 </span>            :   // printf (&quot;Unknown file: %s &quot;,name.c_str());</a>
<a name="372"><span class="lineNum">     372 </span><span class="lineNoCov">          0 :      printf (&quot;Error: unknown file type: &quot;);</span></a>
<a name="373"><span class="lineNum">     373 </span><span class="lineNoCov">          0 :      flush(cout);</span></a>
<a name="374"><span class="lineNum">     374 </span>            : </a>
<a name="375"><span class="lineNum">     375 </span>            :   // I could not make this work!</a>
<a name="376"><span class="lineNum">     376 </span>            :   // systemFromVector (commandLineVector);</a>
<a name="377"><span class="lineNum">     377 </span>            : </a>
<a name="378"><span class="lineNum">     378 </span>            :   // Use &quot;-b&quot; for brief mode!</a>
<a name="379"><span class="lineNum">     379 </span><span class="lineNoCov">          0 :      string commandLine = &quot;file &quot; + name;</span></a>
<a name="380"><span class="lineNum">     380 </span><span class="lineNoCov">          0 :      if (system(commandLine.c_str()))</span></a>
<a name="381"><span class="lineNum">     381 </span><span class="lineNoCov">          0 :          mlog[ERROR] &lt;&lt;&quot;command failed: \&quot;&quot; &lt;&lt;StringUtility::cEscape(commandLine) &lt;&lt;&quot;\&quot;\n&quot;;</span></a>
<a name="382"><span class="lineNum">     382 </span><span class="lineNoCov">          0 :    }</span></a>
<a name="383"><span class="lineNum">     383 </span>            : </a>
<a name="384"><span class="lineNum">     384 </span>            : </a>
<a name="385"><span class="lineNum">     385 </span>            : </a>
<a name="386"><span class="lineNum">     386 </span>            : void</a>
<a name="387"><span class="lineNum">     387 </span><span class="lineNoCov">          0 : outputTypeOfFileAndExit( const string &amp; name )</span></a>
<a name="388"><span class="lineNum">     388 </span>            :    {</a>
<a name="389"><span class="lineNum">     389 </span>            :   // DQ (8/20/2008): The code (from Robb) identifies what kind of file this is or</a>
<a name="390"><span class="lineNum">     390 </span>            :   // more specifically what kind of file most tools would think this</a>
<a name="391"><span class="lineNum">     391 </span>            :   // file is (using the system file(1) command as a standard way to identify</a>
<a name="392"><span class="lineNum">     392 </span>            :   // file types using their first few bytes.</a>
<a name="393"><span class="lineNum">     393 </span>            : </a>
<a name="394"><span class="lineNum">     394 </span>            :   // printf (&quot;In outputTypeOfFileAndExit(%s): Evaluate the file type \n&quot;,name.c_str());</a>
<a name="395"><span class="lineNum">     395 </span>            : </a>
<a name="396"><span class="lineNum">     396 </span>            : #define DEAD_CODE_POTENTIALLY_USEFUL 0</a>
<a name="397"><span class="lineNum">     397 </span>            : #if DEAD_CODE_POTENTIALLY_USEFUL</a>
<a name="398"><span class="lineNum">     398 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="399"><span class="lineNum">     399 </span>            : </a>
<a name="400"><span class="lineNum">     400 </span>            :   // DQ (2/3/2009): This works now, I think that Andreas fixed it.</a>
<a name="401"><span class="lineNum">     401 </span>            : </a>
<a name="402"><span class="lineNum">     402 </span>            :   // Use file(1) to try to figure out the file type to report in the exception</a>
<a name="403"><span class="lineNum">     403 </span>            :      int child_stdout[2];</a>
<a name="404"><span class="lineNum">     404 </span>            :      pipe(child_stdout);</a>
<a name="405"><span class="lineNum">     405 </span>            :      pid_t pid = fork();</a>
<a name="406"><span class="lineNum">     406 </span>            : </a>
<a name="407"><span class="lineNum">     407 </span>            :      printf (&quot;pid = %d \n&quot;,pid);</a>
<a name="408"><span class="lineNum">     408 </span>            : </a>
<a name="409"><span class="lineNum">     409 </span>            :      if (pid == -1)</a>
<a name="410"><span class="lineNum">     410 </span>            :         { // Error</a>
<a name="411"><span class="lineNum">     411 </span>            :           perror(&quot;fork: error in outputTypeOfFileAndExit &quot;);</a>
<a name="412"><span class="lineNum">     412 </span>            :           exit (1);</a>
<a name="413"><span class="lineNum">     413 </span>            :         }</a>
<a name="414"><span class="lineNum">     414 </span>            :      if (0 == pid)</a>
<a name="415"><span class="lineNum">     415 </span>            :         {</a>
<a name="416"><span class="lineNum">     416 </span>            :           close(0);</a>
<a name="417"><span class="lineNum">     417 </span>            :           dup2(child_stdout[1], 1);</a>
<a name="418"><span class="lineNum">     418 </span>            :           close(child_stdout[0]);</a>
<a name="419"><span class="lineNum">     419 </span>            :           close(child_stdout[1]);</a>
<a name="420"><span class="lineNum">     420 </span>            :           execlp(&quot;/usr/bin/file&quot;, &quot;/usr/bin/file&quot;, &quot;-b&quot;, name.c_str(), nullptr);</a>
<a name="421"><span class="lineNum">     421 </span>            :           exit(1);</a>
<a name="422"><span class="lineNum">     422 </span>            :         }</a>
<a name="423"><span class="lineNum">     423 </span>            :        else</a>
<a name="424"><span class="lineNum">     424 </span>            :         {</a>
<a name="425"><span class="lineNum">     425 </span>            :           int status;</a>
<a name="426"><span class="lineNum">     426 </span>            :           if (waitpid(pid, &amp;status, 0) == -1)</a>
<a name="427"><span class="lineNum">     427 </span>            :              {</a>
<a name="428"><span class="lineNum">     428 </span>            :                perror(&quot;waitpid&quot;);</a>
<a name="429"><span class="lineNum">     429 </span>            :                abort();</a>
<a name="430"><span class="lineNum">     430 </span>            :              }</a>
<a name="431"><span class="lineNum">     431 </span>            : </a>
<a name="432"><span class="lineNum">     432 </span>            :           char buf[4096];</a>
<a name="433"><span class="lineNum">     433 </span>            :           memset(buf, 0, sizeof buf);</a>
<a name="434"><span class="lineNum">     434 </span>            :           read(child_stdout[0], buf, sizeof buf);</a>
<a name="435"><span class="lineNum">     435 </span>            :           std::string buffer(buf);</a>
<a name="436"><span class="lineNum">     436 </span>            :           buffer =  name+ &quot; unrecognized file format: &quot; + buffer;</a>
<a name="437"><span class="lineNum">     437 </span>            : </a>
<a name="438"><span class="lineNum">     438 </span>            :        // DQ (2/3/2009): It is helpful to report what type of file this is where possible.</a>
<a name="439"><span class="lineNum">     439 </span>            :           whatTypeOfFileIsThis(name);</a>
<a name="440"><span class="lineNum">     440 </span>            : </a>
<a name="441"><span class="lineNum">     441 </span>            :           throw SgAsmGenericFile::FormatError(buffer.c_str());</a>
<a name="442"><span class="lineNum">     442 </span>            :         }</a>
<a name="443"><span class="lineNum">     443 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="444"><span class="lineNum">     444 </span>            : #else</a>
<a name="445"><span class="lineNum">     445 </span><span class="lineNoCov">          0 :      whatTypeOfFileIsThis(name);</span></a>
<a name="446"><span class="lineNum">     446 </span>            : </a>
<a name="447"><span class="lineNum">     447 </span><span class="lineNoCov">          0 :      printf (&quot;In outputTypeOfFileAndExit(): name = %s \n&quot;,name.c_str());</span></a>
<a name="448"><span class="lineNum">     448 </span><span class="lineNoCov">          0 :      printf (&quot;\n\nExiting: Unknown file Error \n\n&quot;);</span></a>
<a name="449"><span class="lineNum">     449 </span><span class="lineNoCov">          0 :      ROSE_ABORT();</span></a>
<a name="450"><span class="lineNum">     450 </span>            : #endif</a>
<a name="451"><span class="lineNum">     451 </span>            :    }</a>
<a name="452"><span class="lineNum">     452 </span>            : </a>
<a name="453"><span class="lineNum">     453 </span>            : </a>
<a name="454"><span class="lineNum">     454 </span>            : // DQ (1/5/2008): These are functions separated out of the generated</a>
<a name="455"><span class="lineNum">     455 </span>            : // code in ROSETTA.  These functions don't need to be generated since</a>
<a name="456"><span class="lineNum">     456 </span>            : // there implementation is not as dependent upon the IR as other functions</a>
<a name="457"><span class="lineNum">     457 </span>            : // (e.g. IR node member functions).</a>
<a name="458"><span class="lineNum">     458 </span>            : //</a>
<a name="459"><span class="lineNum">     459 </span>            : // Switches taking a second parameter need to be added to CommandlineProcessing::isOptionTakingSecondParameter().</a>
<a name="460"><span class="lineNum">     460 </span>            : </a>
<a name="461"><span class="lineNum">     461 </span>            : string</a>
<a name="462"><span class="lineNum">     462 </span><span class="lineCov">        426 : findRoseSupportPathFromSource(const string&amp; sourceTreeLocation,</span></a>
<a name="463"><span class="lineNum">     463 </span>            :                               const string&amp; installTreeLocation) {</a>
<a name="464"><span class="lineNum">     464 </span><span class="lineCov">        852 :   string installTreePath;</span></a>
<a name="465"><span class="lineNum">     465 </span><span class="lineCov">        426 :   bool inInstallTree = roseInstallPrefix(installTreePath);</span></a>
<a name="466"><span class="lineNum">     466 </span><span class="lineCov">        426 :   if (inInstallTree) {</span></a>
<a name="467"><span class="lineNum">     467 </span><span class="lineNoCov">          0 :     return installTreePath + &quot;/&quot; + installTreeLocation;</span></a>
<a name="468"><span class="lineNum">     468 </span>            :   } else {</a>
<a name="469"><span class="lineNum">     469 </span><span class="lineCov">       1278 :     return string(ROSE_AUTOMAKE_ABSOLUTE_PATH_TOP_SRCDIR) + &quot;/&quot; + sourceTreeLocation;</span></a>
<a name="470"><span class="lineNum">     470 </span>            :   }</a>
<a name="471"><span class="lineNum">     471 </span>            : }</a>
<a name="472"><span class="lineNum">     472 </span>            : </a>
<a name="473"><span class="lineNum">     473 </span>            : string</a>
<a name="474"><span class="lineNum">     474 </span><span class="lineCov">        751 : findRoseSupportPathFromBuild(const string&amp; buildTreeLocation,</span></a>
<a name="475"><span class="lineNum">     475 </span>            :                              const string&amp; installTreeLocation) {</a>
<a name="476"><span class="lineNum">     476 </span><span class="lineCov">       1502 :   string installTreePath;</span></a>
<a name="477"><span class="lineNum">     477 </span><span class="lineCov">        751 :   bool inInstallTree = roseInstallPrefix(installTreePath);</span></a>
<a name="478"><span class="lineNum">     478 </span><span class="lineCov">        751 :   if (inInstallTree) {</span></a>
<a name="479"><span class="lineNum">     479 </span><span class="lineNoCov">          0 :     return installTreePath + &quot;/&quot; + installTreeLocation;</span></a>
<a name="480"><span class="lineNum">     480 </span>            :   } else {</a>
<a name="481"><span class="lineNum">     481 </span>            :     #ifdef _MSC_VER</a>
<a name="482"><span class="lineNum">     482 </span>            :   #ifndef CMAKE_INTDIR</a>
<a name="483"><span class="lineNum">     483 </span>            :   #define CMAKE_INTDIR &quot;&quot;</a>
<a name="484"><span class="lineNum">     484 </span>            :   #endif</a>
<a name="485"><span class="lineNum">     485 </span>            :     if (buildTreeLocation.compare(0, 3, &quot;lib&quot;) == 0 || buildTreeLocation.compare(0, 3, &quot;bin&quot;) == 0) {</a>
<a name="486"><span class="lineNum">     486 </span>            :       return string(ROSE_AUTOMAKE_TOP_BUILDDIR) + &quot;/&quot; + buildTreeLocation + &quot;/&quot; + CMAKE_INTDIR;</a>
<a name="487"><span class="lineNum">     487 </span>            :     }</a>
<a name="488"><span class="lineNum">     488 </span>            :     #endif</a>
<a name="489"><span class="lineNum">     489 </span><span class="lineCov">       2253 :     return string(ROSE_AUTOMAKE_TOP_BUILDDIR) + &quot;/&quot; + buildTreeLocation;</span></a>
<a name="490"><span class="lineNum">     490 </span>            :   }</a>
<a name="491"><span class="lineNum">     491 </span>            : }</a>
<a name="492"><span class="lineNum">     492 </span>            : //! Check if we can get an installation prefix of rose based on the current running translator.</a>
<a name="493"><span class="lineNum">     493 </span>            : // There are two ways</a>
<a name="494"><span class="lineNum">     494 </span>            : //   1. if dladdr is supported: we resolve a rose function (roseInstallPrefix()) to obtain the</a>
<a name="495"><span class="lineNum">     495 </span>            : //      file (librose.so) defining this function</a>
<a name="496"><span class="lineNum">     496 </span>            : //      Then we check the parent directory of librose.so</a>
<a name="497"><span class="lineNum">     497 </span>            : //          if .libs or src --&gt; in a build tree</a>
<a name="498"><span class="lineNum">     498 </span>            : //          otherwise: librose.so is in an installation tree</a>
<a name="499"><span class="lineNum">     499 </span>            : //   2. if dladdr is not supported or anything goes wrong, we check an environment variable</a>
<a name="500"><span class="lineNum">     500 </span>            : //     ROSE_IN_BUILD_TREE to tell if the translator is started from a build tree or an installation tree</a>
<a name="501"><span class="lineNum">     501 </span>            : //     Otherwise we pass the --prefix= ROSE_AUTOMAKE_PREFIX as the installation prefix</a>
<a name="502"><span class="lineNum">     502 </span><span class="lineCov">       1177 : bool roseInstallPrefix(std::string&amp; result) {</span></a>
<a name="503"><span class="lineNum">     503 </span>            : #ifdef HAVE_DLADDR</a>
<a name="504"><span class="lineNum">     504 </span><span class="lineCov">       1177 :   {</span></a>
<a name="505"><span class="lineNum">     505 </span>            :  // This is built on the stack and initialized using the function: dladdr().</a>
<a name="506"><span class="lineNum">     506 </span><span class="lineCov">       1177 :     Dl_info info;</span></a>
<a name="507"><span class="lineNum">     507 </span>            : </a>
<a name="508"><span class="lineNum">     508 </span>            :  // DQ (4/8/2011): Initialize this before it is used as a argument to strdup() below. This is initialized</a>
<a name="509"><span class="lineNum">     509 </span>            :  // by dladdr(), so this is likely redundant; but we can initialize it anyway.</a>
<a name="510"><span class="lineNum">     510 </span>            :  // info.dli_fname = NULL;</a>
<a name="511"><span class="lineNum">     511 </span><span class="lineCov">       1177 :     info.dli_fname = &quot;&quot;;</span></a>
<a name="512"><span class="lineNum">     512 </span>            : </a>
<a name="513"><span class="lineNum">     513 </span><span class="lineCov">       1177 :     int retval = dladdr((void*)(&amp;roseInstallPrefix), &amp;info);</span></a>
<a name="514"><span class="lineNum">     514 </span><span class="lineCov">       1177 :     if (retval == 0) goto default_check;</span></a>
<a name="515"><span class="lineNum">     515 </span>            : </a>
<a name="516"><span class="lineNum">     516 </span>            :  // DQ (4/9/2011): I think the issue here is that the pointer &quot;info.dli_fname&quot; pointer (char*) is pointing to</a>
<a name="517"><span class="lineNum">     517 </span>            :  // a position inside a DLL and thus is a region of memory controled/monitored or allocated by Insure++. Thus</a>
<a name="518"><span class="lineNum">     518 </span>            :  // Insure++ is marking this as an issue while it is not an issue. The reported issue by Insure++ is: &quot;READ_WILD&quot;,</a>
<a name="519"><span class="lineNum">     519 </span>            :  // implying that a pointer set to some wild area of memory is being read.</a>
<a name="520"><span class="lineNum">     520 </span>            : #if __INSURE__</a>
<a name="521"><span class="lineNum">     521 </span>            :  // Debugging information. Trying to understand this insure issue and the value of &quot;info.dli_fname&quot; data member.</a>
<a name="522"><span class="lineNum">     522 </span>            :  // if (retval != 0)</a>
<a name="523"><span class="lineNum">     523 </span>            :  //    fprintf(stderr, &quot;      %08p file: %s\tfunction: %s\n&quot;,info.dli_saddr, info.dli_fname ? info.dli_fname : &quot;???&quot;, info.dli_sname ? info.dli_sname : &quot;???&quot;);</a>
<a name="524"><span class="lineNum">     524 </span>            : </a>
<a name="525"><span class="lineNum">     525 </span>            :     _Insure_checking_enable(0); // disable Insure++ checking</a>
<a name="526"><span class="lineNum">     526 </span>            : #endif</a>
<a name="527"><span class="lineNum">     527 </span>            :  // DQ (4/8/2011): Check for NULL pointer before handling it as a parameter to strdup(),</a>
<a name="528"><span class="lineNum">     528 </span>            :  // but I think it is always non-NULL (added assertion and put back the original code).</a>
<a name="529"><span class="lineNum">     529 </span>            :  // char* libroseName = (info.dli_fname == NULL) ? NULL : strdup(info.dli_fname);</a>
<a name="530"><span class="lineNum">     530 </span><span class="lineCov">       1177 :     ASSERT_not_null(info.dli_fname);</span></a>
<a name="531"><span class="lineNum">     531 </span><span class="lineCov">       1177 :     char* libroseName = strdup(info.dli_fname);</span></a>
<a name="532"><span class="lineNum">     532 </span>            : #if __INSURE__</a>
<a name="533"><span class="lineNum">     533 </span>            :     _Insure_checking_enable(1); // re-enable Insure++ checking</a>
<a name="534"><span class="lineNum">     534 </span>            : #endif</a>
<a name="535"><span class="lineNum">     535 </span>            : </a>
<a name="536"><span class="lineNum">     536 </span><span class="lineCov">       1177 :     if (libroseName == nullptr) goto default_check;</span></a>
<a name="537"><span class="lineNum">     537 </span><span class="lineCov">       1177 :     char* libdir = dirname(libroseName);</span></a>
<a name="538"><span class="lineNum">     538 </span><span class="lineCov">       1177 :     if (libdir == nullptr) {free(libroseName); goto default_check;}</span></a>
<a name="539"><span class="lineNum">     539 </span><span class="lineCov">       1177 :     char* libdirCopy1 = strdup(libdir);</span></a>
<a name="540"><span class="lineNum">     540 </span><span class="lineCov">       1177 :     char* libdirCopy2 = strdup(libdir);</span></a>
<a name="541"><span class="lineNum">     541 </span><span class="lineCov">       1177 :     if (libdirCopy1 == nullptr || libdirCopy2 == nullptr) { free(libroseName); free(libdirCopy1); free(libdirCopy2); goto default_check;}</span></a>
<a name="542"><span class="lineNum">     542 </span><span class="lineCov">       1177 :     char* libdirBasenameCS = basename(libdirCopy1);</span></a>
<a name="543"><span class="lineNum">     543 </span><span class="lineCov">       1177 :     if (libdirBasenameCS == nullptr) {free(libroseName); free(libdirCopy1); free(libdirCopy2); goto default_check;}</span></a>
<a name="544"><span class="lineNum">     544 </span><span class="lineCov">       1177 :     string libdirBasename = libdirBasenameCS;</span></a>
<a name="545"><span class="lineNum">     545 </span><span class="lineCov">       1177 :     free(libdirCopy1);</span></a>
<a name="546"><span class="lineNum">     546 </span><span class="lineCov">       1177 :     char* prefixCS = dirname(libdirCopy2);</span></a>
<a name="547"><span class="lineNum">     547 </span><span class="lineCov">       1177 :     if (prefixCS == nullptr) {free(libroseName); goto default_check;}</span></a>
<a name="548"><span class="lineNum">     548 </span><span class="lineCov">       2354 :     string prefix = prefixCS;</span></a>
<a name="549"><span class="lineNum">     549 </span><span class="lineCov">       1177 :     free(libdirCopy2);</span></a>
<a name="550"><span class="lineNum">     550 </span>            : </a>
<a name="551"><span class="lineNum">     551 </span>            :     // Zack Galbreath, June 2013</a>
<a name="552"><span class="lineNum">     552 </span>            :     // When building with CMake, detect build directory by searching</a>
<a name="553"><span class="lineNum">     553 </span>            :     // for the presence of a CMakeCache.txt file.  If this cannot</a>
<a name="554"><span class="lineNum">     554 </span>            :     // be found, then assume we are running from within an install tree.</a>
<a name="555"><span class="lineNum">     555 </span>            :     // Pei-Hung (04/08/21) use prefix to find CMakeCache.txt and return ROSE_AUTOMAKE_PREFIX if installation is used</a>
<a name="556"><span class="lineNum">     556 </span>            :     #ifdef USE_CMAKE</a>
<a name="557"><span class="lineNum">     557 </span>            :     std::string pathToCache = prefix;</a>
<a name="558"><span class="lineNum">     558 </span>            :     pathToCache += &quot;/CMakeCache.txt&quot;;</a>
<a name="559"><span class="lineNum">     559 </span>            :     if ( SgProject::get_verbose() &gt; 1 )</a>
<a name="560"><span class="lineNum">     560 </span>            :           printf (&quot;Inside of roseInstallPrefix libdir = %s pathToCache = %s \n&quot;,libdir, pathToCache.c_str());</a>
<a name="561"><span class="lineNum">     561 </span>            :     if (boost::filesystem::exists(pathToCache)) {</a>
<a name="562"><span class="lineNum">     562 </span>            :       return false;</a>
<a name="563"><span class="lineNum">     563 </span>            :     } else {</a>
<a name="564"><span class="lineNum">     564 </span>            :       result = ROSE_AUTOMAKE_PREFIX;</a>
<a name="565"><span class="lineNum">     565 </span>            :       return true;</a>
<a name="566"><span class="lineNum">     566 </span>            :     }</a>
<a name="567"><span class="lineNum">     567 </span>            :     #endif</a>
<a name="568"><span class="lineNum">     568 </span>            : </a>
<a name="569"><span class="lineNum">     569 </span><span class="lineCov">       1177 :     free(libroseName);</span></a>
<a name="570"><span class="lineNum">     570 </span>            : // Liao, 12/2/2009</a>
<a name="571"><span class="lineNum">     571 </span>            : // Check the librose's parent directory name to tell if it is within a build or installation tree</a>
<a name="572"><span class="lineNum">     572 </span>            : // This if statement has the assumption that libtool is used to build librose so librose.so is put under .libs</a>
<a name="573"><span class="lineNum">     573 </span>            : // which is not true for cmake building system</a>
<a name="574"><span class="lineNum">     574 </span>            : // For cmake, librose is created directly under build/src</a>
<a name="575"><span class="lineNum">     575 </span>            : //    if (libdirBasename == &quot;.libs&quot;) {</a>
<a name="576"><span class="lineNum">     576 </span><span class="lineCov">       1177 :     if (libdirBasename == &quot;.libs&quot; || libdirBasename == &quot;src&quot;) {</span></a>
<a name="577"><span class="lineNum">     577 </span><span class="lineCov">       1177 :       return false;</span></a>
<a name="578"><span class="lineNum">     578 </span>            :     } else {</a>
<a name="579"><span class="lineNum">     579 </span>            :       // the translator must locate in the installation_tree/lib</a>
<a name="580"><span class="lineNum">     580 </span><span class="lineNoCov">          0 :        if (libdirBasename != &quot;lib&quot; &amp;&amp; libdirBasename != &quot;lib64&quot;)</span></a>
<a name="581"><span class="lineNum">     581 </span>            :           {</a>
<a name="582"><span class="lineNum">     582 </span><span class="lineNoCov">          0 :             printf (&quot;Error: unexpected libdirBasename = %s (result = %s, prefix = %s) \n&quot;,libdirBasename.c_str(),result.c_str(),prefix.c_str());</span></a>
<a name="583"><span class="lineNum">     583 </span>            :           }</a>
<a name="584"><span class="lineNum">     584 </span>            : </a>
<a name="585"><span class="lineNum">     585 </span>            :    // DQ (12/5/2009): Is this really what we need to assert?</a>
<a name="586"><span class="lineNum">     586 </span>            :    // ROSE_ASSERT (libdirBasename == &quot;lib&quot;);</a>
<a name="587"><span class="lineNum">     587 </span>            : </a>
<a name="588"><span class="lineNum">     588 </span><span class="lineCov">       1177 :       result = prefix;</span></a>
<a name="589"><span class="lineNum">     589 </span>            :       return true;</a>
<a name="590"><span class="lineNum">     590 </span>            :     }</a>
<a name="591"><span class="lineNum">     591 </span>            :   }</a>
<a name="592"><span class="lineNum">     592 </span>            : #endif</a>
<a name="593"><span class="lineNum">     593 </span><span class="lineNoCov">          0 : default_check:</span></a>
<a name="594"><span class="lineNum">     594 </span>            : #ifdef HAVE_DLADDR</a>
<a name="595"><span class="lineNum">     595 </span>            :   // Emit a warning that the hard-wired prefix is being used</a>
<a name="596"><span class="lineNum">     596 </span><span class="lineNoCov">          0 :   cerr &lt;&lt; &quot;Warning: roseInstallPrefix() is using the hard-wired prefix and ROSE_IN_BUILD_TREE even though it should be relocatable&quot; &lt;&lt; endl;</span></a>
<a name="597"><span class="lineNum">     597 </span>            : #endif</a>
<a name="598"><span class="lineNum">     598 </span>            :   // dladdr is not supported, we check an environment variables to tell if the</a>
<a name="599"><span class="lineNum">     599 </span>            :   // translator is running from a build tree or an installation tree</a>
<a name="600"><span class="lineNum">     600 </span><span class="lineNoCov">          0 :   if (getenv(&quot;ROSE_IN_BUILD_TREE&quot;) != nullptr) {</span></a>
<a name="601"><span class="lineNum">     601 </span>            :     return false;</a>
<a name="602"><span class="lineNum">     602 </span>            :   } else {</a>
<a name="603"><span class="lineNum">     603 </span>            : // Liao, 12/1/2009</a>
<a name="604"><span class="lineNum">     604 </span>            : // this variable is set via a very bad way, there is actually a right way to use --prefix VALUE within automake/autoconfig</a>
<a name="605"><span class="lineNum">     605 </span>            : // config/build_rose_paths.Makefile</a>
<a name="606"><span class="lineNum">     606 </span>            : // Makefile:       @@echo &quot;const std::string ROSE_AUTOMAKE_PREFIX        = \&quot;/home/liao6/opt/roseLatest\&quot;;&quot; &gt;&gt; src/util/rose_paths.C</a>
<a name="607"><span class="lineNum">     607 </span>            : // TODO fix this to support both automake and cmake 's installation configuration options</a>
<a name="608"><span class="lineNum">     608 </span><span class="lineNoCov">          0 :     result = ROSE_AUTOMAKE_PREFIX;</span></a>
<a name="609"><span class="lineNum">     609 </span><span class="lineNoCov">          0 :     return true;</span></a>
<a name="610"><span class="lineNum">     610 </span>            :   }</a>
<a name="611"><span class="lineNum">     611 </span>            : }</a>
<a name="612"><span class="lineNum">     612 </span>            : </a>
<a name="613"><span class="lineNum">     613 </span>            : /* This function suffers from the same problems as CommandlineProcessing::isExecutableFilename(), namely that the list of</a>
<a name="614"><span class="lineNum">     614 </span>            :  * magic numbers used here needs to be kept in sync with changes to the binary parsers. */</a>
<a name="615"><span class="lineNum">     615 </span>            : bool</a>
<a name="616"><span class="lineNum">     616 </span><span class="lineNoCov">          0 : isBinaryExecutableFile ( string sourceFilename )</span></a>
<a name="617"><span class="lineNum">     617 </span>            :    {</a>
<a name="618"><span class="lineNum">     618 </span><span class="lineNoCov">          0 :      bool returnValue = false;</span></a>
<a name="619"><span class="lineNum">     619 </span>            : </a>
<a name="620"><span class="lineNum">     620 </span><span class="lineNoCov">          0 :      if ( SgProject::get_verbose() &gt; 1 )</span></a>
<a name="621"><span class="lineNum">     621 </span><span class="lineNoCov">          0 :           printf (&quot;Inside of isBinaryExecutableFile(%s) \n&quot;,sourceFilename.c_str());</span></a>
<a name="622"><span class="lineNum">     622 </span>            : </a>
<a name="623"><span class="lineNum">     623 </span>            :   // Open file for reading</a>
<a name="624"><span class="lineNum">     624 </span><span class="lineNoCov">          0 :      FILE* f = fopen(sourceFilename.c_str(), &quot;rb&quot;);</span></a>
<a name="625"><span class="lineNum">     625 </span><span class="lineNoCov">          0 :      if (!f)</span></a>
<a name="626"><span class="lineNum">     626 </span>            :          return false;                                  // a file that cannot be opened is not a binary file</a>
<a name="627"><span class="lineNum">     627 </span>            : </a>
<a name="628"><span class="lineNum">     628 </span><span class="lineNoCov">          0 :      int character0 = fgetc(f);</span></a>
<a name="629"><span class="lineNum">     629 </span><span class="lineNoCov">          0 :      int character1 = fgetc(f);</span></a>
<a name="630"><span class="lineNum">     630 </span>            : </a>
<a name="631"><span class="lineNum">     631 </span>            :   // The first character of an ELF binary is '\127' and for a PE binary it is 'M'</a>
<a name="632"><span class="lineNum">     632 </span>            :   // Note also that some MS-DOS headers can start with &quot;ZM&quot; instead of &quot;MZ&quot; due to</a>
<a name="633"><span class="lineNum">     633 </span>            :   // early confusion about little endian handling for MS-DOS where it was ported</a>
<a name="634"><span class="lineNum">     634 </span>            :   // to not x86 plaforms.  I am not clear how wide spread loaders of this type are.</a>
<a name="635"><span class="lineNum">     635 </span>            : </a>
<a name="636"><span class="lineNum">     636 </span><span class="lineNoCov">          0 :      if (character0 == 127 || character0 == 77)</span></a>
<a name="637"><span class="lineNum">     637 </span>            :         {</a>
<a name="638"><span class="lineNum">     638 </span><span class="lineNoCov">          0 :           if (character1 == 'E' || character1 == 'Z')</span></a>
<a name="639"><span class="lineNum">     639 </span>            :              {</a>
<a name="640"><span class="lineNum">     640 </span><span class="lineNoCov">          0 :                returnValue = true;</span></a>
<a name="641"><span class="lineNum">     641 </span>            :              }</a>
<a name="642"><span class="lineNum">     642 </span>            :         }</a>
<a name="643"><span class="lineNum">     643 </span>            : </a>
<a name="644"><span class="lineNum">     644 </span><span class="lineNoCov">          0 :       fclose(f);</span></a>
<a name="645"><span class="lineNum">     645 </span>            : </a>
<a name="646"><span class="lineNum">     646 </span><span class="lineNoCov">          0 :       return returnValue;</span></a>
<a name="647"><span class="lineNum">     647 </span>            :     }</a>
<a name="648"><span class="lineNum">     648 </span>            : </a>
<a name="649"><span class="lineNum">     649 </span>            : bool</a>
<a name="650"><span class="lineNum">     650 </span><span class="lineNoCov">          0 : isLibraryArchiveFile ( string sourceFilename )</span></a>
<a name="651"><span class="lineNum">     651 </span>            :    {</a>
<a name="652"><span class="lineNum">     652 </span>            :   // The if this is a &quot;*.a&quot; file, not that &quot;*.so&quot; files</a>
<a name="653"><span class="lineNum">     653 </span>            :   // will appear as an executable (same for Windows &quot;*.dll&quot;</a>
<a name="654"><span class="lineNum">     654 </span>            :   // files.</a>
<a name="655"><span class="lineNum">     655 </span>            : </a>
<a name="656"><span class="lineNum">     656 </span><span class="lineNoCov">          0 :      bool returnValue = false;</span></a>
<a name="657"><span class="lineNum">     657 </span>            : </a>
<a name="658"><span class="lineNum">     658 </span><span class="lineNoCov">          0 :      if ( SgProject::get_verbose() &gt; 1 )</span></a>
<a name="659"><span class="lineNum">     659 </span><span class="lineNoCov">          0 :           printf (&quot;Inside of isLibraryArchiveFile(%s) \n&quot;,sourceFilename.c_str());</span></a>
<a name="660"><span class="lineNum">     660 </span>            : </a>
<a name="661"><span class="lineNum">     661 </span>            :   // Open file for reading</a>
<a name="662"><span class="lineNum">     662 </span><span class="lineNoCov">          0 :      FILE* f = fopen(sourceFilename.c_str(), &quot;rb&quot;);</span></a>
<a name="663"><span class="lineNum">     663 </span><span class="lineNoCov">          0 :      if (!f)</span></a>
<a name="664"><span class="lineNum">     664 </span>            :          return false;                                  // a non-existing file is not a library archive</a>
<a name="665"><span class="lineNum">     665 </span>            : </a>
<a name="666"><span class="lineNum">     666 </span><span class="lineNoCov">          0 :      string magicHeader;</span></a>
<a name="667"><span class="lineNum">     667 </span><span class="lineNoCov">          0 :      for (int i = 0; i &lt; 7; i++)</span></a>
<a name="668"><span class="lineNum">     668 </span>            :         {</a>
<a name="669"><span class="lineNum">     669 </span><span class="lineNoCov">          0 :           magicHeader = magicHeader + (char)getc(f);</span></a>
<a name="670"><span class="lineNum">     670 </span>            :         }</a>
<a name="671"><span class="lineNum">     671 </span>            : </a>
<a name="672"><span class="lineNum">     672 </span>            :   // printf (&quot;magicHeader = %s \n&quot;,magicHeader.c_str());</a>
<a name="673"><span class="lineNum">     673 </span><span class="lineNoCov">          0 :      returnValue = (magicHeader == &quot;!&lt;arch&gt;&quot;);</span></a>
<a name="674"><span class="lineNum">     674 </span>            : </a>
<a name="675"><span class="lineNum">     675 </span>            :   // printf (&quot;isLibraryArchiveFile() returning %s \n&quot;,returnValue ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="676"><span class="lineNum">     676 </span>            : </a>
<a name="677"><span class="lineNum">     677 </span><span class="lineNoCov">          0 :      fclose(f);</span></a>
<a name="678"><span class="lineNum">     678 </span>            : </a>
<a name="679"><span class="lineNum">     679 </span><span class="lineNoCov">          0 :      return returnValue;</span></a>
<a name="680"><span class="lineNum">     680 </span>            :    }</a>
<a name="681"><span class="lineNum">     681 </span>            : </a>
<a name="682"><span class="lineNum">     682 </span>            : </a>
<a name="683"><span class="lineNum">     683 </span>            : void</a>
<a name="684"><span class="lineNum">     684 </span><span class="lineCov">        357 : SgFile::initializeSourcePosition( const std::string &amp; sourceFilename )</span></a>
<a name="685"><span class="lineNum">     685 </span>            :    {</a>
<a name="686"><span class="lineNum">     686 </span><span class="lineCov">        357 :      ASSERT_not_null(this);</span></a>
<a name="687"><span class="lineNum">     687 </span>            : </a>
<a name="688"><span class="lineNum">     688 </span>            :   // printf (&quot;Inside of SgFile::initializeSourcePosition() \n&quot;);</a>
<a name="689"><span class="lineNum">     689 </span>            : </a>
<a name="690"><span class="lineNum">     690 </span><span class="lineCov">        357 :      Sg_File_Info* fileInfo = new Sg_File_Info(sourceFilename,1,1);</span></a>
<a name="691"><span class="lineNum">     691 </span><span class="lineCov">        357 :      ASSERT_not_null(fileInfo);</span></a>
<a name="692"><span class="lineNum">     692 </span>            : </a>
<a name="693"><span class="lineNum">     693 </span>            :   // set_file_info(fileInfo);</a>
<a name="694"><span class="lineNum">     694 </span><span class="lineCov">        357 :      set_startOfConstruct(fileInfo);</span></a>
<a name="695"><span class="lineNum">     695 </span><span class="lineCov">        357 :      fileInfo-&gt;set_parent(this);</span></a>
<a name="696"><span class="lineNum">     696 </span><span class="lineCov">        357 :      ASSERT_not_null(get_startOfConstruct());</span></a>
<a name="697"><span class="lineNum">     697 </span><span class="lineCov">        357 :      ASSERT_not_null(get_file_info());</span></a>
<a name="698"><span class="lineNum">     698 </span><span class="lineCov">        357 :    }</span></a>
<a name="699"><span class="lineNum">     699 </span>            : </a>
<a name="700"><span class="lineNum">     700 </span>            : void</a>
<a name="701"><span class="lineNum">     701 </span><span class="lineCov">        357 : SgSourceFile::initializeGlobalScope()</span></a>
<a name="702"><span class="lineNum">     702 </span>            :    {</a>
<a name="703"><span class="lineNum">     703 </span><span class="lineCov">        357 :      ASSERT_not_null(this);</span></a>
<a name="704"><span class="lineNum">     704 </span>            : </a>
<a name="705"><span class="lineNum">     705 </span>            :   // printf (&quot;Inside of SgSourceFile::initializeGlobalScope() \n&quot;);</a>
<a name="706"><span class="lineNum">     706 </span>            : </a>
<a name="707"><span class="lineNum">     707 </span>            :   // Note that SgFile::initializeSourcePosition() should have already been called.</a>
<a name="708"><span class="lineNum">     708 </span><span class="lineCov">        357 :      ASSERT_not_null(get_startOfConstruct());</span></a>
<a name="709"><span class="lineNum">     709 </span>            : </a>
<a name="710"><span class="lineNum">     710 </span><span class="lineCov">        357 :      string sourceFilename = get_startOfConstruct()-&gt;get_filename();</span></a>
<a name="711"><span class="lineNum">     711 </span>            : </a>
<a name="712"><span class="lineNum">     712 </span>            :   // DQ (8/31/2006): Generate a NULL_FILE (instead of SgFile::SgFile) so that we can</a>
<a name="713"><span class="lineNum">     713 </span>            :   // enforce that the filename is always an absolute path (starting with &quot;/&quot;).</a>
<a name="714"><span class="lineNum">     714 </span>            :   // Sg_File_Info* globalScopeFileInfo = new Sg_File_Info(&quot;SgGlobal::SgGlobal&quot;,0,0);</a>
<a name="715"><span class="lineNum">     715 </span><span class="lineCov">        357 :      Sg_File_Info* globalScopeFileInfo = new Sg_File_Info(sourceFilename,0,0);</span></a>
<a name="716"><span class="lineNum">     716 </span><span class="lineCov">        357 :      ASSERT_not_null(globalScopeFileInfo);</span></a>
<a name="717"><span class="lineNum">     717 </span>            : </a>
<a name="718"><span class="lineNum">     718 </span>            :   // printf (&quot;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp; In SgSourceFile::initializeGlobalScope(): Building SgGlobal (with empty filename) &amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp; \n&quot;);</a>
<a name="719"><span class="lineNum">     719 </span>            : </a>
<a name="720"><span class="lineNum">     720 </span><span class="lineCov">        357 :      set_globalScope( new SgGlobal( globalScopeFileInfo ) );</span></a>
<a name="721"><span class="lineNum">     721 </span><span class="lineCov">        357 :      ASSERT_not_null(get_globalScope());</span></a>
<a name="722"><span class="lineNum">     722 </span>            : </a>
<a name="723"><span class="lineNum">     723 </span>            :   // Rasmussen (3/22/2020): Fixed setting case insensitivity</a>
<a name="724"><span class="lineNum">     724 </span>            :   // if (SageBuilder::symbol_table_case_insensitive_semantics == true)</a>
<a name="725"><span class="lineNum">     725 </span><span class="lineCov">        357 :      if (SageInterface::is_language_case_insensitive())</span></a>
<a name="726"><span class="lineNum">     726 </span>            :         {</a>
<a name="727"><span class="lineNum">     727 </span>            :   // Rasmussen (3/27/2020): Experimenting with returning to original (using symbol_table_case_insensitive_semantics variable)</a>
<a name="728"><span class="lineNum">     728 </span><span class="lineCov">         37 :            ROSE_ASSERT(SageBuilder::symbol_table_case_insensitive_semantics == true);</span></a>
<a name="729"><span class="lineNum">     729 </span><span class="lineCov">         37 :            get_globalScope()-&gt;setCaseInsensitive(true);</span></a>
<a name="730"><span class="lineNum">     730 </span>            :         }</a>
<a name="731"><span class="lineNum">     731 </span>            : </a>
<a name="732"><span class="lineNum">     732 </span>            :   // DQ (2/15/2006): Set the parent of the SgGlobal IR node</a>
<a name="733"><span class="lineNum">     733 </span><span class="lineCov">        357 :      get_globalScope()-&gt;set_parent(this);</span></a>
<a name="734"><span class="lineNum">     734 </span>            : </a>
<a name="735"><span class="lineNum">     735 </span>            :   // DQ (8/21/2008): Set the end of the global scope (even if it is updated later)</a>
<a name="736"><span class="lineNum">     736 </span>            :   // printf (&quot;In SgFile::initialization(): p_root-&gt;get_endOfConstruct() = %p \n&quot;,p_root-&gt;get_endOfConstruct());</a>
<a name="737"><span class="lineNum">     737 </span><span class="lineCov">        357 :      ROSE_ASSERT(get_globalScope()-&gt;get_endOfConstruct() == nullptr);</span></a>
<a name="738"><span class="lineNum">     738 </span><span class="lineCov">        357 :      get_globalScope()-&gt;set_endOfConstruct(new Sg_File_Info(sourceFilename,0,0));</span></a>
<a name="739"><span class="lineNum">     739 </span><span class="lineCov">        357 :      ASSERT_not_null(get_globalScope()-&gt;get_endOfConstruct());</span></a>
<a name="740"><span class="lineNum">     740 </span>            : </a>
<a name="741"><span class="lineNum">     741 </span>            :   // DQ (1/21/2008): Set the filename in the SgGlobal IR node so that the traversal to add CPP directives and comments will succeed.</a>
<a name="742"><span class="lineNum">     742 </span><span class="lineCov">        357 :      ROSE_ASSERT (get_globalScope() != NULL);</span></a>
<a name="743"><span class="lineNum">     743 </span><span class="lineCov">        357 :      ROSE_ASSERT(get_globalScope()-&gt;get_startOfConstruct() != NULL);</span></a>
<a name="744"><span class="lineNum">     744 </span>            : </a>
<a name="745"><span class="lineNum">     745 </span>            :   // DQ (8/21/2008): Modified to make endOfConstruct consistant (avoids warning in AST consistancy check).</a>
<a name="746"><span class="lineNum">     746 </span>            :   // ROSE_ASSERT(p_root-&gt;get_endOfConstruct()   == NULL);</a>
<a name="747"><span class="lineNum">     747 </span><span class="lineCov">        357 :      ROSE_ASSERT(get_globalScope()-&gt;get_endOfConstruct()   != NULL);</span></a>
<a name="748"><span class="lineNum">     748 </span>            : </a>
<a name="749"><span class="lineNum">     749 </span>            :   // p_root-&gt;get_file_info()-&gt;set_filenameString(p_sourceFileNameWithPath);</a>
<a name="750"><span class="lineNum">     750 </span>            :   // ROSE_ASSERT(p_root-&gt;get_file_info()-&gt;get_filenameString().empty() == false);</a>
<a name="751"><span class="lineNum">     751 </span>            : </a>
<a name="752"><span class="lineNum">     752 </span>            : #if 0</a>
<a name="753"><span class="lineNum">     753 </span>            :      Sg_File_Info::display_static_data(&quot;Resetting the SgGlobal startOfConstruct and endOfConstruct&quot;);</a>
<a name="754"><span class="lineNum">     754 </span>            :      printf (&quot;Resetting the SgGlobal startOfConstruct and endOfConstruct filename (p_sourceFileNameWithPath = %s) \n&quot;,p_sourceFileNameWithPath.c_str());</a>
<a name="755"><span class="lineNum">     755 </span>            : #endif</a>
<a name="756"><span class="lineNum">     756 </span>            : </a>
<a name="757"><span class="lineNum">     757 </span>            :   // DQ (12/22/2008): Added to support CPP preprocessing of Fortran files.</a>
<a name="758"><span class="lineNum">     758 </span><span class="lineCov">        714 :      string filename = p_sourceFileNameWithPath;</span></a>
<a name="759"><span class="lineNum">     759 </span><span class="lineCov">        357 :      if (get_requires_C_preprocessor() == true)</span></a>
<a name="760"><span class="lineNum">     760 </span>            :         {</a>
<a name="761"><span class="lineNum">     761 </span>            :        // This must be a Fortran source file (requiring the use of CPP to process its directives).</a>
<a name="762"><span class="lineNum">     762 </span><span class="lineNoCov">          0 :           filename = generate_C_preprocessor_intermediate_filename(filename);</span></a>
<a name="763"><span class="lineNum">     763 </span>            :         }</a>
<a name="764"><span class="lineNum">     764 </span>            : </a>
<a name="765"><span class="lineNum">     765 </span>            :   // printf (&quot;get_requires_C_preprocessor() = %s filename = %s \n&quot;,get_requires_C_preprocessor() ? &quot;true&quot; : &quot;false&quot;,filename.c_str());</a>
<a name="766"><span class="lineNum">     766 </span>            : </a>
<a name="767"><span class="lineNum">     767 </span><span class="lineCov">        357 :      get_globalScope()-&gt;get_startOfConstruct()-&gt;set_filenameString(filename);</span></a>
<a name="768"><span class="lineNum">     768 </span><span class="lineCov">        357 :      ROSE_ASSERT(get_globalScope()-&gt;get_startOfConstruct()-&gt;get_filenameString().empty() == false);</span></a>
<a name="769"><span class="lineNum">     769 </span>            : </a>
<a name="770"><span class="lineNum">     770 </span><span class="lineCov">        357 :      get_globalScope()-&gt;get_endOfConstruct()-&gt;set_filenameString(filename);</span></a>
<a name="771"><span class="lineNum">     771 </span><span class="lineCov">        357 :      ROSE_ASSERT(get_globalScope()-&gt;get_endOfConstruct()-&gt;get_filenameString().empty() == false);</span></a>
<a name="772"><span class="lineNum">     772 </span>            : </a>
<a name="773"><span class="lineNum">     773 </span>            : #if 0</a>
<a name="774"><span class="lineNum">     774 </span>            :      printf (&quot;DONE: Resetting the SgGlobal startOfConstruct and endOfConstruct filename (filename = %s) \n&quot;,filename.c_str());</a>
<a name="775"><span class="lineNum">     775 </span>            :      Sg_File_Info::display_static_data(&quot;DONE: Resetting the SgGlobal startOfConstruct and endOfConstruct&quot;);</a>
<a name="776"><span class="lineNum">     776 </span>            : #endif</a>
<a name="777"><span class="lineNum">     777 </span>            : </a>
<a name="778"><span class="lineNum">     778 </span>            :   // DQ (12/23/2008): These should be in the Sg_File_Info map already.</a>
<a name="779"><span class="lineNum">     779 </span><span class="lineCov">        357 :      ROSE_ASSERT(Sg_File_Info::getIDFromFilename(get_file_info()-&gt;get_filename()) &gt;= 0);</span></a>
<a name="780"><span class="lineNum">     780 </span><span class="lineCov">        357 :      if (get_requires_C_preprocessor() == true)</span></a>
<a name="781"><span class="lineNum">     781 </span>            :         {</a>
<a name="782"><span class="lineNum">     782 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(Sg_File_Info::getIDFromFilename(generate_C_preprocessor_intermediate_filename(get_file_info()-&gt;get_filename())) &gt;= 0);</span></a>
<a name="783"><span class="lineNum">     783 </span>            :         }</a>
<a name="784"><span class="lineNum">     784 </span><span class="lineCov">        357 :    }</span></a>
<a name="785"><span class="lineNum">     785 </span>            : </a>
<a name="786"><span class="lineNum">     786 </span>            : SgFile*</a>
<a name="787"><span class="lineNum">     787 </span><span class="lineCov">        357 : determineFileType ( vector&lt;string&gt; argv, int &amp; nextErrorCode, SgProject* project )</span></a>
<a name="788"><span class="lineNum">     788 </span>            :    {</a>
<a name="789"><span class="lineNum">     789 </span><span class="lineCov">        357 :      SgFile* file = nullptr;</span></a>
<a name="790"><span class="lineNum">     790 </span>            : </a>
<a name="791"><span class="lineNum">     791 </span>            : #if 0</a>
<a name="792"><span class="lineNum">     792 </span>            :      printf(&quot;In determineFileType():\n&quot;);</a>
<a name="793"><span class="lineNum">     793 </span>            :      size_t cnt = 0;</a>
<a name="794"><span class="lineNum">     794 </span>            :      for ( std::vector&lt;std::string&gt;::iterator i = argv.begin(); i != argv.end(); i++)</a>
<a name="795"><span class="lineNum">     795 </span>            :         {</a>
<a name="796"><span class="lineNum">     796 </span>            :           printf(&quot;  argv[%zd] = %s\n&quot;, cnt++, i-&gt;c_str());</a>
<a name="797"><span class="lineNum">     797 </span>            :         }</a>
<a name="798"><span class="lineNum">     798 </span>            : #endif</a>
<a name="799"><span class="lineNum">     799 </span>            : </a>
<a name="800"><span class="lineNum">     800 </span>            :   // DQ (2/4/2009): The specification of &quot;-rose:binary&quot; causes filenames to be interpreted</a>
<a name="801"><span class="lineNum">     801 </span>            :   // differently if they are object files or libary archive files.</a>
<a name="802"><span class="lineNum">     802 </span>            :   // DQ (4/21/2006): New version of source file name handling (set the source file name early)</a>
<a name="803"><span class="lineNum">     803 </span>            :   // printf (&quot;In determineFileType(): Calling CommandlineProcessing::generateSourceFilenames(argv) \n&quot;);</a>
<a name="804"><span class="lineNum">     804 </span>            :   // Rose_STL_Container&lt;string&gt; fileList = CommandlineProcessing::generateSourceFilenames(argv);</a>
<a name="805"><span class="lineNum">     805 </span><span class="lineCov">        357 :      ROSE_ASSERT(project != NULL);</span></a>
<a name="806"><span class="lineNum">     806 </span><span class="lineCov">        357 :      Rose_STL_Container&lt;string&gt; fileList = CommandlineProcessing::generateSourceFilenames(argv,project-&gt;get_binary_only());</span></a>
<a name="807"><span class="lineNum">     807 </span>            : </a>
<a name="808"><span class="lineNum">     808 </span>            : #if 0</a>
<a name="809"><span class="lineNum">     809 </span>            :   // this-&gt;display(&quot;In SgFile::setupSourceFilename()&quot;);</a>
<a name="810"><span class="lineNum">     810 </span>            :      printf (&quot;In determineFileType(): listToString(argv) = %s \n&quot;,StringUtility::listToString(argv).c_str());</a>
<a name="811"><span class="lineNum">     811 </span>            :      printf (&quot;In determineFileType(): listToString(fileList) = %s \n&quot;,StringUtility::listToString(fileList).c_str());</a>
<a name="812"><span class="lineNum">     812 </span>            : #endif</a>
<a name="813"><span class="lineNum">     813 </span>            : </a>
<a name="814"><span class="lineNum">     814 </span>            :   // DQ (2/6/2009): This fails for the build function SageBuilder::buildFile(), so OK to comment it out.</a>
<a name="815"><span class="lineNum">     815 </span>            :   // DQ (12/23/2008): I think that we may be able to assert this is true, if so then we can simplify the code below.</a>
<a name="816"><span class="lineNum">     816 </span><span class="lineCov">        357 :      ROSE_ASSERT(fileList.empty() == false);</span></a>
<a name="817"><span class="lineNum">     817 </span>            : </a>
<a name="818"><span class="lineNum">     818 </span><span class="lineCov">        357 :      if (fileList.empty() == false)</span></a>
<a name="819"><span class="lineNum">     819 </span>            :         {</a>
<a name="820"><span class="lineNum">     820 </span><span class="lineCov">        357 :             if (fileList.size() != 1){</span></a>
<a name="821"><span class="lineNum">     821 </span><span class="lineNoCov">          0 :                 cout &lt;&lt; endl;</span></a>
<a name="822"><span class="lineNum">     822 </span><span class="lineNoCov">          0 :                 for ( Rose_STL_Container&lt;string&gt;::iterator i = fileList.begin(); i != fileList.end(); i++) {</span></a>
<a name="823"><span class="lineNum">     823 </span><span class="lineNoCov">          0 :                     cout &lt;&lt; (*i) &lt;&lt; endl;</span></a>
<a name="824"><span class="lineNum">     824 </span>            :                 }</a>
<a name="825"><span class="lineNum">     825 </span><span class="lineNoCov">          0 :                 cout &lt;&lt; endl;</span></a>
<a name="826"><span class="lineNum">     826 </span><span class="lineNoCov">          0 :                 cout.flush();</span></a>
<a name="827"><span class="lineNum">     827 </span>            :             }</a>
<a name="828"><span class="lineNum">     828 </span><span class="lineCov">        357 :           ROSE_ASSERT(fileList.size() == 1);</span></a>
<a name="829"><span class="lineNum">     829 </span>            : </a>
<a name="830"><span class="lineNum">     830 </span>            :        // DQ (8/31/2006): Convert the source file to have a path if it does not already</a>
<a name="831"><span class="lineNum">     831 </span>            :        // p_sourceFileNameWithPath    = *(fileList.begin());</a>
<a name="832"><span class="lineNum">     832 </span><span class="lineCov">        357 :           string sourceFilename = *(fileList.begin());</span></a>
<a name="833"><span class="lineNum">     833 </span>            : </a>
<a name="834"><span class="lineNum">     834 </span>            :        // printf (&quot;Before conversion to absolute path: sourceFilename = %s \n&quot;,sourceFilename.c_str());</a>
<a name="835"><span class="lineNum">     835 </span>            : </a>
<a name="836"><span class="lineNum">     836 </span>            :        // sourceFilename = StringUtility::getAbsolutePathFromRelativePath(sourceFilename);</a>
<a name="837"><span class="lineNum">     837 </span><span class="lineCov">        357 :           sourceFilename = StringUtility::getAbsolutePathFromRelativePath(sourceFilename, true);</span></a>
<a name="838"><span class="lineNum">     838 </span>            : </a>
<a name="839"><span class="lineNum">     839 </span>            :        // printf (&quot;After conversion to absolute path: sourceFilename = %s \n&quot;,sourceFilename.c_str());</a>
<a name="840"><span class="lineNum">     840 </span>            : </a>
<a name="841"><span class="lineNum">     841 </span>            :        // This should be an absolute path</a>
<a name="842"><span class="lineNum">     842 </span><span class="lineCov">        714 :           string targetSubstring = &quot;/&quot;;</span></a>
<a name="843"><span class="lineNum">     843 </span>            :        // if (sourceFilename.substr(0,targetSubstring.size()) != targetSubstring)</a>
<a name="844"><span class="lineNum">     844 </span>            :        //      printf (&quot;@@@@@@@@@@@@@@@@@@@@ In SgFile::setupSourceFilename(int,char**): sourceFilename = %s @@@@@@@@@@@@@@@@@@@@\n&quot;,sourceFilename.c_str());</a>
<a name="845"><span class="lineNum">     845 </span>            :        // ROSE_ASSERT(sourceFilename.substr(0,targetSubstring.size()) == targetSubstring);</a>
<a name="846"><span class="lineNum">     846 </span>            : </a>
<a name="847"><span class="lineNum">     847 </span>            :        // Rama: 12/06/06: Fixup for problem with file names.</a>
<a name="848"><span class="lineNum">     848 </span>            :             // Made changes to this file and string utilities function getAbsolutePathFromRelativePath by cloning it with name getAbsolutePathFromRelativePathWithErrors</a>
<a name="849"><span class="lineNum">     849 </span>            :             // Also refer to script that tests -- reasonably exhaustively -- to various combinarions of input files.</a>
<a name="850"><span class="lineNum">     850 </span>            : </a>
<a name="851"><span class="lineNum">     851 </span>            :        // Zack Galbreath 1/9/2014: Windows absolute paths do not begin with &quot;/&quot;.</a>
<a name="852"><span class="lineNum">     852 </span>            :        // The following printf could cause problems for our testing systems because</a>
<a name="853"><span class="lineNum">     853 </span>            :        // it contains the word &quot;error&quot;.</a>
<a name="854"><span class="lineNum">     854 </span>            :        // [Robb P Matzke 2017-04-21]: Such a low-level utility function as this shouldn't be emitting output at all, especially</a>
<a name="855"><span class="lineNum">     855 </span>            :        // not on standard output, because it makes it problematic to call this in situations where the file might not</a>
<a name="856"><span class="lineNum">     856 </span>            :        // exist.</a>
<a name="857"><span class="lineNum">     857 </span>            :        #ifndef _MSC_VER</a>
<a name="858"><span class="lineNum">     858 </span>            :           //if (sourceFilename.substr(0,targetSubstring.size()) != targetSubstring)</a>
<a name="859"><span class="lineNum">     859 </span>            :           //     printf (&quot;sourceFilename encountered an error in filename\n&quot;);</a>
<a name="860"><span class="lineNum">     860 </span>            :        #endif</a>
<a name="861"><span class="lineNum">     861 </span>            : </a>
<a name="862"><span class="lineNum">     862 </span>            :        // DQ (11/29/2006): Even if this is C mode, we have to define the __cplusplus macro</a>
<a name="863"><span class="lineNum">     863 </span>            :        // if we detect we are processing a source file using a C++ filename extension.</a>
<a name="864"><span class="lineNum">     864 </span><span class="lineCov">        714 :           string filenameExtension = StringUtility::fileNameSuffix(sourceFilename);</span></a>
<a name="865"><span class="lineNum">     865 </span>            : </a>
<a name="866"><span class="lineNum">     866 </span>            : #if 0</a>
<a name="867"><span class="lineNum">     867 </span>            :           printf (&quot;In determineFileType(): sourceFilename    = %s \n&quot;,sourceFilename.c_str());</a>
<a name="868"><span class="lineNum">     868 </span>            :           printf (&quot;In determineFileType(): filenameExtension = %s \n&quot;,filenameExtension.c_str());</a>
<a name="869"><span class="lineNum">     869 </span>            :        // ROSE_ASSERT(false);</a>
<a name="870"><span class="lineNum">     870 </span>            : #endif</a>
<a name="871"><span class="lineNum">     871 </span>            : </a>
<a name="872"><span class="lineNum">     872 </span>            :        // DQ (1/8/2014): We need to handle the case of &quot;/dev/null&quot; being used as an input filename.</a>
<a name="873"><span class="lineNum">     873 </span><span class="lineCov">        357 :           if (filenameExtension == &quot;/dev/null&quot;)</span></a>
<a name="874"><span class="lineNum">     874 </span>            :              {</a>
<a name="875"><span class="lineNum">     875 </span><span class="lineNoCov">          0 :                printf (&quot;Warning: detected use of /dev/null as input filename: not yet supported (exiting with 0 exit code) \n&quot;);</span></a>
<a name="876"><span class="lineNum">     876 </span><span class="lineNoCov">          0 :                exit(0);</span></a>
<a name="877"><span class="lineNum">     877 </span>            :              }</a>
<a name="878"><span class="lineNum">     878 </span>            : </a>
<a name="879"><span class="lineNum">     879 </span>            :        // DQ (5/18/2008): Set this to true (redundant, since the default already specified as true)</a>
<a name="880"><span class="lineNum">     880 </span>            :        // file-&gt;set_requires_C_preprocessor(true);</a>
<a name="881"><span class="lineNum">     881 </span>            : </a>
<a name="882"><span class="lineNum">     882 </span>            :        // DQ (11/17/2007): Mark this as a file using a Fortran file extension (else this turns off options down stream).</a>
<a name="883"><span class="lineNum">     883 </span><span class="lineCov">        357 :           if (CommandlineProcessing::isFortranFileNameSuffix(filenameExtension) == true)</span></a>
<a name="884"><span class="lineNum">     884 </span>            :              {</a>
<a name="885"><span class="lineNum">     885 </span><span class="lineCov">         37 :                SgSourceFile* sourceFile = new SgSourceFile ( argv,  project );</span></a>
<a name="886"><span class="lineNum">     886 </span><span class="lineCov">         37 :                file = sourceFile;</span></a>
<a name="887"><span class="lineNum">     887 </span>            : </a>
<a name="888"><span class="lineNum">     888 </span>            :             // printf (&quot;----------- Great location to set the sourceFilename = %s \n&quot;,sourceFilename.c_str());</a>
<a name="889"><span class="lineNum">     889 </span>            : </a>
<a name="890"><span class="lineNum">     890 </span>            :             // DQ (12/23/2008): Moved initialization of source position (call to initializeSourcePosition())</a>
<a name="891"><span class="lineNum">     891 </span>            :             // to earliest position in setup of SgFile.</a>
<a name="892"><span class="lineNum">     892 </span>            : </a>
<a name="893"><span class="lineNum">     893 </span>            :             // printf (&quot;Calling file-&gt;set_sourceFileUsesFortranFileExtension(true) \n&quot;);</a>
<a name="894"><span class="lineNum">     894 </span><span class="lineCov">         37 :                file-&gt;set_sourceFileUsesFortranFileExtension(true);</span></a>
<a name="895"><span class="lineNum">     895 </span>            : </a>
<a name="896"><span class="lineNum">     896 </span>            :             // Use the filename suffix as a default means to set this value</a>
<a name="897"><span class="lineNum">     897 </span><span class="lineCov">         37 :                file-&gt;set_outputLanguage(SgFile::e_Fortran_language);</span></a>
<a name="898"><span class="lineNum">     898 </span>            : </a>
<a name="899"><span class="lineNum">     899 </span>            :             // DQ (29/8/2017): Set the input language as well.</a>
<a name="900"><span class="lineNum">     900 </span><span class="lineCov">         37 :                file-&gt;set_inputLanguage(SgFile::e_Fortran_language);</span></a>
<a name="901"><span class="lineNum">     901 </span>            : </a>
<a name="902"><span class="lineNum">     902 </span><span class="lineCov">         37 :                file-&gt;set_Fortran_only(true);</span></a>
<a name="903"><span class="lineNum">     903 </span>            : </a>
<a name="904"><span class="lineNum">     904 </span>            :             // DQ (11/25/2020): Add support to set this as a specific language kind file (there is at least one language kind file processed by ROSE).</a>
<a name="905"><span class="lineNum">     905 </span><span class="lineCov">         37 :                Rose::is_Fortran_language = true;</span></a>
<a name="906"><span class="lineNum">     906 </span>            : </a>
<a name="907"><span class="lineNum">     907 </span>            :             // DQ (11/30/2010): This variable activates scopes built within the SageBuilder</a>
<a name="908"><span class="lineNum">     908 </span>            :             // interface to be built to use case insensitive symbol table handling.</a>
<a name="909"><span class="lineNum">     909 </span><span class="lineCov">         37 :                SageBuilder::symbol_table_case_insensitive_semantics = true;</span></a>
<a name="910"><span class="lineNum">     910 </span>            : </a>
<a name="911"><span class="lineNum">     911 </span>            :             // determine whether to run this file through the C preprocessor</a>
<a name="912"><span class="lineNum">     912 </span><span class="lineCov">         37 :                bool requires_C_preprocessor =</span></a>
<a name="913"><span class="lineNum">     913 </span>            :                           // DXN (02/20/2011): rmod file should never require it</a>
<a name="914"><span class="lineNum">     914 </span><span class="lineCov">         37 :                      (filenameExtension != &quot;rmod&quot;)</span></a>
<a name="915"><span class="lineNum">     915 </span><span class="lineCov">         74 :                       &amp;&amp;</span></a>
<a name="916"><span class="lineNum">     916 </span>            :                      (</a>
<a name="917"><span class="lineNum">     917 </span>            :                           // if the file extension implies it</a>
<a name="918"><span class="lineNum">     918 </span><span class="lineCov">         37 :                           CommandlineProcessing::isFortranFileNameSuffixRequiringCPP(filenameExtension)</span></a>
<a name="919"><span class="lineNum">     919 </span><span class="lineCov">         37 :                        ||</span></a>
<a name="920"><span class="lineNum">     920 </span>            :                           //if the command line includes &quot;-D&quot; options</a>
<a name="921"><span class="lineNum">     921 </span><span class="lineCov">         37 :                           ! getProject()-&gt;get_macroSpecifierList().empty()</span></a>
<a name="922"><span class="lineNum">     922 </span><span class="lineCov">         37 :                       );</span></a>
<a name="923"><span class="lineNum">     923 </span>            : </a>
<a name="924"><span class="lineNum">     924 </span>            : #if 0</a>
<a name="925"><span class="lineNum">     925 </span>            :                printf (&quot;@@@@@@@@@@@@@@ Set requires_C_preprocessor to %s (test 1) \n&quot;,requires_C_preprocessor ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="926"><span class="lineNum">     926 </span>            : #endif</a>
<a name="927"><span class="lineNum">     927 </span><span class="lineCov">         37 :                file-&gt;set_requires_C_preprocessor(requires_C_preprocessor);</span></a>
<a name="928"><span class="lineNum">     928 </span>            : </a>
<a name="929"><span class="lineNum">     929 </span>            :             // DQ (12/23/2008): This needs to be called after the set_requires_C_preprocessor() function is called.</a>
<a name="930"><span class="lineNum">     930 </span>            :             // If CPP processing is required then the global scope should have a source position using the intermediate</a>
<a name="931"><span class="lineNum">     931 </span>            :             // file name (generated by generate_C_preprocessor_intermediate_filename()).</a>
<a name="932"><span class="lineNum">     932 </span><span class="lineCov">         37 :                sourceFile-&gt;initializeGlobalScope();</span></a>
<a name="933"><span class="lineNum">     933 </span>            : </a>
<a name="934"><span class="lineNum">     934 </span>            :             // Now set the specific types of Fortran file extensions</a>
<a name="935"><span class="lineNum">     935 </span><span class="lineCov">         37 :                if (CommandlineProcessing::isFortran77FileNameSuffix(filenameExtension) == true)</span></a>
<a name="936"><span class="lineNum">     936 </span>            :                   {</a>
<a name="937"><span class="lineNum">     937 </span>            :                  // printf (&quot;Calling file-&gt;set_sourceFileUsesFortran77FileExtension(true) \n&quot;);</a>
<a name="938"><span class="lineNum">     938 </span><span class="lineCov">         31 :                     file-&gt;set_sourceFileUsesFortran77FileExtension(true);</span></a>
<a name="939"><span class="lineNum">     939 </span>            : </a>
<a name="940"><span class="lineNum">     940 </span>            :                  // Use the filename suffix as a default means to set this value</a>
<a name="941"><span class="lineNum">     941 </span><span class="lineCov">         31 :                     file-&gt;set_outputFormat(SgFile::e_fixed_form_output_format);</span></a>
<a name="942"><span class="lineNum">     942 </span><span class="lineCov">         31 :                     file-&gt;set_backendCompileFormat(SgFile::e_fixed_form_output_format);</span></a>
<a name="943"><span class="lineNum">     943 </span>            : </a>
<a name="944"><span class="lineNum">     944 </span><span class="lineCov">         31 :                     file-&gt;set_F77_only();</span></a>
<a name="945"><span class="lineNum">     945 </span>            :                   }</a>
<a name="946"><span class="lineNum">     946 </span>            : </a>
<a name="947"><span class="lineNum">     947 </span><span class="lineCov">         37 :                if (CommandlineProcessing::isFortran90FileNameSuffix(filenameExtension) == true)</span></a>
<a name="948"><span class="lineNum">     948 </span>            :                   {</a>
<a name="949"><span class="lineNum">     949 </span>            :                  // printf (&quot;Calling file-&gt;set_sourceFileUsesFortran90FileExtension(true) \n&quot;);</a>
<a name="950"><span class="lineNum">     950 </span><span class="lineCov">          6 :                     file-&gt;set_sourceFileUsesFortran90FileExtension(true);</span></a>
<a name="951"><span class="lineNum">     951 </span>            : </a>
<a name="952"><span class="lineNum">     952 </span>            :                  // Use the filename suffix as a default means to set this value</a>
<a name="953"><span class="lineNum">     953 </span><span class="lineCov">          6 :                     file-&gt;set_outputFormat(SgFile::e_free_form_output_format);</span></a>
<a name="954"><span class="lineNum">     954 </span><span class="lineCov">          6 :                     file-&gt;set_backendCompileFormat(SgFile::e_free_form_output_format);</span></a>
<a name="955"><span class="lineNum">     955 </span>            : </a>
<a name="956"><span class="lineNum">     956 </span><span class="lineCov">          6 :                     file-&gt;set_F90_only();</span></a>
<a name="957"><span class="lineNum">     957 </span>            :                   }</a>
<a name="958"><span class="lineNum">     958 </span>            : </a>
<a name="959"><span class="lineNum">     959 </span><span class="lineCov">         37 :                if (CommandlineProcessing::isFortran95FileNameSuffix(filenameExtension) == true)</span></a>
<a name="960"><span class="lineNum">     960 </span>            :                   {</a>
<a name="961"><span class="lineNum">     961 </span>            :                  // printf (&quot;Calling file-&gt;set_sourceFileUsesFortran95FileExtension(true) \n&quot;);</a>
<a name="962"><span class="lineNum">     962 </span><span class="lineNoCov">          0 :                     file-&gt;set_sourceFileUsesFortran95FileExtension(true);</span></a>
<a name="963"><span class="lineNum">     963 </span>            : </a>
<a name="964"><span class="lineNum">     964 </span>            :                  // Use the filename suffix as a default means to set this value</a>
<a name="965"><span class="lineNum">     965 </span><span class="lineNoCov">          0 :                     file-&gt;set_outputFormat(SgFile::e_free_form_output_format);</span></a>
<a name="966"><span class="lineNum">     966 </span><span class="lineNoCov">          0 :                     file-&gt;set_backendCompileFormat(SgFile::e_free_form_output_format);</span></a>
<a name="967"><span class="lineNum">     967 </span>            : </a>
<a name="968"><span class="lineNum">     968 </span><span class="lineNoCov">          0 :                     file-&gt;set_F95_only();</span></a>
<a name="969"><span class="lineNum">     969 </span>            :                   }</a>
<a name="970"><span class="lineNum">     970 </span>            : </a>
<a name="971"><span class="lineNum">     971 </span><span class="lineCov">         37 :                if (CommandlineProcessing::isFortran2003FileNameSuffix(filenameExtension) == true)</span></a>
<a name="972"><span class="lineNum">     972 </span>            :                   {</a>
<a name="973"><span class="lineNum">     973 </span>            :                  // printf (&quot;Calling file-&gt;set_sourceFileUsesFortran2003FileExtension(true) \n&quot;);</a>
<a name="974"><span class="lineNum">     974 </span><span class="lineNoCov">          0 :                     file-&gt;set_sourceFileUsesFortran2003FileExtension(true);</span></a>
<a name="975"><span class="lineNum">     975 </span>            : </a>
<a name="976"><span class="lineNum">     976 </span>            :                  // Use the filename suffix as a default means to set this value</a>
<a name="977"><span class="lineNum">     977 </span><span class="lineNoCov">          0 :                     file-&gt;set_outputFormat(SgFile::e_free_form_output_format);</span></a>
<a name="978"><span class="lineNum">     978 </span><span class="lineNoCov">          0 :                     file-&gt;set_backendCompileFormat(SgFile::e_free_form_output_format);</span></a>
<a name="979"><span class="lineNum">     979 </span>            : </a>
<a name="980"><span class="lineNum">     980 </span><span class="lineNoCov">          0 :                     file-&gt;set_F2003_only();</span></a>
<a name="981"><span class="lineNum">     981 </span>            :                   }</a>
<a name="982"><span class="lineNum">     982 </span>            : </a>
<a name="983"><span class="lineNum">     983 </span><span class="lineCov">         37 :                if (CommandlineProcessing::isCoArrayFortranFileNameSuffix(filenameExtension) == true)</span></a>
<a name="984"><span class="lineNum">     984 </span>            :                   {</a>
<a name="985"><span class="lineNum">     985 </span>            :                  // printf (&quot;Calling file-&gt;set_sourceFileUsesFortran2003FileExtension(true) \n&quot;);</a>
<a name="986"><span class="lineNum">     986 </span><span class="lineNoCov">          0 :                     file-&gt;set_sourceFileUsesCoArrayFortranFileExtension(true);</span></a>
<a name="987"><span class="lineNum">     987 </span>            : </a>
<a name="988"><span class="lineNum">     988 </span>            :                  // Use the filename suffix as a default means to set this value</a>
<a name="989"><span class="lineNum">     989 </span><span class="lineNoCov">          0 :                     file-&gt;set_outputFormat(SgFile::e_free_form_output_format);</span></a>
<a name="990"><span class="lineNum">     990 </span><span class="lineNoCov">          0 :                     file-&gt;set_backendCompileFormat(SgFile::e_free_form_output_format);</span></a>
<a name="991"><span class="lineNum">     991 </span>            : </a>
<a name="992"><span class="lineNum">     992 </span>            :                  // DQ (1/23/2009): I think that since CAF is an extension of F2003, we want to mark this as F2003 as well.</a>
<a name="993"><span class="lineNum">     993 </span><span class="lineNoCov">          0 :                     file-&gt;set_F2003_only();</span></a>
<a name="994"><span class="lineNum">     994 </span><span class="lineNoCov">          0 :                     file-&gt;set_CoArrayFortran_only(true);</span></a>
<a name="995"><span class="lineNum">     995 </span>            :                   }</a>
<a name="996"><span class="lineNum">     996 </span>            : </a>
<a name="997"><span class="lineNum">     997 </span><span class="lineCov">         37 :                if (CommandlineProcessing::isFortran2008FileNameSuffix(filenameExtension) == true)</span></a>
<a name="998"><span class="lineNum">     998 </span>            :                   {</a>
<a name="999"><span class="lineNum">     999 </span>            :                  // printf (&quot;Sorry, Fortran 2008 specific support is not yet implemented in ROSE ... \n&quot;);</a>
<a name="1000"><span class="lineNum">    1000 </span>            :                  // ROSE_ASSERT(false);</a>
<a name="1001"><span class="lineNum">    1001 </span>            : </a>
<a name="1002"><span class="lineNum">    1002 </span>            :                  // This is not yet supported.</a>
<a name="1003"><span class="lineNum">    1003 </span>            :                  // file-&gt;set_sourceFileUsesFortran2008FileExtension(true);</a>
<a name="1004"><span class="lineNum">    1004 </span><span class="lineNoCov">          0 :                     file-&gt;set_sourceFileUsesFortran2008FileExtension(true);</span></a>
<a name="1005"><span class="lineNum">    1005 </span>            : </a>
<a name="1006"><span class="lineNum">    1006 </span>            :                  // Use the filename suffix as a default means to set this value</a>
<a name="1007"><span class="lineNum">    1007 </span><span class="lineNoCov">          0 :                     file-&gt;set_outputFormat(SgFile::e_free_form_output_format);</span></a>
<a name="1008"><span class="lineNum">    1008 </span><span class="lineNoCov">          0 :                     file-&gt;set_backendCompileFormat(SgFile::e_free_form_output_format);</span></a>
<a name="1009"><span class="lineNum">    1009 </span>            : </a>
<a name="1010"><span class="lineNum">    1010 </span><span class="lineNoCov">          0 :                     file-&gt;set_F2008_only();</span></a>
<a name="1011"><span class="lineNum">    1011 </span>            :                   }</a>
<a name="1012"><span class="lineNum">    1012 </span>            :              }</a>
<a name="1013"><span class="lineNum">    1013 </span>            :             else</a>
<a name="1014"><span class="lineNum">    1014 </span>            :              {</a>
<a name="1015"><span class="lineNum">    1015 </span>            :                // SG (7/9/2015) When processing multiple files, we need to reset</a>
<a name="1016"><span class="lineNum">    1016 </span>            :                // case_insensitive_semantics.  But this only sets it to the last</a>
<a name="1017"><span class="lineNum">    1017 </span>            :                // file created.  During AST construction, it will need to be</a>
<a name="1018"><span class="lineNum">    1018 </span>            :                // reset for each language.</a>
<a name="1019"><span class="lineNum">    1019 </span><span class="lineCov">        320 :                SageBuilder::symbol_table_case_insensitive_semantics = false;</span></a>
<a name="1020"><span class="lineNum">    1020 </span>            : </a>
<a name="1021"><span class="lineNum">    1021 </span><span class="lineCov">        320 :                   {</span></a>
<a name="1022"><span class="lineNum">    1022 </span>            :                  // printf (&quot;Calling file-&gt;set_sourceFileUsesFortranFileExtension(false) \n&quot;);</a>
<a name="1023"><span class="lineNum">    1023 </span>            : </a>
<a name="1024"><span class="lineNum">    1024 </span>            :                  // if (StringUtility::isCppFileNameSuffix(filenameExtension) == true)</a>
<a name="1025"><span class="lineNum">    1025 </span><span class="lineCov">        320 :                     if (CommandlineProcessing::isCppFileNameSuffix(filenameExtension) == true)</span></a>
<a name="1026"><span class="lineNum">    1026 </span>            :                        {</a>
<a name="1027"><span class="lineNum">    1027 </span>            :                       // file = new SgSourceFile ( argv,  project );</a>
<a name="1028"><span class="lineNum">    1028 </span><span class="lineCov">         66 :                          SgSourceFile* sourceFile = new SgSourceFile ( argv,  project );</span></a>
<a name="1029"><span class="lineNum">    1029 </span><span class="lineCov">         66 :                          file = sourceFile;</span></a>
<a name="1030"><span class="lineNum">    1030 </span>            : </a>
<a name="1031"><span class="lineNum">    1031 </span>            :                       // This is a C++ file (so define __cplusplus, just like GNU gcc would)</a>
<a name="1032"><span class="lineNum">    1032 </span>            :                       // file-&gt;set_requires_cplusplus_macro(true);</a>
<a name="1033"><span class="lineNum">    1033 </span><span class="lineCov">         66 :                          file-&gt;set_sourceFileUsesCppFileExtension(true);</span></a>
<a name="1034"><span class="lineNum">    1034 </span>            : </a>
<a name="1035"><span class="lineNum">    1035 </span>            :                       // Use the filename suffix as a default means to set this value</a>
<a name="1036"><span class="lineNum">    1036 </span><span class="lineCov">         66 :                          file-&gt;set_outputLanguage(SgFile::e_Cxx_language);</span></a>
<a name="1037"><span class="lineNum">    1037 </span>            : </a>
<a name="1038"><span class="lineNum">    1038 </span>            :                       // DQ (29/8/2017): Set the input language as well.</a>
<a name="1039"><span class="lineNum">    1039 </span><span class="lineCov">         66 :                          file-&gt;set_inputLanguage(SgFile::e_Cxx_language);</span></a>
<a name="1040"><span class="lineNum">    1040 </span>            : </a>
<a name="1041"><span class="lineNum">    1041 </span><span class="lineCov">         66 :                          file-&gt;set_Cxx_only(true);</span></a>
<a name="1042"><span class="lineNum">    1042 </span>            : </a>
<a name="1043"><span class="lineNum">    1043 </span>            :                       // DQ (11/25/2020): Add support to set this as a specific language kind file (there is at least one language kind file processed by ROSE).</a>
<a name="1044"><span class="lineNum">    1044 </span><span class="lineCov">         66 :                          Rose::is_Cxx_language = true;</span></a>
<a name="1045"><span class="lineNum">    1045 </span>            : </a>
<a name="1046"><span class="lineNum">    1046 </span>            :                       // DQ (12/23/2008): This is the eariliest point where the global scope can be set.</a>
<a name="1047"><span class="lineNum">    1047 </span>            :                       // Note that file-&gt;get_requires_C_preprocessor() should be false.</a>
<a name="1048"><span class="lineNum">    1048 </span><span class="lineCov">         66 :                          ROSE_ASSERT(file-&gt;get_requires_C_preprocessor() == false);</span></a>
<a name="1049"><span class="lineNum">    1049 </span><span class="lineCov">         66 :                          sourceFile-&gt;initializeGlobalScope();</span></a>
<a name="1050"><span class="lineNum">    1050 </span>            :                        }</a>
<a name="1051"><span class="lineNum">    1051 </span>            :                       else</a>
<a name="1052"><span class="lineNum">    1052 </span>            :                        {</a>
<a name="1053"><span class="lineNum">    1053 </span>            :                       // Liao, 6/6/2008, Assume AST with UPC will be unparsed using the C unparser</a>
<a name="1054"><span class="lineNum">    1054 </span><span class="lineCov">        257 :                          if ( ( CommandlineProcessing::isCFileNameSuffix(filenameExtension)   == true ) ||</span></a>
<a name="1055"><span class="lineNum">    1055 </span><span class="lineCov">          3 :                               ( CommandlineProcessing::isUPCFileNameSuffix(filenameExtension) == true ) )</span></a>
<a name="1056"><span class="lineNum">    1056 </span>            :                             {</a>
<a name="1057"><span class="lineNum">    1057 </span>            :                            // file = new SgSourceFile ( argv,  project );</a>
<a name="1058"><span class="lineNum">    1058 </span><span class="lineCov">        254 :                               SgSourceFile* sourceFile = new SgSourceFile ( argv,  project );</span></a>
<a name="1059"><span class="lineNum">    1059 </span><span class="lineCov">        254 :                               file = sourceFile;</span></a>
<a name="1060"><span class="lineNum">    1060 </span>            : </a>
<a name="1061"><span class="lineNum">    1061 </span>            :                            // This a not a C++ file (assume it is a C file and don't define the __cplusplus macro, just like GNU gcc would)</a>
<a name="1062"><span class="lineNum">    1062 </span><span class="lineCov">        254 :                               file-&gt;set_sourceFileUsesCppFileExtension(false);</span></a>
<a name="1063"><span class="lineNum">    1063 </span>            : </a>
<a name="1064"><span class="lineNum">    1064 </span>            :                            // Use the filename suffix as a default means to set this value</a>
<a name="1065"><span class="lineNum">    1065 </span><span class="lineCov">        254 :                               file-&gt;set_outputLanguage(SgFile::e_C_language);</span></a>
<a name="1066"><span class="lineNum">    1066 </span>            : </a>
<a name="1067"><span class="lineNum">    1067 </span>            :                            // DQ (8/29/2017): Set the input language as well.</a>
<a name="1068"><span class="lineNum">    1068 </span><span class="lineCov">        254 :                               file-&gt;set_inputLanguage(SgFile::e_C_language);</span></a>
<a name="1069"><span class="lineNum">    1069 </span>            : </a>
<a name="1070"><span class="lineNum">    1070 </span><span class="lineCov">        254 :                               file-&gt;set_C_only(true);</span></a>
<a name="1071"><span class="lineNum">    1071 </span>            : </a>
<a name="1072"><span class="lineNum">    1072 </span>            :                            // DQ (11/25/2020): Add support to set this as a specific language kind file (there is at least one language kind file processed by ROSE).</a>
<a name="1073"><span class="lineNum">    1073 </span><span class="lineCov">        254 :                               Rose::is_C_language = true;</span></a>
<a name="1074"><span class="lineNum">    1074 </span>            : </a>
<a name="1075"><span class="lineNum">    1075 </span>            :                            // Liao 6/6/2008  Set the newly introduced p_UPC_only flag.</a>
<a name="1076"><span class="lineNum">    1076 </span><span class="lineCov">        254 :                               if (CommandlineProcessing::isUPCFileNameSuffix(filenameExtension) == true)</span></a>
<a name="1077"><span class="lineNum">    1077 </span>            :                                  {</a>
<a name="1078"><span class="lineNum">    1078 </span><span class="lineCov">          3 :                                    file-&gt;set_UPC_only();</span></a>
<a name="1079"><span class="lineNum">    1079 </span>            : </a>
<a name="1080"><span class="lineNum">    1080 </span>            :                                 // DQ (11/25/2020): Add support to set this as a specific language kind file (there is at least one language kind file processed by ROSE).</a>
<a name="1081"><span class="lineNum">    1081 </span><span class="lineCov">          3 :                                    Rose::is_UPC_language = true;</span></a>
<a name="1082"><span class="lineNum">    1082 </span>            :                                  }</a>
<a name="1083"><span class="lineNum">    1083 </span>            :                                 else</a>
<a name="1084"><span class="lineNum">    1084 </span>            :                                  {</a>
<a name="1085"><span class="lineNum">    1085 </span><span class="lineCov">        251 :                                    file-&gt;set_C99_gnu_only();</span></a>
<a name="1086"><span class="lineNum">    1086 </span>            : #if 0</a>
<a name="1087"><span class="lineNum">    1087 </span>            :                                    printf (&quot;In determineFileType(): Setting the default mode for detected C cile to C99 (specifically generated code will use: -std=gnu99 option) \n&quot;);</a>
<a name="1088"><span class="lineNum">    1088 </span>            : #endif</a>
<a name="1089"><span class="lineNum">    1089 </span>            :                                  }</a>
<a name="1090"><span class="lineNum">    1090 </span>            : </a>
<a name="1091"><span class="lineNum">    1091 </span>            :                            // DQ (12/23/2008): This is the eariliest point where the global scope can be set.</a>
<a name="1092"><span class="lineNum">    1092 </span>            :                            // Note that file-&gt;get_requires_C_preprocessor() should be false.</a>
<a name="1093"><span class="lineNum">    1093 </span><span class="lineCov">        254 :                               ROSE_ASSERT(file-&gt;get_requires_C_preprocessor() == false);</span></a>
<a name="1094"><span class="lineNum">    1094 </span><span class="lineCov">        254 :                               sourceFile-&gt;initializeGlobalScope();</span></a>
<a name="1095"><span class="lineNum">    1095 </span>            :                             }</a>
<a name="1096"><span class="lineNum">    1096 </span>            :                            else</a>
<a name="1097"><span class="lineNum">    1097 </span>            :                             {</a>
<a name="1098"><span class="lineNum">    1098 </span><span class="lineNoCov">          0 :                               if ( CommandlineProcessing::isCudaFileNameSuffix(filenameExtension) == true )</span></a>
<a name="1099"><span class="lineNum">    1099 </span>            :                                  {</a>
<a name="1100"><span class="lineNum">    1100 </span><span class="lineNoCov">          0 :                                    SgSourceFile* sourceFile = new SgSourceFile ( argv,  project );</span></a>
<a name="1101"><span class="lineNum">    1101 </span><span class="lineNoCov">          0 :                                    file = sourceFile;</span></a>
<a name="1102"><span class="lineNum">    1102 </span>            : </a>
<a name="1103"><span class="lineNum">    1103 </span><span class="lineNoCov">          0 :                                    file-&gt;set_outputLanguage(SgFile::e_Cxx_language);</span></a>
<a name="1104"><span class="lineNum">    1104 </span>            : </a>
<a name="1105"><span class="lineNum">    1105 </span>            :                                 // DQ (29/8/2017): Set the input language as well.</a>
<a name="1106"><span class="lineNum">    1106 </span><span class="lineNoCov">          0 :                                    file-&gt;set_inputLanguage(SgFile::e_Cxx_language);</span></a>
<a name="1107"><span class="lineNum">    1107 </span>            : </a>
<a name="1108"><span class="lineNum">    1108 </span><span class="lineNoCov">          0 :                                    file-&gt;set_Cuda_only(true);</span></a>
<a name="1109"><span class="lineNum">    1109 </span>            : </a>
<a name="1110"><span class="lineNum">    1110 </span>            :                                 // DQ (11/25/2020): Add support to set this as a specific language kind file (there is at least one language kind file processed by ROSE).</a>
<a name="1111"><span class="lineNum">    1111 </span><span class="lineNoCov">          0 :                                    Rose::is_Cuda_language = true;</span></a>
<a name="1112"><span class="lineNum">    1112 </span>            : </a>
<a name="1113"><span class="lineNum">    1113 </span>            :                                 // DQ (12/23/2008): This is the eariliest point where the global scope can be set.</a>
<a name="1114"><span class="lineNum">    1114 </span>            :                                 // Note that file-&gt;get_requires_C_preprocessor() should be false.</a>
<a name="1115"><span class="lineNum">    1115 </span><span class="lineNoCov">          0 :                                    ROSE_ASSERT(file-&gt;get_requires_C_preprocessor() == false);</span></a>
<a name="1116"><span class="lineNum">    1116 </span><span class="lineNoCov">          0 :                                    sourceFile-&gt;initializeGlobalScope();</span></a>
<a name="1117"><span class="lineNum">    1117 </span>            : #if 0</a>
<a name="1118"><span class="lineNum">    1118 </span>            :                                    printf (&quot;In determineFileType(): Processing as a CUDA file \n&quot;);</a>
<a name="1119"><span class="lineNum">    1119 </span>            : #endif</a>
<a name="1120"><span class="lineNum">    1120 </span>            :                                  }</a>
<a name="1121"><span class="lineNum">    1121 </span><span class="lineNoCov">          0 :                                 else if ( CommandlineProcessing::isOpenCLFileNameSuffix(filenameExtension) == true )</span></a>
<a name="1122"><span class="lineNum">    1122 </span>            :                                  {</a>
<a name="1123"><span class="lineNum">    1123 </span><span class="lineNoCov">          0 :                                    SgSourceFile* sourceFile = new SgSourceFile ( argv,  project );</span></a>
<a name="1124"><span class="lineNum">    1124 </span><span class="lineNoCov">          0 :                                    file = sourceFile;</span></a>
<a name="1125"><span class="lineNum">    1125 </span><span class="lineNoCov">          0 :                                    file-&gt;set_OpenCL_only(true);</span></a>
<a name="1126"><span class="lineNum">    1126 </span>            : </a>
<a name="1127"><span class="lineNum">    1127 </span>            :                                 // DQ (11/25/2020): Add support to set this as a specific language kind file (there is at least one language kind file processed by ROSE).</a>
<a name="1128"><span class="lineNum">    1128 </span><span class="lineNoCov">          0 :                                    Rose::is_OpenCL_language = true;</span></a>
<a name="1129"><span class="lineNum">    1129 </span>            : </a>
<a name="1130"><span class="lineNum">    1130 </span>            :                                 // DQ (12/23/2008): This is the eariliest point where the global scope can be set.</a>
<a name="1131"><span class="lineNum">    1131 </span>            :                                 // Note that file-&gt;get_requires_C_preprocessor() should be false.</a>
<a name="1132"><span class="lineNum">    1132 </span><span class="lineNoCov">          0 :                                    ROSE_ASSERT(file-&gt;get_requires_C_preprocessor() == false);</span></a>
<a name="1133"><span class="lineNum">    1133 </span><span class="lineNoCov">          0 :                                    sourceFile-&gt;initializeGlobalScope();</span></a>
<a name="1134"><span class="lineNum">    1134 </span>            :                                  }</a>
<a name="1135"><span class="lineNum">    1135 </span>            :                               else</a>
<a name="1136"><span class="lineNum">    1136 </span>            :                                {</a>
<a name="1137"><span class="lineNum">    1137 </span><span class="lineNoCov">          0 :                                    file = new SgUnknownFile ( argv,  project );</span></a>
<a name="1138"><span class="lineNum">    1138 </span>            : </a>
<a name="1139"><span class="lineNum">    1139 </span>            :                                 // This should have already been setup!</a>
<a name="1140"><span class="lineNum">    1140 </span>            :                                 // file-&gt;initializeSourcePosition();</a>
<a name="1141"><span class="lineNum">    1141 </span>            : </a>
<a name="1142"><span class="lineNum">    1142 </span><span class="lineNoCov">          0 :                                    ASSERT_not_null(file-&gt;get_parent());</span></a>
<a name="1143"><span class="lineNum">    1143 </span><span class="lineNoCov">          0 :                                    ROSE_ASSERT(file-&gt;get_parent() == project);</span></a>
<a name="1144"><span class="lineNum">    1144 </span>            : </a>
<a name="1145"><span class="lineNum">    1145 </span>            :                                 // If all else fails, then output the type of file and exit.</a>
<a name="1146"><span class="lineNum">    1146 </span><span class="lineNoCov">          0 :                                    file-&gt;set_sourceFileTypeIsUnknown(true);</span></a>
<a name="1147"><span class="lineNum">    1147 </span>            : </a>
<a name="1148"><span class="lineNum">    1148 </span>            : #if 0</a>
<a name="1149"><span class="lineNum">    1149 </span>            :                                    printf (&quot;@@@@@@@@@@@@@@ Set requires_C_preprocessor to false (test 3) \n&quot;);</a>
<a name="1150"><span class="lineNum">    1150 </span>            : #endif</a>
<a name="1151"><span class="lineNum">    1151 </span><span class="lineNoCov">          0 :                                    file-&gt;set_requires_C_preprocessor(false);</span></a>
<a name="1152"><span class="lineNum">    1152 </span>            : </a>
<a name="1153"><span class="lineNum">    1153 </span><span class="lineNoCov">          0 :                                    ASSERT_not_null(file-&gt;get_file_info());</span></a>
<a name="1154"><span class="lineNum">    1154 </span>            :                                 // file-&gt;set_parent(project);</a>
<a name="1155"><span class="lineNum">    1155 </span>            : </a>
<a name="1156"><span class="lineNum">    1156 </span>            :                                 // DQ (2/3/2009): Uncommented this to report the file type when we don't process it...</a>
<a name="1157"><span class="lineNum">    1157 </span>            :                                 // outputTypeOfFileAndExit(sourceFilename);</a>
<a name="1158"><span class="lineNum">    1158 </span><span class="lineNoCov">          0 :                                    printf (&quot;Warning: This is an unknown file type, not being processed by ROSE: sourceFilename = %s \n&quot;,sourceFilename.c_str());</span></a>
<a name="1159"><span class="lineNum">    1159 </span><span class="lineNoCov">          0 :                                    outputTypeOfFileAndExit(sourceFilename);</span></a>
<a name="1160"><span class="lineNum">    1160 </span>            :                                  }</a>
<a name="1161"><span class="lineNum">    1161 </span>            :                             }</a>
<a name="1162"><span class="lineNum">    1162 </span>            :                        }</a>
<a name="1163"><span class="lineNum">    1163 </span>            :                   }</a>
<a name="1164"><span class="lineNum">    1164 </span>            : </a>
<a name="1165"><span class="lineNum">    1165 </span><span class="lineCov">        320 :                  file-&gt;set_sourceFileUsesFortranFileExtension(false);</span></a>
<a name="1166"><span class="lineNum">    1166 </span>            :              }</a>
<a name="1167"><span class="lineNum">    1167 </span>            :         }</a>
<a name="1168"><span class="lineNum">    1168 </span>            :        else</a>
<a name="1169"><span class="lineNum">    1169 </span>            :         {</a>
<a name="1170"><span class="lineNum">    1170 </span>            :        // DQ (2/6/2009): This case is used by the build function SageBuilder::buildFile().</a>
<a name="1171"><span class="lineNum">    1171 </span>            : </a>
<a name="1172"><span class="lineNum">    1172 </span>            :        // DQ (12/22/2008): Make any error message from this branch more clear for debugging!</a>
<a name="1173"><span class="lineNum">    1173 </span>            :        // AS Is this option possible?</a>
<a name="1174"><span class="lineNum">    1174 </span>            :           printf (&quot;Is this branch reachable? \n&quot;);</a>
<a name="1175"><span class="lineNum">    1175 </span>            :           ROSE_ABORT();</a>
<a name="1176"><span class="lineNum">    1176 </span>            :        // abort();</a>
<a name="1177"><span class="lineNum">    1177 </span>            : </a>
<a name="1178"><span class="lineNum">    1178 </span>            :        // ROSE_ASSERT (p_numberOfSourceFileNames == 0);</a>
<a name="1179"><span class="lineNum">    1179 </span>            :           ROSE_ASSERT (file-&gt;get_sourceFileNameWithPath().empty() == true);</a>
<a name="1180"><span class="lineNum">    1180 </span>            : </a>
<a name="1181"><span class="lineNum">    1181 </span>            :        // If no source code file name was found then likely this is:</a>
<a name="1182"><span class="lineNum">    1182 </span>            :        //   1) a link command, or</a>
<a name="1183"><span class="lineNum">    1183 </span>            :        //   2) called as part of the SageBuilder::buildFile()</a>
<a name="1184"><span class="lineNum">    1184 </span>            :        // using the C++ compiler.  In this case skip the EDG processing.</a>
<a name="1185"><span class="lineNum">    1185 </span>            :           file-&gt;set_disable_edg_backend(true);</a>
<a name="1186"><span class="lineNum">    1186 </span>            :         }</a>
<a name="1187"><span class="lineNum">    1187 </span>            : </a>
<a name="1188"><span class="lineNum">    1188 </span>            : #if 0</a>
<a name="1189"><span class="lineNum">    1189 </span>            :   // DQ (6/12/2013): I think this is required to support having all of the SgSourceFile</a>
<a name="1190"><span class="lineNum">    1190 </span>            :   // IR nodes pre-built as part of the new Java support required to be better performance</a>
<a name="1191"><span class="lineNum">    1191 </span>            :   // in the Java frontend AST translation.</a>
<a name="1192"><span class="lineNum">    1192 </span>            :      printf (&quot;***************************************************************************************************************************************************************************** \n&quot;);</a>
<a name="1193"><span class="lineNum">    1193 </span>            :      printf (&quot;***************************************************************************************************************************************************************************** \n&quot;);</a>
<a name="1194"><span class="lineNum">    1194 </span>            :      printf (&quot;Disabling the call to the frontend so that we can setup the SgSourceFile IR nodes once at the start and then call the frontend on each of them as we process all of the files \n&quot;);</a>
<a name="1195"><span class="lineNum">    1195 </span>            :      printf (&quot;***************************************************************************************************************************************************************************** \n&quot;);</a>
<a name="1196"><span class="lineNum">    1196 </span>            :      printf (&quot;***************************************************************************************************************************************************************************** \n&quot;);</a>
<a name="1197"><span class="lineNum">    1197 </span>            : #endif</a>
<a name="1198"><span class="lineNum">    1198 </span>            : </a>
<a name="1199"><span class="lineNum">    1199 </span>            :   // Keep the filename stored in the Sg_File_Info consistant.  Later we will want to remove this redundency</a>
<a name="1200"><span class="lineNum">    1200 </span>            :   // The reason we have the Sg_File_Info object is so that we can easily support filename matching based on</a>
<a name="1201"><span class="lineNum">    1201 </span>            :   // the integer values instead of string comparisions.  Required for the handling co CPP directives and comments.</a>
<a name="1202"><span class="lineNum">    1202 </span>            : </a>
<a name="1203"><span class="lineNum">    1203 </span>            : #if 0</a>
<a name="1204"><span class="lineNum">    1204 </span>            :      if (file != nullptr)</a>
<a name="1205"><span class="lineNum">    1205 </span>            :         {</a>
<a name="1206"><span class="lineNum">    1206 </span>            :           printf (&quot;Calling file-&gt;display() \n&quot;);</a>
<a name="1207"><span class="lineNum">    1207 </span>            :           file-&gt;display(&quot;SgFile* determineFileType()&quot;);</a>
<a name="1208"><span class="lineNum">    1208 </span>            :         }</a>
<a name="1209"><span class="lineNum">    1209 </span>            : #endif</a>
<a name="1210"><span class="lineNum">    1210 </span>            : </a>
<a name="1211"><span class="lineNum">    1211 </span><span class="lineCov">        357 :      ASSERT_not_null(file);</span></a>
<a name="1212"><span class="lineNum">    1212 </span>            : </a>
<a name="1213"><span class="lineNum">    1213 </span>            : #if 0</a>
<a name="1214"><span class="lineNum">    1214 </span>            :      printf (&quot;Leaving determineFileType() = %d \n&quot;,file-&gt;get_outputLanguage());</a>
<a name="1215"><span class="lineNum">    1215 </span>            :      printf (&quot;Leaving determineFileType() = %s \n&quot;,SgFile::get_outputLanguageOptionName(file-&gt;get_outputLanguage()).c_str());</a>
<a name="1216"><span class="lineNum">    1216 </span>            : #endif</a>
<a name="1217"><span class="lineNum">    1217 </span>            : </a>
<a name="1218"><span class="lineNum">    1218 </span>            :   // DQ (6/13/2013): Added to support error checking (seperation of construction of SgFile IR nodes from calling the fronend on each one).</a>
<a name="1219"><span class="lineNum">    1219 </span><span class="lineCov">        357 :      ASSERT_not_null(file-&gt;get_parent());</span></a>
<a name="1220"><span class="lineNum">    1220 </span><span class="lineCov">        357 :      ASSERT_not_null(isSgProject(file-&gt;get_parent()));</span></a>
<a name="1221"><span class="lineNum">    1221 </span><span class="lineCov">        357 :      ROSE_ASSERT(file-&gt;get_parent() == project);</span></a>
<a name="1222"><span class="lineNum">    1222 </span>            : </a>
<a name="1223"><span class="lineNum">    1223 </span>            :   // DQ (7/2/2020): Added assertion (fails for snippet tests).</a>
<a name="1224"><span class="lineNum">    1224 </span><span class="lineCov">        357 :      if (file-&gt;get_preprocessorDirectivesAndCommentsList() == nullptr)</span></a>
<a name="1225"><span class="lineNum">    1225 </span>            :         {</a>
<a name="1226"><span class="lineNum">    1226 </span><span class="lineCov">        714 :           file-&gt;set_preprocessorDirectivesAndCommentsList(new ROSEAttributesListContainer());</span></a>
<a name="1227"><span class="lineNum">    1227 </span>            :         }</a>
<a name="1228"><span class="lineNum">    1228 </span><span class="lineCov">        357 :      ASSERT_not_null(file-&gt;get_preprocessorDirectivesAndCommentsList());</span></a>
<a name="1229"><span class="lineNum">    1229 </span>            : </a>
<a name="1230"><span class="lineNum">    1230 </span><span class="lineCov">        357 :      return file;</span></a>
<a name="1231"><span class="lineNum">    1231 </span>            :    }</a>
<a name="1232"><span class="lineNum">    1232 </span>            : </a>
<a name="1233"><span class="lineNum">    1233 </span>            : </a>
<a name="1234"><span class="lineNum">    1234 </span>            : void</a>
<a name="1235"><span class="lineNum">    1235 </span><span class="lineCov">        357 : SgFile::runFrontend(int &amp; nextErrorCode)</span></a>
<a name="1236"><span class="lineNum">    1236 </span>            : {</a>
<a name="1237"><span class="lineNum">    1237 </span>            :   // DQ (6/13/2013):  This function supports the separation of the construction of the SgFile IR nodes from the</a>
<a name="1238"><span class="lineNum">    1238 </span>            :   // invocation of the frontend on each SgFile IR node.</a>
<a name="1239"><span class="lineNum">    1239 </span>            : </a>
<a name="1240"><span class="lineNum">    1240 </span>            : #if 0</a>
<a name="1241"><span class="lineNum">    1241 </span>            :      printf (&quot;************************ \n&quot;);</a>
<a name="1242"><span class="lineNum">    1242 </span>            :      printf (&quot;In SgFile::runFrontend() \n&quot;);</a>
<a name="1243"><span class="lineNum">    1243 </span>            :      printf (&quot;************************ \n&quot;);</a>
<a name="1244"><span class="lineNum">    1244 </span>            : #endif</a>
<a name="1245"><span class="lineNum">    1245 </span>            : </a>
<a name="1246"><span class="lineNum">    1246 </span>            : #if 0</a>
<a name="1247"><span class="lineNum">    1247 </span>            :   // Output state of the SgFile.</a>
<a name="1248"><span class="lineNum">    1248 </span>            :      display(&quot;In runFrontend()&quot;);</a>
<a name="1249"><span class="lineNum">    1249 </span>            : #endif</a>
<a name="1250"><span class="lineNum">    1250 </span>            : </a>
<a name="1251"><span class="lineNum">    1251 </span>            :   // DQ (11/4/2015): Added assertion.</a>
<a name="1252"><span class="lineNum">    1252 </span><span class="lineCov">        357 :      ASSERT_not_null(this);</span></a>
<a name="1253"><span class="lineNum">    1253 </span>            : </a>
<a name="1254"><span class="lineNum">    1254 </span>            :   // DQ (6/13/2013): Added to support error checking (seperation of construction of SgFile IR nodes from calling the fronend on each one).</a>
<a name="1255"><span class="lineNum">    1255 </span><span class="lineCov">        357 :      ROSE_ASSERT(get_parent() != NULL);</span></a>
<a name="1256"><span class="lineNum">    1256 </span>            : </a>
<a name="1257"><span class="lineNum">    1257 </span>            :   // DQ (6/13/2013): This is wrong, the parent of the SgFile is the SgFileList IR node.</a>
<a name="1258"><span class="lineNum">    1258 </span>            :   // ROSE_ASSERT(isSgProject(get_parent()) != NULL);</a>
<a name="1259"><span class="lineNum">    1259 </span>            : </a>
<a name="1260"><span class="lineNum">    1260 </span>            :   // DQ (6/12/2013): This is the functionality that we need to separate out and run after all</a>
<a name="1261"><span class="lineNum">    1261 </span>            :   // of the SgSourceFile IR nodes are constructed.</a>
<a name="1262"><span class="lineNum">    1262 </span>            : </a>
<a name="1263"><span class="lineNum">    1263 </span>            :   // The frontend is called explicitly outside the constructor since that allows for a cleaner</a>
<a name="1264"><span class="lineNum">    1264 </span>            :   // control flow. The callFrontEnd() relies on all the &quot;set_&quot; flags to be already called therefore</a>
<a name="1265"><span class="lineNum">    1265 </span>            :   // it was placed here.</a>
<a name="1266"><span class="lineNum">    1266 </span>            :   // if ( isSgUnknownFile(file) == NULL &amp;&amp; file != NULL  )</a>
<a name="1267"><span class="lineNum">    1267 </span>            : </a>
<a name="1268"><span class="lineNum">    1268 </span>            :   // DQ (3/25/2017): The NULL check is done above and Clang reports it as a warning that we want to remove.</a>
<a name="1269"><span class="lineNum">    1269 </span>            :   // if ( this != NULL &amp;&amp; isSgUnknownFile(this) == NULL )</a>
<a name="1270"><span class="lineNum">    1270 </span><span class="lineCov">        357 :     if ( isSgUnknownFile(this) == nullptr )</span></a>
<a name="1271"><span class="lineNum">    1271 </span>            :     {</a>
<a name="1272"><span class="lineNum">    1272 </span><span class="lineCov">        357 :         nextErrorCode = this-&gt;callFrontEnd();</span></a>
<a name="1273"><span class="lineNum">    1273 </span><span class="lineCov">        357 :         this-&gt;set_frontendErrorCode(nextErrorCode);</span></a>
<a name="1274"><span class="lineNum">    1274 </span>            :     }</a>
<a name="1275"><span class="lineNum">    1275 </span>            : </a>
<a name="1276"><span class="lineNum">    1276 </span><span class="lineCov">        357 :     ROSE_ASSERT(nextErrorCode &lt;= 3);</span></a>
<a name="1277"><span class="lineNum">    1277 </span><span class="lineCov">        357 : }</span></a>
<a name="1278"><span class="lineNum">    1278 </span>            : </a>
<a name="1279"><span class="lineNum">    1279 </span>            : </a>
<a name="1280"><span class="lineNum">    1280 </span>            : // DQ (10/20/2010): Note that Java support can be enabled just because Java internal support was found on the</a>
<a name="1281"><span class="lineNum">    1281 </span>            : // current platform.  But we only want to inialize the JVM server if we require Fortran or Java language support.</a>
<a name="1282"><span class="lineNum">    1282 </span>            : // So use the explicit macros defined in rose_config header file for this level of control.</a>
<a name="1283"><span class="lineNum">    1283 </span>            : #ifdef ROSE_BUILD_FORTRAN_LANGUAGE_SUPPORT</a>
<a name="1284"><span class="lineNum">    1284 </span>            : namespace Rose {</a>
<a name="1285"><span class="lineNum">    1285 </span>            : namespace Frontend {</a>
<a name="1286"><span class="lineNum">    1286 </span>            : namespace Fortran {</a>
<a name="1287"><span class="lineNum">    1287 </span>            : namespace Ofp {</a>
<a name="1288"><span class="lineNum">    1288 </span>            :   extern void jserver_init();</a>
<a name="1289"><span class="lineNum">    1289 </span>            : }// Rose::Frontend::Fortran::Ofp</a>
<a name="1290"><span class="lineNum">    1290 </span>            : }// Rose::Frontend::Fortran</a>
<a name="1291"><span class="lineNum">    1291 </span>            : }// Rose::Frontend</a>
<a name="1292"><span class="lineNum">    1292 </span>            : }// Rose</a>
<a name="1293"><span class="lineNum">    1293 </span>            : #endif</a>
<a name="1294"><span class="lineNum">    1294 </span>            : </a>
<a name="1295"><span class="lineNum">    1295 </span>            : // *****************************************************************************************</a>
<a name="1296"><span class="lineNum">    1296 </span>            : // *****************************************************************************************</a>
<a name="1297"><span class="lineNum">    1297 </span>            : // *****************************************************************************************</a>
<a name="1298"><span class="lineNum">    1298 </span>            : // *********  IMPLEMENTATION OF SAWYER COMMAND LINE SUPPORT FOR ROSE (in progress)  ********</a>
<a name="1299"><span class="lineNum">    1299 </span>            : // *****************************************************************************************</a>
<a name="1300"><span class="lineNum">    1300 </span>            : // *****************************************************************************************</a>
<a name="1301"><span class="lineNum">    1301 </span>            : // *****************************************************************************************</a>
<a name="1302"><span class="lineNum">    1302 </span>            : </a>
<a name="1303"><span class="lineNum">    1303 </span>            : // DQ (4/10/2017): Adding incremental support for ROSE use of Sawyer command line handling to ROSE.</a>
<a name="1304"><span class="lineNum">    1304 </span>            : </a>
<a name="1305"><span class="lineNum">    1305 </span>            : #define ROSE_SAWYER_COMMENT_LINE_DEBUG 0</a>
<a name="1306"><span class="lineNum">    1306 </span>            : </a>
<a name="1307"><span class="lineNum">    1307 </span>            : #if 0</a>
<a name="1308"><span class="lineNum">    1308 </span>            : //! Return a description of the outliner's command-line switches. When these switches are parsed, they will adjust settings</a>
<a name="1309"><span class="lineNum">    1309 </span>            : //  in this @ref Outliner.</a>
<a name="1310"><span class="lineNum">    1310 </span>            : Sawyer::CommandLine::SwitchGroup</a>
<a name="1311"><span class="lineNum">    1311 </span>            : SgProject::commandLineSwitches()</a>
<a name="1312"><span class="lineNum">    1312 </span>            :    {</a>
<a name="1313"><span class="lineNum">    1313 </span>            :      using namespace Sawyer::CommandLine;</a>
<a name="1314"><span class="lineNum">    1314 </span>            : </a>
<a name="1315"><span class="lineNum">    1315 </span>            :      SwitchGroup switches(&quot;ROSE switches&quot;);</a>
<a name="1316"><span class="lineNum">    1316 </span>            :      switches.doc(&quot;These switches control ROSE's frontend. &quot;);</a>
<a name="1317"><span class="lineNum">    1317 </span>            :      switches.name(&quot;rose:frontend&quot;);</a>
<a name="1318"><span class="lineNum">    1318 </span>            : </a>
<a name="1319"><span class="lineNum">    1319 </span>            : #if 0</a>
<a name="1320"><span class="lineNum">    1320 </span>            :   // DQ (4/10/2017): This code serves as examples only at this point.</a>
<a name="1321"><span class="lineNum">    1321 </span>            :      switches.insert(Switch(&quot;xxx_enable_debug&quot;)</a>
<a name="1322"><span class="lineNum">    1322 </span>            :                     .intrinsicValue(true, enable_debug)</a>
<a name="1323"><span class="lineNum">    1323 </span>            :                     .doc(&quot;Enable debugging ode for outlined functions.&quot;));</a>
<a name="1324"><span class="lineNum">    1324 </span>            : </a>
<a name="1325"><span class="lineNum">    1325 </span>            :      switches.insert(Switch(&quot;xxx_preproc-only&quot;)</a>
<a name="1326"><span class="lineNum">    1326 </span>            :                     .intrinsicValue(true, preproc_only_)</a>
<a name="1327"><span class="lineNum">    1327 </span>            :                     .doc(&quot;Enable preprocessing only.&quot;));</a>
<a name="1328"><span class="lineNum">    1328 </span>            : </a>
<a name="1329"><span class="lineNum">    1329 </span>            :      switches.insert(Switch(&quot;xxx_parameter_wrapper&quot;)</a>
<a name="1330"><span class="lineNum">    1330 </span>            :                     .intrinsicValue(true, useParameterWrapper)</a>
<a name="1331"><span class="lineNum">    1331 </span>            :                     .doc(&quot;Enable parameter wrapping.&quot;));</a>
<a name="1332"><span class="lineNum">    1332 </span>            : </a>
<a name="1333"><span class="lineNum">    1333 </span>            :      switches.insert(Switch(&quot;xxx_structure_wrapper&quot;)</a>
<a name="1334"><span class="lineNum">    1334 </span>            :                     .intrinsicValue(true, useStructureWrapper)</a>
<a name="1335"><span class="lineNum">    1335 </span>            :                     .doc(&quot;Enable parameter wrapping using a structure.&quot;));</a>
<a name="1336"><span class="lineNum">    1336 </span>            : </a>
<a name="1337"><span class="lineNum">    1337 </span>            :      switches.insert(Switch(&quot;xxx_new_file&quot;)</a>
<a name="1338"><span class="lineNum">    1338 </span>            :                     .intrinsicValue(true, useNewFile)</a>
<a name="1339"><span class="lineNum">    1339 </span>            :                     .doc(&quot;Enable new source file for outlined functions.&quot;));</a>
<a name="1340"><span class="lineNum">    1340 </span>            : </a>
<a name="1341"><span class="lineNum">    1341 </span>            :      switches.insert(Switch(&quot;xxx_exclude_headers&quot;)</a>
<a name="1342"><span class="lineNum">    1342 </span>            :                     .intrinsicValue(true, exclude_headers)</a>
<a name="1343"><span class="lineNum">    1343 </span>            :                     .doc(&quot;Exclude headers in the new file containing outlined functions.&quot;));</a>
<a name="1344"><span class="lineNum">    1344 </span>            : </a>
<a name="1345"><span class="lineNum">    1345 </span>            :      switches.insert(Switch(&quot;xxx_enable_classic&quot;)</a>
<a name="1346"><span class="lineNum">    1346 </span>            :                     .intrinsicValue(true, enable_classic)</a>
<a name="1347"><span class="lineNum">    1347 </span>            :                     .doc(&quot;Enable a classic way for outlined functions.&quot;));</a>
<a name="1348"><span class="lineNum">    1348 </span>            : </a>
<a name="1349"><span class="lineNum">    1349 </span>            :      switches.insert(Switch(&quot;xxx_temp_variable&quot;)</a>
<a name="1350"><span class="lineNum">    1350 </span>            :                     .intrinsicValue(true, temp_variable)</a>
<a name="1351"><span class="lineNum">    1351 </span>            :                     .doc(&quot;Enable using temp variables to reduce pointer dereferencing for outlined functions.&quot;));</a>
<a name="1352"><span class="lineNum">    1352 </span>            : </a>
<a name="1353"><span class="lineNum">    1353 </span>            :      switches.insert(Switch(&quot;xxx_use_dlopen&quot;)</a>
<a name="1354"><span class="lineNum">    1354 </span>            :                     .intrinsicValue(true, use_dlopen)</a>
<a name="1355"><span class="lineNum">    1355 </span>            :                     .doc(&quot;Use @man{dlopen}(3) to find an outlined function saved into a new source file.&quot;));</a>
<a name="1356"><span class="lineNum">    1356 </span>            : </a>
<a name="1357"><span class="lineNum">    1357 </span>            :      switches.insert(Switch(&quot;xxx_abstract_handle&quot;)</a>
<a name="1358"><span class="lineNum">    1358 </span>            :                     .argument(&quot;handle&quot;, anyParser(handles))</a>
<a name="1359"><span class="lineNum">    1359 </span>            :                     .whichValue(SAVE_ALL)               // if switch appears more than once, save all values not just last</a>
<a name="1360"><span class="lineNum">    1360 </span>            :                     .doc(&quot;Enable using abstract handles to specify targets for outlining.&quot;));</a>
<a name="1361"><span class="lineNum">    1361 </span>            : </a>
<a name="1362"><span class="lineNum">    1362 </span>            :      switches.insert(Switch(&quot;xxx_output_path&quot;)</a>
<a name="1363"><span class="lineNum">    1363 </span>            :                     .argument(&quot;name&quot;, anyParser(output_path))</a>
<a name="1364"><span class="lineNum">    1364 </span>            :                     .doc(&quot;Use a custom output path.&quot;));</a>
<a name="1365"><span class="lineNum">    1365 </span>            : </a>
<a name="1366"><span class="lineNum">    1366 </span>            :      switches.insert(Switch(&quot;xxx_enable_liveness&quot;)</a>
<a name="1367"><span class="lineNum">    1367 </span>            :                     .intrinsicValue(true, enable_liveness)</a>
<a name="1368"><span class="lineNum">    1368 </span>            :                     .doc(&quot;This switch is only honored if @s{temp_variable} was specified.&quot;));</a>
<a name="1369"><span class="lineNum">    1369 </span>            : #endif</a>
<a name="1370"><span class="lineNum">    1370 </span>            : </a>
<a name="1371"><span class="lineNum">    1371 </span>            :      return switches;</a>
<a name="1372"><span class="lineNum">    1372 </span>            :    }</a>
<a name="1373"><span class="lineNum">    1373 </span>            : #endif</a>
<a name="1374"><span class="lineNum">    1374 </span>            : </a>
<a name="1375"><span class="lineNum">    1375 </span>            : </a>
<a name="1376"><span class="lineNum">    1376 </span>            : Sawyer::CommandLine::SwitchGroup</a>
<a name="1377"><span class="lineNum">    1377 </span><span class="lineCov">        355 : SgProject::frontendAllSwitches()</span></a>
<a name="1378"><span class="lineNum">    1378 </span>            :    {</a>
<a name="1379"><span class="lineNum">    1379 </span><span class="lineCov">        355 :      using namespace Sawyer::CommandLine;</span></a>
<a name="1380"><span class="lineNum">    1380 </span>            : </a>
<a name="1381"><span class="lineNum">    1381 </span><span class="lineCov">        710 :      SwitchGroup switches(&quot;ROSE switches&quot;);</span></a>
<a name="1382"><span class="lineNum">    1382 </span><span class="lineCov">        710 :      switches.doc(&quot;These switches control ROSE's frontend. &quot;);</span></a>
<a name="1383"><span class="lineNum">    1383 </span><span class="lineCov">        710 :      switches.name(&quot;rose:frontend&quot;);</span></a>
<a name="1384"><span class="lineNum">    1384 </span>            : </a>
<a name="1385"><span class="lineNum">    1385 </span>            : </a>
<a name="1386"><span class="lineNum">    1386 </span><span class="lineCov">        355 :      return switches;</span></a>
<a name="1387"><span class="lineNum">    1387 </span>            :    }</a>
<a name="1388"><span class="lineNum">    1388 </span>            : </a>
<a name="1389"><span class="lineNum">    1389 </span>            : </a>
<a name="1390"><span class="lineNum">    1390 </span>            : Sawyer::CommandLine::SwitchGroup</a>
<a name="1391"><span class="lineNum">    1391 </span><span class="lineCov">        355 : SgProject::backendAllSwitches()</span></a>
<a name="1392"><span class="lineNum">    1392 </span>            :    {</a>
<a name="1393"><span class="lineNum">    1393 </span><span class="lineCov">        355 :      using namespace Sawyer::CommandLine;</span></a>
<a name="1394"><span class="lineNum">    1394 </span>            : </a>
<a name="1395"><span class="lineNum">    1395 </span><span class="lineCov">        710 :      SwitchGroup switches(&quot;ROSE switches&quot;);</span></a>
<a name="1396"><span class="lineNum">    1396 </span><span class="lineCov">        710 :      switches.doc(&quot;These switches control ROSE's backend. &quot;);</span></a>
<a name="1397"><span class="lineNum">    1397 </span><span class="lineCov">        710 :      switches.name(&quot;rose:backend&quot;);</span></a>
<a name="1398"><span class="lineNum">    1398 </span>            : </a>
<a name="1399"><span class="lineNum">    1399 </span>            : </a>
<a name="1400"><span class="lineNum">    1400 </span><span class="lineCov">        355 :      return switches;</span></a>
<a name="1401"><span class="lineNum">    1401 </span>            :    }</a>
<a name="1402"><span class="lineNum">    1402 </span>            : </a>
<a name="1403"><span class="lineNum">    1403 </span>            : </a>
<a name="1404"><span class="lineNum">    1404 </span>            : </a>
<a name="1405"><span class="lineNum">    1405 </span>            : </a>
<a name="1406"><span class="lineNum">    1406 </span>            : // The &quot;purpose&quot; as it appears in the man page, uncapitalized and a single, short, line.</a>
<a name="1407"><span class="lineNum">    1407 </span>            : static const char *purpose = &quot;This tool provided basic ROSE source-to-source functionality&quot;;</a>
<a name="1408"><span class="lineNum">    1408 </span>            : </a>
<a name="1409"><span class="lineNum">    1409 </span>            : static const char *description =</a>
<a name="1410"><span class="lineNum">    1410 </span>            :     &quot;ROSE is a source-to-source compiler infrastructure for building analysis and/or transformation tools.&quot;</a>
<a name="1411"><span class="lineNum">    1411 </span>            :     &quot;   --- More info can be found at http:www.RoseCompiler.org &quot;;</a>
<a name="1412"><span class="lineNum">    1412 </span>            : </a>
<a name="1413"><span class="lineNum">    1413 </span>            : // DQ (4/10/2017): Not clear if we want to sue this concept of switch setting in ROSE command line handling (implemented as a test).</a>
<a name="1414"><span class="lineNum">    1414 </span>            : // Switches for this tool. Tools with lots of switches will probably want these to be in some Settings struct mirroring the</a>
<a name="1415"><span class="lineNum">    1415 </span>            : // approach used by some analyses that have lots of settings. So we'll do that here too even though it looks funny.</a>
<a name="1416"><span class="lineNum">    1416 </span>            : struct RoseSettings {</a>
<a name="1417"><span class="lineNum">    1417 </span>            :     bool showRoseSettings;         // should we show the outliner settings instead of running it?</a>
<a name="1418"><span class="lineNum">    1418 </span>            :     bool useOldCommandlineParser;  // call the old Outliner command-line parser</a>
<a name="1419"><span class="lineNum">    1419 </span>            : </a>
<a name="1420"><span class="lineNum">    1420 </span>            :     RoseSettings()</a>
<a name="1421"><span class="lineNum">    1421 </span>            :         : showRoseSettings(false), useOldCommandlineParser(false) {}</a>
<a name="1422"><span class="lineNum">    1422 </span>            : } rose_settings;</a>
<a name="1423"><span class="lineNum">    1423 </span>            : </a>
<a name="1424"><span class="lineNum">    1424 </span>            : </a>
<a name="1425"><span class="lineNum">    1425 </span>            : // DQ (4/10/2017): Added commandline support from Saywer (most comments are from Robb's definition of this function for the tutorial/outliner.cc).</a>
<a name="1426"><span class="lineNum">    1426 </span>            : std::vector&lt;std::string&gt;</a>
<a name="1427"><span class="lineNum">    1427 </span><span class="lineCov">        355 : SgProject::parseCommandLine(std::vector&lt;std::string&gt; argv)</span></a>
<a name="1428"><span class="lineNum">    1428 </span>            :    {</a>
<a name="1429"><span class="lineNum">    1429 </span>            :   // Parse the tool's command-line, processing only those switches recognized by Sawyer. Then return the non-parsed switches for</a>
<a name="1430"><span class="lineNum">    1430 </span>            :   // the next stage of parsing. We have three more stages that need to process the command-line: Outliner (the old approach),</a>
<a name="1431"><span class="lineNum">    1431 </span>            :   // frontend(), and the backend compiler. None of these except the backend compiler can issue error messages about misspelled</a>
<a name="1432"><span class="lineNum">    1432 </span>            :   // switches because the first three must assume that an unrecognized switch is intended for a later stage.</a>
<a name="1433"><span class="lineNum">    1433 </span>            : </a>
<a name="1434"><span class="lineNum">    1434 </span><span class="lineCov">        355 :      using namespace Sawyer::CommandLine;</span></a>
<a name="1435"><span class="lineNum">    1435 </span>            : </a>
<a name="1436"><span class="lineNum">    1436 </span><span class="lineCov">        355 :      using namespace Rose;                   // the ROSE team is migrating everything to this namespace</span></a>
<a name="1437"><span class="lineNum">    1437 </span><span class="lineCov">        355 :      using namespace Rose::Diagnostics;      // for mlog, INFO, WARN, ERROR, FATAL, etc.</span></a>
<a name="1438"><span class="lineNum">    1438 </span>            : </a>
<a name="1439"><span class="lineNum">    1439 </span>            :   // Use Rose::CommandLine to create a consistent parser among all tools.  If you want a tool's parser to be different</a>
<a name="1440"><span class="lineNum">    1440 </span>            :   // then either create one yourself, or modify the parser properties after createParser returns. The createEmptyParserStage</a>
<a name="1441"><span class="lineNum">    1441 </span>            :   // creates a parser that assumes all unrecognized switches are intended for a later stage. If there are no later stages</a>
<a name="1442"><span class="lineNum">    1442 </span>            :   // then use createEmptyParser instead or else users will never see error messages for misspelled switches.</a>
<a name="1443"><span class="lineNum">    1443 </span><span class="lineCov">       1065 :      Parser p = Rose::CommandLine::createEmptyParserStage(purpose, description);</span></a>
<a name="1444"><span class="lineNum">    1444 </span><span class="lineCov">        710 :      p.doc(&quot;Synopsis&quot;, &quot;@prop{programName} @v{switches} @v{files}...&quot;);</span></a>
<a name="1445"><span class="lineNum">    1445 </span>            : #if 1</a>
<a name="1446"><span class="lineNum">    1446 </span>            :   // DEBUGGING [Robb P Matzke 2016-09-27]</a>
<a name="1447"><span class="lineNum">    1447 </span><span class="lineCov">        710 :      p.longPrefix(&quot;-&quot;);</span></a>
<a name="1448"><span class="lineNum">    1448 </span>            : #endif</a>
<a name="1449"><span class="lineNum">    1449 </span>            : </a>
<a name="1450"><span class="lineNum">    1450 </span>            :   // User errors (what few will be reported since this is only a first-stage parser) should be sent to standard error instead</a>
<a name="1451"><span class="lineNum">    1451 </span>            :   // of raising an exception.  Programmer errors still cause exceptions.</a>
<a name="1452"><span class="lineNum">    1452 </span><span class="lineCov">        710 :      p.errorStream(SageBuilder::mlog[FATAL]);</span></a>
<a name="1453"><span class="lineNum">    1453 </span>            : </a>
<a name="1454"><span class="lineNum">    1454 </span>            :   // All ROSE tools have some switches in common, such as --version, -V, --help, -h, -?, --log, -L, --threads, etc. We</a>
<a name="1455"><span class="lineNum">    1455 </span>            :   // include them first so they appear near the top of the documentation.  The genericSwitches returns a</a>
<a name="1456"><span class="lineNum">    1456 </span>            :   // Sawyer::CommandLine::SwitchGroup, which this tool could extend by adding additional switches.  This could have been done</a>
<a name="1457"><span class="lineNum">    1457 </span>            :   // inside createParser, but it turns out that many tools like to extend or re-order this group of switches, which is</a>
<a name="1458"><span class="lineNum">    1458 </span>            :   // simpler this way.</a>
<a name="1459"><span class="lineNum">    1459 </span><span class="lineCov">        710 :      p.with(Rose::CommandLine::genericSwitches());</span></a>
<a name="1460"><span class="lineNum">    1460 </span>            : </a>
<a name="1461"><span class="lineNum">    1461 </span>            :   // Eventually, if we change frontend so we can query what switches it knows about, we could insert them into our parser at</a>
<a name="1462"><span class="lineNum">    1462 </span>            :   // this point.  The frontend could report all known switches (sort of how things are organized one) or we could query only</a>
<a name="1463"><span class="lineNum">    1463 </span>            :   // those groups of frontend switches that this tool is interested in (e.g., I don't know if the outliner needs Fortran</a>
<a name="1464"><span class="lineNum">    1464 </span>            :   // switches).</a>
<a name="1465"><span class="lineNum">    1465 </span>            :   // [Robb P Matzke 2016-09-27]</a>
<a name="1466"><span class="lineNum">    1466 </span><span class="lineCov">        710 :      p.with(SgProject::frontendAllSwitches()); // or similar</span></a>
<a name="1467"><span class="lineNum">    1467 </span>            : </a>
<a name="1468"><span class="lineNum">    1468 </span>            :  // DQ (4/10/2017): Added seperate function for backend command line switches.</a>
<a name="1469"><span class="lineNum">    1469 </span><span class="lineCov">        710 :      p.with(SgProject::backendAllSwitches()); // or similar</span></a>
<a name="1470"><span class="lineNum">    1470 </span>            : </a>
<a name="1471"><span class="lineNum">    1471 </span>            : #if 0</a>
<a name="1472"><span class="lineNum">    1472 </span>            :   // These are tool specific switches.</a>
<a name="1473"><span class="lineNum">    1473 </span>            :   // The Outliner has some switches of its own, so include them next.  These switches will automatically adjust the Outliner</a>
<a name="1474"><span class="lineNum">    1474 </span>            :   // settings. Since the outliner is implemented as a namespace rather than a class, it's essentially a singlton.  There can</a>
<a name="1475"><span class="lineNum">    1475 </span>            :   // be only one instance of an outliner per tool, whether the tool uses an outliner directly (like this one) or indirectly</a>
<a name="1476"><span class="lineNum">    1476 </span>            :   // as part of some other analysis.</a>
<a name="1477"><span class="lineNum">    1477 </span>            :      p.with(SgProject::commandLineSwitches());</a>
<a name="1478"><span class="lineNum">    1478 </span>            : #endif</a>
<a name="1479"><span class="lineNum">    1479 </span>            : </a>
<a name="1480"><span class="lineNum">    1480 </span>            :   // Finally, a tool sometimes has its own specific settings, so we demo that here with a couple made-up switches.</a>
<a name="1481"><span class="lineNum">    1481 </span><span class="lineCov">        710 :      SwitchGroup tool(&quot;Tool-specific switches&quot;);</span></a>
<a name="1482"><span class="lineNum">    1482 </span>            : </a>
<a name="1483"><span class="lineNum">    1483 </span><span class="lineCov">        710 :      tool.insert(Switch(&quot;dry-run&quot;, 'n')</span></a>
<a name="1484"><span class="lineNum">    1484 </span><span class="lineCov">        355 :                 .intrinsicValue(true, rose_settings.showRoseSettings)</span></a>
<a name="1485"><span class="lineNum">    1485 </span><span class="lineCov">       1065 :                 .doc(&quot;Instead of running the outliner, just display its settings.&quot;));</span></a>
<a name="1486"><span class="lineNum">    1486 </span>            : </a>
<a name="1487"><span class="lineNum">    1487 </span>            :   // Helper function that adds &quot;--old-outliner&quot; and &quot;--no-old-outliner&quot; to the tool switch group, and causes</a>
<a name="1488"><span class="lineNum">    1488 </span>            :   // settings.useOldParser to be set to true or false. It also appends some additional documentation to say what the default</a>
<a name="1489"><span class="lineNum">    1489 </span>            :   // value is. We could have done this by hand with Sawyer, but having a helper encourages consistency.</a>
<a name="1490"><span class="lineNum">    1490 </span><span class="lineCov">        710 :      Rose::CommandLine::insertBooleanSwitch(tool, &quot;old-commandline-handling&quot;, rose_settings.useOldCommandlineParser,</span></a>
<a name="1491"><span class="lineNum">    1491 </span>            :                                             &quot;Call the old ROSE frontend command line parser in addition to its new Sawyer parser.&quot;);</a>
<a name="1492"><span class="lineNum">    1492 </span>            : </a>
<a name="1493"><span class="lineNum">    1493 </span>            :   // We want the &quot;--rose:help&quot; switch to appear in the Sawyer documentation but we have to pass it to the next stage also. We</a>
<a name="1494"><span class="lineNum">    1494 </span>            :   // could do this two different ways. The older way (that still works) is to have Sawyer process the switch and then we</a>
<a name="1495"><span class="lineNum">    1495 </span>            :   // prepend it into the returned vector for processing by later stages.  The newer way is to set the switch's &quot;skipping&quot;</a>
<a name="1496"><span class="lineNum">    1496 </span>            :   // property that causes Sawyer to treat it as a skipped (unrecognized) switch.  We'll use SKIP_STRONG, but SKIP_WEAK is</a>
<a name="1497"><span class="lineNum">    1497 </span>            :   // sort of a cross between Sawyer recognizing it and not recognizing it.</a>
<a name="1498"><span class="lineNum">    1498 </span><span class="lineCov">        710 :      tool.insert(Switch(&quot;rose:help&quot;)</span></a>
<a name="1499"><span class="lineNum">    1499 </span><span class="lineCov">        355 :                 .skipping(SKIP_STRONG)                  // appears in documentation and is parsed, but treated as skipped</span></a>
<a name="1500"><span class="lineNum">    1500 </span><span class="lineCov">       1065 :                 .doc(&quot;Show the non-Sawyer switch documentation.&quot;));</span></a>
<a name="1501"><span class="lineNum">    1501 </span>            : </a>
<a name="1502"><span class="lineNum">    1502 </span>            : #if 0</a>
<a name="1503"><span class="lineNum">    1503 </span>            :   // DQ (4/10/2017): This is tool specific and should not be a part of the more general ROSE infrastructure support.</a>
<a name="1504"><span class="lineNum">    1504 </span>            :   // Copy this tool's switches into the parser.</a>
<a name="1505"><span class="lineNum">    1505 </span>            :      p.with(tool);</a>
<a name="1506"><span class="lineNum">    1506 </span>            : #endif</a>
<a name="1507"><span class="lineNum">    1507 </span>            : </a>
<a name="1508"><span class="lineNum">    1508 </span>            :   // Parse the command-line, stopping at the first &quot;--&quot; or positional arugment. Return the unparsed stuff so it can be passed</a>
<a name="1509"><span class="lineNum">    1509 </span>            :   // to the next stage.  ROSE's frontend expects arg[0] to be the name of the command, which Sawyer has already processed, so</a>
<a name="1510"><span class="lineNum">    1510 </span>            :   // we need to add it back again.</a>
<a name="1511"><span class="lineNum">    1511 </span>            : </a>
<a name="1512"><span class="lineNum">    1512 </span>            :   // DQ (4/10/2017): Note that we do NOT call the apply function to define an non-destructive first use of Saywer in ROSE command line handling.</a>
<a name="1513"><span class="lineNum">    1513 </span>            :   // std::vector&lt;std::string&gt; remainingArgs = p.parse(argc, argv).apply().unparsedArgs(true);</a>
<a name="1514"><span class="lineNum">    1514 </span><span class="lineCov">        355 :      std::vector&lt;std::string&gt; remainingArgs = p.parse(argv).unparsedArgs(true);</span></a>
<a name="1515"><span class="lineNum">    1515 </span>            : </a>
<a name="1516"><span class="lineNum">    1516 </span>            :   // remainingArgs.insert(remainingArgs.begin(), argv[0]);</a>
<a name="1517"><span class="lineNum">    1517 </span>            : </a>
<a name="1518"><span class="lineNum">    1518 </span>            : #if ROSE_SAWYER_COMMENT_LINE_DEBUG</a>
<a name="1519"><span class="lineNum">    1519 </span>            :   // DEBUGGING [Robb P Matzke 2016-09-27]</a>
<a name="1520"><span class="lineNum">    1520 </span>            :      std::cerr &lt;&lt;&quot;These are the arguments left over after parsing with Sawyer:\n&quot;;</a>
<a name="1521"><span class="lineNum">    1521 </span>            :      BOOST_FOREACH (const std::string &amp;s, remainingArgs)</a>
<a name="1522"><span class="lineNum">    1522 </span>            :          std::cerr &lt;&lt;&quot;    \&quot;&quot; &lt;&lt;s &lt;&lt;&quot;\&quot;\n&quot;;</a>
<a name="1523"><span class="lineNum">    1523 </span>            : #endif</a>
<a name="1524"><span class="lineNum">    1524 </span>            : </a>
<a name="1525"><span class="lineNum">    1525 </span><span class="lineCov">        710 :      return remainingArgs;</span></a>
<a name="1526"><span class="lineNum">    1526 </span>            :    }</a>
<a name="1527"><span class="lineNum">    1527 </span>            : </a>
<a name="1528"><span class="lineNum">    1528 </span>            : </a>
<a name="1529"><span class="lineNum">    1529 </span>            : //! internal function to invoke the EDG frontend and generate the AST</a>
<a name="1530"><span class="lineNum">    1530 </span>            : int</a>
<a name="1531"><span class="lineNum">    1531 </span><span class="lineCov">        355 : SgProject::parse(const vector&lt;string&gt;&amp; argv)</span></a>
<a name="1532"><span class="lineNum">    1532 </span>            :    {</a>
<a name="1533"><span class="lineNum">    1533 </span>            :   // Not sure that if we are just linking that we should call a function called &quot;parse()&quot;!!!</a>
<a name="1534"><span class="lineNum">    1534 </span>            : </a>
<a name="1535"><span class="lineNum">    1535 </span>            :   // DQ (7/6/2005): Introduce tracking of performance of ROSE.</a>
<a name="1536"><span class="lineNum">    1536 </span><span class="lineCov">        709 :      TimingPerformance timer (&quot;AST (SgProject::parse(argc,argv)):&quot;);</span></a>
<a name="1537"><span class="lineNum">    1537 </span>            : </a>
<a name="1538"><span class="lineNum">    1538 </span>            :   // DQ (4/10/2017): Experiment with Saywer for comment line parsing.</a>
<a name="1539"><span class="lineNum">    1539 </span>            :   // Parse Sawyer-recognized switches and the rest we'll pass to Outliner and frontend like before.</a>
<a name="1540"><span class="lineNum">    1540 </span><span class="lineCov">        355 :      std::vector&lt;std::string&gt; sawyer_args = parseCommandLine(argv);</span></a>
<a name="1541"><span class="lineNum">    1541 </span>            : </a>
<a name="1542"><span class="lineNum">    1542 </span>            : #if 0</a>
<a name="1543"><span class="lineNum">    1543 </span>            :   // Unclear if we want to use this feature of Sawyer.</a>
<a name="1544"><span class="lineNum">    1544 </span>            :      if (rose_settings.useOldCommandlineParser)</a>
<a name="1545"><span class="lineNum">    1545 </span>            :         {</a>
<a name="1546"><span class="lineNum">    1546 </span>            :        // Example of usage from outliner.</a>
<a name="1547"><span class="lineNum">    1547 </span>            :        // Outliner::commandLineProcessing(args);  // this is the old way</a>
<a name="1548"><span class="lineNum">    1548 </span>            : </a>
<a name="1549"><span class="lineNum">    1549 </span>            :           printf (&quot;In SgProject::parse(): Permit optional command line handling using the older approach (not supported) \n&quot;);</a>
<a name="1550"><span class="lineNum">    1550 </span>            :         }</a>
<a name="1551"><span class="lineNum">    1551 </span>            : #endif</a>
<a name="1552"><span class="lineNum">    1552 </span>            : </a>
<a name="1553"><span class="lineNum">    1553 </span>            :   // TOO1 (2014/01/22): TODO: Consider moving CLI processing out of SgProject</a>
<a name="1554"><span class="lineNum">    1554 </span>            :   // constructor. We can't set any error codes on SgProject since SgProject::parse</a>
<a name="1555"><span class="lineNum">    1555 </span>            :   // is being called from the SgProject::SgProject constructor, meaning the SgProject</a>
<a name="1556"><span class="lineNum">    1556 </span>            :   // object is not properly constructed yet.. The only thing we can do, then, if</a>
<a name="1557"><span class="lineNum">    1557 </span>            :   // there is an error here in the commandline handling, is to halt the program.</a>
<a name="1558"><span class="lineNum">    1558 </span><span class="lineCov">        355 :      if (KEEP_GOING_CAUGHT_COMMANDLINE_SIGNAL)</span></a>
<a name="1559"><span class="lineNum">    1559 </span>            :        {</a>
<a name="1560"><span class="lineNum">    1560 </span><span class="lineNoCov">          0 :           std::cout</span></a>
<a name="1561"><span class="lineNum">    1561 </span>            :             &lt;&lt; &quot;[FATAL] &quot;</a>
<a name="1562"><span class="lineNum">    1562 </span><span class="lineNoCov">          0 :             &lt;&lt; &quot;Unrecoverable signal generated during commandline processing&quot;</span></a>
<a name="1563"><span class="lineNum">    1563 </span><span class="lineNoCov">          0 :             &lt;&lt; std::endl;</span></a>
<a name="1564"><span class="lineNum">    1564 </span><span class="lineNoCov">          0 :           exit(1);</span></a>
<a name="1565"><span class="lineNum">    1565 </span>            :         }</a>
<a name="1566"><span class="lineNum">    1566 </span>            :        else</a>
<a name="1567"><span class="lineNum">    1567 </span>            :         {</a>
<a name="1568"><span class="lineNum">    1568 </span>            :        // builds file list (or none if this is a link line)</a>
<a name="1569"><span class="lineNum">    1569 </span><span class="lineCov">        355 :           processCommandLine(argv);</span></a>
<a name="1570"><span class="lineNum">    1570 </span>            :         }</a>
<a name="1571"><span class="lineNum">    1571 </span>            : </a>
<a name="1572"><span class="lineNum">    1572 </span><span class="lineCov">        354 :      int errorCode = 0;</span></a>
<a name="1573"><span class="lineNum">    1573 </span>            : </a>
<a name="1574"><span class="lineNum">    1574 </span>            :             // Normal case without AST Merge: Compiling ...</a>
<a name="1575"><span class="lineNum">    1575 </span>            :             // printf (&quot;In SgProject::parse(const vector&lt;string&gt;&amp; argv): get_sourceFileNameList().size() = %&quot; PRIuPTR &quot; \n&quot;,get_sourceFileNameList().size());</a>
<a name="1576"><span class="lineNum">    1576 </span><span class="lineCov">        354 :                if (get_sourceFileNameList().size() &gt; 0)</span></a>
<a name="1577"><span class="lineNum">    1577 </span>            :                   {</a>
<a name="1578"><span class="lineNum">    1578 </span>            : </a>
<a name="1579"><span class="lineNum">    1579 </span>            : #ifdef ROSE_BUILD_FORTRAN_LANGUAGE_SUPPORT</a>
<a name="1580"><span class="lineNum">    1580 </span>            : </a>
<a name="1581"><span class="lineNum">    1581 </span>            :                     //Rose::Frontend::Fortran::Ofp::jserver_init(); //jserver_init is not defined since it does not need, thus of this call.</a>
<a name="1582"><span class="lineNum">    1582 </span>            :                     //Rose::Frontend::Java::Ecj::jserver_init();</a>
<a name="1583"><span class="lineNum">    1583 </span>            : #endif</a>
<a name="1584"><span class="lineNum">    1584 </span><span class="lineCov">        352 :                     errorCode = parse();</span></a>
<a name="1585"><span class="lineNum">    1585 </span>            :                   }</a>
<a name="1586"><span class="lineNum">    1586 </span>            : </a>
<a name="1587"><span class="lineNum">    1587 </span>            : #if 1</a>
<a name="1588"><span class="lineNum">    1588 </span>            :   // DQ (8/22/2009): We test the parent of SgFunctionTypeTable in the AST post processing,</a>
<a name="1589"><span class="lineNum">    1589 </span>            :   // so we need to make sure that it is set.</a>
<a name="1590"><span class="lineNum">    1590 </span><span class="lineCov">        354 :      SgFunctionTypeTable* functionTypeTable = SgNode::get_globalFunctionTypeTable();</span></a>
<a name="1591"><span class="lineNum">    1591 </span><span class="lineCov">        354 :      ASSERT_not_null(functionTypeTable);</span></a>
<a name="1592"><span class="lineNum">    1592 </span><span class="lineCov">        354 :      if (functionTypeTable-&gt;get_parent() == nullptr)</span></a>
<a name="1593"><span class="lineNum">    1593 </span>            :         {</a>
<a name="1594"><span class="lineNum">    1594 </span>            : #if 0</a>
<a name="1595"><span class="lineNum">    1595 </span>            :           printf (&quot;This (globalFunctionTypeTable) should have been set to point to the SgProject not the SgFile \n&quot;);</a>
<a name="1596"><span class="lineNum">    1596 </span>            :           ROSE_ABORT();</a>
<a name="1597"><span class="lineNum">    1597 </span>            : #endif</a>
<a name="1598"><span class="lineNum">    1598 </span>            :        // ROSE_ASSERT(numberOfFiles() &gt; 0);</a>
<a name="1599"><span class="lineNum">    1599 </span>            :        // printf (&quot;Inside of SgProject::parse(const vector&lt;string&gt;&amp; argv): set the parent of SgFunctionTypeTable \n&quot;);</a>
<a name="1600"><span class="lineNum">    1600 </span><span class="lineCov">          2 :           if (numberOfFiles() &gt; 0)</span></a>
<a name="1601"><span class="lineNum">    1601 </span><span class="lineNoCov">          0 :                functionTypeTable-&gt;set_parent(&amp;(get_file(0)));</span></a>
<a name="1602"><span class="lineNum">    1602 </span>            :             else</a>
<a name="1603"><span class="lineNum">    1603 </span><span class="lineCov">          2 :                functionTypeTable-&gt;set_parent(this);</span></a>
<a name="1604"><span class="lineNum">    1604 </span>            :         }</a>
<a name="1605"><span class="lineNum">    1605 </span><span class="lineCov">        354 :      ROSE_ASSERT(functionTypeTable-&gt;get_parent() != NULL);</span></a>
<a name="1606"><span class="lineNum">    1606 </span>            : </a>
<a name="1607"><span class="lineNum">    1607 </span><span class="lineCov">        354 :      ROSE_ASSERT(SgNode::get_globalFunctionTypeTable() != NULL);</span></a>
<a name="1608"><span class="lineNum">    1608 </span><span class="lineCov">        354 :      ROSE_ASSERT(SgNode::get_globalFunctionTypeTable()-&gt;get_parent() != NULL);</span></a>
<a name="1609"><span class="lineNum">    1609 </span>            : #endif</a>
<a name="1610"><span class="lineNum">    1610 </span>            : </a>
<a name="1611"><span class="lineNum">    1611 </span>            : #if 1</a>
<a name="1612"><span class="lineNum">    1612 </span>            :   // DQ (7/25/2010): We test the parent of SgTypeTable in the AST post processing,</a>
<a name="1613"><span class="lineNum">    1613 </span>            :   // so we need to make sure that it is set.</a>
<a name="1614"><span class="lineNum">    1614 </span><span class="lineCov">        354 :      SgTypeTable* typeTable = SgNode::get_globalTypeTable();</span></a>
<a name="1615"><span class="lineNum">    1615 </span><span class="lineCov">        354 :      ASSERT_not_null(typeTable);</span></a>
<a name="1616"><span class="lineNum">    1616 </span><span class="lineCov">        354 :      if (typeTable-&gt;get_parent() == nullptr)</span></a>
<a name="1617"><span class="lineNum">    1617 </span>            :         {</a>
<a name="1618"><span class="lineNum">    1618 </span>            : #if 0</a>
<a name="1619"><span class="lineNum">    1619 </span>            :           printf (&quot;This (globalTypeTable) should have been set to point to the SgProject not the SgFile \n&quot;);</a>
<a name="1620"><span class="lineNum">    1620 </span>            :           ROSE_ABORT();</a>
<a name="1621"><span class="lineNum">    1621 </span>            : #endif</a>
<a name="1622"><span class="lineNum">    1622 </span>            :        // ROSE_ASSERT(numberOfFiles() &gt; 0);</a>
<a name="1623"><span class="lineNum">    1623 </span>            :        // printf (&quot;Inside of SgProject::parse(const vector&lt;string&gt;&amp; argv): set the parent of SgTypeTable \n&quot;);</a>
<a name="1624"><span class="lineNum">    1624 </span><span class="lineCov">          2 :           if (numberOfFiles() &gt; 0)</span></a>
<a name="1625"><span class="lineNum">    1625 </span><span class="lineNoCov">          0 :                typeTable-&gt;set_parent(&amp;(get_file(0)));</span></a>
<a name="1626"><span class="lineNum">    1626 </span>            :             else</a>
<a name="1627"><span class="lineNum">    1627 </span><span class="lineCov">          2 :                typeTable-&gt;set_parent(this);</span></a>
<a name="1628"><span class="lineNum">    1628 </span>            :         }</a>
<a name="1629"><span class="lineNum">    1629 </span><span class="lineCov">        354 :      ASSERT_not_null(typeTable-&gt;get_parent());</span></a>
<a name="1630"><span class="lineNum">    1630 </span>            : </a>
<a name="1631"><span class="lineNum">    1631 </span>            :   // DQ (7/30/2010): This test fails in tests/nonsmoke/functional/CompilerOptionsTests/testCpreprocessorOption</a>
<a name="1632"><span class="lineNum">    1632 </span>            :   // DQ (7/25/2010): Added new test.</a>
<a name="1633"><span class="lineNum">    1633 </span>            :   // printf (&quot;typeTable-&gt;get_parent()-&gt;class_name() = %s \n&quot;,typeTable-&gt;get_parent()-&gt;class_name().c_str());</a>
<a name="1634"><span class="lineNum">    1634 </span>            :   // ROSE_ASSERT(isSgProject(typeTable-&gt;get_parent()) != NULL);</a>
<a name="1635"><span class="lineNum">    1635 </span>            : </a>
<a name="1636"><span class="lineNum">    1636 </span><span class="lineCov">        354 :      ROSE_ASSERT(SgNode::get_globalTypeTable() != NULL);</span></a>
<a name="1637"><span class="lineNum">    1637 </span><span class="lineCov">        354 :      ROSE_ASSERT(SgNode::get_globalTypeTable()-&gt;get_parent() != NULL);</span></a>
<a name="1638"><span class="lineNum">    1638 </span>            : #endif</a>
<a name="1639"><span class="lineNum">    1639 </span>            : </a>
<a name="1640"><span class="lineNum">    1640 </span><span class="lineCov">        708 :      return errorCode;</span></a>
<a name="1641"><span class="lineNum">    1641 </span>            :    }</a>
<a name="1642"><span class="lineNum">    1642 </span>            : </a>
<a name="1643"><span class="lineNum">    1643 </span>            : </a>
<a name="1644"><span class="lineNum">    1644 </span><span class="lineCov">        357 : SgSourceFile::SgSourceFile ( vector&lt;string&gt; &amp; argv , SgProject* project )</span></a>
<a name="1645"><span class="lineNum">    1645 </span>            : // : SgFile (argv,errorCode,fileNameIndex,project)</a>
<a name="1646"><span class="lineNum">    1646 </span>            :    {</a>
<a name="1647"><span class="lineNum">    1647 </span>            :   // printf (&quot;In the SgSourceFile constructor \n&quot;);</a>
<a name="1648"><span class="lineNum">    1648 </span>            : </a>
<a name="1649"><span class="lineNum">    1649 </span>            :      //this-&gt;p_package = NULL;</a>
<a name="1650"><span class="lineNum">    1650 </span>            :      //this-&gt;p_import_list = NULL;</a>
<a name="1651"><span class="lineNum">    1651 </span>            :      //this-&gt;p_class_list = NULL;</a>
<a name="1652"><span class="lineNum">    1652 </span><span class="lineCov">        357 :      this-&gt;p_associated_include_file = nullptr;</span></a>
<a name="1653"><span class="lineNum">    1653 </span><span class="lineCov">        357 :      this-&gt;p_headerFileReport = nullptr;</span></a>
<a name="1654"><span class="lineNum">    1654 </span><span class="lineCov">        357 :      this-&gt;p_processedToIncludeCppDirectivesAndComments = false;</span></a>
<a name="1655"><span class="lineNum">    1655 </span><span class="lineCov">        357 :      this-&gt;p_isHeaderFile = false;</span></a>
<a name="1656"><span class="lineNum">    1656 </span>            : </a>
<a name="1657"><span class="lineNum">    1657 </span><span class="lineCov">        357 :      set_globalScope(nullptr);</span></a>
<a name="1658"><span class="lineNum">    1658 </span>            : </a>
<a name="1659"><span class="lineNum">    1659 </span>            :   // DQ (6/15/2011): Added scope to hold unhandled declarations (see test2011_80.C).</a>
<a name="1660"><span class="lineNum">    1660 </span><span class="lineCov">        357 :      set_temp_holding_scope(nullptr);</span></a>
<a name="1661"><span class="lineNum">    1661 </span>            : </a>
<a name="1662"><span class="lineNum">    1662 </span>            :   // This constructor actually makes the call to EDG/OFP/ECJ to build the AST (via callFrontEnd()).</a>
<a name="1663"><span class="lineNum">    1663 </span>            :   // printf (&quot;In SgSourceFile::SgSourceFile(): Calling doSetupForConstructor() \n&quot;);</a>
<a name="1664"><span class="lineNum">    1664 </span><span class="lineCov">        357 :      doSetupForConstructor(argv,  project);</span></a>
<a name="1665"><span class="lineNum">    1665 </span><span class="lineCov">        357 :     }</span></a>
<a name="1666"><span class="lineNum">    1666 </span>            : </a>
<a name="1667"><span class="lineNum">    1667 </span>            : int</a>
<a name="1668"><span class="lineNum">    1668 </span><span class="lineCov">        357 : SgSourceFile::callFrontEnd()</span></a>
<a name="1669"><span class="lineNum">    1669 </span>            :    {</a>
<a name="1670"><span class="lineNum">    1670 </span><span class="lineCov">        357 :      int frontendErrorLevel = SgFile::callFrontEnd();</span></a>
<a name="1671"><span class="lineNum">    1671 </span>            :   // DQ (1/21/2008): This must be set for all languages</a>
<a name="1672"><span class="lineNum">    1672 </span><span class="lineCov">        357 :      ASSERT_not_null(get_globalScope());</span></a>
<a name="1673"><span class="lineNum">    1673 </span><span class="lineCov">        357 :      ASSERT_not_null(get_globalScope()-&gt;get_file_info());</span></a>
<a name="1674"><span class="lineNum">    1674 </span><span class="lineCov">        357 :      ROSE_ASSERT(get_globalScope()-&gt;get_file_info()-&gt;get_filenameString().empty() == false);</span></a>
<a name="1675"><span class="lineNum">    1675 </span>            :   // printf (&quot;p_root-&gt;get_file_info()-&gt;get_filenameString() = %s \n&quot;,p_root-&gt;get_file_info()-&gt;get_filenameString().c_str());</a>
<a name="1676"><span class="lineNum">    1676 </span>            : </a>
<a name="1677"><span class="lineNum">    1677 </span>            :   // DQ (8/21/2008): Added assertion.</a>
<a name="1678"><span class="lineNum">    1678 </span><span class="lineCov">        357 :      ASSERT_not_null (get_globalScope()-&gt;get_startOfConstruct());</span></a>
<a name="1679"><span class="lineNum">    1679 </span><span class="lineCov">        357 :      ASSERT_not_null (get_globalScope()-&gt;get_endOfConstruct()  );</span></a>
<a name="1680"><span class="lineNum">    1680 </span>            : </a>
<a name="1681"><span class="lineNum">    1681 </span><span class="lineCov">        357 :      return frontendErrorLevel;</span></a>
<a name="1682"><span class="lineNum">    1682 </span>            :    }</a>
<a name="1683"><span class="lineNum">    1683 </span>            : </a>
<a name="1684"><span class="lineNum">    1684 </span>            : int</a>
<a name="1685"><span class="lineNum">    1685 </span><span class="lineNoCov">          0 : SgUnknownFile::callFrontEnd()</span></a>
<a name="1686"><span class="lineNum">    1686 </span>            :    {</a>
<a name="1687"><span class="lineNum">    1687 </span>            :   // DQ (2/3/2009): This function is defined, but should never be called.</a>
<a name="1688"><span class="lineNum">    1688 </span><span class="lineNoCov">          0 :      printf (&quot;Error: calling SgUnknownFile::callFrontEnd() \n&quot;);</span></a>
<a name="1689"><span class="lineNum">    1689 </span><span class="lineNoCov">          0 :      ROSE_ABORT();</span></a>
<a name="1690"><span class="lineNum">    1690 </span>            :    }</a>
<a name="1691"><span class="lineNum">    1691 </span>            : </a>
<a name="1692"><span class="lineNum">    1692 </span>            : int</a>
<a name="1693"><span class="lineNum">    1693 </span><span class="lineCov">        352 : SgProject::RunFrontend()</span></a>
<a name="1694"><span class="lineNum">    1694 </span>            : {</a>
<a name="1695"><span class="lineNum">    1695 </span><span class="lineCov">        352 :   TimingPerformance timer (&quot;AST (SgProject::RunFrontend()):&quot;);</span></a>
<a name="1696"><span class="lineNum">    1696 </span>            : </a>
<a name="1697"><span class="lineNum">    1697 </span><span class="lineCov">        352 :      ASSERT_not_null(this);</span></a>
<a name="1698"><span class="lineNum">    1698 </span>            : </a>
<a name="1699"><span class="lineNum">    1699 </span><span class="lineCov">        352 :   int status_of_function = 0;</span></a>
<a name="1700"><span class="lineNum">    1700 </span><span class="lineCov">        352 :   {</span></a>
<a name="1701"><span class="lineNum">    1701 </span><span class="lineCov">        352 :       status_of_function = Rose::Frontend::Run(this);</span></a>
<a name="1702"><span class="lineNum">    1702 </span><span class="lineCov">        352 :       this-&gt;set_frontendErrorCode(status_of_function);</span></a>
<a name="1703"><span class="lineNum">    1703 </span>            :   }</a>
<a name="1704"><span class="lineNum">    1704 </span>            : </a>
<a name="1705"><span class="lineNum">    1705 </span><span class="lineCov">        352 :   return status_of_function;</span></a>
<a name="1706"><span class="lineNum">    1706 </span>            : }//SgProject::RunFrontend</a>
<a name="1707"><span class="lineNum">    1707 </span>            : </a>
<a name="1708"><span class="lineNum">    1708 </span>            : </a>
<a name="1709"><span class="lineNum">    1709 </span>            : #if 0</a>
<a name="1710"><span class="lineNum">    1710 </span>            : // DQ (12/22/2019): unprde4red_map is not directly available in older compilers used for testing ROSE within Jenkins.</a>
<a name="1711"><span class="lineNum">    1711 </span>            : // DQ (12/21/2019): Support for intersection of multiple sets.</a>
<a name="1712"><span class="lineNum">    1712 </span>            : // unordered_map&lt;int,SgNode*&gt; umap;</a>
<a name="1713"><span class="lineNum">    1713 </span>            : void compute_IR_node_pointers ( SgSourceFile* sourceFile, unordered_map &lt; SgNode*, set &lt;int&gt; &gt; &amp; umap )</a>
<a name="1714"><span class="lineNum">    1714 </span>            :    {</a>
<a name="1715"><span class="lineNum">    1715 </span>            :   // This function traverses each translation unit (called for each one) and traverses the associated AST</a>
<a name="1716"><span class="lineNum">    1716 </span>            :   // and adds each IR node to the hash table or addes to the set of file IDs over which the IR node is</a>
<a name="1717"><span class="lineNum">    1717 </span>            :   // shared if it is shared.  The complexity should be in the number of IR nodes over all of the ASTs of</a>
<a name="1718"><span class="lineNum">    1718 </span>            :   // the translation units (shared nodes count the number of times that they are shared).</a>
<a name="1719"><span class="lineNum">    1719 </span>            : </a>
<a name="1720"><span class="lineNum">    1720 </span>            :      class Visitor: public AstSimpleProcessing</a>
<a name="1721"><span class="lineNum">    1721 </span>            :         {</a>
<a name="1722"><span class="lineNum">    1722 </span>            :           public:</a>
<a name="1723"><span class="lineNum">    1723 </span>            :                SgSourceFile* sourceFile;</a>
<a name="1724"><span class="lineNum">    1724 </span>            :                unordered_map &lt; SgNode*, set &lt;int&gt; &gt; &amp; local_umap;</a>
<a name="1725"><span class="lineNum">    1725 </span>            : </a>
<a name="1726"><span class="lineNum">    1726 </span>            :                Visitor(SgSourceFile* tmp_sourceFile, unordered_map &lt; SgNode*, set &lt;int&gt; &gt; &amp; tmp_umap)</a>
<a name="1727"><span class="lineNum">    1727 </span>            :                   : sourceFile(tmp_sourceFile), local_umap(tmp_umap)</a>
<a name="1728"><span class="lineNum">    1728 </span>            :                   {</a>
<a name="1729"><span class="lineNum">    1729 </span>            :                   }</a>
<a name="1730"><span class="lineNum">    1730 </span>            : </a>
<a name="1731"><span class="lineNum">    1731 </span>            :                void visit(SgNode* n)</a>
<a name="1732"><span class="lineNum">    1732 </span>            :                   {</a>
<a name="1733"><span class="lineNum">    1733 </span>            :                     ASSERT_not_null(n);</a>
<a name="1734"><span class="lineNum">    1734 </span>            : #if 0</a>
<a name="1735"><span class="lineNum">    1735 </span>            :                     printf (&quot;n = %p = %s \n&quot;,n,n-&gt;class_name().c_str());</a>
<a name="1736"><span class="lineNum">    1736 </span>            : #endif</a>
<a name="1737"><span class="lineNum">    1737 </span>            :                     SgLocatedNode* locatedNode = isSgLocatedNode(n);</a>
<a name="1738"><span class="lineNum">    1738 </span>            :                     if (locatedNode != nullptr)</a>
<a name="1739"><span class="lineNum">    1739 </span>            :                        {</a>
<a name="1740"><span class="lineNum">    1740 </span>            :                       // int file_id = locatedNode-&gt;get_file_info()-&gt;get_file_id();</a>
<a name="1741"><span class="lineNum">    1741 </span>            :                          int file_id = sourceFile-&gt;get_startOfConstruct()-&gt;get_file_id();</a>
<a name="1742"><span class="lineNum">    1742 </span>            : #if 0</a>
<a name="1743"><span class="lineNum">    1743 </span>            :                          printf (&quot;file_id = %d \n&quot;,file_id);</a>
<a name="1744"><span class="lineNum">    1744 </span>            : #endif</a>
<a name="1745"><span class="lineNum">    1745 </span>            :                          bool isInHashTable = (local_umap.find(n) != local_umap.end());</a>
<a name="1746"><span class="lineNum">    1746 </span>            : #if 1</a>
<a name="1747"><span class="lineNum">    1747 </span>            :                          if (isInHashTable == true)</a>
<a name="1748"><span class="lineNum">    1748 </span>            :                             {</a>
<a name="1749"><span class="lineNum">    1749 </span>            :                               printf (&quot;n = %p = %s \n&quot;,n,n-&gt;class_name().c_str());</a>
<a name="1750"><span class="lineNum">    1750 </span>            :                               printf (&quot;file_id = %d \n&quot;,file_id);</a>
<a name="1751"><span class="lineNum">    1751 </span>            :                               printf (&quot;(local_umap.find(n) == local_umap.end()) = %s \n&quot;,(local_umap.find(n) == local_umap.end()) ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="1752"><span class="lineNum">    1752 </span>            :                             }</a>
<a name="1753"><span class="lineNum">    1753 </span>            : #endif</a>
<a name="1754"><span class="lineNum">    1754 </span>            :                          local_umap[n].insert(file_id);</a>
<a name="1755"><span class="lineNum">    1755 </span>            : </a>
<a name="1756"><span class="lineNum">    1756 </span>            : #if 1</a>
<a name="1757"><span class="lineNum">    1757 </span>            :                          printf (&quot;local_umap[n].size() = %zu \n&quot;,local_umap[n].size());</a>
<a name="1758"><span class="lineNum">    1758 </span>            : #endif</a>
<a name="1759"><span class="lineNum">    1759 </span>            :                          ROSE_ASSERT(local_umap[n].size() &gt;= 1);</a>
<a name="1760"><span class="lineNum">    1760 </span>            : </a>
<a name="1761"><span class="lineNum">    1761 </span>            :                          if (isInHashTable == true)</a>
<a name="1762"><span class="lineNum">    1762 </span>            :                             {</a>
<a name="1763"><span class="lineNum">    1763 </span>            :                            // We can now mark the IR node as shared.</a>
<a name="1764"><span class="lineNum">    1764 </span>            : #if 1</a>
<a name="1765"><span class="lineNum">    1765 </span>            :                               printf (&quot;Need function to support this at the SgLocatedNode level... (and for operators in expressions) \n&quot;);</a>
<a name="1766"><span class="lineNum">    1766 </span>            : #endif</a>
<a name="1767"><span class="lineNum">    1767 </span>            :                            // locatedNode-&gt;get_startOfConstruct()-&gt;setShared();</a>
<a name="1768"><span class="lineNum">    1768 </span>            :                            // locatedNode-&gt;get_endOfConstruct()-&gt;setShared();</a>
<a name="1769"><span class="lineNum">    1769 </span>            :                               locatedNode-&gt;setShared();</a>
<a name="1770"><span class="lineNum">    1770 </span>            : </a>
<a name="1771"><span class="lineNum">    1771 </span>            :                            // Fill in the set of file id's where this node is shared.</a>
<a name="1772"><span class="lineNum">    1772 </span>            : #if 1</a>
<a name="1773"><span class="lineNum">    1773 </span>            :                               set&lt;int&gt; &amp; s = local_umap[n];</a>
<a name="1774"><span class="lineNum">    1774 </span>            :                               set&lt;int&gt;::iterator i = s.begin();</a>
<a name="1775"><span class="lineNum">    1775 </span>            :                               printf (&quot;umap[n=%p=%s]: \n&quot;,n,n-&gt;class_name().c_str());</a>
<a name="1776"><span class="lineNum">    1776 </span>            :                               while (i != s.end())</a>
<a name="1777"><span class="lineNum">    1777 </span>            :                                  {</a>
<a name="1778"><span class="lineNum">    1778 </span>            :                                    int entry = *i;</a>
<a name="1779"><span class="lineNum">    1779 </span>            :                                    printf (&quot; %d&quot;,entry);</a>
<a name="1780"><span class="lineNum">    1780 </span>            : </a>
<a name="1781"><span class="lineNum">    1781 </span>            :                                    i++;</a>
<a name="1782"><span class="lineNum">    1782 </span>            :                                  }</a>
<a name="1783"><span class="lineNum">    1783 </span>            :                               printf (&quot;\n&quot;);</a>
<a name="1784"><span class="lineNum">    1784 </span>            : #endif</a>
<a name="1785"><span class="lineNum">    1785 </span>            :                             }</a>
<a name="1786"><span class="lineNum">    1786 </span>            :                        }</a>
<a name="1787"><span class="lineNum">    1787 </span>            :                   }</a>
<a name="1788"><span class="lineNum">    1788 </span>            :         };</a>
<a name="1789"><span class="lineNum">    1789 </span>            : </a>
<a name="1790"><span class="lineNum">    1790 </span>            :      printf (&quot;In compute_IR_node_pointers(): umap.size() = %zu \n&quot;,umap.size());</a>
<a name="1791"><span class="lineNum">    1791 </span>            : </a>
<a name="1792"><span class="lineNum">    1792 </span>            :      Visitor traversal(sourceFile,umap);</a>
<a name="1793"><span class="lineNum">    1793 </span>            : </a>
<a name="1794"><span class="lineNum">    1794 </span>            :      printf (&quot;Calling the traversal over the AST for a single file \n&quot;);</a>
<a name="1795"><span class="lineNum">    1795 </span>            : </a>
<a name="1796"><span class="lineNum">    1796 </span>            :      traversal.traverse(sourceFile, preorder);</a>
<a name="1797"><span class="lineNum">    1797 </span>            : </a>
<a name="1798"><span class="lineNum">    1798 </span>            :      printf (&quot;Leaving compute_IR_node_pointers(): umap.size() = %zu \n&quot;,umap.size());</a>
<a name="1799"><span class="lineNum">    1799 </span>            :    }</a>
<a name="1800"><span class="lineNum">    1800 </span>            : #endif</a>
<a name="1801"><span class="lineNum">    1801 </span>            : </a>
<a name="1802"><span class="lineNum">    1802 </span>            : int</a>
<a name="1803"><span class="lineNum">    1803 </span><span class="lineCov">        352 : SgProject::parse()</span></a>
<a name="1804"><span class="lineNum">    1804 </span>            :    {</a>
<a name="1805"><span class="lineNum">    1805 </span><span class="lineCov">        352 :      int errorCode = 0;</span></a>
<a name="1806"><span class="lineNum">    1806 </span>            : </a>
<a name="1807"><span class="lineNum">    1807 </span>            : #define DEBUG_PARSE 0</a>
<a name="1808"><span class="lineNum">    1808 </span>            : </a>
<a name="1809"><span class="lineNum">    1809 </span>            :   // DQ (7/6/2005): Introduce tracking of performance of ROSE.</a>
<a name="1810"><span class="lineNum">    1810 </span><span class="lineCov">        352 :      TimingPerformance timer (&quot;AST (SgProject::parse()):&quot;);</span></a>
<a name="1811"><span class="lineNum">    1811 </span>            : </a>
<a name="1812"><span class="lineNum">    1812 </span>            :   // ROSE_ASSERT (p_fileList != NULL);</a>
<a name="1813"><span class="lineNum">    1813 </span>            : </a>
<a name="1814"><span class="lineNum">    1814 </span>            : #ifdef ROSE_BUILD_FORTRAN_LANGUAGE_SUPPORT</a>
<a name="1815"><span class="lineNum">    1815 </span>            :   // FMZ (5/29/2008)</a>
<a name="1816"><span class="lineNum">    1816 </span><span class="lineCov">        352 :      FortranModuleInfo::setCurrentProject(this);</span></a>
<a name="1817"><span class="lineNum">    1817 </span><span class="lineCov">        352 :      FortranModuleInfo::set_inputDirs(this );</span></a>
<a name="1818"><span class="lineNum">    1818 </span>            : #endif</a>
<a name="1819"><span class="lineNum">    1819 </span>            : </a>
<a name="1820"><span class="lineNum">    1820 </span>            :   // Simplify multi-file handling so that a single file is just the trivial</a>
<a name="1821"><span class="lineNum">    1821 </span>            :   // case and not a special separate case.</a>
<a name="1822"><span class="lineNum">    1822 </span>            : #if DEBUG_PARSE</a>
<a name="1823"><span class="lineNum">    1823 </span>            :      printf (&quot;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ \n&quot;);</a>
<a name="1824"><span class="lineNum">    1824 </span>            :      printf (&quot;In SgProject::parse(): Loop through the source files on the command line! p_sourceFileNameList = %&quot; PRIuPTR &quot; \n&quot;,p_sourceFileNameList.size());</a>
<a name="1825"><span class="lineNum">    1825 </span>            :      printf (&quot;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ \n&quot;);</a>
<a name="1826"><span class="lineNum">    1826 </span>            : #endif</a>
<a name="1827"><span class="lineNum">    1827 </span>            : </a>
<a name="1828"><span class="lineNum">    1828 </span>            : #if 0</a>
<a name="1829"><span class="lineNum">    1829 </span>            :      printf (&quot;Exiting as a test! \n&quot;);</a>
<a name="1830"><span class="lineNum">    1830 </span>            :      ROSE_ASSERT(false);</a>
<a name="1831"><span class="lineNum">    1831 </span>            : #endif</a>
<a name="1832"><span class="lineNum">    1832 </span>            : </a>
<a name="1833"><span class="lineNum">    1833 </span><span class="lineCov">        352 :      Rose_STL_Container&lt;string&gt;::iterator nameIterator = p_sourceFileNameList.begin();</span></a>
<a name="1834"><span class="lineNum">    1834 </span><span class="lineCov">        352 :      unsigned int i = 0;</span></a>
<a name="1835"><span class="lineNum">    1835 </span>            : </a>
<a name="1836"><span class="lineNum">    1836 </span>            :   // The goal in this version of the code is to seperate the construction of the SgFile objects</a>
<a name="1837"><span class="lineNum">    1837 </span>            :   // from the invocation of the frontend on each of the SgFile objects.  In general this allows</a>
<a name="1838"><span class="lineNum">    1838 </span>            :   // the compilation to reference the other SgFile objects on an as needed basis as part of running</a>
<a name="1839"><span class="lineNum">    1839 </span>            :   // the frontend.  This is important for the optimization of Java.</a>
<a name="1840"><span class="lineNum">    1840 </span><span class="lineCov">        704 :      std::vector&lt;SgFile*&gt; vectorOfFiles;</span></a>
<a name="1841"><span class="lineNum">    1841 </span><span class="lineCov">        705 :      while (nameIterator != p_sourceFileNameList.end())</span></a>
<a name="1842"><span class="lineNum">    1842 </span>            :         {</a>
<a name="1843"><span class="lineNum">    1843 </span>            : #if 0</a>
<a name="1844"><span class="lineNum">    1844 </span>            :           printf (&quot;Build a SgFile object for file #%d \n&quot;,i);</a>
<a name="1845"><span class="lineNum">    1845 </span>            : #endif</a>
<a name="1846"><span class="lineNum">    1846 </span><span class="lineCov">        353 :           int nextErrorCode = 0;</span></a>
<a name="1847"><span class="lineNum">    1847 </span>            : </a>
<a name="1848"><span class="lineNum">    1848 </span>            :        // DQ (4/20/2006): Exclude other files from list in argc and argv</a>
<a name="1849"><span class="lineNum">    1849 </span><span class="lineCov">        353 :           vector&lt;string&gt; argv = get_originalCommandLineArgumentList();</span></a>
<a name="1850"><span class="lineNum">    1850 </span><span class="lineCov">        706 :           string currentFileName = *nameIterator;</span></a>
<a name="1851"><span class="lineNum">    1851 </span>            : #if 0</a>
<a name="1852"><span class="lineNum">    1852 </span>            :           printf (&quot;In SgProject::parse(): before removeAllFileNamesExcept() file = %s argv = %s \n&quot;,</a>
<a name="1853"><span class="lineNum">    1853 </span>            :                currentFileName.c_str(),CommandlineProcessing::generateStringFromArgList(argv,false,false).c_str());</a>
<a name="1854"><span class="lineNum">    1854 </span>            : #endif</a>
<a name="1855"><span class="lineNum">    1855 </span><span class="lineCov">        706 :           CommandlineProcessing::removeAllFileNamesExcept(argv,p_sourceFileNameList,currentFileName);</span></a>
<a name="1856"><span class="lineNum">    1856 </span>            : #if 0</a>
<a name="1857"><span class="lineNum">    1857 </span>            :           printf (&quot;In SgProject::parse(): after removeAllFileNamesExcept() from command line for file = %s argv = %s \n&quot;,</a>
<a name="1858"><span class="lineNum">    1858 </span>            :                currentFileName.c_str(),CommandlineProcessing::generateStringFromArgList(argv,false,false).c_str());</a>
<a name="1859"><span class="lineNum">    1859 </span>            :           printf (&quot;currentFileName = %s \n&quot;,currentFileName.c_str());</a>
<a name="1860"><span class="lineNum">    1860 </span>            : #endif</a>
<a name="1861"><span class="lineNum">    1861 </span>            :        // DQ (11/13/2008): Removed overly complex logic here!</a>
<a name="1862"><span class="lineNum">    1862 </span>            : #if 0</a>
<a name="1863"><span class="lineNum">    1863 </span>            :           printf (&quot;In SgProject::parse(): Calling determineFileType() currentFileName = %s \n&quot;,currentFileName.c_str());</a>
<a name="1864"><span class="lineNum">    1864 </span>            : #endif</a>
<a name="1865"><span class="lineNum">    1865 </span><span class="lineCov">        353 :           SgFile* newFile = determineFileType(argv, nextErrorCode, this);</span></a>
<a name="1866"><span class="lineNum">    1866 </span><span class="lineCov">        353 :           ASSERT_not_null(newFile);</span></a>
<a name="1867"><span class="lineNum">    1867 </span>            : #if 0</a>
<a name="1868"><span class="lineNum">    1868 </span>            :           printf (&quot;+++++++++++++++ DONE: Calling determineFileType() currentFileName = %s \n&quot;,currentFileName.c_str());</a>
<a name="1869"><span class="lineNum">    1869 </span>            :           printf (&quot;In SgProject::parse(): newFile = %p = %s \n&quot;,newFile,newFile-&gt;class_name().c_str());</a>
<a name="1870"><span class="lineNum">    1870 </span>            : #endif</a>
<a name="1871"><span class="lineNum">    1871 </span><span class="lineCov">        353 :           ASSERT_not_null(newFile-&gt;get_startOfConstruct());</span></a>
<a name="1872"><span class="lineNum">    1872 </span><span class="lineCov">        353 :           ASSERT_not_null(newFile-&gt;get_parent());</span></a>
<a name="1873"><span class="lineNum">    1873 </span>            : </a>
<a name="1874"><span class="lineNum">    1874 </span>            :        // DQ (6/13/2013): Added to support error checking (seperation of construction of SgFile IR nodes from calling the fronend on each one).</a>
<a name="1875"><span class="lineNum">    1875 </span><span class="lineCov">        353 :           ASSERT_not_null(isSgProject(newFile-&gt;get_parent()));</span></a>
<a name="1876"><span class="lineNum">    1876 </span><span class="lineCov">        353 :           ROSE_ASSERT(newFile-&gt;get_parent() == this);</span></a>
<a name="1877"><span class="lineNum">    1877 </span>            : </a>
<a name="1878"><span class="lineNum">    1878 </span>            :        // This just adds the new file to the list of files stored internally (note: this sets the parent of the newFile).</a>
<a name="1879"><span class="lineNum">    1879 </span><span class="lineCov">        353 :           set_file ( *newFile );</span></a>
<a name="1880"><span class="lineNum">    1880 </span>            : </a>
<a name="1881"><span class="lineNum">    1881 </span>            :        // DQ (6/13/2013): Added to support error checking (seperation of construction of SgFile IR nodes from calling the fronend on each one).</a>
<a name="1882"><span class="lineNum">    1882 </span><span class="lineCov">        353 :           ASSERT_not_null(newFile-&gt;get_parent());</span></a>
<a name="1883"><span class="lineNum">    1883 </span>            : </a>
<a name="1884"><span class="lineNum">    1884 </span>            :        // This list of files will be iterated over to call the frontend in the next loop.</a>
<a name="1885"><span class="lineNum">    1885 </span><span class="lineCov">        353 :           vectorOfFiles.push_back(newFile);</span></a>
<a name="1886"><span class="lineNum">    1886 </span>            : </a>
<a name="1887"><span class="lineNum">    1887 </span>            :        // newFile-&gt;display(&quot;Called from SgProject::parse()&quot;);</a>
<a name="1888"><span class="lineNum">    1888 </span>            : </a>
<a name="1889"><span class="lineNum">    1889 </span><span class="lineCov">        353 :           nameIterator++;</span></a>
<a name="1890"><span class="lineNum">    1890 </span><span class="lineCov">        353 :           i++;</span></a>
<a name="1891"><span class="lineNum">    1891 </span>            :         } // end while</a>
<a name="1892"><span class="lineNum">    1892 </span>            : </a>
<a name="1893"><span class="lineNum">    1893 </span>            : #if 0</a>
<a name="1894"><span class="lineNum">    1894 </span>            :      printf (&quot;In Project::parse(): (calling the frontend on all previously setup SgFile objects) vectorOfFiles.size() = %&quot; PRIuPTR &quot; \n&quot;,vectorOfFiles.size());</a>
<a name="1895"><span class="lineNum">    1895 </span>            : #endif</a>
<a name="1896"><span class="lineNum">    1896 </span>            : </a>
<a name="1897"><span class="lineNum">    1897 </span><span class="lineCov">        352 :      errorCode = this-&gt;RunFrontend();</span></a>
<a name="1898"><span class="lineNum">    1898 </span><span class="lineCov">        352 :      if (errorCode &gt; 3)</span></a>
<a name="1899"><span class="lineNum">    1899 </span>            :         {</a>
<a name="1900"><span class="lineNum">    1900 </span>            :           return errorCode;</a>
<a name="1901"><span class="lineNum">    1901 </span>            :         }</a>
<a name="1902"><span class="lineNum">    1902 </span>            : </a>
<a name="1903"><span class="lineNum">    1903 </span>            :   // DQ (6/13/2013): Test the new function to lookup the SgFile from the name with full path.</a>
<a name="1904"><span class="lineNum">    1904 </span>            :   // This is a simple consistency test for that new function.</a>
<a name="1905"><span class="lineNum">    1905 </span><span class="lineCov">        705 :      for (size_t i = 0; i &lt; vectorOfFiles.size(); i++)</span></a>
<a name="1906"><span class="lineNum">    1906 </span>            :         {</a>
<a name="1907"><span class="lineNum">    1907 </span><span class="lineCov">        706 :           string filename = vectorOfFiles[i]-&gt;get_sourceFileNameWithPath();</span></a>
<a name="1908"><span class="lineNum">    1908 </span><span class="lineCov">        706 :           SgFile* file = this-&gt;operator[](filename);</span></a>
<a name="1909"><span class="lineNum">    1909 </span><span class="lineCov">        353 :           ASSERT_not_null(file);</span></a>
<a name="1910"><span class="lineNum">    1910 </span>            : </a>
<a name="1911"><span class="lineNum">    1911 </span><span class="lineCov">        353 :           if ( SgProject::get_verbose() &gt; 0 )</span></a>
<a name="1912"><span class="lineNum">    1912 </span>            :              {</a>
<a name="1913"><span class="lineNum">    1913 </span><span class="lineNoCov">          0 :                printf (&quot;Testing: map of filenames to SgFile IR nodes: filename = %s is mapped to SgFile = %p \n&quot;,filename.c_str(),vectorOfFiles[i]);</span></a>
<a name="1914"><span class="lineNum">    1914 </span>            :              }</a>
<a name="1915"><span class="lineNum">    1915 </span>            : </a>
<a name="1916"><span class="lineNum">    1916 </span><span class="lineCov">        353 :           ROSE_ASSERT(file == vectorOfFiles[i]);</span></a>
<a name="1917"><span class="lineNum">    1917 </span>            :         }</a>
<a name="1918"><span class="lineNum">    1918 </span>            : </a>
<a name="1919"><span class="lineNum">    1919 </span>            : #if 0</a>
<a name="1920"><span class="lineNum">    1920 </span>            :   // DQ (12/21/2019): Adding support to detect and mark all shared IR nodes across multiple translation units.</a>
<a name="1921"><span class="lineNum">    1921 </span>            :      if (vectorOfFiles.size() &gt; 1)</a>
<a name="1922"><span class="lineNum">    1922 </span>            :         {</a>
<a name="1923"><span class="lineNum">    1923 </span>            : #if 0</a>
<a name="1924"><span class="lineNum">    1924 </span>            :           printf (&quot;Need to detect and mark all shared IR nodes in the ASTs of multiple translation units: vectorOfFiles.size() = %zu \n&quot;,vectorOfFiles.size());</a>
<a name="1925"><span class="lineNum">    1925 </span>            : #endif</a>
<a name="1926"><span class="lineNum">    1926 </span>            : </a>
<a name="1927"><span class="lineNum">    1927 </span>            :        // We need to collect all of the IR nodes from each file's translation unit and perform an intersection.</a>
<a name="1928"><span class="lineNum">    1928 </span>            : </a>
<a name="1929"><span class="lineNum">    1929 </span>            :        // unordered_map&lt;int,SgNode*&gt; umap;</a>
<a name="1930"><span class="lineNum">    1930 </span>            :           unordered_map &lt; SgNode*, set &lt;int&gt; &gt; umap;</a>
<a name="1931"><span class="lineNum">    1931 </span>            : </a>
<a name="1932"><span class="lineNum">    1932 </span>            :           for (size_t i = 0; i &lt; vectorOfFiles.size(); i++)</a>
<a name="1933"><span class="lineNum">    1933 </span>            :              {</a>
<a name="1934"><span class="lineNum">    1934 </span>            :                string filename = vectorOfFiles[i]-&gt;get_sourceFileNameWithPath();</a>
<a name="1935"><span class="lineNum">    1935 </span>            :                SgFile* file = this-&gt;operator[](filename);</a>
<a name="1936"><span class="lineNum">    1936 </span>            : </a>
<a name="1937"><span class="lineNum">    1937 </span>            :             // Form a hash table of the pointers to all of the IR nodes in the first translation unit.</a>
<a name="1938"><span class="lineNum">    1938 </span>            : </a>
<a name="1939"><span class="lineNum">    1939 </span>            :                int file_id = file-&gt;get_startOfConstruct()-&gt;get_file_id();</a>
<a name="1940"><span class="lineNum">    1940 </span>            : #if 0</a>
<a name="1941"><span class="lineNum">    1941 </span>            :                printf (&quot;filename = %s file_id = %d \n&quot;,filename.c_str(),file_id);</a>
<a name="1942"><span class="lineNum">    1942 </span>            : #endif</a>
<a name="1943"><span class="lineNum">    1943 </span>            :             // umap[file_id] = file;</a>
<a name="1944"><span class="lineNum">    1944 </span>            :                SgSourceFile* sourceFile = isSgSourceFile(file);</a>
<a name="1945"><span class="lineNum">    1945 </span>            :                ASSERT_not_null(sourceFile);</a>
<a name="1946"><span class="lineNum">    1946 </span>            : </a>
<a name="1947"><span class="lineNum">    1947 </span>            :                compute_IR_node_pointers(sourceFile, umap);</a>
<a name="1948"><span class="lineNum">    1948 </span>            :              }</a>
<a name="1949"><span class="lineNum">    1949 </span>            : </a>
<a name="1950"><span class="lineNum">    1950 </span>            : #if 0</a>
<a name="1951"><span class="lineNum">    1951 </span>            :           printf (&quot;Exiting as a test after detecting and marking shared IR nodes from multiple files \n&quot;);</a>
<a name="1952"><span class="lineNum">    1952 </span>            :           ROSE_ABORT();</a>
<a name="1953"><span class="lineNum">    1953 </span>            : #endif</a>
<a name="1954"><span class="lineNum">    1954 </span>            :         }</a>
<a name="1955"><span class="lineNum">    1955 </span>            : #else</a>
<a name="1956"><span class="lineNum">    1956 </span>            : #if 0</a>
<a name="1957"><span class="lineNum">    1957 </span>            :      printf (&quot;In SgProject::parse(): Skipping computation of shared nodes! \n&quot;);</a>
<a name="1958"><span class="lineNum">    1958 </span>            : #endif</a>
<a name="1959"><span class="lineNum">    1959 </span>            : #endif</a>
<a name="1960"><span class="lineNum">    1960 </span>            : </a>
<a name="1961"><span class="lineNum">    1961 </span>            : #if 0</a>
<a name="1962"><span class="lineNum">    1962 </span>            :      printf (&quot;In SgProject::parse() before AstPostProcessing() \n&quot;);</a>
<a name="1963"><span class="lineNum">    1963 </span>            : #endif</a>
<a name="1964"><span class="lineNum">    1964 </span>            : </a>
<a name="1965"><span class="lineNum">    1965 </span>            :   // GB (8/19/2009): Moved the AstPostProcessing call from</a>
<a name="1966"><span class="lineNum">    1966 </span>            :   // SgFile::callFrontEnd to this point. Thus, it is only called once for</a>
<a name="1967"><span class="lineNum">    1967 </span>            :   // the whole project rather than once per file. Repeated calls to</a>
<a name="1968"><span class="lineNum">    1968 </span>            :   // AstPostProcessing are slow due to repeated memory pool traversals. The</a>
<a name="1969"><span class="lineNum">    1969 </span>            :   // AstPostProcessing is only to be called if there are input files to run</a>
<a name="1970"><span class="lineNum">    1970 </span>            :   // it on, and they are meant to be used in some way other than just</a>
<a name="1971"><span class="lineNum">    1971 </span>            :   // calling the backend on them. (If only the backend is used, this was</a>
<a name="1972"><span class="lineNum">    1972 </span>            :   // never called by SgFile::callFrontEnd either.)</a>
<a name="1973"><span class="lineNum">    1973 </span>            :   // if ( !get_fileList().empty() &amp;&amp; !get_useBackendOnly() )</a>
<a name="1974"><span class="lineNum">    1974 </span>            : #ifndef ROSE_USE_CLANG_FRONTEND</a>
<a name="1975"><span class="lineNum">    1975 </span><span class="lineCov">        352 :      if ( (get_fileList().empty() == false) &amp;&amp; (get_useBackendOnly() == false) )</span></a>
<a name="1976"><span class="lineNum">    1976 </span>            :         {</a>
<a name="1977"><span class="lineNum">    1977 </span><span class="lineCov">        352 :           AstPostProcessing(this);</span></a>
<a name="1978"><span class="lineNum">    1978 </span>            :         }</a>
<a name="1979"><span class="lineNum">    1979 </span>            : #endif</a>
<a name="1980"><span class="lineNum">    1980 </span>            : #if 0</a>
<a name="1981"><span class="lineNum">    1981 </span>            :        else</a>
<a name="1982"><span class="lineNum">    1982 </span>            :         {</a>
<a name="1983"><span class="lineNum">    1983 </span>            :        // Alternatively if this is a part of binary analysis then process via AstPostProcessing().</a>
<a name="1984"><span class="lineNum">    1984 </span>            :           if (this-&gt;get_binary_only() == true)</a>
<a name="1985"><span class="lineNum">    1985 </span>            :              {</a>
<a name="1986"><span class="lineNum">    1986 </span>            :                AstPostProcessing(this);</a>
<a name="1987"><span class="lineNum">    1987 </span>            :              }</a>
<a name="1988"><span class="lineNum">    1988 </span>            :         }</a>
<a name="1989"><span class="lineNum">    1989 </span>            : #endif</a>
<a name="1990"><span class="lineNum">    1990 </span>            : </a>
<a name="1991"><span class="lineNum">    1991 </span>            :   // negara1 (06/23/2011): Collect information about the included files to support unparsing of those that are modified.</a>
<a name="1992"><span class="lineNum">    1992 </span>            :   // In the first step, get the include search paths, which will be used while attaching include preprocessing infos.</a>
<a name="1993"><span class="lineNum">    1993 </span>            :   // Proceed only if there are input files and they require header files unparsing.</a>
<a name="1994"><span class="lineNum">    1994 </span><span class="lineCov">        352 :      if (!get_fileList().empty() &amp;&amp; (*get_fileList().begin())-&gt;get_unparseHeaderFiles())</span></a>
<a name="1995"><span class="lineNum">    1995 </span>            :         {</a>
<a name="1996"><span class="lineNum">    1996 </span><span class="lineNoCov">          0 :           if (SgProject::get_verbose() &gt;= 1)</span></a>
<a name="1997"><span class="lineNum">    1997 </span>            :              {</a>
<a name="1998"><span class="lineNum">    1998 </span><span class="lineNoCov">          0 :                cout &lt;&lt; endl &lt;&lt; &quot;***HEADER FILES ANALYSIS***&quot; &lt;&lt; endl &lt;&lt; endl;</span></a>
<a name="1999"><span class="lineNum">    1999 </span>            :              }</a>
<a name="2000"><span class="lineNum">    2000 </span><span class="lineNoCov">          0 :           CompilerOutputParser compilerOutputParser(this);</span></a>
<a name="2001"><span class="lineNum">    2001 </span><span class="lineNoCov">          0 :           const pair&lt;list&lt;string&gt;, list&lt;string&gt; &gt;&amp; includedFilesSearchPaths = compilerOutputParser.collectIncludedFilesSearchPaths();</span></a>
<a name="2002"><span class="lineNum">    2002 </span><span class="lineNoCov">          0 :           set_quotedIncludesSearchPaths(includedFilesSearchPaths.first);</span></a>
<a name="2003"><span class="lineNum">    2003 </span><span class="lineNoCov">          0 :           set_bracketedIncludesSearchPaths(includedFilesSearchPaths.second);</span></a>
<a name="2004"><span class="lineNum">    2004 </span>            : </a>
<a name="2005"><span class="lineNum">    2005 </span><span class="lineNoCov">          0 :           if (SgProject::get_verbose() &gt;= 1)</span></a>
<a name="2006"><span class="lineNum">    2006 </span>            :              {</a>
<a name="2007"><span class="lineNum">    2007 </span>            :             // DQ (11/7/2018): Output the list of quotedIncludesSearchPaths and bracketedIncludesSearchPaths include paths.</a>
<a name="2008"><span class="lineNum">    2008 </span><span class="lineNoCov">          0 :                CollectionHelper::printList(get_quotedIncludesSearchPaths(), &quot;\nQuoted includes search paths:&quot;, &quot;Path:&quot;);</span></a>
<a name="2009"><span class="lineNum">    2009 </span><span class="lineNoCov">          0 :                CollectionHelper::printList(get_bracketedIncludesSearchPaths(), &quot;\nBracketed includes search paths:&quot;, &quot;Path:&quot;);</span></a>
<a name="2010"><span class="lineNum">    2010 </span>            :              }</a>
<a name="2011"><span class="lineNum">    2011 </span>            : #if 0</a>
<a name="2012"><span class="lineNum">    2012 </span>            :           printf (&quot;Exiting as a test! \n&quot;);</a>
<a name="2013"><span class="lineNum">    2013 </span>            :           ROSE_ABORT();</a>
<a name="2014"><span class="lineNum">    2014 </span>            : #endif</a>
<a name="2015"><span class="lineNum">    2015 </span>            :         }</a>
<a name="2016"><span class="lineNum">    2016 </span>            : </a>
<a name="2017"><span class="lineNum">    2017 </span>            :   // GB (9/4/2009): Moved the secondary pass over source files (which</a>
<a name="2018"><span class="lineNum">    2018 </span>            :   // attaches the preprocessing information) to this point. This way, the</a>
<a name="2019"><span class="lineNum">    2019 </span>            :   // secondary pass over each file runs after all fixes have been done. This</a>
<a name="2020"><span class="lineNum">    2020 </span>            :   // is relevant where the AstPostProcessing mechanism must first mark nodes</a>
<a name="2021"><span class="lineNum">    2021 </span>            :   // to be output before preprocessing information is attached.</a>
<a name="2022"><span class="lineNum">    2022 </span><span class="lineCov">        352 :      SgFilePtrList &amp; files = get_fileList();</span></a>
<a name="2023"><span class="lineNum">    2023 </span>            : </a>
<a name="2024"><span class="lineNum">    2024 </span>            : #if 0</a>
<a name="2025"><span class="lineNum">    2025 </span>            :   // DQ (4/24/2021): Debugging the handling of header_file_unparsing_optimization for non-optimized case.</a>
<a name="2026"><span class="lineNum">    2026 </span>            :      BOOST_FOREACH(SgFile* file, files)</a>
<a name="2027"><span class="lineNum">    2027 </span>            :         {</a>
<a name="2028"><span class="lineNum">    2028 </span>            :           printf (&quot;file = %s \n&quot;,file-&gt;getFileName().c_str());</a>
<a name="2029"><span class="lineNum">    2029 </span>            :           printf (&quot; --- file-&gt;get_header_file_unparsing_optimization()             = %s \n&quot;,file-&gt;get_header_file_unparsing_optimization() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="2030"><span class="lineNum">    2030 </span>            :           printf (&quot; --- file-&gt;get_header_file_unparsing_optimization_source_file() = %s \n&quot;,file-&gt;get_header_file_unparsing_optimization_source_file() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="2031"><span class="lineNum">    2031 </span>            :           printf (&quot; --- file-&gt;get_header_file_unparsing_optimization_header_file() = %s \n&quot;,file-&gt;get_header_file_unparsing_optimization_header_file() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="2032"><span class="lineNum">    2032 </span>            :         }</a>
<a name="2033"><span class="lineNum">    2033 </span>            : #endif</a>
<a name="2034"><span class="lineNum">    2034 </span>            : </a>
<a name="2035"><span class="lineNum">    2035 </span><span class="lineCov">        352 :      bool unparse_using_tokens = false;</span></a>
<a name="2036"><span class="lineNum">    2036 </span>            : </a>
<a name="2037"><span class="lineNum">    2037 </span><span class="lineCov">       1058 :      BOOST_FOREACH(SgFile* file, files)</span></a>
<a name="2038"><span class="lineNum">    2038 </span>            :         {</a>
<a name="2039"><span class="lineNum">    2039 </span><span class="lineCov">        353 :           ASSERT_not_null(file);</span></a>
<a name="2040"><span class="lineNum">    2040 </span>            : </a>
<a name="2041"><span class="lineNum">    2041 </span><span class="lineCov">        353 :           SgSourceFile* sourceFile = isSgSourceFile(file);</span></a>
<a name="2042"><span class="lineNum">    2042 </span>            : </a>
<a name="2043"><span class="lineNum">    2043 </span>            :        // We can't assert this when supporting binary analysis.</a>
<a name="2044"><span class="lineNum">    2044 </span>            :        // ROSE_ASSERT(sourceFile != NULL);</a>
<a name="2045"><span class="lineNum">    2045 </span><span class="lineCov">        353 :           if (sourceFile != nullptr)</span></a>
<a name="2046"><span class="lineNum">    2046 </span>            :              {</a>
<a name="2047"><span class="lineNum">    2047 </span>            :             // DQ (4/25/2021): I think this should be a static bool data member.</a>
<a name="2048"><span class="lineNum">    2048 </span><span class="lineCov">        353 :                if (unparse_using_tokens == false)</span></a>
<a name="2049"><span class="lineNum">    2049 </span>            :                   {</a>
<a name="2050"><span class="lineNum">    2050 </span><span class="lineCov">        353 :                     unparse_using_tokens = sourceFile-&gt;get_unparse_tokens();</span></a>
<a name="2051"><span class="lineNum">    2051 </span>            :                   }</a>
<a name="2052"><span class="lineNum">    2052 </span>            :              }</a>
<a name="2053"><span class="lineNum">    2053 </span>            : #if 0</a>
<a name="2054"><span class="lineNum">    2054 </span>            :           printf (&quot;unparse_using_tokens = %s \n&quot;,unparse_using_tokens ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="2055"><span class="lineNum">    2055 </span>            : #endif</a>
<a name="2056"><span class="lineNum">    2056 </span><span class="lineCov">        353 :           if (KEEP_GOING_CAUGHT_FRONTEND_SECONDARY_PASS_SIGNAL)</span></a>
<a name="2057"><span class="lineNum">    2057 </span>            :              {</a>
<a name="2058"><span class="lineNum">    2058 </span><span class="lineNoCov">          0 :                std::cout</span></a>
<a name="2059"><span class="lineNum">    2059 </span>            :                     &lt;&lt; &quot;[WARN] &quot;</a>
<a name="2060"><span class="lineNum">    2060 </span>            :                     &lt;&lt; &quot;Configured to keep going after catching a signal in &quot;</a>
<a name="2061"><span class="lineNum">    2061 </span><span class="lineNoCov">          0 :                     &lt;&lt; &quot;SgFile::secondaryPassOverSourceFile()&quot;</span></a>
<a name="2062"><span class="lineNum">    2062 </span><span class="lineNoCov">          0 :                     &lt;&lt; std::endl;</span></a>
<a name="2063"><span class="lineNum">    2063 </span>            : </a>
<a name="2064"><span class="lineNum">    2064 </span><span class="lineNoCov">          0 :                if (file != nullptr)</span></a>
<a name="2065"><span class="lineNum">    2065 </span>            :                   {</a>
<a name="2066"><span class="lineNum">    2066 </span><span class="lineNoCov">          0 :                     file-&gt;set_frontendErrorCode(100);</span></a>
<a name="2067"><span class="lineNum">    2067 </span><span class="lineNoCov">          0 :                     errorCode = std::max(100, errorCode);</span></a>
<a name="2068"><span class="lineNum">    2068 </span>            :                   }</a>
<a name="2069"><span class="lineNum">    2069 </span>            :                  else</a>
<a name="2070"><span class="lineNum">    2070 </span>            :                   {</a>
<a name="2071"><span class="lineNum">    2071 </span><span class="lineNoCov">          0 :                     std::cout</span></a>
<a name="2072"><span class="lineNum">    2072 </span>            :                          &lt;&lt; &quot;[FATAL] &quot;</a>
<a name="2073"><span class="lineNum">    2073 </span><span class="lineNoCov">          0 :                          &lt;&lt; &quot;Unable to keep going due to an unrecoverable internal error&quot;</span></a>
<a name="2074"><span class="lineNum">    2074 </span><span class="lineNoCov">          0 :                          &lt;&lt; std::endl;</span></a>
<a name="2075"><span class="lineNum">    2075 </span>            :                  // Liao, 4/25/2017. one assertion failure may trigger other assertion failures. We still want to keep going.</a>
<a name="2076"><span class="lineNum">    2076 </span><span class="lineNoCov">          0 :                     exit(1);</span></a>
<a name="2077"><span class="lineNum">    2077 </span>            :                  // return std::max(100, errorCode);</a>
<a name="2078"><span class="lineNum">    2078 </span>            :                   }</a>
<a name="2079"><span class="lineNum">    2079 </span>            :              }</a>
<a name="2080"><span class="lineNum">    2080 </span>            :             else</a>
<a name="2081"><span class="lineNum">    2081 </span>            :              {</a>
<a name="2082"><span class="lineNum">    2082 </span>            : #if 0</a>
<a name="2083"><span class="lineNum">    2083 </span>            :                printf (&quot;Test for call to secondaryPassOverSourceFile(): get_disable_edg_backend() = %s \n&quot;,</a>
<a name="2084"><span class="lineNum">    2084 </span>            :                     file-&gt;get_disable_edg_backend() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="2085"><span class="lineNum">    2085 </span>            : #endif</a>
<a name="2086"><span class="lineNum">    2086 </span>            : #if 0</a>
<a name="2087"><span class="lineNum">    2087 </span>            :                display(&quot;Calling secondaryPassOverSourceFile()&quot;);</a>
<a name="2088"><span class="lineNum">    2088 </span>            : #endif</a>
<a name="2089"><span class="lineNum">    2089 </span>            :             // DQ (1/23/2018): If we are not doing the translation of EDG to ROSE, then we don't want to call this second pass.</a>
<a name="2090"><span class="lineNum">    2090 </span>            :             // This will fix the negative test in Plum hall for what should be an error to the C preprocessor.</a>
<a name="2091"><span class="lineNum">    2091 </span>            :             // file-&gt;secondaryPassOverSourceFile();</a>
<a name="2092"><span class="lineNum">    2092 </span>            : </a>
<a name="2093"><span class="lineNum">    2093 </span>            :             // if (file-&gt;get_skip_translation_from_edg_ast_to_rose_ast() == false)</a>
<a name="2094"><span class="lineNum">    2094 </span><span class="lineCov">        353 :                if (file-&gt;get_disable_edg_backend() == false)</span></a>
<a name="2095"><span class="lineNum">    2095 </span>            :                   {</a>
<a name="2096"><span class="lineNum">    2096 </span>            : #if 0</a>
<a name="2097"><span class="lineNum">    2097 </span>            :                  // Output an optional graph of the AST (just the tree, when active). Note that we need to multiple file version</a>
<a name="2098"><span class="lineNum">    2098 </span>            :                  // of this with includes so that we can present a single SgProject rooted AST with multiple SgFile objects.</a>
<a name="2099"><span class="lineNum">    2099 </span>            :                  // generateDOT ( *globalProject );</a>
<a name="2100"><span class="lineNum">    2100 </span>            :                     printf (&quot;\n\nGenerating a dot file of the secondaryPassOverSourceFile AST (could be very large) \n&quot;);</a>
<a name="2101"><span class="lineNum">    2101 </span>            :                     generateDOT_withIncludes ( *this, &quot;before_secondaryPassOverSourceFileAST&quot; );</a>
<a name="2102"><span class="lineNum">    2102 </span>            :                     printf (&quot;DONE: Generating a dot file of the secondaryPassOverSourceFile AST \n&quot;);</a>
<a name="2103"><span class="lineNum">    2103 </span>            : #endif</a>
<a name="2104"><span class="lineNum">    2104 </span>            : #if 0</a>
<a name="2105"><span class="lineNum">    2105 </span>            :                  // Output an optional graph of the AST (just the tree, when active)</a>
<a name="2106"><span class="lineNum">    2106 </span>            :                     printf (&quot;Generating a dot file... (ROSE Release Note: turn off output of dot files before committing code) \n&quot;);</a>
<a name="2107"><span class="lineNum">    2107 </span>            :                  // DQ (12/22/2019): Call multi-file version (instead of generateDOT() function).</a>
<a name="2108"><span class="lineNum">    2108 </span>            :                  // generateAstGraph(project, 2000);</a>
<a name="2109"><span class="lineNum">    2109 </span>            :                  // generateDOT ( *project );</a>
<a name="2110"><span class="lineNum">    2110 </span>            :                     generateDOTforMultipleFile(*this);</a>
<a name="2111"><span class="lineNum">    2111 </span>            : #endif</a>
<a name="2112"><span class="lineNum">    2112 </span>            : #if 0</a>
<a name="2113"><span class="lineNum">    2113 </span>            :                     printf (&quot;Exiting after test! \n&quot;);</a>
<a name="2114"><span class="lineNum">    2114 </span>            :                     ROSE_ABORT();</a>
<a name="2115"><span class="lineNum">    2115 </span>            : #endif</a>
<a name="2116"><span class="lineNum">    2116 </span>            : #if 0</a>
<a name="2117"><span class="lineNum">    2117 </span>            :                     printf (&quot;$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ \n&quot;);</a>
<a name="2118"><span class="lineNum">    2118 </span>            :                     printf (&quot;Calling secondaryPassOverSourceFile(): file = %s \n&quot;,file-&gt;getFileName().c_str());</a>
<a name="2119"><span class="lineNum">    2119 </span>            : #endif</a>
<a name="2120"><span class="lineNum">    2120 </span>            :                  // DQ (8/19/2019): Divide this into two parts, for optimization of header file unparsing, optionally</a>
<a name="2121"><span class="lineNum">    2121 </span>            :                  // support the main file collection of comments and CPP directives, and seperately the header file</a>
<a name="2122"><span class="lineNum">    2122 </span>            :                  // collection of comments and CPP directives.</a>
<a name="2123"><span class="lineNum">    2123 </span>            : #if 0</a>
<a name="2124"><span class="lineNum">    2124 </span>            :                     printf (&quot;######### In calling secondaryPassOverSourceFile() support an optimization improve performance of header file unparsing \n&quot;);</a>
<a name="2125"><span class="lineNum">    2125 </span>            : #endif</a>
<a name="2126"><span class="lineNum">    2126 </span>            :                  // DQ (1/27/2019): Comment out enough to generate the dot file to debug symbol with null basis.</a>
<a name="2127"><span class="lineNum">    2127 </span>            :                  // printf (&quot;ERROR: In Project::parse(): Comment out file-&gt;secondaryPassOverSourceFile() to generate the dot file to debug symbol with null basis \n&quot;);</a>
<a name="2128"><span class="lineNum">    2128 </span>            : #if 0</a>
<a name="2129"><span class="lineNum">    2129 </span>            :                     file-&gt;set_header_file_unparsing_optimization(false);</a>
<a name="2130"><span class="lineNum">    2130 </span>            :                     file-&gt;secondaryPassOverSourceFile();</a>
<a name="2131"><span class="lineNum">    2131 </span>            : #else</a>
<a name="2132"><span class="lineNum">    2132 </span>            : #if 0</a>
<a name="2133"><span class="lineNum">    2133 </span>            :                     printf (&quot;############### Setting file-&gt;set_header_file_unparsing_optimization(true): file = %p = %s \n&quot;,file,file-&gt;class_name().c_str());</a>
<a name="2134"><span class="lineNum">    2134 </span>            : #endif</a>
<a name="2135"><span class="lineNum">    2135 </span>            : #if 0</a>
<a name="2136"><span class="lineNum">    2136 </span>            :                  // DQ (4/24/2021): This data member header_file_unparsing_optimization is now static (so we don't need this code).</a>
<a name="2137"><span class="lineNum">    2137 </span>            :                     printf (&quot;This is required to be set here, even though it is set in the codeSegregation tool explicitly \n&quot;);</a>
<a name="2138"><span class="lineNum">    2138 </span>            : #endif</a>
<a name="2139"><span class="lineNum">    2139 </span>            :                  // DQ (4/25/2021): Test without this code.</a>
<a name="2140"><span class="lineNum">    2140 </span>            :                  // file-&gt;set_header_file_unparsing_optimization(true);</a>
<a name="2141"><span class="lineNum">    2141 </span>            : </a>
<a name="2142"><span class="lineNum">    2142 </span>            :                  // DQ (4/24/2021): Debugging header file optimization.</a>
<a name="2143"><span class="lineNum">    2143 </span>            :                  // file-&gt;set_header_file_unparsing_optimization_source_file(true);</a>
<a name="2144"><span class="lineNum">    2144 </span>            : #if 0</a>
<a name="2145"><span class="lineNum">    2145 </span>            :                     printf (&quot;In SgProject::parse(): Perform collection of comments and CPP directives only on the source file \n&quot;);</a>
<a name="2146"><span class="lineNum">    2146 </span>            :                     printf (&quot;###################################################### \n&quot;);</a>
<a name="2147"><span class="lineNum">    2147 </span>            :                     printf (&quot;Processing comments and CPP directives for source file \n&quot;);</a>
<a name="2148"><span class="lineNum">    2148 </span>            :                     printf (&quot;###################################################### \n&quot;);</a>
<a name="2149"><span class="lineNum">    2149 </span>            : #endif</a>
<a name="2150"><span class="lineNum">    2150 </span><span class="lineCov">        353 :                     file-&gt;secondaryPassOverSourceFile();</span></a>
<a name="2151"><span class="lineNum">    2151 </span>            : #if 0</a>
<a name="2152"><span class="lineNum">    2152 </span>            :                     printf (&quot;Exiting after test! processed first phase of collecting comments and CPP directives for source file) \n&quot;);</a>
<a name="2153"><span class="lineNum">    2153 </span>            :                     ROSE_ABORT();</a>
<a name="2154"><span class="lineNum">    2154 </span>            : #endif</a>
<a name="2155"><span class="lineNum">    2155 </span>            : #if 0</a>
<a name="2156"><span class="lineNum">    2156 </span>            :                     printf (&quot;############### Setting file-&gt;set_header_file_unparsing_optimization_source_file(false): file = %p = %s \n&quot;,file,file-&gt;class_name().c_str());</a>
<a name="2157"><span class="lineNum">    2157 </span>            :                     printf (&quot;############### Setting file-&gt;set_header_file_unparsing_optimization_header_file(true):  file = %p = %s \n&quot;,file,file-&gt;class_name().c_str());</a>
<a name="2158"><span class="lineNum">    2158 </span>            : #endif</a>
<a name="2159"><span class="lineNum">    2159 </span>            :                  // DQ (4/24/2021): Debugging header file optimization.</a>
<a name="2160"><span class="lineNum">    2160 </span>            :                  // file-&gt;set_header_file_unparsing_optimization_source_file(false);</a>
<a name="2161"><span class="lineNum">    2161 </span>            : </a>
<a name="2162"><span class="lineNum">    2162 </span>            : </a>
<a name="2163"><span class="lineNum">    2163 </span>            : #if 0</a>
<a name="2164"><span class="lineNum">    2164 </span>            :                     file-&gt;set_header_file_unparsing_optimization_header_file(true);</a>
<a name="2165"><span class="lineNum">    2165 </span>            : </a>
<a name="2166"><span class="lineNum">    2166 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="2167"><span class="lineNum">    2167 </span>            : </a>
<a name="2168"><span class="lineNum">    2168 </span>            : #if 0</a>
<a name="2169"><span class="lineNum">    2169 </span>            :                     printf (&quot;Perform collection of comments and CPP directives only on the header files \n&quot;);</a>
<a name="2170"><span class="lineNum">    2170 </span>            :                     printf (&quot;####################################################### \n&quot;);</a>
<a name="2171"><span class="lineNum">    2171 </span>            :                     printf (&quot;Processing comments and CPP directives for header files \n&quot;);</a>
<a name="2172"><span class="lineNum">    2172 </span>            :                     printf (&quot;####################################################### \n&quot;);</a>
<a name="2173"><span class="lineNum">    2173 </span>            : #endif</a>
<a name="2174"><span class="lineNum">    2174 </span>            :                  // printf (&quot;Commented out specific header file collection of comments and CPP directives \n&quot;);</a>
<a name="2175"><span class="lineNum">    2175 </span>            :                     file-&gt;secondaryPassOverSourceFile();</a>
<a name="2176"><span class="lineNum">    2176 </span>            : #if 0</a>
<a name="2177"><span class="lineNum">    2177 </span>            :                     printf (&quot;Exiting after test! processed second phase of collecting comments and CPP directives for header files) \n&quot;);</a>
<a name="2178"><span class="lineNum">    2178 </span>            :                     ROSE_ABORT();</a>
<a name="2179"><span class="lineNum">    2179 </span>            : #endif</a>
<a name="2180"><span class="lineNum">    2180 </span>            : #if 0</a>
<a name="2181"><span class="lineNum">    2181 </span>            :                     printf (&quot;############### Setting file-&gt;set_header_file_unparsing_optimization_header_file(false): file = %p = %s \n&quot;,file,file-&gt;class_name().c_str());</a>
<a name="2182"><span class="lineNum">    2182 </span>            : #endif</a>
<a name="2183"><span class="lineNum">    2183 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="2184"><span class="lineNum">    2184 </span>            :                     file-&gt;set_header_file_unparsing_optimization_header_file(false);</a>
<a name="2185"><span class="lineNum">    2185 </span>            : #endif</a>
<a name="2186"><span class="lineNum">    2186 </span>            : #endif</a>
<a name="2187"><span class="lineNum">    2187 </span>            :                  // DQ (4/25/2021): Test without this assertion.</a>
<a name="2188"><span class="lineNum">    2188 </span>            :                  // DQ (9/18/2019): I think this is true, though it might depend on the command-line options.</a>
<a name="2189"><span class="lineNum">    2189 </span>            :                  // ROSE_ASSERT(file-&gt;get_header_file_unparsing_optimization() == true);</a>
<a name="2190"><span class="lineNum">    2190 </span>            : </a>
<a name="2191"><span class="lineNum">    2191 </span><span class="lineCov">        353 :                     ROSE_ASSERT(file-&gt;get_header_file_unparsing_optimization_source_file() == false);</span></a>
<a name="2192"><span class="lineNum">    2192 </span><span class="lineCov">        353 :                     ROSE_ASSERT(file-&gt;get_header_file_unparsing_optimization_header_file() == false);</span></a>
<a name="2193"><span class="lineNum">    2193 </span>            : #if 0</a>
<a name="2194"><span class="lineNum">    2194 </span>            :                     printf (&quot;In SgProject::parse(): DONE: Calling secondaryPassOverSourceFile() \n&quot;);</a>
<a name="2195"><span class="lineNum">    2195 </span>            : #endif</a>
<a name="2196"><span class="lineNum">    2196 </span>            :                   }</a>
<a name="2197"><span class="lineNum">    2197 </span>            :                  else</a>
<a name="2198"><span class="lineNum">    2198 </span>            :                   {</a>
<a name="2199"><span class="lineNum">    2199 </span>            : #if 0</a>
<a name="2200"><span class="lineNum">    2200 </span>            :                     printf (&quot;Skipping the call to secondaryPassOverSourceFile() \n&quot;);</a>
<a name="2201"><span class="lineNum">    2201 </span>            : #endif</a>
<a name="2202"><span class="lineNum">    2202 </span>            :                   }</a>
<a name="2203"><span class="lineNum">    2203 </span>            : #if 0</a>
<a name="2204"><span class="lineNum">    2204 </span>            :                printf (&quot;Exiting after test! \n&quot;);</a>
<a name="2205"><span class="lineNum">    2205 </span>            :                ROSE_ABORT();</a>
<a name="2206"><span class="lineNum">    2206 </span>            : #endif</a>
<a name="2207"><span class="lineNum">    2207 </span>            :              }</a>
<a name="2208"><span class="lineNum">    2208 </span>            :         }</a>
<a name="2209"><span class="lineNum">    2209 </span>            : </a>
<a name="2210"><span class="lineNum">    2210 </span><span class="lineCov">        352 :      if (errorCode != 0)</span></a>
<a name="2211"><span class="lineNum">    2211 </span>            :         {</a>
<a name="2212"><span class="lineNum">    2212 </span>            :           return errorCode;</a>
<a name="2213"><span class="lineNum">    2213 </span>            :         }</a>
<a name="2214"><span class="lineNum">    2214 </span>            : </a>
<a name="2215"><span class="lineNum">    2215 </span>            : #if 0</a>
<a name="2216"><span class="lineNum">    2216 </span>            :      printf (&quot;Exiting after test! \n&quot;);</a>
<a name="2217"><span class="lineNum">    2217 </span>            :      ROSE_ABORT();</a>
<a name="2218"><span class="lineNum">    2218 </span>            : #endif</a>
<a name="2219"><span class="lineNum">    2219 </span>            : </a>
<a name="2220"><span class="lineNum">    2220 </span>            :   // negara1 (06/23/2011): Collect information about the included files to support unparsing of those that are modified.</a>
<a name="2221"><span class="lineNum">    2221 </span>            :   // In the second step (after preprocessing infos are already attached), collect the including files map.</a>
<a name="2222"><span class="lineNum">    2222 </span>            :   // Proceed only if there are input files and they require header files unparsing.</a>
<a name="2223"><span class="lineNum">    2223 </span><span class="lineCov">        352 :      if (!get_fileList().empty() &amp;&amp; (*get_fileList().begin())-&gt;get_unparseHeaderFiles())</span></a>
<a name="2224"><span class="lineNum">    2224 </span>            :         {</a>
<a name="2225"><span class="lineNum">    2225 </span><span class="lineNoCov">          0 :           CompilerOutputParser compilerOutputParser(this);</span></a>
<a name="2226"><span class="lineNum">    2226 </span><span class="lineNoCov">          0 :           const map&lt;string, set&lt;string&gt; &gt;&amp; includedFilesMap = compilerOutputParser.collectIncludedFilesMap();</span></a>
<a name="2227"><span class="lineNum">    2227 </span>            : #if 0</a>
<a name="2228"><span class="lineNum">    2228 </span>            :           printf (&quot;includedFilesMap.size() = %zu \n&quot;,includedFilesMap.size());</a>
<a name="2229"><span class="lineNum">    2229 </span>            :           map&lt;string, set&lt;string&gt; &gt;::const_iterator i = includedFilesMap.begin();</a>
<a name="2230"><span class="lineNum">    2230 </span>            :           while (i != includedFilesMap.end())</a>
<a name="2231"><span class="lineNum">    2231 </span>            :             {</a>
<a name="2232"><span class="lineNum">    2232 </span>            :               printf (&quot; --- includedFilesMap: i.first = %s i.second.size() = %zu \n&quot;,i-&gt;first.c_str(),i-&gt;second.size());</a>
<a name="2233"><span class="lineNum">    2233 </span>            :               set&lt;string&gt;::const_iterator ii = i-&gt;second.begin();</a>
<a name="2234"><span class="lineNum">    2234 </span>            :               while (ii != i-&gt;second.end())</a>
<a name="2235"><span class="lineNum">    2235 </span>            :                  {</a>
<a name="2236"><span class="lineNum">    2236 </span>            :                    printf (&quot; --- --- includedFilesMap: i.second element = %s \n&quot;,ii-&gt;c_str());</a>
<a name="2237"><span class="lineNum">    2237 </span>            :                    ii++;</a>
<a name="2238"><span class="lineNum">    2238 </span>            :                  }</a>
<a name="2239"><span class="lineNum">    2239 </span>            :               i++;</a>
<a name="2240"><span class="lineNum">    2240 </span>            :             }</a>
<a name="2241"><span class="lineNum">    2241 </span>            : #endif</a>
<a name="2242"><span class="lineNum">    2242 </span><span class="lineNoCov">          0 :           IncludingPreprocessingInfosCollector includingPreprocessingInfosCollector(this, includedFilesMap);</span></a>
<a name="2243"><span class="lineNum">    2243 </span><span class="lineNoCov">          0 :           const map&lt;string, set&lt;PreprocessingInfo*&gt; &gt;&amp; includingPreprocessingInfosMap = includingPreprocessingInfosCollector.collect();</span></a>
<a name="2244"><span class="lineNum">    2244 </span>            : #if 0</a>
<a name="2245"><span class="lineNum">    2245 </span>            :           printf (&quot;includingPreprocessingInfosMap.size() = %zu \n&quot;,includingPreprocessingInfosMap.size());</a>
<a name="2246"><span class="lineNum">    2246 </span>            :           map&lt;string, set&lt;PreprocessingInfo*&gt; &gt;::const_iterator j = includingPreprocessingInfosMap.begin();</a>
<a name="2247"><span class="lineNum">    2247 </span>            :           while (j != includingPreprocessingInfosMap.end())</a>
<a name="2248"><span class="lineNum">    2248 </span>            :             {</a>
<a name="2249"><span class="lineNum">    2249 </span>            :               printf (&quot; --- includingPreprocessingInfosMap: j.first = %s j.second.size() = %zu \n&quot;,j-&gt;first.c_str(),j-&gt;second.size());</a>
<a name="2250"><span class="lineNum">    2250 </span>            :               set&lt;PreprocessingInfo*&gt;::const_iterator jj = j-&gt;second.begin();</a>
<a name="2251"><span class="lineNum">    2251 </span>            :               while (jj != j-&gt;second.end())</a>
<a name="2252"><span class="lineNum">    2252 </span>            :                  {</a>
<a name="2253"><span class="lineNum">    2253 </span>            :                    ASSERT_not_null(*jj);</a>
<a name="2254"><span class="lineNum">    2254 </span>            :                    printf (&quot; --- --- includingPreprocessingInfosMap: j.second element-&gt;get_string() = %s \n&quot;,(*jj)-&gt;getString().c_str());</a>
<a name="2255"><span class="lineNum">    2255 </span>            :                    jj++;</a>
<a name="2256"><span class="lineNum">    2256 </span>            :                  }</a>
<a name="2257"><span class="lineNum">    2257 </span>            :               j++;</a>
<a name="2258"><span class="lineNum">    2258 </span>            :             }</a>
<a name="2259"><span class="lineNum">    2259 </span>            : #endif</a>
<a name="2260"><span class="lineNum">    2260 </span><span class="lineNoCov">          0 :           set_includingPreprocessingInfosMap(includingPreprocessingInfosMap);</span></a>
<a name="2261"><span class="lineNum">    2261 </span>            : </a>
<a name="2262"><span class="lineNum">    2262 </span><span class="lineNoCov">          0 :           if (SgProject::get_verbose() &gt;= 1)</span></a>
<a name="2263"><span class="lineNum">    2263 </span>            :              {</a>
<a name="2264"><span class="lineNum">    2264 </span><span class="lineNoCov">          0 :                printf (&quot;\nOutput info for unparse headers support: \n&quot;);</span></a>
<a name="2265"><span class="lineNum">    2265 </span><span class="lineNoCov">          0 :                CollectionHelper::printMapOfSets(includedFilesMap, &quot;\nIncluded files map:&quot;, &quot;File:&quot;, &quot;Included file:&quot;);</span></a>
<a name="2266"><span class="lineNum">    2266 </span><span class="lineNoCov">          0 :                CollectionHelper::printMapOfSets(get_includingPreprocessingInfosMap(), &quot;\nIncluding files map:&quot;, &quot;File:&quot;, &quot;Including file:&quot;);</span></a>
<a name="2267"><span class="lineNum">    2267 </span>            :              }</a>
<a name="2268"><span class="lineNum">    2268 </span>            : </a>
<a name="2269"><span class="lineNum">    2269 </span>            : #if 0</a>
<a name="2270"><span class="lineNum">    2270 </span>            :        // DQ (4/24/2021): This may be where we need to support the non-optimized header file unparsing, and process ALL header files.</a>
<a name="2271"><span class="lineNum">    2271 </span>            :           printf (&quot;This may be where we need to support the non optimized header file unparsing, and process ALL header files \n&quot;);</a>
<a name="2272"><span class="lineNum">    2272 </span>            : #endif</a>
<a name="2273"><span class="lineNum">    2273 </span>            : #if 0</a>
<a name="2274"><span class="lineNum">    2274 </span>            :           for (SgFile* file : files)</a>
<a name="2275"><span class="lineNum">    2275 </span>            :              {</a>
<a name="2276"><span class="lineNum">    2276 </span>            :                printf (&quot;file = %s \n&quot;,file-&gt;getFileName().c_str());</a>
<a name="2277"><span class="lineNum">    2277 </span>            :                printf (&quot; --- file-&gt;get_header_file_unparsing_optimization()             = %s \n&quot;,file-&gt;get_header_file_unparsing_optimization() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="2278"><span class="lineNum">    2278 </span>            :                printf (&quot; --- file-&gt;get_header_file_unparsing_optimization_source_file() = %s \n&quot;,file-&gt;get_header_file_unparsing_optimization_source_file() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="2279"><span class="lineNum">    2279 </span>            :                printf (&quot; --- file-&gt;get_header_file_unparsing_optimization_header_file() = %s \n&quot;,file-&gt;get_header_file_unparsing_optimization_header_file() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="2280"><span class="lineNum">    2280 </span>            :              }</a>
<a name="2281"><span class="lineNum">    2281 </span>            : #endif</a>
<a name="2282"><span class="lineNum">    2282 </span>            :        // ROSE_ASSERT(file-&gt;get_header_file_unparsing_optimization() == true);</a>
<a name="2283"><span class="lineNum">    2283 </span>            :        // ROSE_ASSERT(file-&gt;get_header_file_unparsing_optimization_source_file() == false);</a>
<a name="2284"><span class="lineNum">    2284 </span>            :        // ROSE_ASSERT(file-&gt;get_header_file_unparsing_optimization_header_file() == false);</a>
<a name="2285"><span class="lineNum">    2285 </span>            : </a>
<a name="2286"><span class="lineNum">    2286 </span>            :        // DQ (4/25/2021): Adding code to process header files when file-&gt;get_header_file_unparsing_optimization() == false.</a>
<a name="2287"><span class="lineNum">    2287 </span><span class="lineNoCov">          0 :           if (SgFile::get_header_file_unparsing_optimization() == false)</span></a>
<a name="2288"><span class="lineNum">    2288 </span>            :              {</a>
<a name="2289"><span class="lineNum">    2289 </span><span class="lineNoCov">          0 :                std::map&lt;std::string, SgIncludeFile*&gt;::iterator i = EDG_ROSE_Translation::edg_include_file_map.begin();</span></a>
<a name="2290"><span class="lineNum">    2290 </span><span class="lineNoCov">          0 :                while (i != EDG_ROSE_Translation::edg_include_file_map.end())</span></a>
<a name="2291"><span class="lineNum">    2291 </span>            :                   {</a>
<a name="2292"><span class="lineNum">    2292 </span><span class="lineNoCov">          0 :                     string filename = i-&gt;first;</span></a>
<a name="2293"><span class="lineNum">    2293 </span>            : #if 0</a>
<a name="2294"><span class="lineNum">    2294 </span>            :                     printf (&quot;filename = %s \n&quot;,filename.c_str());</a>
<a name="2295"><span class="lineNum">    2295 </span>            : #endif</a>
<a name="2296"><span class="lineNum">    2296 </span><span class="lineNoCov">          0 :                     SgIncludeFile* include_file = i-&gt;second;</span></a>
<a name="2297"><span class="lineNum">    2297 </span><span class="lineNoCov">          0 :                     if (include_file != nullptr)</span></a>
<a name="2298"><span class="lineNum">    2298 </span>            :                        {</a>
<a name="2299"><span class="lineNum">    2299 </span>            : #if 0</a>
<a name="2300"><span class="lineNum">    2300 </span>            :                          printf (&quot;include_file = %p filename = %s \n&quot;,include_file,include_file-&gt;get_filename().str());</a>
<a name="2301"><span class="lineNum">    2301 </span>            : #endif</a>
<a name="2302"><span class="lineNum">    2302 </span><span class="lineNoCov">          0 :                          SgSourceFile* sourceFile = include_file-&gt;get_source_file();</span></a>
<a name="2303"><span class="lineNum">    2303 </span><span class="lineNoCov">          0 :                          if (sourceFile != nullptr)</span></a>
<a name="2304"><span class="lineNum">    2304 </span>            :                             {</a>
<a name="2305"><span class="lineNum">    2305 </span>            : #if 0</a>
<a name="2306"><span class="lineNum">    2306 </span>            :                               printf (&quot;sourceFile = %p filename = %s \n&quot;,sourceFile,sourceFile-&gt;getFileName().c_str());</a>
<a name="2307"><span class="lineNum">    2307 </span>            :                               printf (&quot;unparse_using_tokens = %s \n&quot;,unparse_using_tokens ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="2308"><span class="lineNum">    2308 </span>            :                               printf (&quot;sourceFile-&gt;get_unparse_tokens() = %s \n&quot;,sourceFile-&gt;get_unparse_tokens() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="2309"><span class="lineNum">    2309 </span>            : #endif</a>
<a name="2310"><span class="lineNum">    2310 </span><span class="lineNoCov">          0 :                               if (sourceFile-&gt;get_unparse_tokens() == false &amp;&amp; unparse_using_tokens == true)</span></a>
<a name="2311"><span class="lineNum">    2311 </span>            :                                  {</a>
<a name="2312"><span class="lineNum">    2312 </span>            : #if 0</a>
<a name="2313"><span class="lineNum">    2313 </span>            :                                    printf (&quot;Setting sourceFile-&gt;set_unparse_tokens(true) \n&quot;);</a>
<a name="2314"><span class="lineNum">    2314 </span>            : #endif</a>
<a name="2315"><span class="lineNum">    2315 </span><span class="lineNoCov">          0 :                                    sourceFile-&gt;set_unparse_tokens(true);</span></a>
<a name="2316"><span class="lineNum">    2316 </span>            :                                  }</a>
<a name="2317"><span class="lineNum">    2317 </span><span class="lineNoCov">          0 :                               ROSE_ASSERT(sourceFile-&gt;get_unparse_tokens() == unparse_using_tokens);</span></a>
<a name="2318"><span class="lineNum">    2318 </span>            : </a>
<a name="2319"><span class="lineNum">    2319 </span><span class="lineNoCov">          0 :                               sourceFile-&gt;secondaryPassOverSourceFile();</span></a>
<a name="2320"><span class="lineNum">    2320 </span>            :                             }</a>
<a name="2321"><span class="lineNum">    2321 </span>            :                            else</a>
<a name="2322"><span class="lineNum">    2322 </span>            :                             {</a>
<a name="2323"><span class="lineNum">    2323 </span>            : #if 0</a>
<a name="2324"><span class="lineNum">    2324 </span>            :                               printf (&quot;sourceFile == NULL \n&quot;);</a>
<a name="2325"><span class="lineNum">    2325 </span>            : #endif</a>
<a name="2326"><span class="lineNum">    2326 </span>            :                             }</a>
<a name="2327"><span class="lineNum">    2327 </span>            :                        }</a>
<a name="2328"><span class="lineNum">    2328 </span>            : </a>
<a name="2329"><span class="lineNum">    2329 </span><span class="lineNoCov">          0 :                     i++;</span></a>
<a name="2330"><span class="lineNum">    2330 </span>            :                   }</a>
<a name="2331"><span class="lineNum">    2331 </span>            : </a>
<a name="2332"><span class="lineNum">    2332 </span>            : #if 0</a>
<a name="2333"><span class="lineNum">    2333 </span>            :             // DQ (4/24/2021): Testing for case of non-optimized header file unparsing, need to process ALL header files.</a>
<a name="2334"><span class="lineNum">    2334 </span>            :                printf (&quot;In SgFile::parse(): file-&gt;get_header_file_unparsing_optimization() == false: Exiting as a test! \n&quot;);</a>
<a name="2335"><span class="lineNum">    2335 </span>            :                ROSE_ABORT();</a>
<a name="2336"><span class="lineNum">    2336 </span>            : #endif</a>
<a name="2337"><span class="lineNum">    2337 </span>            :              }</a>
<a name="2338"><span class="lineNum">    2338 </span>            : </a>
<a name="2339"><span class="lineNum">    2339 </span>            : #if 0</a>
<a name="2340"><span class="lineNum">    2340 </span>            :        // DQ (4/24/2021): Testing for case of non-optimized header file unparsing, need to process ALL header files.</a>
<a name="2341"><span class="lineNum">    2341 </span>            :           printf (&quot;Exiting as a test! \n&quot;);</a>
<a name="2342"><span class="lineNum">    2342 </span>            :           ROSE_ABORT();</a>
<a name="2343"><span class="lineNum">    2343 </span>            : #endif</a>
<a name="2344"><span class="lineNum">    2344 </span>            :         }</a>
<a name="2345"><span class="lineNum">    2345 </span>            : </a>
<a name="2346"><span class="lineNum">    2346 </span>            : #if 0</a>
<a name="2347"><span class="lineNum">    2347 </span>            :      printf (&quot;Skipping processing of token stream for header files in the parse() function (should be moved to be consistent with attaching comments and CPP directives to header files) \n&quot;);</a>
<a name="2348"><span class="lineNum">    2348 </span>            : </a>
<a name="2349"><span class="lineNum">    2349 </span>            :   // DQ (8/18/2019): Test if we are calling this parsing support (which had dependence on the SgIncludeFile IR nodes.</a>
<a name="2350"><span class="lineNum">    2350 </span>            :      printf (&quot;Exiting after test! \n&quot;);</a>
<a name="2351"><span class="lineNum">    2351 </span>            :      ROSE_ABORT();</a>
<a name="2352"><span class="lineNum">    2352 </span>            : #endif</a>
<a name="2353"><span class="lineNum">    2353 </span>            : </a>
<a name="2354"><span class="lineNum">    2354 </span><span class="lineCov">        352 :      if ( get_verbose() &gt; 0 )</span></a>
<a name="2355"><span class="lineNum">    2355 </span>            :         {</a>
<a name="2356"><span class="lineNum">    2356 </span>            :        // Report the error code if it is non-zero (but only in verbose mode)</a>
<a name="2357"><span class="lineNum">    2357 </span>            :           if (errorCode &gt; 0)</a>
<a name="2358"><span class="lineNum">    2358 </span>            :              {</a>
<a name="2359"><span class="lineNum">    2359 </span>            :                printf (&quot;Frontend Warnings only: errorCode = %d \n&quot;,errorCode);</a>
<a name="2360"><span class="lineNum">    2360 </span>            :                if (errorCode &gt; 3)</a>
<a name="2361"><span class="lineNum">    2361 </span>            :                   {</a>
<a name="2362"><span class="lineNum">    2362 </span><span class="lineCov">        352 :                     printf (&quot;Frontend Errors found: errorCode = %d \n&quot;,errorCode);</span></a>
<a name="2363"><span class="lineNum">    2363 </span>            :                   }</a>
<a name="2364"><span class="lineNum">    2364 </span>            :              }</a>
<a name="2365"><span class="lineNum">    2365 </span>            :         }</a>
<a name="2366"><span class="lineNum">    2366 </span>            : </a>
<a name="2367"><span class="lineNum">    2367 </span>            :   // warnings from EDG processing are OK but not errors</a>
<a name="2368"><span class="lineNum">    2368 </span><span class="lineCov">        352 :      ROSE_ASSERT (errorCode &lt;= 3);</span></a>
<a name="2369"><span class="lineNum">    2369 </span>            : </a>
<a name="2370"><span class="lineNum">    2370 </span>            :   // if (get_useBackendOnly() == false)</a>
<a name="2371"><span class="lineNum">    2371 </span><span class="lineCov">        352 :      if ( SgProject::get_verbose() &gt;= 1 )</span></a>
<a name="2372"><span class="lineNum">    2372 </span>            :         {</a>
<a name="2373"><span class="lineNum">    2373 </span><span class="lineNoCov">          0 :           cout &lt;&lt; &quot;C++ source(s) parsed. AST generated.&quot; &lt;&lt; endl;</span></a>
<a name="2374"><span class="lineNum">    2374 </span>            :         }</a>
<a name="2375"><span class="lineNum">    2375 </span>            : </a>
<a name="2376"><span class="lineNum">    2376 </span><span class="lineCov">        352 :      if ( get_verbose() &gt; 3 )</span></a>
<a name="2377"><span class="lineNum">    2377 </span>            :         {</a>
<a name="2378"><span class="lineNum">    2378 </span><span class="lineNoCov">          0 :           printf (&quot;In SgProject::parse() (verbose mode ON): \n&quot;);</span></a>
<a name="2379"><span class="lineNum">    2379 </span><span class="lineNoCov">          0 :           display (&quot;In SgProject::parse()&quot;);</span></a>
<a name="2380"><span class="lineNum">    2380 </span>            :         }</a>
<a name="2381"><span class="lineNum">    2381 </span>            : </a>
<a name="2382"><span class="lineNum">    2382 </span>            : #if DEBUG_PARSE</a>
<a name="2383"><span class="lineNum">    2383 </span>            :      printf (&quot;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ \n&quot;);</a>
<a name="2384"><span class="lineNum">    2384 </span>            :      printf (&quot;Leaving SgProject::parse(): errorCode = %d \n&quot;,errorCode);</a>
<a name="2385"><span class="lineNum">    2385 </span>            :      printf (&quot;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ \n&quot;);</a>
<a name="2386"><span class="lineNum">    2386 </span>            : #endif</a>
<a name="2387"><span class="lineNum">    2387 </span>            : </a>
<a name="2388"><span class="lineNum">    2388 </span>            :      return errorCode;</a>
<a name="2389"><span class="lineNum">    2389 </span>            :    } // end parse(;</a>
<a name="2390"><span class="lineNum">    2390 </span>            : </a>
<a name="2391"><span class="lineNum">    2391 </span>            : </a>
<a name="2392"><span class="lineNum">    2392 </span>            : </a>
<a name="2393"><span class="lineNum">    2393 </span>            : //negara1 (07/29/2011)</a>
<a name="2394"><span class="lineNum">    2394 </span>            : //The returned file path is not normalized.</a>
<a name="2395"><span class="lineNum">    2395 </span>            : //TODO: Return the normalized path after the bug in ROSE is fixed. The bug manifests itself when the same header file is included in</a>
<a name="2396"><span class="lineNum">    2396 </span>            : //multiple places using different paths. In such a case, ROSE treats the same file as different files and generates different IDs for them.</a>
<a name="2397"><span class="lineNum">    2397 </span><span class="lineNoCov">          0 : string SgProject::findIncludedFile(PreprocessingInfo* preprocessingInfo) {</span></a>
<a name="2398"><span class="lineNum">    2398 </span><span class="lineNoCov">          0 :     IncludeDirective includeDirective(preprocessingInfo -&gt; getString());</span></a>
<a name="2399"><span class="lineNum">    2399 </span><span class="lineNoCov">          0 :     const string&amp; includedPath = includeDirective.getIncludedPath();</span></a>
<a name="2400"><span class="lineNum">    2400 </span><span class="lineNoCov">          0 :     if (FileHelper::isAbsolutePath(includedPath)) {</span></a>
<a name="2401"><span class="lineNum">    2401 </span>            :         //the path is absolute, so no need to search for the file</a>
<a name="2402"><span class="lineNum">    2402 </span><span class="lineNoCov">          0 :         if (FileHelper::fileExists(includedPath)) {</span></a>
<a name="2403"><span class="lineNum">    2403 </span><span class="lineNoCov">          0 :             return includedPath;</span></a>
<a name="2404"><span class="lineNum">    2404 </span>            :         }</a>
<a name="2405"><span class="lineNum">    2405 </span><span class="lineNoCov">          0 :         return &quot;&quot;; //file does not exist, so return an empty string</span></a>
<a name="2406"><span class="lineNum">    2406 </span>            :     }</a>
<a name="2407"><span class="lineNum">    2407 </span><span class="lineNoCov">          0 :     if (includeDirective.isQuotedInclude()) {</span></a>
<a name="2408"><span class="lineNum">    2408 </span>            :         //start looking from the current folder, then proceed with the quoted includes search paths</a>
<a name="2409"><span class="lineNum">    2409 </span>            :         //TODO: Consider the presence of -I- option, which disables looking in the current folder for quoted includes.</a>
<a name="2410"><span class="lineNum">    2410 </span><span class="lineNoCov">          0 :         string currentFolder = FileHelper::getParentFolder(preprocessingInfo -&gt; get_file_info() -&gt; get_filenameString());</span></a>
<a name="2411"><span class="lineNum">    2411 </span><span class="lineNoCov">          0 :         p_quotedIncludesSearchPaths.insert(p_quotedIncludesSearchPaths.begin(), currentFolder);</span></a>
<a name="2412"><span class="lineNum">    2412 </span><span class="lineNoCov">          0 :         string includedFilePath = FileHelper::getIncludedFilePath(p_quotedIncludesSearchPaths, includedPath);</span></a>
<a name="2413"><span class="lineNum">    2413 </span><span class="lineNoCov">          0 :         p_quotedIncludesSearchPaths.erase(p_quotedIncludesSearchPaths.begin()); //remove the previously inserted current folder (for other files it might be different)</span></a>
<a name="2414"><span class="lineNum">    2414 </span><span class="lineNoCov">          0 :         if (!includedFilePath.empty()) {</span></a>
<a name="2415"><span class="lineNum">    2415 </span><span class="lineNoCov">          0 :             return includedFilePath;</span></a>
<a name="2416"><span class="lineNum">    2416 </span>            :         }</a>
<a name="2417"><span class="lineNum">    2417 </span>            :     }</a>
<a name="2418"><span class="lineNum">    2418 </span>            :     //For bracketed includes and for not yet found quoted includes proceed with the bracketed includes search paths</a>
<a name="2419"><span class="lineNum">    2419 </span><span class="lineNoCov">          0 :     return FileHelper::getIncludedFilePath(p_bracketedIncludesSearchPaths, includedPath);</span></a>
<a name="2420"><span class="lineNum">    2420 </span>            : }</a>
<a name="2421"><span class="lineNum">    2421 </span>            : </a>
<a name="2422"><span class="lineNum">    2422 </span>            : void</a>
<a name="2423"><span class="lineNum">    2423 </span><span class="lineCov">        357 : SgSourceFile::doSetupForConstructor(const vector&lt;string&gt;&amp; argv, SgProject* project)</span></a>
<a name="2424"><span class="lineNum">    2424 </span>            :    {</a>
<a name="2425"><span class="lineNum">    2425 </span>            :   // Call the base class implementation!</a>
<a name="2426"><span class="lineNum">    2426 </span><span class="lineCov">        357 :      SgFile::doSetupForConstructor(argv, project);</span></a>
<a name="2427"><span class="lineNum">    2427 </span><span class="lineCov">        357 :    }</span></a>
<a name="2428"><span class="lineNum">    2428 </span>            : </a>
<a name="2429"><span class="lineNum">    2429 </span>            : void</a>
<a name="2430"><span class="lineNum">    2430 </span><span class="lineNoCov">          0 : SgUnknownFile::doSetupForConstructor(const vector&lt;string&gt;&amp; argv, SgProject* project)</span></a>
<a name="2431"><span class="lineNum">    2431 </span>            :    {</a>
<a name="2432"><span class="lineNum">    2432 </span><span class="lineNoCov">          0 :      SgFile::doSetupForConstructor(argv, project);</span></a>
<a name="2433"><span class="lineNum">    2433 </span><span class="lineNoCov">          0 :    }</span></a>
<a name="2434"><span class="lineNum">    2434 </span>            : </a>
<a name="2435"><span class="lineNum">    2435 </span>            : void</a>
<a name="2436"><span class="lineNum">    2436 </span><span class="lineCov">        357 : SgFile::doSetupForConstructor(const vector&lt;string&gt;&amp; argv, SgProject* project)</span></a>
<a name="2437"><span class="lineNum">    2437 </span>            :    {</a>
<a name="2438"><span class="lineNum">    2438 </span>            :   // JJW 10-26-2007 ensure that this object is not on the stack</a>
<a name="2439"><span class="lineNum">    2439 </span><span class="lineCov">        357 :      preventConstructionOnStack(this);</span></a>
<a name="2440"><span class="lineNum">    2440 </span>            : </a>
<a name="2441"><span class="lineNum">    2441 </span>            : #if 0</a>
<a name="2442"><span class="lineNum">    2442 </span>            :      printf (&quot;!!!!!!!!!!!!!!!!!! Inside of SgFile::doSetupForConstructor() !!!!!!!!!!!!!!! \n&quot;);</a>
<a name="2443"><span class="lineNum">    2443 </span>            : #endif</a>
<a name="2444"><span class="lineNum">    2444 </span>            : </a>
<a name="2445"><span class="lineNum">    2445 </span>            :   // Set the project early in the construction phase so that we can access data in</a>
<a name="2446"><span class="lineNum">    2446 </span>            :   // the parent if needed (useful for template handling but also makes sure the parent is</a>
<a name="2447"><span class="lineNum">    2447 </span>            :   // set (and avoids fixup (currently done, but too late in the construction process for</a>
<a name="2448"><span class="lineNum">    2448 </span>            :   // the template support).</a>
<a name="2449"><span class="lineNum">    2449 </span><span class="lineCov">        357 :      if (project != nullptr)</span></a>
<a name="2450"><span class="lineNum">    2450 </span><span class="lineCov">        357 :           set_parent(project);</span></a>
<a name="2451"><span class="lineNum">    2451 </span>            : </a>
<a name="2452"><span class="lineNum">    2452 </span><span class="lineCov">        357 :      ASSERT_not_null(project);</span></a>
<a name="2453"><span class="lineNum">    2453 </span><span class="lineCov">        357 :      ASSERT_not_null(get_parent());</span></a>
<a name="2454"><span class="lineNum">    2454 </span>            : </a>
<a name="2455"><span class="lineNum">    2455 </span>            :   // initalize all local variables to default values</a>
<a name="2456"><span class="lineNum">    2456 </span><span class="lineCov">        357 :      initialization();</span></a>
<a name="2457"><span class="lineNum">    2457 </span>            : </a>
<a name="2458"><span class="lineNum">    2458 </span><span class="lineCov">        357 :      ASSERT_not_null(get_parent());</span></a>
<a name="2459"><span class="lineNum">    2459 </span>            : </a>
<a name="2460"><span class="lineNum">    2460 </span>            :   // DQ (2/4/2009): The specification of &quot;-rose:binary&quot; causes filenames to be interpreted</a>
<a name="2461"><span class="lineNum">    2461 </span>            :   // differently if they are object files or libary archive files.</a>
<a name="2462"><span class="lineNum">    2462 </span>            :   // DQ (4/21/2006): Setup the source filename as early as possible</a>
<a name="2463"><span class="lineNum">    2463 </span>            :   // setupSourceFilename(argv);</a>
<a name="2464"><span class="lineNum">    2464 </span>            :   // Rose_STL_Container&lt;string&gt; fileList = CommandlineProcessing::generateSourceFilenames(argv);</a>
<a name="2465"><span class="lineNum">    2465 </span>            :   // Rose_STL_Container&lt;string&gt; fileList = CommandlineProcessing::generateSourceFilenames(argv,get_binary_only());</a>
<a name="2466"><span class="lineNum">    2466 </span><span class="lineCov">        357 :      Rose_STL_Container&lt;string&gt; fileList = CommandlineProcessing::generateSourceFilenames(argv,project-&gt;get_binary_only());</span></a>
<a name="2467"><span class="lineNum">    2467 </span>            : </a>
<a name="2468"><span class="lineNum">    2468 </span>            :   // DQ (12/23/2008): Use of this assertion will simplify the code below!</a>
<a name="2469"><span class="lineNum">    2469 </span><span class="lineCov">        357 :      ROSE_ASSERT (fileList.empty() == false);</span></a>
<a name="2470"><span class="lineNum">    2470 </span><span class="lineCov">        714 :      string sourceFilename = *(fileList.begin());</span></a>
<a name="2471"><span class="lineNum">    2471 </span>            : </a>
<a name="2472"><span class="lineNum">    2472 </span>            :   // printf (&quot;Before conversion to absolute path: sourceFilename = %s \n&quot;,sourceFilename.c_str());</a>
<a name="2473"><span class="lineNum">    2473 </span>            :   // sourceFilename = StringUtility::getAbsolutePathFromRelativePath(sourceFilename);</a>
<a name="2474"><span class="lineNum">    2474 </span><span class="lineCov">        357 :      sourceFilename = StringUtility::getAbsolutePathFromRelativePath(sourceFilename, true);</span></a>
<a name="2475"><span class="lineNum">    2475 </span>            : </a>
<a name="2476"><span class="lineNum">    2476 </span><span class="lineCov">        714 :      set_sourceFileNameWithPath(sourceFilename);</span></a>
<a name="2477"><span class="lineNum">    2477 </span>            : </a>
<a name="2478"><span class="lineNum">    2478 </span>            :   // printf (&quot;In SgFile::setupSourceFilename(const vector&lt;string&gt;&amp; argv): p_sourceFileNameWithPath = %s \n&quot;,get_sourceFileNameWithPath().c_str());</a>
<a name="2479"><span class="lineNum">    2479 </span>            :   // tps: 08/18/2010, This should call StringUtility for WINDOWS- there are two implementations of this?</a>
<a name="2480"><span class="lineNum">    2480 </span>            :   // set_sourceFileNameWithoutPath( Rose::utility_stripPathFromFileName(get_sourceFileNameWithPath().c_str()) );</a>
<a name="2481"><span class="lineNum">    2481 </span><span class="lineCov">       1071 :      set_sourceFileNameWithoutPath( StringUtility::stripPathFromFileName(get_sourceFileNameWithPath().c_str()) );</span></a>
<a name="2482"><span class="lineNum">    2482 </span>            : </a>
<a name="2483"><span class="lineNum">    2483 </span><span class="lineCov">        357 :      initializeSourcePosition(sourceFilename);</span></a>
<a name="2484"><span class="lineNum">    2484 </span><span class="lineCov">        357 :      ASSERT_not_null(get_file_info());</span></a>
<a name="2485"><span class="lineNum">    2485 </span>            : </a>
<a name="2486"><span class="lineNum">    2486 </span>            :   // printf (&quot;In SgFile::doSetupForConstructor(): source position set for sourceFilename = %s \n&quot;,sourceFilename.c_str());</a>
<a name="2487"><span class="lineNum">    2487 </span>            : </a>
<a name="2488"><span class="lineNum">    2488 </span>            :   // DQ (5/9/2007): Moved this call from above to where the file name is available so that we could include</a>
<a name="2489"><span class="lineNum">    2489 </span>            :   // the filename in the label.  This helps to identify the performance data with individual files where</a>
<a name="2490"><span class="lineNum">    2490 </span>            :   // multiple source files are specificed on the command line.</a>
<a name="2491"><span class="lineNum">    2491 </span>            :   // printf (&quot;p_sourceFileNameWithPath = %s \n&quot;,p_sourceFileNameWithPath);</a>
<a name="2492"><span class="lineNum">    2492 </span><span class="lineCov">        714 :      string timerLabel = &quot;AST SgFile Constructor for &quot; + p_sourceFileNameWithPath + &quot;:&quot;;</span></a>
<a name="2493"><span class="lineNum">    2493 </span><span class="lineCov">       1071 :      TimingPerformance timer (timerLabel);</span></a>
<a name="2494"><span class="lineNum">    2494 </span>            : </a>
<a name="2495"><span class="lineNum">    2495 </span>            :   // Build a DEEP COPY of the input parameters!</a>
<a name="2496"><span class="lineNum">    2496 </span><span class="lineCov">        714 :      vector&lt;string&gt; local_commandLineArgumentList = argv;</span></a>
<a name="2497"><span class="lineNum">    2497 </span>            : </a>
<a name="2498"><span class="lineNum">    2498 </span>            :   // Save the commandline as a list of strings (we made a deep copy because the &quot;callFrontEnd()&quot; function might change it!</a>
<a name="2499"><span class="lineNum">    2499 </span><span class="lineCov">        357 :      set_originalCommandLineArgumentList( local_commandLineArgumentList );</span></a>
<a name="2500"><span class="lineNum">    2500 </span>            : </a>
<a name="2501"><span class="lineNum">    2501 </span>            :   // DQ (5/22/2005): Store the file name index in the SgFile object so that it can figure out</a>
<a name="2502"><span class="lineNum">    2502 </span>            :   // which file name applies to it.  This helps support functions such as &quot;get_filename()&quot;</a>
<a name="2503"><span class="lineNum">    2503 </span>            :   // used elsewhere in Sage III.  Not clear if we really need this!</a>
<a name="2504"><span class="lineNum">    2504 </span>            :   // error checking</a>
<a name="2505"><span class="lineNum">    2505 </span><span class="lineCov">        357 :      ROSE_ASSERT (argv.size() &gt; 1);</span></a>
<a name="2506"><span class="lineNum">    2506 </span>            : </a>
<a name="2507"><span class="lineNum">    2507 </span><span class="lineCov">        357 :      ASSERT_not_null(get_file_info());</span></a>
<a name="2508"><span class="lineNum">    2508 </span><span class="lineCov">        357 :      ASSERT_not_null(get_startOfConstruct());</span></a>
<a name="2509"><span class="lineNum">    2509 </span>            : </a>
<a name="2510"><span class="lineNum">    2510 </span>            :   // DQ (6/13/2013): Added to support error checking (seperation of construction of SgFile IR nodes from calling the fronend on each one).</a>
<a name="2511"><span class="lineNum">    2511 </span><span class="lineCov">        357 :      ASSERT_not_null(get_parent());</span></a>
<a name="2512"><span class="lineNum">    2512 </span><span class="lineCov">        357 :      ROSE_ASSERT(get_parent() == project);</span></a>
<a name="2513"><span class="lineNum">    2513 </span>            : </a>
<a name="2514"><span class="lineNum">    2514 </span>            : #if 0</a>
<a name="2515"><span class="lineNum">    2515 </span>            :      printf (&quot;Leaving  SgFile::doSetupForConstructor() \n&quot;);</a>
<a name="2516"><span class="lineNum">    2516 </span>            : #endif</a>
<a name="2517"><span class="lineNum">    2517 </span><span class="lineCov">        357 :    }</span></a>
<a name="2518"><span class="lineNum">    2518 </span>            : </a>
<a name="2519"><span class="lineNum">    2519 </span>            : </a>
<a name="2520"><span class="lineNum">    2520 </span>            : string</a>
<a name="2521"><span class="lineNum">    2521 </span><span class="lineNoCov">          0 : SgFile::generate_C_preprocessor_intermediate_filename( string sourceFilename )</span></a>
<a name="2522"><span class="lineNum">    2522 </span>            :    {</a>
<a name="2523"><span class="lineNum">    2523 </span>            :   // DQ (9/24/2013): We need this assertion to make sure we are not causing what might be strange errors in memory.</a>
<a name="2524"><span class="lineNum">    2524 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(sourceFilename.empty() == false);</span></a>
<a name="2525"><span class="lineNum">    2525 </span>            : </a>
<a name="2526"><span class="lineNum">    2526 </span>            :   // Note: for &quot;foo.F90&quot; the fileNameSuffix() returns &quot;F90&quot;</a>
<a name="2527"><span class="lineNum">    2527 </span><span class="lineNoCov">          0 :      string filenameExtension              = StringUtility::fileNameSuffix(sourceFilename);</span></a>
<a name="2528"><span class="lineNum">    2528 </span>            : </a>
<a name="2529"><span class="lineNum">    2529 </span>            :   // DQ (9/24/2013): We need this assertion to make sure we are not causing what might be strange errors in memory.</a>
<a name="2530"><span class="lineNum">    2530 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(filenameExtension.empty() == false);</span></a>
<a name="2531"><span class="lineNum">    2531 </span>            : </a>
<a name="2532"><span class="lineNum">    2532 </span><span class="lineNoCov">          0 :      string sourceFileNameWithoutExtension = StringUtility::stripFileSuffixFromFileName(sourceFilename);</span></a>
<a name="2533"><span class="lineNum">    2533 </span>            : </a>
<a name="2534"><span class="lineNum">    2534 </span>            :   // DQ (9/24/2013): We need this assertion to make sure we are not causing what might be strange errors in memory.</a>
<a name="2535"><span class="lineNum">    2535 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(sourceFileNameWithoutExtension.empty() == false);</span></a>
<a name="2536"><span class="lineNum">    2536 </span>            : </a>
<a name="2537"><span class="lineNum">    2537 </span>            :   // string sourceFileNameInputToCpp = get_sourceFileNameWithPath();</a>
<a name="2538"><span class="lineNum">    2538 </span>            : #if 0</a>
<a name="2539"><span class="lineNum">    2539 </span>            :      printf (&quot;In SgFile::generate_C_preprocessor_intermediate_filename(): Before lowering case: filenameExtension = %s \n&quot;,filenameExtension.c_str());</a>
<a name="2540"><span class="lineNum">    2540 </span>            : #endif</a>
<a name="2541"><span class="lineNum">    2541 </span>            : </a>
<a name="2542"><span class="lineNum">    2542 </span>            :   // We need to turn on the 5th bit to make the capital a lower case character (assume ASCII)</a>
<a name="2543"><span class="lineNum">    2543 </span><span class="lineNoCov">          0 :      filenameExtension[0] = filenameExtension[0] | (1 &lt;&lt; 5);</span></a>
<a name="2544"><span class="lineNum">    2544 </span>            : </a>
<a name="2545"><span class="lineNum">    2545 </span>            : #if 0</a>
<a name="2546"><span class="lineNum">    2546 </span>            :      printf (&quot;In SgFile::generate_C_preprocessor_intermediate_filename(): After lowering case: filenameExtension = %s \n&quot;,filenameExtension.c_str());</a>
<a name="2547"><span class="lineNum">    2547 </span>            : #endif</a>
<a name="2548"><span class="lineNum">    2548 </span>            : </a>
<a name="2549"><span class="lineNum">    2549 </span>            :   // Rename the CPP generated intermediate file (strip path to put it in the current directory)</a>
<a name="2550"><span class="lineNum">    2550 </span>            :   // string sourceFileNameOutputFromCpp = sourceFileNameWithoutExtension + &quot;_preprocessed.&quot; + filenameExtension;</a>
<a name="2551"><span class="lineNum">    2551 </span><span class="lineNoCov">          0 :      string sourceFileNameWithoutPathAndWithoutExtension = StringUtility::stripPathFromFileName(sourceFileNameWithoutExtension);</span></a>
<a name="2552"><span class="lineNum">    2552 </span><span class="lineNoCov">          0 :      string sourceFileNameOutputFromCpp = sourceFileNameWithoutPathAndWithoutExtension + &quot;_postprocessed.&quot; + filenameExtension;</span></a>
<a name="2553"><span class="lineNum">    2553 </span>            : </a>
<a name="2554"><span class="lineNum">    2554 </span><span class="lineNoCov">          0 :      return sourceFileNameOutputFromCpp;</span></a>
<a name="2555"><span class="lineNum">    2555 </span>            :    }</a>
<a name="2556"><span class="lineNum">    2556 </span>            : </a>
<a name="2557"><span class="lineNum">    2557 </span>            : </a>
<a name="2558"><span class="lineNum">    2558 </span>            : #ifdef ROSE_BUILD_FORTRAN_LANGUAGE_SUPPORT</a>
<a name="2559"><span class="lineNum">    2559 </span>            : // This is the &quot;C&quot; function implemented in:</a>
<a name="2560"><span class="lineNum">    2560 </span>            : //    ROSE/src/frontend/OpenFortranParser_SAGE_Connection/openFortranParser_main.c</a>
<a name="2561"><span class="lineNum">    2561 </span>            : // This function calls the Java JVM to load the Java implemented parser (written</a>
<a name="2562"><span class="lineNum">    2562 </span>            : // using ANTLR, a parser generator).</a>
<a name="2563"><span class="lineNum">    2563 </span>            : int openFortranParser_main(int argc, char **argv );</a>
<a name="2564"><span class="lineNum">    2564 </span>            : #endif</a>
<a name="2565"><span class="lineNum">    2565 </span>            : </a>
<a name="2566"><span class="lineNum">    2566 </span>            : int</a>
<a name="2567"><span class="lineNum">    2567 </span><span class="lineCov">        357 : SgFile::callFrontEnd()</span></a>
<a name="2568"><span class="lineNum">    2568 </span>            :    {</a>
<a name="2569"><span class="lineNum">    2569 </span><span class="lineCov">        357 :      if (SgProject::get_verbose() &gt; 0)</span></a>
<a name="2570"><span class="lineNum">    2570 </span>            :         {</a>
<a name="2571"><span class="lineNum">    2571 </span><span class="lineNoCov">          0 :           std::cout &lt;&lt; &quot;[INFO] [SgFile::callFrontEnd]&quot; &lt;&lt; std::endl;</span></a>
<a name="2572"><span class="lineNum">    2572 </span>            :         }</a>
<a name="2573"><span class="lineNum">    2573 </span>            : </a>
<a name="2574"><span class="lineNum">    2574 </span>            :   // DQ (1/17/2006): test this</a>
<a name="2575"><span class="lineNum">    2575 </span>            :   // ROSE_ASSERT(get_fileInfo() != NULL);</a>
<a name="2576"><span class="lineNum">    2576 </span>            : </a>
<a name="2577"><span class="lineNum">    2577 </span><span class="lineCov">        357 :      int fileNameIndex = 0;</span></a>
<a name="2578"><span class="lineNum">    2578 </span>            : </a>
<a name="2579"><span class="lineNum">    2579 </span>            :   // DQ (4/21/2006): I think we can now assert this!</a>
<a name="2580"><span class="lineNum">    2580 </span><span class="lineCov">        357 :      ROSE_ASSERT(fileNameIndex == 0);</span></a>
<a name="2581"><span class="lineNum">    2581 </span>            : </a>
<a name="2582"><span class="lineNum">    2582 </span>            :   // DQ (7/6/2005): Introduce tracking of performance of ROSE.</a>
<a name="2583"><span class="lineNum">    2583 </span><span class="lineCov">        714 :      TimingPerformance timer (&quot;AST Front End Processing (SgFile):&quot;);</span></a>
<a name="2584"><span class="lineNum">    2584 </span>            : </a>
<a name="2585"><span class="lineNum">    2585 </span>            :   // This function processes the command line and calls the EDG frontend.</a>
<a name="2586"><span class="lineNum">    2586 </span><span class="lineCov">        357 :      int frontendErrorLevel = 0;</span></a>
<a name="2587"><span class="lineNum">    2587 </span>            : </a>
<a name="2588"><span class="lineNum">    2588 </span>            :   // Build an argc,argv based C style commandline (we might not really need this)</a>
<a name="2589"><span class="lineNum">    2589 </span><span class="lineCov">        357 :      vector&lt;string&gt; argv = get_originalCommandLineArgumentList();</span></a>
<a name="2590"><span class="lineNum">    2590 </span>            : </a>
<a name="2591"><span class="lineNum">    2591 </span>            : #if 0</a>
<a name="2592"><span class="lineNum">    2592 </span>            :      printf (&quot;get_C_only()   = %s \n&quot;,get_C_only() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="2593"><span class="lineNum">    2593 </span>            :      printf (&quot;get_Cxx_only() = %s \n&quot;,get_Cxx_only() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="2594"><span class="lineNum">    2594 </span>            : #endif</a>
<a name="2595"><span class="lineNum">    2595 </span>            : </a>
<a name="2596"><span class="lineNum">    2596 </span>            : #if ROSE_INTERNAL_DEBUG</a>
<a name="2597"><span class="lineNum">    2597 </span>            :      if (ROSE_DEBUG &gt; 9)</a>
<a name="2598"><span class="lineNum">    2598 </span>            :         {</a>
<a name="2599"><span class="lineNum">    2599 </span>            :        // Print out the input arguments, so we can set them up internally instead of</a>
<a name="2600"><span class="lineNum">    2600 </span>            :        // on the command line (which is driving me nuts)</a>
<a name="2601"><span class="lineNum">    2601 </span>            :           for (unsigned int i=0; i &lt; argv.size(); i++)</a>
<a name="2602"><span class="lineNum">    2602 </span>            :                printf (&quot;argv[%d] = %s \n&quot;,i,argv[i]);</a>
<a name="2603"><span class="lineNum">    2603 </span>            :         }</a>
<a name="2604"><span class="lineNum">    2604 </span>            : #endif</a>
<a name="2605"><span class="lineNum">    2605 </span>            : </a>
<a name="2606"><span class="lineNum">    2606 </span>            :   // printf (&quot;Inside of SgFile::callFrontEnd(): fileNameIndex = %d \n&quot;,fileNameIndex);</a>
<a name="2607"><span class="lineNum">    2607 </span>            : </a>
<a name="2608"><span class="lineNum">    2608 </span>            :   // Save this so that it can be used in the template instantiation phase later.</a>
<a name="2609"><span class="lineNum">    2609 </span>            :   // This file is later written into the *.ti file so that the compilation can</a>
<a name="2610"><span class="lineNum">    2610 </span>            :   // be repeated as required to instantiate all function templates.</a>
<a name="2611"><span class="lineNum">    2611 </span><span class="lineCov">        714 :      std::string translatorCommandLineString = CommandlineProcessing::generateStringFromArgList(argv,false,true);</span></a>
<a name="2612"><span class="lineNum">    2612 </span>            : #if 0</a>
<a name="2613"><span class="lineNum">    2613 </span>            :      printf (&quot;translatorCommandLineString = %s \n&quot;,translatorCommandLineString.c_str());</a>
<a name="2614"><span class="lineNum">    2614 </span>            : #endif</a>
<a name="2615"><span class="lineNum">    2615 </span><span class="lineCov">        714 :      set_savedFrontendCommandLine(translatorCommandLineString);</span></a>
<a name="2616"><span class="lineNum">    2616 </span>            : </a>
<a name="2617"><span class="lineNum">    2617 </span>            :   // display(&quot;At TOP of SgFile::callFrontEnd()&quot;);</a>
<a name="2618"><span class="lineNum">    2618 </span>            : </a>
<a name="2619"><span class="lineNum">    2619 </span>            :   // local copies of argc and argv variables</a>
<a name="2620"><span class="lineNum">    2620 </span>            :   // The purpose of building local copies is to avoid</a>
<a name="2621"><span class="lineNum">    2621 </span>            :   // the modification of the command line by SLA</a>
<a name="2622"><span class="lineNum">    2622 </span><span class="lineCov">        714 :      vector&lt;string&gt; localCopy_argv = argv;</span></a>
<a name="2623"><span class="lineNum">    2623 </span>            :   // printf (&quot;DONE with copy of command line! \n&quot;);</a>
<a name="2624"><span class="lineNum">    2624 </span>            : #if 0</a>
<a name="2625"><span class="lineNum">    2625 </span>            :      std::string tmp2_translatorCommandLineString = CommandlineProcessing::generateStringFromArgList(localCopy_argv,false,true);</a>
<a name="2626"><span class="lineNum">    2626 </span>            :      printf (&quot;tmp2_translatorCommandLineString = %s \n&quot;,tmp2_translatorCommandLineString.c_str());</a>
<a name="2627"><span class="lineNum">    2627 </span>            : #endif</a>
<a name="2628"><span class="lineNum">    2628 </span>            :   // Process command line options specific to ROSE</a>
<a name="2629"><span class="lineNum">    2629 </span>            :   // This leaves all filenames and non-rose specific option in the argv list</a>
<a name="2630"><span class="lineNum">    2630 </span><span class="lineCov">        357 :      processRoseCommandLineOptions (localCopy_argv);</span></a>
<a name="2631"><span class="lineNum">    2631 </span>            : #if 0</a>
<a name="2632"><span class="lineNum">    2632 </span>            :      printf (&quot;After processRoseCommandLineOptions(): get_C_only()   = %s \n&quot;,get_C_only() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="2633"><span class="lineNum">    2633 </span>            :      printf (&quot;After processRoseCommandLineOptions(): get_Cxx_only() = %s \n&quot;,get_Cxx_only() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="2634"><span class="lineNum">    2634 </span>            : #endif</a>
<a name="2635"><span class="lineNum">    2635 </span>            :   // DQ (6/21/2005): Process template specific options so that we can generated</a>
<a name="2636"><span class="lineNum">    2636 </span>            :   // code for the backend compiler (this processing is backend specific).</a>
<a name="2637"><span class="lineNum">    2637 </span><span class="lineCov">        357 :      processBackendSpecificCommandLineOptions (localCopy_argv);</span></a>
<a name="2638"><span class="lineNum">    2638 </span>            : #if 0</a>
<a name="2639"><span class="lineNum">    2639 </span>            :      printf (&quot;After processBackendSpecificCommandLineOptions(): get_C_only()   = %s \n&quot;,get_C_only() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="2640"><span class="lineNum">    2640 </span>            :      printf (&quot;After processBackendSpecificCommandLineOptions(): get_Cxx_only() = %s \n&quot;,get_Cxx_only() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="2641"><span class="lineNum">    2641 </span>            : #endif</a>
<a name="2642"><span class="lineNum">    2642 </span>            : #if 0</a>
<a name="2643"><span class="lineNum">    2643 </span>            :      std::string tmp4_translatorCommandLineString = CommandlineProcessing::generateStringFromArgList(localCopy_argv,false,true);</a>
<a name="2644"><span class="lineNum">    2644 </span>            :      printf (&quot;tmp4_translatorCommandLineString = %s \n&quot;,tmp4_translatorCommandLineString.c_str());</a>
<a name="2645"><span class="lineNum">    2645 </span>            : #endif</a>
<a name="2646"><span class="lineNum">    2646 </span>            :   // display(&quot;AFTER processRoseCommandLineOptions in SgFile::callFrontEnd()&quot;);</a>
<a name="2647"><span class="lineNum">    2647 </span>            : </a>
<a name="2648"><span class="lineNum">    2648 </span>            :   // Use ROSE buildCommandLine() function</a>
<a name="2649"><span class="lineNum">    2649 </span>            :   // int numberOfCommandLineArguments = 24;</a>
<a name="2650"><span class="lineNum">    2650 </span>            :   // char** inputCommandLine = new char* [numberOfCommandLineArguments];</a>
<a name="2651"><span class="lineNum">    2651 </span>            :   // ROSE_ASSERT (inputCommandLine != NULL);</a>
<a name="2652"><span class="lineNum">    2652 </span><span class="lineCov">        357 :      vector&lt;string&gt; inputCommandLine;</span></a>
<a name="2653"><span class="lineNum">    2653 </span>            : </a>
<a name="2654"><span class="lineNum">    2654 </span>            : #if 0</a>
<a name="2655"><span class="lineNum">    2655 </span>            :      printf (&quot;Inside of SgFile::callFrontEnd(): Calling build_EDG_CommandLine (fileNameIndex = %d) \n&quot;,fileNameIndex);</a>
<a name="2656"><span class="lineNum">    2656 </span>            : #endif</a>
<a name="2657"><span class="lineNum">    2657 </span>            : </a>
<a name="2658"><span class="lineNum">    2658 </span>            :   // Build the commandline for EDG</a>
<a name="2659"><span class="lineNum">    2659 </span><span class="lineCov">        357 :      if (get_C_only() || get_Cxx_only() || get_Cuda_only() || get_OpenCL_only() )</span></a>
<a name="2660"><span class="lineNum">    2660 </span>            :         {</a>
<a name="2661"><span class="lineNum">    2661 </span>            : #ifdef BACKEND_CXX_IS_CLANG_COMPILER</a>
<a name="2662"><span class="lineNum">    2662 </span>            :    #if ((ROSE_EDG_MAJOR_VERSION_NUMBER == 4) &amp;&amp; (ROSE_EDG_MINOR_VERSION_NUMBER &gt;= 9) ) || (ROSE_EDG_MAJOR_VERSION_NUMBER &gt; 4)</a>
<a name="2663"><span class="lineNum">    2663 </span>            :      // OK, we are supporting Clang using EDG 4.9 and greater.</a>
<a name="2664"><span class="lineNum">    2664 </span>            :    #else</a>
<a name="2665"><span class="lineNum">    2665 </span>            :         printf (&quot;\nERROR: Clang compiler as backend to ROSE is not supported unless using EDG 4.9 version \n&quot;);</a>
<a name="2666"><span class="lineNum">    2666 </span>            :         printf (&quot;       or greater (use --enable-edg_version=4.9 or greater to configure ROSE). \n\n&quot;);</a>
<a name="2667"><span class="lineNum">    2667 </span>            :         exit(1);</a>
<a name="2668"><span class="lineNum">    2668 </span>            :    #endif</a>
<a name="2669"><span class="lineNum">    2669 </span>            : #endif</a>
<a name="2670"><span class="lineNum">    2670 </span>            : </a>
<a name="2671"><span class="lineNum">    2671 </span>            : #ifndef ROSE_USE_CLANG_FRONTEND</a>
<a name="2672"><span class="lineNum">    2672 </span>            :        // printf (&quot;Calling build_EDG_CommandLine() \n&quot;);</a>
<a name="2673"><span class="lineNum">    2673 </span><span class="lineCov">        320 :           build_EDG_CommandLine (inputCommandLine,localCopy_argv,fileNameIndex );</span></a>
<a name="2674"><span class="lineNum">    2674 </span>            : #else</a>
<a name="2675"><span class="lineNum">    2675 </span>            :           build_CLANG_CommandLine (inputCommandLine,localCopy_argv,fileNameIndex );</a>
<a name="2676"><span class="lineNum">    2676 </span>            : #endif</a>
<a name="2677"><span class="lineNum">    2677 </span>            :         }</a>
<a name="2678"><span class="lineNum">    2678 </span>            :        else</a>
<a name="2679"><span class="lineNum">    2679 </span>            :         {</a>
<a name="2680"><span class="lineNum">    2680 </span>            : #if 0</a>
<a name="2681"><span class="lineNum">    2681 </span>            :           printf (&quot;Failed to call build_EDG_CommandLine() (not a C, C++, Cuda, or OpenCL program) \n&quot;);</a>
<a name="2682"><span class="lineNum">    2682 </span>            : #endif</a>
<a name="2683"><span class="lineNum">    2683 </span>            :         }</a>
<a name="2684"><span class="lineNum">    2684 </span>            : </a>
<a name="2685"><span class="lineNum">    2685 </span>            : #if 0</a>
<a name="2686"><span class="lineNum">    2686 </span>            :      printf (&quot;DONE: Inside of SgFile::callFrontEnd(): Calling build_EDG_CommandLine (fileNameIndex = %d) \n&quot;,fileNameIndex);</a>
<a name="2687"><span class="lineNum">    2687 </span>            : #endif</a>
<a name="2688"><span class="lineNum">    2688 </span><span class="lineCov">        714 :      std::string tmp_translatorCommandLineString = CommandlineProcessing::generateStringFromArgList(inputCommandLine,false,true);</span></a>
<a name="2689"><span class="lineNum">    2689 </span>            : #if 0</a>
<a name="2690"><span class="lineNum">    2690 </span>            :      printf (&quot;tmp_translatorCommandLineString = %s \n&quot;,tmp_translatorCommandLineString.c_str());</a>
<a name="2691"><span class="lineNum">    2691 </span>            : #endif</a>
<a name="2692"><span class="lineNum">    2692 </span>            : </a>
<a name="2693"><span class="lineNum">    2693 </span>            :   // DQ (10/15/2005): This is now a single C++ string (and not a list)</a>
<a name="2694"><span class="lineNum">    2694 </span>            :   // Make sure the list of file names is allocated, even if there are no file names in the list.</a>
<a name="2695"><span class="lineNum">    2695 </span>            :   // DQ (1/23/2004): I wish that C++ string objects had been used uniformally through out this code!!!</a>
<a name="2696"><span class="lineNum">    2696 </span>            :   // ROSE_ASSERT (get_sourceFileNamesWithoutPath() != NULL);</a>
<a name="2697"><span class="lineNum">    2697 </span>            :   // ROSE_ASSERT (get_sourceFileNameWithoutPath().empty() == false);</a>
<a name="2698"><span class="lineNum">    2698 </span>            : </a>
<a name="2699"><span class="lineNum">    2699 </span>            :   // display(&quot;AFTER build_EDG_CommandLine in SgFile::callFrontEnd()&quot;);</a>
<a name="2700"><span class="lineNum">    2700 </span>            : </a>
<a name="2701"><span class="lineNum">    2701 </span>            :   // Exit if we are to ONLY call the vendor's backend compiler</a>
<a name="2702"><span class="lineNum">    2702 </span><span class="lineCov">        357 :      if (p_useBackendOnly == true)</span></a>
<a name="2703"><span class="lineNum">    2703 </span>            :         {</a>
<a name="2704"><span class="lineNum">    2704 </span>            : #if 0</a>
<a name="2705"><span class="lineNum">    2705 </span>            :           printf (&quot;############## Exit because we are to ONLY call the vendor's backend compiler \n&quot;);</a>
<a name="2706"><span class="lineNum">    2706 </span>            : #endif</a>
<a name="2707"><span class="lineNum">    2707 </span>            :           return 0;</a>
<a name="2708"><span class="lineNum">    2708 </span>            :         }</a>
<a name="2709"><span class="lineNum">    2709 </span>            : </a>
<a name="2710"><span class="lineNum">    2710 </span><span class="lineCov">        357 :      ROSE_ASSERT (p_useBackendOnly == false);</span></a>
<a name="2711"><span class="lineNum">    2711 </span>            : </a>
<a name="2712"><span class="lineNum">    2712 </span>            :   // DQ (4/21/2006): If we have called the frontend for this SgFile then mark this file to be unparsed.</a>
<a name="2713"><span class="lineNum">    2713 </span>            :   // This will cause code to be generated and the compileOutput() function will then set the name of</a>
<a name="2714"><span class="lineNum">    2714 </span>            :   // the file that the backend (vendor) compiler will compile to be the the intermediate file. Else it</a>
<a name="2715"><span class="lineNum">    2715 </span>            :   // will be set to be the origianl source file.  In the new design, the frontendShell() can be called</a>
<a name="2716"><span class="lineNum">    2716 </span>            :   // to generate just the SgProject and SgFile nodes and we can loop over the SgFile objects and call</a>
<a name="2717"><span class="lineNum">    2717 </span>            :   // the frontend separately for each SgFile.  so we have to set the output file name to be compiled</a>
<a name="2718"><span class="lineNum">    2718 </span>            :   // late in the processing (at backend compile time since we don't know when or if the frontend will</a>
<a name="2719"><span class="lineNum">    2719 </span>            :   // be called for each SgFile).</a>
<a name="2720"><span class="lineNum">    2720 </span>            :   // PP (8/23/2022): Experimental: Do not override the flag from the command line. RC-1381</a>
<a name="2721"><span class="lineNum">    2721 </span>            :   //   set_skip_unparse(false);</a>
<a name="2722"><span class="lineNum">    2722 </span>            : </a>
<a name="2723"><span class="lineNum">    2723 </span><span class="lineCov">        780 :      if ((get_C_only() || get_Cxx_only()) &amp;&amp;</span></a>
<a name="2724"><span class="lineNum">    2724 </span>            :       // DQ (1/22/2004): As I recall this has a name that really</a>
<a name="2725"><span class="lineNum">    2725 </span>            :       // should be &quot;disable_edg&quot; instead of &quot;disable_edg_backend&quot;.</a>
<a name="2726"><span class="lineNum">    2726 </span><span class="lineCov">        743 :           get_disable_edg_backend() == false &amp;&amp; get_new_frontend() == true)</span></a>
<a name="2727"><span class="lineNum">    2727 </span>            :         {</a>
<a name="2728"><span class="lineNum">    2728 </span>            :        // Rose::new_frontend = true;</a>
<a name="2729"><span class="lineNum">    2729 </span>            : </a>
<a name="2730"><span class="lineNum">    2730 </span>            :        // We can either use the newest EDG frontend separately (useful for debugging)</a>
<a name="2731"><span class="lineNum">    2731 </span>            :        // or the EDG frontend that is included in SAGE III (currently EDG 3.3).</a>
<a name="2732"><span class="lineNum">    2732 </span>            :        // New EDG frontend:</a>
<a name="2733"><span class="lineNum">    2733 </span>            :        //      This permits testing with the most up-to-date version of the EDG frontend and</a>
<a name="2734"><span class="lineNum">    2734 </span>            :        //      can be useful in identifing errors or bugs in the SAGE processing (or ROSE itself).</a>
<a name="2735"><span class="lineNum">    2735 </span>            :        // EDG frontend used by SAGE III:</a>
<a name="2736"><span class="lineNum">    2736 </span>            :        //      The use of this frontend permits the continued processing via ROSE and the</a>
<a name="2737"><span class="lineNum">    2737 </span>            :        //      unparsing of the AST to rebuilt the C++ source code (with transformations if any</a>
<a name="2738"><span class="lineNum">    2738 </span>            :        //      were done).</a>
<a name="2739"><span class="lineNum">    2739 </span>            : </a>
<a name="2740"><span class="lineNum">    2740 </span>            :        // DQ (10/15/2005): This is now a C++ string (and not char* C style string)</a>
<a name="2741"><span class="lineNum">    2741 </span>            :        // Make sure that we have generated a proper file name (or move filename</a>
<a name="2742"><span class="lineNum">    2742 </span>            :        // processing to processRoseCommandLineOptions()).</a>
<a name="2743"><span class="lineNum">    2743 </span>            :        // printf (&quot;Print out the file name to make sure it is processed \n&quot;);</a>
<a name="2744"><span class="lineNum">    2744 </span>            :        // printf (&quot;     filename = %s \n&quot;,get_unparse_output_filename());</a>
<a name="2745"><span class="lineNum">    2745 </span>            :        // ROSE_ASSERT (get_unparse_output_filename() != NULL);</a>
<a name="2746"><span class="lineNum">    2746 </span>            :        // ROSE_ASSERT (get_unparse_output_filename().empty() == false);</a>
<a name="2747"><span class="lineNum">    2747 </span>            : </a>
<a name="2748"><span class="lineNum">    2748 </span>            :       // Use the current version of the EDG frontend from EDG (or any other version)</a>
<a name="2749"><span class="lineNum">    2749 </span>            :       // abort();</a>
<a name="2750"><span class="lineNum">    2750 </span><span class="lineNoCov">          0 :          printf (&quot;Rose::new_frontend == true (call edgFrontEnd using unix system() function!) \n&quot;);</span></a>
<a name="2751"><span class="lineNum">    2751 </span>            : </a>
<a name="2752"><span class="lineNum">    2752 </span><span class="lineNoCov">          0 :          std::string frontEndCommandLineString;</span></a>
<a name="2753"><span class="lineNum">    2753 </span><span class="lineNoCov">          0 :          if ( get_KCC_frontend() == true )</span></a>
<a name="2754"><span class="lineNum">    2754 </span>            :             {</a>
<a name="2755"><span class="lineNum">    2755 </span><span class="lineNoCov">          0 :               frontEndCommandLineString = &quot;KCC &quot;;  // -cpfe_only is no longer supported (I think)</span></a>
<a name="2756"><span class="lineNum">    2756 </span>            :             }</a>
<a name="2757"><span class="lineNum">    2757 </span>            :            else</a>
<a name="2758"><span class="lineNum">    2758 </span>            :             {</a>
<a name="2759"><span class="lineNum">    2759 </span>            :            // frontEndCommandLineString = &quot;edgFrontEnd &quot;;</a>
<a name="2760"><span class="lineNum">    2760 </span><span class="lineNoCov">          0 :               frontEndCommandLineString = &quot;edgcpfe --g++ --gnu_version 40201 &quot;;</span></a>
<a name="2761"><span class="lineNum">    2761 </span>            :             }</a>
<a name="2762"><span class="lineNum">    2762 </span><span class="lineNoCov">          0 :          frontEndCommandLineString += CommandlineProcessing::generateStringFromArgList(inputCommandLine,true,false);</span></a>
<a name="2763"><span class="lineNum">    2763 </span>            : </a>
<a name="2764"><span class="lineNum">    2764 </span><span class="lineNoCov">          0 :          if ( get_verbose() &gt; -1 )</span></a>
<a name="2765"><span class="lineNum">    2765 </span><span class="lineNoCov">          0 :               printf (&quot;frontEndCommandLineString = %s \n\n&quot;,frontEndCommandLineString.c_str());</span></a>
<a name="2766"><span class="lineNum">    2766 </span>            : </a>
<a name="2767"><span class="lineNum">    2767 </span>            :       // ROSE_ASSERT (!&quot;Should not get here&quot;);</a>
<a name="2768"><span class="lineNum">    2768 </span><span class="lineNoCov">          0 :          int status = system(frontEndCommandLineString.c_str());</span></a>
<a name="2769"><span class="lineNum">    2769 </span>            : </a>
<a name="2770"><span class="lineNum">    2770 </span><span class="lineNoCov">          0 :          printf (&quot;After calling edgcpfe as a test (status = %d) \n&quot;,status);</span></a>
<a name="2771"><span class="lineNum">    2771 </span><span class="lineNoCov">          0 :          ROSE_ASSERT(status == 0);</span></a>
<a name="2772"><span class="lineNum">    2772 </span>            :       // ROSE_ASSERT(false);</a>
<a name="2773"><span class="lineNum">    2773 </span>            :         }</a>
<a name="2774"><span class="lineNum">    2774 </span>            :        else</a>
<a name="2775"><span class="lineNum">    2775 </span>            :         {</a>
<a name="2776"><span class="lineNum">    2776 </span><span class="lineCov">        357 :           if ((get_C_only() || get_Cxx_only()) &amp;&amp; get_disable_edg_backend() == true)</span></a>
<a name="2777"><span class="lineNum">    2777 </span>            :              {</a>
<a name="2778"><span class="lineNum">    2778 </span><span class="lineNoCov">          0 :                if (SgProject::get_verbose() &gt; 0)</span></a>
<a name="2779"><span class="lineNum">    2779 </span>            :                   {</a>
<a name="2780"><span class="lineNum">    2780 </span><span class="lineNoCov">          0 :                     std::cout &lt;&lt; &quot;[INFO] [SgFile::callFrontEnd] Skipping EDG frontend&quot; &lt;&lt; std::endl;</span></a>
<a name="2781"><span class="lineNum">    2781 </span>            :                   }</a>
<a name="2782"><span class="lineNum">    2782 </span>            :              }</a>
<a name="2783"><span class="lineNum">    2783 </span>            :             else</a>
<a name="2784"><span class="lineNum">    2784 </span>            :              {</a>
<a name="2785"><span class="lineNum">    2785 </span>            :             // DQ (9/2/2008): Factored out the details of building the AST for Source code (SgSourceFile IR node) and Binaries (SgBinaryComposite IR node)</a>
<a name="2786"><span class="lineNum">    2786 </span>            :             // Note that making buildAST() a virtual function does not appear to solve the problems since it is called form the base class.  This is</a>
<a name="2787"><span class="lineNum">    2787 </span>            :             // awkward code which is temporary.</a>
<a name="2788"><span class="lineNum">    2788 </span>            : #if 0</a>
<a name="2789"><span class="lineNum">    2789 </span>            :                printf (&quot;Before calling buildAST(): this-&gt;class_name() = %s \n&quot;,this-&gt;class_name().c_str());</a>
<a name="2790"><span class="lineNum">    2790 </span>            : #endif</a>
<a name="2791"><span class="lineNum">    2791 </span><span class="lineCov">        357 :                switch (this-&gt;variantT())</span></a>
<a name="2792"><span class="lineNum">    2792 </span>            :                   {</a>
<a name="2793"><span class="lineNum">    2793 </span><span class="lineCov">        357 :                     case V_SgFile:</span></a>
<a name="2794"><span class="lineNum">    2794 </span><span class="lineCov">        357 :                     case V_SgSourceFile:</span></a>
<a name="2795"><span class="lineNum">    2795 </span><span class="lineCov">        357 :                        {</span></a>
<a name="2796"><span class="lineNum">    2796 </span><span class="lineCov">        357 :                          SgSourceFile* sourceFile = const_cast&lt;SgSourceFile*&gt;(isSgSourceFile(this));</span></a>
<a name="2797"><span class="lineNum">    2797 </span><span class="lineCov">        357 :                          ASSERT_not_null(sourceFile);</span></a>
<a name="2798"><span class="lineNum">    2798 </span><span class="lineCov">        357 :                          frontendErrorLevel = sourceFile-&gt;buildAST(localCopy_argv, inputCommandLine);</span></a>
<a name="2799"><span class="lineNum">    2799 </span><span class="lineCov">        357 :                          break;</span></a>
<a name="2800"><span class="lineNum">    2800 </span>            :                        }</a>
<a name="2801"><span class="lineNum">    2801 </span>            : </a>
<a name="2802"><span class="lineNum">    2802 </span>            :                     case V_SgUnknownFile:</a>
<a name="2803"><span class="lineNum">    2803 </span>            :                        {</a>
<a name="2804"><span class="lineNum">    2804 </span>            :                          break;</a>
<a name="2805"><span class="lineNum">    2805 </span>            :                        }</a>
<a name="2806"><span class="lineNum">    2806 </span>            : </a>
<a name="2807"><span class="lineNum">    2807 </span><span class="lineNoCov">          0 :                     default:</span></a>
<a name="2808"><span class="lineNum">    2808 </span><span class="lineNoCov">          0 :                        {</span></a>
<a name="2809"><span class="lineNum">    2809 </span><span class="lineNoCov">          0 :                          printf (&quot;Error: default reached in Rose parser/IR translation processing: class name = %s \n&quot;,this-&gt;class_name().c_str());</span></a>
<a name="2810"><span class="lineNum">    2810 </span><span class="lineNoCov">          0 :                          ROSE_ABORT();</span></a>
<a name="2811"><span class="lineNum">    2811 </span>            :                        }</a>
<a name="2812"><span class="lineNum">    2812 </span>            :                   }</a>
<a name="2813"><span class="lineNum">    2813 </span>            :              }</a>
<a name="2814"><span class="lineNum">    2814 </span>            :         }</a>
<a name="2815"><span class="lineNum">    2815 </span>            : </a>
<a name="2816"><span class="lineNum">    2816 </span>            : #if 0</a>
<a name="2817"><span class="lineNum">    2817 </span>            :      printf (&quot;After calling buildAST(): this-&gt;class_name() = %s \n&quot;,this-&gt;class_name().c_str());</a>
<a name="2818"><span class="lineNum">    2818 </span>            : #endif</a>
<a name="2819"><span class="lineNum">    2819 </span>            : </a>
<a name="2820"><span class="lineNum">    2820 </span>            :   // if there are warnings report that there are in the verbose mode and continue</a>
<a name="2821"><span class="lineNum">    2821 </span><span class="lineCov">        357 :      if (frontendErrorLevel &gt; 0)</span></a>
<a name="2822"><span class="lineNum">    2822 </span>            :         {</a>
<a name="2823"><span class="lineNum">    2823 </span><span class="lineNoCov">          0 :           if ( get_verbose() &gt;= 1 )</span></a>
<a name="2824"><span class="lineNum">    2824 </span><span class="lineNoCov">          0 :                cout &lt;&lt; &quot;Warnings in Rose parser/IR translation processing! (continuing ...) &quot; &lt;&lt; endl;</span></a>
<a name="2825"><span class="lineNum">    2825 </span>            :         }</a>
<a name="2826"><span class="lineNum">    2826 </span>            : </a>
<a name="2827"><span class="lineNum">    2827 </span>            :   // DQ (4/20/2006): This code was moved from the SgFile constructor so that is would</a>
<a name="2828"><span class="lineNum">    2828 </span>            :   // permit the separate construction of the SgProject and call to the front-end cleaner.</a>
<a name="2829"><span class="lineNum">    2829 </span>            : </a>
<a name="2830"><span class="lineNum">    2830 </span>            :   // DQ (5/22/2005): This is a older function with a newer more up-to-date comment on why we have it.</a>
<a name="2831"><span class="lineNum">    2831 </span>            :   // This function is a repository for minor AST fixups done as a post-processing step in the</a>
<a name="2832"><span class="lineNum">    2832 </span>            :   // construction of the Sage III AST from the EDG frontend.  In some cases it fixes specific</a>
<a name="2833"><span class="lineNum">    2833 </span>            :   // problems in either EDG or the translation of EDG to Sage III (more the later than the former).</a>
<a name="2834"><span class="lineNum">    2834 </span>            :   // In other cases if does post-processing (e.g. setting parent pointers in the AST) can could</a>
<a name="2835"><span class="lineNum">    2835 </span>            :   // only done from a more complete global view of the staticly defined AST.  In many cases these</a>
<a name="2836"><span class="lineNum">    2836 </span>            :   // AST fixups are not so temporary so the name of the function might change at some point.</a>
<a name="2837"><span class="lineNum">    2837 </span>            :   // Notice that all AST fixup is done before attachment of the comments to the AST.</a>
<a name="2838"><span class="lineNum">    2838 </span>            :   // temporaryAstFixes(this);</a>
<a name="2839"><span class="lineNum">    2839 </span>            : </a>
<a name="2840"><span class="lineNum">    2840 </span>            : #if 0</a>
<a name="2841"><span class="lineNum">    2841 </span>            :   // FMZ (this is just debugging support)</a>
<a name="2842"><span class="lineNum">    2842 </span>            :      list&lt;SgScopeStatement*&gt; *stmp = &amp;astScopeStack;</a>
<a name="2843"><span class="lineNum">    2843 </span>            :      printf(&quot;FMZ :: before AstPostProcessing astScopeStack = %p \n&quot;,stmp);</a>
<a name="2844"><span class="lineNum">    2844 </span>            : #endif</a>
<a name="2845"><span class="lineNum">    2845 </span>            : </a>
<a name="2846"><span class="lineNum">    2846 </span>            :   // GB (8/19/2009): Commented this out and moved it to SgProject::parse().</a>
<a name="2847"><span class="lineNum">    2847 </span>            :   // Repeated calls to AstPostProcessing (one per file) can be slow on</a>
<a name="2848"><span class="lineNum">    2848 </span>            :   // projects consisting of multiple files due to repeated memory pool</a>
<a name="2849"><span class="lineNum">    2849 </span>            :   // traversals.</a>
<a name="2850"><span class="lineNum">    2850 </span>            :   // AstPostProcessing(this);</a>
<a name="2851"><span class="lineNum">    2851 </span>            : </a>
<a name="2852"><span class="lineNum">    2852 </span>            : #ifdef ROSE_BUILD_FORTRAN_LANGUAGE_SUPPORT</a>
<a name="2853"><span class="lineNum">    2853 </span>            :   // FMZ: 05/30/2008.  Do not generate .rmod file for the PU imported by &quot;use&quot; stmt</a>
<a name="2854"><span class="lineNum">    2854 </span>            :   // DXN (01/18/2011): Fixed to build rmod file only when there is no error passed back from the frontend.</a>
<a name="2855"><span class="lineNum">    2855 </span>            :   // if (get_Fortran_only() == true &amp;&amp; FortranModuleInfo::isRmodFile() == false)</a>
<a name="2856"><span class="lineNum">    2856 </span><span class="lineCov">        357 :      if (get_Fortran_only() == true &amp;&amp; FortranModuleInfo::isRmodFile() == false &amp;&amp; frontendErrorLevel == 0)</span></a>
<a name="2857"><span class="lineNum">    2857 </span>            :         {</a>
<a name="2858"><span class="lineNum">    2858 </span><span class="lineCov">         37 :           if (get_verbose() &gt; 1)</span></a>
<a name="2859"><span class="lineNum">    2859 </span><span class="lineNoCov">          0 :                printf (&quot;Generating a Fortran 90 module file (*.rmod) \n&quot;);</span></a>
<a name="2860"><span class="lineNum">    2860 </span>            : </a>
<a name="2861"><span class="lineNum">    2861 </span><span class="lineCov">         37 :           generateModFile(this);</span></a>
<a name="2862"><span class="lineNum">    2862 </span>            : </a>
<a name="2863"><span class="lineNum">    2863 </span><span class="lineCov">         37 :           if (get_verbose() &gt; 1)</span></a>
<a name="2864"><span class="lineNum">    2864 </span><span class="lineCov">        357 :                printf (&quot;DONE: Generating a Fortran 90 module file (*.rmod) \n&quot;);</span></a>
<a name="2865"><span class="lineNum">    2865 </span>            :         }</a>
<a name="2866"><span class="lineNum">    2866 </span>            : #endif</a>
<a name="2867"><span class="lineNum">    2867 </span>            : </a>
<a name="2868"><span class="lineNum">    2868 </span>            : #if 0</a>
<a name="2869"><span class="lineNum">    2869 </span>            :      printf (&quot;Leaving SgFile::callFrontEnd(): fileNameIndex = %d \n&quot;,fileNameIndex);</a>
<a name="2870"><span class="lineNum">    2870 </span>            :      display(&quot;At bottom of SgFile::callFrontEnd()&quot;);</a>
<a name="2871"><span class="lineNum">    2871 </span>            : #endif</a>
<a name="2872"><span class="lineNum">    2872 </span>            : #if 0</a>
<a name="2873"><span class="lineNum">    2873 </span>            :      printf (&quot;Exiting as a test of the F03 module support \n&quot;);</a>
<a name="2874"><span class="lineNum">    2874 </span>            :      ROSE_ABORT();</a>
<a name="2875"><span class="lineNum">    2875 </span>            : #endif</a>
<a name="2876"><span class="lineNum">    2876 </span>            : </a>
<a name="2877"><span class="lineNum">    2877 </span>            : #if 0</a>
<a name="2878"><span class="lineNum">    2878 </span>            :      printf (&quot;Leaving SgFile::callFrontEnd(): fileNameIndex = %d frontendErrorLevel = %d \n&quot;,fileNameIndex,frontendErrorLevel);</a>
<a name="2879"><span class="lineNum">    2879 </span>            : #endif</a>
<a name="2880"><span class="lineNum">    2880 </span>            : </a>
<a name="2881"><span class="lineNum">    2881 </span>            :   // return the error code associated with the call to the C++ Front-end</a>
<a name="2882"><span class="lineNum">    2882 </span>            :      return frontendErrorLevel;</a>
<a name="2883"><span class="lineNum">    2883 </span>            :    }</a>
<a name="2884"><span class="lineNum">    2884 </span>            : </a>
<a name="2885"><span class="lineNum">    2885 </span>            : </a>
<a name="2886"><span class="lineNum">    2886 </span>            : </a>
<a name="2887"><span class="lineNum">    2887 </span>            : void</a>
<a name="2888"><span class="lineNum">    2888 </span><span class="lineCov">        353 : SgFile::secondaryPassOverSourceFile()</span></a>
<a name="2889"><span class="lineNum">    2889 </span>            :    {</a>
<a name="2890"><span class="lineNum">    2890 </span>            :   // DQ (8/19/2019): We want to optionally separate this function out over two phases to optimize the support for header file unparsing.</a>
<a name="2891"><span class="lineNum">    2891 </span>            :   // When not optimized, we process all of the header file with the source file.</a>
<a name="2892"><span class="lineNum">    2892 </span>            :   // When we are supporting optimization, we handle the collection of comments and</a>
<a name="2893"><span class="lineNum">    2893 </span>            :   // CPP directives and their insertion into the AST in two phases:</a>
<a name="2894"><span class="lineNum">    2894 </span>            :   //  1) Just the source file (no header files)</a>
<a name="2895"><span class="lineNum">    2895 </span>            :   //  2) Just the header files (not the source file)</a>
<a name="2896"><span class="lineNum">    2896 </span>            : </a>
<a name="2897"><span class="lineNum">    2897 </span>            :   // DQ (02/20/2021): Using the performance tracking within ROSE.</a>
<a name="2898"><span class="lineNum">    2898 </span><span class="lineCov">        706 :      TimingPerformance timer (&quot;AST secondaryPassOverSourceFile:&quot;);</span></a>
<a name="2899"><span class="lineNum">    2899 </span>            : </a>
<a name="2900"><span class="lineNum">    2900 </span>            : #if 0</a>
<a name="2901"><span class="lineNum">    2901 </span>            :      printf (&quot;################ In SgFile::secondaryPassOverSourceFile(): this = %p = %s \n&quot;,this,this-&gt;class_name().c_str());</a>
<a name="2902"><span class="lineNum">    2902 </span>            :      printf (&quot; --- filename ============================================= %s \n&quot;,this-&gt;getFileName().c_str());</a>
<a name="2903"><span class="lineNum">    2903 </span>            :      printf (&quot; --- get_header_file_unparsing_optimization()             = %s \n&quot;,this-&gt;get_header_file_unparsing_optimization() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="2904"><span class="lineNum">    2904 </span>            :      printf (&quot; --- get_header_file_unparsing_optimization_source_file() = %s \n&quot;,this-&gt;get_header_file_unparsing_optimization_source_file() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="2905"><span class="lineNum">    2905 </span>            :      printf (&quot; --- get_header_file_unparsing_optimization_header_file() = %s \n&quot;,this-&gt;get_header_file_unparsing_optimization_header_file() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="2906"><span class="lineNum">    2906 </span>            : #endif</a>
<a name="2907"><span class="lineNum">    2907 </span>            : </a>
<a name="2908"><span class="lineNum">    2908 </span>            : #define DEBUG_SECONDARY_PASS 0</a>
<a name="2909"><span class="lineNum">    2909 </span>            : </a>
<a name="2910"><span class="lineNum">    2910 </span>            :   // To support initial testing we will call one phase immediately after the other.  Late we will call the second phase, header</a>
<a name="2911"><span class="lineNum">    2911 </span>            :   // file processing, from within the unparser when we know what header files are intended to be unparsed.</a>
<a name="2912"><span class="lineNum">    2912 </span>            : </a>
<a name="2913"><span class="lineNum">    2913 </span>            : #if 0</a>
<a name="2914"><span class="lineNum">    2914 </span>            :   // DQ (4/24/2021): Trying to debug the header file optimization support.</a>
<a name="2915"><span class="lineNum">    2915 </span>            : </a>
<a name="2916"><span class="lineNum">    2916 </span>            :   // DQ (12/21/2019): Two of these three are not used and generate a compiler warning.</a>
<a name="2917"><span class="lineNum">    2917 </span>            :   // bool header_file_unparsing_optimization             = false;</a>
<a name="2918"><span class="lineNum">    2918 </span>            :   // bool header_file_unparsing_optimization_source_file = false;</a>
<a name="2919"><span class="lineNum">    2919 </span>            :      bool header_file_unparsing_optimization_header_file = false;</a>
<a name="2920"><span class="lineNum">    2920 </span>            : </a>
<a name="2921"><span class="lineNum">    2921 </span>            :   // DQ (4/24/2021): Trying to debug the header file optimization support.</a>
<a name="2922"><span class="lineNum">    2922 </span>            :   // if (this-&gt;get_header_file_unparsing_optimization() == true)</a>
<a name="2923"><span class="lineNum">    2923 </span>            :         {</a>
<a name="2924"><span class="lineNum">    2924 </span>            :        // DQ (12/21/2019): This not used and generates a compiler warning.</a>
<a name="2925"><span class="lineNum">    2925 </span>            :        // header_file_unparsing_optimization = true;</a>
<a name="2926"><span class="lineNum">    2926 </span>            : </a>
<a name="2927"><span class="lineNum">    2927 </span>            :        // DQ (4/24/2021): Trying to debug the header file optimization support.</a>
<a name="2928"><span class="lineNum">    2928 </span>            :        // if (this-&gt;get_header_file_unparsing_optimization_source_file() == true)</a>
<a name="2929"><span class="lineNum">    2929 </span>            :              {</a>
<a name="2930"><span class="lineNum">    2930 </span>            : #if DEBUG_SECONDARY_PASS</a>
<a name="2931"><span class="lineNum">    2931 </span>            :                printf (&quot;In SgFile::secondaryPassOverSourceFile(): this = %p = %s name = %s this-&gt;get_header_file_unparsing_optimization_header_file() = %s \n&quot;,</a>
<a name="2932"><span class="lineNum">    2932 </span>            :                     this,this-&gt;class_name().c_str(),this-&gt;getFileName().c_str(),this-&gt;get_header_file_unparsing_optimization_header_file() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="2933"><span class="lineNum">    2933 </span>            : #endif</a>
<a name="2934"><span class="lineNum">    2934 </span>            : </a>
<a name="2935"><span class="lineNum">    2935 </span>            :             // DQ (4/24/2021): Trying to debug the header file optimization support.</a>
<a name="2936"><span class="lineNum">    2936 </span>            :             // DQ (9/19/2019): Set this to false explicitly (testing).</a>
<a name="2937"><span class="lineNum">    2937 </span>            :             // if (this-&gt;get_header_file_unparsing_optimization_header_file() == true)</a>
<a name="2938"><span class="lineNum">    2938 </span>            :                   {</a>
<a name="2939"><span class="lineNum">    2939 </span>            :                     printf (&quot;In SgFile::secondaryPassOverSourceFile(): this = %p = %s name = %s explicitly call this-&gt;set_header_file_unparsing_optimization_header_file(false) \n&quot;,</a>
<a name="2940"><span class="lineNum">    2940 </span>            :                          this,this-&gt;class_name().c_str(),this-&gt;getFileName().c_str());</a>
<a name="2941"><span class="lineNum">    2941 </span>            : </a>
<a name="2942"><span class="lineNum">    2942 </span>            :                  // DQ (4/24/2021): Debugging the header file optimization support.</a>
<a name="2943"><span class="lineNum">    2943 </span>            :                  // this-&gt;set_header_file_unparsing_optimization_header_file(false);</a>
<a name="2944"><span class="lineNum">    2944 </span>            :                     printf (&quot;Skip setting this-&gt;set_header_file_unparsing_optimization_header_file(false) \n&quot;);</a>
<a name="2945"><span class="lineNum">    2945 </span>            :                   }</a>
<a name="2946"><span class="lineNum">    2946 </span>            : </a>
<a name="2947"><span class="lineNum">    2947 </span>            :                ROSE_ASSERT(this-&gt;get_header_file_unparsing_optimization_header_file() == false);</a>
<a name="2948"><span class="lineNum">    2948 </span>            : #if DEBUG_SECONDARY_PASS</a>
<a name="2949"><span class="lineNum">    2949 </span>            :                printf (&quot;In SgFile::secondaryPassOverSourceFile(): Optimize the collection of comments and CPP directives to seperate handling of the source file from the header files \n&quot;);</a>
<a name="2950"><span class="lineNum">    2950 </span>            : #endif</a>
<a name="2951"><span class="lineNum">    2951 </span>            :             // DQ (12/21/2019): This not used and generates a compiler warning.</a>
<a name="2952"><span class="lineNum">    2952 </span>            :             // header_file_unparsing_optimization_source_file = true;</a>
<a name="2953"><span class="lineNum">    2953 </span>            :              }</a>
<a name="2954"><span class="lineNum">    2954 </span>            :             else</a>
<a name="2955"><span class="lineNum">    2955 </span>            :              {</a>
<a name="2956"><span class="lineNum">    2956 </span>            :                ROSE_ASSERT(this-&gt;get_header_file_unparsing_optimization_source_file() == false);</a>
<a name="2957"><span class="lineNum">    2957 </span>            : </a>
<a name="2958"><span class="lineNum">    2958 </span>            :             // DQ (4/24/2021): Trying to debug the header file optimization support.</a>
<a name="2959"><span class="lineNum">    2959 </span>            :             // if (this-&gt;get_header_file_unparsing_optimization_header_file() == true)</a>
<a name="2960"><span class="lineNum">    2960 </span>            :                   {</a>
<a name="2961"><span class="lineNum">    2961 </span>            : #if DEBUG_SECONDARY_PASS</a>
<a name="2962"><span class="lineNum">    2962 </span>            :                     printf (&quot;Optimize the collection of comments and CPP directives to seperate handling of the header files from the source file \n&quot;);</a>
<a name="2963"><span class="lineNum">    2963 </span>            : #endif</a>
<a name="2964"><span class="lineNum">    2964 </span>            :                     header_file_unparsing_optimization_header_file = true;</a>
<a name="2965"><span class="lineNum">    2965 </span>            :                   }</a>
<a name="2966"><span class="lineNum">    2966 </span>            :              }</a>
<a name="2967"><span class="lineNum">    2967 </span>            : </a>
<a name="2968"><span class="lineNum">    2968 </span>            : #if 0</a>
<a name="2969"><span class="lineNum">    2969 </span>            :           printf (&quot;Exiting as a test! \n&quot;);</a>
<a name="2970"><span class="lineNum">    2970 </span>            :           ROSE_ABORT();</a>
<a name="2971"><span class="lineNum">    2971 </span>            : #endif</a>
<a name="2972"><span class="lineNum">    2972 </span>            :         }</a>
<a name="2973"><span class="lineNum">    2973 </span>            : #endif</a>
<a name="2974"><span class="lineNum">    2974 </span>            : </a>
<a name="2975"><span class="lineNum">    2975 </span>            : #if 0</a>
<a name="2976"><span class="lineNum">    2976 </span>            :      printf (&quot;################ In SgFile::secondaryPassOverSourceFile(): (after preamble tests): this = %p = %s \n&quot;,this,this-&gt;class_name().c_str());</a>
<a name="2977"><span class="lineNum">    2977 </span>            :      printf (&quot; --- filename ============================================= %s \n&quot;,this-&gt;getFileName().c_str());</a>
<a name="2978"><span class="lineNum">    2978 </span>            :   // printf (&quot; --- header_file_unparsing_optimization_header_file       = %s \n&quot;,header_file_unparsing_optimization_header_file ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="2979"><span class="lineNum">    2979 </span>            :      printf (&quot; --- get_header_file_unparsing_optimization()             = %s \n&quot;,this-&gt;get_header_file_unparsing_optimization() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="2980"><span class="lineNum">    2980 </span>            :      printf (&quot; --- get_header_file_unparsing_optimization_source_file() = %s \n&quot;,this-&gt;get_header_file_unparsing_optimization_source_file() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="2981"><span class="lineNum">    2981 </span>            :      printf (&quot; --- get_header_file_unparsing_optimization_header_file() = %s \n&quot;,this-&gt;get_header_file_unparsing_optimization_header_file() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="2982"><span class="lineNum">    2982 </span>            : #endif</a>
<a name="2983"><span class="lineNum">    2983 </span>            : </a>
<a name="2984"><span class="lineNum">    2984 </span>            :   // **************************************************************************</a>
<a name="2985"><span class="lineNum">    2985 </span>            :   //                      Secondary Pass Over Source File</a>
<a name="2986"><span class="lineNum">    2986 </span>            :   // **************************************************************************</a>
<a name="2987"><span class="lineNum">    2987 </span>            :   // This pass collects extra information about the source file that may not have</a>
<a name="2988"><span class="lineNum">    2988 </span>            :   // been available from previous tools that operated on the file. For example:</a>
<a name="2989"><span class="lineNum">    2989 </span>            :   //    1) EDG ignores comments and so we collect the whole token stream in this phase.</a>
<a name="2990"><span class="lineNum">    2990 </span>            :   //    2) OFP ignores comments similarly to EDG and so we collect the whole token stream.</a>
<a name="2991"><span class="lineNum">    2991 </span>            :   //    3) Binary disassembly ignores the binary format so we collect this information</a>
<a name="2992"><span class="lineNum">    2992 </span>            :   //       about the structure of the ELF binary separately.</a>
<a name="2993"><span class="lineNum">    2993 </span>            :   // For source code (C,C++,Fortran) we collect the whole token stream, for example:</a>
<a name="2994"><span class="lineNum">    2994 </span>            :   //    1) Comments</a>
<a name="2995"><span class="lineNum">    2995 </span>            :   //    2) Preprocessors directives</a>
<a name="2996"><span class="lineNum">    2996 </span>            :   //    3) White space</a>
<a name="2997"><span class="lineNum">    2997 </span>            :   //    4) All tokens (each is classified as to what specific type of token it is)</a>
<a name="2998"><span class="lineNum">    2998 </span>            :   //</a>
<a name="2999"><span class="lineNum">    2999 </span>            :   // There is no secondary processing for binaries.</a>
<a name="3000"><span class="lineNum">    3000 </span>            : </a>
<a name="3001"><span class="lineNum">    3001 </span>            :   // DQ (10/27/2018): Added documentation.</a>
<a name="3002"><span class="lineNum">    3002 </span>            :   // Note that this function is called from two locations:</a>
<a name="3003"><span class="lineNum">    3003 </span>            :   // 1) From the sage_support.cpp (for the main source file)</a>
<a name="3004"><span class="lineNum">    3004 </span>            :   // 2) From the attachPreprocessingInfoTraversal.C (for any header files when using the unparse headers option)</a>
<a name="3005"><span class="lineNum">    3005 </span>            : </a>
<a name="3006"><span class="lineNum">    3006 </span>            :   // GB (9/4/2009): Factored out the secondary pass. It is now done after</a>
<a name="3007"><span class="lineNum">    3007 </span>            :   // the whole project has been constructed and fixed up.</a>
<a name="3008"><span class="lineNum">    3008 </span>            : </a>
<a name="3009"><span class="lineNum">    3009 </span><span class="lineCov">        353 :         {</span></a>
<a name="3010"><span class="lineNum">    3010 </span>            :        // This is set in the unparser now so that we can handle the source file plus all header files</a>
<a name="3011"><span class="lineNum">    3011 </span>            : </a>
<a name="3012"><span class="lineNum">    3012 </span>            :        // DQ (8/19/2019): When header file optimization is turned on the this asertion is incorrect.</a>
<a name="3013"><span class="lineNum">    3013 </span>            :        // ROSE_ASSERT (p_preprocessorDirectivesAndCommentsList == NULL);</a>
<a name="3014"><span class="lineNum">    3014 </span>            : </a>
<a name="3015"><span class="lineNum">    3015 </span>            :        // DQ (8/19/2019): When header file optimization is turned on the this asertion is incorrect.</a>
<a name="3016"><span class="lineNum">    3016 </span>            :        // Build the empty list container so that we can just add lists for new files as they are encountered</a>
<a name="3017"><span class="lineNum">    3017 </span>            :        // p_preprocessorDirectivesAndCommentsList = new ROSEAttributesListContainer();</a>
<a name="3018"><span class="lineNum">    3018 </span>            :        // ROSE_ASSERT (p_preprocessorDirectivesAndCommentsList != NULL);</a>
<a name="3019"><span class="lineNum">    3019 </span>            : #if 1</a>
<a name="3020"><span class="lineNum">    3020 </span>            :        // DQ (4/24/2021): Trying to debug the header file optimization support.</a>
<a name="3021"><span class="lineNum">    3021 </span>            :        // printf (&quot;In SgFile::secondaryPassOverSourceFile(): header_file_unparsing_optimization_header_file = %s \n&quot;,header_file_unparsing_optimization_header_file ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="3022"><span class="lineNum">    3022 </span>            : #endif</a>
<a name="3023"><span class="lineNum">    3023 </span>            : </a>
<a name="3024"><span class="lineNum">    3024 </span>            : #if 0</a>
<a name="3025"><span class="lineNum">    3025 </span>            :        // DQ (4/24/2021): Trying to debug the header file optimization support.</a>
<a name="3026"><span class="lineNum">    3026 </span>            :           if (header_file_unparsing_optimization_header_file == true)</a>
<a name="3027"><span class="lineNum">    3027 </span>            :              {</a>
<a name="3028"><span class="lineNum">    3028 </span>            :                ASSERT_not_null(p_preprocessorDirectivesAndCommentsList);</a>
<a name="3029"><span class="lineNum">    3029 </span>            :              }</a>
<a name="3030"><span class="lineNum">    3030 </span>            :             else</a>
<a name="3031"><span class="lineNum">    3031 </span>            : #endif</a>
<a name="3032"><span class="lineNum">    3032 </span><span class="lineCov">        353 :              {</span></a>
<a name="3033"><span class="lineNum">    3033 </span>            :             // DQ (9/23/2019): We need to support calling this function multiple times.</a>
<a name="3034"><span class="lineNum">    3034 </span>            :             // ROSE_ASSERT (p_preprocessorDirectivesAndCommentsList == NULL);</a>
<a name="3035"><span class="lineNum">    3035 </span>            :             // p_preprocessorDirectivesAndCommentsList = new ROSEAttributesListContainer();</a>
<a name="3036"><span class="lineNum">    3036 </span><span class="lineCov">        353 :                if (p_preprocessorDirectivesAndCommentsList == nullptr)</span></a>
<a name="3037"><span class="lineNum">    3037 </span>            :                   {</a>
<a name="3038"><span class="lineNum">    3038 </span>            : #if DEBUG_SECONDARY_PASS</a>
<a name="3039"><span class="lineNum">    3039 </span>            :                     printf (&quot;Initialize NULL p_preprocessorDirectivesAndCommentsList to empty ROSEAttributesListContainer \n&quot;);</a>
<a name="3040"><span class="lineNum">    3040 </span>            : #endif</a>
<a name="3041"><span class="lineNum">    3041 </span><span class="lineNoCov">          0 :                     p_preprocessorDirectivesAndCommentsList = new ROSEAttributesListContainer();</span></a>
<a name="3042"><span class="lineNum">    3042 </span>            :                   }</a>
<a name="3043"><span class="lineNum">    3043 </span>            :                  else</a>
<a name="3044"><span class="lineNum">    3044 </span>            :                   {</a>
<a name="3045"><span class="lineNum">    3045 </span>            : #if DEBUG_SECONDARY_PASS</a>
<a name="3046"><span class="lineNum">    3046 </span>            :                     printf (&quot;NOTE: p_preprocessorDirectivesAndCommentsList is already defined! \n&quot;);</a>
<a name="3047"><span class="lineNum">    3047 </span>            :                     printf (&quot; --- filename = %s \n&quot;,this-&gt;getFileName().c_str());</a>
<a name="3048"><span class="lineNum">    3048 </span>            :                     printf (&quot; --- p_preprocessorDirectivesAndCommentsList-&gt;getList().size() = %zu \n&quot;,p_preprocessorDirectivesAndCommentsList-&gt;getList().size());</a>
<a name="3049"><span class="lineNum">    3049 </span>            : #endif</a>
<a name="3050"><span class="lineNum">    3050 </span>            :                   }</a>
<a name="3051"><span class="lineNum">    3051 </span><span class="lineCov">        353 :                ASSERT_not_null(p_preprocessorDirectivesAndCommentsList);</span></a>
<a name="3052"><span class="lineNum">    3052 </span>            :              }</a>
<a name="3053"><span class="lineNum">    3053 </span>            : #if 0</a>
<a name="3054"><span class="lineNum">    3054 </span>            :        // This is empty so there is nothing to display!</a>
<a name="3055"><span class="lineNum">    3055 </span>            :           p_preprocessorDirectivesAndCommentsList-&gt;display(&quot;Secondary Source File Processing at bottom of SgFile::callFrontEnd()&quot;);</a>
<a name="3056"><span class="lineNum">    3056 </span>            : #endif</a>
<a name="3057"><span class="lineNum">    3057 </span>            : </a>
<a name="3058"><span class="lineNum">    3058 </span>            :        // DQ (4/19/2006): since they can take a while and includes substantial</a>
<a name="3059"><span class="lineNum">    3059 </span>            :        // file I/O we make this optional (selected from the command line).</a>
<a name="3060"><span class="lineNum">    3060 </span>            :        // bool collectAllCommentsAndDirectives = get_collectAllCommentsAndDirectives();</a>
<a name="3061"><span class="lineNum">    3061 </span>            : #if 0</a>
<a name="3062"><span class="lineNum">    3062 </span>            :           printf (&quot;get_skip_commentsAndDirectives() = %s \n&quot;,get_skip_commentsAndDirectives() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="3063"><span class="lineNum">    3063 </span>            : #endif</a>
<a name="3064"><span class="lineNum">    3064 </span>            :        // DQ (12/17/2008): The merging of CPP directives and comments from either the</a>
<a name="3065"><span class="lineNum">    3065 </span>            :        // source file or including all the include files is not implemented as a single</a>
<a name="3066"><span class="lineNum">    3066 </span>            :        // traversal and has been rewritten.</a>
<a name="3067"><span class="lineNum">    3067 </span><span class="lineCov">        353 :           if (get_skip_commentsAndDirectives() == false)</span></a>
<a name="3068"><span class="lineNum">    3068 </span>            :              {</a>
<a name="3069"><span class="lineNum">    3069 </span><span class="lineCov">        353 :                if (get_verbose() &gt;= 1)</span></a>
<a name="3070"><span class="lineNum">    3070 </span>            :                   {</a>
<a name="3071"><span class="lineNum">    3071 </span><span class="lineNoCov">          0 :                     printf (&quot;In SgFile::secondaryPassOverSourceFile(): calling attachAllPreprocessingInfo() \n&quot;);</span></a>
<a name="3072"><span class="lineNum">    3072 </span>            :                   }</a>
<a name="3073"><span class="lineNum">    3073 </span>            : </a>
<a name="3074"><span class="lineNum">    3074 </span>            :             // printf (&quot;Secondary pass over source file = %s to comment comments and CPP directives \n&quot;,this-&gt;get_file_info()-&gt;get_filenameString().c_str());</a>
<a name="3075"><span class="lineNum">    3075 </span>            :             // SgSourceFile* sourceFile = const_cast&lt;SgSourceFile*&gt;(this);</a>
<a name="3076"><span class="lineNum">    3076 </span><span class="lineCov">        353 :                SgSourceFile* sourceFile = isSgSourceFile(this);</span></a>
<a name="3077"><span class="lineNum">    3077 </span><span class="lineCov">        353 :                ASSERT_not_null(sourceFile);</span></a>
<a name="3078"><span class="lineNum">    3078 </span>            : </a>
<a name="3079"><span class="lineNum">    3079 </span>            :             // Save the state of the requirement fo CPP processing (fortran only)</a>
<a name="3080"><span class="lineNum">    3080 </span><span class="lineCov">        353 :                bool requiresCPP = false;</span></a>
<a name="3081"><span class="lineNum">    3081 </span><span class="lineCov">        353 :                if (get_Fortran_only() == true)</span></a>
<a name="3082"><span class="lineNum">    3082 </span>            :                   {</a>
<a name="3083"><span class="lineNum">    3083 </span><span class="lineCov">         37 :                     requiresCPP = get_requires_C_preprocessor();</span></a>
<a name="3084"><span class="lineNum">    3084 </span><span class="lineCov">         37 :                     if (requiresCPP == true)</span></a>
<a name="3085"><span class="lineNum">    3085 </span>            :                        {</a>
<a name="3086"><span class="lineNum">    3086 </span>            : #if DEBUG_SECONDARY_PASS</a>
<a name="3087"><span class="lineNum">    3087 </span>            :                          printf (&quot;@@@@@@@@@@@@@@ Set requires_C_preprocessor to false (test 4) \n&quot;);</a>
<a name="3088"><span class="lineNum">    3088 </span>            : #endif</a>
<a name="3089"><span class="lineNum">    3089 </span><span class="lineNoCov">          0 :                          set_requires_C_preprocessor(false);</span></a>
<a name="3090"><span class="lineNum">    3090 </span>            :                        }</a>
<a name="3091"><span class="lineNum">    3091 </span>            :                   }</a>
<a name="3092"><span class="lineNum">    3092 </span>            : #if DEBUG_SECONDARY_PASS</a>
<a name="3093"><span class="lineNum">    3093 </span>            :                printf (&quot;In SgFile::secondaryPassOverSourceFile(): requiresCPP = %s \n&quot;,requiresCPP ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="3094"><span class="lineNum">    3094 </span>            : #endif</a>
<a name="3095"><span class="lineNum">    3095 </span>            : #if 1</a>
<a name="3096"><span class="lineNum">    3096 </span>            :             // Debugging code (eliminate use of CPP directives from source file so that we</a>
<a name="3097"><span class="lineNum">    3097 </span>            :             // can debug the insertion of linemarkers from first phase of CPP processing.</a>
<a name="3098"><span class="lineNum">    3098 </span><span class="lineCov">         37 :                if (requiresCPP == false)</span></a>
<a name="3099"><span class="lineNum">    3099 </span>            :                   {</a>
<a name="3100"><span class="lineNum">    3100 </span>            :                  // DQ (10/21/2019): This will be tested below, in attachPreprocessingInfo(), if it is not in place then we need to do it here.</a>
<a name="3101"><span class="lineNum">    3101 </span>            :                  // ROSEAttributesListContainerPtr filePreprocInfo = sourceFile-&gt;get_preprocessorDirectivesAndCommentsList();</a>
<a name="3102"><span class="lineNum">    3102 </span>            : #if 0</a>
<a name="3103"><span class="lineNum">    3103 </span>            :                  // printf (&quot;In SgFile::secondaryPassOverSourceFile(): filePreprocInfo-&gt;getList().empty() = %s \n&quot;,filePreprocInfo-&gt;getList().empty() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="3104"><span class="lineNum">    3104 </span>            : #endif</a>
<a name="3105"><span class="lineNum">    3105 </span>            :                  // ROSE_ASSERT(filePreprocInfo-&gt;getList().empty() == false);</a>
<a name="3106"><span class="lineNum">    3106 </span>            : </a>
<a name="3107"><span class="lineNum">    3107 </span>            :                  // DQ (10/18/2020): This is enforced within attachPreprocessingInfo(), so move the enforcement to be as early as possible.</a>
<a name="3108"><span class="lineNum">    3108 </span><span class="lineCov">        353 :                     ROSE_ASSERT(sourceFile-&gt;get_processedToIncludeCppDirectivesAndComments() == false);</span></a>
<a name="3109"><span class="lineNum">    3109 </span>            : #if DEBUG_SECONDARY_PASS</a>
<a name="3110"><span class="lineNum">    3110 </span>            :                     printf (&quot;@@@@@@@@@@@@@@ In SgFile::secondaryPassOverSourceFile(): Calling attachPreprocessingInfo(): sourceFile = %p = %s filename = %s \n&quot;,</a>
<a name="3111"><span class="lineNum">    3111 </span>            :                          sourceFile,sourceFile-&gt;class_name().c_str(),sourceFile-&gt;getFileName().c_str());</a>
<a name="3112"><span class="lineNum">    3112 </span>            : #endif</a>
<a name="3113"><span class="lineNum">    3113 </span><span class="lineCov">        706 :                     attachPreprocessingInfo(sourceFile);</span></a>
<a name="3114"><span class="lineNum">    3114 </span>            : #if DEBUG_SECONDARY_PASS</a>
<a name="3115"><span class="lineNum">    3115 </span>            :                     printf (&quot;@@@@@@@@@@@@@@ DONE: In SgFile::secondaryPassOverSourceFile(): Calling attachPreprocessingInfo(): sourceFile = %p = %s \n&quot;,sourceFile,sourceFile-&gt;class_name().c_str());</a>
<a name="3116"><span class="lineNum">    3116 </span>            :                  // printf (&quot;In SgFile::secondaryPassOverSourceFile(): sourceFile-&gt;get_tokenSubsequenceMap().size() = %zu \n&quot;,sourceFile-&gt;get_tokenSubsequenceMap().size());</a>
<a name="3117"><span class="lineNum">    3117 </span>            : #endif</a>
<a name="3118"><span class="lineNum">    3118 </span>            : #if 0</a>
<a name="3119"><span class="lineNum">    3119 </span>            :                     printf (&quot;Exiting as a test (should not be called for Fortran CPP source files) \n&quot;);</a>
<a name="3120"><span class="lineNum">    3120 </span>            :                     ROSE_ABORT();</a>
<a name="3121"><span class="lineNum">    3121 </span>            : #endif</a>
<a name="3122"><span class="lineNum">    3122 </span>            :                   }</a>
<a name="3123"><span class="lineNum">    3123 </span>            : </a>
<a name="3124"><span class="lineNum">    3124 </span>            : #if 0</a>
<a name="3125"><span class="lineNum">    3125 </span>            :                printf (&quot;Adding support for processing of token stream \n&quot;);</a>
<a name="3126"><span class="lineNum">    3126 </span>            : #endif</a>
<a name="3127"><span class="lineNum">    3127 </span>            :             // DQ (7/2/2020): Adding support for processing of token stream.</a>
<a name="3128"><span class="lineNum">    3128 </span>            :             // Procesing has been moved here since only at this point do we know which header files will be processed (unparsed).</a>
<a name="3129"><span class="lineNum">    3129 </span>            :             // And it is the unparsing of the file that drives the requirement for both collection of comments and CPP directives,</a>
<a name="3130"><span class="lineNum">    3130 </span>            :             // and when toke-based unparsing is used, drives the processing of the token stream (generation of the token map to the AST).</a>
<a name="3131"><span class="lineNum">    3131 </span>            : </a>
<a name="3132"><span class="lineNum">    3132 </span><span class="lineCov">        353 :         {</span></a>
<a name="3133"><span class="lineNum">    3133 </span>            :        // DQ (8/18/2019): Add performance analysis support.</a>
<a name="3134"><span class="lineNum">    3134 </span><span class="lineCov">        706 :           TimingPerformance timer (&quot;EDG-ROSE header file support for tokens:&quot;);</span></a>
<a name="3135"><span class="lineNum">    3135 </span>            : </a>
<a name="3136"><span class="lineNum">    3136 </span>            :        // DQ (7/2/2020): Use this variable for now while debuging this code moved from the parse() function.</a>
<a name="3137"><span class="lineNum">    3137 </span><span class="lineCov">        353 :           SgFile* file = sourceFile;</span></a>
<a name="3138"><span class="lineNum">    3138 </span>            : #if 0</a>
<a name="3139"><span class="lineNum">    3139 </span>            :           printf (&quot;(before conditional) filename = %s file-&gt;get_unparse_tokens() = %s \n&quot;,file-&gt;getFileName().c_str(),file-&gt;get_unparse_tokens() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="3140"><span class="lineNum">    3140 </span>            : #endif</a>
<a name="3141"><span class="lineNum">    3141 </span>            :        // DQ (10/27/2013): Adding support for token stream use in unparser. We might want to only turn this of when -rose:unparse_tokens is specified.</a>
<a name="3142"><span class="lineNum">    3142 </span>            :        // if ( ( (SageInterface::is_C_language() == true) || (SageInterface::is_Cxx_language() == true) ) &amp;&amp; file-&gt;get_unparse_tokens() == true)</a>
<a name="3143"><span class="lineNum">    3143 </span><span class="lineCov">        669 :           if ( ( (SageInterface::is_C_language() == true) || (SageInterface::is_Cxx_language() == true) ) &amp;&amp;</span></a>
<a name="3144"><span class="lineNum">    3144 </span><span class="lineCov">        632 :                ( (file-&gt;get_unparse_tokens() == true)     || (file-&gt;get_use_token_stream_to_improve_source_position_info() == true) ) )</span></a>
<a name="3145"><span class="lineNum">    3145 </span>            :              {</a>
<a name="3146"><span class="lineNum">    3146 </span>            :             // This is only currently being tested and evaluated for C language (should also work for C++, but not yet for Fortran).</a>
<a name="3147"><span class="lineNum">    3147 </span><span class="lineNoCov">          0 :                if (file-&gt;get_translateCommentsAndDirectivesIntoAST() == true)</span></a>
<a name="3148"><span class="lineNum">    3148 </span>            :                   {</a>
<a name="3149"><span class="lineNum">    3149 </span><span class="lineNoCov">          0 :                     printf (&quot;translateCommentsAndDirectivesIntoAST option not yet supported! \n&quot;);</span></a>
<a name="3150"><span class="lineNum">    3150 </span><span class="lineNoCov">          0 :                     ROSE_ABORT();</span></a>
<a name="3151"><span class="lineNum">    3151 </span>            : #if 0 // [Robb Matzke 2021-03-24]: unreachable</a>
<a name="3152"><span class="lineNum">    3152 </span>            :                  // DQ (3/29/2019): This still needs to be debugged.</a>
<a name="3153"><span class="lineNum">    3153 </span>            :                     SageInterface::translateToUseCppDeclarations(sourceFile);</a>
<a name="3154"><span class="lineNum">    3154 </span>            : #endif</a>
<a name="3155"><span class="lineNum">    3155 </span>            :                   }</a>
<a name="3156"><span class="lineNum">    3156 </span>            : </a>
<a name="3157"><span class="lineNum">    3157 </span>            : #if DEBUG_SECONDARY_PASS</a>
<a name="3158"><span class="lineNum">    3158 </span>            :             // SgSourceFile* sourceFile = isSgSourceFile(this);</a>
<a name="3159"><span class="lineNum">    3159 </span>            :             // printf (&quot;In SgFile::secondaryPassOverSourceFile(): sourceFile-&gt;get_tokenSubsequenceMap().size() = %zu \n&quot;,sourceFile-&gt;get_tokenSubsequenceMap().size());</a>
<a name="3160"><span class="lineNum">    3160 </span>            :                printf (&quot;In SgFile::secondaryPassOverSourceFile(): Building token stream mapping map! \n&quot;);</a>
<a name="3161"><span class="lineNum">    3161 </span>            : #endif</a>
<a name="3162"><span class="lineNum">    3162 </span>            : </a>
<a name="3163"><span class="lineNum">    3163 </span>            :             // DQ (1/18/2021): This is now moved to the buildCommentAndCppDirectiveList() function (closer to where the vector of tokens is generated).</a>
<a name="3164"><span class="lineNum">    3164 </span>            :             // This function builds the data base (STL map) for the different subsequences ranges of the token stream.</a>
<a name="3165"><span class="lineNum">    3165 </span>            :             // and attaches the toke stream to the SgSourceFile IR node.</a>
<a name="3166"><span class="lineNum">    3166 </span>            :             // *** Next we have to attached the data base ***</a>
<a name="3167"><span class="lineNum">    3167 </span>            :             // buildTokenStreamMapping(sourceFile);</a>
<a name="3168"><span class="lineNum">    3168 </span>            : #if 0</a>
<a name="3169"><span class="lineNum">    3169 </span>            :                printf (&quot;sourceFile-&gt;get_token_list().size() = %zu \n&quot;,sourceFile-&gt;get_token_list().size());</a>
<a name="3170"><span class="lineNum">    3170 </span>            : #endif</a>
<a name="3171"><span class="lineNum">    3171 </span>            : </a>
<a name="3172"><span class="lineNum">    3172 </span>            : #if 0</a>
<a name="3173"><span class="lineNum">    3173 </span>            :             // DQ (7/1/2020): Debugging the token collection into the AST.</a>
<a name="3174"><span class="lineNum">    3174 </span>            :                printf (&quot;Exiting after test! \n&quot;);</a>
<a name="3175"><span class="lineNum">    3175 </span>            :                ROSE_ABORT();</a>
<a name="3176"><span class="lineNum">    3176 </span>            : #endif</a>
<a name="3177"><span class="lineNum">    3177 </span>            :             // DQ (9/26/2018): We should be able to enforce this for the current header file we have just processed.</a>
<a name="3178"><span class="lineNum">    3178 </span><span class="lineNoCov">          0 :                ASSERT_not_null(sourceFile-&gt;get_globalScope());</span></a>
<a name="3179"><span class="lineNum">    3179 </span>            : </a>
<a name="3180"><span class="lineNum">    3180 </span>            :             // DQ (12/2/2018): We can't enforce this for an empty file (see test in roseTests/astTokenStreamTests).</a>
<a name="3181"><span class="lineNum">    3181 </span>            :             // ROSE_ASSERT(sourceFile-&gt;get_tokenSubsequenceMap().find(sourceFile-&gt;get_globalScope()) != sourceFile-&gt;get_tokenSubsequenceMap().end());</a>
<a name="3182"><span class="lineNum">    3182 </span>            : #if 0</a>
<a name="3183"><span class="lineNum">    3183 </span>            :             // DQ (7/1/2020): Debugging output.</a>
<a name="3184"><span class="lineNum">    3184 </span>            :                printf (&quot;Calling display on token sequence for global scope (for *.C file) \n&quot;);</a>
<a name="3185"><span class="lineNum">    3185 </span>            :                ASSERT_not_null(sourceFile-&gt;get_tokenSubsequenceMap()[sourceFile-&gt;get_globalScope()]);</a>
<a name="3186"><span class="lineNum">    3186 </span>            :                TokenStreamSequenceToNodeMapping* tokenSequence = sourceFile-&gt;get_tokenSubsequenceMap()[sourceFile-&gt;get_globalScope()];</a>
<a name="3187"><span class="lineNum">    3187 </span>            :                ASSERT_not_null(tokenSequence);</a>
<a name="3188"><span class="lineNum">    3188 </span>            :                printf (&quot;sourceFile-&gt;get_tokenSubsequenceMap().size() = %zu \n&quot;,sourceFile-&gt;get_tokenSubsequenceMap().size());</a>
<a name="3189"><span class="lineNum">    3189 </span>            :                tokenSequence-&gt;display(&quot;token sequence for global scope (*.C file)&quot;);</a>
<a name="3190"><span class="lineNum">    3190 </span>            : #endif</a>
<a name="3191"><span class="lineNum">    3191 </span>            : </a>
<a name="3192"><span class="lineNum">    3192 </span>            : #if 0</a>
<a name="3193"><span class="lineNum">    3193 </span>            :             // Search over the list of include files</a>
<a name="3194"><span class="lineNum">    3194 </span>            : </a>
<a name="3195"><span class="lineNum">    3195 </span>            :             // DQ (11/15/2018): We have removed the include_file_list from the SgSourceFile so that we can support traversals on the SgIncludeFile tree.</a>
<a name="3196"><span class="lineNum">    3196 </span>            :             // SgIncludeFilePtrList &amp; include_file_list = sourceFile-&gt;get_include_file_list();</a>
<a name="3197"><span class="lineNum">    3197 </span>            :             // ROSE_ASSERT(sourceFile-&gt;get_associated_include_file() != NULL);</a>
<a name="3198"><span class="lineNum">    3198 </span>            :                if (sourceFile-&gt;get_associated_include_file() != nullptr)</a>
<a name="3199"><span class="lineNum">    3199 </span>            :                   {</a>
<a name="3200"><span class="lineNum">    3200 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="3201"><span class="lineNum">    3201 </span>            :                     SgIncludeFilePtrList &amp; include_file_list = sourceFile-&gt;get_associated_include_file()-&gt;get_include_file_list();</a>
<a name="3202"><span class="lineNum">    3202 </span>            : #if 0</a>
<a name="3203"><span class="lineNum">    3203 </span>            :                     printf (&quot;In SgProject::parse(): include_file_list.size() = %zu \n&quot;,include_file_list.size());</a>
<a name="3204"><span class="lineNum">    3204 </span>            : #endif</a>
<a name="3205"><span class="lineNum">    3205 </span>            :                     for (size_t i = 0; i &lt; include_file_list.size(); i++)</a>
<a name="3206"><span class="lineNum">    3206 </span>            :                        {</a>
<a name="3207"><span class="lineNum">    3207 </span>            :                          SgIncludeFile* includeFile = include_file_list[i];</a>
<a name="3208"><span class="lineNum">    3208 </span>            :                          ASSERT_not_null(includeFile);</a>
<a name="3209"><span class="lineNum">    3209 </span>            : #if 0</a>
<a name="3210"><span class="lineNum">    3210 </span>            :                          printf (&quot;In SgProject::parse(): includeFile-&gt;get_filename() = %s \n&quot;,includeFile-&gt;get_filename().str());</a>
<a name="3211"><span class="lineNum">    3211 </span>            : #endif</a>
<a name="3212"><span class="lineNum">    3212 </span>            :                       // DQ (9/26/2018): Note that this is null for include files that are not explicit in the source file (e.g. -isystem option).</a>
<a name="3213"><span class="lineNum">    3213 </span>            :                       // The common example is the header file &quot;rose_edg_required_macros_and_functions.h&quot;, which is never explicit include by the</a>
<a name="3214"><span class="lineNum">    3214 </span>            :                       // the source (*.C) file.</a>
<a name="3215"><span class="lineNum">    3215 </span>            :                          SgSourceFile* header_file = includeFile-&gt;get_source_file();</a>
<a name="3216"><span class="lineNum">    3216 </span>            :                       // ROSE_ASSERT(header_file != NULL);</a>
<a name="3217"><span class="lineNum">    3217 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="3218"><span class="lineNum">    3218 </span>            :                          if (header_file != nullptr)</a>
<a name="3219"><span class="lineNum">    3219 </span>            :                             {</a>
<a name="3220"><span class="lineNum">    3220 </span>            : #if 0</a>
<a name="3221"><span class="lineNum">    3221 </span>            :                            // DQ (11/10/2018): Added debugging output.</a>
<a name="3222"><span class="lineNum">    3222 </span>            :                               printf (&quot;header_file = %p header_file-&gt;getFileName() = %s \n&quot;,header_file,header_file-&gt;getFileName().c_str());</a>
<a name="3223"><span class="lineNum">    3223 </span>            :                               printf (&quot; --- header_file-&gt;getFileName() = %s \n&quot;,header_file-&gt;getFileName().c_str());</a>
<a name="3224"><span class="lineNum">    3224 </span>            : #endif</a>
<a name="3225"><span class="lineNum">    3225 </span>            :                            // DQ (11/29/2018): I think this is only valid when header file unparsing and token unparsing are used together.</a>
<a name="3226"><span class="lineNum">    3226 </span>            :                            // ROSE_ASSERT(header_file-&gt;get_globalScope() != NULL);</a>
<a name="3227"><span class="lineNum">    3227 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="3228"><span class="lineNum">    3228 </span>            :                               if (header_file-&gt;get_globalScope() != nullptr)</a>
<a name="3229"><span class="lineNum">    3229 </span>            :                                  {</a>
<a name="3230"><span class="lineNum">    3230 </span>            : #if 0</a>
<a name="3231"><span class="lineNum">    3231 </span>            :                                    printf (&quot;header_file-&gt;get_globalScope() = %p = %s \n&quot;,header_file-&gt;get_globalScope(),header_file-&gt;get_globalScope()-&gt;class_name().c_str());</a>
<a name="3232"><span class="lineNum">    3232 </span>            :                                    printf (&quot; --- header_file-&gt;get_tokenSubsequenceMap().size() = %zu \n&quot;,header_file-&gt;get_tokenSubsequenceMap().size());</a>
<a name="3233"><span class="lineNum">    3233 </span>            : #endif</a>
<a name="3234"><span class="lineNum">    3234 </span>            :                                    ROSE_ASSERT(header_file-&gt;get_tokenSubsequenceMap().find(header_file-&gt;get_globalScope()) != header_file-&gt;get_tokenSubsequenceMap().end());</a>
<a name="3235"><span class="lineNum">    3235 </span>            : #if 0</a>
<a name="3236"><span class="lineNum">    3236 </span>            :                                    printf (&quot;Calling display on token sequence for global scope (for *.h file) \n&quot;);</a>
<a name="3237"><span class="lineNum">    3237 </span>            :                                    ROSE_ASSERT(header_file-&gt;get_tokenSubsequenceMap()[header_file-&gt;get_globalScope()] != NULL);</a>
<a name="3238"><span class="lineNum">    3238 </span>            :                                    TokenStreamSequenceToNodeMapping* tokenSequence = header_file-&gt;get_tokenSubsequenceMap()[header_file-&gt;get_globalScope()];</a>
<a name="3239"><span class="lineNum">    3239 </span>            :                                    ROSE_ASSERT(tokenSequence != NULL);</a>
<a name="3240"><span class="lineNum">    3240 </span>            :                                    printf (&quot;header_file-&gt;get_tokenSubsequenceMap().size() = %zu \n&quot;,header_file-&gt;get_tokenSubsequenceMap().size());</a>
<a name="3241"><span class="lineNum">    3241 </span>            :                                    tokenSequence-&gt;display(&quot;token sequence for global scope (*.h file)&quot;);</a>
<a name="3242"><span class="lineNum">    3242 </span>            : #endif</a>
<a name="3243"><span class="lineNum">    3243 </span>            :                                  }</a>
<a name="3244"><span class="lineNum">    3244 </span>            :                             }</a>
<a name="3245"><span class="lineNum">    3245 </span>            :                        }</a>
<a name="3246"><span class="lineNum">    3246 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="3247"><span class="lineNum">    3247 </span>            :                   }</a>
<a name="3248"><span class="lineNum">    3248 </span>            : #endif</a>
<a name="3249"><span class="lineNum">    3249 </span>            : </a>
<a name="3250"><span class="lineNum">    3250 </span>            : #if DEBUG_SECONDARY_PASS</a>
<a name="3251"><span class="lineNum">    3251 </span>            :             // DQ (1/19/2021): This is a test for calling the get_tokenSubsequenceMap() function.</a>
<a name="3252"><span class="lineNum">    3252 </span>            :                printf (&quot;Testing first use of SgSourceFile::get_tokenSubsequenceMap() function:sourceFile = %p = %s \n&quot;,sourceFile,sourceFile-&gt;getFileName().c_str());</a>
<a name="3253"><span class="lineNum">    3253 </span>            :                map&lt;SgNode*,TokenStreamSequenceToNodeMapping*&gt; &amp; temp_tokenStreamSequenceMap = sourceFile-&gt;get_tokenSubsequenceMap();</a>
<a name="3254"><span class="lineNum">    3254 </span>            :                printf (&quot;DONE: Testing first use of SgSourceFile::get_tokenSubsequenceMap() function:sourceFile = %p = %s \n&quot;,sourceFile,sourceFile-&gt;getFileName().c_str());</a>
<a name="3255"><span class="lineNum">    3255 </span>            : #endif</a>
<a name="3256"><span class="lineNum">    3256 </span>            : #if 0</a>
<a name="3257"><span class="lineNum">    3257 </span>            :                printf (&quot;Exiting as a test! \n&quot;);</a>
<a name="3258"><span class="lineNum">    3258 </span>            :                ROSE_ABORT();</a>
<a name="3259"><span class="lineNum">    3259 </span>            : #endif</a>
<a name="3260"><span class="lineNum">    3260 </span>            :             // DQ (11/30/2015): Add support to detect macro and include file expansions (can use the token sequence mapping if available).</a>
<a name="3261"><span class="lineNum">    3261 </span>            :             // Not clear if I want to require the token sequence mapping, it is likely useful to detect macro expansions even without the</a>
<a name="3262"><span class="lineNum">    3262 </span>            :             // token sequence, but usig the token sequence permit us to gather more data.</a>
<a name="3263"><span class="lineNum">    3263 </span><span class="lineNoCov">          0 :                detectMacroOrIncludeFileExpansions(sourceFile);</span></a>
<a name="3264"><span class="lineNum">    3264 </span>            :              }</a>
<a name="3265"><span class="lineNum">    3265 </span>            :             else</a>
<a name="3266"><span class="lineNum">    3266 </span>            :              {</a>
<a name="3267"><span class="lineNum">    3267 </span>            :             // DQ (2/24/2021): Adding debugging support for the token-based unparsing.</a>
<a name="3268"><span class="lineNum">    3268 </span>            : #if 0</a>
<a name="3269"><span class="lineNum">    3269 </span>            :                printf (&quot;We should have been able to process this file to support token-based unparsing (something might have gone wrong) \n&quot;);</a>
<a name="3270"><span class="lineNum">    3270 </span>            :                printf (&quot;file-&gt;getFileName() = %s \n&quot;,file-&gt;getFileName().c_str());</a>
<a name="3271"><span class="lineNum">    3271 </span>            : #endif</a>
<a name="3272"><span class="lineNum">    3272 </span>            : #if 0</a>
<a name="3273"><span class="lineNum">    3273 </span>            :                printf (&quot;(false part of conditional) file-&gt;get_unparse_tokens() = %s \n&quot;,file-&gt;get_unparse_tokens() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="3274"><span class="lineNum">    3274 </span>            : #endif</a>
<a name="3275"><span class="lineNum">    3275 </span>            : #if 0</a>
<a name="3276"><span class="lineNum">    3276 </span>            :                printf (&quot;Exiting as a test! \n&quot;);</a>
<a name="3277"><span class="lineNum">    3277 </span>            :                ROSE_ASSERT(false);</a>
<a name="3278"><span class="lineNum">    3278 </span>            : #endif</a>
<a name="3279"><span class="lineNum">    3279 </span>            : #if 0</a>
<a name="3280"><span class="lineNum">    3280 </span>            :                if (file-&gt;getFileName() == &quot;/home/quinlan1/ROSE/ROSE_GARDEN/codeSegregation/tests/sources/test_135.h&quot;)</a>
<a name="3281"><span class="lineNum">    3281 </span>            :                   {</a>
<a name="3282"><span class="lineNum">    3282 </span>            :                     printf (&quot;Exiting as a test! \n&quot;);</a>
<a name="3283"><span class="lineNum">    3283 </span>            :                     ROSE_ASSERT(false);</a>
<a name="3284"><span class="lineNum">    3284 </span>            :                   }</a>
<a name="3285"><span class="lineNum">    3285 </span>            : #endif</a>
<a name="3286"><span class="lineNum">    3286 </span>            :              }</a>
<a name="3287"><span class="lineNum">    3287 </span>            : #if 0</a>
<a name="3288"><span class="lineNum">    3288 </span>            :           if ( SgProject::get_verbose() &gt; 0 )</a>
<a name="3289"><span class="lineNum">    3289 </span>            :              {</a>
<a name="3290"><span class="lineNum">    3290 </span>            :                printf (&quot;In SgProject::parse(): SgTokenPtrList token_list: token_list.size() = %zu \n&quot;,sourceFile-&gt;get_token_list().size());</a>
<a name="3291"><span class="lineNum">    3291 </span>            :              }</a>
<a name="3292"><span class="lineNum">    3292 </span>            : #endif</a>
<a name="3293"><span class="lineNum">    3293 </span>            : #if 0</a>
<a name="3294"><span class="lineNum">    3294 </span>            :           printf (&quot;DONE: Building token stream mapping map! \n&quot;);</a>
<a name="3295"><span class="lineNum">    3295 </span>            :           printf (&quot;In SgProject::parse(): SgTokenPtrList token_list: token_list.size() = %zu \n&quot;,sourceFile-&gt;get_token_list().size());</a>
<a name="3296"><span class="lineNum">    3296 </span>            : #endif</a>
<a name="3297"><span class="lineNum">    3297 </span>            : </a>
<a name="3298"><span class="lineNum">    3298 </span>            : #if 0</a>
<a name="3299"><span class="lineNum">    3299 </span>            :        // DQ (3/14/2021): Test this on our regression tests.</a>
<a name="3300"><span class="lineNum">    3300 </span>            :        // void buildFirstAndLastStatementsForIncludeFiles(SgSourceFile* sourceFile);</a>
<a name="3301"><span class="lineNum">    3301 </span>            :           SgSourceFile* sourceFile = isSgSourceFile(this);</a>
<a name="3302"><span class="lineNum">    3302 </span>            :           if (sourceFile != nullptr)</a>
<a name="3303"><span class="lineNum">    3303 </span>            :              {</a>
<a name="3304"><span class="lineNum">    3304 </span>            : </a>
<a name="3305"><span class="lineNum">    3305 </span>            :                printf (&quot;sourceFile-&gt;getFileName() = %s \n&quot;,sourceFile-&gt;getFileName().c_str());</a>
<a name="3306"><span class="lineNum">    3306 </span>            : </a>
<a name="3307"><span class="lineNum">    3307 </span>            :                std::map&lt;SgNode*,TokenStreamSequenceToNodeMapping*&gt; &amp; tokenStreamSequenceMap = sourceFile-&gt;get_tokenSubsequenceMap();</a>
<a name="3308"><span class="lineNum">    3308 </span>            : #if 0</a>
<a name="3309"><span class="lineNum">    3309 </span>            :                printf (&quot; --- tokenStreamSequenceMap.size() = %zu \n&quot;,tokenStreamSequenceMap.size());</a>
<a name="3310"><span class="lineNum">    3310 </span>            : #endif</a>
<a name="3311"><span class="lineNum">    3311 </span>            :             // SageInterface::translateToUseCppDeclarations(sourceFile);</a>
<a name="3312"><span class="lineNum">    3312 </span>            :             // DQ (3/8/2021): Build a map of the first and last statement in each include file.</a>
<a name="3313"><span class="lineNum">    3313 </span>            :             // buildFirstAndLastStatementsForIncludeFiles(sourceFile);</a>
<a name="3314"><span class="lineNum">    3314 </span>            :              }</a>
<a name="3315"><span class="lineNum">    3315 </span>            : #if 0</a>
<a name="3316"><span class="lineNum">    3316 </span>            :           printf (&quot;DONE: buildFirstAndLastStatementsForIncludeFiles! \n&quot;);</a>
<a name="3317"><span class="lineNum">    3317 </span>            :           printf (&quot;In SgProject::parse(): SgTokenPtrList token_list: token_list.size() = %zu \n&quot;,sourceFile-&gt;get_token_list().size());</a>
<a name="3318"><span class="lineNum">    3318 </span>            : #endif</a>
<a name="3319"><span class="lineNum">    3319 </span>            : #endif</a>
<a name="3320"><span class="lineNum">    3320 </span>            :         }</a>
<a name="3321"><span class="lineNum">    3321 </span>            : </a>
<a name="3322"><span class="lineNum">    3322 </span>            : #else</a>
<a name="3323"><span class="lineNum">    3323 </span>            : </a>
<a name="3324"><span class="lineNum">    3324 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="3325"><span class="lineNum">    3325 </span>            : </a>
<a name="3326"><span class="lineNum">    3326 </span>            :             // Normal path calling attachPreprocessingInfo()</a>
<a name="3327"><span class="lineNum">    3327 </span>            :                attachPreprocessingInfo(sourceFile);</a>
<a name="3328"><span class="lineNum">    3328 </span>            : #endif</a>
<a name="3329"><span class="lineNum">    3329 </span>            : </a>
<a name="3330"><span class="lineNum">    3330 </span>            : #ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT</a>
<a name="3331"><span class="lineNum">    3331 </span>            :             // Liao, 3/31/2009 Handle OpenMP here to see macro calls within directives</a>
<a name="3332"><span class="lineNum">    3332 </span><span class="lineCov">        353 :                processOpenMP(sourceFile);</span></a>
<a name="3333"><span class="lineNum">    3333 </span>            : #endif</a>
<a name="3334"><span class="lineNum">    3334 </span>            :                // Liao, 1/29/2014, handle failsafe pragmas for resilience work</a>
<a name="3335"><span class="lineNum">    3335 </span>            :                //if (sourceFile-&gt;get_failsafe())</a>
<a name="3336"><span class="lineNum">    3336 </span>            :                //  FailSafe::process_fail_safe_directives (sourceFile);</a>
<a name="3337"><span class="lineNum">    3337 </span>            : </a>
<a name="3338"><span class="lineNum">    3338 </span>            :             // Reset the saved state (might not really be required at this point).</a>
<a name="3339"><span class="lineNum">    3339 </span><span class="lineCov">        353 :                if (requiresCPP == true)</span></a>
<a name="3340"><span class="lineNum">    3340 </span>            :                   {</a>
<a name="3341"><span class="lineNum">    3341 </span>            : #if 0</a>
<a name="3342"><span class="lineNum">    3342 </span>            :                     printf (&quot;@@@@@@@@@@@@@@ Set requires_C_preprocessor to false (test 5) \n&quot;);</a>
<a name="3343"><span class="lineNum">    3343 </span>            : #endif</a>
<a name="3344"><span class="lineNum">    3344 </span><span class="lineNoCov">          0 :                     set_requires_C_preprocessor(false);</span></a>
<a name="3345"><span class="lineNum">    3345 </span>            :                   }</a>
<a name="3346"><span class="lineNum">    3346 </span>            : </a>
<a name="3347"><span class="lineNum">    3347 </span>            : #if 0</a>
<a name="3348"><span class="lineNum">    3348 </span>            :                printf (&quot;In SgFile::secondaryPassOverSourceFile(): exiting after attachPreprocessingInfo() \n&quot;);</a>
<a name="3349"><span class="lineNum">    3349 </span>            :                ROSE_ABORT();</a>
<a name="3350"><span class="lineNum">    3350 </span>            : #endif</a>
<a name="3351"><span class="lineNum">    3351 </span><span class="lineCov">        353 :                if (get_verbose() &gt; 1)</span></a>
<a name="3352"><span class="lineNum">    3352 </span>            :                   {</a>
<a name="3353"><span class="lineNum">    3353 </span><span class="lineNoCov">          0 :                     printf (&quot;In SgFile::secondaryPassOverSourceFile(): Done with attachAllPreprocessingInfo() \n&quot;);</span></a>
<a name="3354"><span class="lineNum">    3354 </span>            :                   }</a>
<a name="3355"><span class="lineNum">    3355 </span>            : </a>
<a name="3356"><span class="lineNum">    3356 </span>            :             // DQ (12/13/2012): Insert pass over AST to detect &quot;#line&quot; directives within only the input source file and</a>
<a name="3357"><span class="lineNum">    3357 </span>            :             // accoumulate a list of filenames that will have statements incorrectly marked as being from another file.</a>
<a name="3358"><span class="lineNum">    3358 </span>            :             // This might be something we want to control via a command line option.  This sort fo processing can be</a>
<a name="3359"><span class="lineNum">    3359 </span>            :             // important for generated files (e.g. the sudo application has four generated C language files from lex</a>
<a name="3360"><span class="lineNum">    3360 </span>            :             // that are generated into a file toke.c but with #line N &quot;toke.l&quot; CPP directives and this fools ROSE into</a>
<a name="3361"><span class="lineNum">    3361 </span>            :             // not unparsing all of the code from the token.c file (because some of it is assigned to the filename &quot;toke.l&quot;.</a>
<a name="3362"><span class="lineNum">    3362 </span>            :             // For the case of the sudo application code this prevents the generated code from linking properly (undefined symbols).</a>
<a name="3363"><span class="lineNum">    3363 </span>            :             // Since many application include generated code (including ROSE itself) we would like to support this better.</a>
<a name="3364"><span class="lineNum">    3364 </span><span class="lineCov">        353 :                ASSERT_not_null(sourceFile);</span></a>
<a name="3365"><span class="lineNum">    3365 </span>            :             // sourceFile-&gt;gatherASTSourcePositionsBasedOnDetectedLineDirectives();</a>
<a name="3366"><span class="lineNum">    3366 </span>            :             // sourceFile-&gt;fixupASTSourcePositionsBasedOnDetectedLineDirectives();</a>
<a name="3367"><span class="lineNum">    3367 </span>            : </a>
<a name="3368"><span class="lineNum">    3368 </span>            :              } //end if get_skip_commentsAndDirectives() is false</a>
<a name="3369"><span class="lineNum">    3369 </span>            :         }</a>
<a name="3370"><span class="lineNum">    3370 </span>            : </a>
<a name="3371"><span class="lineNum">    3371 </span>            : #if 0</a>
<a name="3372"><span class="lineNum">    3372 </span>            :      printf (&quot;Leaving SgFile::secondaryPassOverSourceFile() \n&quot;);</a>
<a name="3373"><span class="lineNum">    3373 </span>            : #endif</a>
<a name="3374"><span class="lineNum">    3374 </span>            : #if 0</a>
<a name="3375"><span class="lineNum">    3375 </span>            :      printf (&quot;Leaving SgFile::secondaryPassOverSourceFile(): fileNameIndex = %d \n&quot;,fileNameIndex);</a>
<a name="3376"><span class="lineNum">    3376 </span>            :      display(&quot;At bottom of SgFile::secondaryPassOverSourceFile()&quot;);</a>
<a name="3377"><span class="lineNum">    3377 </span>            : #endif</a>
<a name="3378"><span class="lineNum">    3378 </span>            : </a>
<a name="3379"><span class="lineNum">    3379 </span>            : #if 1</a>
<a name="3380"><span class="lineNum">    3380 </span>            :   // DQ (8/22/2009): We test the parent of SgFunctionTypeTable in the AST post processing,</a>
<a name="3381"><span class="lineNum">    3381 </span>            :   // so we need to make sure that it is set.</a>
<a name="3382"><span class="lineNum">    3382 </span><span class="lineCov">        353 :      SgFunctionTypeTable* functionTypeTable = SgNode::get_globalFunctionTypeTable();</span></a>
<a name="3383"><span class="lineNum">    3383 </span>            :   // ROSE_ASSERT(functionTypeTable != NULL);</a>
<a name="3384"><span class="lineNum">    3384 </span><span class="lineCov">        353 :      if (functionTypeTable != nullptr &amp;&amp; functionTypeTable-&gt;get_parent() == nullptr)</span></a>
<a name="3385"><span class="lineNum">    3385 </span>            :         {</a>
<a name="3386"><span class="lineNum">    3386 </span>            :        // printf (&quot;In SgFile::callFrontEnd(): set the parent of SgFunctionTypeTable \n&quot;);</a>
<a name="3387"><span class="lineNum">    3387 </span><span class="lineNoCov">          0 :           functionTypeTable-&gt;set_parent(this);</span></a>
<a name="3388"><span class="lineNum">    3388 </span>            :         }</a>
<a name="3389"><span class="lineNum">    3389 </span>            :   // ROSE_ASSERT(functionTypeTable-&gt;get_parent() != NULL);</a>
<a name="3390"><span class="lineNum">    3390 </span>            : #endif</a>
<a name="3391"><span class="lineNum">    3391 </span>            : </a>
<a name="3392"><span class="lineNum">    3392 </span>            :   // DQ (3/14/2021): Not clear if this needs to be here.</a>
<a name="3393"><span class="lineNum">    3393 </span>            :   // SageInterface::translateToUseCppDeclarations(sourceFile);</a>
<a name="3394"><span class="lineNum">    3394 </span>            : </a>
<a name="3395"><span class="lineNum">    3395 </span>            :   // ROSE_ASSERT(SgNode::get_globalFunctionTypeTable() != NULL);</a>
<a name="3396"><span class="lineNum">    3396 </span>            :   // ROSE_ASSERT(SgNode::get_globalFunctionTypeTable()-&gt;get_parent() != NULL);</a>
<a name="3397"><span class="lineNum">    3397 </span><span class="lineCov">        353 :    }</span></a>
<a name="3398"><span class="lineNum">    3398 </span>            : </a>
<a name="3399"><span class="lineNum">    3399 </span>            : </a>
<a name="3400"><span class="lineNum">    3400 </span>            : #if 0</a>
<a name="3401"><span class="lineNum">    3401 </span>            : namespace SgSourceFile_processCppLinemarkers</a>
<a name="3402"><span class="lineNum">    3402 </span>            :    {</a>
<a name="3403"><span class="lineNum">    3403 </span>            :   // This class (AST traversal) supports the traversal of the AST required</a>
<a name="3404"><span class="lineNum">    3404 </span>            :   // to translate the source position using the CPP linemarkers.</a>
<a name="3405"><span class="lineNum">    3405 </span>            : </a>
<a name="3406"><span class="lineNum">    3406 </span>            :      class GatherASTSourcePositionsBasedOnDetectedLineDirectives : public AstSimpleProcessing</a>
<a name="3407"><span class="lineNum">    3407 </span>            :         {</a>
<a name="3408"><span class="lineNum">    3408 </span>            :           public:</a>
<a name="3409"><span class="lineNum">    3409 </span>            :               set&lt;int&gt; filenameIdList;</a>
<a name="3410"><span class="lineNum">    3410 </span>            : </a>
<a name="3411"><span class="lineNum">    3411 </span>            :               GatherASTSourcePositionsBasedOnDetectedLineDirectives( const string &amp; sourceFilename );</a>
<a name="3412"><span class="lineNum">    3412 </span>            : </a>
<a name="3413"><span class="lineNum">    3413 </span>            :               void visit ( SgNode* astNode );</a>
<a name="3414"><span class="lineNum">    3414 </span>            :         };</a>
<a name="3415"><span class="lineNum">    3415 </span>            :    }</a>
<a name="3416"><span class="lineNum">    3416 </span>            : </a>
<a name="3417"><span class="lineNum">    3417 </span>            : SgSourceFile_processCppLinemarkers::GatherASTSourcePositionsBasedOnDetectedLineDirectives::GatherASTSourcePositionsBasedOnDetectedLineDirectives( const string &amp; sourceFilename )</a>
<a name="3418"><span class="lineNum">    3418 </span>            :    {</a>
<a name="3419"><span class="lineNum">    3419 </span>            :   // Build an initial element on the stack so that the original source file name will be used to</a>
<a name="3420"><span class="lineNum">    3420 </span>            :   // set the global scope (which will be traversed before we visit any statements that might have</a>
<a name="3421"><span class="lineNum">    3421 </span>            :   // CPP directives attached (or which are CPP direcitve IR nodes).</a>
<a name="3422"><span class="lineNum">    3422 </span>            : </a>
<a name="3423"><span class="lineNum">    3423 </span>            :   // Get the fileId of the assocated filename</a>
<a name="3424"><span class="lineNum">    3424 </span>            :      int fileId = Sg_File_Info::getIDFromFilename(sourceFilename);</a>
<a name="3425"><span class="lineNum">    3425 </span>            : </a>
<a name="3426"><span class="lineNum">    3426 </span>            :      if ( SgProject::get_verbose() &gt; 1 )</a>
<a name="3427"><span class="lineNum">    3427 </span>            :           printf (&quot;In GatherASTSourcePositionsBasedOnDetectedLineDirectives::GatherASTSourcePositionsBasedOnDetectedLineDirectives(): source file: fileId = %d sourceFilename = %s \n&quot;,fileId,sourceFilename.c_str());</a>
<a name="3428"><span class="lineNum">    3428 </span>            : </a>
<a name="3429"><span class="lineNum">    3429 </span>            :   // Push an entry onto the stack before doing the traversal over the whole AST.</a>
<a name="3430"><span class="lineNum">    3430 </span>            :   // filenameIdList.insert(fileId);</a>
<a name="3431"><span class="lineNum">    3431 </span>            :    }</a>
<a name="3432"><span class="lineNum">    3432 </span>            : </a>
<a name="3433"><span class="lineNum">    3433 </span>            : </a>
<a name="3434"><span class="lineNum">    3434 </span>            : void</a>
<a name="3435"><span class="lineNum">    3435 </span>            : SgSourceFile_processCppLinemarkers::GatherASTSourcePositionsBasedOnDetectedLineDirectives::visit ( SgNode* astNode )</a>
<a name="3436"><span class="lineNum">    3436 </span>            :    {</a>
<a name="3437"><span class="lineNum">    3437 </span>            :   // DQ (12/14/2012): This functionality is being added to support applications like sudo which have generated code from tools like lex.</a>
<a name="3438"><span class="lineNum">    3438 </span>            :   // This traversal is defined to detect the use of &quot;#line&quot; directived and then accumulate the list of filenames used in the #line directives.</a>
<a name="3439"><span class="lineNum">    3439 </span>            :   // When #line directives are used in the input source file then we consider all statements associated with those filenames to be from the</a>
<a name="3440"><span class="lineNum">    3440 </span>            :   // input source file and direct them to be unparsed.  The actual way we trigger them to be unparsed is to make the source position to</a>
<a name="3441"><span class="lineNum">    3441 </span>            :   // be unparsed in the Sg_File_Info object, this is enough to force the unparsed to output those statements.</a>
<a name="3442"><span class="lineNum">    3442 </span>            :   // TODO: It might be that this should operate on SgLocatedNode IR nodes instead of SgStatement IR nodes.</a>
<a name="3443"><span class="lineNum">    3443 </span>            : </a>
<a name="3444"><span class="lineNum">    3444 </span>            :      SgStatement* statement = isSgStatement(astNode);</a>
<a name="3445"><span class="lineNum">    3445 </span>            : </a>
<a name="3446"><span class="lineNum">    3446 </span>            :      printf (&quot;GatherASTSourcePositionsBasedOnDetectedLineDirectives::visit(): statement = %p = %s \n&quot;,statement,(statement != nullptr) ? statement-&gt;class_name().c_str() : &quot;NULL&quot;);</a>
<a name="3447"><span class="lineNum">    3447 </span>            : </a>
<a name="3448"><span class="lineNum">    3448 </span>            :      if (statement != nullptr)</a>
<a name="3449"><span class="lineNum">    3449 </span>            :         {</a>
<a name="3450"><span class="lineNum">    3450 </span>            :           if ( SgProject::get_verbose() &gt; 1)</a>
<a name="3451"><span class="lineNum">    3451 </span>            :                printf (&quot;GatherASTSourcePositionsBasedOnDetectedLineDirectives::visit(): statement = %p = %s \n&quot;,statement,statement-&gt;class_name().c_str());</a>
<a name="3452"><span class="lineNum">    3452 </span>            : </a>
<a name="3453"><span class="lineNum">    3453 </span>            :           AttachedPreprocessingInfoType *commentOrDirectiveList = statement-&gt;getAttachedPreprocessingInfo();</a>
<a name="3454"><span class="lineNum">    3454 </span>            : </a>
<a name="3455"><span class="lineNum">    3455 </span>            :           if (SgProject::get_verbose() &gt; 1)</a>
<a name="3456"><span class="lineNum">    3456 </span>            :                printf (&quot;GatherASTSourcePositionsBasedOnDetectedLineDirectives::visit(): commentOrDirectiveList = %p (size = %&quot; PRIuPTR &quot;) \n&quot;,commentOrDirectiveList,(commentOrDirectiveList != NULL) ? commentOrDirectiveList-&gt;size() : 0);</a>
<a name="3457"><span class="lineNum">    3457 </span>            : </a>
<a name="3458"><span class="lineNum">    3458 </span>            :           if (commentOrDirectiveList != nullptr)</a>
<a name="3459"><span class="lineNum">    3459 </span>            :              {</a>
<a name="3460"><span class="lineNum">    3460 </span>            :                AttachedPreprocessingInfoType::iterator i = commentOrDirectiveList-&gt;begin();</a>
<a name="3461"><span class="lineNum">    3461 </span>            :                while(i != commentOrDirectiveList-&gt;end())</a>
<a name="3462"><span class="lineNum">    3462 </span>            :                   {</a>
<a name="3463"><span class="lineNum">    3463 </span>            : #if 0</a>
<a name="3464"><span class="lineNum">    3464 </span>            :                     printf (&quot;Directve type = %d = %s = %s \n&quot;,(*i)-&gt;getTypeOfDirective(),PreprocessingInfo::directiveTypeName((*i)-&gt;getTypeOfDirective()).c_str(),(*i)-&gt;getString().c_str());</a>
<a name="3465"><span class="lineNum">    3465 </span>            : #endif</a>
<a name="3466"><span class="lineNum">    3466 </span>            :                  // if ( (*i)-&gt;getTypeOfDirective() == PreprocessingInfo::CpreprocessorCompilerGeneratedLinemarker )</a>
<a name="3467"><span class="lineNum">    3467 </span>            :                     if ( (*i)-&gt;getTypeOfDirective() == PreprocessingInfo::CpreprocessorLineDeclaration )</a>
<a name="3468"><span class="lineNum">    3468 </span>            :                        {</a>
<a name="3469"><span class="lineNum">    3469 </span>            :                       // This is a CPP line directive</a>
<a name="3470"><span class="lineNum">    3470 </span>            :                          string directiveString = (*i)-&gt;getString();</a>
<a name="3471"><span class="lineNum">    3471 </span>            : #if 0</a>
<a name="3472"><span class="lineNum">    3472 </span>            :                          printf (&quot;directiveString = %s \n&quot;,directiveString.c_str());</a>
<a name="3473"><span class="lineNum">    3473 </span>            : #endif</a>
<a name="3474"><span class="lineNum">    3474 </span>            :                       // Remove leading white space.</a>
<a name="3475"><span class="lineNum">    3475 </span>            :                          size_t p = directiveString.find_first_not_of(&quot;# \t&quot;);</a>
<a name="3476"><span class="lineNum">    3476 </span>            :                          directiveString.erase(0,p);</a>
<a name="3477"><span class="lineNum">    3477 </span>            : #if 0</a>
<a name="3478"><span class="lineNum">    3478 </span>            :                          printf (&quot;directiveString (trimmed) = %s \n&quot;,directiveString.c_str());</a>
<a name="3479"><span class="lineNum">    3479 </span>            : #endif</a>
<a name="3480"><span class="lineNum">    3480 </span>            :                       // string directiveStringWithoutHash = directiveString;</a>
<a name="3481"><span class="lineNum">    3481 </span>            :                          size_t lengthOfLineKeyword = string(&quot;line&quot;).length();</a>
<a name="3482"><span class="lineNum">    3482 </span>            : </a>
<a name="3483"><span class="lineNum">    3483 </span>            :                          string directiveStringWithoutHashAndKeyword = directiveString.substr(lengthOfLineKeyword,directiveString.length()-(lengthOfLineKeyword+1));</a>
<a name="3484"><span class="lineNum">    3484 </span>            : #if 0</a>
<a name="3485"><span class="lineNum">    3485 </span>            :                          printf (&quot;directiveStringWithoutHashAndKeyword = %s \n&quot;,directiveStringWithoutHashAndKeyword.c_str());</a>
<a name="3486"><span class="lineNum">    3486 </span>            : #endif</a>
<a name="3487"><span class="lineNum">    3487 </span>            :                       // Remove white space between &quot;#&quot; and &quot;line&quot; keyword.</a>
<a name="3488"><span class="lineNum">    3488 </span>            :                          p = directiveStringWithoutHashAndKeyword.find_first_not_of(&quot; \t&quot;);</a>
<a name="3489"><span class="lineNum">    3489 </span>            :                          directiveStringWithoutHashAndKeyword.erase(0, p);</a>
<a name="3490"><span class="lineNum">    3490 </span>            : #if 0</a>
<a name="3491"><span class="lineNum">    3491 </span>            :                          printf (&quot;directiveStringWithoutHashLineAndKeyword (trimmed) = %s \n&quot;,directiveStringWithoutHashAndKeyword.c_str());</a>
<a name="3492"><span class="lineNum">    3492 </span>            : #endif</a>
<a name="3493"><span class="lineNum">    3493 </span>            :                       // At this point we have just '2 &quot;toke.l&quot;', and we can strip off the number.</a>
<a name="3494"><span class="lineNum">    3494 </span>            :                          p = directiveStringWithoutHashAndKeyword.find_first_not_of(&quot;0123456789&quot;);</a>
<a name="3495"><span class="lineNum">    3495 </span>            : </a>
<a name="3496"><span class="lineNum">    3496 </span>            :                          string lineNumberString = directiveStringWithoutHashAndKeyword.substr(0,p);</a>
<a name="3497"><span class="lineNum">    3497 </span>            : #if 0</a>
<a name="3498"><span class="lineNum">    3498 </span>            :                          printf (&quot;lineNumberString = %s \n&quot;,lineNumberString.c_str());</a>
<a name="3499"><span class="lineNum">    3499 </span>            : #endif</a>
<a name="3500"><span class="lineNum">    3500 </span>            :                          int line = atoi(lineNumberString.c_str());</a>
<a name="3501"><span class="lineNum">    3501 </span>            : </a>
<a name="3502"><span class="lineNum">    3502 </span>            :                       // string directiveStringWithoutHashAndKeywordAndLineNumber = directiveStringWithoutHashAndKeyword.substr(p,directiveStringWithoutHashAndKeyword.length()-(p+1));</a>
<a name="3503"><span class="lineNum">    3503 </span>            :                          string directiveStringWithoutHashAndKeywordAndLineNumber = directiveStringWithoutHashAndKeyword.substr(p,directiveStringWithoutHashAndKeyword.length());</a>
<a name="3504"><span class="lineNum">    3504 </span>            : #if 0</a>
<a name="3505"><span class="lineNum">    3505 </span>            :                          printf (&quot;directiveStringWithoutHashAndKeywordAndLineNumber = %s \n&quot;,directiveStringWithoutHashAndKeywordAndLineNumber.c_str());</a>
<a name="3506"><span class="lineNum">    3506 </span>            : #endif</a>
<a name="3507"><span class="lineNum">    3507 </span>            :                       // Remove white space between the line number and the filename.</a>
<a name="3508"><span class="lineNum">    3508 </span>            :                          p = directiveStringWithoutHashAndKeywordAndLineNumber.find_first_not_of(&quot; \t&quot;);</a>
<a name="3509"><span class="lineNum">    3509 </span>            :                          directiveStringWithoutHashAndKeywordAndLineNumber.erase(0,p);</a>
<a name="3510"><span class="lineNum">    3510 </span>            : #if 0</a>
<a name="3511"><span class="lineNum">    3511 </span>            :                          printf (&quot;directiveStringWithoutHashAndKeywordAndLineNumber (trimmed) = %s \n&quot;,directiveStringWithoutHashAndKeywordAndLineNumber.c_str());</a>
<a name="3512"><span class="lineNum">    3512 </span>            : #endif</a>
<a name="3513"><span class="lineNum">    3513 </span>            :                          string quotedFilename = directiveStringWithoutHashAndKeywordAndLineNumber;</a>
<a name="3514"><span class="lineNum">    3514 </span>            : #if 0</a>
<a name="3515"><span class="lineNum">    3515 </span>            :                          printf (&quot;quotedFilename = %s \n&quot;,quotedFilename.c_str());</a>
<a name="3516"><span class="lineNum">    3516 </span>            : #endif</a>
<a name="3517"><span class="lineNum">    3517 </span>            :                          ROSE_ASSERT(quotedFilename[0] == '\&quot;');</a>
<a name="3518"><span class="lineNum">    3518 </span>            :                          ROSE_ASSERT(quotedFilename[quotedFilename.length()-1] == '\&quot;');</a>
<a name="3519"><span class="lineNum">    3519 </span>            :                          std::string filename = quotedFilename.substr(1,quotedFilename.length()-2);</a>
<a name="3520"><span class="lineNum">    3520 </span>            : #if 0</a>
<a name="3521"><span class="lineNum">    3521 </span>            :                          printf (&quot;filename = %s \n&quot;,filename.c_str());</a>
<a name="3522"><span class="lineNum">    3522 </span>            : #endif</a>
<a name="3523"><span class="lineNum">    3523 </span>            :                       // Add the new filename to the static map stored in the Sg_File_Info (no action if filename is already in the map).</a>
<a name="3524"><span class="lineNum">    3524 </span>            :                          Sg_File_Info::addFilenameToMap(filename);</a>
<a name="3525"><span class="lineNum">    3525 </span>            : </a>
<a name="3526"><span class="lineNum">    3526 </span>            :                          int fileId = Sg_File_Info::getIDFromFilename(filename);</a>
<a name="3527"><span class="lineNum">    3527 </span>            : </a>
<a name="3528"><span class="lineNum">    3528 </span>            :                          if (SgProject::get_verbose() &gt;= 0)</a>
<a name="3529"><span class="lineNum">    3529 </span>            :                               printf (&quot;In SgSourceFile_processCppLinemarkers::GatherASTSourcePositionsBasedOnDetectedLineDirectives::visit(): line = %d fileId = %d quotedFilename = %s filename = %s \n&quot;,line,fileId,quotedFilename.c_str(),filename.c_str());</a>
<a name="3530"><span class="lineNum">    3530 </span>            : </a>
<a name="3531"><span class="lineNum">    3531 </span>            :                          if (filenameIdList.find(fileId) == filenameIdList.end())</a>
<a name="3532"><span class="lineNum">    3532 </span>            :                             {</a>
<a name="3533"><span class="lineNum">    3533 </span>            :                               filenameIdList.insert(fileId);</a>
<a name="3534"><span class="lineNum">    3534 </span>            :                             }</a>
<a name="3535"><span class="lineNum">    3535 </span>            :                        }</a>
<a name="3536"><span class="lineNum">    3536 </span>            : </a>
<a name="3537"><span class="lineNum">    3537 </span>            :                     i++;</a>
<a name="3538"><span class="lineNum">    3538 </span>            :                   }</a>
<a name="3539"><span class="lineNum">    3539 </span>            :              }</a>
<a name="3540"><span class="lineNum">    3540 </span>            :         }</a>
<a name="3541"><span class="lineNum">    3541 </span>            :    }</a>
<a name="3542"><span class="lineNum">    3542 </span>            : #endif</a>
<a name="3543"><span class="lineNum">    3543 </span>            : </a>
<a name="3544"><span class="lineNum">    3544 </span>            : #if 0</a>
<a name="3545"><span class="lineNum">    3545 </span>            : void</a>
<a name="3546"><span class="lineNum">    3546 </span>            : SgSourceFile::gatherASTSourcePositionsBasedOnDetectedLineDirectives()</a>
<a name="3547"><span class="lineNum">    3547 </span>            :    {</a>
<a name="3548"><span class="lineNum">    3548 </span>            :   // DQ (12/18/2012): This is not inlined into the fixupASTSourcePositionsBasedOnDetectedLineDirectives() function to simplify the code.</a>
<a name="3549"><span class="lineNum">    3549 </span>            : </a>
<a name="3550"><span class="lineNum">    3550 </span>            :      printf (&quot;Error: This function should not be called \n&quot;);</a>
<a name="3551"><span class="lineNum">    3551 </span>            :      ROSE_ABORT();</a>
<a name="3552"><span class="lineNum">    3552 </span>            : </a>
<a name="3553"><span class="lineNum">    3553 </span>            : #if 0</a>
<a name="3554"><span class="lineNum">    3554 </span>            :      SgSourceFile* sourceFile = const_cast&lt;SgSourceFile*&gt;(this);</a>
<a name="3555"><span class="lineNum">    3555 </span>            : </a>
<a name="3556"><span class="lineNum">    3556 </span>            :      SgSourceFile_processCppLinemarkers::GatherASTSourcePositionsBasedOnDetectedLineDirectives linemarkerTraversal(sourceFile-&gt;get_sourceFileNameWithPath());</a>
<a name="3557"><span class="lineNum">    3557 </span>            : </a>
<a name="3558"><span class="lineNum">    3558 </span>            :      linemarkerTraversal.traverse(sourceFile,preorder);</a>
<a name="3559"><span class="lineNum">    3559 </span>            : </a>
<a name="3560"><span class="lineNum">    3560 </span>            : #if 0</a>
<a name="3561"><span class="lineNum">    3561 </span>            :      set&lt;int&gt;::iterator i = linemarkerTraversal.filenameIdList.begin();</a>
<a name="3562"><span class="lineNum">    3562 </span>            :      int counter = 0;</a>
<a name="3563"><span class="lineNum">    3563 </span>            :      while (i != linemarkerTraversal.filenameIdList.end())</a>
<a name="3564"><span class="lineNum">    3564 </span>            :         {</a>
<a name="3565"><span class="lineNum">    3565 </span>            :           printf (&quot;filenameIdList entry #%d = %d \n&quot;,counter,*i);</a>
<a name="3566"><span class="lineNum">    3566 </span>            :           counter++;</a>
<a name="3567"><span class="lineNum">    3567 </span>            : </a>
<a name="3568"><span class="lineNum">    3568 </span>            :           i++;</a>
<a name="3569"><span class="lineNum">    3569 </span>            :         }</a>
<a name="3570"><span class="lineNum">    3570 </span>            : #endif</a>
<a name="3571"><span class="lineNum">    3571 </span>            : #else</a>
<a name="3572"><span class="lineNum">    3572 </span>            :      printf (&quot;NOTE: SgSourceFile::gatherASTSourcePositionsBasedOnDetectedLineDirectives(): empty function \n&quot;);</a>
<a name="3573"><span class="lineNum">    3573 </span>            : #endif</a>
<a name="3574"><span class="lineNum">    3574 </span>            : #if 0</a>
<a name="3575"><span class="lineNum">    3575 </span>            :      printf (&quot;Exiting as a test ... (processing gatherASTSourcePositionsBasedOnDetectedLineDirectives) \n&quot;);</a>
<a name="3576"><span class="lineNum">    3576 </span>            :      ROSE_ABORT();</a>
<a name="3577"><span class="lineNum">    3577 </span>            : #endif</a>
<a name="3578"><span class="lineNum">    3578 </span>            :    }</a>
<a name="3579"><span class="lineNum">    3579 </span>            : #endif</a>
<a name="3580"><span class="lineNum">    3580 </span>            : </a>
<a name="3581"><span class="lineNum">    3581 </span>            : </a>
<a name="3582"><span class="lineNum">    3582 </span>            : #if 1</a>
<a name="3583"><span class="lineNum">    3583 </span>            : namespace SgSourceFile_processCppLinemarkers</a>
<a name="3584"><span class="lineNum">    3584 </span>            :    {</a>
<a name="3585"><span class="lineNum">    3585 </span>            :      class FixupASTSourcePositionsBasedOnDetectedLineDirectives : public AstSimpleProcessing</a>
<a name="3586"><span class="lineNum">    3586 </span>            :         {</a>
<a name="3587"><span class="lineNum">    3587 </span>            :           public:</a>
<a name="3588"><span class="lineNum">    3588 </span>            :               set&lt;int&gt; filenameIdList;</a>
<a name="3589"><span class="lineNum">    3589 </span>            : </a>
<a name="3590"><span class="lineNum">    3590 </span>            :               FixupASTSourcePositionsBasedOnDetectedLineDirectives( const string &amp; sourceFilename, set&lt;int&gt; &amp; filenameSet );</a>
<a name="3591"><span class="lineNum">    3591 </span>            : </a>
<a name="3592"><span class="lineNum">    3592 </span>            :               void visit ( SgNode* astNode );</a>
<a name="3593"><span class="lineNum">    3593 </span>            :         };</a>
<a name="3594"><span class="lineNum">    3594 </span>            :    }</a>
<a name="3595"><span class="lineNum">    3595 </span>            : </a>
<a name="3596"><span class="lineNum">    3596 </span>            : </a>
<a name="3597"><span class="lineNum">    3597 </span><span class="lineNoCov">          0 : SgSourceFile_processCppLinemarkers::FixupASTSourcePositionsBasedOnDetectedLineDirectives::FixupASTSourcePositionsBasedOnDetectedLineDirectives( const string &amp; sourceFilename, set&lt;int&gt; &amp; filenameSet )</span></a>
<a name="3598"><span class="lineNum">    3598 </span><span class="lineNoCov">          0 :    : filenameIdList(filenameSet)</span></a>
<a name="3599"><span class="lineNum">    3599 </span>            :    {</a>
<a name="3600"><span class="lineNum">    3600 </span><span class="lineNoCov">          0 :      if (SgProject::get_verbose() &gt; 1)</span></a>
<a name="3601"><span class="lineNum">    3601 </span><span class="lineNoCov">          0 :           printf (&quot;In FixupASTSourcePositionsBasedOnDetectedLineDirectives::FixupASTSourcePositionsBasedOnDetectedLineDirectives(): filenameIdList.size() = %&quot; PRIuPTR &quot; \n&quot;,filenameIdList.size());</span></a>
<a name="3602"><span class="lineNum">    3602 </span><span class="lineNoCov">          0 :    }</span></a>
<a name="3603"><span class="lineNum">    3603 </span>            : </a>
<a name="3604"><span class="lineNum">    3604 </span>            : </a>
<a name="3605"><span class="lineNum">    3605 </span>            : void</a>
<a name="3606"><span class="lineNum">    3606 </span><span class="lineNoCov">          0 : SgSourceFile_processCppLinemarkers::FixupASTSourcePositionsBasedOnDetectedLineDirectives::visit ( SgNode* astNode )</span></a>
<a name="3607"><span class="lineNum">    3607 </span>            :    {</a>
<a name="3608"><span class="lineNum">    3608 </span>            :   // DQ (12/14/2012): This functionality is being added to support applications like sudo which have generated code from tools like lex.</a>
<a name="3609"><span class="lineNum">    3609 </span>            :   // This traversal is defined to detect the use of &quot;#line&quot; directived and then accumulate the list of filenames used in the #line directives.</a>
<a name="3610"><span class="lineNum">    3610 </span>            :   // When #line directives are used in the input source file then we consider all statements associated with those filenames to be from the</a>
<a name="3611"><span class="lineNum">    3611 </span>            :   // input source file and direct them to be unparsed.  The actual way we trigger them to be unparsed is to make the source position to</a>
<a name="3612"><span class="lineNum">    3612 </span>            :   // be unparsed in the Sg_File_Info object, this is enough to force the unparsed to output those statements.</a>
<a name="3613"><span class="lineNum">    3613 </span>            :   // TODO: It might be that this should operate on SgLocatedNode IR nodes instead of SgStatement IR nodes.</a>
<a name="3614"><span class="lineNum">    3614 </span>            : </a>
<a name="3615"><span class="lineNum">    3615 </span><span class="lineNoCov">          0 :      SgStatement* statement = isSgStatement(astNode);</span></a>
<a name="3616"><span class="lineNum">    3616 </span>            : </a>
<a name="3617"><span class="lineNum">    3617 </span>            : #if 0</a>
<a name="3618"><span class="lineNum">    3618 </span>            :      printf (&quot;FixupASTSourcePositionsBasedOnDetectedLineDirectives::visit(): statement = %p = %s \n&quot;,statement,(statement != nullptr) ? statement-&gt;class_name().c_str() : &quot;NULL&quot;);</a>
<a name="3619"><span class="lineNum">    3619 </span>            : #endif</a>
<a name="3620"><span class="lineNum">    3620 </span>            : </a>
<a name="3621"><span class="lineNum">    3621 </span><span class="lineNoCov">          0 :      if (statement != nullptr)</span></a>
<a name="3622"><span class="lineNum">    3622 </span>            :         {</a>
<a name="3623"><span class="lineNum">    3623 </span><span class="lineNoCov">          0 :           if ( SgProject::get_verbose() &gt; 1)</span></a>
<a name="3624"><span class="lineNum">    3624 </span><span class="lineNoCov">          0 :                printf (&quot;FixupASTSourcePositionsBasedOnDetectedLineDirectives::visit(): statement = %p = %s \n&quot;,statement,statement-&gt;class_name().c_str());</span></a>
<a name="3625"><span class="lineNum">    3625 </span>            : </a>
<a name="3626"><span class="lineNum">    3626 </span><span class="lineNoCov">          0 :           ASSERT_not_null(statement-&gt;get_file_info());</span></a>
<a name="3627"><span class="lineNum">    3627 </span><span class="lineNoCov">          0 :           int fileId = statement-&gt;get_file_info()-&gt;get_file_id();</span></a>
<a name="3628"><span class="lineNum">    3628 </span>            : </a>
<a name="3629"><span class="lineNum">    3629 </span>            :        // Check if this fileId is associated with set of fileId that we would like to output.</a>
<a name="3630"><span class="lineNum">    3630 </span><span class="lineNoCov">          0 :           if (filenameIdList.find(fileId) != filenameIdList.end())</span></a>
<a name="3631"><span class="lineNum">    3631 </span>            :              {</a>
<a name="3632"><span class="lineNum">    3632 </span>            : #if 0</a>
<a name="3633"><span class="lineNum">    3633 </span>            :                printf (&quot;FixupASTSourcePositionsBasedOnDetectedLineDirectives::visit(): statement = %p = %s \n&quot;,statement,(statement != NULL) ? statement-&gt;class_name().c_str() : &quot;NULL&quot;);</a>
<a name="3634"><span class="lineNum">    3634 </span>            :                printf (&quot;Fixup the fileInfo for this statement to force it to be output fileId = %d \n&quot;,fileId);</a>
<a name="3635"><span class="lineNum">    3635 </span>            :                Sg_File_Info::display_static_data(&quot;FixupASTSourcePositionsBasedOnDetectedLineDirectives::visit()&quot;);</a>
<a name="3636"><span class="lineNum">    3636 </span>            : #endif</a>
<a name="3637"><span class="lineNum">    3637 </span>            : #if 0</a>
<a name="3638"><span class="lineNum">    3638 </span>            :                statement-&gt;get_startOfConstruct()-&gt;set_file_id(0);</a>
<a name="3639"><span class="lineNum">    3639 </span>            :                statement-&gt;get_endOfConstruct()-&gt;set_file_id(0);</a>
<a name="3640"><span class="lineNum">    3640 </span>            : #else</a>
<a name="3641"><span class="lineNum">    3641 </span>            :             // statement-&gt;get_fileInfo()-&gt;setOutputInCodeGeneration();</a>
<a name="3642"><span class="lineNum">    3642 </span><span class="lineNoCov">          0 :                statement-&gt;get_startOfConstruct()-&gt;setOutputInCodeGeneration();</span></a>
<a name="3643"><span class="lineNum">    3643 </span><span class="lineNoCov">          0 :                statement-&gt;get_endOfConstruct()  -&gt;setOutputInCodeGeneration();</span></a>
<a name="3644"><span class="lineNum">    3644 </span>            : #endif</a>
<a name="3645"><span class="lineNum">    3645 </span>            :              }</a>
<a name="3646"><span class="lineNum">    3646 </span>            :         }</a>
<a name="3647"><span class="lineNum">    3647 </span><span class="lineNoCov">          0 :    }</span></a>
<a name="3648"><span class="lineNum">    3648 </span>            : #endif</a>
<a name="3649"><span class="lineNum">    3649 </span>            : </a>
<a name="3650"><span class="lineNum">    3650 </span>            : #if 1</a>
<a name="3651"><span class="lineNum">    3651 </span>            : void</a>
<a name="3652"><span class="lineNum">    3652 </span><span class="lineNoCov">          0 : SgSourceFile::fixupASTSourcePositionsBasedOnDetectedLineDirectives(set&lt;int&gt; equivalentFilenames)</span></a>
<a name="3653"><span class="lineNum">    3653 </span>            :    {</a>
<a name="3654"><span class="lineNum">    3654 </span>            : #if 0</a>
<a name="3655"><span class="lineNum">    3655 </span>            :   // DQ (12/23/2012): This function is called from: AttachPreprocessingInfoTreeTrav::evaluateInheritedAttribute().</a>
<a name="3656"><span class="lineNum">    3656 </span>            :   // It is used to map filenames generated from #line directives into thoses associated with the</a>
<a name="3657"><span class="lineNum">    3657 </span>            :   // physical filename.  However, now that we internally keep references to both the logical</a>
<a name="3658"><span class="lineNum">    3658 </span>            :   // source position AND the physical source position, this should not be required.</a>
<a name="3659"><span class="lineNum">    3659 </span>            : </a>
<a name="3660"><span class="lineNum">    3660 </span>            :      printf (&quot;ERROR: Now that we strore both logical and physical source position information, this function shuld not be used \n&quot;);</a>
<a name="3661"><span class="lineNum">    3661 </span>            :      ROSE_ABORT();</a>
<a name="3662"><span class="lineNum">    3662 </span>            : #endif</a>
<a name="3663"><span class="lineNum">    3663 </span>            : </a>
<a name="3664"><span class="lineNum">    3664 </span>            : #if 0</a>
<a name="3665"><span class="lineNum">    3665 </span>            :   // DQ (12/18/2012): This function is not called, since processing the #line directives after they have been added to the AST is TOO LATE!</a>
<a name="3666"><span class="lineNum">    3666 </span>            :   // We instead have to process the list of collected directives from the lexer more directly before they are added to the AST so that we</a>
<a name="3667"><span class="lineNum">    3667 </span>            :   // can build the list of equivalent filenames (to the input file) and thus get the all of the directives into the correct places using</a>
<a name="3668"><span class="lineNum">    3668 </span>            :   // the mapping of the input filename to the list of equivalent filenames (from the #line directives).  Then we get both the comments/CPP</a>
<a name="3669"><span class="lineNum">    3669 </span>            :   // directives into the correct locaions AND we can then process the statement's source positions to force the output in the unparser.</a>
<a name="3670"><span class="lineNum">    3670 </span>            : </a>
<a name="3671"><span class="lineNum">    3671 </span>            :      SgSourceFile* sourceFile = const_cast&lt;SgSourceFile*&gt;(this);</a>
<a name="3672"><span class="lineNum">    3672 </span>            : </a>
<a name="3673"><span class="lineNum">    3673 </span>            :      SgSourceFile_processCppLinemarkers::GatherASTSourcePositionsBasedOnDetectedLineDirectives linemarkerTraversal_1(sourceFile-&gt;get_sourceFileNameWithPath());</a>
<a name="3674"><span class="lineNum">    3674 </span>            : </a>
<a name="3675"><span class="lineNum">    3675 </span>            :      linemarkerTraversal_1.traverse(sourceFile,preorder);</a>
<a name="3676"><span class="lineNum">    3676 </span>            : #endif</a>
<a name="3677"><span class="lineNum">    3677 </span>            : #if 0</a>
<a name="3678"><span class="lineNum">    3678 </span>            :      printf (&quot;In SgSourceFile::fixupASTSourcePositionsBasedOnDetectedLineDirectives(): output set of associated filenames: \n&quot;);</a>
<a name="3679"><span class="lineNum">    3679 </span>            :      set&lt;int&gt;::iterator i = linemarkerTraversal_1.filenameIdList.begin();</a>
<a name="3680"><span class="lineNum">    3680 </span>            :      int counter = 0;</a>
<a name="3681"><span class="lineNum">    3681 </span>            :      while (i != linemarkerTraversal_1.filenameIdList.end())</a>
<a name="3682"><span class="lineNum">    3682 </span>            :         {</a>
<a name="3683"><span class="lineNum">    3683 </span>            :           printf (&quot;   --- filenameIdList entry #%d = %d \n&quot;,counter,*i);</a>
<a name="3684"><span class="lineNum">    3684 </span>            :           counter++;</a>
<a name="3685"><span class="lineNum">    3685 </span>            : </a>
<a name="3686"><span class="lineNum">    3686 </span>            :           i++;</a>
<a name="3687"><span class="lineNum">    3687 </span>            :         }</a>
<a name="3688"><span class="lineNum">    3688 </span>            : #endif</a>
<a name="3689"><span class="lineNum">    3689 </span>            : #if 0</a>
<a name="3690"><span class="lineNum">    3690 </span>            :      printf (&quot;Exiting as a test ... (processing gatherASTSourcePositionsBasedOnDetectedLineDirectives) \n&quot;);</a>
<a name="3691"><span class="lineNum">    3691 </span>            :      ROSE_ABORT();</a>
<a name="3692"><span class="lineNum">    3692 </span>            : #endif</a>
<a name="3693"><span class="lineNum">    3693 </span>            : </a>
<a name="3694"><span class="lineNum">    3694 </span>            :   // SgSourceFile_processCppLinemarkers::FixupASTSourcePositionsBasedOnDetectedLineDirectives linemarkerTraversal(sourceFile-&gt;get_sourceFileNameWithPath(),linemarkerTraversal_1.filenameIdList);</a>
<a name="3695"><span class="lineNum">    3695 </span><span class="lineNoCov">          0 :      SgSourceFile_processCppLinemarkers::FixupASTSourcePositionsBasedOnDetectedLineDirectives linemarkerTraversal(this-&gt;get_sourceFileNameWithPath(),equivalentFilenames);</span></a>
<a name="3696"><span class="lineNum">    3696 </span>            : </a>
<a name="3697"><span class="lineNum">    3697 </span><span class="lineNoCov">          0 :      linemarkerTraversal.traverse(this,preorder);</span></a>
<a name="3698"><span class="lineNum">    3698 </span>            : </a>
<a name="3699"><span class="lineNum">    3699 </span>            : #if 0</a>
<a name="3700"><span class="lineNum">    3700 </span>            :      printf (&quot;Exiting as a test ... (processing fixupASTSourcePositionsBasedOnDetectedLineDirectives) \n&quot;);</a>
<a name="3701"><span class="lineNum">    3701 </span>            :      ROSE_ABORT();</a>
<a name="3702"><span class="lineNum">    3702 </span>            : #endif</a>
<a name="3703"><span class="lineNum">    3703 </span><span class="lineNoCov">          0 :    }</span></a>
<a name="3704"><span class="lineNum">    3704 </span>            : #endif</a>
<a name="3705"><span class="lineNum">    3705 </span>            : </a>
<a name="3706"><span class="lineNum">    3706 </span>            : int</a>
<a name="3707"><span class="lineNum">    3707 </span><span class="lineCov">         37 : SgSourceFile::build_Fortran_AST( vector&lt;string&gt; argv, vector&lt;string&gt; inputCommandLine )</span></a>
<a name="3708"><span class="lineNum">    3708 </span>            :    {</a>
<a name="3709"><span class="lineNum">    3709 </span>            :   // Rasmussen (1/24/2022): Transitioning to using Flang as the Fortran parser.</a>
<a name="3710"><span class="lineNum">    3710 </span>            :   // The variable ROSE_EXPERIMENTAL_FLANG_ROSE_CONNECTION will be defined at configuration</a>
<a name="3711"><span class="lineNum">    3711 </span>            :   // but not ROSE_BUILD_FORTRAN_LANGUAGE_SUPPORT.  Unfortunately the latter variable is</a>
<a name="3712"><span class="lineNum">    3712 </span>            :   // too tightly coupled with Java usage at the moment. The Flang parser doesn't require Java.</a>
<a name="3713"><span class="lineNum">    3713 </span><span class="lineCov">         37 :      if (get_experimental_flang_frontend() == true) {</span></a>
<a name="3714"><span class="lineNum">    3714 </span><span class="lineNoCov">          0 :        int status{-1};</span></a>
<a name="3715"><span class="lineNum">    3715 </span><span class="lineNoCov">          0 :        int flangArgc{0};</span></a>
<a name="3716"><span class="lineNum">    3716 </span><span class="lineNoCov">          0 :        char** flangArgv{nullptr};</span></a>
<a name="3717"><span class="lineNum">    3717 </span>            : </a>
<a name="3718"><span class="lineNum">    3718 </span><span class="lineNoCov">          0 :        vector&lt;string&gt; flangCommandLine;</span></a>
<a name="3719"><span class="lineNum">    3719 </span><span class="lineNoCov">          0 :        flangCommandLine.push_back(&quot;f18&quot;);</span></a>
<a name="3720"><span class="lineNum">    3720 </span><span class="lineNoCov">          0 :        flangCommandLine.push_back(&quot;-fexternal-builder&quot;);</span></a>
<a name="3721"><span class="lineNum">    3721 </span><span class="lineNoCov">          0 :        flangCommandLine.push_back(get_sourceFileNameWithPath());</span></a>
<a name="3722"><span class="lineNum">    3722 </span><span class="lineNoCov">          0 :        CommandlineProcessing::generateArgcArgvFromList(flangCommandLine, flangArgc, flangArgv);</span></a>
<a name="3723"><span class="lineNum">    3723 </span>            : </a>
<a name="3724"><span class="lineNum">    3724 </span>            :     // SG (7/9/2015) In case of a mixed language project, force case sensitivity here.</a>
<a name="3725"><span class="lineNum">    3725 </span><span class="lineNoCov">          0 :        SageBuilder::symbol_table_case_insensitive_semantics = true;</span></a>
<a name="3726"><span class="lineNum">    3726 </span>            : </a>
<a name="3727"><span class="lineNum">    3727 </span>            : #if defined(ROSE_EXPERIMENTAL_FLANG_ROSE_CONNECTION)</a>
<a name="3728"><span class="lineNum">    3728 </span>            :        status = experimental_fortran_main(flangArgc, flangArgv, const_cast&lt;SgSourceFile*&gt;(this));</a>
<a name="3729"><span class="lineNum">    3729 </span>            :        ROSE_ASSERT(status == 0);</a>
<a name="3730"><span class="lineNum">    3730 </span>            : #else</a>
<a name="3731"><span class="lineNum">    3731 </span><span class="lineNoCov">          0 :        ROSE_ASSERT(! &quot;[FATAL] [ROSE] [frontend] [Fortran] &quot;</span></a>
<a name="3732"><span class="lineNum">    3732 </span>            :                      &quot;error: ROSE was not configured to support the Fortran Flang frontend.&quot;);</a>
<a name="3733"><span class="lineNum">    3733 </span>            : #endif</a>
<a name="3734"><span class="lineNum">    3734 </span>            :        return status;</a>
<a name="3735"><span class="lineNum">    3735 </span>            :      }</a>
<a name="3736"><span class="lineNum">    3736 </span>            : </a>
<a name="3737"><span class="lineNum">    3737 </span>            : #if defined(ROSE_BUILD_FORTRAN_LANGUAGE_SUPPORT)</a>
<a name="3738"><span class="lineNum">    3738 </span>            :   // This is how we pass the pointer to the SgFile created in ROSE before the Open</a>
<a name="3739"><span class="lineNum">    3739 </span>            :   // Fortran Parser is called to the Open Fortran Parser.  In the case of C/C++ using</a>
<a name="3740"><span class="lineNum">    3740 </span>            :   // EDG the SgFile is passed through the edg_main() function, but not so with the</a>
<a name="3741"><span class="lineNum">    3741 </span>            :   // Open Fortran Parser's openFortranParser_main() function API.  So we use this</a>
<a name="3742"><span class="lineNum">    3742 </span>            :   // global variable to pass the SgFile (so that the parser c_action functions can</a>
<a name="3743"><span class="lineNum">    3743 </span>            :   // build the Fotran AST using the existing SgFile.</a>
<a name="3744"><span class="lineNum">    3744 </span>            : </a>
<a name="3745"><span class="lineNum">    3745 </span>            :      // FMZ(7/27/2010): check command line options for Rice CAF syntax</a>
<a name="3746"><span class="lineNum">    3746 </span>            :      //  -rose:CoArrayFortran, -rose:CAF, -rose:caf</a>
<a name="3747"><span class="lineNum">    3747 </span>            : </a>
<a name="3748"><span class="lineNum">    3748 </span>            :      // SG (7/9/2015) In case of a mixed language project, force case</a>
<a name="3749"><span class="lineNum">    3749 </span>            :      // insensitivity here.</a>
<a name="3750"><span class="lineNum">    3750 </span><span class="lineCov">         37 :      SageBuilder::symbol_table_case_insensitive_semantics = true;</span></a>
<a name="3751"><span class="lineNum">    3751 </span>            : </a>
<a name="3752"><span class="lineNum">    3752 </span><span class="lineCov">         37 :      bool using_rice_caf = false;</span></a>
<a name="3753"><span class="lineNum">    3753 </span><span class="lineCov">         37 :      vector&lt;string&gt; ArgTmp = get_project()-&gt;get_originalCommandLineArgumentList();</span></a>
<a name="3754"><span class="lineNum">    3754 </span><span class="lineCov">         37 :      int sizeArgs = ArgTmp.size();</span></a>
<a name="3755"><span class="lineNum">    3755 </span>            : </a>
<a name="3756"><span class="lineNum">    3756 </span><span class="lineCov">        234 :      for (int i = 0; i&lt; sizeArgs; i++)  {</span></a>
<a name="3757"><span class="lineNum">    3757 </span><span class="lineCov">        197 :        if (ArgTmp[i].find(&quot;-rose:caf&quot;,0)==0     ||</span></a>
<a name="3758"><span class="lineNum">    3758 </span><span class="lineCov">        197 :            ArgTmp[i].find(&quot;-rose:CAF2.0&quot;,0)==0  ||</span></a>
<a name="3759"><span class="lineNum">    3759 </span><span class="lineCov">        197 :            ArgTmp[i].find(&quot;-rose:CAF2.0&quot;,0)==0  ) {</span></a>
<a name="3760"><span class="lineNum">    3760 </span>            : </a>
<a name="3761"><span class="lineNum">    3761 </span>            :          using_rice_caf=true;</a>
<a name="3762"><span class="lineNum">    3762 </span>            :          break;</a>
<a name="3763"><span class="lineNum">    3763 </span>            :        }</a>
<a name="3764"><span class="lineNum">    3764 </span>            :      }</a>
<a name="3765"><span class="lineNum">    3765 </span>            : </a>
<a name="3766"><span class="lineNum">    3766 </span><span class="lineCov">         37 :      extern SgSourceFile* OpenFortranParser_globalFilePointer;</span></a>
<a name="3767"><span class="lineNum">    3767 </span>            : </a>
<a name="3768"><span class="lineNum">    3768 </span>            :   // DQ (10/26/2010): Moved from SgSourceFile::callFrontEnd() so that the stack will</a>
<a name="3769"><span class="lineNum">    3769 </span>            :   // be empty when processing Java language support (not Fortran).</a>
<a name="3770"><span class="lineNum">    3770 </span><span class="lineCov">         37 :      FortranParserState* currStks = new FortranParserState();</span></a>
<a name="3771"><span class="lineNum">    3771 </span>            : </a>
<a name="3772"><span class="lineNum">    3772 </span>            :   // printf (&quot;######################### Inside of SgSourceFile::build_Fortran_AST() ############################ \n&quot;);</a>
<a name="3773"><span class="lineNum">    3773 </span>            : </a>
<a name="3774"><span class="lineNum">    3774 </span><span class="lineCov">         37 :      bool requires_C_preprocessor = get_requires_C_preprocessor();</span></a>
<a name="3775"><span class="lineNum">    3775 </span><span class="lineCov">         37 :      if (requires_C_preprocessor == true)</span></a>
<a name="3776"><span class="lineNum">    3776 </span>            :         {</a>
<a name="3777"><span class="lineNum">    3777 </span><span class="lineNoCov">          0 :           int errorCode;</span></a>
<a name="3778"><span class="lineNum">    3778 </span>            : </a>
<a name="3779"><span class="lineNum">    3779 </span>            :        // If we detect that the input file requires processing via CPP (e.g. filename of form *.F??) then</a>
<a name="3780"><span class="lineNum">    3780 </span>            :        // we generate the command to run CPP on the input file and collect the results in a file with</a>
<a name="3781"><span class="lineNum">    3781 </span>            :        // the suffix &quot;_postprocessed.f??&quot;.  Note: instead of using CPP we use the target backend fortran</a>
<a name="3782"><span class="lineNum">    3782 </span>            :        // compiler with the &quot;-E&quot; option.</a>
<a name="3783"><span class="lineNum">    3783 </span>            : </a>
<a name="3784"><span class="lineNum">    3784 </span><span class="lineNoCov">          0 :           vector&lt;string&gt; fortran_C_preprocessor_commandLine;</span></a>
<a name="3785"><span class="lineNum">    3785 </span>            : </a>
<a name="3786"><span class="lineNum">    3786 </span>            :        // Note: The `-traditional' and `-undef' flags are supplied to cpp by default [when used with cpp is used by gfortran],</a>
<a name="3787"><span class="lineNum">    3787 </span>            :        // to help avoid unpleasant surprises.  So to simplify use of cpp and make it more consistant with gfortran we use</a>
<a name="3788"><span class="lineNum">    3788 </span>            :        // gfortran to call cpp.</a>
<a name="3789"><span class="lineNum">    3789 </span>            : #if BACKEND_FORTRAN_IS_GNU_COMPILER</a>
<a name="3790"><span class="lineNum">    3790 </span><span class="lineNoCov">          0 :           fortran_C_preprocessor_commandLine.push_back(BACKEND_FORTRAN_COMPILER_NAME_WITH_PATH);</span></a>
<a name="3791"><span class="lineNum">    3791 </span>            : #elif BACKEND_FORTRAN_IS_PGI_COMPILER</a>
<a name="3792"><span class="lineNum">    3792 </span>            :           fortran_C_preprocessor_commandLine.push_back(BACKEND_FORTRAN_COMPILER_NAME_WITH_PATH);</a>
<a name="3793"><span class="lineNum">    3793 </span>            : #elif BACKEND_FORTRAN_IS_INTEL_COMPILER</a>
<a name="3794"><span class="lineNum">    3794 </span>            : #if ROSE_USE_INTEL_FPP</a>
<a name="3795"><span class="lineNum">    3795 </span>            :           fortran_C_preprocessor_commandLine.push_back(INTEL_FPP_PATH);</a>
<a name="3796"><span class="lineNum">    3796 </span>            :           fortran_C_preprocessor_commandLine.push_back(&quot;-P&quot;);</a>
<a name="3797"><span class="lineNum">    3797 </span>            : #else</a>
<a name="3798"><span class="lineNum">    3798 </span>            :           cerr &lt;&lt; &quot;Intel Fortran preprocessor not available! &quot; &lt;&lt; endl;</a>
<a name="3799"><span class="lineNum">    3799 </span>            :           ROSE_ABORT();</a>
<a name="3800"><span class="lineNum">    3800 </span>            : #endif</a>
<a name="3801"><span class="lineNum">    3801 </span>            : #endif</a>
<a name="3802"><span class="lineNum">    3802 </span>            : </a>
<a name="3803"><span class="lineNum">    3803 </span>            :        // DQ (10/23/2010): Added support for &quot;-D&quot; options (this will trigger CPP preprocessing, eventually, but this is just to support the syntax checking).</a>
<a name="3804"><span class="lineNum">    3804 </span>            :        // Note that we have to do this before calling the C preprocessor and not with the syntax checking.</a>
<a name="3805"><span class="lineNum">    3805 </span><span class="lineNoCov">          0 :           const SgStringList &amp; macroSpecifierList = get_project()-&gt;get_macroSpecifierList();</span></a>
<a name="3806"><span class="lineNum">    3806 </span><span class="lineNoCov">          0 :           for (size_t i = 0; i &lt; macroSpecifierList.size(); i++)</span></a>
<a name="3807"><span class="lineNum">    3807 </span>            :              {</a>
<a name="3808"><span class="lineNum">    3808 </span>            :             // Note that gfortran will only do macro substitution of &quot;-D&quot; command line arguments on files with *.F or *.F?? suffix.</a>
<a name="3809"><span class="lineNum">    3809 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(get_requires_C_preprocessor() == true);</span></a>
<a name="3810"><span class="lineNum">    3810 </span><span class="lineNoCov">          0 :                fortran_C_preprocessor_commandLine.push_back(&quot;-D&quot;+macroSpecifierList[i]);</span></a>
<a name="3811"><span class="lineNum">    3811 </span>            :              }</a>
<a name="3812"><span class="lineNum">    3812 </span>            :       // Pei-Hung (09/22/2020): Added openacc support for the preprocessing command line.</a>
<a name="3813"><span class="lineNum">    3813 </span>            :       // This is a tentative work and needs to be enhanced later.</a>
<a name="3814"><span class="lineNum">    3814 </span>            : #if 0</a>
<a name="3815"><span class="lineNum">    3815 </span>            :           if(get_openacc())</a>
<a name="3816"><span class="lineNum">    3816 </span>            :            {</a>
<a name="3817"><span class="lineNum">    3817 </span>            :              fortran_C_preprocessor_commandLine.push_back(&quot;-D_OPENACC=&quot;+ StringUtility::numberToString(3));</a>
<a name="3818"><span class="lineNum">    3818 </span>            :            }</a>
<a name="3819"><span class="lineNum">    3819 </span>            : #endif</a>
<a name="3820"><span class="lineNum">    3820 </span>            :        // DQ (5/19/2008): Added support for include paths as required for relatively new Fortran specific include mechanism in OFP.</a>
<a name="3821"><span class="lineNum">    3821 </span><span class="lineNoCov">          0 :           const SgStringList &amp; includeList = get_project()-&gt;get_includeDirectorySpecifierList();</span></a>
<a name="3822"><span class="lineNum">    3822 </span><span class="lineNoCov">          0 :           for (size_t i = 0; i &lt; includeList.size(); i++)</span></a>
<a name="3823"><span class="lineNum">    3823 </span>            :              {</a>
<a name="3824"><span class="lineNum">    3824 </span><span class="lineNoCov">          0 :                fortran_C_preprocessor_commandLine.push_back(includeList[i]);</span></a>
<a name="3825"><span class="lineNum">    3825 </span>            :              }</a>
<a name="3826"><span class="lineNum">    3826 </span>            : </a>
<a name="3827"><span class="lineNum">    3827 </span>            :        // add option to specify preprocessing only</a>
<a name="3828"><span class="lineNum">    3828 </span>            : #if BACKEND_FORTRAN_IS_GNU_COMPILER</a>
<a name="3829"><span class="lineNum">    3829 </span><span class="lineNoCov">          0 :           fortran_C_preprocessor_commandLine.push_back(&quot;-E&quot;);</span></a>
<a name="3830"><span class="lineNum">    3830 </span>            :       // Pei-Hung (06/18/2020) gfortran option to inhibit generation of linemarkers in the output from the preprocessor.</a>
<a name="3831"><span class="lineNum">    3831 </span><span class="lineNoCov">          0 :           fortran_C_preprocessor_commandLine.push_back(&quot;-P&quot;);</span></a>
<a name="3832"><span class="lineNum">    3832 </span>            : #elif BACKEND_FORTRAN_IS_PGI_COMPILER</a>
<a name="3833"><span class="lineNum">    3833 </span>            :      // Pei-Hung 12/09/2019 This is for PGI Fortran compiler, add others if necessary</a>
<a name="3834"><span class="lineNum">    3834 </span>            :           fortran_C_preprocessor_commandLine.push_back(&quot;-Mcpp&quot;);</a>
<a name="3835"><span class="lineNum">    3835 </span>            : </a>
<a name="3836"><span class="lineNum">    3836 </span>            : #endif</a>
<a name="3837"><span class="lineNum">    3837 </span>            : </a>
<a name="3838"><span class="lineNum">    3838 </span>            :        // add source file name</a>
<a name="3839"><span class="lineNum">    3839 </span><span class="lineNoCov">          0 :           string sourceFilename = get_sourceFileNameWithPath();</span></a>
<a name="3840"><span class="lineNum">    3840 </span>            : </a>
<a name="3841"><span class="lineNum">    3841 </span>            :           // use a pseudonym for source file in case original extension does not permit preprocessing</a>
<a name="3842"><span class="lineNum">    3842 </span>            :           // compute absolute path for pseudonym</a>
<a name="3843"><span class="lineNum">    3843 </span><span class="lineNoCov">          0 :           FileSystem::Path abs_path = FileSystem::makeAbsolute(this-&gt;get_unparse_output_filename());</span></a>
<a name="3844"><span class="lineNum">    3844 </span><span class="lineNoCov">          0 :           FileSystem::Path abs_dir = abs_path.parent_path();</span></a>
<a name="3845"><span class="lineNum">    3845 </span><span class="lineNoCov">          0 :           FileSystem::Path base = abs_dir.filename().stem();</span></a>
<a name="3846"><span class="lineNum">    3846 </span><span class="lineNoCov">          0 :           string preprocessFilename = (abs_dir / boost::filesystem::unique_path(base.string() + &quot;-%%%%%%%%.F90&quot;)).string();</span></a>
<a name="3847"><span class="lineNum">    3847 </span>            : </a>
<a name="3848"><span class="lineNum">    3848 </span>            :           // The Sawyer::FileSystem::TemporaryFile d'tor will delete the file. We close the file after it's created because</a>
<a name="3849"><span class="lineNum">    3849 </span>            :           // Rose::FileSystem::copyFile will reopen it in binary mode anyway.</a>
<a name="3850"><span class="lineNum">    3850 </span><span class="lineNoCov">          0 :           Sawyer::FileSystem::TemporaryFile tempFile(preprocessFilename);</span></a>
<a name="3851"><span class="lineNum">    3851 </span><span class="lineNoCov">          0 :           tempFile.stream().close();</span></a>
<a name="3852"><span class="lineNum">    3852 </span>            : </a>
<a name="3853"><span class="lineNum">    3853 </span>            :           // copy source file to pseudonym file</a>
<a name="3854"><span class="lineNum">    3854 </span><span class="lineNoCov">          0 :           try {</span></a>
<a name="3855"><span class="lineNum">    3855 </span><span class="lineNoCov">          0 :               Rose::FileSystem::copyFile(sourceFilename, preprocessFilename);</span></a>
<a name="3856"><span class="lineNum">    3856 </span><span class="lineNoCov">          0 :           } catch(exception &amp;e) {</span></a>
<a name="3857"><span class="lineNum">    3857 </span><span class="lineNoCov">          0 :               cerr &lt;&lt; &quot;Error in copying file &quot; &lt;&lt; sourceFilename &lt;&lt; &quot; to &quot; &lt;&lt; preprocessFilename</span></a>
<a name="3858"><span class="lineNum">    3858 </span><span class="lineNoCov">          0 :                    &lt;&lt; &quot; (&quot; &lt;&lt; e.what() &lt;&lt; &quot;)&quot; &lt;&lt; endl;</span></a>
<a name="3859"><span class="lineNum">    3859 </span><span class="lineNoCov">          0 :               ROSE_ABORT();</span></a>
<a name="3860"><span class="lineNum">    3860 </span>            :           }</a>
<a name="3861"><span class="lineNum">    3861 </span><span class="lineNoCov">          0 :           fortran_C_preprocessor_commandLine.push_back(preprocessFilename);</span></a>
<a name="3862"><span class="lineNum">    3862 </span>            : </a>
<a name="3863"><span class="lineNum">    3863 </span>            :           // add option to specify output file name</a>
<a name="3864"><span class="lineNum">    3864 </span><span class="lineNoCov">          0 :           fortran_C_preprocessor_commandLine.push_back(&quot;-o&quot;);</span></a>
<a name="3865"><span class="lineNum">    3865 </span><span class="lineNoCov">          0 :           string sourceFileNameOutputFromCpp = generate_C_preprocessor_intermediate_filename(sourceFilename);</span></a>
<a name="3866"><span class="lineNum">    3866 </span><span class="lineNoCov">          0 :           fortran_C_preprocessor_commandLine.push_back(sourceFileNameOutputFromCpp);</span></a>
<a name="3867"><span class="lineNum">    3867 </span>            : </a>
<a name="3868"><span class="lineNum">    3868 </span><span class="lineNoCov">          0 :           if ( SgProject::get_verbose() &gt; 0 )</span></a>
<a name="3869"><span class="lineNum">    3869 </span><span class="lineNoCov">          0 :                printf (&quot;cpp command line = %s \n&quot;,CommandlineProcessing::generateStringFromArgList(fortran_C_preprocessor_commandLine,false,false).c_str());</span></a>
<a name="3870"><span class="lineNum">    3870 </span>            : </a>
<a name="3871"><span class="lineNum">    3871 </span>            :        // Pei-Hung 12/09/2019 the preprocess command has to be executed by all Fortran compiler</a>
<a name="3872"><span class="lineNum">    3872 </span>            : //#if BACKEND_FORTRAN_IS_GNU_COMPILER</a>
<a name="3873"><span class="lineNum">    3873 </span>            :        // Some security checking here could be helpful!!!</a>
<a name="3874"><span class="lineNum">    3874 </span><span class="lineNoCov">          0 :           errorCode = systemFromVector (fortran_C_preprocessor_commandLine);</span></a>
<a name="3875"><span class="lineNum">    3875 </span>            : //#endif</a>
<a name="3876"><span class="lineNum">    3876 </span>            : </a>
<a name="3877"><span class="lineNum">    3877 </span>            :        // DQ (10/1/2008): Added error checking on return value from CPP.</a>
<a name="3878"><span class="lineNum">    3878 </span><span class="lineNoCov">          0 :           if (errorCode != 0)</span></a>
<a name="3879"><span class="lineNum">    3879 </span>            :           {</a>
<a name="3880"><span class="lineNum">    3880 </span><span class="lineNoCov">          0 :              printf (&quot;Error in running cpp on Fortran code: errorCode = %d \n&quot;,errorCode);</span></a>
<a name="3881"><span class="lineNum">    3881 </span><span class="lineNoCov">          0 :              ROSE_ABORT();</span></a>
<a name="3882"><span class="lineNum">    3882 </span>            :           }</a>
<a name="3883"><span class="lineNum">    3883 </span>            :      } // Terminates if (requires_C_preprocessor == true)</a>
<a name="3884"><span class="lineNum">    3884 </span>            : </a>
<a name="3885"><span class="lineNum">    3885 </span>            : </a>
<a name="3886"><span class="lineNum">    3886 </span>            : </a>
<a name="3887"><span class="lineNum">    3887 </span>            :   // DQ (9/30/2007): Introduce syntax checking on input code (initially we can just call the backend compiler</a>
<a name="3888"><span class="lineNum">    3888 </span>            :   // and let it report on the syntax errors).  Later we can make this a command line switch to disable (default</a>
<a name="3889"><span class="lineNum">    3889 </span>            :   // should be true).</a>
<a name="3890"><span class="lineNum">    3890 </span><span class="lineCov">         37 :      bool syntaxCheckInputCode = (get_skip_syntax_check() == false);</span></a>
<a name="3891"><span class="lineNum">    3891 </span>            : </a>
<a name="3892"><span class="lineNum">    3892 </span><span class="lineCov">         37 :      if (syntaxCheckInputCode == true)</span></a>
<a name="3893"><span class="lineNum">    3893 </span>            :         {</a>
<a name="3894"><span class="lineNum">    3894 </span>            :        // Note that syntax checking of Fortran 2003 code using gfortran versions greater than 4.1 can</a>
<a name="3895"><span class="lineNum">    3895 </span>            :        // be a problem because there are a lot of bugs in the Fortran 2003 support in later versions</a>
<a name="3896"><span class="lineNum">    3896 </span>            :        // of gfortran (not present in initial Fortran 2003 support for syntax checking only). This problem</a>
<a name="3897"><span class="lineNum">    3897 </span>            :        // has been verified in version 4.2 and 4.3 of gfortran.</a>
<a name="3898"><span class="lineNum">    3898 </span>            : </a>
<a name="3899"><span class="lineNum">    3899 </span>            :        // DQ (9/30/2007): Introduce tracking of performance of ROSE.</a>
<a name="3900"><span class="lineNum">    3900 </span><span class="lineCov">         74 :           TimingPerformance timer (&quot;Fortran syntax checking of input:&quot;);</span></a>
<a name="3901"><span class="lineNum">    3901 </span>            : </a>
<a name="3902"><span class="lineNum">    3902 </span>            :        // DQ (9/30/2007): For Fortran, we want to run gfortran up front so that we can verify that</a>
<a name="3903"><span class="lineNum">    3903 </span>            :        // the input file is syntax error free.  First lets see what data is avilable to use to check</a>
<a name="3904"><span class="lineNum">    3904 </span>            :        // that we have a fortran file.</a>
<a name="3905"><span class="lineNum">    3905 </span>            :        // display(&quot;Before calling OpenFortranParser, what are the values in the SgFile&quot;);</a>
<a name="3906"><span class="lineNum">    3906 </span>            : </a>
<a name="3907"><span class="lineNum">    3907 </span>            :        // DQ (9/30/2007): Call the backend Fortran compiler (typically gfortran) to check the syntax</a>
<a name="3908"><span class="lineNum">    3908 </span>            :        // of the input program.  When using GNU gfortran, use the &quot;-S&quot; option which means:</a>
<a name="3909"><span class="lineNum">    3909 </span>            :        // &quot;Compile only; do not assemble or link&quot;.</a>
<a name="3910"><span class="lineNum">    3910 </span>            : </a>
<a name="3911"><span class="lineNum">    3911 </span>            :        // DQ (11/17/2007): Note that syntax and semantics checking is turned on using -fno-backend not -S</a>
<a name="3912"><span class="lineNum">    3912 </span>            :        // as I previously thought.  Also I have turned on all possible warnings and specified the Fortran 2003</a>
<a name="3913"><span class="lineNum">    3913 </span>            :        // features.  I have also specified use of cray-pointers.</a>
<a name="3914"><span class="lineNum">    3914 </span>            :        // string syntaxCheckingCommandline = &quot;gfortran -S &quot; + get_sourceFileNameWithPath();</a>
<a name="3915"><span class="lineNum">    3915 </span>            :        // string warnings = &quot;-Wall -Wconversion -Waliasing -Wampersand -Wimplicit-interface -Wline-truncation -Wnonstd-intrinsics -Wsurprising -Wunderflow -Wunused-labels&quot;;</a>
<a name="3916"><span class="lineNum">    3916 </span>            :        // DQ (12/8/2007): Added commandline control over warnings output in using gfortran sytax checking prior to use of OFP.</a>
<a name="3917"><span class="lineNum">    3917 </span>            : </a>
<a name="3918"><span class="lineNum">    3918 </span><span class="lineCov">         37 :           vector&lt;string&gt; fortranCommandLine;</span></a>
<a name="3919"><span class="lineNum">    3919 </span><span class="lineCov">         37 :           fortranCommandLine.push_back(ROSE_GFORTRAN_PATH);</span></a>
<a name="3920"><span class="lineNum">    3920 </span><span class="lineCov">         74 :           fortranCommandLine.push_back(&quot;-fsyntax-only&quot;);</span></a>
<a name="3921"><span class="lineNum">    3921 </span>            : </a>
<a name="3922"><span class="lineNum">    3922 </span>            :        // DQ (5/19/2008): Added support for include paths as required for relatively new Fortran specific include mechanism in OFP.</a>
<a name="3923"><span class="lineNum">    3923 </span><span class="lineCov">         37 :           const SgStringList &amp; includeList = get_project()-&gt;get_includeDirectorySpecifierList();</span></a>
<a name="3924"><span class="lineNum">    3924 </span><span class="lineCov">         68 :           for (size_t i = 0; i &lt; includeList.size(); i++)</span></a>
<a name="3925"><span class="lineNum">    3925 </span>            :              {</a>
<a name="3926"><span class="lineNum">    3926 </span><span class="lineCov">         31 :                fortranCommandLine.push_back(includeList[i]);</span></a>
<a name="3927"><span class="lineNum">    3927 </span>            :              }</a>
<a name="3928"><span class="lineNum">    3928 </span>            : </a>
<a name="3929"><span class="lineNum">    3929 </span><span class="lineCov">         37 :           if (get_output_warnings() == true)</span></a>
<a name="3930"><span class="lineNum">    3930 </span>            :              {</a>
<a name="3931"><span class="lineNum">    3931 </span>            :             // These are gfortran specific options</a>
<a name="3932"><span class="lineNum">    3932 </span>            :             // As of 2004, -Wall implied: -Wunused-labels, -Waliasing, -Wsurprising and -Wline-truncation</a>
<a name="3933"><span class="lineNum">    3933 </span>            :             // Additional major options include:</a>
<a name="3934"><span class="lineNum">    3934 </span>            :             //      -fsyntax-only -pedantic -pedantic-errors -w -Wall -Waliasing -Wconversion -Wimplicit-interface</a>
<a name="3935"><span class="lineNum">    3935 </span>            :             //      -Wsurprising -Wunderflow -Wunused-labels -Wline-truncation -Werror -W</a>
<a name="3936"><span class="lineNum">    3936 </span>            :             // warnings = &quot;-Wall -Wconversion -Waliasing -Wampersand -Wimplicit-interface -Wline-truncation -Wnonstd-intrinsics -Wsurprising -Wunderflow&quot;;</a>
<a name="3937"><span class="lineNum">    3937 </span>            : </a>
<a name="3938"><span class="lineNum">    3938 </span>            :             // If warnings are requested (on the comandline to ROSE translator) then we want to output all possible warnings by defaul (at least for how)</a>
<a name="3939"><span class="lineNum">    3939 </span>            : </a>
<a name="3940"><span class="lineNum">    3940 </span>            :             // Check if we are using GNU compiler backend (if so then we are using gfortran, though we have no test in place currently for what</a>
<a name="3941"><span class="lineNum">    3941 </span>            :             // version of gfortran (as we do for C and C++))</a>
<a name="3942"><span class="lineNum">    3942 </span><span class="lineNoCov">          0 :                bool usingGfortran = false;</span></a>
<a name="3943"><span class="lineNum">    3943 </span>            :             // string backendCompilerSystem = BACKEND_CXX_COMPILER_NAME_WITHOUT_PATH;</a>
<a name="3944"><span class="lineNum">    3944 </span>            :                #ifdef USE_CMAKE</a>
<a name="3945"><span class="lineNum">    3945 </span>            :                  #ifdef CMAKE_COMPILER_IS_GNUG77</a>
<a name="3946"><span class="lineNum">    3946 </span>            :                    usingGfortran = true;</a>
<a name="3947"><span class="lineNum">    3947 </span>            :                  #endif</a>
<a name="3948"><span class="lineNum">    3948 </span>            :                #else</a>
<a name="3949"><span class="lineNum">    3949 </span>            :               // DQ (2/1/2016): Make the behavior of ROSE independent of the exact name of the backend compiler (problem when packages name compilers such as &quot;g++-4.8&quot;).</a>
<a name="3950"><span class="lineNum">    3950 </span>            :               // Note that this code assumes that if we are using the C/C++ GNU compiler then we are using the GNU Fortran comiler (we need a similar BACKEND_FORTRAN_IS_GNU_COMPILER macro).</a>
<a name="3951"><span class="lineNum">    3951 </span>            :               // usingGfortran = (backendCompilerSystem == &quot;g++&quot; || backendCompilerSystem == &quot;mpicc&quot; || backendCompilerSystem == &quot;mpicxx&quot;);</a>
<a name="3952"><span class="lineNum">    3952 </span>            :                  #if BACKEND_FORTRAN_IS_GNU_COMPILER</a>
<a name="3953"><span class="lineNum">    3953 </span><span class="lineNoCov">          0 :                     usingGfortran = true;</span></a>
<a name="3954"><span class="lineNum">    3954 </span>            :                  #endif</a>
<a name="3955"><span class="lineNum">    3955 </span>            :                #endif</a>
<a name="3956"><span class="lineNum">    3956 </span>            : </a>
<a name="3957"><span class="lineNum">    3957 </span><span class="lineNoCov">          0 :                if (usingGfortran)</span></a>
<a name="3958"><span class="lineNum">    3958 </span>            :                   {</a>
<a name="3959"><span class="lineNum">    3959 </span>            :                  // Since this is specific to gfortran version 4.1.2, we will exclude it (it is also redundant since it is included in -Wall)</a>
<a name="3960"><span class="lineNum">    3960 </span>            :                  // warnings += &quot; -Wunused-labels&quot;;</a>
<a name="3961"><span class="lineNum">    3961 </span>            :                  // warnings = &quot;-Wall -Wconversion -Wampersand -Wimplicit-interface -Wnonstd-intrinsics -Wunderflow&quot;;</a>
<a name="3962"><span class="lineNum">    3962 </span><span class="lineNoCov">          0 :                     fortranCommandLine.push_back(&quot;-Wall&quot;);</span></a>
<a name="3963"><span class="lineNum">    3963 </span>            : </a>
<a name="3964"><span class="lineNum">    3964 </span>            :                  // Add in the gfortran extra warnings</a>
<a name="3965"><span class="lineNum">    3965 </span><span class="lineNoCov">          0 :                     fortranCommandLine.push_back(&quot;-W&quot;);</span></a>
<a name="3966"><span class="lineNum">    3966 </span>            : </a>
<a name="3967"><span class="lineNum">    3967 </span>            :                  // More warnings not yet turned on.</a>
<a name="3968"><span class="lineNum">    3968 </span><span class="lineNoCov">          0 :                     fortranCommandLine.push_back(&quot;-Wconversion&quot;);</span></a>
<a name="3969"><span class="lineNum">    3969 </span><span class="lineNoCov">          0 :                     fortranCommandLine.push_back(&quot;-Wampersand&quot;);</span></a>
<a name="3970"><span class="lineNum">    3970 </span><span class="lineNoCov">          0 :                     fortranCommandLine.push_back(&quot;-Wimplicit-interface&quot;);</span></a>
<a name="3971"><span class="lineNum">    3971 </span><span class="lineNoCov">          0 :                     fortranCommandLine.push_back(&quot;-Wnonstd-intrinsics&quot;);</span></a>
<a name="3972"><span class="lineNum">    3972 </span><span class="lineNoCov">          0 :                     fortranCommandLine.push_back(&quot;-Wunderflow&quot;);</span></a>
<a name="3973"><span class="lineNum">    3973 </span>            :                   }</a>
<a name="3974"><span class="lineNum">    3974 </span>            :                  else</a>
<a name="3975"><span class="lineNum">    3975 </span>            :                   {</a>
<a name="3976"><span class="lineNum">    3976 </span>            :                     string backendCompilerSystem = BACKEND_CXX_COMPILER_NAME_WITHOUT_PATH;</a>
<a name="3977"><span class="lineNum">    3977 </span>            :                     printf (&quot;Currently only the GNU compiler backend is supported (gfortran) backendCompilerSystem = %s \n&quot;,backendCompilerSystem.c_str());</a>
<a name="3978"><span class="lineNum">    3978 </span>            :                     ROSE_ABORT();</a>
<a name="3979"><span class="lineNum">    3979 </span>            :                   }</a>
<a name="3980"><span class="lineNum">    3980 </span>            :              }</a>
<a name="3981"><span class="lineNum">    3981 </span>            : </a>
<a name="3982"><span class="lineNum">    3982 </span>            :        // Refactor the code below so that we can conditionally set the -ffree-line-length-none</a>
<a name="3983"><span class="lineNum">    3983 </span>            :        // or -ffixed-line-length-none options (not available in all versions of gfortran).</a>
<a name="3984"><span class="lineNum">    3984 </span><span class="lineCov">         74 :           string use_line_length_none_string;</span></a>
<a name="3985"><span class="lineNum">    3985 </span>            : </a>
<a name="3986"><span class="lineNum">    3986 </span><span class="lineCov">         37 :           bool relaxSyntaxCheckInputCode = (get_relax_syntax_check() == true);</span></a>
<a name="3987"><span class="lineNum">    3987 </span>            : </a>
<a name="3988"><span class="lineNum">    3988 </span>            :        // DQ (11/17/2007): Set the fortran mode used with gfortran.</a>
<a name="3989"><span class="lineNum">    3989 </span><span class="lineCov">         37 :           if (get_F90_only() == true || get_F95_only() == true)</span></a>
<a name="3990"><span class="lineNum">    3990 </span>            :              {</a>
<a name="3991"><span class="lineNum">    3991 </span>            :             // For now let's consider f90 to be syntax checked under f95 rules (since gfortran does not support a f90 specific mode)</a>
<a name="3992"><span class="lineNum">    3992 </span><span class="lineCov">          6 :                if (relaxSyntaxCheckInputCode == false)</span></a>
<a name="3993"><span class="lineNum">    3993 </span>            :                   {</a>
<a name="3994"><span class="lineNum">    3994 </span>            :                  // DQ (9/24/2010): Relaxed syntax checking would allow &quot;REAL*8&quot; syntax with F90 if we used &quot;-std=legacy&quot; instead of &quot;-std=f95&quot;.</a>
<a name="3995"><span class="lineNum">    3995 </span>            :                  // We will implement a strict syntax checking option with a default of false so that we can by default support codes using</a>
<a name="3996"><span class="lineNum">    3996 </span>            :                  // the &quot;REAL*8&quot; syntax with F90 (which appear to be common).</a>
<a name="3997"><span class="lineNum">    3997 </span>            :                  // fortranCommandLine.push_back(&quot;-std=f95&quot;);</a>
<a name="3998"><span class="lineNum">    3998 </span><span class="lineCov">         12 :                     fortranCommandLine.push_back(&quot;-std=legacy&quot;);</span></a>
<a name="3999"><span class="lineNum">    3999 </span>            :                   }</a>
<a name="4000"><span class="lineNum">    4000 </span>            : </a>
<a name="4001"><span class="lineNum">    4001 </span>            :             // DQ (5/20/2008)</a>
<a name="4002"><span class="lineNum">    4002 </span>            :             // fortranCommandLine.push_back(&quot;-ffree-line-length-none&quot;);</a>
<a name="4003"><span class="lineNum">    4003 </span>            : #if BACKEND_FORTRAN_IS_GNU_COMPILER</a>
<a name="4004"><span class="lineNum">    4004 </span><span class="lineCov">          6 :                use_line_length_none_string = &quot;-ffree-line-length-none&quot;;</span></a>
<a name="4005"><span class="lineNum">    4005 </span>            : #elif BACKEND_FORTRAN_IS_INTEL_COMPILER</a>
<a name="4006"><span class="lineNum">    4006 </span>            :                use_line_length_none_string = &quot;-free&quot;;</a>
<a name="4007"><span class="lineNum">    4007 </span>            : #endif</a>
<a name="4008"><span class="lineNum">    4008 </span>            :              }</a>
<a name="4009"><span class="lineNum">    4009 </span>            :             else</a>
<a name="4010"><span class="lineNum">    4010 </span>            :              {</a>
<a name="4011"><span class="lineNum">    4011 </span><span class="lineCov">         31 :                if (get_F2003_only() == true)</span></a>
<a name="4012"><span class="lineNum">    4012 </span>            :                   {</a>
<a name="4013"><span class="lineNum">    4013 </span>            :                  // fortranCommandLine.push_back(&quot;-std=f2003&quot;);</a>
<a name="4014"><span class="lineNum">    4014 </span><span class="lineNoCov">          0 :                     if (relaxSyntaxCheckInputCode == false)</span></a>
<a name="4015"><span class="lineNum">    4015 </span>            :                        {</a>
<a name="4016"><span class="lineNum">    4016 </span>            :                       // DQ (9/24/2010): We need to consider making a strict syntax checking option and allowing this to be relaxed</a>
<a name="4017"><span class="lineNum">    4017 </span>            :                       // by default.  It is however not clear that this is required for F2003 code where it does appear to be required</a>
<a name="4018"><span class="lineNum">    4018 </span>            :                       // for F90 code.  So this needs to be tested, see comments above relative to use of &quot;-std=legacy&quot;.</a>
<a name="4019"><span class="lineNum">    4019 </span><span class="lineNoCov">          0 :                          fortranCommandLine.push_back(&quot;-std=f2003&quot;);</span></a>
<a name="4020"><span class="lineNum">    4020 </span>            :                        }</a>
<a name="4021"><span class="lineNum">    4021 </span>            : </a>
<a name="4022"><span class="lineNum">    4022 </span>            :                  // DQ (5/20/2008)</a>
<a name="4023"><span class="lineNum">    4023 </span>            :                  // fortranCommandLine.push_back(&quot;-ffree-line-length-none&quot;);</a>
<a name="4024"><span class="lineNum">    4024 </span>            : #if BACKEND_FORTRAN_IS_GNU_COMPILER</a>
<a name="4025"><span class="lineNum">    4025 </span><span class="lineNoCov">          0 :                     use_line_length_none_string = &quot;-ffree-line-length-none&quot;;</span></a>
<a name="4026"><span class="lineNum">    4026 </span>            : #elif BACKEND_FORTRAN_IS_INTEL_COMPILER</a>
<a name="4027"><span class="lineNum">    4027 </span>            :                     use_line_length_none_string = &quot;-free&quot;;</a>
<a name="4028"><span class="lineNum">    4028 </span>            : #endif</a>
<a name="4029"><span class="lineNum">    4029 </span>            :                   }</a>
<a name="4030"><span class="lineNum">    4030 </span>            :                  else</a>
<a name="4031"><span class="lineNum">    4031 </span>            :                   {</a>
<a name="4032"><span class="lineNum">    4032 </span><span class="lineCov">         31 :                     if (get_F2008_only() == true)</span></a>
<a name="4033"><span class="lineNum">    4033 </span>            :                        {</a>
<a name="4034"><span class="lineNum">    4034 </span>            :                       // fortranCommandLine.push_back(&quot;-std=f2003&quot;);</a>
<a name="4035"><span class="lineNum">    4035 </span><span class="lineNoCov">          0 :                          if (relaxSyntaxCheckInputCode == false)</span></a>
<a name="4036"><span class="lineNum">    4036 </span>            :                             {</a>
<a name="4037"><span class="lineNum">    4037 </span>            :                            // DQ (1/25/2016): We need to consider making a strict syntax checking option and allowing this to be relaxed</a>
<a name="4038"><span class="lineNum">    4038 </span>            :                            // by default.  It is however not clear that this is required for F2008 code where it does appear to be required</a>
<a name="4039"><span class="lineNum">    4039 </span>            :                            // for F90 code.  So this needs to be tested, see comments above relative to use of &quot;-std=legacy&quot;.</a>
<a name="4040"><span class="lineNum">    4040 </span><span class="lineNoCov">          0 :                               fortranCommandLine.push_back(&quot;-std=f2008&quot;);</span></a>
<a name="4041"><span class="lineNum">    4041 </span>            :                             }</a>
<a name="4042"><span class="lineNum">    4042 </span>            : #if BACKEND_FORTRAN_IS_GNU_COMPILER</a>
<a name="4043"><span class="lineNum">    4043 </span><span class="lineNoCov">          0 :                          use_line_length_none_string = &quot;-ffree-line-length-none&quot;;</span></a>
<a name="4044"><span class="lineNum">    4044 </span>            : #elif BACKEND_FORTRAN_IS_INTEL_COMPILER</a>
<a name="4045"><span class="lineNum">    4045 </span>            :                          use_line_length_none_string = &quot;-free&quot;;</a>
<a name="4046"><span class="lineNum">    4046 </span>            : #endif</a>
<a name="4047"><span class="lineNum">    4047 </span>            :                        }</a>
<a name="4048"><span class="lineNum">    4048 </span>            :                       else</a>
<a name="4049"><span class="lineNum">    4049 </span>            :                        {</a>
<a name="4050"><span class="lineNum">    4050 </span>            :                       // This should be the default mode (fortranMode string is empty). So is it f77?</a>
<a name="4051"><span class="lineNum">    4051 </span>            : #if BACKEND_FORTRAN_IS_GNU_COMPILER</a>
<a name="4052"><span class="lineNum">    4052 </span><span class="lineCov">         31 :                          use_line_length_none_string = &quot;-ffixed-line-length-none&quot;;</span></a>
<a name="4053"><span class="lineNum">    4053 </span>            : #elif BACKEND_FORTRAN_IS_INTEL_COMPILER</a>
<a name="4054"><span class="lineNum">    4054 </span>            :                          use_line_length_none_string = &quot;-fixed&quot;;</a>
<a name="4055"><span class="lineNum">    4055 </span>            : #endif</a>
<a name="4056"><span class="lineNum">    4056 </span>            :                        }</a>
<a name="4057"><span class="lineNum">    4057 </span>            :                   }</a>
<a name="4058"><span class="lineNum">    4058 </span>            :              }</a>
<a name="4059"><span class="lineNum">    4059 </span>            : </a>
<a name="4060"><span class="lineNum">    4060 </span>            : // We need this #if since if gfortran is unavailable the macros for the major and minor version numbers will be empty strings (blank).</a>
<a name="4061"><span class="lineNum">    4061 </span>            : #if BACKEND_FORTRAN_IS_GNU_COMPILER</a>
<a name="4062"><span class="lineNum">    4062 </span>            :        // DQ (9/16/2009): This option is not available in gfortran version 4.0.x (wonderful).</a>
<a name="4063"><span class="lineNum">    4063 </span>            :        // DQ (5/20/2008): Need to select between fixed and free format</a>
<a name="4064"><span class="lineNum">    4064 </span>            :        // fortran_C_preprocessor_commandLine.push_back(&quot;-ffree-line-length-none&quot;);</a>
<a name="4065"><span class="lineNum">    4065 </span><span class="lineCov">         37 :           if ( (BACKEND_FORTRAN_COMPILER_MAJOR_VERSION_NUMBER &gt;= 4) &amp;&amp; (BACKEND_FORTRAN_COMPILER_MINOR_VERSION_NUMBER &gt;= 1) )</span></a>
<a name="4066"><span class="lineNum">    4066 </span>            :              {</a>
<a name="4067"><span class="lineNum">    4067 </span><span class="lineCov">         37 :                fortranCommandLine.push_back(use_line_length_none_string);</span></a>
<a name="4068"><span class="lineNum">    4068 </span>            :              }</a>
<a name="4069"><span class="lineNum">    4069 </span>            : #elif BACKEND_FORTRAN_IS_INTEL_COMPILER</a>
<a name="4070"><span class="lineNum">    4070 </span>            :           fortranCommandLine.push_back(use_line_length_none_string);</a>
<a name="4071"><span class="lineNum">    4071 </span>            : #endif</a>
<a name="4072"><span class="lineNum">    4072 </span>            : </a>
<a name="4073"><span class="lineNum">    4073 </span>            :        // DQ (12/8/2007): Added support for cray pointers from commandline.</a>
<a name="4074"><span class="lineNum">    4074 </span><span class="lineCov">         37 :           if (get_cray_pointer_support() == true)</span></a>
<a name="4075"><span class="lineNum">    4075 </span>            :              {</a>
<a name="4076"><span class="lineNum">    4076 </span><span class="lineNoCov">          0 :                fortranCommandLine.push_back(&quot;-fcray-pointer&quot;);</span></a>
<a name="4077"><span class="lineNum">    4077 </span>            :              }</a>
<a name="4078"><span class="lineNum">    4078 </span>            : </a>
<a name="4079"><span class="lineNum">    4079 </span>            :        // Note that &quot;-c&quot; is required to enforce that we only compile and not link the result (even though -fno-backend is specified)</a>
<a name="4080"><span class="lineNum">    4080 </span>            :        // A web page specific to -fno-backend suggests using -fsyntax-only instead (so the &quot;-c&quot; options is not required).</a>
<a name="4081"><span class="lineNum">    4081 </span>            : #if 1</a>
<a name="4082"><span class="lineNum">    4082 </span>            :        // if ( SgProject::get_verbose() &gt; 0 )</a>
<a name="4083"><span class="lineNum">    4083 </span><span class="lineCov">         37 :           if ( get_verbose() &gt; 0 )</span></a>
<a name="4084"><span class="lineNum">    4084 </span>            :              {</a>
<a name="4085"><span class="lineNum">    4085 </span><span class="lineNoCov">          0 :                printf (&quot;Checking syntax of input program using gfortran: syntaxCheckingCommandline = %s \n&quot;,CommandlineProcessing::generateStringFromArgList(fortranCommandLine,false,false).c_str());</span></a>
<a name="4086"><span class="lineNum">    4086 </span>            :              }</a>
<a name="4087"><span class="lineNum">    4087 </span>            : #endif</a>
<a name="4088"><span class="lineNum">    4088 </span>            :        // Call the OS with the commandline defined by: syntaxCheckingCommandline</a>
<a name="4089"><span class="lineNum">    4089 </span>            : #if 0</a>
<a name="4090"><span class="lineNum">    4090 </span>            :           fortranCommandLine.push_back(get_sourceFileNameWithPath());</a>
<a name="4091"><span class="lineNum">    4091 </span>            : #else</a>
<a name="4092"><span class="lineNum">    4092 </span>            :        // DQ (5/19/2008): Support for C preprocessing</a>
<a name="4093"><span class="lineNum">    4093 </span><span class="lineCov">         37 :           if (requires_C_preprocessor == true)</span></a>
<a name="4094"><span class="lineNum">    4094 </span>            :              {</a>
<a name="4095"><span class="lineNum">    4095 </span>            :             // If C preprocessing was required then we have to provide the generated filename of the preprocessed file!</a>
<a name="4096"><span class="lineNum">    4096 </span>            : </a>
<a name="4097"><span class="lineNum">    4097 </span>            :             // Note that since we are using gfortran to do the syntax checking, we could just</a>
<a name="4098"><span class="lineNum">    4098 </span>            :             // hand the original file to gfortran instead of the one that we generate using CPP.</a>
<a name="4099"><span class="lineNum">    4099 </span><span class="lineNoCov">          0 :                string sourceFilename = get_sourceFileNameWithPath();</span></a>
<a name="4100"><span class="lineNum">    4100 </span><span class="lineNoCov">          0 :                string sourceFileNameOutputFromCpp = generate_C_preprocessor_intermediate_filename(sourceFilename);</span></a>
<a name="4101"><span class="lineNum">    4101 </span><span class="lineNoCov">          0 :                fortranCommandLine.push_back(sourceFileNameOutputFromCpp);</span></a>
<a name="4102"><span class="lineNum">    4102 </span>            :              }</a>
<a name="4103"><span class="lineNum">    4103 </span>            :             else</a>
<a name="4104"><span class="lineNum">    4104 </span>            :              {</a>
<a name="4105"><span class="lineNum">    4105 </span>            :             // This will cause the original file to be used for syntax checking (instead of</a>
<a name="4106"><span class="lineNum">    4106 </span>            :             // the CPP generated one, if one was generated).</a>
<a name="4107"><span class="lineNum">    4107 </span><span class="lineCov">         74 :                fortranCommandLine.push_back(get_sourceFileNameWithPath());</span></a>
<a name="4108"><span class="lineNum">    4108 </span>            :              }</a>
<a name="4109"><span class="lineNum">    4109 </span>            : #endif</a>
<a name="4110"><span class="lineNum">    4110 </span>            : </a>
<a name="4111"><span class="lineNum">    4111 </span>            :        // At this point we have the full command line with the source file name</a>
<a name="4112"><span class="lineNum">    4112 </span><span class="lineCov">         37 :           if ( get_verbose() &gt; 0 )</span></a>
<a name="4113"><span class="lineNum">    4113 </span>            :              {</a>
<a name="4114"><span class="lineNum">    4114 </span><span class="lineNoCov">          0 :                printf (&quot;Checking syntax of input program using gfortran: syntaxCheckingCommandline = %s \n&quot;,CommandlineProcessing::generateStringFromArgList(fortranCommandLine,false,false).c_str());</span></a>
<a name="4115"><span class="lineNum">    4115 </span>            :              }</a>
<a name="4116"><span class="lineNum">    4116 </span>            : </a>
<a name="4117"><span class="lineNum">    4117 </span><span class="lineCov">         37 :           int returnValueForSyntaxCheckUsingBackendCompiler = 0;</span></a>
<a name="4118"><span class="lineNum">    4118 </span>            : #if BACKEND_FORTRAN_IS_GNU_COMPILER</a>
<a name="4119"><span class="lineNum">    4119 </span><span class="lineCov">         37 :         returnValueForSyntaxCheckUsingBackendCompiler = systemFromVector (fortranCommandLine);</span></a>
<a name="4120"><span class="lineNum">    4120 </span>            : #else</a>
<a name="4121"><span class="lineNum">    4121 </span>            :         printf (&quot;backend fortran compiler (gfortran) unavailable ... (not an error) \n&quot;);</a>
<a name="4122"><span class="lineNum">    4122 </span>            : #endif</a>
<a name="4123"><span class="lineNum">    4123 </span>            : </a>
<a name="4124"><span class="lineNum">    4124 </span>            :      // Check that there are no errors, I think that warnings are ignored!</a>
<a name="4125"><span class="lineNum">    4125 </span><span class="lineCov">         37 :         if (returnValueForSyntaxCheckUsingBackendCompiler != 0)</span></a>
<a name="4126"><span class="lineNum">    4126 </span>            :            {</a>
<a name="4127"><span class="lineNum">    4127 </span><span class="lineNoCov">          0 :              printf (&quot;Syntax errors detected in input fortran program ... \n&quot;);</span></a>
<a name="4128"><span class="lineNum">    4128 </span>            : </a>
<a name="4129"><span class="lineNum">    4129 </span>            :           // We should define some convention for error codes returned by ROSE</a>
<a name="4130"><span class="lineNum">    4130 </span><span class="lineNoCov">          0 :              throw std::exception();</span></a>
<a name="4131"><span class="lineNum">    4131 </span>            :            }</a>
<a name="4132"><span class="lineNum">    4132 </span><span class="lineCov">         37 :         ROSE_ASSERT(returnValueForSyntaxCheckUsingBackendCompiler == 0);</span></a>
<a name="4133"><span class="lineNum">    4133 </span>            :       } // Terminates if (syntaxCheckInputCode == true)</a>
<a name="4134"><span class="lineNum">    4134 </span>            : </a>
<a name="4135"><span class="lineNum">    4135 </span>            :     // Build the classpath list for Fortran support.</a>
<a name="4136"><span class="lineNum">    4136 </span><span class="lineCov">         74 :     string classpath = Rose::Cmdline::Fortran::Ofp::GetRoseClasspath();</span></a>
<a name="4137"><span class="lineNum">    4137 </span>            : </a>
<a name="4138"><span class="lineNum">    4138 </span>            :   //</a>
<a name="4139"><span class="lineNum">    4139 </span>            :   // In the case of Javam add the paths specified for the input program, if any.</a>
<a name="4140"><span class="lineNum">    4140 </span>            :   //</a>
<a name="4141"><span class="lineNum">    4141 </span><span class="lineCov">         74 :      list&lt;string&gt; classpath_list = get_project() -&gt; get_Java_classpath();</span></a>
<a name="4142"><span class="lineNum">    4142 </span><span class="lineCov">         37 :      for (list&lt;string&gt;::iterator i = classpath_list.begin(); i != classpath_list.end(); i++) {</span></a>
<a name="4143"><span class="lineNum">    4143 </span><span class="lineNoCov">          0 :          classpath += &quot;:&quot;;</span></a>
<a name="4144"><span class="lineNum">    4144 </span><span class="lineNoCov">          0 :          classpath += (*i);</span></a>
<a name="4145"><span class="lineNum">    4145 </span>            :      }</a>
<a name="4146"><span class="lineNum">    4146 </span>            : </a>
<a name="4147"><span class="lineNum">    4147 </span>            : </a>
<a name="4148"><span class="lineNum">    4148 </span>            :   // This is part of debugging output to call OFP and output the list of parser actions that WOULD be called.</a>
<a name="4149"><span class="lineNum">    4149 </span>            :   // printf (&quot;get_output_parser_actions() = %s \n&quot;,get_output_parser_actions() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="4150"><span class="lineNum">    4150 </span><span class="lineCov">         37 :      if (get_output_parser_actions() == true)</span></a>
<a name="4151"><span class="lineNum">    4151 </span>            :         {</a>
<a name="4152"><span class="lineNum">    4152 </span>            :        // DQ (1/19/2008): New version of OFP requires different calling syntax.</a>
<a name="4153"><span class="lineNum">    4153 </span>            :        // string OFPCommandLineString = std::string(&quot;java parser.java.FortranMain&quot;) + &quot; --dump &quot; + get_sourceFileNameWithPath();</a>
<a name="4154"><span class="lineNum">    4154 </span><span class="lineNoCov">          0 :           vector&lt;string&gt; OFPCommandLine;</span></a>
<a name="4155"><span class="lineNum">    4155 </span><span class="lineNoCov">          0 :           OFPCommandLine.push_back(JAVA_JVM_PATH);</span></a>
<a name="4156"><span class="lineNum">    4156 </span><span class="lineNoCov">          0 :           OFPCommandLine.push_back(classpath);</span></a>
<a name="4157"><span class="lineNum">    4157 </span><span class="lineNoCov">          0 :           OFPCommandLine.push_back(&quot;fortran.ofp.FrontEnd&quot;);</span></a>
<a name="4158"><span class="lineNum">    4158 </span><span class="lineNoCov">          0 :           OFPCommandLine.push_back(&quot;--dump&quot;);</span></a>
<a name="4159"><span class="lineNum">    4159 </span>            :        // OFPCommandLine.push_back(&quot;--tokens&quot;);</a>
<a name="4160"><span class="lineNum">    4160 </span>            : </a>
<a name="4161"><span class="lineNum">    4161 </span>            :        // DQ (5/18/2008): Added support for include paths as required for relatively new Fortran specific include mechanism in OFP.</a>
<a name="4162"><span class="lineNum">    4162 </span><span class="lineNoCov">          0 :           const SgStringList &amp; includeList = get_project()-&gt;get_includeDirectorySpecifierList();</span></a>
<a name="4163"><span class="lineNum">    4163 </span><span class="lineNoCov">          0 :           for (size_t i = 0; i &lt; includeList.size(); i++)</span></a>
<a name="4164"><span class="lineNum">    4164 </span>            :              {</a>
<a name="4165"><span class="lineNum">    4165 </span><span class="lineNoCov">          0 :                OFPCommandLine.push_back(includeList[i]);</span></a>
<a name="4166"><span class="lineNum">    4166 </span>            :              }</a>
<a name="4167"><span class="lineNum">    4167 </span>            : </a>
<a name="4168"><span class="lineNum">    4168 </span>            :        // DQ (5/19/2008): Support for C preprocessing</a>
<a name="4169"><span class="lineNum">    4169 </span><span class="lineNoCov">          0 :           if (requires_C_preprocessor == true)</span></a>
<a name="4170"><span class="lineNum">    4170 </span>            :              {</a>
<a name="4171"><span class="lineNum">    4171 </span>            :             // If C preprocessing was required then we have to provide the generated filename of the preprocessed file!</a>
<a name="4172"><span class="lineNum">    4172 </span>            :             // Note that OFP has no support for CPP directives and will ignore them all.</a>
<a name="4173"><span class="lineNum">    4173 </span><span class="lineNoCov">          0 :                string sourceFilename              = get_sourceFileNameWithPath();</span></a>
<a name="4174"><span class="lineNum">    4174 </span><span class="lineNoCov">          0 :                string sourceFileNameOutputFromCpp = generate_C_preprocessor_intermediate_filename(sourceFilename);</span></a>
<a name="4175"><span class="lineNum">    4175 </span><span class="lineNoCov">          0 :                OFPCommandLine.push_back(sourceFileNameOutputFromCpp);</span></a>
<a name="4176"><span class="lineNum">    4176 </span>            :              }</a>
<a name="4177"><span class="lineNum">    4177 </span>            :             else</a>
<a name="4178"><span class="lineNum">    4178 </span>            :              {</a>
<a name="4179"><span class="lineNum">    4179 </span>            :             // Build the command line using the original file (to be used by OFP).</a>
<a name="4180"><span class="lineNum">    4180 </span><span class="lineNoCov">          0 :                OFPCommandLine.push_back(get_sourceFileNameWithPath());</span></a>
<a name="4181"><span class="lineNum">    4181 </span>            :              }</a>
<a name="4182"><span class="lineNum">    4182 </span>            : </a>
<a name="4183"><span class="lineNum">    4183 </span>            : #if 1</a>
<a name="4184"><span class="lineNum">    4184 </span><span class="lineNoCov">          0 :           printf (&quot;output_parser_actions: OFPCommandLine = %s \n&quot;,CommandlineProcessing::generateStringFromArgList(OFPCommandLine,false,false).c_str());</span></a>
<a name="4185"><span class="lineNum">    4185 </span>            : #endif</a>
<a name="4186"><span class="lineNum">    4186 </span>            : </a>
<a name="4187"><span class="lineNum">    4187 </span>            : #if 1</a>
<a name="4188"><span class="lineNum">    4188 </span>            :        // Some security checking here could be helpful!!!</a>
<a name="4189"><span class="lineNum">    4189 </span>            :        // Run OFP with the --dump option so that we can get the parset actions (used only for internal debugging support).</a>
<a name="4190"><span class="lineNum">    4190 </span><span class="lineNoCov">          0 :           int errorCode = systemFromVector(OFPCommandLine);</span></a>
<a name="4191"><span class="lineNum">    4191 </span>            : </a>
<a name="4192"><span class="lineNum">    4192 </span><span class="lineNoCov">          0 :           if (errorCode != 0)</span></a>
<a name="4193"><span class="lineNum">    4193 </span>            :              {</a>
<a name="4194"><span class="lineNum">    4194 </span><span class="lineNoCov">          0 :                printf (&quot;Running OFP ONLY causes an error (errorCode = %d) \n&quot;,errorCode);</span></a>
<a name="4195"><span class="lineNum">    4195 </span>            : #if 1</a>
<a name="4196"><span class="lineNum">    4196 </span>            :             // DQ (10/4/2008): Need to work with Liao to see why this passes for me but fails for him (and others).</a>
<a name="4197"><span class="lineNum">    4197 </span>            :             // for now we can comment out the error checking on the running of OFP as part of getting the</a>
<a name="4198"><span class="lineNum">    4198 </span>            :             // output_parser_actions option (used for debugging).</a>
<a name="4199"><span class="lineNum">    4199 </span><span class="lineNoCov">          0 :                ROSE_ABORT();</span></a>
<a name="4200"><span class="lineNum">    4200 </span>            : #else</a>
<a name="4201"><span class="lineNum">    4201 </span>            :                printf (&quot;Skipping enforcement of exit after running OFP ONLY as (part of output_parser_actions option) \n&quot;);</a>
<a name="4202"><span class="lineNum">    4202 </span>            : #endif</a>
<a name="4203"><span class="lineNum">    4203 </span>            :              }</a>
<a name="4204"><span class="lineNum">    4204 </span>            : #else</a>
<a name="4205"><span class="lineNum">    4205 </span>            : </a>
<a name="4206"><span class="lineNum">    4206 </span>            : #error &quot;REMOVE THIS CODE&quot;</a>
<a name="4207"><span class="lineNum">    4207 </span>            : </a>
<a name="4208"><span class="lineNum">    4208 </span>            :        // This fails, I think because we can't call the openFortranParser_main twice.</a>
<a name="4209"><span class="lineNum">    4209 </span>            :        // DQ (11/30/2008):  Does the work by Rice fix this now?</a>
<a name="4210"><span class="lineNum">    4210 </span>            :           int openFortranParser_dump_argc    = 0;</a>
<a name="4211"><span class="lineNum">    4211 </span>            :           char** openFortranParser_dump_argv = nullptr;</a>
<a name="4212"><span class="lineNum">    4212 </span>            :           CommandlineProcessing::generateArgcArgvFromList(OFPCommandLine,openFortranParser_dump_argc,openFortranParser_dump_argv);</a>
<a name="4213"><span class="lineNum">    4213 </span>            :           frontendErrorLevel = openFortranParser_main (openFortranParser_dump_argc, openFortranParser_dump_argv);</a>
<a name="4214"><span class="lineNum">    4214 </span>            : </a>
<a name="4215"><span class="lineNum">    4215 </span>            : #endif</a>
<a name="4216"><span class="lineNum">    4216 </span>            :        // If this was selected as an option then we can stop here (rather than call OFP again).</a>
<a name="4217"><span class="lineNum">    4217 </span>            :        // printf (&quot;--- get_exit_after_parser() = %s \n&quot;,get_exit_after_parser() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="4218"><span class="lineNum">    4218 </span><span class="lineNoCov">          0 :           if (get_exit_after_parser() == true)</span></a>
<a name="4219"><span class="lineNum">    4219 </span>            :              {</a>
<a name="4220"><span class="lineNum">    4220 </span><span class="lineNoCov">          0 :                printf (&quot;Exiting after parsing... \n&quot;);</span></a>
<a name="4221"><span class="lineNum">    4221 </span><span class="lineNoCov">          0 :                exit(0);</span></a>
<a name="4222"><span class="lineNum">    4222 </span>            :              }</a>
<a name="4223"><span class="lineNum">    4223 </span>            : </a>
<a name="4224"><span class="lineNum">    4224 </span>            :        // End of option handling to generate list of OPF parser actions.</a>
<a name="4225"><span class="lineNum">    4225 </span>            :         }</a>
<a name="4226"><span class="lineNum">    4226 </span>            : </a>
<a name="4227"><span class="lineNum">    4227 </span>            :   // Option to just run the parser (not constructing the AST) and quit.</a>
<a name="4228"><span class="lineNum">    4228 </span>            :   // printf (&quot;get_exit_after_parser() = %s \n&quot;,get_exit_after_parser() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="4229"><span class="lineNum">    4229 </span><span class="lineCov">         37 :      if (get_exit_after_parser() == true)</span></a>
<a name="4230"><span class="lineNum">    4230 </span>            :         {</a>
<a name="4231"><span class="lineNum">    4231 </span>            :        // DQ (1/19/2008): New version of OFP requires different calling syntax.</a>
<a name="4232"><span class="lineNum">    4232 </span>            :        // string OFPCommandLineString = std::string(&quot;java parser.java.FortranMain&quot;) + &quot; &quot; + get_sourceFileNameWithPath();</a>
<a name="4233"><span class="lineNum">    4233 </span><span class="lineNoCov">          0 :           vector&lt;string&gt; OFPCommandLine;</span></a>
<a name="4234"><span class="lineNum">    4234 </span><span class="lineNoCov">          0 :           OFPCommandLine.push_back(JAVA_JVM_PATH);</span></a>
<a name="4235"><span class="lineNum">    4235 </span><span class="lineNoCov">          0 :           OFPCommandLine.push_back(classpath);</span></a>
<a name="4236"><span class="lineNum">    4236 </span><span class="lineNoCov">          0 :           OFPCommandLine.push_back(&quot;fortran.ofp.FrontEnd&quot;);</span></a>
<a name="4237"><span class="lineNum">    4237 </span>            : </a>
<a name="4238"><span class="lineNum">    4238 </span><span class="lineNoCov">          0 :           bool foundSourceDirectoryExplicitlyListedInIncludePaths = false;</span></a>
<a name="4239"><span class="lineNum">    4239 </span>            : </a>
<a name="4240"><span class="lineNum">    4240 </span>            :        // DQ (5/18/2008): Added support for include paths as required for relatively new Fortran specific include mechanism in OFP.</a>
<a name="4241"><span class="lineNum">    4241 </span><span class="lineNoCov">          0 :           const SgStringList &amp; includeList = get_project()-&gt;get_includeDirectorySpecifierList();</span></a>
<a name="4242"><span class="lineNum">    4242 </span><span class="lineNoCov">          0 :           for (size_t i = 0; i &lt; includeList.size(); i++)</span></a>
<a name="4243"><span class="lineNum">    4243 </span>            :              {</a>
<a name="4244"><span class="lineNum">    4244 </span><span class="lineNoCov">          0 :                OFPCommandLine.push_back(includeList[i]);</span></a>
<a name="4245"><span class="lineNum">    4245 </span>            : </a>
<a name="4246"><span class="lineNum">    4246 </span>            :             // printf (&quot;includeList[%d] = %s \n&quot;,i,includeList[i].c_str());</a>
<a name="4247"><span class="lineNum">    4247 </span>            : </a>
<a name="4248"><span class="lineNum">    4248 </span>            :             // I think we have to permit an optional space between the &quot;-I&quot; and the path</a>
<a name="4249"><span class="lineNum">    4249 </span><span class="lineNoCov">          0 :                if (&quot;-I&quot; + getSourceDirectory() == includeList[i] || &quot;-I &quot; + getSourceDirectory() == includeList[i])</span></a>
<a name="4250"><span class="lineNum">    4250 </span>            :                   {</a>
<a name="4251"><span class="lineNum">    4251 </span>            :                  // The source file path is already included!</a>
<a name="4252"><span class="lineNum">    4252 </span><span class="lineNoCov">          0 :                     foundSourceDirectoryExplicitlyListedInIncludePaths = true;</span></a>
<a name="4253"><span class="lineNum">    4253 </span>            :                   }</a>
<a name="4254"><span class="lineNum">    4254 </span>            :              }</a>
<a name="4255"><span class="lineNum">    4255 </span>            : </a>
<a name="4256"><span class="lineNum">    4256 </span><span class="lineNoCov">          0 :           if (foundSourceDirectoryExplicitlyListedInIncludePaths == false)</span></a>
<a name="4257"><span class="lineNum">    4257 </span>            :              {</a>
<a name="4258"><span class="lineNum">    4258 </span>            :             // Add the source directory to the include list so that we reproduce the semantics of gfortran</a>
<a name="4259"><span class="lineNum">    4259 </span><span class="lineNoCov">          0 :                OFPCommandLine.push_back(&quot;-I&quot; + getSourceDirectory() );</span></a>
<a name="4260"><span class="lineNum">    4260 </span>            :              }</a>
<a name="4261"><span class="lineNum">    4261 </span>            : </a>
<a name="4262"><span class="lineNum">    4262 </span>            :        // DQ (8/24/2010): Detect the use of CPP on the fortran file and use the correct generated file from CPP, if required.</a>
<a name="4263"><span class="lineNum">    4263 </span>            :        // OFPCommandLine.push_back(get_sourceFileNameWithPath());</a>
<a name="4264"><span class="lineNum">    4264 </span><span class="lineNoCov">          0 :           if (requires_C_preprocessor == true)</span></a>
<a name="4265"><span class="lineNum">    4265 </span>            :              {</a>
<a name="4266"><span class="lineNum">    4266 </span><span class="lineNoCov">          0 :                string sourceFilename = get_sourceFileNameWithoutPath();</span></a>
<a name="4267"><span class="lineNum">    4267 </span><span class="lineNoCov">          0 :                string sourceFileNameOutputFromCpp = generate_C_preprocessor_intermediate_filename(sourceFilename);</span></a>
<a name="4268"><span class="lineNum">    4268 </span><span class="lineNoCov">          0 :                OFPCommandLine.push_back(sourceFileNameOutputFromCpp);</span></a>
<a name="4269"><span class="lineNum">    4269 </span>            :              }</a>
<a name="4270"><span class="lineNum">    4270 </span>            :             else</a>
<a name="4271"><span class="lineNum">    4271 </span>            :              {</a>
<a name="4272"><span class="lineNum">    4272 </span><span class="lineNoCov">          0 :                OFPCommandLine.push_back(get_sourceFileNameWithPath());</span></a>
<a name="4273"><span class="lineNum">    4273 </span>            :              }</a>
<a name="4274"><span class="lineNum">    4274 </span>            : </a>
<a name="4275"><span class="lineNum">    4275 </span>            : #if 1</a>
<a name="4276"><span class="lineNum">    4276 </span>            :        // Some security checking here could be helpful!!!</a>
<a name="4277"><span class="lineNum">    4277 </span><span class="lineNoCov">          0 :           int errorCode = systemFromVector (OFPCommandLine);</span></a>
<a name="4278"><span class="lineNum">    4278 </span>            : </a>
<a name="4279"><span class="lineNum">    4279 </span>            :        // DQ (9/30/2008): Added error checking of return value</a>
<a name="4280"><span class="lineNum">    4280 </span><span class="lineNoCov">          0 :           if (errorCode != 0)</span></a>
<a name="4281"><span class="lineNum">    4281 </span>            :              {</a>
<a name="4282"><span class="lineNum">    4282 </span><span class="lineNoCov">          0 :                printf (&quot;Using option -rose:exit_after_parser (errorCode = %d) \n&quot;,errorCode);</span></a>
<a name="4283"><span class="lineNum">    4283 </span><span class="lineNoCov">          0 :                ROSE_ABORT();</span></a>
<a name="4284"><span class="lineNum">    4284 </span>            :              }</a>
<a name="4285"><span class="lineNum">    4285 </span>            : #else</a>
<a name="4286"><span class="lineNum">    4286 </span>            : </a>
<a name="4287"><span class="lineNum">    4287 </span>            : // #error &quot;REMOVE THIS CODE&quot;</a>
<a name="4288"><span class="lineNum">    4288 </span>            : </a>
<a name="4289"><span class="lineNum">    4289 </span>            :        // This fails, I think because we can't call the openFortranParser_main twice.</a>
<a name="4290"><span class="lineNum">    4290 </span>            :           int openFortranParser_only_argc    = 0;</a>
<a name="4291"><span class="lineNum">    4291 </span>            :           char** openFortranParser_only_argv = nullptr;</a>
<a name="4292"><span class="lineNum">    4292 </span>            :           CommandlineProcessing::generateArgcArgvFromList(OFPCommandLine,openFortranParser_only_argc,openFortranParser_only_argv);</a>
<a name="4293"><span class="lineNum">    4293 </span>            :           int errorCode = openFortranParser_main (openFortranParser_only_argc, openFortranParser_only_argv);</a>
<a name="4294"><span class="lineNum">    4294 </span>            : </a>
<a name="4295"><span class="lineNum">    4295 </span>            : #endif</a>
<a name="4296"><span class="lineNum">    4296 </span><span class="lineNoCov">          0 :           printf (&quot;Skipping all processing after parsing fortran (OFP) ... (get_exit_after_parser() == true) errorCode = %d \n&quot;,errorCode);</span></a>
<a name="4297"><span class="lineNum">    4297 </span>            : </a>
<a name="4298"><span class="lineNum">    4298 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(errorCode == 0);</span></a>
<a name="4299"><span class="lineNum">    4299 </span><span class="lineNoCov">          0 :           return errorCode;</span></a>
<a name="4300"><span class="lineNum">    4300 </span>            :        }</a>
<a name="4301"><span class="lineNum">    4301 </span>            : </a>
<a name="4302"><span class="lineNum">    4302 </span>            :   // DQ (1/19/2008): New version of OFP requires different calling syntax; new lib name is: libfortran_ofp_parser_java_FortranParserActionJNI.so old name: libparser_java_FortranParserActionJNI.so</a>
<a name="4303"><span class="lineNum">    4303 </span>            :   // frontEndCommandLineString = std::string(argv[0]) + &quot; --class parser.java.FortranParserActionJNI &quot; + get_sourceFileNameWithPath();</a>
<a name="4304"><span class="lineNum">    4304 </span><span class="lineCov">         37 :      vector&lt;string&gt; frontEndCommandLine;</span></a>
<a name="4305"><span class="lineNum">    4305 </span>            : </a>
<a name="4306"><span class="lineNum">    4306 </span><span class="lineCov">         37 :      frontEndCommandLine.push_back(argv[0]);</span></a>
<a name="4307"><span class="lineNum">    4307 </span><span class="lineCov">         74 :      frontEndCommandLine.push_back(&quot;--class&quot;);</span></a>
<a name="4308"><span class="lineNum">    4308 </span><span class="lineCov">         74 :      frontEndCommandLine.push_back(&quot;fortran.ofp.parser.c.jni.FortranParserActionJNI&quot;);</span></a>
<a name="4309"><span class="lineNum">    4309 </span>            : </a>
<a name="4310"><span class="lineNum">    4310 </span>            :      //FMZ (7/26/2010)  added an option for using rice CAF.</a>
<a name="4311"><span class="lineNum">    4311 </span><span class="lineCov">         37 :      if (using_rice_caf==true)</span></a>
<a name="4312"><span class="lineNum">    4312 </span><span class="lineNoCov">          0 :           frontEndCommandLine.push_back(&quot;--RiceCAF&quot;);</span></a>
<a name="4313"><span class="lineNum">    4313 </span>            : </a>
<a name="4314"><span class="lineNum">    4314 </span>            : #if 0</a>
<a name="4315"><span class="lineNum">    4315 </span>            :   // Debugging output</a>
<a name="4316"><span class="lineNum">    4316 </span>            :      get_project()-&gt;display(&quot;Calling SgProject display&quot;);</a>
<a name="4317"><span class="lineNum">    4317 </span>            :      display(&quot;Calling SgFile display&quot;);</a>
<a name="4318"><span class="lineNum">    4318 </span>            : #endif</a>
<a name="4319"><span class="lineNum">    4319 </span>            : </a>
<a name="4320"><span class="lineNum">    4320 </span><span class="lineCov">         37 :      const SgStringList &amp; includeList = get_project()-&gt;get_includeDirectorySpecifierList();</span></a>
<a name="4321"><span class="lineNum">    4321 </span>            :      bool foundSourceDirectoryExplicitlyListedInIncludePaths = false;</a>
<a name="4322"><span class="lineNum">    4322 </span>            : </a>
<a name="4323"><span class="lineNum">    4323 </span><span class="lineCov">         68 :      for (size_t i = 0; i &lt; includeList.size(); i++)</span></a>
<a name="4324"><span class="lineNum">    4324 </span>            :         {</a>
<a name="4325"><span class="lineNum">    4325 </span><span class="lineCov">         31 :           frontEndCommandLine.push_back(includeList[i]);</span></a>
<a name="4326"><span class="lineNum">    4326 </span>            : </a>
<a name="4327"><span class="lineNum">    4327 </span>            :        // printf (&quot;includeList[%d] = %s \n&quot;,i,includeList[i].c_str());</a>
<a name="4328"><span class="lineNum">    4328 </span>            : </a>
<a name="4329"><span class="lineNum">    4329 </span>            :        // I think we have to permit an optional space between the &quot;-I&quot; and the path</a>
<a name="4330"><span class="lineNum">    4330 </span><span class="lineCov">        124 :           if (  &quot;-I&quot; + getSourceDirectory() == includeList[i] || &quot;-I &quot; + getSourceDirectory() == includeList[i])</span></a>
<a name="4331"><span class="lineNum">    4331 </span>            :              {</a>
<a name="4332"><span class="lineNum">    4332 </span>            :             // The source file path is already included!</a>
<a name="4333"><span class="lineNum">    4333 </span><span class="lineNoCov">          0 :                foundSourceDirectoryExplicitlyListedInIncludePaths = true;</span></a>
<a name="4334"><span class="lineNum">    4334 </span>            :              }</a>
<a name="4335"><span class="lineNum">    4335 </span>            :         }</a>
<a name="4336"><span class="lineNum">    4336 </span>            : </a>
<a name="4337"><span class="lineNum">    4337 </span><span class="lineCov">         37 :      if (foundSourceDirectoryExplicitlyListedInIncludePaths == false)</span></a>
<a name="4338"><span class="lineNum">    4338 </span>            :         {</a>
<a name="4339"><span class="lineNum">    4339 </span>            :        // Add the source directory to the include list so that we reproduce the semantics of gfortran</a>
<a name="4340"><span class="lineNum">    4340 </span><span class="lineCov">         74 :           frontEndCommandLine.push_back(&quot;-I&quot; + getSourceDirectory() );</span></a>
<a name="4341"><span class="lineNum">    4341 </span>            :         }</a>
<a name="4342"><span class="lineNum">    4342 </span>            : </a>
<a name="4343"><span class="lineNum">    4343 </span>            :   // DQ (5/19/2008): Support for C preprocessing</a>
<a name="4344"><span class="lineNum">    4344 </span><span class="lineCov">         37 :      if (requires_C_preprocessor == true)</span></a>
<a name="4345"><span class="lineNum">    4345 </span>            :         {</a>
<a name="4346"><span class="lineNum">    4346 </span>            :        // If C preprocessing was required then we have to provide the generated filename of the preprocessed file!</a>
<a name="4347"><span class="lineNum">    4347 </span>            : </a>
<a name="4348"><span class="lineNum">    4348 </span>            :        // Note that the filename referenced in the Sg_File_Info objects will use the original file name and not</a>
<a name="4349"><span class="lineNum">    4349 </span>            :        // the generated file name of the CPP generated file.  This is because it gets the filename from the</a>
<a name="4350"><span class="lineNum">    4350 </span>            :        // SgSourceFile IR node and not from the filename provided on the internal command line generated for call OFP.</a>
<a name="4351"><span class="lineNum">    4351 </span>            : </a>
<a name="4352"><span class="lineNum">    4352 </span><span class="lineNoCov">          0 :           string sourceFilename              = get_sourceFileNameWithPath();</span></a>
<a name="4353"><span class="lineNum">    4353 </span><span class="lineNoCov">          0 :           string sourceFileNameOutputFromCpp = generate_C_preprocessor_intermediate_filename(sourceFilename);</span></a>
<a name="4354"><span class="lineNum">    4354 </span>            : </a>
<a name="4355"><span class="lineNum">    4355 </span><span class="lineNoCov">          0 :           frontEndCommandLine.push_back(sourceFileNameOutputFromCpp);</span></a>
<a name="4356"><span class="lineNum">    4356 </span>            :         }</a>
<a name="4357"><span class="lineNum">    4357 </span>            :        else</a>
<a name="4358"><span class="lineNum">    4358 </span>            :         {</a>
<a name="4359"><span class="lineNum">    4359 </span>            :        // If not being preprocessed, the fortran filename is just the original input source file name.</a>
<a name="4360"><span class="lineNum">    4360 </span><span class="lineCov">         74 :           frontEndCommandLine.push_back(get_sourceFileNameWithPath());</span></a>
<a name="4361"><span class="lineNum">    4361 </span>            :         }</a>
<a name="4362"><span class="lineNum">    4362 </span>            : </a>
<a name="4363"><span class="lineNum">    4363 </span>            : #if 1</a>
<a name="4364"><span class="lineNum">    4364 </span><span class="lineCov">         37 :      if ( get_verbose() &gt; 0 )</span></a>
<a name="4365"><span class="lineNum">    4365 </span><span class="lineNoCov">          0 :           printf (&quot;Fortran numberOfCommandLineArguments = %&quot; PRIuPTR &quot; frontEndCommandLine = %s \n&quot;,frontEndCommandLine.size(),CommandlineProcessing::generateStringFromArgList(frontEndCommandLine,false,false).c_str());</span></a>
<a name="4366"><span class="lineNum">    4366 </span>            : #endif</a>
<a name="4367"><span class="lineNum">    4367 </span>            : </a>
<a name="4368"><span class="lineNum">    4368 </span>            : #if 0</a>
<a name="4369"><span class="lineNum">    4369 </span>            :      frontEndCommandLine.push_back(&quot;--tokens&quot;);</a>
<a name="4370"><span class="lineNum">    4370 </span>            : #endif</a>
<a name="4371"><span class="lineNum">    4371 </span>            : </a>
<a name="4372"><span class="lineNum">    4372 </span><span class="lineCov">         37 :      if (get_unparse_tokens() == true)</span></a>
<a name="4373"><span class="lineNum">    4373 </span>            :         {</a>
<a name="4374"><span class="lineNum">    4374 </span>            :        // Note that this will cause all other c_actions to not be executed (resulting in an empty file).</a>
<a name="4375"><span class="lineNum">    4375 </span>            :        // So this makes since to run in an analysis mode only, not for generation of code or compiling</a>
<a name="4376"><span class="lineNum">    4376 </span>            :        // of the generated code.</a>
<a name="4377"><span class="lineNum">    4377 </span><span class="lineNoCov">          0 :           frontEndCommandLine.push_back(&quot;--tokens&quot;);</span></a>
<a name="4378"><span class="lineNum">    4378 </span>            :         }</a>
<a name="4379"><span class="lineNum">    4379 </span>            : </a>
<a name="4380"><span class="lineNum">    4380 </span><span class="lineCov">         37 :      int openFortranParser_argc    = 0;</span></a>
<a name="4381"><span class="lineNum">    4381 </span><span class="lineCov">         37 :      char** openFortranParser_argv = nullptr;</span></a>
<a name="4382"><span class="lineNum">    4382 </span><span class="lineCov">         37 :      CommandlineProcessing::generateArgcArgvFromList(frontEndCommandLine,openFortranParser_argc,openFortranParser_argv);</span></a>
<a name="4383"><span class="lineNum">    4383 </span>            : </a>
<a name="4384"><span class="lineNum">    4384 </span>            :   // DQ (8/19/2007): Setup the global pointer used to pass the SgFile to which the Open Fortran Parser</a>
<a name="4385"><span class="lineNum">    4385 </span>            :   // should attach the AST.  This is a bit ugly, but the parser interface only takes a commandline so it</a>
<a name="4386"><span class="lineNum">    4386 </span>            :   // would be more ackward to pass a pointer to a C++ object through the commandline or the Java interface.</a>
<a name="4387"><span class="lineNum">    4387 </span><span class="lineCov">         37 :      OpenFortranParser_globalFilePointer = const_cast&lt;SgSourceFile*&gt;(this);</span></a>
<a name="4388"><span class="lineNum">    4388 </span><span class="lineCov">         37 :      ASSERT_not_null(OpenFortranParser_globalFilePointer);</span></a>
<a name="4389"><span class="lineNum">    4389 </span>            : </a>
<a name="4390"><span class="lineNum">    4390 </span><span class="lineCov">         37 :      if ( get_verbose() &gt; 1 )</span></a>
<a name="4391"><span class="lineNum">    4391 </span><span class="lineNoCov">          0 :           printf (&quot;Calling openFortranParser_main(): OpenFortranParser_globalFilePointer = %p \n&quot;,OpenFortranParser_globalFilePointer);</span></a>
<a name="4392"><span class="lineNum">    4392 </span>            : </a>
<a name="4393"><span class="lineNum">    4393 </span>            : #if USE_ROSE_SSL_SUPPORT</a>
<a name="4394"><span class="lineNum">    4394 </span>            :   // The use of the JVM required to support Java is a problem when linking to the SSL library (either -lssl or -lcrypto)</a>
<a name="4395"><span class="lineNum">    4395 </span>            :   // this may be fixed in Java version 6, but this is a hope, it has not been tested.  Java version 6 does</a>
<a name="4396"><span class="lineNum">    4396 </span>            :   // appear to fix the problem with zlib (we think) and this appears to be a similar problem).</a>
<a name="4397"><span class="lineNum">    4397 </span>            :      int frontendErrorLevel = 1;</a>
<a name="4398"><span class="lineNum">    4398 </span>            : </a>
<a name="4399"><span class="lineNum">    4399 </span>            :      printf (&quot;********************************************************************************************** \n&quot;);</a>
<a name="4400"><span class="lineNum">    4400 </span>            :      printf (&quot;Fortran support using the JVM is incompatable with the use of the SSL library (fails in jvm).  \n&quot;);</a>
<a name="4401"><span class="lineNum">    4401 </span>            :      printf (&quot;To enable the use of Fortran support in ROSE don't use --enable-ssl on configure command line. \n&quot;);</a>
<a name="4402"><span class="lineNum">    4402 </span>            :      printf (&quot;********************************************************************************************** \n&quot;);</a>
<a name="4403"><span class="lineNum">    4403 </span>            : #else</a>
<a name="4404"><span class="lineNum">    4404 </span>            : </a>
<a name="4405"><span class="lineNum">    4405 </span>            :   // DQ (11/11/2010): There should be no include files on the stack from previous files, see test2010_78.C and test2010_79.C when</a>
<a name="4406"><span class="lineNum">    4406 </span>            :   // compiled together on the same command line.</a>
<a name="4407"><span class="lineNum">    4407 </span><span class="lineCov">         37 :      ROSE_ASSERT(astIncludeStack.size() == 0);</span></a>
<a name="4408"><span class="lineNum">    4408 </span>            : </a>
<a name="4409"><span class="lineNum">    4409 </span>            :   // DQ (6/7/2013): Added support for the call to the experimental Fortran frontend (if the associated option is specified on the command line).</a>
<a name="4410"><span class="lineNum">    4410 </span><span class="lineCov">         37 :      int frontendErrorLevel = 0;</span></a>
<a name="4411"><span class="lineNum">    4411 </span><span class="lineCov">         37 :      if (get_experimental_fortran_frontend() == true || get_experimental_flang_frontend() == true)</span></a>
<a name="4412"><span class="lineNum">    4412 </span>            :         {</a>
<a name="4413"><span class="lineNum">    4413 </span><span class="lineNoCov">          0 :           vector&lt;string&gt; experimentalFrontEndCommandLine;</span></a>
<a name="4414"><span class="lineNum">    4414 </span>            : </a>
<a name="4415"><span class="lineNum">    4415 </span>            :        // Push an initial argument onto the command line stack so that the command line can be interpreted</a>
<a name="4416"><span class="lineNum">    4416 </span>            :        // as coming from an command shell command line (where the calling program is always argument zero).</a>
<a name="4417"><span class="lineNum">    4417 </span><span class="lineNoCov">          0 :           if (get_experimental_fortran_frontend() == true)</span></a>
<a name="4418"><span class="lineNum">    4418 </span>            :              {</a>
<a name="4419"><span class="lineNum">    4419 </span><span class="lineNoCov">          0 :                 experimentalFrontEndCommandLine.push_back(&quot;dummyArg_0&quot;);</span></a>
<a name="4420"><span class="lineNum">    4420 </span>            :              }</a>
<a name="4421"><span class="lineNum">    4421 </span>            :           else</a>
<a name="4422"><span class="lineNum">    4422 </span>            :              {</a>
<a name="4423"><span class="lineNum">    4423 </span><span class="lineNoCov">          0 :                 experimentalFrontEndCommandLine.push_back(&quot;f18&quot;);</span></a>
<a name="4424"><span class="lineNum">    4424 </span><span class="lineNoCov">          0 :                 experimentalFrontEndCommandLine.push_back(&quot;-fexternal-builder&quot;);</span></a>
<a name="4425"><span class="lineNum">    4425 </span>            :              }</a>
<a name="4426"><span class="lineNum">    4426 </span>            : </a>
<a name="4427"><span class="lineNum">    4427 </span>            :        // Rasmussen (11/13/2017): Removed usage of --parseTable command-line option.</a>
<a name="4428"><span class="lineNum">    4428 </span>            :        // This information is better known by the individual language support files.</a>
<a name="4429"><span class="lineNum">    4429 </span>            :        // Rasmussen (3/12/2018): Also removed usage of path_to_table for same reason.</a>
<a name="4430"><span class="lineNum">    4430 </span>            : </a>
<a name="4431"><span class="lineNum">    4431 </span><span class="lineNoCov">          0 :           experimentalFrontEndCommandLine.push_back(get_sourceFileNameWithPath());</span></a>
<a name="4432"><span class="lineNum">    4432 </span>            : </a>
<a name="4433"><span class="lineNum">    4433 </span><span class="lineNoCov">          0 :           int experimental_FortranParser_argc    = 0;</span></a>
<a name="4434"><span class="lineNum">    4434 </span><span class="lineNoCov">          0 :           char** experimental_FortranParser_argv = nullptr;</span></a>
<a name="4435"><span class="lineNum">    4435 </span><span class="lineNoCov">          0 :           CommandlineProcessing::generateArgcArgvFromList(experimentalFrontEndCommandLine,experimental_FortranParser_argc,experimental_FortranParser_argv);</span></a>
<a name="4436"><span class="lineNum">    4436 </span>            : </a>
<a name="4437"><span class="lineNum">    4437 </span><span class="lineNoCov">          0 :           if ( SgProject::get_verbose() &gt; 1 )</span></a>
<a name="4438"><span class="lineNum">    4438 </span>            :              {</a>
<a name="4439"><span class="lineNum">    4439 </span><span class="lineNoCov">          0 :                 printf (&quot;Calling the experimental fortran frontend (this work is incomplete) \n&quot;);</span></a>
<a name="4440"><span class="lineNum">    4440 </span><span class="lineNoCov">          0 :                 printf (&quot;   --- Fortran numberOfCommandLineArguments = %&quot; PRIuPTR &quot; frontEndCommandLine = %s \n&quot;,experimentalFrontEndCommandLine.size(),CommandlineProcessing::generateStringFromArgList(experimentalFrontEndCommandLine,false,false).c_str());</span></a>
<a name="4441"><span class="lineNum">    4441 </span>            :              }</a>
<a name="4442"><span class="lineNum">    4442 </span>            : </a>
<a name="4443"><span class="lineNum">    4443 </span>            : // Added ROSE_EXPERIMENTAL_FLANG_ROSE_CONNECTION. Note that they both use the same entrance to the parser.</a>
<a name="4444"><span class="lineNum">    4444 </span>            : // The two experimental Fortran versions should not be used at the same time [Rasmussen 2019.08.30]</a>
<a name="4445"><span class="lineNum">    4445 </span>            : #if defined(ROSE_EXPERIMENTAL_OFP_ROSE_CONNECTION) || defined(ROSE_EXPERIMENTAL_FLANG_ROSE_CONNECTION)</a>
<a name="4446"><span class="lineNum">    4446 </span>            :        // Rasmussen (3/12/2018): Modified call to include the source file.</a>
<a name="4447"><span class="lineNum">    4447 </span>            :           SgSourceFile* fortranSourceFile = const_cast&lt;SgSourceFile*&gt;(this);</a>
<a name="4448"><span class="lineNum">    4448 </span>            :           frontendErrorLevel = experimental_fortran_main (experimental_FortranParser_argc,</a>
<a name="4449"><span class="lineNum">    4449 </span>            :                                                           experimental_FortranParser_argv,</a>
<a name="4450"><span class="lineNum">    4450 </span>            :                                                           fortranSourceFile);</a>
<a name="4451"><span class="lineNum">    4451 </span>            : #else</a>
<a name="4452"><span class="lineNum">    4452 </span><span class="lineNoCov">          0 :           printf (&quot;Neither ROSE_EXPERIMENTAL_OFP_ROSE_CONNECTION nor ROSE_EXPERIMENTAL_FLANG_ROSE_CONNECTION is defined \n&quot;);</span></a>
<a name="4453"><span class="lineNum">    4453 </span>            : #endif</a>
<a name="4454"><span class="lineNum">    4454 </span>            : </a>
<a name="4455"><span class="lineNum">    4455 </span><span class="lineNoCov">          0 :           if (frontendErrorLevel == 0)</span></a>
<a name="4456"><span class="lineNum">    4456 </span>            :              {</a>
<a name="4457"><span class="lineNum">    4457 </span><span class="lineNoCov">          0 :                 if ( SgProject::get_verbose() &gt; 1 ) printf (&quot;SUCCESS with call to experimental_FortranParser_main() \n&quot;);</span></a>
<a name="4458"><span class="lineNum">    4458 </span>            :              }</a>
<a name="4459"><span class="lineNum">    4459 </span>            :             else</a>
<a name="4460"><span class="lineNum">    4460 </span>            :              {</a>
<a name="4461"><span class="lineNum">    4461 </span>            :                printf (&quot;Error returned from call to experimental_FortranParser_main(): FAILED! (frontendErrorLevel = %d) \n&quot;,frontendErrorLevel);</a>
<a name="4462"><span class="lineNum">    4462 </span>            :                exit(1);</a>
<a name="4463"><span class="lineNum">    4463 </span>            :              }</a>
<a name="4464"><span class="lineNum">    4464 </span>            :         }</a>
<a name="4465"><span class="lineNum">    4465 </span>            :        else</a>
<a name="4466"><span class="lineNum">    4466 </span>            :         {</a>
<a name="4467"><span class="lineNum">    4467 </span><span class="lineCov">         37 :           frontendErrorLevel = openFortranParser_main (openFortranParser_argc, openFortranParser_argv);</span></a>
<a name="4468"><span class="lineNum">    4468 </span>            :         }</a>
<a name="4469"><span class="lineNum">    4469 </span>            : </a>
<a name="4470"><span class="lineNum">    4470 </span>            : </a>
<a name="4471"><span class="lineNum">    4471 </span>            :   // DQ (11/11/2010): There should be no include files left in the stack, see test2010_78.C and test2010_79.C when</a>
<a name="4472"><span class="lineNum">    4472 </span>            :   // compiled together on the same command line.</a>
<a name="4473"><span class="lineNum">    4473 </span>            :   // ROSE_ASSERT(astIncludeStack.size() == 0);</a>
<a name="4474"><span class="lineNum">    4474 </span><span class="lineCov">         37 :      if (astIncludeStack.size() != 0)</span></a>
<a name="4475"><span class="lineNum">    4475 </span>            :         {</a>
<a name="4476"><span class="lineNum">    4476 </span>            :        // DQ (3/17/2017): Added support to use message streams.</a>
<a name="4477"><span class="lineNum">    4477 </span><span class="lineNoCov">          0 :           mprintf (&quot;Warning: astIncludeStack not cleaned up after openFortranParser_main(): astIncludeStack.size() = %&quot; PRIuPTR &quot; \n&quot;,astIncludeStack.size());</span></a>
<a name="4478"><span class="lineNum">    4478 </span>            :         }</a>
<a name="4479"><span class="lineNum">    4479 </span>            : #endif</a>
<a name="4480"><span class="lineNum">    4480 </span>            : </a>
<a name="4481"><span class="lineNum">    4481 </span><span class="lineCov">         37 :      if ( get_verbose() &gt; 1 )</span></a>
<a name="4482"><span class="lineNum">    4482 </span><span class="lineNoCov">          0 :           printf (&quot;DONE: Calling the openFortranParser_main() function (which loads the JVM) \n&quot;);</span></a>
<a name="4483"><span class="lineNum">    4483 </span>            : </a>
<a name="4484"><span class="lineNum">    4484 </span>            :   // Reset this global pointer after we are done (just to be safe and avoid it being used later and causing strange bugs).</a>
<a name="4485"><span class="lineNum">    4485 </span><span class="lineCov">         37 :      OpenFortranParser_globalFilePointer = nullptr;</span></a>
<a name="4486"><span class="lineNum">    4486 </span>            : </a>
<a name="4487"><span class="lineNum">    4487 </span>            :   // Now read the CPP directives such as &quot;# &lt;number&gt; &lt;filename&gt; &lt;optional numeric code&gt;&quot;, in the generated file from CPP.</a>
<a name="4488"><span class="lineNum">    4488 </span><span class="lineCov">         37 :      if (requires_C_preprocessor == true)</span></a>
<a name="4489"><span class="lineNum">    4489 </span>            :         {</a>
<a name="4490"><span class="lineNum">    4490 </span>            :        // If this was part of the processing of a CPP generated file then read the preprocessed file</a>
<a name="4491"><span class="lineNum">    4491 </span>            :        // to get the CPP directives (different from those of the original *.F?? file) which will</a>
<a name="4492"><span class="lineNum">    4492 </span>            :        // indicate line numbers and files where text was inserted as part of CPP processing.  We</a>
<a name="4493"><span class="lineNum">    4493 </span>            :        // mostly want to read CPP declarations of the form &quot;# &lt;number&gt; &lt;filename&gt; &lt;optional numeric code&gt;&quot;.</a>
<a name="4494"><span class="lineNum">    4494 </span>            :        // these are the only directives that will be in the CPP generated file (as I recall).</a>
<a name="4495"><span class="lineNum">    4495 </span>            : </a>
<a name="4496"><span class="lineNum">    4496 </span><span class="lineNoCov">          0 :           string sourceFilename              = get_sourceFileNameWithPath();</span></a>
<a name="4497"><span class="lineNum">    4497 </span><span class="lineNoCov">          0 :           string sourceFileNameOutputFromCpp = generate_C_preprocessor_intermediate_filename(sourceFilename);</span></a>
<a name="4498"><span class="lineNum">    4498 </span>            : #if 0</a>
<a name="4499"><span class="lineNum">    4499 </span>            :           printf (&quot;Need to preprocess the CPP generated fortran file so that we can attribute source code statements to files: sourceFileNameOutputFromCpp = %s \n&quot;,sourceFileNameOutputFromCpp.c_str());</a>
<a name="4500"><span class="lineNum">    4500 </span>            : #endif</a>
<a name="4501"><span class="lineNum">    4501 </span>            : #if 1</a>
<a name="4502"><span class="lineNum">    4502 </span>            :        // Note that the collection of CPP linemarker directives from the CPP generated file</a>
<a name="4503"><span class="lineNum">    4503 </span>            :        // (and their insertion into the AST), should be done before the collection and</a>
<a name="4504"><span class="lineNum">    4504 </span>            :        // insertion of the Comments and more general CPP directives from the original source</a>
<a name="4505"><span class="lineNum">    4505 </span>            :        // file and their insertion. This will allow the correct representation of source</a>
<a name="4506"><span class="lineNum">    4506 </span>            :        // position information to be used in the final insertion of comments and CPP directives</a>
<a name="4507"><span class="lineNum">    4507 </span>            :        // from the original file.</a>
<a name="4508"><span class="lineNum">    4508 </span>            : </a>
<a name="4509"><span class="lineNum">    4509 </span>            : #if 0</a>
<a name="4510"><span class="lineNum">    4510 </span>            :        // DQ (12/19/2008): This is now done by the AttachPreprocessingInfoTreeTrav</a>
<a name="4511"><span class="lineNum">    4511 </span>            : </a>
<a name="4512"><span class="lineNum">    4512 </span>            :        // List of all comments and CPP directives (collected from the generated CPP file so that we can collect the</a>
<a name="4513"><span class="lineNum">    4513 </span>            :        // CPP directives that indicate source file boundaries of included regions of source code.</a>
<a name="4514"><span class="lineNum">    4514 </span>            :        // E.g. # 42 &quot;foobar.f&quot; 2</a>
<a name="4515"><span class="lineNum">    4515 </span>            :           ROSEAttributesList* currentListOfAttributes = new ROSEAttributesList();</a>
<a name="4516"><span class="lineNum">    4516 </span>            :           ASSERT_not_null(currentListOfAttributes);</a>
<a name="4517"><span class="lineNum">    4517 </span>            : </a>
<a name="4518"><span class="lineNum">    4518 </span>            :        // DQ (11/28/2008): This will collect the CPP directives from the generated CPP file so that</a>
<a name="4519"><span class="lineNum">    4519 </span>            :        // we can associate parts of the AST included from different files with the correct file.</a>
<a name="4520"><span class="lineNum">    4520 </span>            :        // Without this processing all the parts of the AST will be associated with the same generated file.</a>
<a name="4521"><span class="lineNum">    4521 </span>            :           currentListOfAttributes-&gt;collectPreprocessorDirectivesAndCommentsForAST(sourceFileNameOutputFromCpp,ROSEAttributesList::e_C_language);</a>
<a name="4522"><span class="lineNum">    4522 </span>            : #endif</a>
<a name="4523"><span class="lineNum">    4523 </span>            : </a>
<a name="4524"><span class="lineNum">    4524 </span>            : #if 0</a>
<a name="4525"><span class="lineNum">    4525 </span>            :           printf (&quot;Secondary pass over Fortran source file = %s to comment comments and CPP directives (might still be referencing the original source file) \n&quot;,sourceFileNameOutputFromCpp.c_str());</a>
<a name="4526"><span class="lineNum">    4526 </span>            :           printf (&quot;Calling attachPreprocessingInfo() \n&quot;);</a>
<a name="4527"><span class="lineNum">    4527 </span>            : #endif</a>
<a name="4528"><span class="lineNum">    4528 </span>            : </a>
<a name="4529"><span class="lineNum">    4529 </span><span class="lineNoCov">          0 :           attachPreprocessingInfo(this);</span></a>
<a name="4530"><span class="lineNum">    4530 </span>            : </a>
<a name="4531"><span class="lineNum">    4531 </span>            : #if 0</a>
<a name="4532"><span class="lineNum">    4532 </span>            :           printf (&quot;DONE: calling attachPreprocessingInfo() \n&quot;);</a>
<a name="4533"><span class="lineNum">    4533 </span>            : #endif</a>
<a name="4534"><span class="lineNum">    4534 </span>            : </a>
<a name="4535"><span class="lineNum">    4535 </span>            :        // DQ (12/19/2008): Now we have to do an analysis of the AST to interpret the linemarkers.</a>
<a name="4536"><span class="lineNum">    4536 </span><span class="lineNoCov">          0 :           processCppLinemarkers();</span></a>
<a name="4537"><span class="lineNum">    4537 </span>            : </a>
<a name="4538"><span class="lineNum">    4538 </span>            : #endif</a>
<a name="4539"><span class="lineNum">    4539 </span>            : #if 0</a>
<a name="4540"><span class="lineNum">    4540 </span>            :           printf (&quot;Exiting as a test ... (collect the CPP directives from the CPP generated file after building the AST)\n&quot;);</a>
<a name="4541"><span class="lineNum">    4541 </span>            :           ROSE_ABORT();</a>
<a name="4542"><span class="lineNum">    4542 </span>            : #endif</a>
<a name="4543"><span class="lineNum">    4543 </span>            :         }</a>
<a name="4544"><span class="lineNum">    4544 </span>            : </a>
<a name="4545"><span class="lineNum">    4545 </span>            :   // printf (&quot;######################### Leaving SgSourceFile::build_Fortran_AST() ############################ \n&quot;);</a>
<a name="4546"><span class="lineNum">    4546 </span>            : </a>
<a name="4547"><span class="lineNum">    4547 </span>            : </a>
<a name="4548"><span class="lineNum">    4548 </span>            :   // DQ (10/26/2010): Moved from SgSourceFile::callFrontEnd() so that the stack will</a>
<a name="4549"><span class="lineNum">    4549 </span>            :   // be empty when processing Java language support (not Fortran).</a>
<a name="4550"><span class="lineNum">    4550 </span><span class="lineCov">         37 :      delete  currStks;</span></a>
<a name="4551"><span class="lineNum">    4551 </span><span class="lineCov">         37 :      currStks = nullptr;</span></a>
<a name="4552"><span class="lineNum">    4552 </span>            : </a>
<a name="4553"><span class="lineNum">    4553 </span><span class="lineCov">         37 :      return frontendErrorLevel;</span></a>
<a name="4554"><span class="lineNum">    4554 </span>            : #else</a>
<a name="4555"><span class="lineNum">    4555 </span>            :      fprintf(stderr, &quot;Fortran parser not supported \n&quot;);</a>
<a name="4556"><span class="lineNum">    4556 </span>            :      ROSE_ABORT();</a>
<a name="4557"><span class="lineNum">    4557 </span>            : #endif</a>
<a name="4558"><span class="lineNum">    4558 </span>            :    }</a>
<a name="4559"><span class="lineNum">    4559 </span>            : </a>
<a name="4560"><span class="lineNum">    4560 </span>            : //-----------------------------------------------------------------------------</a>
<a name="4561"><span class="lineNum">    4561 </span>            : // Rose::Frontend</a>
<a name="4562"><span class="lineNum">    4562 </span>            : //-----------------------------------------------------------------------------</a>
<a name="4563"><span class="lineNum">    4563 </span>            : </a>
<a name="4564"><span class="lineNum">    4564 </span>            : int</a>
<a name="4565"><span class="lineNum">    4565 </span><span class="lineCov">        352 : Rose::Frontend::Run(SgProject* project)</span></a>
<a name="4566"><span class="lineNum">    4566 </span>            : {</a>
<a name="4567"><span class="lineNum">    4567 </span><span class="lineCov">        352 :   ASSERT_not_null(project);</span></a>
<a name="4568"><span class="lineNum">    4568 </span>            : </a>
<a name="4569"><span class="lineNum">    4569 </span><span class="lineCov">        352 :   int status = 0;</span></a>
<a name="4570"><span class="lineNum">    4570 </span><span class="lineCov">        352 :   {</span></a>
<a name="4571"><span class="lineNum">    4571 </span><span class="lineCov">        352 :       status = Rose::Frontend::RunSerial(project);</span></a>
<a name="4572"><span class="lineNum">    4572 </span>            : </a>
<a name="4573"><span class="lineNum">    4573 </span><span class="lineCov">        352 :       project-&gt;set_frontendErrorCode(status);</span></a>
<a name="4574"><span class="lineNum">    4574 </span>            :   }</a>
<a name="4575"><span class="lineNum">    4575 </span>            : </a>
<a name="4576"><span class="lineNum">    4576 </span><span class="lineCov">        352 :   return status;</span></a>
<a name="4577"><span class="lineNum">    4577 </span>            : } // Rose::Frontend::Run</a>
<a name="4578"><span class="lineNum">    4578 </span>            : </a>
<a name="4579"><span class="lineNum">    4579 </span>            : int</a>
<a name="4580"><span class="lineNum">    4580 </span><span class="lineCov">        352 : Rose::Frontend::RunSerial(SgProject* project)</span></a>
<a name="4581"><span class="lineNum">    4581 </span>            : {</a>
<a name="4582"><span class="lineNum">    4582 </span><span class="lineCov">        352 :   if (SgProject::get_verbose() &gt; 0)</span></a>
<a name="4583"><span class="lineNum">    4583 </span><span class="lineNoCov">          0 :       std::cout &lt;&lt; &quot;[INFO] [Frontend] Running in serial mode&quot; &lt;&lt; std::endl;</span></a>
<a name="4584"><span class="lineNum">    4584 </span>            : </a>
<a name="4585"><span class="lineNum">    4585 </span><span class="lineCov">        352 :   int status_of_function = 0;</span></a>
<a name="4586"><span class="lineNum">    4586 </span>            : </a>
<a name="4587"><span class="lineNum">    4587 </span><span class="lineCov">        352 :   std::vector&lt;SgFile*&gt; all_files = project-&gt;get_fileList();</span></a>
<a name="4588"><span class="lineNum">    4588 </span><span class="lineCov">        352 :   {</span></a>
<a name="4589"><span class="lineNum">    4589 </span><span class="lineCov">        352 :       int status_of_file = 0;</span></a>
<a name="4590"><span class="lineNum">    4590 </span><span class="lineCov">        705 :       for (SgFile* file : all_files)</span></a>
<a name="4591"><span class="lineNum">    4591 </span>            :       {</a>
<a name="4592"><span class="lineNum">    4592 </span><span class="lineCov">        353 :           ASSERT_not_null(file);</span></a>
<a name="4593"><span class="lineNum">    4593 </span><span class="lineCov">        353 :           if (KEEP_GOING_CAUGHT_FRONTEND_SIGNAL)</span></a>
<a name="4594"><span class="lineNum">    4594 </span>            :           {</a>
<a name="4595"><span class="lineNum">    4595 </span><span class="lineNoCov">          0 :               std::cout</span></a>
<a name="4596"><span class="lineNum">    4596 </span>            :                   &lt;&lt; &quot;[WARN] &quot;</a>
<a name="4597"><span class="lineNum">    4597 </span>            :                   &lt;&lt; &quot;Configured to keep going after catching a &quot;</a>
<a name="4598"><span class="lineNum">    4598 </span><span class="lineNoCov">          0 :                   &lt;&lt; &quot;signal in SgFile::RunFrontend()&quot;</span></a>
<a name="4599"><span class="lineNum">    4599 </span><span class="lineNoCov">          0 :                   &lt;&lt; std::endl;</span></a>
<a name="4600"><span class="lineNum">    4600 </span>            : </a>
<a name="4601"><span class="lineNum">    4601 </span><span class="lineNoCov">          0 :               if (file != nullptr)</span></a>
<a name="4602"><span class="lineNum">    4602 </span>            :               {</a>
<a name="4603"><span class="lineNum">    4603 </span><span class="lineNoCov">          0 :                   file-&gt;set_frontendErrorCode(100);</span></a>
<a name="4604"><span class="lineNum">    4604 </span><span class="lineNoCov">          0 :                   status_of_function =</span></a>
<a name="4605"><span class="lineNum">    4605 </span><span class="lineNoCov">          0 :                       std::max(100, status_of_function);</span></a>
<a name="4606"><span class="lineNum">    4606 </span>            :               }</a>
<a name="4607"><span class="lineNum">    4607 </span>            :               else</a>
<a name="4608"><span class="lineNum">    4608 </span>            :               {</a>
<a name="4609"><span class="lineNum">    4609 </span><span class="lineNoCov">          0 :                   std::cout</span></a>
<a name="4610"><span class="lineNum">    4610 </span>            :                       &lt;&lt; &quot;[FATAL] &quot;</a>
<a name="4611"><span class="lineNum">    4611 </span><span class="lineNoCov">          0 :                       &lt;&lt; &quot;Unable to keep going due to an unrecoverable internal error&quot;</span></a>
<a name="4612"><span class="lineNum">    4612 </span><span class="lineNoCov">          0 :                       &lt;&lt; std::endl;</span></a>
<a name="4613"><span class="lineNum">    4613 </span><span class="lineNoCov">          0 :                   exit(1);</span></a>
<a name="4614"><span class="lineNum">    4614 </span>            :               }</a>
<a name="4615"><span class="lineNum">    4615 </span>            :           }</a>
<a name="4616"><span class="lineNum">    4616 </span>            :           else</a>
<a name="4617"><span class="lineNum">    4617 </span>            :           {</a>
<a name="4618"><span class="lineNum">    4618 </span>            : #if 0</a>
<a name="4619"><span class="lineNum">    4619 </span>            :            // DQ (9/5/2014): I sometimes need to avoid the try catch mechanism for debugging</a>
<a name="4620"><span class="lineNum">    4620 </span>            :            // (allows better use of gdb since traces on exceptions are not supported).</a>
<a name="4621"><span class="lineNum">    4621 </span>            :               printf (&quot;In Rose::Frontend::RunSerial(): Skipping try...catch mechanism in call to file-&gt;runFrontend(status_of_file); \n&quot;);</a>
<a name="4622"><span class="lineNum">    4622 </span>            :               file-&gt;runFrontend(status_of_file);</a>
<a name="4623"><span class="lineNum">    4623 </span>            : #else</a>
<a name="4624"><span class="lineNum">    4624 </span>            : #if 0</a>
<a name="4625"><span class="lineNum">    4625 </span>            :               try</a>
<a name="4626"><span class="lineNum">    4626 </span>            :               {</a>
<a name="4627"><span class="lineNum">    4627 </span>            :                   //-----------------------------------------------------------</a>
<a name="4628"><span class="lineNum">    4628 </span>            :                   // Pass File to Frontend</a>
<a name="4629"><span class="lineNum">    4629 </span>            :                   //-----------------------------------------------------------</a>
<a name="4630"><span class="lineNum">    4630 </span>            :                   file-&gt;runFrontend(status_of_file);</a>
<a name="4631"><span class="lineNum">    4631 </span>            :                   {</a>
<a name="4632"><span class="lineNum">    4632 </span>            :                       status_of_function =</a>
<a name="4633"><span class="lineNum">    4633 </span>            :                           max(status_of_file, status_of_function);</a>
<a name="4634"><span class="lineNum">    4634 </span>            :                   }</a>
<a name="4635"><span class="lineNum">    4635 </span>            :               }</a>
<a name="4636"><span class="lineNum">    4636 </span>            :               catch(...)</a>
<a name="4637"><span class="lineNum">    4637 </span>            :               {</a>
<a name="4638"><span class="lineNum">    4638 </span>            :                   if (file != nullptr)</a>
<a name="4639"><span class="lineNum">    4639 </span>            :                   {</a>
<a name="4640"><span class="lineNum">    4640 </span>            :                      file-&gt;set_frontendErrorCode(100);</a>
<a name="4641"><span class="lineNum">    4641 </span>            :                   }</a>
<a name="4642"><span class="lineNum">    4642 </span>            :                   else</a>
<a name="4643"><span class="lineNum">    4643 </span>            :                   {</a>
<a name="4644"><span class="lineNum">    4644 </span>            :                       std::cout</a>
<a name="4645"><span class="lineNum">    4645 </span>            :                           &lt;&lt; &quot;[FATAL] &quot;</a>
<a name="4646"><span class="lineNum">    4646 </span>            :                           &lt;&lt; &quot;Unable to keep going due to an unrecoverable internal error&quot;</a>
<a name="4647"><span class="lineNum">    4647 </span>            :                           &lt;&lt; std::endl;</a>
<a name="4648"><span class="lineNum">    4648 </span>            :                       exit(1);</a>
<a name="4649"><span class="lineNum">    4649 </span>            :                   }</a>
<a name="4650"><span class="lineNum">    4650 </span>            :               }</a>
<a name="4651"><span class="lineNum">    4651 </span>            : #endif</a>
<a name="4652"><span class="lineNum">    4652 </span>            :               //-----------------------------------------------------------</a>
<a name="4653"><span class="lineNum">    4653 </span>            :               // Pass File to Frontend. Avoid using try/catch/re-throw if not necessary because it interferes with debugging</a>
<a name="4654"><span class="lineNum">    4654 </span>            :               // the exception (it makes it hard to find where the exception was originally thrown).  Also, no need to print a</a>
<a name="4655"><span class="lineNum">    4655 </span>            :               // fatal message to std::cout(!) if the exception inherits from the STL properly since the C++ runtime will do</a>
<a name="4656"><span class="lineNum">    4656 </span>            :               // all that for us. [Robb P. Matzke 2015-01-07]</a>
<a name="4657"><span class="lineNum">    4657 </span>            :               //-----------------------------------------------------------</a>
<a name="4658"><span class="lineNum">    4658 </span><span class="lineCov">        353 :               if (Rose::KeepGoing::g_keep_going) {</span></a>
<a name="4659"><span class="lineNum">    4659 </span><span class="lineNoCov">          0 :                   try {</span></a>
<a name="4660"><span class="lineNum">    4660 </span><span class="lineNoCov">          0 :                       file-&gt;runFrontend(status_of_file);</span></a>
<a name="4661"><span class="lineNum">    4661 </span><span class="lineNoCov">          0 :                       status_of_function = max(status_of_file, status_of_function);</span></a>
<a name="4662"><span class="lineNum">    4662 </span><span class="lineNoCov">          0 :                   } catch (...) {</span></a>
<a name="4663"><span class="lineNum">    4663 </span><span class="lineNoCov">          0 :                       if (file != nullptr) {</span></a>
<a name="4664"><span class="lineNum">    4664 </span><span class="lineNoCov">          0 :                          file-&gt;set_frontendErrorCode(100);</span></a>
<a name="4665"><span class="lineNum">    4665 </span>            :                       } else {</a>
<a name="4666"><span class="lineNum">    4666 </span><span class="lineNoCov">          0 :                           std::cout</span></a>
<a name="4667"><span class="lineNum">    4667 </span>            :                               &lt;&lt; &quot;[FATAL] &quot;</a>
<a name="4668"><span class="lineNum">    4668 </span><span class="lineNoCov">          0 :                               &lt;&lt; &quot;Unable to keep going due to an unrecoverable internal error&quot;</span></a>
<a name="4669"><span class="lineNum">    4669 </span><span class="lineNoCov">          0 :                               &lt;&lt; std::endl;</span></a>
<a name="4670"><span class="lineNum">    4670 </span><span class="lineNoCov">          0 :                           exit(1);</span></a>
<a name="4671"><span class="lineNum">    4671 </span>            :                       }</a>
<a name="4672"><span class="lineNum">    4672 </span><span class="lineNoCov">          0 :                       raise(SIGABRT); // catch with signal handling above</span></a>
<a name="4673"><span class="lineNum">    4673 </span>            :                   }</a>
<a name="4674"><span class="lineNum">    4674 </span>            :               } else {</a>
<a name="4675"><span class="lineNum">    4675 </span>            :                   // Same thing but without the try/catch because we want the exception to be propagated all the way to the</a>
<a name="4676"><span class="lineNum">    4676 </span>            :                   // user without us re-throwing it and interfering with debugging.</a>
<a name="4677"><span class="lineNum">    4677 </span><span class="lineCov">        353 :                   file-&gt;runFrontend(status_of_file);</span></a>
<a name="4678"><span class="lineNum">    4678 </span><span class="lineCov">        353 :                   status_of_function = max(status_of_file, status_of_function);</span></a>
<a name="4679"><span class="lineNum">    4679 </span>            :               }</a>
<a name="4680"><span class="lineNum">    4680 </span>            : #endif</a>
<a name="4681"><span class="lineNum">    4681 </span>            :           }</a>
<a name="4682"><span class="lineNum">    4682 </span>            :       }//BOOST_FOREACH</a>
<a name="4683"><span class="lineNum">    4683 </span>            :   }//all_files-&gt;callFrontEnd</a>
<a name="4684"><span class="lineNum">    4684 </span>            : </a>
<a name="4685"><span class="lineNum">    4685 </span><span class="lineCov">        352 :   ASSERT_not_null(project);</span></a>
<a name="4686"><span class="lineNum">    4686 </span>            : </a>
<a name="4687"><span class="lineNum">    4687 </span><span class="lineCov">        352 :   project-&gt;set_frontendErrorCode(status_of_function);</span></a>
<a name="4688"><span class="lineNum">    4688 </span>            : </a>
<a name="4689"><span class="lineNum">    4689 </span><span class="lineCov">        704 :   return status_of_function;</span></a>
<a name="4690"><span class="lineNum">    4690 </span>            : } // Rose::Frontend::RunSerial</a>
<a name="4691"><span class="lineNum">    4691 </span>            : </a>
<a name="4692"><span class="lineNum">    4692 </span>            : namespace SgSourceFile_processCppLinemarkers</a>
<a name="4693"><span class="lineNum">    4693 </span>            :    {</a>
<a name="4694"><span class="lineNum">    4694 </span>            :   // This class (AST traversal) supports the traversal of the AST required</a>
<a name="4695"><span class="lineNum">    4695 </span>            :   // to translate the source position using the CPP linemarkers.</a>
<a name="4696"><span class="lineNum">    4696 </span>            : </a>
<a name="4697"><span class="lineNum">    4697 </span>            :      class LinemarkerTraversal : public AstSimpleProcessing</a>
<a name="4698"><span class="lineNum">    4698 </span>            :         {</a>
<a name="4699"><span class="lineNum">    4699 </span>            :           public:</a>
<a name="4700"><span class="lineNum">    4700 </span>            :            // list&lt;PreprocessingInfo*&gt; preprocessingInfoStack;</a>
<a name="4701"><span class="lineNum">    4701 </span>            :               list&lt; pair&lt;int,int&gt; &gt; sourcePositionStack;</a>
<a name="4702"><span class="lineNum">    4702 </span>            : </a>
<a name="4703"><span class="lineNum">    4703 </span>            :               LinemarkerTraversal( const string &amp; sourceFilename );</a>
<a name="4704"><span class="lineNum">    4704 </span>            : </a>
<a name="4705"><span class="lineNum">    4705 </span>            :               void visit ( SgNode* astNode );</a>
<a name="4706"><span class="lineNum">    4706 </span>            :         };</a>
<a name="4707"><span class="lineNum">    4707 </span>            :    }</a>
<a name="4708"><span class="lineNum">    4708 </span>            : </a>
<a name="4709"><span class="lineNum">    4709 </span>            : </a>
<a name="4710"><span class="lineNum">    4710 </span><span class="lineNoCov">          0 : SgSourceFile_processCppLinemarkers::LinemarkerTraversal::LinemarkerTraversal( const string &amp; sourceFilename )</span></a>
<a name="4711"><span class="lineNum">    4711 </span>            :    {</a>
<a name="4712"><span class="lineNum">    4712 </span>            :   // Build an initial element on the stack so that the original source file name will be used to</a>
<a name="4713"><span class="lineNum">    4713 </span>            :   // set the global scope (which will be traversed before we visit any statements that might have</a>
<a name="4714"><span class="lineNum">    4714 </span>            :   // CPP directives attached (or which are CPP direcitve IR nodes).</a>
<a name="4715"><span class="lineNum">    4715 </span>            : </a>
<a name="4716"><span class="lineNum">    4716 </span>            :   // Get the fileId of the assocated filename</a>
<a name="4717"><span class="lineNum">    4717 </span><span class="lineNoCov">          0 :      int fileId = Sg_File_Info::getIDFromFilename(sourceFilename);</span></a>
<a name="4718"><span class="lineNum">    4718 </span>            : </a>
<a name="4719"><span class="lineNum">    4719 </span>            :   // Assume this is line 1 (I forget why zero is not a great idea here,</a>
<a name="4720"><span class="lineNum">    4720 </span>            :   // I expect that it causes a consstancy test to fail somewhere).</a>
<a name="4721"><span class="lineNum">    4721 </span><span class="lineNoCov">          0 :      int line = 1;</span></a>
<a name="4722"><span class="lineNum">    4722 </span>            : </a>
<a name="4723"><span class="lineNum">    4723 </span><span class="lineNoCov">          0 :      if ( SgProject::get_verbose() &gt; 1 )</span></a>
<a name="4724"><span class="lineNum">    4724 </span><span class="lineNoCov">          0 :           printf (&quot;In LinemarkerTraversal::LinemarkerTraversal(): Push initial stack entry for line = %d fileId = %d sourceFilename = %s \n&quot;,line,fileId,sourceFilename.c_str());</span></a>
<a name="4725"><span class="lineNum">    4725 </span>            : </a>
<a name="4726"><span class="lineNum">    4726 </span>            :   // Push an entry onto the stack before doing the traversal over the whole AST.</a>
<a name="4727"><span class="lineNum">    4727 </span><span class="lineNoCov">          0 :      sourcePositionStack.push_front( pair&lt;int,int&gt;(line,fileId) );</span></a>
<a name="4728"><span class="lineNum">    4728 </span><span class="lineNoCov">          0 :    }</span></a>
<a name="4729"><span class="lineNum">    4729 </span>            : </a>
<a name="4730"><span class="lineNum">    4730 </span>            : </a>
<a name="4731"><span class="lineNum">    4731 </span>            : #ifdef ROSE_BUILD_FORTRAN_LANGUAGE_SUPPORT</a>
<a name="4732"><span class="lineNum">    4732 </span>            :      extern SgSourceFile* OpenFortranParser_globalFilePointer;</a>
<a name="4733"><span class="lineNum">    4733 </span>            : #endif</a>
<a name="4734"><span class="lineNum">    4734 </span>            : </a>
<a name="4735"><span class="lineNum">    4735 </span>            : void</a>
<a name="4736"><span class="lineNum">    4736 </span><span class="lineNoCov">          0 : SgSourceFile_processCppLinemarkers::LinemarkerTraversal::visit ( SgNode* astNode )</span></a>
<a name="4737"><span class="lineNum">    4737 </span>            :    {</a>
<a name="4738"><span class="lineNum">    4738 </span>            : #ifdef ROSE_BUILD_FORTRAN_LANGUAGE_SUPPORT</a>
<a name="4739"><span class="lineNum">    4739 </span>            : </a>
<a name="4740"><span class="lineNum">    4740 </span>            :     // DXN (02/21/2011): Consider the case of SgInterfaceBody.</a>
<a name="4741"><span class="lineNum">    4741 </span>            :     // TODO: revise SgInterfaceBody::get_numberOfTraversalSuccessor() to return 1 and</a>
<a name="4742"><span class="lineNum">    4742 </span>            :     // TODO: revise SgInterfaceBody::get_traversalSuccessorByIndex(int ) to return p_functionDeclaration</a>
<a name="4743"><span class="lineNum">    4743 </span>            :     // Such changes will require some re-write of the code to build SgInterfaceBody.</a>
<a name="4744"><span class="lineNum">    4744 </span>            :     // With such changes, the patch below to treat the case of SgInterfaceBody will no longer be necessary.</a>
<a name="4745"><span class="lineNum">    4745 </span><span class="lineNoCov">          0 :      SgInterfaceBody* interfaceBody = isSgInterfaceBody(astNode);</span></a>
<a name="4746"><span class="lineNum">    4746 </span><span class="lineNoCov">          0 :      if (interfaceBody)</span></a>
<a name="4747"><span class="lineNum">    4747 </span>            :         {</a>
<a name="4748"><span class="lineNum">    4748 </span><span class="lineNoCov">          0 :           AstSimpleProcessing::traverse(interfaceBody-&gt;get_functionDeclaration(), preorder);</span></a>
<a name="4749"><span class="lineNum">    4749 </span>            :         }</a>
<a name="4750"><span class="lineNum">    4750 </span>            : </a>
<a name="4751"><span class="lineNum">    4751 </span><span class="lineNoCov">          0 :      SgStatement* statement = isSgStatement(astNode);</span></a>
<a name="4752"><span class="lineNum">    4752 </span>            :   // printf (&quot;LinemarkerTraversal::visit(): statement = %p = %s \n&quot;,statement,(statement != nullptr) ? statement-&gt;class_name().c_str() : &quot;NULL&quot;);</a>
<a name="4753"><span class="lineNum">    4753 </span><span class="lineNoCov">          0 :      if (statement != nullptr)</span></a>
<a name="4754"><span class="lineNum">    4754 </span>            :         {</a>
<a name="4755"><span class="lineNum">    4755 </span><span class="lineNoCov">          0 :           if ( SgProject::get_verbose() &gt; 1 )</span></a>
<a name="4756"><span class="lineNum">    4756 </span><span class="lineNoCov">          0 :                printf (&quot;LinemarkerTraversal::visit(): statement = %p = %s \n&quot;,statement,statement-&gt;class_name().c_str());</span></a>
<a name="4757"><span class="lineNum">    4757 </span>            : </a>
<a name="4758"><span class="lineNum">    4758 </span><span class="lineNoCov">          0 :           AttachedPreprocessingInfoType *commentOrDirectiveList = statement-&gt;getAttachedPreprocessingInfo();</span></a>
<a name="4759"><span class="lineNum">    4759 </span>            : </a>
<a name="4760"><span class="lineNum">    4760 </span><span class="lineNoCov">          0 :           if ( SgProject::get_verbose() &gt; 1 )</span></a>
<a name="4761"><span class="lineNum">    4761 </span><span class="lineNoCov">          0 :                printf (&quot;LinemarkerTraversal::visit(): commentOrDirectiveList = %p (size = %&quot; PRIuPTR &quot;) \n&quot;,commentOrDirectiveList,(commentOrDirectiveList != NULL) ? commentOrDirectiveList-&gt;size() : 0);</span></a>
<a name="4762"><span class="lineNum">    4762 </span>            : </a>
<a name="4763"><span class="lineNum">    4763 </span><span class="lineNoCov">          0 :           if (commentOrDirectiveList != nullptr)</span></a>
<a name="4764"><span class="lineNum">    4764 </span>            :              {</a>
<a name="4765"><span class="lineNum">    4765 </span><span class="lineNoCov">          0 :                AttachedPreprocessingInfoType::iterator i = commentOrDirectiveList-&gt;begin();</span></a>
<a name="4766"><span class="lineNum">    4766 </span><span class="lineNoCov">          0 :                while(i != commentOrDirectiveList-&gt;end())</span></a>
<a name="4767"><span class="lineNum">    4767 </span>            :                   {</a>
<a name="4768"><span class="lineNum">    4768 </span><span class="lineNoCov">          0 :                     if ( (*i)-&gt;getTypeOfDirective() == PreprocessingInfo::CpreprocessorCompilerGeneratedLinemarker )</span></a>
<a name="4769"><span class="lineNum">    4769 </span>            :                        {</a>
<a name="4770"><span class="lineNum">    4770 </span>            :                       // This is a CPP linemarker</a>
<a name="4771"><span class="lineNum">    4771 </span><span class="lineNoCov">          0 :                          int line = (*i)-&gt;get_lineNumberForCompilerGeneratedLinemarker();</span></a>
<a name="4772"><span class="lineNum">    4772 </span>            : </a>
<a name="4773"><span class="lineNum">    4773 </span>            :                       // DQ (12/23/2008): Note this is a quoted name, we need the unquoted version!</a>
<a name="4774"><span class="lineNum">    4774 </span><span class="lineNoCov">          0 :                          std::string quotedFilename = (*i)-&gt;get_filenameForCompilerGeneratedLinemarker();</span></a>
<a name="4775"><span class="lineNum">    4775 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(quotedFilename[0] == '\&quot;');</span></a>
<a name="4776"><span class="lineNum">    4776 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(quotedFilename[quotedFilename.length()-1] == '\&quot;');</span></a>
<a name="4777"><span class="lineNum">    4777 </span><span class="lineNoCov">          0 :                          std::string filename = quotedFilename.substr(1,quotedFilename.length()-2);</span></a>
<a name="4778"><span class="lineNum">    4778 </span>            : </a>
<a name="4779"><span class="lineNum">    4779 </span><span class="lineNoCov">          0 :                          std::string options  = (*i)-&gt;get_optionalflagsForCompilerGeneratedLinemarker();</span></a>
<a name="4780"><span class="lineNum">    4780 </span>            : </a>
<a name="4781"><span class="lineNum">    4781 </span>            :                       // Add the new filename to the static map stored in the Sg_File_Info (no action if filename is already in the map).</a>
<a name="4782"><span class="lineNum">    4782 </span><span class="lineNoCov">          0 :                          Sg_File_Info::addFilenameToMap(filename);</span></a>
<a name="4783"><span class="lineNum">    4783 </span>            : </a>
<a name="4784"><span class="lineNum">    4784 </span><span class="lineNoCov">          0 :                          int fileId = Sg_File_Info::getIDFromFilename(filename);</span></a>
<a name="4785"><span class="lineNum">    4785 </span>            : </a>
<a name="4786"><span class="lineNum">    4786 </span><span class="lineNoCov">          0 :                          if ( SgProject::get_verbose() &gt; 1 )</span></a>
<a name="4787"><span class="lineNum">    4787 </span><span class="lineNoCov">          0 :                               printf (&quot;line = %d fileId = %d quotedFilename = %s filename = %s options = %s \n&quot;,line,fileId,quotedFilename.c_str(),filename.c_str(),options.c_str());</span></a>
<a name="4788"><span class="lineNum">    4788 </span>            : </a>
<a name="4789"><span class="lineNum">    4789 </span>            :                       // Just record the first linemarker so that we can test getting the filename correct.</a>
<a name="4790"><span class="lineNum">    4790 </span><span class="lineNoCov">          0 :                          if (line == 1 &amp;&amp; sourcePositionStack.empty() == true)</span></a>
<a name="4791"><span class="lineNum">    4791 </span>            :                             {</a>
<a name="4792"><span class="lineNum">    4792 </span><span class="lineNoCov">          0 :                               sourcePositionStack.push_front( pair&lt;int,int&gt;(line,fileId) );</span></a>
<a name="4793"><span class="lineNum">    4793 </span>            :                             }</a>
<a name="4794"><span class="lineNum">    4794 </span>            :                        }</a>
<a name="4795"><span class="lineNum">    4795 </span>            : </a>
<a name="4796"><span class="lineNum">    4796 </span><span class="lineNoCov">          0 :                     i++;</span></a>
<a name="4797"><span class="lineNum">    4797 </span>            :                   }</a>
<a name="4798"><span class="lineNum">    4798 </span>            :              }</a>
<a name="4799"><span class="lineNum">    4799 </span>            : </a>
<a name="4800"><span class="lineNum">    4800 </span>            :        // ROSE_ASSERT(sourcePositionStack.empty() == false);</a>
<a name="4801"><span class="lineNum">    4801 </span><span class="lineNoCov">          0 :           if (sourcePositionStack.empty() == false)</span></a>
<a name="4802"><span class="lineNum">    4802 </span>            :              {</a>
<a name="4803"><span class="lineNum">    4803 </span><span class="lineNoCov">          0 :                int line   = sourcePositionStack.front().first;</span></a>
<a name="4804"><span class="lineNum">    4804 </span><span class="lineNoCov">          0 :                int fileId = sourcePositionStack.front().second;</span></a>
<a name="4805"><span class="lineNum">    4805 </span>            : </a>
<a name="4806"><span class="lineNum">    4806 </span><span class="lineNoCov">          0 :                if ( SgProject::get_verbose() &gt; 1 )</span></a>
<a name="4807"><span class="lineNum">    4807 </span><span class="lineNoCov">          0 :                     printf (&quot;Setting the source position of statement = %p = %s to line = %d fileId = %d \n&quot;,statement,statement-&gt;class_name().c_str(),line,fileId);</span></a>
<a name="4808"><span class="lineNum">    4808 </span>            : </a>
<a name="4809"><span class="lineNum">    4809 </span>            :             // DXN (02/18/2011): only reset the file id for the node whose file id corresponds to the &quot;_postprocessed&quot; file.</a>
<a name="4810"><span class="lineNum">    4810 </span><span class="lineNoCov">          0 :                string sourceFilename              = Sg_File_Info::getFilenameFromID(fileId) ;</span></a>
<a name="4811"><span class="lineNum">    4811 </span><span class="lineNoCov">          0 :                string sourceFileNameOutputFromCpp = OpenFortranParser_globalFilePointer-&gt;generate_C_preprocessor_intermediate_filename(sourceFilename);</span></a>
<a name="4812"><span class="lineNum">    4812 </span><span class="lineNoCov">          0 :                int cppFileId = Sg_File_Info::getIDFromFilename(sourceFileNameOutputFromCpp);</span></a>
<a name="4813"><span class="lineNum">    4813 </span><span class="lineNoCov">          0 :                if (statement-&gt;get_file_info()-&gt;get_file_id() == cppFileId)</span></a>
<a name="4814"><span class="lineNum">    4814 </span>            :                   {</a>
<a name="4815"><span class="lineNum">    4815 </span><span class="lineNoCov">          0 :                    statement-&gt;get_file_info()-&gt;set_file_id(fileId);</span></a>
<a name="4816"><span class="lineNum">    4816 </span>            :                   }</a>
<a name="4817"><span class="lineNum">    4817 </span>            :             // statement-&gt;get_file_info()-&gt;set_line(line);</a>
<a name="4818"><span class="lineNum">    4818 </span>            : </a>
<a name="4819"><span class="lineNum">    4819 </span><span class="lineNoCov">          0 :                if ( SgProject::get_verbose() &gt; 1 )</span></a>
<a name="4820"><span class="lineNum">    4820 </span><span class="lineNoCov">          0 :                     Sg_File_Info::display_static_data(&quot;Setting the source position of statement&quot;);</span></a>
<a name="4821"><span class="lineNum">    4821 </span>            : </a>
<a name="4822"><span class="lineNum">    4822 </span><span class="lineNoCov">          0 :                string filename = Sg_File_Info::getFilenameFromID(fileId);</span></a>
<a name="4823"><span class="lineNum">    4823 </span>            : </a>
<a name="4824"><span class="lineNum">    4824 </span><span class="lineNoCov">          0 :                if ( SgProject::get_verbose() &gt; 1 )</span></a>
<a name="4825"><span class="lineNum">    4825 </span>            :                   {</a>
<a name="4826"><span class="lineNum">    4826 </span><span class="lineNoCov">          0 :                     printf (&quot;filename = %s \n&quot;,filename.c_str());</span></a>
<a name="4827"><span class="lineNum">    4827 </span><span class="lineNoCov">          0 :                     printf (&quot;filename = %s \n&quot;,statement-&gt;get_file_info()-&gt;get_filenameString().c_str());</span></a>
<a name="4828"><span class="lineNum">    4828 </span>            :                   }</a>
<a name="4829"><span class="lineNum">    4829 </span>            : </a>
<a name="4830"><span class="lineNum">    4830 </span><span class="lineNoCov">          0 :                ASSERT_not_null(statement-&gt;get_file_info()-&gt;get_filename());</span></a>
<a name="4831"><span class="lineNum">    4831 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(statement-&gt;get_file_info()-&gt;get_filenameString().empty() == false);</span></a>
<a name="4832"><span class="lineNum">    4832 </span>            :              }</a>
<a name="4833"><span class="lineNum">    4833 </span>            :         }</a>
<a name="4834"><span class="lineNum">    4834 </span>            : #else  // ! ROSE_BUILD_FORTRAN_LANGUAGE_SUPPORT</a>
<a name="4835"><span class="lineNum">    4835 </span>            :      // SKW: not called except from Fortran</a>
<a name="4836"><span class="lineNum">    4836 </span>            :      printf(&quot;&gt;&gt;&gt; SgSourceFile_processCppLinemarkers::LinemarkerTraversal::visit is not implemented for languages other than Fortran\n&quot;);</a>
<a name="4837"><span class="lineNum">    4837 </span>            :      ROSE_ABORT();</a>
<a name="4838"><span class="lineNum">    4838 </span>            : #endif //   ROSE_BUILD_FORTRAN_LANGUAGE_SUPPORT</a>
<a name="4839"><span class="lineNum">    4839 </span><span class="lineNoCov">          0 :    }</span></a>
<a name="4840"><span class="lineNum">    4840 </span>            : </a>
<a name="4841"><span class="lineNum">    4841 </span>            : </a>
<a name="4842"><span class="lineNum">    4842 </span>            : void</a>
<a name="4843"><span class="lineNum">    4843 </span><span class="lineNoCov">          0 : SgSourceFile::processCppLinemarkers()</span></a>
<a name="4844"><span class="lineNum">    4844 </span>            :    {</a>
<a name="4845"><span class="lineNum">    4845 </span><span class="lineNoCov">          0 :      SgSourceFile* sourceFile = const_cast&lt;SgSourceFile*&gt;(this);</span></a>
<a name="4846"><span class="lineNum">    4846 </span>            : </a>
<a name="4847"><span class="lineNum">    4847 </span><span class="lineNoCov">          0 :      SgSourceFile_processCppLinemarkers::LinemarkerTraversal linemarkerTraversal(sourceFile-&gt;get_sourceFileNameWithPath());</span></a>
<a name="4848"><span class="lineNum">    4848 </span>            : </a>
<a name="4849"><span class="lineNum">    4849 </span><span class="lineNoCov">          0 :      linemarkerTraversal.traverse(sourceFile,preorder);</span></a>
<a name="4850"><span class="lineNum">    4850 </span>            : </a>
<a name="4851"><span class="lineNum">    4851 </span>            : #if 0</a>
<a name="4852"><span class="lineNum">    4852 </span>            :      printf (&quot;Exiting as a test ... (processing linemarkers)\n&quot;);</a>
<a name="4853"><span class="lineNum">    4853 </span>            :      ROSE_ABORT();</a>
<a name="4854"><span class="lineNum">    4854 </span>            : #endif</a>
<a name="4855"><span class="lineNum">    4855 </span><span class="lineNoCov">          0 :    }</span></a>
<a name="4856"><span class="lineNum">    4856 </span>            : </a>
<a name="4857"><span class="lineNum">    4857 </span>            : </a>
<a name="4858"><span class="lineNum">    4858 </span>            : int</a>
<a name="4859"><span class="lineNum">    4859 </span><span class="lineCov">        320 : SgSourceFile::build_C_and_Cxx_AST( vector&lt;string&gt; argv, vector&lt;string&gt; inputCommandLine )</span></a>
<a name="4860"><span class="lineNum">    4860 </span>            :    {</a>
<a name="4861"><span class="lineNum">    4861 </span>            :      // SG (7/9/2015) In case of a mixed language project, force case</a>
<a name="4862"><span class="lineNum">    4862 </span>            :      // sensitivity here.</a>
<a name="4863"><span class="lineNum">    4863 </span><span class="lineCov">        320 :      SageBuilder::symbol_table_case_insensitive_semantics = false;</span></a>
<a name="4864"><span class="lineNum">    4864 </span>            : </a>
<a name="4865"><span class="lineNum">    4865 </span><span class="lineCov">        320 :      std::string frontEndCommandLineString;</span></a>
<a name="4866"><span class="lineNum">    4866 </span><span class="lineCov">        958 :      frontEndCommandLineString = std::string(argv[0]) + std::string(&quot; &quot;) + CommandlineProcessing::generateStringFromArgList(inputCommandLine,false,false);</span></a>
<a name="4867"><span class="lineNum">    4867 </span>            : </a>
<a name="4868"><span class="lineNum">    4868 </span><span class="lineCov">        320 :      if ( get_verbose() &gt; 1 )</span></a>
<a name="4869"><span class="lineNum">    4869 </span>            :         {</a>
<a name="4870"><span class="lineNum">    4870 </span><span class="lineNoCov">          0 :           printf (&quot;In build_C_and_Cxx_AST(): Before calling edg_main: frontEndCommandLineString = %s \n&quot;,frontEndCommandLineString.c_str());</span></a>
<a name="4871"><span class="lineNum">    4871 </span>            :         }</a>
<a name="4872"><span class="lineNum">    4872 </span>            : </a>
<a name="4873"><span class="lineNum">    4873 </span><span class="lineCov">        320 :      int c_cxx_argc = 0;</span></a>
<a name="4874"><span class="lineNum">    4874 </span><span class="lineCov">        320 :      char **c_cxx_argv = nullptr;</span></a>
<a name="4875"><span class="lineNum">    4875 </span><span class="lineCov">        320 :      CommandlineProcessing::generateArgcArgvFromList(inputCommandLine, c_cxx_argc, c_cxx_argv);</span></a>
<a name="4876"><span class="lineNum">    4876 </span>            : </a>
<a name="4877"><span class="lineNum">    4877 </span>            : #ifdef ROSE_BUILD_CXX_LANGUAGE_SUPPORT</a>
<a name="4878"><span class="lineNum">    4878 </span>            :   // This is the function call to the EDG front-end (modified in ROSE to pass a SgFile)</a>
<a name="4879"><span class="lineNum">    4879 </span>            : </a>
<a name="4880"><span class="lineNum">    4880 </span>            : #if 0</a>
<a name="4881"><span class="lineNum">    4881 </span>            :        // If this was selected as an option then we can stop here (rather than call OFP again).</a>
<a name="4882"><span class="lineNum">    4882 </span>            :        // printf (&quot;--- get_exit_after_parser() = %s \n&quot;,get_exit_after_parser() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="4883"><span class="lineNum">    4883 </span>            :           if (get_exit_after_parser() == true)</a>
<a name="4884"><span class="lineNum">    4884 </span>            :              {</a>
<a name="4885"><span class="lineNum">    4885 </span>            :                printf (&quot;Exiting after parsing... \n&quot;);</a>
<a name="4886"><span class="lineNum">    4886 </span>            :                exit(0);</a>
<a name="4887"><span class="lineNum">    4887 </span>            :              }</a>
<a name="4888"><span class="lineNum">    4888 </span>            : #endif</a>
<a name="4889"><span class="lineNum">    4889 </span>            : </a>
<a name="4890"><span class="lineNum">    4890 </span>            : #ifdef ROSE_USE_CLANG_FRONTEND</a>
<a name="4891"><span class="lineNum">    4891 </span>            :      int clang_main(int, char *[], SgSourceFile &amp; sageFile );</a>
<a name="4892"><span class="lineNum">    4892 </span>            :      int frontendErrorLevel = clang_main (c_cxx_argc, c_cxx_argv, *this);</a>
<a name="4893"><span class="lineNum">    4893 </span>            : #else /* default to EDG */</a>
<a name="4894"><span class="lineNum">    4894 </span>            : </a>
<a name="4895"><span class="lineNum">    4895 </span>            :   // DQ (1/24/2017): We want to conditionally support C++11 input files. It is an error</a>
<a name="4896"><span class="lineNum">    4896 </span>            :   // to violate this conditions.  Within the ROSE regression test we don't test C++11</a>
<a name="4897"><span class="lineNum">    4897 </span>            :   // files if they would violate this conditions.</a>
<a name="4898"><span class="lineNum">    4898 </span>            : #if ((ROSE_EDG_MAJOR_VERSION_NUMBER == 4) &amp;&amp; (ROSE_EDG_MINOR_VERSION_NUMBER == 9))</a>
<a name="4899"><span class="lineNum">    4899 </span>            :      #ifdef BACKEND_CXX_IS_GNU_COMPILER</a>
<a name="4900"><span class="lineNum">    4900 </span>            :        // DQ (1/24/2017): Add restrictions to handle exclusigon of C++11 specific files when ROSE is configured using EDG 4.9 and GNU 4.9 as the backend.</a>
<a name="4901"><span class="lineNum">    4901 </span>            :           #if ((BACKEND_CXX_COMPILER_MAJOR_VERSION_NUMBER == 4) &amp;&amp; (BACKEND_CXX_COMPILER_MINOR_VERSION_NUMBER == 9))</a>
<a name="4902"><span class="lineNum">    4902 </span>            :             // And if this is a C++11 file.</a>
<a name="4903"><span class="lineNum">    4903 </span>            :                if (this-&gt;get_Cxx11_only() == true)</a>
<a name="4904"><span class="lineNum">    4904 </span>            :                   {</a>
<a name="4905"><span class="lineNum">    4905 </span>            :                     printf (&quot;Note: C++11 input files to ROSE are NOT supported using EDG 4.9 configuration with GNU compilers 4.9 and greater (configure ROSE using EDG 4.12) \n&quot;);</a>
<a name="4906"><span class="lineNum">    4906 </span>            :                     exit(1);</a>
<a name="4907"><span class="lineNum">    4907 </span>            :                   }</a>
<a name="4908"><span class="lineNum">    4908 </span>            :           #else</a>
<a name="4909"><span class="lineNum">    4909 </span>            :                #if (BACKEND_CXX_COMPILER_MAJOR_VERSION_NUMBER &gt;= 5)</a>
<a name="4910"><span class="lineNum">    4910 </span>            :             // And if this is a C++11 file.</a>
<a name="4911"><span class="lineNum">    4911 </span>            :                if (this-&gt;get_Cxx11_only() == true)</a>
<a name="4912"><span class="lineNum">    4912 </span>            :                   {</a>
<a name="4913"><span class="lineNum">    4913 </span>            :                     printf (&quot;Note: C++11 input files to ROSE are NOT supported using EDG 4.9 configuration with GNU compilers 5.x and greater (configure ROSE using EDG 4.12) \n&quot;);</a>
<a name="4914"><span class="lineNum">    4914 </span>            :                     exit(1);</a>
<a name="4915"><span class="lineNum">    4915 </span>            :                   }</a>
<a name="4916"><span class="lineNum">    4916 </span>            :                #endif</a>
<a name="4917"><span class="lineNum">    4917 </span>            :           #endif</a>
<a name="4918"><span class="lineNum">    4918 </span>            :      #else</a>
<a name="4919"><span class="lineNum">    4919 </span>            :           #ifdef BACKEND_CXX_IS_CLANG_COMPILER</a>
<a name="4920"><span class="lineNum">    4920 </span>            :                #if ((BACKEND_CXX_COMPILER_MAJOR_VERSION_NUMBER == 3) &amp;&amp; (BACKEND_CXX_COMPILER_MINOR_VERSION_NUMBER == 5))</a>
<a name="4921"><span class="lineNum">    4921 </span>            :             // And if this is a C++11 file.</a>
<a name="4922"><span class="lineNum">    4922 </span>            :                if (this-&gt;get_Cxx11_only() == true)</a>
<a name="4923"><span class="lineNum">    4923 </span>            :                   {</a>
<a name="4924"><span class="lineNum">    4924 </span>            :                     printf (&quot;Note: C++11 input files to ROSE are NOT supported using EDG 4.9 configuration with Clang/LLVM compiler 3.5 (configure ROSE using EDG 4.12) \n&quot;);</a>
<a name="4925"><span class="lineNum">    4925 </span>            :                     exit(1);</a>
<a name="4926"><span class="lineNum">    4926 </span>            :                   }</a>
<a name="4927"><span class="lineNum">    4927 </span>            :                #endif</a>
<a name="4928"><span class="lineNum">    4928 </span>            :           #endif</a>
<a name="4929"><span class="lineNum">    4929 </span>            :      #endif</a>
<a name="4930"><span class="lineNum">    4930 </span>            : #else</a>
<a name="4931"><span class="lineNum">    4931 </span>            :   // DQ (1/24/2017): C++, C++11, and C++14 files are allowed for EDG 4.12.</a>
<a name="4932"><span class="lineNum">    4932 </span>            : #endif</a>
<a name="4933"><span class="lineNum">    4933 </span>            : </a>
<a name="4934"><span class="lineNum">    4934 </span><span class="lineCov">        320 :      int edg_main(int, char *[], SgSourceFile &amp; sageFile );</span></a>
<a name="4935"><span class="lineNum">    4935 </span><span class="lineCov">        320 :      int frontendErrorLevel = edg_main (c_cxx_argc, c_cxx_argv, *this);</span></a>
<a name="4936"><span class="lineNum">    4936 </span>            : #endif /* clang or edg */</a>
<a name="4937"><span class="lineNum">    4937 </span>            : </a>
<a name="4938"><span class="lineNum">    4938 </span>            : #else</a>
<a name="4939"><span class="lineNum">    4939 </span>            :   // DQ (2/21/2016): Added &quot;error: &quot; to allow this to be caught by the ROSE Matrix Testing.</a>
<a name="4940"><span class="lineNum">    4940 </span>            :      int frontendErrorLevel = 99;</a>
<a name="4941"><span class="lineNum">    4941 </span>            :      ROSE_ASSERT (! &quot;[FATAL] [ROSE] [frontend] [C/C++] &quot;</a>
<a name="4942"><span class="lineNum">    4942 </span>            :                     &quot;error: ROSE was not configured to support the C/C++ frontend.&quot;);</a>
<a name="4943"><span class="lineNum">    4943 </span>            : #endif</a>
<a name="4944"><span class="lineNum">    4944 </span>            : </a>
<a name="4945"><span class="lineNum">    4945 </span><span class="lineCov">        640 :      return frontendErrorLevel;</span></a>
<a name="4946"><span class="lineNum">    4946 </span>            :    }</a>
<a name="4947"><span class="lineNum">    4947 </span>            : </a>
<a name="4948"><span class="lineNum">    4948 </span>            : int</a>
<a name="4949"><span class="lineNum">    4949 </span><span class="lineCov">        357 : SgSourceFile::buildAST( vector&lt;string&gt; argv, vector&lt;string&gt; inputCommandLine )</span></a>
<a name="4950"><span class="lineNum">    4950 </span>            :    {</a>
<a name="4951"><span class="lineNum">    4951 </span>            :   // printf (&quot;######################## Inside of SgSourceFile::buildAST() ##########################\n&quot;);</a>
<a name="4952"><span class="lineNum">    4952 </span>            : </a>
<a name="4953"><span class="lineNum">    4953 </span>            :   // TV (09/24/2018): Skip actually calling the frontend (used to test the backend with ROSE command line processing)</a>
<a name="4954"><span class="lineNum">    4954 </span><span class="lineCov">        357 :      if (get_skip_parser()) return 0;</span></a>
<a name="4955"><span class="lineNum">    4955 </span>            : </a>
<a name="4956"><span class="lineNum">    4956 </span>            :   // DXN (01/10/2011): except for building C and Cxx AST, frontend fails when frontend error level &gt; 0.</a>
<a name="4957"><span class="lineNum">    4957 </span><span class="lineCov">        357 :      int frontendErrorLevel = 0;</span></a>
<a name="4958"><span class="lineNum">    4958 </span><span class="lineCov">        357 :      bool frontend_failed = false;</span></a>
<a name="4959"><span class="lineNum">    4959 </span><span class="lineCov">        357 :      if (get_Fortran_only() == true)</span></a>
<a name="4960"><span class="lineNum">    4960 </span>            :         {</a>
<a name="4961"><span class="lineNum">    4961 </span>            : #if defined(ROSE_BUILD_FORTRAN_LANGUAGE_SUPPORT) || defined(ROSE_EXPERIMENTAL_FLANG_ROSE_CONNECTION)</a>
<a name="4962"><span class="lineNum">    4962 </span><span class="lineCov">         37 :           frontendErrorLevel = build_Fortran_AST(argv,inputCommandLine);</span></a>
<a name="4963"><span class="lineNum">    4963 </span><span class="lineCov">         37 :           frontend_failed = (frontendErrorLevel &gt; 1);  // DXN (01/18/2011): needed to pass make check.  TODO: need fixing up</span></a>
<a name="4964"><span class="lineNum">    4964 </span>            : #else</a>
<a name="4965"><span class="lineNum">    4965 </span>            :        // DQ (2/21/2016): Added &quot;error: &quot; to allow this to be caught by the ROSE Matrix Testing.</a>
<a name="4966"><span class="lineNum">    4966 </span>            :           ROSE_ASSERT (! &quot;[FATAL] [ROSE] [frontend] [Fortran] &quot;</a>
<a name="4967"><span class="lineNum">    4967 </span>            :                          &quot;error: ROSE was not configured to support the Fortran frontend.&quot;);</a>
<a name="4968"><span class="lineNum">    4968 </span>            : #endif</a>
<a name="4969"><span class="lineNum">    4969 </span>            :         }</a>
<a name="4970"><span class="lineNum">    4970 </span>            :        else</a>
<a name="4971"><span class="lineNum">    4971 </span>            :         {</a>
<a name="4972"><span class="lineNum">    4972 </span><span class="lineCov">        320 :                                                 {</span></a>
<a name="4973"><span class="lineNum">    4973 </span>            :                                                // This is the C/C++ case (default).</a>
<a name="4974"><span class="lineNum">    4974 </span><span class="lineCov">        320 :                                                   frontendErrorLevel = build_C_and_Cxx_AST(argv,inputCommandLine);</span></a>
<a name="4975"><span class="lineNum">    4975 </span>            : </a>
<a name="4976"><span class="lineNum">    4976 </span>            :                                                // DQ (12/29/2008): The newer version of EDG (version 3.10 and 4.0) use different return codes for indicating an error.</a>
<a name="4977"><span class="lineNum">    4977 </span>            :                                                // Any non-zero value indicates an error.</a>
<a name="4978"><span class="lineNum">    4978 </span><span class="lineCov">        320 :                                                   frontend_failed = (frontendErrorLevel != 0);</span></a>
<a name="4979"><span class="lineNum">    4979 </span>            :                                                 }</a>
<a name="4980"><span class="lineNum">    4980 </span>            :         }</a>
<a name="4981"><span class="lineNum">    4981 </span>            : </a>
<a name="4982"><span class="lineNum">    4982 </span>            :   // Uniform processing of the error code!</a>
<a name="4983"><span class="lineNum">    4983 </span>            : </a>
<a name="4984"><span class="lineNum">    4984 </span><span class="lineCov">        357 :      if ( get_verbose() &gt; 1 )</span></a>
<a name="4985"><span class="lineNum">    4985 </span><span class="lineNoCov">          0 :           printf (&quot;DONE: frontend called (frontendErrorLevel = %d) \n&quot;,frontendErrorLevel);</span></a>
<a name="4986"><span class="lineNum">    4986 </span>            : </a>
<a name="4987"><span class="lineNum">    4987 </span>            :   // If we had any errors reported by the frontend then quite now</a>
<a name="4988"><span class="lineNum">    4988 </span><span class="lineCov">        357 :      if (frontend_failed == true)</span></a>
<a name="4989"><span class="lineNum">    4989 </span>            :         {</a>
<a name="4990"><span class="lineNum">    4990 </span>            :        // cout &lt;&lt; &quot;Errors in Processing: (frontendErrorLevel &gt; 3)&quot; &lt;&lt; endl;</a>
<a name="4991"><span class="lineNum">    4991 </span><span class="lineNoCov">          0 :           if ( get_verbose() &gt; 1 )</span></a>
<a name="4992"><span class="lineNum">    4992 </span><span class="lineNoCov">          0 :                printf (&quot;frontendErrorLevel = %d \n&quot;,frontendErrorLevel);</span></a>
<a name="4993"><span class="lineNum">    4993 </span>            : </a>
<a name="4994"><span class="lineNum">    4994 </span>            :        // DQ (9/22/2006): We need to invert the test result (return code) for</a>
<a name="4995"><span class="lineNum">    4995 </span>            :        // negative tests (where failure is expected and success is an error).</a>
<a name="4996"><span class="lineNum">    4996 </span><span class="lineNoCov">          0 :           if (get_negative_test() == true)</span></a>
<a name="4997"><span class="lineNum">    4997 </span>            :              {</a>
<a name="4998"><span class="lineNum">    4998 </span><span class="lineNoCov">          0 :                if ( get_verbose() &gt; 1 )</span></a>
<a name="4999"><span class="lineNum">    4999 </span>            :                   {</a>
<a name="5000"><span class="lineNum">    5000 </span><span class="lineNoCov">          0 :                     printf (&quot;(evaluation of frontend results) This is a negative tests, so an error in compilation is a PASS but a successful \n&quot;);</span></a>
<a name="5001"><span class="lineNum">    5001 </span><span class="lineNoCov">          0 :                     printf (&quot;compilation is not a FAIL since the failure might happen in the compilation of the generated code by the vendor compiler. \n&quot;);</span></a>
<a name="5002"><span class="lineNum">    5002 </span>            :                   }</a>
<a name="5003"><span class="lineNum">    5003 </span><span class="lineNoCov">          0 :                exit(0);</span></a>
<a name="5004"><span class="lineNum">    5004 </span>            :              }</a>
<a name="5005"><span class="lineNum">    5005 </span>            :             else</a>
<a name="5006"><span class="lineNum">    5006 </span>            :              {</a>
<a name="5007"><span class="lineNum">    5007 </span>            :             // DQ (1/28/2016): Tone this down a bit to be less sarcastic.</a>
<a name="5008"><span class="lineNum">    5008 </span>            :             // DQ (4/12/2015): Make this a more friendly message than what the OS provides on abort() (which is &quot;Aborted (core dumped)&quot;).</a>
<a name="5009"><span class="lineNum">    5009 </span>            :             // Exit because there are errors in the input program</a>
<a name="5010"><span class="lineNum">    5010 </span>            :             // cout &lt;&lt; &quot;Errors in Processing: (frontend_failed)&quot; &lt;&lt; endl;</a>
<a name="5011"><span class="lineNum">    5011 </span>            :             // ROSE_ABORT(&quot;Errors in Processing: (frontend_failed)&quot;);</a>
<a name="5012"><span class="lineNum">    5012 </span>            :             // printf (&quot;Errors in Processing Input File: (throwing an instance of \&quot;frontend_failed\&quot; exception due to errors detected in the input code), have a nice day! \n&quot;);</a>
<a name="5013"><span class="lineNum">    5013 </span><span class="lineNoCov">          0 :                printf (&quot;Errors in Processing Input File: throwing an instance of \&quot;frontend_failed\&quot; exception due to syntax errors detected in the input code \n&quot;);</span></a>
<a name="5014"><span class="lineNum">    5014 </span><span class="lineNoCov">          0 :                if (Rose::KeepGoing::g_keep_going) {</span></a>
<a name="5015"><span class="lineNum">    5015 </span><span class="lineNoCov">          0 :                  raise(SIGABRT); // raise a signal to be handled by the keep going support , instead of exit. Liao 4/25/2017</span></a>
<a name="5016"><span class="lineNum">    5016 </span>            :                }</a>
<a name="5017"><span class="lineNum">    5017 </span>            :                else</a>
<a name="5018"><span class="lineNum">    5018 </span><span class="lineNoCov">          0 :                   exit(1);</span></a>
<a name="5019"><span class="lineNum">    5019 </span>            :              }</a>
<a name="5020"><span class="lineNum">    5020 </span>            :         }</a>
<a name="5021"><span class="lineNum">    5021 </span>            : </a>
<a name="5022"><span class="lineNum">    5022 </span>            :      return frontendErrorLevel;</a>
<a name="5023"><span class="lineNum">    5023 </span>            :    }</a>
<a name="5024"><span class="lineNum">    5024 </span>            : </a>
<a name="5025"><span class="lineNum">    5025 </span>            : // DQ (10/14/2010): Removing reference to macros defined in rose_config.h (defined in the header file as a default parameter).</a>
<a name="5026"><span class="lineNum">    5026 </span>            : // int SgFile::compileOutput ( vector&lt;string&gt;&amp; argv, int fileNameIndex, const string&amp; compilerNameOrig )</a>
<a name="5027"><span class="lineNum">    5027 </span>            : int</a>
<a name="5028"><span class="lineNum">    5028 </span><span class="lineCov">        347 : SgFile::compileOutput ( vector&lt;string&gt;&amp; argv, int fileNameIndex )</span></a>
<a name="5029"><span class="lineNum">    5029 </span>            :    {</a>
<a name="5030"><span class="lineNum">    5030 </span>            :   // DQ (7/12/2005): Introduce tracking of performance of ROSE.</a>
<a name="5031"><span class="lineNum">    5031 </span><span class="lineCov">        347 :      TimingPerformance timer (&quot;AST Object Code Generation (compile output):&quot;);</span></a>
<a name="5032"><span class="lineNum">    5032 </span>            : </a>
<a name="5033"><span class="lineNum">    5033 </span>            :   // DQ (11/4/2015): Added assertion.</a>
<a name="5034"><span class="lineNum">    5034 </span><span class="lineCov">        347 :      ROSE_ASSERT(this != NULL);</span></a>
<a name="5035"><span class="lineNum">    5035 </span>            : </a>
<a name="5036"><span class="lineNum">    5036 </span>            :   // DQ (4/21/2006): I think we can now assert this!</a>
<a name="5037"><span class="lineNum">    5037 </span><span class="lineCov">        347 :      ROSE_ASSERT(fileNameIndex == 0);</span></a>
<a name="5038"><span class="lineNum">    5038 </span>            : </a>
<a name="5039"><span class="lineNum">    5039 </span>            : #if 0</a>
<a name="5040"><span class="lineNum">    5040 </span>            :      printf (&quot;Inside of SgFile::compileOutput() \n&quot;);</a>
<a name="5041"><span class="lineNum">    5041 </span>            : #endif</a>
<a name="5042"><span class="lineNum">    5042 </span>            : </a>
<a name="5043"><span class="lineNum">    5043 </span>            : #if 0</a>
<a name="5044"><span class="lineNum">    5044 </span>            :      printf (&quot;In SgFile::compileOutput(): Exiting as a test! \n&quot;);</a>
<a name="5045"><span class="lineNum">    5045 </span>            :      ROSE_ABORT();</a>
<a name="5046"><span class="lineNum">    5046 </span>            : #endif</a>
<a name="5047"><span class="lineNum">    5047 </span>            : </a>
<a name="5048"><span class="lineNum">    5048 </span>            : #define DEBUG_PROJECT_COMPILE_COMMAND_LINE_WITH_ARGS 0</a>
<a name="5049"><span class="lineNum">    5049 </span>            : </a>
<a name="5050"><span class="lineNum">    5050 </span>            : #if DEBUG_PROJECT_COMPILE_COMMAND_LINE_WITH_ARGS</a>
<a name="5051"><span class="lineNum">    5051 </span>            :      printf (&quot;\n\n***************************************************** \n&quot;);</a>
<a name="5052"><span class="lineNum">    5052 </span>            :      printf (&quot;Inside of SgFile::compileOutput() \n&quot;);</a>
<a name="5053"><span class="lineNum">    5053 </span>            :      printf (&quot;   --- get_unparse_output_filename() = %s \n&quot;,get_unparse_output_filename().c_str());</a>
<a name="5054"><span class="lineNum">    5054 </span>            :      printf (&quot;***************************************************** \n\n\n&quot;);</a>
<a name="5055"><span class="lineNum">    5055 </span>            : #endif</a>
<a name="5056"><span class="lineNum">    5056 </span>            : #if 0</a>
<a name="5057"><span class="lineNum">    5057 </span>            :      printf (&quot;In SgFile::compileOutput(): calling display() \n&quot;);</a>
<a name="5058"><span class="lineNum">    5058 </span>            :      display(&quot;In SgFile::compileOutput()&quot;);</a>
<a name="5059"><span class="lineNum">    5059 </span>            : #endif</a>
<a name="5060"><span class="lineNum">    5060 </span>            : </a>
<a name="5061"><span class="lineNum">    5061 </span>            :   // This function does the final compilation of the unparsed file</a>
<a name="5062"><span class="lineNum">    5062 </span>            :   // Remaining arguments from the original compile time are used as well</a>
<a name="5063"><span class="lineNum">    5063 </span>            :   // as additional arguments added by the buildCompilerCommandLineOptions() function</a>
<a name="5064"><span class="lineNum">    5064 </span>            : </a>
<a name="5065"><span class="lineNum">    5065 </span>            :   // DQ NOTE: This function has to be modified to compile more than</a>
<a name="5066"><span class="lineNum">    5066 </span>            :   //       just one file (as part of the multi-file support)</a>
<a name="5067"><span class="lineNum">    5067 </span>            :   // ROSE_ASSERT (sageProject.numberOfFiles() == 1);</a>
<a name="5068"><span class="lineNum">    5068 </span>            : </a>
<a name="5069"><span class="lineNum">    5069 </span>            :   // ******************************************************************************</a>
<a name="5070"><span class="lineNum">    5070 </span>            :   // At this point in the control flow (for ROSE) we have returned from the processing</a>
<a name="5071"><span class="lineNum">    5071 </span>            :   // via the EDG frontend (or skipped it if that option was specified).</a>
<a name="5072"><span class="lineNum">    5072 </span>            :   // The following has been done or explicitly skipped if such options were specified</a>
<a name="5073"><span class="lineNum">    5073 </span>            :   // on the commandline:</a>
<a name="5074"><span class="lineNum">    5074 </span>            :   //    1) The application program has been parsed</a>
<a name="5075"><span class="lineNum">    5075 </span>            :   //    2) All AST's have been build (one for each grammar)</a>
<a name="5076"><span class="lineNum">    5076 </span>            :   //    3) The transformations have been edited into the C++ AST</a>
<a name="5077"><span class="lineNum">    5077 </span>            :   //    4) The C++ AST has been unparsed to form the final output file (all code has</a>
<a name="5078"><span class="lineNum">    5078 </span>            :   //       been generated into a different filename)</a>
<a name="5079"><span class="lineNum">    5079 </span>            :   // ******************************************************************************</a>
<a name="5080"><span class="lineNum">    5080 </span>            : </a>
<a name="5081"><span class="lineNum">    5081 </span>            :   // What remains is to run the specified compiler (typically the C++ compiler) using</a>
<a name="5082"><span class="lineNum">    5082 </span>            :   // the generated output file (unparsed and transformed application code).</a>
<a name="5083"><span class="lineNum">    5083 </span><span class="lineCov">        347 :      int returnValueForRose = 0;</span></a>
<a name="5084"><span class="lineNum">    5084 </span>            : </a>
<a name="5085"><span class="lineNum">    5085 </span>            :   // DQ (1/17/2006): test this</a>
<a name="5086"><span class="lineNum">    5086 </span>            :   // ROSE_ASSERT(get_fileInfo() != NULL);</a>
<a name="5087"><span class="lineNum">    5087 </span>            : </a>
<a name="5088"><span class="lineNum">    5088 </span>            :   // DQ (4/2/2011): Added language specific support.</a>
<a name="5089"><span class="lineNum">    5089 </span>            :   // const string compilerNameOrig = BACKEND_CXX_COMPILER_NAME_WITH_PATH;</a>
<a name="5090"><span class="lineNum">    5090 </span><span class="lineCov">        694 :      string compilerNameOrig = BACKEND_CXX_COMPILER_NAME_WITH_PATH;</span></a>
<a name="5091"><span class="lineNum">    5091 </span>            : </a>
<a name="5092"><span class="lineNum">    5092 </span><span class="lineCov">        347 :      if (get_Fortran_only() == true)</span></a>
<a name="5093"><span class="lineNum">    5093 </span>            :         {</a>
<a name="5094"><span class="lineNum">    5094 </span>            :        // printf (&quot;Fortran language support in SgFile::compileOutput() not implemented \n&quot;);</a>
<a name="5095"><span class="lineNum">    5095 </span>            :        // ROSE_ASSERT(false);</a>
<a name="5096"><span class="lineNum">    5096 </span><span class="lineCov">         37 :           compilerNameOrig = BACKEND_FORTRAN_COMPILER_NAME_WITH_PATH;</span></a>
<a name="5097"><span class="lineNum">    5097 </span>            :         }</a>
<a name="5098"><span class="lineNum">    5098 </span>            : </a>
<a name="5099"><span class="lineNum">    5099 </span>            :   // BP : 11/13/2001, checking to see that the compiler name is set</a>
<a name="5100"><span class="lineNum">    5100 </span><span class="lineCov">        694 :      string compilerName = compilerNameOrig + &quot; &quot;;</span></a>
<a name="5101"><span class="lineNum">    5101 </span>            : </a>
<a name="5102"><span class="lineNum">    5102 </span>            :   // DQ (4/21/2006): Setup the output file name.</a>
<a name="5103"><span class="lineNum">    5103 </span>            :   // Rose_STL_Container&lt;string&gt; fileList = CommandlineProcessing::generateSourceFilenames(argc,argv);</a>
<a name="5104"><span class="lineNum">    5104 </span>            :   // ROSE_ASSERT (fileList.size() == 1);</a>
<a name="5105"><span class="lineNum">    5105 </span>            :   // p_sourceFileNameWithPath    = *(fileList.begin());</a>
<a name="5106"><span class="lineNum">    5106 </span>            :   // p_sourceFileNameWithoutPath = Rose::utility_stripPathFromFileName(p_sourceFileNameWithPath.c_str());</a>
<a name="5107"><span class="lineNum">    5107 </span>            : </a>
<a name="5108"><span class="lineNum">    5108 </span>            : #if 1</a>
<a name="5109"><span class="lineNum">    5109 </span>            :   // ROSE_ASSERT (get_unparse_output_filename().empty() == true);</a>
<a name="5110"><span class="lineNum">    5110 </span>            : </a>
<a name="5111"><span class="lineNum">    5111 </span>            :   // DQ (4/21/2006): If we have not set the unparse_output_filename then we could not have called</a>
<a name="5112"><span class="lineNum">    5112 </span>            :   // unparse and we want to compile the original source file as a backup mechanism to generate an</a>
<a name="5113"><span class="lineNum">    5113 </span>            :   // object file.</a>
<a name="5114"><span class="lineNum">    5114 </span>            :   // printf (&quot;In SgFile::compileOutput(): get_unparse_output_filename() = %s \n&quot;,get_unparse_output_filename().c_str());</a>
<a name="5115"><span class="lineNum">    5115 </span>            : </a>
<a name="5116"><span class="lineNum">    5116 </span><span class="lineCov">        347 :     bool use_original_input_file = Rose::KeepGoing::Backend::UseOriginalInputFile(this);</span></a>
<a name="5117"><span class="lineNum">    5117 </span>            : </a>
<a name="5118"><span class="lineNum">    5118 </span>            : #if 0</a>
<a name="5119"><span class="lineNum">    5119 </span>            :     printf (&quot;In SgFile::compileOutput(): use_original_input_file = %s \n&quot;,use_original_input_file ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="5120"><span class="lineNum">    5120 </span>            : #endif</a>
<a name="5121"><span class="lineNum">    5121 </span>            : </a>
<a name="5122"><span class="lineNum">    5122 </span>            :   // TOO1 (05/14/2013): Handling for -rose:keep_going</a>
<a name="5123"><span class="lineNum">    5123 </span>            :   // Replace the unparsed file with the original input file.</a>
<a name="5124"><span class="lineNum">    5124 </span><span class="lineCov">        347 :      if (use_original_input_file)</span></a>
<a name="5125"><span class="lineNum">    5125 </span>            :         {</a>
<a name="5126"><span class="lineNum">    5126 </span>            :        // ROSE_ASSERT(get_skip_unparse() == true);</a>
<a name="5127"><span class="lineNum">    5127 </span><span class="lineNoCov">          0 :           string outputFilename = get_sourceFileNameWithPath();</span></a>
<a name="5128"><span class="lineNum">    5128 </span>            : </a>
<a name="5129"><span class="lineNum">    5129 </span>            :        // DQ (9/15/2013): Added support for generated file to be placed into the same directory as the source file.</a>
<a name="5130"><span class="lineNum">    5130 </span>            :        // It's use here is similar to that in the unparse.C file, but less clear here that it is correct since we</a>
<a name="5131"><span class="lineNum">    5131 </span>            :        // don't have tests of the -rose:keep_going option (that I know of directly in ROSE).</a>
<a name="5132"><span class="lineNum">    5132 </span><span class="lineNoCov">          0 :           SgProject* project = TransformationSupport::getProject(this);</span></a>
<a name="5133"><span class="lineNum">    5133 </span><span class="lineNoCov">          0 :           if (project != nullptr)</span></a>
<a name="5134"><span class="lineNum">    5134 </span>            :              {</a>
<a name="5135"><span class="lineNum">    5135 </span>            : #if DEBUG_PROJECT_COMPILE_COMMAND_LINE_WITH_ARGS</a>
<a name="5136"><span class="lineNum">    5136 </span>            :                printf (&quot;In SgFile::compileOutput(): project-&gt;get_unparse_in_same_directory_as_input_file() = %s \n&quot;,project-&gt;get_unparse_in_same_directory_as_input_file() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="5137"><span class="lineNum">    5137 </span>            : #endif</a>
<a name="5138"><span class="lineNum">    5138 </span><span class="lineNoCov">          0 :                if (project-&gt;get_unparse_in_same_directory_as_input_file() == true)</span></a>
<a name="5139"><span class="lineNum">    5139 </span>            :                   {</a>
<a name="5140"><span class="lineNum">    5140 </span><span class="lineNoCov">          0 :                     outputFilename = Rose::getPathFromFileName(get_sourceFileNameWithPath()) + &quot;/rose_&quot; + get_sourceFileNameWithoutPath();</span></a>
<a name="5141"><span class="lineNum">    5141 </span>            : </a>
<a name="5142"><span class="lineNum">    5142 </span><span class="lineNoCov">          0 :                     printf (&quot;In SgFile::compileOutput(): Using filename for unparsed file into same directory as input file: outputFilename = %s \n&quot;,outputFilename.c_str());</span></a>
<a name="5143"><span class="lineNum">    5143 </span>            : </a>
<a name="5144"><span class="lineNum">    5144 </span><span class="lineNoCov">          0 :                     set_unparse_output_filename(outputFilename);</span></a>
<a name="5145"><span class="lineNum">    5145 </span>            :                   }</a>
<a name="5146"><span class="lineNum">    5146 </span>            :              }</a>
<a name="5147"><span class="lineNum">    5147 </span>            :             else</a>
<a name="5148"><span class="lineNum">    5148 </span>            :              {</a>
<a name="5149"><span class="lineNum">    5149 </span><span class="lineNoCov">          0 :                printf (&quot;WARNING: In SgFile::compileOutput(): file = %p has no associated project \n&quot;,this);</span></a>
<a name="5150"><span class="lineNum">    5150 </span>            :              }</a>
<a name="5151"><span class="lineNum">    5151 </span>            : </a>
<a name="5152"><span class="lineNum">    5152 </span><span class="lineNoCov">          0 :           if (get_unparse_output_filename().empty())</span></a>
<a name="5153"><span class="lineNum">    5153 </span>            :              {</a>
<a name="5154"><span class="lineNum">    5154 </span><span class="lineNoCov">          0 :                if (get_skipfinalCompileStep())</span></a>
<a name="5155"><span class="lineNum">    5155 </span>            :                   {</a>
<a name="5156"><span class="lineNum">    5156 </span>            :                   // nothing to do...</a>
<a name="5157"><span class="lineNum">    5157 </span>            :                   }</a>
<a name="5158"><span class="lineNum">    5158 </span>            :                  else</a>
<a name="5159"><span class="lineNum">    5159 </span><span class="lineNoCov">          0 :                     if (this -&gt; get_frontendErrorCode() == 0)</span></a>
<a name="5160"><span class="lineNum">    5160 </span>            :                        {</a>
<a name="5161"><span class="lineNum">    5161 </span>            :                  // DQ (7/14/2013): This is the branch taken when processing the -H option (which outputs the</a>
<a name="5162"><span class="lineNum">    5162 </span>            :                  // header file list, and is required to be supported in ROSE as part of some application</a>
<a name="5163"><span class="lineNum">    5163 </span>            :                  // specific configuration testing (when configure tests ROSE translators)).</a>
<a name="5164"><span class="lineNum">    5164 </span>            : </a>
<a name="5165"><span class="lineNum">    5165 </span>            :                  // TOO1 (9/23/2013): There was never an else branch (or assertion) here before.</a>
<a name="5166"><span class="lineNum">    5166 </span>            :                  //                   Commenting out for now to allow $ROSE/tests/CompilerOptionTests to pass</a>
<a name="5167"><span class="lineNum">    5167 </span>            :                  //                   in order to expedite the transition from ROSE-EDG3 to ROSE-EDG4.</a>
<a name="5168"><span class="lineNum">    5168 </span>            :                  //   ROSE_ASSERT(! &quot;Not implemented yet&quot;);</a>
<a name="5169"><span class="lineNum">    5169 </span>            :                        }</a>
<a name="5170"><span class="lineNum">    5170 </span>            :              }</a>
<a name="5171"><span class="lineNum">    5171 </span>            :             else</a>
<a name="5172"><span class="lineNum">    5172 </span>            :              {</a>
<a name="5173"><span class="lineNum">    5173 </span><span class="lineNoCov">          0 :                boost::filesystem::path original_file = outputFilename;</span></a>
<a name="5174"><span class="lineNum">    5174 </span><span class="lineNoCov">          0 :                boost::filesystem::path unparsed_file = get_unparse_output_filename();</span></a>
<a name="5175"><span class="lineNum">    5175 </span>            : </a>
<a name="5176"><span class="lineNum">    5176 </span><span class="lineNoCov">          0 :                if (SgProject::get_verbose() &gt;= 2)</span></a>
<a name="5177"><span class="lineNum">    5177 </span>            :                   {</a>
<a name="5178"><span class="lineNum">    5178 </span><span class="lineNoCov">          0 :                     std::cout</span></a>
<a name="5179"><span class="lineNum">    5179 </span>            :                       &lt;&lt; &quot;[DEBUG] &quot;</a>
<a name="5180"><span class="lineNum">    5180 </span>            :                       &lt;&lt; &quot;unparsed_file &quot;</a>
<a name="5181"><span class="lineNum">    5181 </span>            :                       &lt;&lt; &quot;'&quot; &lt;&lt; unparsed_file &lt;&lt; &quot;' &quot;</a>
<a name="5182"><span class="lineNum">    5182 </span><span class="lineNoCov">          0 :                       &lt;&lt; &quot;exists = &quot;</span></a>
<a name="5183"><span class="lineNum">    5183 </span><span class="lineNoCov">          0 :                       &lt;&lt; std::boolalpha</span></a>
<a name="5184"><span class="lineNum">    5184 </span><span class="lineNoCov">          0 :                       &lt;&lt; boost::filesystem::exists(unparsed_file)</span></a>
<a name="5185"><span class="lineNum">    5185 </span><span class="lineNoCov">          0 :                       &lt;&lt; std::endl;</span></a>
<a name="5186"><span class="lineNum">    5186 </span>            :                   }</a>
<a name="5187"><span class="lineNum">    5187 </span>            :               // Don't replace the original input file with itself</a>
<a name="5188"><span class="lineNum">    5188 </span><span class="lineNoCov">          0 :                if (original_file.string() != unparsed_file.string())</span></a>
<a name="5189"><span class="lineNum">    5189 </span>            :                   {</a>
<a name="5190"><span class="lineNum">    5190 </span><span class="lineNoCov">          0 :                     if (SgProject::get_verbose() &gt;= 1)</span></a>
<a name="5191"><span class="lineNum">    5191 </span>            :                        {</a>
<a name="5192"><span class="lineNum">    5192 </span><span class="lineNoCov">          0 :                          std::cout</span></a>
<a name="5193"><span class="lineNum">    5193 </span>            :                           &lt;&lt; &quot;[INFO] &quot;</a>
<a name="5194"><span class="lineNum">    5194 </span>            :                           &lt;&lt; &quot;Replacing &quot;</a>
<a name="5195"><span class="lineNum">    5195 </span>            :                           &lt;&lt; &quot;'&quot; &lt;&lt; unparsed_file &lt;&lt; &quot;' &quot;</a>
<a name="5196"><span class="lineNum">    5196 </span>            :                           &lt;&lt; &quot;with &quot;</a>
<a name="5197"><span class="lineNum">    5197 </span><span class="lineNoCov">          0 :                           &lt;&lt; &quot;'&quot; &lt;&lt; original_file &lt;&lt; &quot;'&quot;</span></a>
<a name="5198"><span class="lineNum">    5198 </span><span class="lineNoCov">          0 :                           &lt;&lt; std::endl;</span></a>
<a name="5199"><span class="lineNum">    5199 </span>            :                        }</a>
<a name="5200"><span class="lineNum">    5200 </span>            : </a>
<a name="5201"><span class="lineNum">    5201 </span>            :                   // copy_file will only completely override the existing file in Boost 1.46+</a>
<a name="5202"><span class="lineNum">    5202 </span>            :                   // http://stackoverflow.com/questions/14628836/boost-copy-file-has-inconsistent-behavior-when-overwrite-if-exists-is-used</a>
<a name="5203"><span class="lineNum">    5203 </span><span class="lineNoCov">          0 :                     if (boost::filesystem::exists(unparsed_file))</span></a>
<a name="5204"><span class="lineNum">    5204 </span>            :                        {</a>
<a name="5205"><span class="lineNum">    5205 </span><span class="lineNoCov">          0 :                          boost::filesystem::remove(unparsed_file);</span></a>
<a name="5206"><span class="lineNum">    5206 </span>            :                        }</a>
<a name="5207"><span class="lineNum">    5207 </span>            : #if 0</a>
<a name="5208"><span class="lineNum">    5208 </span>            :                     printf (&quot;NOTE: keep_going option supporting direct copy of original input file to overwrite the unparsed file \n&quot;);</a>
<a name="5209"><span class="lineNum">    5209 </span>            : #endif</a>
<a name="5210"><span class="lineNum">    5210 </span><span class="lineNoCov">          0 :                     Rose::FileSystem::copyFile(original_file, unparsed_file);</span></a>
<a name="5211"><span class="lineNum">    5211 </span>            :                   }</a>
<a name="5212"><span class="lineNum">    5212 </span>            :              }</a>
<a name="5213"><span class="lineNum">    5213 </span>            : </a>
<a name="5214"><span class="lineNum">    5214 </span>            : #if 0</a>
<a name="5215"><span class="lineNum">    5215 </span>            :        // DQ (11/8/2015): Commented out to avoid output spew.</a>
<a name="5216"><span class="lineNum">    5216 </span>            :           printf (&quot;In SgFile::compileOutput(): outputFilename = %s \n&quot;,outputFilename.c_str());</a>
<a name="5217"><span class="lineNum">    5217 </span>            : #endif</a>
<a name="5218"><span class="lineNum">    5218 </span><span class="lineNoCov">          0 :           set_unparse_output_filename(outputFilename);</span></a>
<a name="5219"><span class="lineNum">    5219 </span>            :         }</a>
<a name="5220"><span class="lineNum">    5220 </span>            : #endif</a>
<a name="5221"><span class="lineNum">    5221 </span>            : </a>
<a name="5222"><span class="lineNum">    5222 </span><span class="lineCov">        347 :      ROSE_ASSERT (get_unparse_output_filename().empty() == false); // TODO: may need to add condition:  &quot;&amp;&amp; (! get_Java_only())&quot;  here</span></a>
<a name="5223"><span class="lineNum">    5223 </span>            : </a>
<a name="5224"><span class="lineNum">    5224 </span>            :   // Now call the compiler that rose is replacing</a>
<a name="5225"><span class="lineNum">    5225 </span>            :   // if (get_useBackendOnly() == false)</a>
<a name="5226"><span class="lineNum">    5226 </span><span class="lineCov">        347 :      if ( SgProject::get_verbose() &gt;= 1 )</span></a>
<a name="5227"><span class="lineNum">    5227 </span>            :         {</a>
<a name="5228"><span class="lineNum">    5228 </span><span class="lineNoCov">          0 :           printf (&quot;Now call the backend (vendor's) compiler compilerNameOrig = %s for file = %s \n&quot;,compilerNameOrig.c_str(),get_unparse_output_filename().c_str());</span></a>
<a name="5229"><span class="lineNum">    5229 </span>            :         }</a>
<a name="5230"><span class="lineNum">    5230 </span>            : </a>
<a name="5231"><span class="lineNum">    5231 </span>            :   // Build the commandline to hand off to the C++/C compiler</a>
<a name="5232"><span class="lineNum">    5232 </span><span class="lineCov">        694 :      vector&lt;string&gt; compilerCmdLine = buildCompilerCommandLineOptions (argv,fileNameIndex, compilerName );</span></a>
<a name="5233"><span class="lineNum">    5233 </span>            : </a>
<a name="5234"><span class="lineNum">    5234 </span>            : #if 0</a>
<a name="5235"><span class="lineNum">    5235 </span>            :   // DQ (3/15/2020): There are only two places where this is called (here and in the CompilerOutputParser::processFile() function).</a>
<a name="5236"><span class="lineNum">    5236 </span>            :      printf (&quot;In SgFile::compileOutput(): After buildCompilerCommandLineOptions(): compilerCmdLine.size() = %&quot; PRIuPTR &quot; compilerCmdLine = %s \n&quot;,compilerCmdLine.size(),StringUtility::listToString(compilerCmdLine).c_str());</a>
<a name="5237"><span class="lineNum">    5237 </span>            : #endif</a>
<a name="5238"><span class="lineNum">    5238 </span>            : </a>
<a name="5239"><span class="lineNum">    5239 </span>            : #if 0</a>
<a name="5240"><span class="lineNum">    5240 </span>            :      printf (&quot;Exiting as a test! \n&quot;);</a>
<a name="5241"><span class="lineNum">    5241 </span>            :      ROSE_ABORT();</a>
<a name="5242"><span class="lineNum">    5242 </span>            : #endif</a>
<a name="5243"><span class="lineNum">    5243 </span>            : </a>
<a name="5244"><span class="lineNum">    5244 </span>            :   // Support for compiling .C files as C++ on Visual Studio</a>
<a name="5245"><span class="lineNum">    5245 </span>            : #ifdef _MSC_VER</a>
<a name="5246"><span class="lineNum">    5246 </span>            :      if (get_Cxx_only() == true)</a>
<a name="5247"><span class="lineNum">    5247 </span>            :         {</a>
<a name="5248"><span class="lineNum">    5248 </span>            :           vector&lt;string&gt;::iterator pos = compilerCmdLine.begin() + 1;</a>
<a name="5249"><span class="lineNum">    5249 </span>            :           compilerCmdLine.insert(pos, &quot;/TP&quot;);</a>
<a name="5250"><span class="lineNum">    5250 </span>            :         }</a>
<a name="5251"><span class="lineNum">    5251 </span>            : #endif</a>
<a name="5252"><span class="lineNum">    5252 </span>            : </a>
<a name="5253"><span class="lineNum">    5253 </span><span class="lineCov">        347 :      int returnValueForCompiler = 0;</span></a>
<a name="5254"><span class="lineNum">    5254 </span>            : </a>
<a name="5255"><span class="lineNum">    5255 </span>            :   // error checking</a>
<a name="5256"><span class="lineNum">    5256 </span>            :   // display(&quot;Called from SgFile::compileOutput()&quot;);</a>
<a name="5257"><span class="lineNum">    5257 </span>            : </a>
<a name="5258"><span class="lineNum">    5258 </span>            :   // Allow conditional skipping of the final compile step for testing ROSE.</a>
<a name="5259"><span class="lineNum">    5259 </span>            :   // printf (&quot;SgFile::compileOutput(): get_skipfinalCompileStep() = %s \n&quot;,get_skipfinalCompileStep() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="5260"><span class="lineNum">    5260 </span><span class="lineCov">        347 :      if (get_skipfinalCompileStep() == false)</span></a>
<a name="5261"><span class="lineNum">    5261 </span>            :         {</a>
<a name="5262"><span class="lineNum">    5262 </span>            :        // Debugging code</a>
<a name="5263"><span class="lineNum">    5263 </span><span class="lineCov">        332 :           if ( get_verbose() &gt;= 1 )</span></a>
<a name="5264"><span class="lineNum">    5264 </span>            :              {</a>
<a name="5265"><span class="lineNum">    5265 </span><span class="lineNoCov">          0 :                printf (&quot;calling systemFromVector() \n&quot;);</span></a>
<a name="5266"><span class="lineNum">    5266 </span><span class="lineNoCov">          0 :                printf (&quot;Number of command line arguments: %&quot; PRIuPTR &quot;\n&quot;, compilerCmdLine.size());</span></a>
<a name="5267"><span class="lineNum">    5267 </span><span class="lineNoCov">          0 :                for (size_t i = 0; i &lt; compilerCmdLine.size(); ++i)</span></a>
<a name="5268"><span class="lineNum">    5268 </span>            :                   {</a>
<a name="5269"><span class="lineNum">    5269 </span>            : #ifdef _MSC_VER</a>
<a name="5270"><span class="lineNum">    5270 </span>            :                     printf (&quot;Backend compiler arg[%Iu]: = %s\n&quot;, i, compilerCmdLine[i].c_str());</a>
<a name="5271"><span class="lineNum">    5271 </span>            : #else</a>
<a name="5272"><span class="lineNum">    5272 </span><span class="lineNoCov">          0 :                     printf (&quot;Backend compiler arg[%&quot; PRIuPTR &quot;]: = %s\n&quot;, i, compilerCmdLine[i].c_str());</span></a>
<a name="5273"><span class="lineNum">    5273 </span>            : #endif</a>
<a name="5274"><span class="lineNum">    5274 </span>            :                   }</a>
<a name="5275"><span class="lineNum">    5275 </span><span class="lineNoCov">          0 :                printf(&quot;End of command line for backend compiler\n&quot;);</span></a>
<a name="5276"><span class="lineNum">    5276 </span>            : </a>
<a name="5277"><span class="lineNum">    5277 </span>            :             // DQ (6/19/2020): Error checking for embedded application name.</a>
<a name="5278"><span class="lineNum">    5278 </span><span class="lineNoCov">          0 :                string finalCommandLine = CommandlineProcessing::generateStringFromArgList(compilerCmdLine,false,false);</span></a>
<a name="5279"><span class="lineNum">    5279 </span><span class="lineNoCov">          0 :                printf (&quot;finalCommandLine = %s \n&quot;,finalCommandLine.c_str());</span></a>
<a name="5280"><span class="lineNum">    5280 </span><span class="lineNoCov">          0 :                size_t substringPosition = finalCommandLine.find(&quot;TestUnparseHeaders&quot;);</span></a>
<a name="5281"><span class="lineNum">    5281 </span><span class="lineNoCov">          0 :                printf (&quot;substringPosition = %zu \n&quot;,substringPosition);</span></a>
<a name="5282"><span class="lineNum">    5282 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(substringPosition == string::npos);</span></a>
<a name="5283"><span class="lineNum">    5283 </span>            : </a>
<a name="5284"><span class="lineNum">    5284 </span>            :             // I need the exact command line used to compile the generate code with the backendcompiler (so that I can reuse it to test the generated code).</a>
<a name="5285"><span class="lineNum">    5285 </span><span class="lineNoCov">          0 :                printf (&quot;SgFile::compileOutput(): get_skipfinalCompileStep() == false: compilerCmdLine = \n%s\n&quot;,CommandlineProcessing::generateStringFromArgList(compilerCmdLine,false,false).c_str());</span></a>
<a name="5286"><span class="lineNum">    5286 </span>            :              }</a>
<a name="5287"><span class="lineNum">    5287 </span>            : #if 0</a>
<a name="5288"><span class="lineNum">    5288 </span>            :           printf (&quot;In SgFile::compileOutput(): get_compileOnly() = %s \n&quot;,get_compileOnly() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="5289"><span class="lineNum">    5289 </span>            : #endif</a>
<a name="5290"><span class="lineNum">    5290 </span>            :        // DQ (4/18/2015): Adding support to add compile only mode to the processing of each file when multiple files are processed.</a>
<a name="5291"><span class="lineNum">    5291 </span><span class="lineCov">        332 :           if (get_compileOnly() == true)</span></a>
<a name="5292"><span class="lineNum">    5292 </span>            :              {</a>
<a name="5293"><span class="lineNum">    5293 </span>            :                bool addCompileOnlyFlag = true;</a>
<a name="5294"><span class="lineNum">    5294 </span>            : </a>
<a name="5295"><span class="lineNum">    5295 </span><span class="lineCov">       4385 :                for (size_t i = 0; i &lt; compilerCmdLine.size(); ++i)</span></a>
<a name="5296"><span class="lineNum">    5296 </span>            :                   {</a>
<a name="5297"><span class="lineNum">    5297 </span><span class="lineCov">       4056 :                     if (compilerCmdLine[i] == &quot;-c&quot;)</span></a>
<a name="5298"><span class="lineNum">    5298 </span>            :                        {</a>
<a name="5299"><span class="lineNum">    5299 </span><span class="lineCov">        329 :                          addCompileOnlyFlag = false;</span></a>
<a name="5300"><span class="lineNum">    5300 </span>            :                        }</a>
<a name="5301"><span class="lineNum">    5301 </span>            :                   }</a>
<a name="5302"><span class="lineNum">    5302 </span>            : </a>
<a name="5303"><span class="lineNum">    5303 </span>            : #if DEBUG_PROJECT_COMPILE_COMMAND_LINE_WITH_ARGS || 0</a>
<a name="5304"><span class="lineNum">    5304 </span>            :                printf (&quot;addCompileOnlyFlag = %s \n&quot;,addCompileOnlyFlag ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="5305"><span class="lineNum">    5305 </span>            : #endif</a>
<a name="5306"><span class="lineNum">    5306 </span><span class="lineCov">        329 :                if (addCompileOnlyFlag == true)</span></a>
<a name="5307"><span class="lineNum">    5307 </span>            :                   {</a>
<a name="5308"><span class="lineNum">    5308 </span>            :                  // We might want to check if &quot;-c&quot; is already present so we don't add it redundantly.</a>
<a name="5309"><span class="lineNum">    5309 </span>            : #if 0</a>
<a name="5310"><span class="lineNum">    5310 </span>            :                     printf (&quot;Adding \&quot;-c\&quot; to the backend command line \n&quot;);</a>
<a name="5311"><span class="lineNum">    5311 </span>            : #endif</a>
<a name="5312"><span class="lineNum">    5312 </span><span class="lineNoCov">          0 :                     compilerCmdLine.push_back(&quot;-c&quot;);</span></a>
<a name="5313"><span class="lineNum">    5313 </span>            :                   }</a>
<a name="5314"><span class="lineNum">    5314 </span>            : </a>
<a name="5315"><span class="lineNum">    5315 </span>            : #if DEBUG_PROJECT_COMPILE_COMMAND_LINE_WITH_ARGS || 0</a>
<a name="5316"><span class="lineNum">    5316 </span>            :                printf (&quot;In SgFile::compileOutput(): get_skipfinalCompileStep() == false: get_compileOnly() == true: compilerCmdLine = \n%s\n&quot;,CommandlineProcessing::generateStringFromArgList(compilerCmdLine,false,false).c_str());</a>
<a name="5317"><span class="lineNum">    5317 </span>            : #endif</a>
<a name="5318"><span class="lineNum">    5318 </span>            : </a>
<a name="5319"><span class="lineNum">    5319 </span>            : #if 0</a>
<a name="5320"><span class="lineNum">    5320 </span>            :                printf (&quot;Exiting as a test! \n&quot;);</a>
<a name="5321"><span class="lineNum">    5321 </span>            :                ROSE_ABORT();</a>
<a name="5322"><span class="lineNum">    5322 </span>            : #endif</a>
<a name="5323"><span class="lineNum">    5323 </span>            :              }</a>
<a name="5324"><span class="lineNum">    5324 </span>            : </a>
<a name="5325"><span class="lineNum">    5325 </span>            : #if DEBUG_PROJECT_COMPILE_COMMAND_LINE_WITH_ARGS || 0</a>
<a name="5326"><span class="lineNum">    5326 </span>            :           printf (&quot;In SgFile::compileOutput(): Calling systemFromVector(): compilerCmdLine = \n%s\n&quot;,CommandlineProcessing::generateStringFromArgList(compilerCmdLine,false,false).c_str());</a>
<a name="5327"><span class="lineNum">    5327 </span>            : #endif</a>
<a name="5328"><span class="lineNum">    5328 </span>            : </a>
<a name="5329"><span class="lineNum">    5329 </span>            :        // DQ (2/20/2013): The timer used in TimingPerformance is now fixed to properly record elapsed wall clock time.</a>
<a name="5330"><span class="lineNum">    5330 </span>            :        // CAVE3 double check that is correct and shouldn't be compilerCmdLine</a>
<a name="5331"><span class="lineNum">    5331 </span><span class="lineCov">        332 :           returnValueForCompiler = systemFromVector (compilerCmdLine);</span></a>
<a name="5332"><span class="lineNum">    5332 </span>            : </a>
<a name="5333"><span class="lineNum">    5333 </span>            : #if 0</a>
<a name="5334"><span class="lineNum">    5334 </span>            :           printf (&quot;In SgFile::compileOutput(): Calling systemFromVector(): returnValueForCompiler = %d \n&quot;,returnValueForCompiler);</a>
<a name="5335"><span class="lineNum">    5335 </span>            : #endif</a>
<a name="5336"><span class="lineNum">    5336 </span>            : </a>
<a name="5337"><span class="lineNum">    5337 </span>            :        // TOO1 (05/14/2013): Handling for -rose:keep_going</a>
<a name="5338"><span class="lineNum">    5338 </span>            :        //</a>
<a name="5339"><span class="lineNum">    5339 </span>            :        // Compilation failed =&gt;</a>
<a name="5340"><span class="lineNum">    5340 </span>            :        //</a>
<a name="5341"><span class="lineNum">    5341 </span>            :        //   1. Unparsed file is invalid =&gt; Try compiling the original input file</a>
<a name="5342"><span class="lineNum">    5342 </span>            :        //   2. Original input file is invalid =&gt; abort</a>
<a name="5343"><span class="lineNum">    5343 </span><span class="lineCov">        332 :           if (returnValueForCompiler != 0)</span></a>
<a name="5344"><span class="lineNum">    5344 </span>            :              {</a>
<a name="5345"><span class="lineNum">    5345 </span><span class="lineNoCov">          0 :                this-&gt;set_backendCompilerErrorCode(-1);</span></a>
<a name="5346"><span class="lineNum">    5346 </span><span class="lineNoCov">          0 :                if (this-&gt;get_project()-&gt;get_keep_going() == true)</span></a>
<a name="5347"><span class="lineNum">    5347 </span>            :                   {</a>
<a name="5348"><span class="lineNum">    5348 </span>            :                  // 1. We already failed the compilation of the ROSE unparsed file.</a>
<a name="5349"><span class="lineNum">    5349 </span>            :                  // 2. Now we tried to compile the original input file --</a>
<a name="5350"><span class="lineNum">    5350 </span>            :                  //    that was just compiled above -- and failed also.</a>
<a name="5351"><span class="lineNum">    5351 </span><span class="lineNoCov">          0 :                     if (this-&gt;get_unparsedFileFailedCompilation())</span></a>
<a name="5352"><span class="lineNum">    5352 </span>            :                        {</a>
<a name="5353"><span class="lineNum">    5353 </span><span class="lineNoCov">          0 :                          this-&gt;set_backendCompilerErrorCode(-1);</span></a>
<a name="5354"><span class="lineNum">    5354 </span>            :                          // TOO1 (11/16/2013): TODO: Allow user to catch InvalidOriginalInputFileException?</a>
<a name="5355"><span class="lineNum">    5355 </span>            :                          //throw std::runtime_error(&quot;Original input file is invalid&quot;);</a>
<a name="5356"><span class="lineNum">    5356 </span><span class="lineNoCov">          0 :                          std::cout  &lt;&lt; &quot;[FATAL] &quot;</span></a>
<a name="5357"><span class="lineNum">    5357 </span>            :                                     &lt;&lt; &quot;Original input file is invalid: &quot;</a>
<a name="5358"><span class="lineNum">    5358 </span><span class="lineNoCov">          0 :                                     &lt;&lt; &quot;'&quot; &lt;&lt; this-&gt;getFileName() &lt;&lt; &quot;'&quot;</span></a>
<a name="5359"><span class="lineNum">    5359 </span><span class="lineNoCov">          0 :                                     &lt;&lt; &quot;\n\treported by &quot; &lt;&lt; __FILE__ &lt;&lt;&quot;:&quot;&lt;&lt;__LINE__ &lt;&lt;std::endl;</span></a>
<a name="5360"><span class="lineNum">    5360 </span><span class="lineNoCov">          0 :                          if (Rose::KeepGoing::g_keep_going)</span></a>
<a name="5361"><span class="lineNum">    5361 </span><span class="lineNoCov">          0 :                            raise(SIGABRT); // raise a signal to be handled by the keep going support , instead of exit. Liao 4/25/2017</span></a>
<a name="5362"><span class="lineNum">    5362 </span>            :                          else</a>
<a name="5363"><span class="lineNum">    5363 </span><span class="lineNoCov">          0 :                            exit(1);</span></a>
<a name="5364"><span class="lineNum">    5364 </span>            :                        }</a>
<a name="5365"><span class="lineNum">    5365 </span>            :                       else</a>
<a name="5366"><span class="lineNum">    5366 </span>            :                       {</a>
<a name="5367"><span class="lineNum">    5367 </span>            :                         // The ROSE unparsed file is invalid...</a>
<a name="5368"><span class="lineNum">    5368 </span><span class="lineNoCov">          0 :                         this-&gt;set_frontendErrorCode(-1);</span></a>
<a name="5369"><span class="lineNum">    5369 </span><span class="lineNoCov">          0 :                         this-&gt;set_unparsedFileFailedCompilation(true);</span></a>
<a name="5370"><span class="lineNum">    5370 </span>            : </a>
<a name="5371"><span class="lineNum">    5371 </span><span class="lineNoCov">          0 :                          returnValueForCompiler = this-&gt;compileOutput(argv, fileNameIndex);</span></a>
<a name="5372"><span class="lineNum">    5372 </span>            :                       }</a>
<a name="5373"><span class="lineNum">    5373 </span>            :                   }</a>
<a name="5374"><span class="lineNum">    5374 </span>            :              }</a>
<a name="5375"><span class="lineNum">    5375 </span>            :          } //if (get_skipfinalCompileStep() == false)</a>
<a name="5376"><span class="lineNum">    5376 </span>            :        else</a>
<a name="5377"><span class="lineNum">    5377 </span>            :         {</a>
<a name="5378"><span class="lineNum">    5378 </span><span class="lineCov">         15 :           if ( get_verbose() &gt; 1 )</span></a>
<a name="5379"><span class="lineNum">    5379 </span><span class="lineNoCov">          0 :                printf (&quot;COMPILER NOT CALLED: compilerNameString = %s \n&quot;, &quot;&lt;unknown&gt;&quot; /* compilerNameString.c_str() */);</span></a>
<a name="5380"><span class="lineNum">    5380 </span>            :         }</a>
<a name="5381"><span class="lineNum">    5381 </span>            : </a>
<a name="5382"><span class="lineNum">    5382 </span>            :   // DQ (7/20/2006): Catch errors returned from unix &quot;system&quot; function</a>
<a name="5383"><span class="lineNum">    5383 </span>            :   // (commonly &quot;out of memory&quot; errors, suggested by Peter and Jeremiah).</a>
<a name="5384"><span class="lineNum">    5384 </span><span class="lineCov">        332 :      if (returnValueForCompiler &lt; 0)</span></a>
<a name="5385"><span class="lineNum">    5385 </span>            :         {</a>
<a name="5386"><span class="lineNum">    5386 </span><span class="lineNoCov">          0 :           perror(&quot;Serious Error returned from internal systemFromVector command&quot;);</span></a>
<a name="5387"><span class="lineNum">    5387 </span>            :         }</a>
<a name="5388"><span class="lineNum">    5388 </span>            : </a>
<a name="5389"><span class="lineNum">    5389 </span>            :   // Assemble an exit status that combines the values for ROSE and the C++/C compiler</a>
<a name="5390"><span class="lineNum">    5390 </span>            :   // return an exit status which is the boolean OR of the bits from the EDG/SAGE/ROSE and the compile step</a>
<a name="5391"><span class="lineNum">    5391 </span><span class="lineCov">        347 :      int finalCompiledExitStatus = returnValueForRose | returnValueForCompiler;</span></a>
<a name="5392"><span class="lineNum">    5392 </span>            : </a>
<a name="5393"><span class="lineNum">    5393 </span>            :   // It is a strange property of the UNIX $status that it does not map uniformally from</a>
<a name="5394"><span class="lineNum">    5394 </span>            :   // the return value of the &quot;exit&quot; command (or &quot;return&quot; statement).  So if the exit</a>
<a name="5395"><span class="lineNum">    5395 </span>            :   // status from the compilation stage is nonzero then we just make the exit status 1</a>
<a name="5396"><span class="lineNum">    5396 </span>            :   // (this does seem to be a portable solution).</a>
<a name="5397"><span class="lineNum">    5397 </span>            :   // FYI: only the first 8 bits of the exit value are significant (Solaris uses 'exit_value mod 256').</a>
<a name="5398"><span class="lineNum">    5398 </span><span class="lineCov">        347 :      if (finalCompiledExitStatus != 0)</span></a>
<a name="5399"><span class="lineNum">    5399 </span>            :         {</a>
<a name="5400"><span class="lineNum">    5400 </span>            :        // If this it is non-zero then make it 1 to be more clear to external tools (e.g. make)</a>
<a name="5401"><span class="lineNum">    5401 </span><span class="lineNoCov">          0 :           finalCompiledExitStatus = 1;</span></a>
<a name="5402"><span class="lineNum">    5402 </span>            :         }</a>
<a name="5403"><span class="lineNum">    5403 </span>            : </a>
<a name="5404"><span class="lineNum">    5404 </span>            :   // DQ (9/19/2006): We need to invert the test result (return code) for</a>
<a name="5405"><span class="lineNum">    5405 </span>            :   // negative tests (where failure is expected and success is an error).</a>
<a name="5406"><span class="lineNum">    5406 </span><span class="lineCov">        347 :      if (get_negative_test() == true)</span></a>
<a name="5407"><span class="lineNum">    5407 </span>            :         {</a>
<a name="5408"><span class="lineNum">    5408 </span><span class="lineNoCov">          0 :           if ( get_verbose() &gt; 1 )</span></a>
<a name="5409"><span class="lineNum">    5409 </span><span class="lineNoCov">          0 :                printf (&quot;This is a negative tests, so an error in compilation is a PASS and successful compilation is a FAIL (vendor compiler return value = %d) \n&quot;,returnValueForCompiler);</span></a>
<a name="5410"><span class="lineNum">    5410 </span>            : </a>
<a name="5411"><span class="lineNum">    5411 </span><span class="lineNoCov">          0 :           finalCompiledExitStatus = (finalCompiledExitStatus == 0) ? /* error */ 1 : /* success */ 0;</span></a>
<a name="5412"><span class="lineNum">    5412 </span>            :         }</a>
<a name="5413"><span class="lineNum">    5413 </span>            : </a>
<a name="5414"><span class="lineNum">    5414 </span>            : #if 0</a>
<a name="5415"><span class="lineNum">    5415 </span>            :      printf (&quot;Program Terminated Normally (exit status = %d)! \n\n\n\n&quot;,finalCompiledExitStatus);</a>
<a name="5416"><span class="lineNum">    5416 </span>            : #endif</a>
<a name="5417"><span class="lineNum">    5417 </span>            : </a>
<a name="5418"><span class="lineNum">    5418 </span>            :   // Liao, 4/26/2017. KeepGoingTranslator should keep going no mater what.</a>
<a name="5419"><span class="lineNum">    5419 </span><span class="lineCov">        347 :      if (Rose::KeepGoing::g_keep_going)</span></a>
<a name="5420"><span class="lineNum">    5420 </span>            :         {</a>
<a name="5421"><span class="lineNum">    5421 </span><span class="lineNoCov">          0 :           finalCompiledExitStatus = 0;</span></a>
<a name="5422"><span class="lineNum">    5422 </span>            :         }</a>
<a name="5423"><span class="lineNum">    5423 </span>            : </a>
<a name="5424"><span class="lineNum">    5424 </span><span class="lineCov">        694 :      return finalCompiledExitStatus;</span></a>
<a name="5425"><span class="lineNum">    5425 </span>            :    }</a>
<a name="5426"><span class="lineNum">    5426 </span>            : </a>
<a name="5427"><span class="lineNum">    5427 </span>            : </a>
<a name="5428"><span class="lineNum">    5428 </span>            : //! project level compilation and linking</a>
<a name="5429"><span class="lineNum">    5429 </span>            : // three cases: 1. preprocessing only</a>
<a name="5430"><span class="lineNum">    5430 </span>            : //              2. compilation:</a>
<a name="5431"><span class="lineNum">    5431 </span>            : //              3. linking:</a>
<a name="5432"><span class="lineNum">    5432 </span>            : // int SgProject::compileOutput( const std::string&amp; compilerName )</a>
<a name="5433"><span class="lineNum">    5433 </span>            : int</a>
<a name="5434"><span class="lineNum">    5434 </span><span class="lineCov">        346 : SgProject::compileOutput()</span></a>
<a name="5435"><span class="lineNum">    5435 </span>            :    {</a>
<a name="5436"><span class="lineNum">    5436 </span>            :   // DQ (7/6/2005): Introduce tracking of performance of ROSE.</a>
<a name="5437"><span class="lineNum">    5437 </span><span class="lineCov">        346 :      TimingPerformance timer (&quot;AST Backend Compilation (SgProject):&quot;);</span></a>
<a name="5438"><span class="lineNum">    5438 </span>            : </a>
<a name="5439"><span class="lineNum">    5439 </span><span class="lineCov">        346 :      int errorCode = 0;</span></a>
<a name="5440"><span class="lineNum">    5440 </span><span class="lineCov">        346 :      int linkingReturnVal = 0;</span></a>
<a name="5441"><span class="lineNum">    5441 </span><span class="lineCov">        346 :      int i = 0;</span></a>
<a name="5442"><span class="lineNum">    5442 </span>            : </a>
<a name="5443"><span class="lineNum">    5443 </span><span class="lineCov">        692 :      std::string compilerName;</span></a>
<a name="5444"><span class="lineNum">    5444 </span>            : </a>
<a name="5445"><span class="lineNum">    5445 </span>            : #define DEBUG_PROJECT_COMPILE_COMMAND_LINE 0</a>
<a name="5446"><span class="lineNum">    5446 </span>            : </a>
<a name="5447"><span class="lineNum">    5447 </span>            : #if 0</a>
<a name="5448"><span class="lineNum">    5448 </span>            :      vector&lt;string&gt; tmp_argv = get_originalCommandLineArgumentList();</a>
<a name="5449"><span class="lineNum">    5449 </span>            :      printf (&quot;In SgProject::compileOutput(): listToString(originalCommandLine) = %s \n&quot;,StringUtility::listToString(tmp_argv).c_str());</a>
<a name="5450"><span class="lineNum">    5450 </span>            : #endif</a>
<a name="5451"><span class="lineNum">    5451 </span>            : </a>
<a name="5452"><span class="lineNum">    5452 </span>            : #if 0</a>
<a name="5453"><span class="lineNum">    5453 </span>            :      display(&quot;In SgProject::compileOutput(): debugging&quot;);</a>
<a name="5454"><span class="lineNum">    5454 </span>            : #endif</a>
<a name="5455"><span class="lineNum">    5455 </span>            : </a>
<a name="5456"><span class="lineNum">    5456 </span>            :   // DQ (1/19/2014): Adding support for gnu &quot;-S&quot; option.</a>
<a name="5457"><span class="lineNum">    5457 </span><span class="lineCov">        346 :      if (get_stop_after_compilation_do_not_assemble_file() == true)</span></a>
<a name="5458"><span class="lineNum">    5458 </span>            :         {</a>
<a name="5459"><span class="lineNum">    5459 </span>            :        // DQ (1/19/2014): Handle special case (issue a single compile command for all files using the &quot;-S&quot; option).</a>
<a name="5460"><span class="lineNum">    5460 </span><span class="lineNoCov">          0 :           vector&lt;string&gt; argv = get_originalCommandLineArgumentList();</span></a>
<a name="5461"><span class="lineNum">    5461 </span>            : </a>
<a name="5462"><span class="lineNum">    5462 </span>            :        // strip out any rose options before passing the command line.</a>
<a name="5463"><span class="lineNum">    5463 </span><span class="lineNoCov">          0 :           SgFile::stripRoseCommandLineOptions( argv );</span></a>
<a name="5464"><span class="lineNum">    5464 </span>            : </a>
<a name="5465"><span class="lineNum">    5465 </span>            :        // strip out edg specific options that would cause an error in the backend linker (compiler).</a>
<a name="5466"><span class="lineNum">    5466 </span><span class="lineNoCov">          0 :           SgFile::stripEdgCommandLineOptions( argv );</span></a>
<a name="5467"><span class="lineNum">    5467 </span>            : </a>
<a name="5468"><span class="lineNum">    5468 </span><span class="lineNoCov">          0 :           vector&lt;string&gt; originalCommandLine = argv;</span></a>
<a name="5469"><span class="lineNum">    5469 </span><span class="lineNoCov">          0 :           ROSE_ASSERT (!originalCommandLine.empty());</span></a>
<a name="5470"><span class="lineNum">    5470 </span>            : </a>
<a name="5471"><span class="lineNum">    5471 </span><span class="lineNoCov">          0 :           string &amp; compilerNameString = originalCommandLine[0];</span></a>
<a name="5472"><span class="lineNum">    5472 </span><span class="lineNoCov">          0 :           if (get_C_only() == true)</span></a>
<a name="5473"><span class="lineNum">    5473 </span>            :              {</a>
<a name="5474"><span class="lineNum">    5474 </span><span class="lineNoCov">          0 :                compilerNameString = BACKEND_C_COMPILER_NAME_WITH_PATH;</span></a>
<a name="5475"><span class="lineNum">    5475 </span>            :              }</a>
<a name="5476"><span class="lineNum">    5476 </span>            :             else</a>
<a name="5477"><span class="lineNum">    5477 </span>            :              {</a>
<a name="5478"><span class="lineNum">    5478 </span><span class="lineNoCov">          0 :                printf (&quot;Error: GNU \&quot;-S\&quot; option is not supported for more than the C language in ROSE at present! \n&quot;);</span></a>
<a name="5479"><span class="lineNum">    5479 </span><span class="lineNoCov">          0 :                ROSE_ABORT();</span></a>
<a name="5480"><span class="lineNum">    5480 </span>            :              }</a>
<a name="5481"><span class="lineNum">    5481 </span>            : </a>
<a name="5482"><span class="lineNum">    5482 </span>            : #if 0</a>
<a name="5483"><span class="lineNum">    5483 </span>            :           printf (&quot;Exiting as a test! \n&quot;);</a>
<a name="5484"><span class="lineNum">    5484 </span>            :           ROSE_ABORT();</a>
<a name="5485"><span class="lineNum">    5485 </span>            : #endif</a>
<a name="5486"><span class="lineNum">    5486 </span>            : </a>
<a name="5487"><span class="lineNum">    5487 </span><span class="lineNoCov">          0 :           if ( SgProject::get_verbose() &gt; 0 )</span></a>
<a name="5488"><span class="lineNum">    5488 </span>            :              {</a>
<a name="5489"><span class="lineNum">    5489 </span><span class="lineNoCov">          0 :                printf (&quot;In SgProject::compileOutput(): listToString(originalCommandLine) = %s \n&quot;,StringUtility::listToString(originalCommandLine).c_str());</span></a>
<a name="5490"><span class="lineNum">    5490 </span>            :              }</a>
<a name="5491"><span class="lineNum">    5491 </span>            : </a>
<a name="5492"><span class="lineNum">    5492 </span><span class="lineNoCov">          0 :           errorCode = systemFromVector(originalCommandLine);</span></a>
<a name="5493"><span class="lineNum">    5493 </span>            : </a>
<a name="5494"><span class="lineNum">    5494 </span><span class="lineNoCov">          0 :           return errorCode + linkingReturnVal;</span></a>
<a name="5495"><span class="lineNum">    5495 </span>            :         }</a>
<a name="5496"><span class="lineNum">    5496 </span>            : </a>
<a name="5497"><span class="lineNum">    5497 </span>            : </a>
<a name="5498"><span class="lineNum">    5498 </span><span class="lineCov">        346 :      if (numberOfFiles() == 0)</span></a>
<a name="5499"><span class="lineNum">    5499 </span>            :         {</a>
<a name="5500"><span class="lineNum">    5500 </span>            :        // printf (&quot;Note in SgProject::compileOutput(%s): numberOfFiles() == 0 \n&quot;,compilerName.c_str());</a>
<a name="5501"><span class="lineNum">    5501 </span>            :        // printf (&quot;ROSE using %s as backend compiler: no input files \n&quot;,compilerName.c_str());</a>
<a name="5502"><span class="lineNum">    5502 </span>            : </a>
<a name="5503"><span class="lineNum">    5503 </span>            :        // DQ (8/24/2008): We can't recreate same behavior on exit as GNU on exit with no</a>
<a name="5504"><span class="lineNum">    5504 </span>            :        // files since it causes the test immediately after building librose.so to fail.</a>
<a name="5505"><span class="lineNum">    5505 </span>            :        // exit(1);</a>
<a name="5506"><span class="lineNum">    5506 </span>            :         }</a>
<a name="5507"><span class="lineNum">    5507 </span>            : </a>
<a name="5508"><span class="lineNum">    5508 </span>            :   // NOTE: that get_C_PreprocessorOnly() is true only if using the &quot;-E&quot; option and not for the &quot;-edg:E&quot; option.</a>
<a name="5509"><span class="lineNum">    5509 </span>            : #if 0</a>
<a name="5510"><span class="lineNum">    5510 </span>            :      printf (&quot;In SgProject::compileOutput(): get_C_PreprocessorOnly() = %s \n&quot;,get_C_PreprocessorOnly() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="5511"><span class="lineNum">    5511 </span>            : #endif</a>
<a name="5512"><span class="lineNum">    5512 </span>            : </a>
<a name="5513"><span class="lineNum">    5513 </span>            :   // case 1: preprocessing only</a>
<a name="5514"><span class="lineNum">    5514 </span><span class="lineCov">        346 :      if (get_C_PreprocessorOnly() == true)</span></a>
<a name="5515"><span class="lineNum">    5515 </span>            :         {</a>
<a name="5516"><span class="lineNum">    5516 </span>            :        // DQ (10/16/2005): Handle special case (issue a single compile command for all files)</a>
<a name="5517"><span class="lineNum">    5517 </span><span class="lineNoCov">          0 :           vector&lt;string&gt; argv = get_originalCommandLineArgumentList();</span></a>
<a name="5518"><span class="lineNum">    5518 </span>            : </a>
<a name="5519"><span class="lineNum">    5519 </span>            :        // strip out any rose options before passing the command line.</a>
<a name="5520"><span class="lineNum">    5520 </span><span class="lineNoCov">          0 :           SgFile::stripRoseCommandLineOptions( argv );</span></a>
<a name="5521"><span class="lineNum">    5521 </span>            : </a>
<a name="5522"><span class="lineNum">    5522 </span>            :        // strip out edg specific options that would cause an error in the backend linker (compiler).</a>
<a name="5523"><span class="lineNum">    5523 </span><span class="lineNoCov">          0 :           SgFile::stripEdgCommandLineOptions( argv );</span></a>
<a name="5524"><span class="lineNum">    5524 </span>            : </a>
<a name="5525"><span class="lineNum">    5525 </span>            :        // Skip the name of the ROSE translator (so that we can insert the backend compiler name, below)</a>
<a name="5526"><span class="lineNum">    5526 </span>            :        // bool skipInitialEntry = true;</a>
<a name="5527"><span class="lineNum">    5527 </span>            : </a>
<a name="5528"><span class="lineNum">    5528 </span>            :        // Include all the specified source files</a>
<a name="5529"><span class="lineNum">    5529 </span>            :        // bool skipSourceFiles  = false;</a>
<a name="5530"><span class="lineNum">    5530 </span>            : </a>
<a name="5531"><span class="lineNum">    5531 </span><span class="lineNoCov">          0 :           vector&lt;string&gt; originalCommandLine = argv;</span></a>
<a name="5532"><span class="lineNum">    5532 </span><span class="lineNoCov">          0 :           ROSE_ASSERT (!originalCommandLine.empty());</span></a>
<a name="5533"><span class="lineNum">    5533 </span>            : </a>
<a name="5534"><span class="lineNum">    5534 </span>            :        // DQ (8/13/2006): Use the path to the compiler specified as that backend compiler (should not be specifi to GNU!)</a>
<a name="5535"><span class="lineNum">    5535 </span>            :        // DQ (8/6/2006): Test for g++ and use gcc with &quot;-E&quot; option</a>
<a name="5536"><span class="lineNum">    5536 </span>            :        // (makes a different for header file processing in ARES configuration)</a>
<a name="5537"><span class="lineNum">    5537 </span>            :        // string compilerNameString = compilerName;</a>
<a name="5538"><span class="lineNum">    5538 </span><span class="lineNoCov">          0 :           string &amp; compilerNameString = originalCommandLine[0];</span></a>
<a name="5539"><span class="lineNum">    5539 </span><span class="lineNoCov">          0 :           if (get_C_only() == true)</span></a>
<a name="5540"><span class="lineNum">    5540 </span>            :              {</a>
<a name="5541"><span class="lineNum">    5541 </span><span class="lineNoCov">          0 :                compilerNameString = BACKEND_C_COMPILER_NAME_WITH_PATH;</span></a>
<a name="5542"><span class="lineNum">    5542 </span>            :              }</a>
<a name="5543"><span class="lineNum">    5543 </span>            :             else</a>
<a name="5544"><span class="lineNum">    5544 </span>            :              {</a>
<a name="5545"><span class="lineNum">    5545 </span><span class="lineNoCov">          0 :                compilerNameString = BACKEND_CXX_COMPILER_NAME_WITH_PATH;</span></a>
<a name="5546"><span class="lineNum">    5546 </span><span class="lineNoCov">          0 :                if (get_Fortran_only() == true)</span></a>
<a name="5547"><span class="lineNum">    5547 </span>            :                   {</a>
<a name="5548"><span class="lineNum">    5548 </span><span class="lineNoCov">          0 :                     compilerNameString = &quot;f77&quot;;</span></a>
<a name="5549"><span class="lineNum">    5549 </span>            :                   }</a>
<a name="5550"><span class="lineNum">    5550 </span>            :              }</a>
<a name="5551"><span class="lineNum">    5551 </span>            : </a>
<a name="5552"><span class="lineNum">    5552 </span>            :           // TOO1 (2014-10-09): Use the correct Boost version that ROSE was configured --with-boost</a>
<a name="5553"><span class="lineNum">    5553 </span>            : #ifdef ROSE_BOOST_PATH</a>
<a name="5554"><span class="lineNum">    5554 </span><span class="lineNoCov">          0 :           if (get_C_only() || get_Cxx_only())</span></a>
<a name="5555"><span class="lineNum">    5555 </span>            :              {</a>
<a name="5556"><span class="lineNum">    5556 </span>            :             // Search dir for header files, after all directories specified by -I but</a>
<a name="5557"><span class="lineNum">    5557 </span>            :             // before the standard system directories.</a>
<a name="5558"><span class="lineNum">    5558 </span><span class="lineNoCov">          0 :                originalCommandLine.push_back(&quot;-isystem&quot;);</span></a>
<a name="5559"><span class="lineNum">    5559 </span><span class="lineNoCov">          0 :                originalCommandLine.push_back(std::string(ROSE_BOOST_PATH) + &quot;/include&quot;);</span></a>
<a name="5560"><span class="lineNum">    5560 </span>            :              }</a>
<a name="5561"><span class="lineNum">    5561 </span>            : #endif</a>
<a name="5562"><span class="lineNum">    5562 </span>            : </a>
<a name="5563"><span class="lineNum">    5563 </span>            :        // DQ (8/13/2006): Add a space to avoid building &quot;g++-E&quot; as output.</a>
<a name="5564"><span class="lineNum">    5564 </span>            :        // compilerNameString += &quot; &quot;;</a>
<a name="5565"><span class="lineNum">    5565 </span>            : </a>
<a name="5566"><span class="lineNum">    5566 </span>            :        // Prepend the compiler name to the original command line</a>
<a name="5567"><span class="lineNum">    5567 </span>            :        // originalCommandLine = std::string(compilerName) + std::string(&quot; &quot;) + originalCommandLine;</a>
<a name="5568"><span class="lineNum">    5568 </span>            :        // originalCommandLine = compilerNameString + originalCommandLine;</a>
<a name="5569"><span class="lineNum">    5569 </span>            : </a>
<a name="5570"><span class="lineNum">    5570 </span>            :        // Prepend the compiler name to the original command line</a>
<a name="5571"><span class="lineNum">    5571 </span>            :        // originalCommandLine = std::string(compilerName) + std::string(&quot; &quot;) + originalCommandLine;</a>
<a name="5572"><span class="lineNum">    5572 </span>            : </a>
<a name="5573"><span class="lineNum">    5573 </span>            :        // printf (&quot;originalCommandLine = %s \n&quot;,originalCommandLine.c_str());</a>
<a name="5574"><span class="lineNum">    5574 </span>            : </a>
<a name="5575"><span class="lineNum">    5575 </span>            : #ifdef BACKEND_CXX_IS_INTEL_COMPILER</a>
<a name="5576"><span class="lineNum">    5576 </span>            :        // DQ (12/18/2016): In the case of using &quot;-E&quot; with the Intel backend compiler we need to</a>
<a name="5577"><span class="lineNum">    5577 </span>            :        // add -D__INTEL_CLANG_COMPILER so that we can take a path through the Intel header files</a>
<a name="5578"><span class="lineNum">    5578 </span>            :        // that avoids editing header Intel specific header files to handle builtin functions that</a>
<a name="5579"><span class="lineNum">    5579 </span>            :        // use types defined in the header files.</a>
<a name="5580"><span class="lineNum">    5580 </span>            :           originalCommandLine.push_back(&quot;-D__INTEL_CLANG_COMPILER&quot;);</a>
<a name="5581"><span class="lineNum">    5581 </span>            : #endif</a>
<a name="5582"><span class="lineNum">    5582 </span>            : </a>
<a name="5583"><span class="lineNum">    5583 </span>            :        // DQ (12/18/2016): Add a ROSE specific macro definition that will permit our ROSE specific</a>
<a name="5584"><span class="lineNum">    5584 </span>            :        // preinclude header file to skip over the ROSE specific macros and builting functions.  This</a>
<a name="5585"><span class="lineNum">    5585 </span>            :        // will allow ROSE to be use to generate CPP output that ROSE could then use as input (without</a>
<a name="5586"><span class="lineNum">    5586 </span>            :        // specific declarations being defined twice).  Markus had also requested this behavior.</a>
<a name="5587"><span class="lineNum">    5587 </span><span class="lineNoCov">          0 :           originalCommandLine.push_back(&quot;-DUSE_ROSE_CPP_PROCESSING&quot;);</span></a>
<a name="5588"><span class="lineNum">    5588 </span>            : </a>
<a name="5589"><span class="lineNum">    5589 </span>            :        // Debug: Output commandline arguments before actually executing</a>
<a name="5590"><span class="lineNum">    5590 </span><span class="lineNoCov">          0 :           if (SgProject::get_verbose() &gt; 0)</span></a>
<a name="5591"><span class="lineNum">    5591 </span>            :        // if (SgProject::get_verbose() &gt;= 0)</a>
<a name="5592"><span class="lineNum">    5592 </span>            :              {</a>
<a name="5593"><span class="lineNum">    5593 </span><span class="lineNoCov">          0 :                for (unsigned int i=0; i &lt; originalCommandLine.size(); ++i)</span></a>
<a name="5594"><span class="lineNum">    5594 </span>            :                   {</a>
<a name="5595"><span class="lineNum">    5595 </span><span class="lineNoCov">          0 :                     printf (&quot;originalCommandLine[%u] = %s \n&quot;, i, originalCommandLine[i].c_str());</span></a>
<a name="5596"><span class="lineNum">    5596 </span>            :                   }</a>
<a name="5597"><span class="lineNum">    5597 </span>            :              }</a>
<a name="5598"><span class="lineNum">    5598 </span>            : </a>
<a name="5599"><span class="lineNum">    5599 </span>            : #if 0</a>
<a name="5600"><span class="lineNum">    5600 </span>            :           printf (&quot;Support for \&quot;-E\&quot; being tested \n&quot;);</a>
<a name="5601"><span class="lineNum">    5601 </span>            :           ROSE_ABORT();</a>
<a name="5602"><span class="lineNum">    5602 </span>            : #endif</a>
<a name="5603"><span class="lineNum">    5603 </span>            : </a>
<a name="5604"><span class="lineNum">    5604 </span><span class="lineNoCov">          0 :           errorCode = systemFromVector(originalCommandLine);</span></a>
<a name="5605"><span class="lineNum">    5605 </span>            : </a>
<a name="5606"><span class="lineNum">    5606 </span><span class="lineNoCov">          0 :           ASSERT_not_null(SgNode::get_globalFunctionTypeTable());</span></a>
<a name="5607"><span class="lineNum">    5607 </span><span class="lineNoCov">          0 :           ASSERT_not_null(SgNode::get_globalFunctionTypeTable()-&gt;get_parent());</span></a>
<a name="5608"><span class="lineNum">    5608 </span>            : </a>
<a name="5609"><span class="lineNum">    5609 </span>            :        // printf (&quot;Exiting after call to compiler using -E option! \n&quot;);</a>
<a name="5610"><span class="lineNum">    5610 </span>            :        // ROSE_ASSERT(false);</a>
<a name="5611"><span class="lineNum">    5611 </span>            :         }</a>
<a name="5612"><span class="lineNum">    5612 </span>            :        else // non-preprocessing-only case</a>
<a name="5613"><span class="lineNum">    5613 </span>            :         {</a>
<a name="5614"><span class="lineNum">    5614 </span>            : #if DEBUG_PROJECT_COMPILE_COMMAND_LINE</a>
<a name="5615"><span class="lineNum">    5615 </span>            :           printf (&quot;\n\nIn Project::compileOutput(): Compiling numberOfFiles() = %d \n&quot;,numberOfFiles());</a>
<a name="5616"><span class="lineNum">    5616 </span>            : #endif</a>
<a name="5617"><span class="lineNum">    5617 </span>            : </a>
<a name="5618"><span class="lineNum">    5618 </span><span class="lineCov">        346 :           bool multifile_support_compile_only_flag = false;</span></a>
<a name="5619"><span class="lineNum">    5619 </span>            : </a>
<a name="5620"><span class="lineNum">    5620 </span>            :        // case 2: compilation  for each file</a>
<a name="5621"><span class="lineNum">    5621 </span>            :        // Typical case</a>
<a name="5622"><span class="lineNum">    5622 </span><span class="lineCov">        346 :              {</span></a>
<a name="5623"><span class="lineNum">    5623 </span><span class="lineCov">        346 :                if (numberOfFiles() &gt; 1)</span></a>
<a name="5624"><span class="lineNum">    5624 </span>            :                   {</a>
<a name="5625"><span class="lineNum">    5625 </span>            : #if DEBUG_PROJECT_COMPILE_COMMAND_LINE</a>
<a name="5626"><span class="lineNum">    5626 </span>            :                     printf (&quot;In Project::compileOutput(): Need to handled multiple files: \n&quot;);</a>
<a name="5627"><span class="lineNum">    5627 </span>            :                     printf (&quot;   1) run each one separately through ROSE to generate the translated source file, and object files (compile only), then \n&quot;);</a>
<a name="5628"><span class="lineNum">    5628 </span>            :                     printf (&quot;   2) collect the object files in a final link command \n&quot;);</a>
<a name="5629"><span class="lineNum">    5629 </span>            : #endif</a>
<a name="5630"><span class="lineNum">    5630 </span><span class="lineCov">          1 :                     multifile_support_compile_only_flag = true;</span></a>
<a name="5631"><span class="lineNum">    5631 </span>            :                   }</a>
<a name="5632"><span class="lineNum">    5632 </span>            : </a>
<a name="5633"><span class="lineNum">    5633 </span><span class="lineCov">        693 :                for (i=0; i &lt; numberOfFiles(); i++)</span></a>
<a name="5634"><span class="lineNum">    5634 </span>            :                   {</a>
<a name="5635"><span class="lineNum">    5635 </span><span class="lineCov">        347 :                     int localErrorCode = 0;</span></a>
<a name="5636"><span class="lineNum">    5636 </span><span class="lineCov">        347 :                     SgFile &amp; file = get_file(i);</span></a>
<a name="5637"><span class="lineNum">    5637 </span>            : </a>
<a name="5638"><span class="lineNum">    5638 </span>            : #if DEBUG_PROJECT_COMPILE_COMMAND_LINE || 0</a>
<a name="5639"><span class="lineNum">    5639 </span>            :                     printf (&quot;In Project::compileOutput(): Processing file #%d of %d: filename = %s \n&quot;,i,numberOfFiles(),file.getFileName().c_str());</a>
<a name="5640"><span class="lineNum">    5640 </span>            : #endif</a>
<a name="5641"><span class="lineNum">    5641 </span><span class="lineCov">        347 :                     if (multifile_support_compile_only_flag == true)</span></a>
<a name="5642"><span class="lineNum">    5642 </span>            :                        {</a>
<a name="5643"><span class="lineNum">    5643 </span>            : #if DEBUG_PROJECT_COMPILE_COMMAND_LINE || 0</a>
<a name="5644"><span class="lineNum">    5644 </span>            :                          printf (&quot;multifile_support_compile_only_flag == true: Turn ON compileOnly flag \n&quot;);</a>
<a name="5645"><span class="lineNum">    5645 </span>            : #endif</a>
<a name="5646"><span class="lineNum">    5646 </span><span class="lineCov">          2 :                          file.set_compileOnly(true);</span></a>
<a name="5647"><span class="lineNum">    5647 </span>            : </a>
<a name="5648"><span class="lineNum">    5648 </span>            : #if DEBUG_PROJECT_COMPILE_COMMAND_LINE || 0</a>
<a name="5649"><span class="lineNum">    5649 </span>            :                          printf (&quot;Need to supporess the generation of object file specification in backend compiler link line \n&quot;);</a>
<a name="5650"><span class="lineNum">    5650 </span>            : #endif</a>
<a name="5651"><span class="lineNum">    5651 </span><span class="lineCov">          2 :                          file.set_multifile_support(true);</span></a>
<a name="5652"><span class="lineNum">    5652 </span>            :                        }</a>
<a name="5653"><span class="lineNum">    5653 </span>            : </a>
<a name="5654"><span class="lineNum">    5654 </span><span class="lineCov">        347 :                     if (KEEP_GOING_CAUGHT_BACKEND_COMPILER_SIGNAL)</span></a>
<a name="5655"><span class="lineNum">    5655 </span>            :                        {</a>
<a name="5656"><span class="lineNum">    5656 </span><span class="lineNoCov">          0 :                          std::cout</span></a>
<a name="5657"><span class="lineNum">    5657 </span>            :                              &lt;&lt; &quot;[WARN] &quot;</a>
<a name="5658"><span class="lineNum">    5658 </span>            :                              &lt;&lt; &quot;Configured to keep going after catching a &quot;</a>
<a name="5659"><span class="lineNum">    5659 </span><span class="lineNoCov">          0 :                              &lt;&lt; &quot;signal in SgProject::compileOutput()&quot;</span></a>
<a name="5660"><span class="lineNum">    5660 </span><span class="lineNoCov">          0 :                              &lt;&lt; std::endl;</span></a>
<a name="5661"><span class="lineNum">    5661 </span>            : </a>
<a name="5662"><span class="lineNum">    5662 </span><span class="lineNoCov">          0 :                          localErrorCode = 100;</span></a>
<a name="5663"><span class="lineNum">    5663 </span><span class="lineNoCov">          0 :                          file.set_backendCompilerErrorCode(localErrorCode);</span></a>
<a name="5664"><span class="lineNum">    5664 </span>            :                        }</a>
<a name="5665"><span class="lineNum">    5665 </span>            :                       else</a>
<a name="5666"><span class="lineNum">    5666 </span>            :                        {</a>
<a name="5667"><span class="lineNum">    5667 </span><span class="lineCov">        347 :                          localErrorCode = file.compileOutput(0);</span></a>
<a name="5668"><span class="lineNum">    5668 </span>            :                        }</a>
<a name="5669"><span class="lineNum">    5669 </span>            : </a>
<a name="5670"><span class="lineNum">    5670 </span><span class="lineCov">        347 :                     if (localErrorCode &gt; errorCode)</span></a>
<a name="5671"><span class="lineNum">    5671 </span>            :                        {</a>
<a name="5672"><span class="lineNum">    5672 </span>            :                          errorCode = localErrorCode;</a>
<a name="5673"><span class="lineNum">    5673 </span>            :                        }</a>
<a name="5674"><span class="lineNum">    5674 </span>            : </a>
<a name="5675"><span class="lineNum">    5675 </span><span class="lineCov">        347 :                     if (multifile_support_compile_only_flag == true)</span></a>
<a name="5676"><span class="lineNum">    5676 </span>            :                        {</a>
<a name="5677"><span class="lineNum">    5677 </span>            : #if DEBUG_PROJECT_COMPILE_COMMAND_LINE</a>
<a name="5678"><span class="lineNum">    5678 </span>            :                          printf (&quot;In SgProject::compileOutput(): multifile_support_compile_only_flag == true: Turn OFF compileOnly flag \n&quot;);</a>
<a name="5679"><span class="lineNum">    5679 </span>            : #endif</a>
<a name="5680"><span class="lineNum">    5680 </span><span class="lineCov">          2 :                          file.set_compileOnly(false);</span></a>
<a name="5681"><span class="lineNum">    5681 </span>            : #if DEBUG_PROJECT_COMPILE_COMMAND_LINE</a>
<a name="5682"><span class="lineNum">    5682 </span>            :                       // Build a link line now that we have processed all of the source files to build the object file.</a>
<a name="5683"><span class="lineNum">    5683 </span>            :                          printf (&quot;Need to build the link line to build the executable using the generated object files \n&quot;);</a>
<a name="5684"><span class="lineNum">    5684 </span>            : </a>
<a name="5685"><span class="lineNum">    5685 </span>            :                          printf (&quot;In SgProject::compileOutput(): get_compileOnly() = %s (reset to false) \n&quot;,get_compileOnly() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="5686"><span class="lineNum">    5686 </span>            : #endif</a>
<a name="5687"><span class="lineNum">    5687 </span>            :                       // I think we should not have set the compileOnly flag to true prevously.</a>
<a name="5688"><span class="lineNum">    5688 </span>            :                       // set_compileOnly(false);</a>
<a name="5689"><span class="lineNum">    5689 </span>            : #if 0</a>
<a name="5690"><span class="lineNum">    5690 </span>            :                          printf (&quot;Exiting as a test! \n&quot;);</a>
<a name="5691"><span class="lineNum">    5691 </span>            :                          ROSE_ABORT();</a>
<a name="5692"><span class="lineNum">    5692 </span>            : #endif</a>
<a name="5693"><span class="lineNum">    5693 </span>            :                        }</a>
<a name="5694"><span class="lineNum">    5694 </span>            :                   }</a>
<a name="5695"><span class="lineNum">    5695 </span>            :              }</a>
<a name="5696"><span class="lineNum">    5696 </span>            : </a>
<a name="5697"><span class="lineNum">    5697 </span>            : #if DEBUG_PROJECT_COMPILE_COMMAND_LINE</a>
<a name="5698"><span class="lineNum">    5698 </span>            :           printf (&quot;In SgProject::compileOutput(): get_compileOnly() = %s \n&quot;,get_compileOnly() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="5699"><span class="lineNum">    5699 </span>            :           printf (&quot;In SgProject::compileOutput(): errorCode = %d \n&quot;,errorCode);</a>
<a name="5700"><span class="lineNum">    5700 </span>            : #endif</a>
<a name="5701"><span class="lineNum">    5701 </span>            :        // case 3: linking at the project level</a>
<a name="5702"><span class="lineNum">    5702 </span>            : </a>
<a name="5703"><span class="lineNum">    5703 </span>            :        // DQ (1/9/2017): Only proceed with linking step if the compilation step finished without error.</a>
<a name="5704"><span class="lineNum">    5704 </span>            :        // DQ (30/8/2017): Note that Csharp does not use linking the same way that C/C++ does (as I understand it).</a>
<a name="5705"><span class="lineNum">    5705 </span>            :        // if (! (get_Java_only() || get_Python_only() || get_X10_only()) )</a>
<a name="5706"><span class="lineNum">    5706 </span>            :        // if (! (get_Java_only() || get_Python_only() || get_X10_only() || get_Csharp_only() ) )</a>
<a name="5707"><span class="lineNum">    5707 </span><span class="lineCov">        346 :           if ( (errorCode == 0) )</span></a>
<a name="5708"><span class="lineNum">    5708 </span>            :              {</a>
<a name="5709"><span class="lineNum">    5709 </span>            : </a>
<a name="5710"><span class="lineNum">    5710 </span>            :             // ROSE_ASSERT(get_compileOnly() == true);</a>
<a name="5711"><span class="lineNum">    5711 </span>            : </a>
<a name="5712"><span class="lineNum">    5712 </span>            :             // Liao, 11/19/2009,</a>
<a name="5713"><span class="lineNum">    5713 </span>            :             // I really want to just move the SgFile::compileOutput() to SgProject::compileOutput()</a>
<a name="5714"><span class="lineNum">    5714 </span>            :             // and have both compilation and linking finished at the same time, just as the original command line does.</a>
<a name="5715"><span class="lineNum">    5715 </span>            :             // Then we don't have to compose compilation command line for each of the input source file</a>
<a name="5716"><span class="lineNum">    5716 </span>            :             // or to compose the final linking command line.</a>
<a name="5717"><span class="lineNum">    5717 </span>            :             //</a>
<a name="5718"><span class="lineNum">    5718 </span>            :             // But there may be some advantages of doing the compilation and linking separately at two levels.</a>
<a name="5719"><span class="lineNum">    5719 </span>            :             // I just discussed it with Dan.</a>
<a name="5720"><span class="lineNum">    5720 </span>            :             // The two level scheme is needed to support mixed language input, like a C file and a Fortran file</a>
<a name="5721"><span class="lineNum">    5721 </span>            :             // In this case, we cannot have a single one level command line to compile and link those two files</a>
<a name="5722"><span class="lineNum">    5722 </span>            :             // We have to compile each of them first and finally link the object files.</a>
<a name="5723"><span class="lineNum">    5723 </span>            : </a>
<a name="5724"><span class="lineNum">    5724 </span>            :             // DQ (4/13/2015): Check if the compile line supported the link step.</a>
<a name="5725"><span class="lineNum">    5725 </span>            :             // Could this call the linker even we we don't want it called, or skipp calling it when we do want it to be called?</a>
<a name="5726"><span class="lineNum">    5726 </span><span class="lineCov">        346 :                if (get_compileOnly() == false)</span></a>
<a name="5727"><span class="lineNum">    5727 </span>            :                   {</a>
<a name="5728"><span class="lineNum">    5728 </span>            :                    // Liao 5/1/2015</a>
<a name="5729"><span class="lineNum">    5729 </span><span class="lineCov">          5 :                       linkingReturnVal = link (BACKEND_CXX_COMPILER_NAME_WITH_PATH);</span></a>
<a name="5730"><span class="lineNum">    5730 </span>            :                   }</a>
<a name="5731"><span class="lineNum">    5731 </span>            :                  else</a>
<a name="5732"><span class="lineNum">    5732 </span>            :                   {</a>
<a name="5733"><span class="lineNum">    5733 </span>            : #if DEBUG_PROJECT_COMPILE_COMMAND_LINE</a>
<a name="5734"><span class="lineNum">    5734 </span>            :                     printf (&quot;In SgProject::compileOutput(): Skip calling the linker if the compile line handled the link step! \n&quot;);</a>
<a name="5735"><span class="lineNum">    5735 </span>            : #endif</a>
<a name="5736"><span class="lineNum">    5736 </span>            :                   }</a>
<a name="5737"><span class="lineNum">    5737 </span>            :              }</a>
<a name="5738"><span class="lineNum">    5738 </span>            :         } // end if preprocessing-only is false</a>
<a name="5739"><span class="lineNum">    5739 </span>            : </a>
<a name="5740"><span class="lineNum">    5740 </span><span class="lineCov">        346 :      return errorCode + linkingReturnVal;</span></a>
<a name="5741"><span class="lineNum">    5741 </span>            :    }</a>
<a name="5742"><span class="lineNum">    5742 </span>            : </a>
<a name="5743"><span class="lineNum">    5743 </span>            : </a>
<a name="5744"><span class="lineNum">    5744 </span>            : bool</a>
<a name="5745"><span class="lineNum">    5745 </span><span class="lineCov">       1020 : SgFile::isPrelinkPhase() const</span></a>
<a name="5746"><span class="lineNum">    5746 </span>            :    {</a>
<a name="5747"><span class="lineNum">    5747 </span>            :   // This function checks if the &quot;-prelink&quot; option was passed to the ROSE preprocessor</a>
<a name="5748"><span class="lineNum">    5748 </span>            :   // It could alternatively just check the commandline and set a flag in the SgFile object.</a>
<a name="5749"><span class="lineNum">    5749 </span>            :   // But then there would be a redundent flag in each SgFile object (perhaps the design needs to</a>
<a name="5750"><span class="lineNum">    5750 </span>            :   // be better, using a common base class for commandline options (in both the SgProject and</a>
<a name="5751"><span class="lineNum">    5751 </span>            :   // the SgFile (would not be a new IR node)).</a>
<a name="5752"><span class="lineNum">    5752 </span>            : </a>
<a name="5753"><span class="lineNum">    5753 </span><span class="lineCov">       1020 :      bool returnValue = false;</span></a>
<a name="5754"><span class="lineNum">    5754 </span>            : </a>
<a name="5755"><span class="lineNum">    5755 </span>            :   // DQ (5/9/2004): If the parent is not set then this was compiled as a SgFile directly</a>
<a name="5756"><span class="lineNum">    5756 </span>            :   // (likely by the rewrite mechanism). IF so it can't be a prelink phase, which is</a>
<a name="5757"><span class="lineNum">    5757 </span>            :   // called only on SgProjects). Not happy with this mechanism!</a>
<a name="5758"><span class="lineNum">    5758 </span><span class="lineCov">       1020 :      if (get_parent() != nullptr)</span></a>
<a name="5759"><span class="lineNum">    5759 </span>            :         {</a>
<a name="5760"><span class="lineNum">    5760 </span>            :        // DQ (1/24/2010): Now that we have directory support, the parent of a SgFile does not have to be a SgProject.</a>
<a name="5761"><span class="lineNum">    5761 </span>            :        // SgProject* project = isSgProject(get_parent());</a>
<a name="5762"><span class="lineNum">    5762 </span><span class="lineCov">       1020 :           SgProject* project = TransformationSupport::getProject(this);</span></a>
<a name="5763"><span class="lineNum">    5763 </span>            : </a>
<a name="5764"><span class="lineNum">    5764 </span><span class="lineCov">       1020 :           ASSERT_not_null(project);</span></a>
<a name="5765"><span class="lineNum">    5765 </span><span class="lineCov">       1020 :           returnValue = project-&gt;get_prelink();</span></a>
<a name="5766"><span class="lineNum">    5766 </span>            :         }</a>
<a name="5767"><span class="lineNum">    5767 </span>            : </a>
<a name="5768"><span class="lineNum">    5768 </span><span class="lineCov">       1020 :      return returnValue;</span></a>
<a name="5769"><span class="lineNum">    5769 </span>            : </a>
<a name="5770"><span class="lineNum">    5770 </span>            :   // Note that project can be false if this is called on an intermediate file</a>
<a name="5771"><span class="lineNum">    5771 </span>            :   // generated by the rewrite system.</a>
<a name="5772"><span class="lineNum">    5772 </span>            :   // return (project == NULL) ? false : project-&gt;get_prelink();</a>
<a name="5773"><span class="lineNum">    5773 </span>            :    }</a>
<a name="5774"><span class="lineNum">    5774 </span>            : </a>
<a name="5775"><span class="lineNum">    5775 </span>            : // DQ (10/14/2010): Removing reference to macros defined in rose_config.h (defined in the header file as a default parameter).</a>
<a name="5776"><span class="lineNum">    5776 </span>            : //! Preprocessing command line and pass it to generate the final linking command line</a>
<a name="5777"><span class="lineNum">    5777 </span>            : // int SgProject::link ()</a>
<a name="5778"><span class="lineNum">    5778 </span><span class="lineCov">          5 : int SgProject::link ( std::string linkerName )</span></a>
<a name="5779"><span class="lineNum">    5779 </span>            :    {</a>
<a name="5780"><span class="lineNum">    5780 </span>            : #if 0</a>
<a name="5781"><span class="lineNum">    5781 </span>            :      printf (&quot;In SgProject::link(): linkerName = %s \n&quot;,linkerName.c_str());</a>
<a name="5782"><span class="lineNum">    5782 </span>            :      printf (&quot;Exiting as a test! \n&quot;);</a>
<a name="5783"><span class="lineNum">    5783 </span>            :      ROSE_ABORT();</a>
<a name="5784"><span class="lineNum">    5784 </span>            : #endif</a>
<a name="5785"><span class="lineNum">    5785 </span>            : </a>
<a name="5786"><span class="lineNum">    5786 </span>            :   // DQ (1/25/2010): We have to now test for both numberOfFiles() and numberOfDirectories(),</a>
<a name="5787"><span class="lineNum">    5787 </span>            :   // or perhaps define a more simple function to use more directly.</a>
<a name="5788"><span class="lineNum">    5788 </span>            :   // Liao, 11/20/2009</a>
<a name="5789"><span class="lineNum">    5789 </span>            :   // translator test1.o will have ZERO SgFile attached with SgProject</a>
<a name="5790"><span class="lineNum">    5790 </span>            :   // Special handling for this case</a>
<a name="5791"><span class="lineNum">    5791 </span>            :   // if (numberOfFiles() == 0)</a>
<a name="5792"><span class="lineNum">    5792 </span><span class="lineCov">          5 :      if (numberOfFiles() == 0 &amp;&amp; numberOfDirectories() == 0)</span></a>
<a name="5793"><span class="lineNum">    5793 </span>            :         {</a>
<a name="5794"><span class="lineNum">    5794 </span><span class="lineNoCov">          0 :           if (get_verbose() &gt; 0)</span></a>
<a name="5795"><span class="lineNum">    5795 </span><span class="lineNoCov">          0 :                cout &lt;&lt; &quot;SgProject::link maybe encountering an object file ...&quot; &lt;&lt; endl;</span></a>
<a name="5796"><span class="lineNum">    5796 </span>            : </a>
<a name="5797"><span class="lineNum">    5797 </span>            :        // DQ (1/24/2010): support for directories not in place yet.</a>
<a name="5798"><span class="lineNum">    5798 </span><span class="lineNoCov">          0 :           if (numberOfDirectories() &gt; 0)</span></a>
<a name="5799"><span class="lineNum">    5799 </span>            :              {</a>
<a name="5800"><span class="lineNum">    5800 </span><span class="lineNoCov">          0 :                printf (&quot;Directory support for linking not implemented... (unclear what this means...)\n&quot;);</span></a>
<a name="5801"><span class="lineNum">    5801 </span><span class="lineNoCov">          0 :                return 0;</span></a>
<a name="5802"><span class="lineNum">    5802 </span>            :              }</a>
<a name="5803"><span class="lineNum">    5803 </span>            :         }</a>
<a name="5804"><span class="lineNum">    5804 </span>            :        else</a>
<a name="5805"><span class="lineNum">    5805 </span>            :         {</a>
<a name="5806"><span class="lineNum">    5806 </span>            :        // normal cases that rose translators will actually do something about the input files</a>
<a name="5807"><span class="lineNum">    5807 </span>            :        // and we have SgFile for each of the files.</a>
<a name="5808"><span class="lineNum">    5808 </span>            :        // if ((numberOfFiles()== 0) || get_compileOnly() || get_file(0).get_skipfinalCompileStep()</a>
<a name="5809"><span class="lineNum">    5809 </span><span class="lineCov">          5 :           if ( get_compileOnly() || get_file(0).get_skipfinalCompileStep() ||get_file(0).get_skip_unparse())</span></a>
<a name="5810"><span class="lineNum">    5810 </span>            :              {</a>
<a name="5811"><span class="lineNum">    5811 </span><span class="lineCov">          2 :                if (get_verbose() &gt; 0)</span></a>
<a name="5812"><span class="lineNum">    5812 </span><span class="lineNoCov">          0 :                     cout &lt;&lt; &quot;Skipping SgProject::link ...&quot; &lt;&lt; endl;</span></a>
<a name="5813"><span class="lineNum">    5813 </span><span class="lineCov">          2 :                return 0;</span></a>
<a name="5814"><span class="lineNum">    5814 </span>            :              }</a>
<a name="5815"><span class="lineNum">    5815 </span>            :         }</a>
<a name="5816"><span class="lineNum">    5816 </span>            : </a>
<a name="5817"><span class="lineNum">    5817 </span>            :   // Compile the output file from the unparsing</a>
<a name="5818"><span class="lineNum">    5818 </span><span class="lineCov">          6 :      vector&lt;string&gt; argcArgvList = get_originalCommandLineArgumentList();</span></a>
<a name="5819"><span class="lineNum">    5819 </span>            : </a>
<a name="5820"><span class="lineNum">    5820 </span>            :   // error checking</a>
<a name="5821"><span class="lineNum">    5821 </span><span class="lineCov">          3 :      if (numberOfFiles() != 0)</span></a>
<a name="5822"><span class="lineNum">    5822 </span><span class="lineCov">          3 :           ROSE_ASSERT (argcArgvList.size() &gt; 1);</span></a>
<a name="5823"><span class="lineNum">    5823 </span>            : </a>
<a name="5824"><span class="lineNum">    5824 </span><span class="lineCov">          3 :      ROSE_ASSERT(linkerName != &quot;&quot;);</span></a>
<a name="5825"><span class="lineNum">    5825 </span>            : </a>
<a name="5826"><span class="lineNum">    5826 </span>            :   // strip out any rose options before passing the command line.</a>
<a name="5827"><span class="lineNum">    5827 </span><span class="lineCov">          3 :      SgFile::stripRoseCommandLineOptions( argcArgvList );</span></a>
<a name="5828"><span class="lineNum">    5828 </span>            : </a>
<a name="5829"><span class="lineNum">    5829 </span>            :   // strip out edg specific options that would cause an error in the backend linker (compiler).</a>
<a name="5830"><span class="lineNum">    5830 </span><span class="lineCov">          3 :      SgFile::stripEdgCommandLineOptions( argcArgvList );</span></a>
<a name="5831"><span class="lineNum">    5831 </span>            : </a>
<a name="5832"><span class="lineNum">    5832 </span><span class="lineCov">          3 :      SgFile::stripTranslationCommandLineOptions( argcArgvList );</span></a>
<a name="5833"><span class="lineNum">    5833 </span>            : </a>
<a name="5834"><span class="lineNum">    5834 </span>            :   // remove the original compiler/linker name</a>
<a name="5835"><span class="lineNum">    5835 </span><span class="lineCov">          3 :      if (argcArgvList.size() &gt; 0) argcArgvList.erase(argcArgvList.begin());</span></a>
<a name="5836"><span class="lineNum">    5836 </span>            : </a>
<a name="5837"><span class="lineNum">    5837 </span>            :   // remove all original file names</a>
<a name="5838"><span class="lineNum">    5838 </span><span class="lineCov">          3 :      Rose_STL_Container&lt;string&gt; sourceFilenames = get_sourceFileNameList();</span></a>
<a name="5839"><span class="lineNum">    5839 </span><span class="lineCov">          6 :      for (Rose_STL_Container&lt;string&gt;::iterator i = sourceFilenames.begin(); i != sourceFilenames.end(); i++)</span></a>
<a name="5840"><span class="lineNum">    5840 </span>            :         {</a>
<a name="5841"><span class="lineNum">    5841 </span>            : #if USE_ABSOLUTE_PATHS_IN_SOURCE_FILE_LIST</a>
<a name="5842"><span class="lineNum">    5842 </span>            : #error &quot;USE_ABSOLUTE_PATHS_IN_SOURCE_FILE_LIST is not supported yet&quot;</a>
<a name="5843"><span class="lineNum">    5843 </span>            :        // DQ (9/1/2006): Check for use of absolute path and convert filename to absolute path if required</a>
<a name="5844"><span class="lineNum">    5844 </span>            :           bool usesAbsolutePath = ((*i)[0] == '/');</a>
<a name="5845"><span class="lineNum">    5845 </span>            :           if (usesAbsolutePath == false)</a>
<a name="5846"><span class="lineNum">    5846 </span>            :              {</a>
<a name="5847"><span class="lineNum">    5847 </span>            :                string targetSourceFileToRemove = StringUtility::getAbsolutePathFromRelativePath(*i);</a>
<a name="5848"><span class="lineNum">    5848 </span>            :                printf (&quot;Converting source file to absolute path to search for it and remove it! targetSourceFileToRemove = %s \n&quot;,targetSourceFileToRemove.c_str());</a>
<a name="5849"><span class="lineNum">    5849 </span>            :                argcArgvList.remove(targetSourceFileToRemove);</a>
<a name="5850"><span class="lineNum">    5850 </span>            :              }</a>
<a name="5851"><span class="lineNum">    5851 </span>            :             else</a>
<a name="5852"><span class="lineNum">    5852 </span>            :              {</a>
<a name="5853"><span class="lineNum">    5853 </span>            :                argcArgvList.remove(*i);</a>
<a name="5854"><span class="lineNum">    5854 </span>            :              }</a>
<a name="5855"><span class="lineNum">    5855 </span>            : #else</a>
<a name="5856"><span class="lineNum">    5856 </span><span class="lineCov">          3 :           if (find(argcArgvList.begin(),argcArgvList.end(),*i) != argcArgvList.end())</span></a>
<a name="5857"><span class="lineNum">    5857 </span>            :              {</a>
<a name="5858"><span class="lineNum">    5858 </span><span class="lineCov">          3 :                argcArgvList.erase(find(argcArgvList.begin(),argcArgvList.end(),*i));</span></a>
<a name="5859"><span class="lineNum">    5859 </span>            :              }</a>
<a name="5860"><span class="lineNum">    5860 </span>            : #endif</a>
<a name="5861"><span class="lineNum">    5861 </span>            :         }</a>
<a name="5862"><span class="lineNum">    5862 </span>            : </a>
<a name="5863"><span class="lineNum">    5863 </span>            :      // fix double quoted strings</a>
<a name="5864"><span class="lineNum">    5864 </span>            :      // DQ (4/14/2005): Fixup quoted strings in args fix &quot;-DTEST_STRING_MACRO=&quot;Thu Apr 14 08:18:33 PDT 2005&quot;</a>
<a name="5865"><span class="lineNum">    5865 </span>            :      // to be -DTEST_STRING_MACRO=\&quot;&quot;Thu Apr 14 08:18:33 PDT 2005&quot;\&quot;  This is a problem in the compilation of</a>
<a name="5866"><span class="lineNum">    5866 </span>            :      // a Kull file (version.cc), when the backend is specified as /usr/apps/kull/tools/mpig++-3.4.1.  The</a>
<a name="5867"><span class="lineNum">    5867 </span>            :      // problem is that /usr/apps/kull/tools/mpig++-3.4.1 is a wrapper for a shell script /usr/local/bin/mpiCC</a>
<a name="5868"><span class="lineNum">    5868 </span>            :      // which does not tend to observe quotes well.  The solution is to add additional escaped quotes.</a>
<a name="5869"><span class="lineNum">    5869 </span><span class="lineCov">          9 :      for (Rose_STL_Container&lt;string&gt;::iterator i = argcArgvList.begin(); i != argcArgvList.end(); i++)</span></a>
<a name="5870"><span class="lineNum">    5870 </span>            :         {</a>
<a name="5871"><span class="lineNum">    5871 </span><span class="lineCov">          6 :           std::string::size_type startingQuote = i-&gt;find(&quot;\&quot;&quot;);</span></a>
<a name="5872"><span class="lineNum">    5872 </span><span class="lineCov">          6 :           if (startingQuote != std::string::npos)</span></a>
<a name="5873"><span class="lineNum">    5873 </span>            :              {</a>
<a name="5874"><span class="lineNum">    5874 </span><span class="lineNoCov">          0 :                std::string::size_type endingQuote   = i-&gt;rfind(&quot;\&quot;&quot;);</span></a>
<a name="5875"><span class="lineNum">    5875 </span>            : </a>
<a name="5876"><span class="lineNum">    5876 </span>            :             // There should be a double quote on both ends of the string</a>
<a name="5877"><span class="lineNum">    5877 </span><span class="lineNoCov">          0 :                ROSE_ASSERT (endingQuote != std::string::npos);</span></a>
<a name="5878"><span class="lineNum">    5878 </span>            : </a>
<a name="5879"><span class="lineNum">    5879 </span><span class="lineNoCov">          0 :                std::string quotedSubstring = i-&gt;substr(startingQuote,endingQuote);</span></a>
<a name="5880"><span class="lineNum">    5880 </span>            : </a>
<a name="5881"><span class="lineNum">    5881 </span>            :             // DQ (11/1/2012): Robb has suggested using single quote instead of double quotes here.</a>
<a name="5882"><span class="lineNum">    5882 </span>            :             // This is a problem for the processing of mutt (large C application) (but we can figure</a>
<a name="5883"><span class="lineNum">    5883 </span>            :             // out the link command after the compile command).</a>
<a name="5884"><span class="lineNum">    5884 </span>            :             // std::string fixedQuotedSubstring = std::string(&quot;\\\&quot;&quot;) + quotedSubstring + std::string(&quot;\\\&quot;&quot;);</a>
<a name="5885"><span class="lineNum">    5885 </span>            :             // std::string fixedQuotedSubstring = std::string(&quot;\\\'&quot;) + quotedSubstring + std::string(&quot;\\\'&quot;);</a>
<a name="5886"><span class="lineNum">    5886 </span><span class="lineNoCov">          0 :                std::string fixedQuotedSubstring = std::string(&quot;\\\&quot;&quot;) + quotedSubstring + std::string(&quot;\\\&quot;&quot;);</span></a>
<a name="5887"><span class="lineNum">    5887 </span>            : </a>
<a name="5888"><span class="lineNum">    5888 </span>            :             // Now replace the quotedSubstring with the fixedQuotedSubstring</a>
<a name="5889"><span class="lineNum">    5889 </span><span class="lineNoCov">          0 :                i-&gt;replace(startingQuote,endingQuote,fixedQuotedSubstring);</span></a>
<a name="5890"><span class="lineNum">    5890 </span>            : </a>
<a name="5891"><span class="lineNum">    5891 </span><span class="lineNoCov">          0 :                printf (&quot;Modified argument = %s \n&quot;,(*i).c_str());</span></a>
<a name="5892"><span class="lineNum">    5892 </span>            :              }</a>
<a name="5893"><span class="lineNum">    5893 </span>            :         }</a>
<a name="5894"><span class="lineNum">    5894 </span>            : </a>
<a name="5895"><span class="lineNum">    5895 </span>            :   // Call the compile</a>
<a name="5896"><span class="lineNum">    5896 </span><span class="lineCov">          6 :      int errorCode = link ( argcArgvList, linkerName );</span></a>
<a name="5897"><span class="lineNum">    5897 </span>            : </a>
<a name="5898"><span class="lineNum">    5898 </span>            :   // return the error code from the compilation</a>
<a name="5899"><span class="lineNum">    5899 </span><span class="lineCov">          3 :      return errorCode;</span></a>
<a name="5900"><span class="lineNum">    5900 </span>            :    }</a>
<a name="5901"><span class="lineNum">    5901 </span>            : </a>
<a name="5902"><span class="lineNum">    5902 </span>            : // DQ (10/14/2010): Removing reference to macros defined in rose_config.h (defined in the header file as a default parameter).</a>
<a name="5903"><span class="lineNum">    5903 </span>            : // int SgProject::link ( const std::vector&lt;std::string&gt;&amp; argv )</a>
<a name="5904"><span class="lineNum">    5904 </span><span class="lineCov">          3 : int SgProject::link ( const std::vector&lt;std::string&gt;&amp; argv, std::string linkerName )</span></a>
<a name="5905"><span class="lineNum">    5905 </span>            :    {</a>
<a name="5906"><span class="lineNum">    5906 </span>            :   // argv.size could be 0 after strip off compiler name, original source file, etc</a>
<a name="5907"><span class="lineNum">    5907 </span>            :   // ROSE_ASSERT(argv.size() &gt; 0);</a>
<a name="5908"><span class="lineNum">    5908 </span>            : </a>
<a name="5909"><span class="lineNum">    5909 </span>            :   // This link function will be moved into the SgProject IR node when complete</a>
<a name="5910"><span class="lineNum">    5910 </span><span class="lineCov">          3 :      const std::string whiteSpace = &quot; &quot;;</span></a>
<a name="5911"><span class="lineNum">    5911 </span>            :   // printf (&quot;This link function is no longer called (I think!) \n&quot;);</a>
<a name="5912"><span class="lineNum">    5912 </span>            :   // ROSE_ASSERT(false);</a>
<a name="5913"><span class="lineNum">    5913 </span>            : </a>
<a name="5914"><span class="lineNum">    5914 </span>            :   // DQ (10/15/2005): Trap out case of C programs where we want to make sure that we don't use the C++ compiler to do our linking!</a>
<a name="5915"><span class="lineNum">    5915 </span><span class="lineCov">          3 :      if (get_C_only() == true || get_C99_only() == true)</span></a>
<a name="5916"><span class="lineNum">    5916 </span>            :         {</a>
<a name="5917"><span class="lineNum">    5917 </span><span class="lineCov">          1 :           linkerName = BACKEND_C_COMPILER_NAME_WITH_PATH;</span></a>
<a name="5918"><span class="lineNum">    5918 </span>            :         }</a>
<a name="5919"><span class="lineNum">    5919 </span>            :        else</a>
<a name="5920"><span class="lineNum">    5920 </span>            :         {</a>
<a name="5921"><span class="lineNum">    5921 </span>            :        // The default is C++</a>
<a name="5922"><span class="lineNum">    5922 </span><span class="lineCov">          2 :           linkerName = BACKEND_CXX_COMPILER_NAME_WITH_PATH;</span></a>
<a name="5923"><span class="lineNum">    5923 </span>            : </a>
<a name="5924"><span class="lineNum">    5924 </span><span class="lineCov">          2 :           if (get_Fortran_only() == true)</span></a>
<a name="5925"><span class="lineNum">    5925 </span>            :              {</a>
<a name="5926"><span class="lineNum">    5926 </span>            :             // linkerName = &quot;f77 &quot;;</a>
<a name="5927"><span class="lineNum">    5927 </span><span class="lineCov">          1 :                linkerName = BACKEND_FORTRAN_COMPILER_NAME_WITH_PATH;</span></a>
<a name="5928"><span class="lineNum">    5928 </span>            :              }</a>
<a name="5929"><span class="lineNum">    5929 </span>            :             else</a>
<a name="5930"><span class="lineNum">    5930 </span>            :              {</a>
<a name="5931"><span class="lineNum">    5931 </span>            :                  // Nothing to do here (case of C++)</a>
<a name="5932"><span class="lineNum">    5932 </span>            :              }</a>
<a name="5933"><span class="lineNum">    5933 </span>            :         }</a>
<a name="5934"><span class="lineNum">    5934 </span>            : </a>
<a name="5935"><span class="lineNum">    5935 </span>            :   // This is a better implementation since it will include any additional command line options that target the linker</a>
<a name="5936"><span class="lineNum">    5936 </span><span class="lineCov">          6 :      Rose_STL_Container&lt;string&gt; linkingCommand;</span></a>
<a name="5937"><span class="lineNum">    5937 </span>            : </a>
<a name="5938"><span class="lineNum">    5938 </span><span class="lineCov">          3 :      linkingCommand.push_back (linkerName);</span></a>
<a name="5939"><span class="lineNum">    5939 </span>            :      // find all object files generated at file level compilation</a>
<a name="5940"><span class="lineNum">    5940 </span>            :      // The assumption is that -o objectFileName is made explicit and</a>
<a name="5941"><span class="lineNum">    5941 </span>            :      // is generated by SgFile::generateOutputFileName()</a>
<a name="5942"><span class="lineNum">    5942 </span><span class="lineCov">          6 :      for (int i=0; i &lt; numberOfFiles(); i++)</span></a>
<a name="5943"><span class="lineNum">    5943 </span>            :         {</a>
<a name="5944"><span class="lineNum">    5944 </span>            :        // DQ (2/25/2014): If this file was supressed in the compilation to build an</a>
<a name="5945"><span class="lineNum">    5945 </span>            :        // object file then it should be supressed in being used in the linking stage.</a>
<a name="5946"><span class="lineNum">    5946 </span>            :        // linkingCommand.push_back(get_file(i).generateOutputFileName());</a>
<a name="5947"><span class="lineNum">    5947 </span><span class="lineCov">          3 :           if (get_file(i).get_skipfinalCompileStep() == false)</span></a>
<a name="5948"><span class="lineNum">    5948 </span>            :              {</a>
<a name="5949"><span class="lineNum">    5949 </span><span class="lineCov">          6 :                linkingCommand.push_back(get_file(i).generateOutputFileName());</span></a>
<a name="5950"><span class="lineNum">    5950 </span>            :              }</a>
<a name="5951"><span class="lineNum">    5951 </span>            :         }</a>
<a name="5952"><span class="lineNum">    5952 </span>            : </a>
<a name="5953"><span class="lineNum">    5953 </span>            : #if 0</a>
<a name="5954"><span class="lineNum">    5954 </span>            :   // DQ (5/27/2015): There appear to be extra command line options here that we might want to exclude (e.g. -DNDEBUG).</a>
<a name="5955"><span class="lineNum">    5955 </span>            :   // Note that we should leave these in place until we better understand where the limits are of what we should remove.</a>
<a name="5956"><span class="lineNum">    5956 </span>            :      printf (&quot;In SgProject::link(): Output argv list: \n&quot;);</a>
<a name="5957"><span class="lineNum">    5957 </span>            :      for (size_t i = 0; i &lt; argv.size(); i++)</a>
<a name="5958"><span class="lineNum">    5958 </span>            :         {</a>
<a name="5959"><span class="lineNum">    5959 </span>            :           printf (&quot;   --- argv = %s \n&quot;,argv[i].c_str());</a>
<a name="5960"><span class="lineNum">    5960 </span>            :         }</a>
<a name="5961"><span class="lineNum">    5961 </span>            : #endif</a>
<a name="5962"><span class="lineNum">    5962 </span>            : </a>
<a name="5963"><span class="lineNum">    5963 </span>            :   // Add any options specified in the original command line (after preprocessing)</a>
<a name="5964"><span class="lineNum">    5964 </span><span class="lineCov">          3 :      linkingCommand.insert(linkingCommand.end(), argv.begin(), argv.end());</span></a>
<a name="5965"><span class="lineNum">    5965 </span>            : </a>
<a name="5966"><span class="lineNum">    5966 </span>            :   // Check if -o option exists, otherwise append -o a.out to the command line</a>
<a name="5967"><span class="lineNum">    5967 </span>            : </a>
<a name="5968"><span class="lineNum">    5968 </span>            :   // Additional libraries to be linked with</a>
<a name="5969"><span class="lineNum">    5969 </span>            :   // Liao, 9/23/2009, optional linker flags to support OpenMP lowering targeting GOMP</a>
<a name="5970"><span class="lineNum">    5970 </span>            :   // if ((numberOfFiles() !=0) &amp;&amp; (get_file(0).get_openmp_lowering())</a>
<a name="5971"><span class="lineNum">    5971 </span>            :   // Liao 6/29/2012. sometimes rose translator is used as a wrapper for linking</a>
<a name="5972"><span class="lineNum">    5972 </span>            :   // There will be no SgFile at all in this case but we still want to append relevant linking options for OpenMP</a>
<a name="5973"><span class="lineNum">    5973 </span><span class="lineCov">          3 :      if (get_openmp_linking())</span></a>
<a name="5974"><span class="lineNum">    5974 </span>            :         {</a>
<a name="5975"><span class="lineNum">    5975 </span>            : // Sara Royuela 12/10/2012:  Add GCC version check</a>
<a name="5976"><span class="lineNum">    5976 </span>            : #ifdef USE_ROSE_GOMP_OPENMP_LIBRARY</a>
<a name="5977"><span class="lineNum">    5977 </span>            : #if (__GNUC__ &lt; 4 || (__GNUC__ == 4 &amp;&amp; (__GNUC_MINOR__ &lt; 4)))</a>
<a name="5978"><span class="lineNum">    5978 </span>            : #warning &quot;GNU version lower than expected&quot;</a>
<a name="5979"><span class="lineNum">    5979 </span>            :           printf(&quot;GCC version must be 4.4.0 or later when linking with GOMP OpenMP Runtime Library \n(OpenMP tasking calls are not implemented in previous versions)\n&quot;);</a>
<a name="5980"><span class="lineNum">    5980 </span>            :           ROSE_ABORT();</a>
<a name="5981"><span class="lineNum">    5981 </span>            : #endif</a>
<a name="5982"><span class="lineNum">    5982 </span>            : </a>
<a name="5983"><span class="lineNum">    5983 </span>            :        // add libxomp.a , Liao 6/12/2010</a>
<a name="5984"><span class="lineNum">    5984 </span>            :           string xomp_lib_path(ROSE_INSTALLATION_PATH);</a>
<a name="5985"><span class="lineNum">    5985 </span>            :           ROSE_ASSERT (xomp_lib_path.size() != 0);</a>
<a name="5986"><span class="lineNum">    5986 </span>            :           linkingCommand.push_back(xomp_lib_path+&quot;/lib/libxomp.a&quot;); // static linking for simplicity</a>
<a name="5987"><span class="lineNum">    5987 </span>            : </a>
<a name="5988"><span class="lineNum">    5988 </span>            :        // lib path is available if --with-gomp_omp_runtime_library=XXX is used</a>
<a name="5989"><span class="lineNum">    5989 </span>            :           string gomp_lib_path(GCC_GOMP_OPENMP_LIB_PATH);</a>
<a name="5990"><span class="lineNum">    5990 </span>            :           ROSE_ASSERT (gomp_lib_path.size() != 0);</a>
<a name="5991"><span class="lineNum">    5991 </span>            :           linkingCommand.push_back(gomp_lib_path+&quot;/libgomp.a&quot;);</a>
<a name="5992"><span class="lineNum">    5992 </span>            :           linkingCommand.push_back(&quot;-lpthread&quot;);</a>
<a name="5993"><span class="lineNum">    5993 </span>            : #else</a>
<a name="5994"><span class="lineNum">    5994 </span>            :   // GOMP has higher priority when both GOMP and OMNI are specified (wrongfully)</a>
<a name="5995"><span class="lineNum">    5995 </span>            :   #ifdef OMNI_OPENMP_LIB_PATH</a>
<a name="5996"><span class="lineNum">    5996 </span>            :        // a little redundant code to defer supporting 'ROSE_INSTALLATION_PATH' in cmake</a>
<a name="5997"><span class="lineNum">    5997 </span>            :           string xomp_lib_path(ROSE_INSTALLATION_PATH);</a>
<a name="5998"><span class="lineNum">    5998 </span>            :           ROSE_ASSERT (xomp_lib_path.size() != 0);</a>
<a name="5999"><span class="lineNum">    5999 </span>            :           linkingCommand.push_back(xomp_lib_path+&quot;/lib/libxomp.a&quot;);</a>
<a name="6000"><span class="lineNum">    6000 </span>            : </a>
<a name="6001"><span class="lineNum">    6001 </span>            :           string omni_lib_path(OMNI_OPENMP_LIB_PATH);</a>
<a name="6002"><span class="lineNum">    6002 </span>            :           ROSE_ASSERT (omni_lib_path.size() != 0);</a>
<a name="6003"><span class="lineNum">    6003 </span>            :           linkingCommand.push_back(omni_lib_path+&quot;/libgompc.a&quot;);</a>
<a name="6004"><span class="lineNum">    6004 </span>            :           linkingCommand.push_back(&quot;-lpthread&quot;);</a>
<a name="6005"><span class="lineNum">    6005 </span>            :   #else</a>
<a name="6006"><span class="lineNum">    6006 </span><span class="lineNoCov">          0 :           printf(&quot;Warning: OpenMP lowering is requested but no target runtime library is specified!\n&quot;);</span></a>
<a name="6007"><span class="lineNum">    6007 </span>            :   #endif</a>
<a name="6008"><span class="lineNum">    6008 </span>            : #endif</a>
<a name="6009"><span class="lineNum">    6009 </span>            :         }</a>
<a name="6010"><span class="lineNum">    6010 </span>            : </a>
<a name="6011"><span class="lineNum">    6011 </span>            : #if 0</a>
<a name="6012"><span class="lineNum">    6012 </span>            :      printf (&quot;In SgProject::link command line = %s \n&quot;,CommandlineProcessing::generateStringFromArgList(linkingCommand,false,false).c_str());</a>
<a name="6013"><span class="lineNum">    6013 </span>            : #endif</a>
<a name="6014"><span class="lineNum">    6014 </span>            : </a>
<a name="6015"><span class="lineNum">    6015 </span>            :      // TOO1 (2015/05/11): Causes automake configure tests to fail. Checking ld linker, as example:</a>
<a name="6016"><span class="lineNum">    6016 </span>            :      //</a>
<a name="6017"><span class="lineNum">    6017 </span>            :      //     identityTranslator -print-prog-name=ld -rose:verbose 0</a>
<a name="6018"><span class="lineNum">    6018 </span>            :      //     In SgProject::link command line = g++ -print-prog-name=ld</a>
<a name="6019"><span class="lineNum">    6019 </span>            :      //     ld</a>
<a name="6020"><span class="lineNum">    6020 </span>            :      //if ( get_verbose() &gt; 0 )</a>
<a name="6021"><span class="lineNum">    6021 </span>            :      //   {</a>
<a name="6022"><span class="lineNum">    6022 </span>            :      //     printf (&quot;In SgProject::link command line = %s \n&quot;,CommandlineProcessing::generateStringFromArgList(linkingCommand,false,false).c_str());</a>
<a name="6023"><span class="lineNum">    6023 </span>            :      //   }</a>
<a name="6024"><span class="lineNum">    6024 </span>            : </a>
<a name="6025"><span class="lineNum">    6025 </span><span class="lineCov">          3 :      int status = systemFromVector(linkingCommand);</span></a>
<a name="6026"><span class="lineNum">    6026 </span>            : </a>
<a name="6027"><span class="lineNum">    6027 </span><span class="lineCov">          3 :      if ( get_verbose() &gt; 1 )</span></a>
<a name="6028"><span class="lineNum">    6028 </span>            :         {</a>
<a name="6029"><span class="lineNum">    6029 </span><span class="lineNoCov">          0 :           printf (&quot;linker error status = %d \n&quot;,status);</span></a>
<a name="6030"><span class="lineNum">    6030 </span>            :         }</a>
<a name="6031"><span class="lineNum">    6031 </span>            : </a>
<a name="6032"><span class="lineNum">    6032 </span>            :   // DQ (4/13/2015): Added testing and exiting on non-zero link status (debugging use of redundant -o option).</a>
<a name="6033"><span class="lineNum">    6033 </span>            :   // If the compile line has triggered the link step then we don't want to do the linking here.  Note</a>
<a name="6034"><span class="lineNum">    6034 </span>            :   // that we can't disable the link in the compilation line because &quot;-MMD -MF .subdirs-install.d&quot; options</a>
<a name="6035"><span class="lineNum">    6035 </span>            :   // require the use of the non-absolute path (at least that is my understanding of the problem).</a>
<a name="6036"><span class="lineNum">    6036 </span><span class="lineCov">          3 :      if (status != 0)</span></a>
<a name="6037"><span class="lineNum">    6037 </span>            :         {</a>
<a name="6038"><span class="lineNum">    6038 </span>            : #if 0</a>
<a name="6039"><span class="lineNum">    6039 </span>            :           printf (&quot;Detected non-zero status in link process: status = %d \n&quot;,status);</a>
<a name="6040"><span class="lineNum">    6040 </span>            :           printf (&quot;Exiting as a test! \n&quot;);</a>
<a name="6041"><span class="lineNum">    6041 </span>            :           ROSE_ABORT();</a>
<a name="6042"><span class="lineNum">    6042 </span>            : #endif</a>
<a name="6043"><span class="lineNum">    6043 </span>            :         }</a>
<a name="6044"><span class="lineNum">    6044 </span>            : </a>
<a name="6045"><span class="lineNum">    6045 </span><span class="lineCov">          6 :      return status;</span></a>
<a name="6046"><span class="lineNum">    6046 </span>            :    }</a>
<a name="6047"><span class="lineNum">    6047 </span>            : </a>
<a name="6048"><span class="lineNum">    6048 </span>            : // DQ (12/22/2005): Jochen's support for a constant (non-NULL) valued pointer</a>
<a name="6049"><span class="lineNum">    6049 </span>            : // to use to distinguish valid from invalid IR nodes within the memory pools.</a>
<a name="6050"><span class="lineNum">    6050 </span>            : namespace AST_FileIO</a>
<a name="6051"><span class="lineNum">    6051 </span>            :    {</a>
<a name="6052"><span class="lineNum">    6052 </span><span class="lineCov"> 2302140000 :      SgNode* IS_VALID_POINTER()</span></a>
<a name="6053"><span class="lineNum">    6053 </span>            :         {</a>
<a name="6054"><span class="lineNum">    6054 </span>            :        // static SgNode* value = (SgNode*)(new char[1]);</a>
<a name="6055"><span class="lineNum">    6055 </span>            : </a>
<a name="6056"><span class="lineNum">    6056 </span>            :        // DQ (1/17/2006): Set to the pointer value 0xffffffff (as used by std::string::npos)</a>
<a name="6057"><span class="lineNum">    6057 </span><span class="lineCov"> 2302140000 :           static SgNode* value = (SgNode*)(std::string::npos);</span></a>
<a name="6058"><span class="lineNum">    6058 </span>            :        // printf (&quot;In AST_FileIO::IS_VALID_POINTER(): value = %p \n&quot;,value);</a>
<a name="6059"><span class="lineNum">    6059 </span>            : </a>
<a name="6060"><span class="lineNum">    6060 </span><span class="lineCov"> 2302140000 :           return value;</span></a>
<a name="6061"><span class="lineNum">    6061 </span>            :         }</a>
<a name="6062"><span class="lineNum">    6062 </span>            : </a>
<a name="6063"><span class="lineNum">    6063 </span>            :   // similar vlue for reprentation of subsets of the AST</a>
<a name="6064"><span class="lineNum">    6064 </span><span class="lineNoCov">          0 :      SgNode* TO_BE_COPIED_POINTER()</span></a>
<a name="6065"><span class="lineNum">    6065 </span>            :         {</a>
<a name="6066"><span class="lineNum">    6066 </span>            :        // static SgNode* value = (SgNode*)(new char[1]);</a>
<a name="6067"><span class="lineNum">    6067 </span><span class="lineNoCov">          0 :           static SgNode* value = (SgNode*)((std::string::npos) - 1);</span></a>
<a name="6068"><span class="lineNum">    6068 </span>            :        // printf (&quot;In AST_FileIO::TO_BE_COPIED_POINTER(): value = %p \n&quot;,value);</a>
<a name="6069"><span class="lineNum">    6069 </span><span class="lineNoCov">          0 :           return value;</span></a>
<a name="6070"><span class="lineNum">    6070 </span>            :         }</a>
<a name="6071"><span class="lineNum">    6071 </span>            :    }</a>
<a name="6072"><span class="lineNum">    6072 </span>            : </a>
<a name="6073"><span class="lineNum">    6073 </span>            : </a>
<a name="6074"><span class="lineNum">    6074 </span>            : //! Prints pragma associated with a grammatical element.</a>
<a name="6075"><span class="lineNum">    6075 </span>            : /*!       (fill in more detail here!)</a>
<a name="6076"><span class="lineNum">    6076 </span>            :  */</a>
<a name="6077"><span class="lineNum">    6077 </span>            : void</a>
<a name="6078"><span class="lineNum">    6078 </span><span class="lineNoCov">          0 : print_pragma(SgAttributePtrList&amp; pattr, std::ostream&amp; os)</span></a>
<a name="6079"><span class="lineNum">    6079 </span>            :    {</a>
<a name="6080"><span class="lineNum">    6080 </span><span class="lineNoCov">          0 :      SgAttributePtrList::const_iterator p = pattr.begin();</span></a>
<a name="6081"><span class="lineNum">    6081 </span><span class="lineNoCov">          0 :      if (p == pattr.end())</span></a>
<a name="6082"><span class="lineNum">    6082 </span><span class="lineNoCov">          0 :           return;</span></a>
<a name="6083"><span class="lineNum">    6083 </span>            :        else</a>
<a name="6084"><span class="lineNum">    6084 </span><span class="lineNoCov">          0 :           p++;</span></a>
<a name="6085"><span class="lineNum">    6085 </span>            : </a>
<a name="6086"><span class="lineNum">    6086 </span><span class="lineNoCov">          0 :      while (p != pattr.end())</span></a>
<a name="6087"><span class="lineNum">    6087 </span>            :         {</a>
<a name="6088"><span class="lineNum">    6088 </span><span class="lineNoCov">          0 :           if ( (*p)-&gt;isPragma() )</span></a>
<a name="6089"><span class="lineNum">    6089 </span>            :              {</a>
<a name="6090"><span class="lineNum">    6090 </span><span class="lineNoCov">          0 :                SgPragma *pr = (SgPragma*)(*p);</span></a>
<a name="6091"><span class="lineNum">    6091 </span><span class="lineNoCov">          0 :                if (!pr-&gt;gotPrinted())</span></a>
<a name="6092"><span class="lineNum">    6092 </span>            :                   {</a>
<a name="6093"><span class="lineNum">    6093 </span><span class="lineNoCov">          0 :                     os &lt;&lt; std::endl &lt;&lt; &quot;#pragma &quot; &lt;&lt;pr-&gt;get_name() &lt;&lt; std::endl;</span></a>
<a name="6094"><span class="lineNum">    6094 </span><span class="lineNoCov">          0 :                     pr-&gt;setPrinted(1);</span></a>
<a name="6095"><span class="lineNum">    6095 </span>            :                   }</a>
<a name="6096"><span class="lineNum">    6096 </span>            :              }</a>
<a name="6097"><span class="lineNum">    6097 </span><span class="lineNoCov">          0 :           p++;</span></a>
<a name="6098"><span class="lineNum">    6098 </span>            :         }</a>
<a name="6099"><span class="lineNum">    6099 </span>            :    }</a>
<a name="6100"><span class="lineNum">    6100 </span>            : </a>
<a name="6101"><span class="lineNum">    6101 </span>            : </a>
<a name="6102"><span class="lineNum">    6102 </span>            : </a>
<a name="6103"><span class="lineNum">    6103 </span>            : </a>
<a name="6104"><span class="lineNum">    6104 </span>            : // Temporary function to be later put into Sg_FileInfo</a>
<a name="6105"><span class="lineNum">    6105 </span>            : StringUtility::FileNameLocation</a>
<a name="6106"><span class="lineNum">    6106 </span><span class="lineNoCov">          0 : get_location ( Sg_File_Info* X )</span></a>
<a name="6107"><span class="lineNum">    6107 </span>            :    {</a>
<a name="6108"><span class="lineNum">    6108 </span><span class="lineNoCov">          0 :      SgFile* file = TransformationSupport::getFile(X-&gt;get_parent());</span></a>
<a name="6109"><span class="lineNum">    6109 </span><span class="lineNoCov">          0 :      ASSERT_not_null(file);</span></a>
<a name="6110"><span class="lineNum">    6110 </span><span class="lineNoCov">          0 :      string sourceFilename = file-&gt;getFileName();</span></a>
<a name="6111"><span class="lineNum">    6111 </span><span class="lineNoCov">          0 :      string sourceDirectory = StringUtility::getPathFromFileName(sourceFilename);</span></a>
<a name="6112"><span class="lineNum">    6112 </span>            : </a>
<a name="6113"><span class="lineNum">    6113 </span><span class="lineNoCov">          0 :      StringUtility::FileNameClassification classification = StringUtility::classifyFileName(X-&gt;get_filenameString(),sourceDirectory,StringUtility::getOSType());</span></a>
<a name="6114"><span class="lineNum">    6114 </span>            : </a>
<a name="6115"><span class="lineNum">    6115 </span>            :   // return StringUtility::FILENAME_LOCATION_UNKNOWN;</a>
<a name="6116"><span class="lineNum">    6116 </span><span class="lineNoCov">          0 :      return classification.getLocation();</span></a>
<a name="6117"><span class="lineNum">    6117 </span>            :    }</a>
<a name="6118"><span class="lineNum">    6118 </span>            : </a>
<a name="6119"><span class="lineNum">    6119 </span>            : StringUtility::FileNameLibrary</a>
<a name="6120"><span class="lineNum">    6120 </span><span class="lineNoCov">          0 : get_library ( Sg_File_Info* X )</span></a>
<a name="6121"><span class="lineNum">    6121 </span>            :    {</a>
<a name="6122"><span class="lineNum">    6122 </span><span class="lineNoCov">          0 :      SgFile* file = TransformationSupport::getFile(X-&gt;get_parent());</span></a>
<a name="6123"><span class="lineNum">    6123 </span><span class="lineNoCov">          0 :      ASSERT_not_null(file);</span></a>
<a name="6124"><span class="lineNum">    6124 </span><span class="lineNoCov">          0 :      string sourceFilename = file-&gt;getFileName();</span></a>
<a name="6125"><span class="lineNum">    6125 </span><span class="lineNoCov">          0 :      string sourceDirectory = StringUtility::getPathFromFileName(sourceFilename);</span></a>
<a name="6126"><span class="lineNum">    6126 </span>            : </a>
<a name="6127"><span class="lineNum">    6127 </span><span class="lineNoCov">          0 :      StringUtility::FileNameClassification classification = StringUtility::classifyFileName(X-&gt;get_filenameString(),sourceDirectory,StringUtility::getOSType());</span></a>
<a name="6128"><span class="lineNum">    6128 </span>            : </a>
<a name="6129"><span class="lineNum">    6129 </span>            :   // return StringUtility::FILENAME_LIBRARY_UNKNOWN;</a>
<a name="6130"><span class="lineNum">    6130 </span><span class="lineNoCov">          0 :      return classification.getLibrary();</span></a>
<a name="6131"><span class="lineNum">    6131 </span>            :    }</a>
<a name="6132"><span class="lineNum">    6132 </span>            : </a>
<a name="6133"><span class="lineNum">    6133 </span>            : std::string</a>
<a name="6134"><span class="lineNum">    6134 </span><span class="lineNoCov">          0 : get_libraryName ( Sg_File_Info* X )</span></a>
<a name="6135"><span class="lineNum">    6135 </span>            :    {</a>
<a name="6136"><span class="lineNum">    6136 </span><span class="lineNoCov">          0 :      SgFile* file = TransformationSupport::getFile(X-&gt;get_parent());</span></a>
<a name="6137"><span class="lineNum">    6137 </span><span class="lineNoCov">          0 :      ASSERT_not_null(file);</span></a>
<a name="6138"><span class="lineNum">    6138 </span><span class="lineNoCov">          0 :      string sourceFilename = file-&gt;getFileName();</span></a>
<a name="6139"><span class="lineNum">    6139 </span><span class="lineNoCov">          0 :      string sourceDirectory = StringUtility::getPathFromFileName(sourceFilename);</span></a>
<a name="6140"><span class="lineNum">    6140 </span>            : </a>
<a name="6141"><span class="lineNum">    6141 </span><span class="lineNoCov">          0 :      StringUtility::FileNameClassification classification = StringUtility::classifyFileName(X-&gt;get_filenameString(),sourceDirectory,StringUtility::getOSType());</span></a>
<a name="6142"><span class="lineNum">    6142 </span>            : </a>
<a name="6143"><span class="lineNum">    6143 </span>            :   // return &quot;&quot;;</a>
<a name="6144"><span class="lineNum">    6144 </span><span class="lineNoCov">          0 :      return classification.getLibraryName();</span></a>
<a name="6145"><span class="lineNum">    6145 </span>            :    }</a>
<a name="6146"><span class="lineNum">    6146 </span>            : </a>
<a name="6147"><span class="lineNum">    6147 </span>            : StringUtility::OSType</a>
<a name="6148"><span class="lineNum">    6148 </span><span class="lineNoCov">          0 : get_OS_type ()</span></a>
<a name="6149"><span class="lineNum">    6149 </span>            :    {</a>
<a name="6150"><span class="lineNum">    6150 </span>            :   // return StringUtility::OS_TYPE_UNKNOWN;</a>
<a name="6151"><span class="lineNum">    6151 </span><span class="lineNoCov">          0 :      return StringUtility::getOSType();</span></a>
<a name="6152"><span class="lineNum">    6152 </span>            :    }</a>
<a name="6153"><span class="lineNum">    6153 </span>            : </a>
<a name="6154"><span class="lineNum">    6154 </span>            : int</a>
<a name="6155"><span class="lineNum">    6155 </span><span class="lineNoCov">          0 : get_distanceFromSourceDirectory ( Sg_File_Info* X )</span></a>
<a name="6156"><span class="lineNum">    6156 </span>            :    {</a>
<a name="6157"><span class="lineNum">    6157 </span><span class="lineNoCov">          0 :      SgFile* file = TransformationSupport::getFile(X-&gt;get_parent());</span></a>
<a name="6158"><span class="lineNum">    6158 </span><span class="lineNoCov">          0 :      ASSERT_not_null(file);</span></a>
<a name="6159"><span class="lineNum">    6159 </span><span class="lineNoCov">          0 :      string sourceFilename = file-&gt;getFileName();</span></a>
<a name="6160"><span class="lineNum">    6160 </span><span class="lineNoCov">          0 :      string sourceDirectory = StringUtility::getPathFromFileName(sourceFilename);</span></a>
<a name="6161"><span class="lineNum">    6161 </span>            : </a>
<a name="6162"><span class="lineNum">    6162 </span><span class="lineNoCov">          0 :      StringUtility::FileNameClassification classification = StringUtility::classifyFileName(X-&gt;get_filenameString(),sourceDirectory,StringUtility::getOSType());</span></a>
<a name="6163"><span class="lineNum">    6163 </span>            : </a>
<a name="6164"><span class="lineNum">    6164 </span>            :   // return 0;</a>
<a name="6165"><span class="lineNum">    6165 </span><span class="lineNoCov">          0 :      return classification.getDistanceFromSourceDirectory();</span></a>
<a name="6166"><span class="lineNum">    6166 </span>            :    }</a>
<a name="6167"><span class="lineNum">    6167 </span>            : </a>
<a name="6168"><span class="lineNum">    6168 </span>            : </a>
<a name="6169"><span class="lineNum">    6169 </span>            : </a>
<a name="6170"><span class="lineNum">    6170 </span>            : </a>
<a name="6171"><span class="lineNum">    6171 </span>            : </a>
<a name="6172"><span class="lineNum">    6172 </span>            : int</a>
<a name="6173"><span class="lineNum">    6173 </span><span class="lineNoCov">          0 : SgNode::numberOfNodesInSubtree()</span></a>
<a name="6174"><span class="lineNum">    6174 </span>            :    {</a>
<a name="6175"><span class="lineNum">    6175 </span><span class="lineNoCov">          0 :      int value = 0;</span></a>
<a name="6176"><span class="lineNum">    6176 </span>            : </a>
<a name="6177"><span class="lineNum">    6177 </span><span class="lineNoCov">          0 :      class CountTraversal : public SgSimpleProcessing</span></a>
<a name="6178"><span class="lineNum">    6178 </span>            :         {</a>
<a name="6179"><span class="lineNum">    6179 </span>            :           public:</a>
<a name="6180"><span class="lineNum">    6180 </span>            :               int count;</a>
<a name="6181"><span class="lineNum">    6181 </span><span class="lineNoCov">          0 :               CountTraversal() : count(0) {}</span></a>
<a name="6182"><span class="lineNum">    6182 </span><span class="lineNoCov">          0 :               void visit ( SgNode* n ) { count++; }</span></a>
<a name="6183"><span class="lineNum">    6183 </span>            :         };</a>
<a name="6184"><span class="lineNum">    6184 </span>            : </a>
<a name="6185"><span class="lineNum">    6185 </span><span class="lineNoCov">          0 :      CountTraversal counter;</span></a>
<a name="6186"><span class="lineNum">    6186 </span><span class="lineNoCov">          0 :      SgNode* thisNode = const_cast&lt;SgNode*&gt;(this);</span></a>
<a name="6187"><span class="lineNum">    6187 </span><span class="lineNoCov">          0 :      counter.traverse(thisNode,preorder);</span></a>
<a name="6188"><span class="lineNum">    6188 </span><span class="lineNoCov">          0 :      value = counter.count;</span></a>
<a name="6189"><span class="lineNum">    6189 </span>            : </a>
<a name="6190"><span class="lineNum">    6190 </span><span class="lineNoCov">          0 :      return value;</span></a>
<a name="6191"><span class="lineNum">    6191 </span>            :    }</a>
<a name="6192"><span class="lineNum">    6192 </span>            : </a>
<a name="6193"><span class="lineNum">    6193 </span>            : namespace SgNode_depthOfSubtree</a>
<a name="6194"><span class="lineNum">    6194 </span>            :    {</a>
<a name="6195"><span class="lineNum">    6195 </span>            :   // This class (AST traversal) could not be defined in the function SgNode::depthOfSubtree()</a>
<a name="6196"><span class="lineNum">    6196 </span>            :   // So I have constructed a namespace for this class to be implemented outside of the function.</a>
<a name="6197"><span class="lineNum">    6197 </span>            : </a>
<a name="6198"><span class="lineNum">    6198 </span>            :      class DepthInheritedAttribute</a>
<a name="6199"><span class="lineNum">    6199 </span>            :         {</a>
<a name="6200"><span class="lineNum">    6200 </span>            :           public:</a>
<a name="6201"><span class="lineNum">    6201 </span>            :                int treeDepth;</a>
<a name="6202"><span class="lineNum">    6202 </span><span class="lineNoCov">          0 :                DepthInheritedAttribute( int depth ) : treeDepth(depth) {}</span></a>
<a name="6203"><span class="lineNum">    6203 </span>            :         };</a>
<a name="6204"><span class="lineNum">    6204 </span>            : </a>
<a name="6205"><span class="lineNum">    6205 </span><span class="lineNoCov">          0 :      class MaxDepthTraversal : public AstTopDownProcessing&lt;DepthInheritedAttribute&gt;</span></a>
<a name="6206"><span class="lineNum">    6206 </span>            :         {</a>
<a name="6207"><span class="lineNum">    6207 </span>            :           public:</a>
<a name="6208"><span class="lineNum">    6208 </span>            :               int maxDepth;</a>
<a name="6209"><span class="lineNum">    6209 </span><span class="lineNoCov">          0 :               MaxDepthTraversal() : maxDepth(0) {}</span></a>
<a name="6210"><span class="lineNum">    6210 </span>            : </a>
<a name="6211"><span class="lineNum">    6211 </span><span class="lineNoCov">          0 :               DepthInheritedAttribute evaluateInheritedAttribute ( SgNode* astNode, DepthInheritedAttribute inheritedAttribute )</span></a>
<a name="6212"><span class="lineNum">    6212 </span>            :                  {</a>
<a name="6213"><span class="lineNum">    6213 </span><span class="lineNoCov">          0 :                    if (inheritedAttribute.treeDepth &gt; maxDepth)</span></a>
<a name="6214"><span class="lineNum">    6214 </span><span class="lineNoCov">          0 :                         maxDepth = inheritedAttribute.treeDepth;</span></a>
<a name="6215"><span class="lineNum">    6215 </span>            : #if 0</a>
<a name="6216"><span class="lineNum">    6216 </span>            :                    printf (&quot;maxDepth = %d for IR nodes = %p = %s \n&quot;,maxDepth,astNode,astNode-&gt;class_name().c_str());</a>
<a name="6217"><span class="lineNum">    6217 </span>            : #endif</a>
<a name="6218"><span class="lineNum">    6218 </span><span class="lineNoCov">          0 :                    return DepthInheritedAttribute(inheritedAttribute.treeDepth + 1);</span></a>
<a name="6219"><span class="lineNum">    6219 </span>            :                  }</a>
<a name="6220"><span class="lineNum">    6220 </span>            :         };</a>
<a name="6221"><span class="lineNum">    6221 </span>            :    }</a>
<a name="6222"><span class="lineNum">    6222 </span>            : </a>
<a name="6223"><span class="lineNum">    6223 </span>            : int</a>
<a name="6224"><span class="lineNum">    6224 </span><span class="lineNoCov">          0 : SgNode::depthOfSubtree()</span></a>
<a name="6225"><span class="lineNum">    6225 </span>            :    {</a>
<a name="6226"><span class="lineNum">    6226 </span><span class="lineNoCov">          0 :      int value = 0;</span></a>
<a name="6227"><span class="lineNum">    6227 </span>            : </a>
<a name="6228"><span class="lineNum">    6228 </span><span class="lineNoCov">          0 :      SgNode_depthOfSubtree::MaxDepthTraversal depthCounter;</span></a>
<a name="6229"><span class="lineNum">    6229 </span><span class="lineNoCov">          0 :      SgNode_depthOfSubtree::DepthInheritedAttribute inheritedAttribute(0);</span></a>
<a name="6230"><span class="lineNum">    6230 </span><span class="lineNoCov">          0 :      SgNode* thisNode = const_cast&lt;SgNode*&gt;(this);</span></a>
<a name="6231"><span class="lineNum">    6231 </span>            : </a>
<a name="6232"><span class="lineNum">    6232 </span><span class="lineNoCov">          0 :      depthCounter.traverse(thisNode,inheritedAttribute);</span></a>
<a name="6233"><span class="lineNum">    6233 </span>            : </a>
<a name="6234"><span class="lineNum">    6234 </span><span class="lineNoCov">          0 :      value = depthCounter.maxDepth;</span></a>
<a name="6235"><span class="lineNum">    6235 </span>            : </a>
<a name="6236"><span class="lineNum">    6236 </span><span class="lineNoCov">          0 :      return value;</span></a>
<a name="6237"><span class="lineNum">    6237 </span>            :    }</a>
<a name="6238"><span class="lineNum">    6238 </span>            : </a>
<a name="6239"><span class="lineNum">    6239 </span>            : #if 0</a>
<a name="6240"><span class="lineNum">    6240 </span>            : // We only need one definition for this function at the SgNode IR node.</a>
<a name="6241"><span class="lineNum">    6241 </span>            : size_t</a>
<a name="6242"><span class="lineNum">    6242 </span>            : SgFile::numberOfNodesInSubtree()</a>
<a name="6243"><span class="lineNum">    6243 </span>            :    {</a>
<a name="6244"><span class="lineNum">    6244 </span>            :      printf (&quot;Base class of virtual function (SgFile::numberOfNodesInSubtree() should not be called! \n&quot;);</a>
<a name="6245"><span class="lineNum">    6245 </span>            :      ROSE_ABORT();</a>
<a name="6246"><span class="lineNum">    6246 </span>            :    }</a>
<a name="6247"><span class="lineNum">    6247 </span>            : </a>
<a name="6248"><span class="lineNum">    6248 </span>            : size_t</a>
<a name="6249"><span class="lineNum">    6249 </span>            : SgSourceFile::numberOfNodesInSubtree()</a>
<a name="6250"><span class="lineNum">    6250 </span>            :    {</a>
<a name="6251"><span class="lineNum">    6251 </span>            :      return get_globalScope()-&gt;numberOfNodesInSubtree() + 1;</a>
<a name="6252"><span class="lineNum">    6252 </span>            :    }</a>
<a name="6253"><span class="lineNum">    6253 </span>            : #endif</a>
<a name="6254"><span class="lineNum">    6254 </span>            : </a>
<a name="6255"><span class="lineNum">    6255 </span>            : </a>
<a name="6256"><span class="lineNum">    6256 </span>            : // DQ (10/3/2008): Added support for getting interfaces in a module</a>
<a name="6257"><span class="lineNum">    6257 </span>            : std::vector&lt;SgInterfaceStatement*&gt;</a>
<a name="6258"><span class="lineNum">    6258 </span><span class="lineNoCov">          0 : SgModuleStatement::get_interfaces() const</span></a>
<a name="6259"><span class="lineNum">    6259 </span>            :    {</a>
<a name="6260"><span class="lineNum">    6260 </span><span class="lineNoCov">          0 :      std::vector&lt;SgInterfaceStatement*&gt; returnList;</span></a>
<a name="6261"><span class="lineNum">    6261 </span>            : </a>
<a name="6262"><span class="lineNum">    6262 </span><span class="lineNoCov">          0 :      SgModuleStatement* definingModuleStatement = isSgModuleStatement(get_definingDeclaration());</span></a>
<a name="6263"><span class="lineNum">    6263 </span><span class="lineNoCov">          0 :      ASSERT_not_null(definingModuleStatement);</span></a>
<a name="6264"><span class="lineNum">    6264 </span>            : </a>
<a name="6265"><span class="lineNum">    6265 </span><span class="lineNoCov">          0 :      SgClassDefinition* moduleDefinition = definingModuleStatement-&gt;get_definition();</span></a>
<a name="6266"><span class="lineNum">    6266 </span><span class="lineNoCov">          0 :      ASSERT_not_null(moduleDefinition);</span></a>
<a name="6267"><span class="lineNum">    6267 </span>            : </a>
<a name="6268"><span class="lineNum">    6268 </span><span class="lineNoCov">          0 :      SgDeclarationStatementPtrList &amp; declarationList = moduleDefinition-&gt;getDeclarationList();</span></a>
<a name="6269"><span class="lineNum">    6269 </span>            : </a>
<a name="6270"><span class="lineNum">    6270 </span><span class="lineNoCov">          0 :      SgDeclarationStatementPtrList::iterator i = declarationList.begin();</span></a>
<a name="6271"><span class="lineNum">    6271 </span><span class="lineNoCov">          0 :      while (i != declarationList.end())</span></a>
<a name="6272"><span class="lineNum">    6272 </span>            :         {</a>
<a name="6273"><span class="lineNum">    6273 </span><span class="lineNoCov">          0 :           SgInterfaceStatement* interfaceStatement = isSgInterfaceStatement(*i);</span></a>
<a name="6274"><span class="lineNum">    6274 </span><span class="lineNoCov">          0 :           if (interfaceStatement != nullptr)</span></a>
<a name="6275"><span class="lineNum">    6275 </span>            :              {</a>
<a name="6276"><span class="lineNum">    6276 </span><span class="lineNoCov">          0 :                returnList.push_back(interfaceStatement);</span></a>
<a name="6277"><span class="lineNum">    6277 </span>            :              }</a>
<a name="6278"><span class="lineNum">    6278 </span>            : </a>
<a name="6279"><span class="lineNum">    6279 </span><span class="lineNoCov">          0 :           i++;</span></a>
<a name="6280"><span class="lineNum">    6280 </span>            :         }</a>
<a name="6281"><span class="lineNum">    6281 </span>            : </a>
<a name="6282"><span class="lineNum">    6282 </span><span class="lineNoCov">          0 :      return  returnList;</span></a>
<a name="6283"><span class="lineNum">    6283 </span>            :    }</a>
<a name="6284"><span class="lineNum">    6284 </span>            : </a>
<a name="6285"><span class="lineNum">    6285 </span>            : // DQ (11/23/2008): This is a static function</a>
<a name="6286"><span class="lineNum">    6286 </span>            : SgC_PreprocessorDirectiveStatement*</a>
<a name="6287"><span class="lineNum">    6287 </span><span class="lineNoCov">          0 : SgC_PreprocessorDirectiveStatement::createDirective ( PreprocessingInfo* currentPreprocessingInfo )</span></a>
<a name="6288"><span class="lineNum">    6288 </span>            :    {</a>
<a name="6289"><span class="lineNum">    6289 </span>            :   // This is the new factory interface to build CPP directives as IR nodes.</a>
<a name="6290"><span class="lineNum">    6290 </span><span class="lineNoCov">          0 :      PreprocessingInfo::DirectiveType directive = currentPreprocessingInfo-&gt;getTypeOfDirective();</span></a>
<a name="6291"><span class="lineNum">    6291 </span>            : </a>
<a name="6292"><span class="lineNum">    6292 </span>            :   // SgC_PreprocessorDirectiveStatement* cppDirective = new SgEmptyDirectiveStatement();</a>
<a name="6293"><span class="lineNum">    6293 </span><span class="lineNoCov">          0 :      SgC_PreprocessorDirectiveStatement* cppDirective = nullptr;</span></a>
<a name="6294"><span class="lineNum">    6294 </span>            : </a>
<a name="6295"><span class="lineNum">    6295 </span><span class="lineNoCov">          0 :      switch(directive)</span></a>
<a name="6296"><span class="lineNum">    6296 </span>            :         {</a>
<a name="6297"><span class="lineNum">    6297 </span><span class="lineNoCov">          0 :           case PreprocessingInfo::CpreprocessorUnknownDeclaration:</span></a>
<a name="6298"><span class="lineNum">    6298 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="6299"><span class="lineNum">    6299 </span>            :             // I think this is an error...</a>
<a name="6300"><span class="lineNum">    6300 </span>            :             // locatedNode-&gt;addToAttachedPreprocessingInfo(currentPreprocessingInfoPtr);</a>
<a name="6301"><span class="lineNum">    6301 </span><span class="lineNoCov">          0 :                printf (&quot;Error: directive == PreprocessingInfo::CpreprocessorUnknownDeclaration \n&quot;);</span></a>
<a name="6302"><span class="lineNum">    6302 </span><span class="lineNoCov">          0 :                ROSE_ABORT();</span></a>
<a name="6303"><span class="lineNum">    6303 </span>            :              }</a>
<a name="6304"><span class="lineNum">    6304 </span>            : </a>
<a name="6305"><span class="lineNum">    6305 </span><span class="lineNoCov">          0 :           case PreprocessingInfo::C_StyleComment:</span></a>
<a name="6306"><span class="lineNum">    6306 </span><span class="lineNoCov">          0 :           case PreprocessingInfo::CplusplusStyleComment:</span></a>
<a name="6307"><span class="lineNum">    6307 </span><span class="lineNoCov">          0 :           case PreprocessingInfo::FortranStyleComment:</span></a>
<a name="6308"><span class="lineNum">    6308 </span><span class="lineNoCov">          0 :           case PreprocessingInfo::CpreprocessorBlankLine:</span></a>
<a name="6309"><span class="lineNum">    6309 </span><span class="lineNoCov">          0 :           case PreprocessingInfo::ClinkageSpecificationStart:</span></a>
<a name="6310"><span class="lineNum">    6310 </span><span class="lineNoCov">          0 :           case PreprocessingInfo::ClinkageSpecificationEnd:</span></a>
<a name="6311"><span class="lineNum">    6311 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="6312"><span class="lineNum">    6312 </span><span class="lineNoCov">          0 :                printf (&quot;Error: these cases could not generate a new IR node (directiveTypeName = %s) \n&quot;,PreprocessingInfo::directiveTypeName(directive).c_str());</span></a>
<a name="6313"><span class="lineNum">    6313 </span><span class="lineNoCov">          0 :                ROSE_ABORT();</span></a>
<a name="6314"><span class="lineNum">    6314 </span>            :              }</a>
<a name="6315"><span class="lineNum">    6315 </span>            : </a>
<a name="6316"><span class="lineNum">    6316 </span><span class="lineNoCov">          0 :           case PreprocessingInfo::CpreprocessorIncludeDeclaration:          { cppDirective = new SgIncludeDirectiveStatement();     break; }</span></a>
<a name="6317"><span class="lineNum">    6317 </span><span class="lineNoCov">          0 :           case PreprocessingInfo::CpreprocessorIncludeNextDeclaration:      { cppDirective = new SgIncludeNextDirectiveStatement(); break; }</span></a>
<a name="6318"><span class="lineNum">    6318 </span><span class="lineNoCov">          0 :           case PreprocessingInfo::CpreprocessorDefineDeclaration:           { cppDirective = new SgDefineDirectiveStatement();      break; }</span></a>
<a name="6319"><span class="lineNum">    6319 </span><span class="lineNoCov">          0 :           case PreprocessingInfo::CpreprocessorUndefDeclaration:            { cppDirective = new SgUndefDirectiveStatement();       break; }</span></a>
<a name="6320"><span class="lineNum">    6320 </span><span class="lineNoCov">          0 :           case PreprocessingInfo::CpreprocessorIfdefDeclaration:            { cppDirective = new SgIfdefDirectiveStatement();       break; }</span></a>
<a name="6321"><span class="lineNum">    6321 </span><span class="lineNoCov">          0 :           case PreprocessingInfo::CpreprocessorIfndefDeclaration:           { cppDirective = new SgIfndefDirectiveStatement();      break; }</span></a>
<a name="6322"><span class="lineNum">    6322 </span><span class="lineNoCov">          0 :           case PreprocessingInfo::CpreprocessorIfDeclaration:               { cppDirective = new SgIfDirectiveStatement();          break; }</span></a>
<a name="6323"><span class="lineNum">    6323 </span><span class="lineNoCov">          0 :           case PreprocessingInfo::CpreprocessorDeadIfDeclaration:           { cppDirective = new SgDeadIfDirectiveStatement();      break; }</span></a>
<a name="6324"><span class="lineNum">    6324 </span><span class="lineNoCov">          0 :           case PreprocessingInfo::CpreprocessorElseDeclaration:             { cppDirective = new SgElseDirectiveStatement();        break; }</span></a>
<a name="6325"><span class="lineNum">    6325 </span><span class="lineNoCov">          0 :           case PreprocessingInfo::CpreprocessorElifDeclaration:             { cppDirective = new SgElseifDirectiveStatement();      break; }</span></a>
<a name="6326"><span class="lineNum">    6326 </span><span class="lineNoCov">          0 :           case PreprocessingInfo::CpreprocessorEndifDeclaration:            { cppDirective = new SgEndifDirectiveStatement();       break; }</span></a>
<a name="6327"><span class="lineNum">    6327 </span><span class="lineNoCov">          0 :           case PreprocessingInfo::CpreprocessorLineDeclaration:             { cppDirective = new SgLineDirectiveStatement();        break; }</span></a>
<a name="6328"><span class="lineNum">    6328 </span><span class="lineNoCov">          0 :           case PreprocessingInfo::CpreprocessorErrorDeclaration:            { cppDirective = new SgErrorDirectiveStatement();       break; }</span></a>
<a name="6329"><span class="lineNum">    6329 </span><span class="lineNoCov">          0 :           case PreprocessingInfo::CpreprocessorWarningDeclaration:          { cppDirective = new SgWarningDirectiveStatement();     break; }</span></a>
<a name="6330"><span class="lineNum">    6330 </span><span class="lineNoCov">          0 :           case PreprocessingInfo::CpreprocessorEmptyDeclaration:            { cppDirective = new SgEmptyDirectiveStatement();       break; }</span></a>
<a name="6331"><span class="lineNum">    6331 </span><span class="lineNoCov">          0 :           case PreprocessingInfo::CpreprocessorIdentDeclaration:            { cppDirective = new SgIdentDirectiveStatement();       break; }</span></a>
<a name="6332"><span class="lineNum">    6332 </span><span class="lineNoCov">          0 :           case PreprocessingInfo::CpreprocessorCompilerGeneratedLinemarker: { cppDirective = new SgLinemarkerDirectiveStatement();  break; }</span></a>
<a name="6333"><span class="lineNum">    6333 </span>            : </a>
<a name="6334"><span class="lineNum">    6334 </span><span class="lineNoCov">          0 :           default:</span></a>
<a name="6335"><span class="lineNum">    6335 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="6336"><span class="lineNum">    6336 </span><span class="lineNoCov">          0 :                printf (&quot;Error: directive not handled directiveTypeName = %s \n&quot;,PreprocessingInfo::directiveTypeName(directive).c_str());</span></a>
<a name="6337"><span class="lineNum">    6337 </span><span class="lineNoCov">          0 :                ROSE_ABORT();</span></a>
<a name="6338"><span class="lineNum">    6338 </span>            :              }</a>
<a name="6339"><span class="lineNum">    6339 </span>            :         }</a>
<a name="6340"><span class="lineNum">    6340 </span>            : </a>
<a name="6341"><span class="lineNum">    6341 </span><span class="lineNoCov">          0 :      ASSERT_not_null(cppDirective);</span></a>
<a name="6342"><span class="lineNum">    6342 </span>            : </a>
<a name="6343"><span class="lineNum">    6343 </span><span class="lineNoCov">          0 :      printf (&quot;In SgC_PreprocessorDirectiveStatement::createDirective(): currentPreprocessingInfo-&gt;getString() = %s \n&quot;,currentPreprocessingInfo-&gt;getString().c_str());</span></a>
<a name="6344"><span class="lineNum">    6344 </span>            : </a>
<a name="6345"><span class="lineNum">    6345 </span><span class="lineNoCov">          0 :      cppDirective-&gt;set_directiveString(currentPreprocessingInfo-&gt;getString());</span></a>
<a name="6346"><span class="lineNum">    6346 </span>            : </a>
<a name="6347"><span class="lineNum">    6347 </span><span class="lineNoCov">          0 :      printf (&quot;In SgC_PreprocessorDirectiveStatement::createDirective(): cppDirective-&gt;get_directiveString() = %s \n&quot;,cppDirective-&gt;get_directiveString().c_str());</span></a>
<a name="6348"><span class="lineNum">    6348 </span>            : </a>
<a name="6349"><span class="lineNum">    6349 </span>            :   // Set the defining declaration to be a self reference...</a>
<a name="6350"><span class="lineNum">    6350 </span><span class="lineNoCov">          0 :      cppDirective-&gt;set_definingDeclaration(cppDirective);</span></a>
<a name="6351"><span class="lineNum">    6351 </span>            : </a>
<a name="6352"><span class="lineNum">    6352 </span>            :   // Build source position information...</a>
<a name="6353"><span class="lineNum">    6353 </span><span class="lineNoCov">          0 :      cppDirective-&gt;set_startOfConstruct(new Sg_File_Info(*(currentPreprocessingInfo-&gt;get_file_info())));</span></a>
<a name="6354"><span class="lineNum">    6354 </span><span class="lineNoCov">          0 :      cppDirective-&gt;set_endOfConstruct  (new Sg_File_Info(*(currentPreprocessingInfo-&gt;get_file_info())));</span></a>
<a name="6355"><span class="lineNum">    6355 </span>            : </a>
<a name="6356"><span class="lineNum">    6356 </span><span class="lineNoCov">          0 :      return cppDirective;</span></a>
<a name="6357"><span class="lineNum">    6357 </span>            :    }</a>
<a name="6358"><span class="lineNum">    6358 </span>            : </a>
<a name="6359"><span class="lineNum">    6359 </span>            : bool</a>
<a name="6360"><span class="lineNum">    6360 </span><span class="lineNoCov">          0 : StringUtility::popen_wrapper ( const string &amp; command, vector&lt;string&gt; &amp; result )</span></a>
<a name="6361"><span class="lineNum">    6361 </span>            :    {</a>
<a name="6362"><span class="lineNum">    6362 </span>            :   // DQ (2/5/2009): Simple wrapper for Unix popen command.</a>
<a name="6363"><span class="lineNum">    6363 </span>            : </a>
<a name="6364"><span class="lineNum">    6364 </span><span class="lineNoCov">          0 :      const int  SIZE = 10000;</span></a>
<a name="6365"><span class="lineNum">    6365 </span><span class="lineNoCov">          0 :      bool       returnValue = true;</span></a>
<a name="6366"><span class="lineNum">    6366 </span><span class="lineNoCov">          0 :      FILE*      fp = nullptr;</span></a>
<a name="6367"><span class="lineNum">    6367 </span><span class="lineNoCov">          0 :      char       buffer[SIZE];</span></a>
<a name="6368"><span class="lineNum">    6368 </span>            : </a>
<a name="6369"><span class="lineNum">    6369 </span><span class="lineNoCov">          0 :      result = vector&lt;string&gt;();</span></a>
<a name="6370"><span class="lineNum">    6370 </span>            : </a>
<a name="6371"><span class="lineNum">    6371 </span>            :      // CH (4/6/2010): The Windows version of popen is _popen</a>
<a name="6372"><span class="lineNum">    6372 </span>            : #ifdef _MSC_VER</a>
<a name="6373"><span class="lineNum">    6373 </span>            :      if ((fp = _popen(command.c_str (), &quot;r&quot;)) == nullptr)</a>
<a name="6374"><span class="lineNum">    6374 </span>            : #else</a>
<a name="6375"><span class="lineNum">    6375 </span><span class="lineNoCov">          0 :      if ((fp = popen(command.c_str (), &quot;r&quot;)) == nullptr)</span></a>
<a name="6376"><span class="lineNum">    6376 </span>            : #endif</a>
<a name="6377"><span class="lineNum">    6377 </span>            :         {</a>
<a name="6378"><span class="lineNum">    6378 </span><span class="lineNoCov">          0 :           cerr &lt;&lt; &quot;Files or processes cannot be created&quot; &lt;&lt; endl;</span></a>
<a name="6379"><span class="lineNum">    6379 </span><span class="lineNoCov">          0 :           returnValue = false;</span></a>
<a name="6380"><span class="lineNum">    6380 </span><span class="lineNoCov">          0 :           return returnValue;</span></a>
<a name="6381"><span class="lineNum">    6381 </span>            :         }</a>
<a name="6382"><span class="lineNum">    6382 </span>            : </a>
<a name="6383"><span class="lineNum">    6383 </span><span class="lineNoCov">          0 :      string  current_string;</span></a>
<a name="6384"><span class="lineNum">    6384 </span><span class="lineNoCov">          0 :      while (fgets(buffer, sizeof (buffer), fp))</span></a>
<a name="6385"><span class="lineNum">    6385 </span>            :         {</a>
<a name="6386"><span class="lineNum">    6386 </span><span class="lineNoCov">          0 :           current_string = buffer;</span></a>
<a name="6387"><span class="lineNum">    6387 </span><span class="lineNoCov">          0 :           if (current_string [current_string.size () - 1] != '\n')</span></a>
<a name="6388"><span class="lineNum">    6388 </span>            :              {</a>
<a name="6389"><span class="lineNum">    6389 </span><span class="lineNoCov">          0 :                cerr &lt;&lt; &quot;SIZEBUF too small (&quot; &lt;&lt; SIZE &lt;&lt; &quot;)&quot; &lt;&lt; endl;</span></a>
<a name="6390"><span class="lineNum">    6390 </span><span class="lineNoCov">          0 :                returnValue = false;</span></a>
<a name="6391"><span class="lineNum">    6391 </span>            :                return returnValue;</a>
<a name="6392"><span class="lineNum">    6392 </span>            :              }</a>
<a name="6393"><span class="lineNum">    6393 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(current_string [current_string.size () - 1] == '\n');</span></a>
<a name="6394"><span class="lineNum">    6394 </span><span class="lineNoCov">          0 :           result.push_back (current_string.substr (0, current_string.size () - 1));</span></a>
<a name="6395"><span class="lineNum">    6395 </span>            :         }</a>
<a name="6396"><span class="lineNum">    6396 </span>            : </a>
<a name="6397"><span class="lineNum">    6397 </span>            : #ifdef _MSC_VER</a>
<a name="6398"><span class="lineNum">    6398 </span>            :      if (_pclose(fp) == -1)</a>
<a name="6399"><span class="lineNum">    6399 </span>            : #else</a>
<a name="6400"><span class="lineNum">    6400 </span><span class="lineNoCov">          0 :      if (pclose(fp) == -1)</span></a>
<a name="6401"><span class="lineNum">    6401 </span>            : #endif</a>
<a name="6402"><span class="lineNum">    6402 </span>            :         {</a>
<a name="6403"><span class="lineNum">    6403 </span><span class="lineNoCov">          0 :           cerr &lt;&lt; (&quot;Cannot execute pclose&quot;);</span></a>
<a name="6404"><span class="lineNum">    6404 </span>            :           returnValue = false;</a>
<a name="6405"><span class="lineNum">    6405 </span>            :         }</a>
<a name="6406"><span class="lineNum">    6406 </span>            : </a>
<a name="6407"><span class="lineNum">    6407 </span>            :      return returnValue;</a>
<a name="6408"><span class="lineNum">    6408 </span>            :    }</a>
<a name="6409"><span class="lineNum">    6409 </span>            : </a>
<a name="6410"><span class="lineNum">    6410 </span>            : string</a>
<a name="6411"><span class="lineNum">    6411 </span><span class="lineNoCov">          0 : StringUtility::demangledName ( string s )</span></a>
<a name="6412"><span class="lineNum">    6412 </span>            :    {</a>
<a name="6413"><span class="lineNum">    6413 </span>            :   // Support for demangling of C++ names. We take care of an empty</a>
<a name="6414"><span class="lineNum">    6414 </span>            :   // string, but an input string with a single space might be an issue.</a>
<a name="6415"><span class="lineNum">    6415 </span>            : </a>
<a name="6416"><span class="lineNum">    6416 </span><span class="lineNoCov">          0 :      vector&lt;string&gt; result;</span></a>
<a name="6417"><span class="lineNum">    6417 </span><span class="lineNoCov">          0 :      if (s.empty() == false)</span></a>
<a name="6418"><span class="lineNum">    6418 </span>            :         {</a>
<a name="6419"><span class="lineNum">    6419 </span><span class="lineNoCov">          0 :           if (!popen_wrapper (&quot;c++filt &quot; + s, result))</span></a>
<a name="6420"><span class="lineNum">    6420 </span>            :              {</a>
<a name="6421"><span class="lineNum">    6421 </span><span class="lineNoCov">          0 :                cout &lt;&lt; &quot;Cannot execute popen_wrapper&quot; &lt;&lt; endl;</span></a>
<a name="6422"><span class="lineNum">    6422 </span><span class="lineNoCov">          0 :                return &quot;unknown demangling &quot; + s;</span></a>
<a name="6423"><span class="lineNum">    6423 </span>            :              }</a>
<a name="6424"><span class="lineNum">    6424 </span>            : #if 0</a>
<a name="6425"><span class="lineNum">    6425 </span>            :        // Debugging...</a>
<a name="6426"><span class="lineNum">    6426 </span>            :           for (size_t i = 0; i &lt; result.size (); i++)</a>
<a name="6427"><span class="lineNum">    6427 </span>            :              {</a>
<a name="6428"><span class="lineNum">    6428 </span>            :                cout &lt;&lt; &quot;[&quot; &lt;&lt; i &lt;&lt; &quot;]\t : &quot; &lt;&lt; result [i] &lt;&lt; endl;</a>
<a name="6429"><span class="lineNum">    6429 </span>            :              }</a>
<a name="6430"><span class="lineNum">    6430 </span>            : #endif</a>
<a name="6431"><span class="lineNum">    6431 </span>            :         }</a>
<a name="6432"><span class="lineNum">    6432 </span>            :        else</a>
<a name="6433"><span class="lineNum">    6433 </span>            :         {</a>
<a name="6434"><span class="lineNum">    6434 </span><span class="lineNoCov">          0 :           result.push_back(&quot;unknown&quot;);</span></a>
<a name="6435"><span class="lineNum">    6435 </span>            :         }</a>
<a name="6436"><span class="lineNum">    6436 </span>            : </a>
<a name="6437"><span class="lineNum">    6437 </span><span class="lineNoCov">          0 :      return result[0];</span></a>
<a name="6438"><span class="lineNum">    6438 </span>            :    }</a>
<a name="6439"><span class="lineNum">    6439 </span>            : </a>
<a name="6440"><span class="lineNum">    6440 </span>            : </a>
<a name="6441"><span class="lineNum">    6441 </span>            : SgFunctionDeclaration*</a>
<a name="6442"><span class="lineNum">    6442 </span><span class="lineCov">      20963 : SgFunctionCallExp::getAssociatedFunctionDeclaration() const</span></a>
<a name="6443"><span class="lineNum">    6443 </span>            :    {</a>
<a name="6444"><span class="lineNum">    6444 </span>            :   // This is helpful in chasing down the associated declaration to this function reference.</a>
<a name="6445"><span class="lineNum">    6445 </span><span class="lineCov">      20963 :      SgFunctionDeclaration* returnFunctionDeclaration = nullptr;</span></a>
<a name="6446"><span class="lineNum">    6446 </span>            : </a>
<a name="6447"><span class="lineNum">    6447 </span><span class="lineCov">      20963 :      SgFunctionSymbol* associatedFunctionSymbol = getAssociatedFunctionSymbol();</span></a>
<a name="6448"><span class="lineNum">    6448 </span>            :      // It can be NULL for a function pointer</a>
<a name="6449"><span class="lineNum">    6449 </span>            :      //ROSE_ASSERT(associatedFunctionSymbol != NULL);</a>
<a name="6450"><span class="lineNum">    6450 </span><span class="lineCov">      20963 :      if (associatedFunctionSymbol != nullptr)</span></a>
<a name="6451"><span class="lineNum">    6451 </span><span class="lineCov">      12560 :        returnFunctionDeclaration = associatedFunctionSymbol-&gt;get_declaration();</span></a>
<a name="6452"><span class="lineNum">    6452 </span>            : </a>
<a name="6453"><span class="lineNum">    6453 </span>            :     // ROSE_ASSERT(returnFunctionDeclaration != NULL);</a>
<a name="6454"><span class="lineNum">    6454 </span>            : </a>
<a name="6455"><span class="lineNum">    6455 </span><span class="lineCov">      20963 :      return returnFunctionDeclaration;</span></a>
<a name="6456"><span class="lineNum">    6456 </span>            :    }</a>
<a name="6457"><span class="lineNum">    6457 </span>            : </a>
<a name="6458"><span class="lineNum">    6458 </span>            : </a>
<a name="6459"><span class="lineNum">    6459 </span>            : SgFunctionSymbol*</a>
<a name="6460"><span class="lineNum">    6460 </span><span class="lineCov">      25922 : SgFunctionCallExp::getAssociatedFunctionSymbol() const</span></a>
<a name="6461"><span class="lineNum">    6461 </span>            :    {</a>
<a name="6462"><span class="lineNum">    6462 </span>            :   // This is helpful in chasing down the associated declaration to this function reference.</a>
<a name="6463"><span class="lineNum">    6463 </span>            :   // But this refactored function does the first step of getting the symbol, so that it</a>
<a name="6464"><span class="lineNum">    6464 </span>            :   // can also be used separately in the outlining support.</a>
<a name="6465"><span class="lineNum">    6465 </span><span class="lineCov">      25922 :      SgFunctionSymbol* returnSymbol = nullptr;</span></a>
<a name="6466"><span class="lineNum">    6466 </span>            : </a>
<a name="6467"><span class="lineNum">    6467 </span>            :   // Note that as I recall there are a number of different types of IR nodes that</a>
<a name="6468"><span class="lineNum">    6468 </span>            :   // the functionCallExp-&gt;get_function() can return (this is the complete list,</a>
<a name="6469"><span class="lineNum">    6469 </span>            :   // as tested in astConsistancyTests.C):</a>
<a name="6470"><span class="lineNum">    6470 </span>            :   //   - SgDotExp</a>
<a name="6471"><span class="lineNum">    6471 </span>            :   //   - SgDotStarOp</a>
<a name="6472"><span class="lineNum">    6472 </span>            :   //   - SgArrowExp</a>
<a name="6473"><span class="lineNum">    6473 </span>            :   //   - SgArrowStarOp</a>
<a name="6474"><span class="lineNum">    6474 </span>            :   //   - SgPointerDerefExp</a>
<a name="6475"><span class="lineNum">    6475 </span>            :   //   - SgAddressOfOp</a>
<a name="6476"><span class="lineNum">    6476 </span>            :   //   - SgFunctionRefExp</a>
<a name="6477"><span class="lineNum">    6477 </span>            :   //   - SgMemberFunctionRefExp</a>
<a name="6478"><span class="lineNum">    6478 </span>            :   //   - SgFunctionSymbol  // Liao 4/7/2017, discovered by a call to RAJA template functions using lambda expressions</a>
<a name="6479"><span class="lineNum">    6479 </span>            :   // schroder3 (2016-06-28): There are some more (see below).</a>
<a name="6480"><span class="lineNum">    6480 </span>            : </a>
<a name="6481"><span class="lineNum">    6481 </span>            :   // Some virtual functions are resolved statically (e.g. for objects allocated on the stack)</a>
<a name="6482"><span class="lineNum">    6482 </span><span class="lineCov">      25922 :      bool isAlwaysResolvedStatically = false;</span></a>
<a name="6483"><span class="lineNum">    6483 </span>            : </a>
<a name="6484"><span class="lineNum">    6484 </span><span class="lineCov">      25922 :      SgExpression* functionExp = this-&gt;get_function();</span></a>
<a name="6485"><span class="lineNum">    6485 </span>            : </a>
<a name="6486"><span class="lineNum">    6486 </span>            :      // schroder3 (2016-08-16): Moved the handling of SgPointerDerefExp and SgAddressOfOp above the switch. Due to this</a>
<a name="6487"><span class="lineNum">    6487 </span>            :      //  all pointer dereferences and address-ofs are removed from the function expression before it is analyzed.</a>
<a name="6488"><span class="lineNum">    6488 </span>            :      //  Member functions that are an operand of a pointer dereference or address-of are supported due to this now.</a>
<a name="6489"><span class="lineNum">    6489 </span>            :      //</a>
<a name="6490"><span class="lineNum">    6490 </span>            :      // schroder3 (2016-06-28): Added SgAddressOp (for example &quot;(&amp;f)()&quot;, &quot;(*&amp;***&amp;**&amp;*&amp;f)()&quot; or &quot;(&amp;***&amp;**&amp;*&amp;f)()&quot;)</a>
<a name="6491"><span class="lineNum">    6491 </span>            :      //</a>
<a name="6492"><span class="lineNum">    6492 </span>            :      // EDG3 removes all SgPointerDerefExp nodes from an expression like this</a>
<a name="6493"><span class="lineNum">    6493 </span>            :      //    void f() { (***f)(); }</a>
<a name="6494"><span class="lineNum">    6494 </span>            :      // EDG4 does not.  Therefore, if the thing to which the pointers ultimately point is a SgFunctionRefExp then we</a>
<a name="6495"><span class="lineNum">    6495 </span>            :      // know the function, otherwise Liao's comment below applies. [Robb Matzke 2012-12-28]</a>
<a name="6496"><span class="lineNum">    6496 </span>            :      //</a>
<a name="6497"><span class="lineNum">    6497 </span>            :      // Liao, 5/19/2009</a>
<a name="6498"><span class="lineNum">    6498 </span>            :      // A pointer to function can be associated to any functions with a matching function type</a>
<a name="6499"><span class="lineNum">    6499 </span>            :      // There is no single function declaration which is associated with it.</a>
<a name="6500"><span class="lineNum">    6500 </span>            :      // In this case return NULL should be allowed and the caller has to handle it accordingly</a>
<a name="6501"><span class="lineNum">    6501 </span>            :      //</a>
<a name="6502"><span class="lineNum">    6502 </span><span class="lineCov">      25922 :      while (isSgPointerDerefExp(functionExp) || isSgAddressOfOp(functionExp)) {</span></a>
<a name="6503"><span class="lineNum">    6503 </span><span class="lineNoCov">          0 :        functionExp = isSgUnaryOp(functionExp)-&gt;get_operand();</span></a>
<a name="6504"><span class="lineNum">    6504 </span>            :      }</a>
<a name="6505"><span class="lineNum">    6505 </span>            : </a>
<a name="6506"><span class="lineNum">    6506 </span><span class="lineCov">      25922 :      switch (functionExp-&gt;variantT())</span></a>
<a name="6507"><span class="lineNum">    6507 </span>            :         {</a>
<a name="6508"><span class="lineNum">    6508 </span><span class="lineNoCov">          0 :           case V_SgPointerDerefExp:</span></a>
<a name="6509"><span class="lineNum">    6509 </span><span class="lineNoCov">          0 :           case V_SgAddressOfOp:</span></a>
<a name="6510"><span class="lineNum">    6510 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="6511"><span class="lineNum">    6511 </span><span class="lineNoCov">          0 :                ROSE_ABORT();</span></a>
<a name="6512"><span class="lineNum">    6512 </span>            :              }</a>
<a name="6513"><span class="lineNum">    6513 </span><span class="lineCov">       5755 :           case V_SgFunctionRefExp:</span></a>
<a name="6514"><span class="lineNum">    6514 </span><span class="lineCov">       5755 :              {</span></a>
<a name="6515"><span class="lineNum">    6515 </span><span class="lineCov">       5755 :                SgFunctionRefExp* functionRefExp = isSgFunctionRefExp(functionExp);</span></a>
<a name="6516"><span class="lineNum">    6516 </span><span class="lineCov">       5755 :                ASSERT_not_null(functionRefExp);</span></a>
<a name="6517"><span class="lineNum">    6517 </span><span class="lineCov">       5755 :                returnSymbol = functionRefExp-&gt;get_symbol();</span></a>
<a name="6518"><span class="lineNum">    6518 </span>            : </a>
<a name="6519"><span class="lineNum">    6519 </span>            :             // DQ (2/8/2009): Can we assert this! What about pointers to functions?</a>
<a name="6520"><span class="lineNum">    6520 </span><span class="lineCov">       5755 :                ASSERT_not_null(returnSymbol);</span></a>
<a name="6521"><span class="lineNum">    6521 </span><span class="lineCov">       5755 :                break;</span></a>
<a name="6522"><span class="lineNum">    6522 </span>            :              }</a>
<a name="6523"><span class="lineNum">    6523 </span>            : </a>
<a name="6524"><span class="lineNum">    6524 </span>            :        // DQ (2/24/2013): Added case to support SgTemplateFunctionRefExp (now generated as a result of</a>
<a name="6525"><span class="lineNum">    6525 </span>            :        // work on 2/23/2013 specific to unknown function handling in templates, now resolved by name).</a>
<a name="6526"><span class="lineNum">    6526 </span><span class="lineCov">       1991 :           case V_SgTemplateFunctionRefExp:</span></a>
<a name="6527"><span class="lineNum">    6527 </span><span class="lineCov">       1991 :              {</span></a>
<a name="6528"><span class="lineNum">    6528 </span><span class="lineCov">       1991 :                SgTemplateFunctionRefExp* functionRefExp = isSgTemplateFunctionRefExp(functionExp);</span></a>
<a name="6529"><span class="lineNum">    6529 </span><span class="lineCov">       1991 :                ASSERT_not_null(functionRefExp);</span></a>
<a name="6530"><span class="lineNum">    6530 </span><span class="lineCov">       1991 :                returnSymbol = functionRefExp-&gt;get_symbol();</span></a>
<a name="6531"><span class="lineNum">    6531 </span>            : </a>
<a name="6532"><span class="lineNum">    6532 </span>            :             // DQ (2/8/2009): Can we assert this! What about pointers to functions?</a>
<a name="6533"><span class="lineNum">    6533 </span><span class="lineCov">       1991 :                ASSERT_not_null(returnSymbol);</span></a>
<a name="6534"><span class="lineNum">    6534 </span><span class="lineCov">       1991 :                break;</span></a>
<a name="6535"><span class="lineNum">    6535 </span>            :              }</a>
<a name="6536"><span class="lineNum">    6536 </span>            : </a>
<a name="6537"><span class="lineNum">    6537 </span>            :        // DQ (2/25/2013): Added case to support SgTemplateFunctionRefExp (now generated as a result of</a>
<a name="6538"><span class="lineNum">    6538 </span>            :        // work on 2/23/2013 specific to unknown function handling in templates, now resolved by name).</a>
<a name="6539"><span class="lineNum">    6539 </span><span class="lineCov">       2551 :           case V_SgTemplateMemberFunctionRefExp:</span></a>
<a name="6540"><span class="lineNum">    6540 </span><span class="lineCov">       2551 :              {</span></a>
<a name="6541"><span class="lineNum">    6541 </span><span class="lineCov">       2551 :                SgTemplateMemberFunctionRefExp* templateMemberFunctionRefExp = isSgTemplateMemberFunctionRefExp(functionExp);</span></a>
<a name="6542"><span class="lineNum">    6542 </span><span class="lineCov">       2551 :                ASSERT_not_null(templateMemberFunctionRefExp);</span></a>
<a name="6543"><span class="lineNum">    6543 </span><span class="lineCov">       2551 :                returnSymbol = templateMemberFunctionRefExp-&gt;get_symbol();</span></a>
<a name="6544"><span class="lineNum">    6544 </span>            : </a>
<a name="6545"><span class="lineNum">    6545 </span>            :             // DQ (2/8/2009): Can we assert this! What about pointers to functions?</a>
<a name="6546"><span class="lineNum">    6546 </span><span class="lineCov">       2551 :                ASSERT_not_null(returnSymbol);</span></a>
<a name="6547"><span class="lineNum">    6547 </span><span class="lineCov">       2551 :                break;</span></a>
<a name="6548"><span class="lineNum">    6548 </span>            :              }</a>
<a name="6549"><span class="lineNum">    6549 </span>            : </a>
<a name="6550"><span class="lineNum">    6550 </span><span class="lineCov">        808 :           case V_SgMemberFunctionRefExp:</span></a>
<a name="6551"><span class="lineNum">    6551 </span><span class="lineCov">        808 :              {</span></a>
<a name="6552"><span class="lineNum">    6552 </span><span class="lineCov">        808 :                SgMemberFunctionRefExp* memberFunctionRefExp = isSgMemberFunctionRefExp(functionExp);</span></a>
<a name="6553"><span class="lineNum">    6553 </span><span class="lineCov">        808 :                ASSERT_not_null(memberFunctionRefExp);</span></a>
<a name="6554"><span class="lineNum">    6554 </span><span class="lineCov">        808 :                returnSymbol = memberFunctionRefExp-&gt;get_symbol();</span></a>
<a name="6555"><span class="lineNum">    6555 </span>            : </a>
<a name="6556"><span class="lineNum">    6556 </span>            :             // DQ (2/8/2009): Can we assert this! What about pointers to functions?</a>
<a name="6557"><span class="lineNum">    6557 </span><span class="lineCov">        808 :                ASSERT_not_null(returnSymbol);</span></a>
<a name="6558"><span class="lineNum">    6558 </span><span class="lineCov">        808 :                break;</span></a>
<a name="6559"><span class="lineNum">    6559 </span>            :              }</a>
<a name="6560"><span class="lineNum">    6560 </span>            : </a>
<a name="6561"><span class="lineNum">    6561 </span><span class="lineCov">       5776 :           case V_SgArrowExp:</span></a>
<a name="6562"><span class="lineNum">    6562 </span><span class="lineCov">       5776 :              {</span></a>
<a name="6563"><span class="lineNum">    6563 </span>            :             // The lhs is the this pointer (SgThisExp) and the rhs is the member function.</a>
<a name="6564"><span class="lineNum">    6564 </span><span class="lineCov">       5776 :                SgArrowExp* arrayExp = isSgArrowExp(functionExp);</span></a>
<a name="6565"><span class="lineNum">    6565 </span><span class="lineCov">       5776 :                ASSERT_not_null(arrayExp);</span></a>
<a name="6566"><span class="lineNum">    6566 </span>            : </a>
<a name="6567"><span class="lineNum">    6567 </span><span class="lineCov">       5776 :                SgMemberFunctionRefExp* memberFunctionRefExp = isSgMemberFunctionRefExp(arrayExp-&gt;get_rhs_operand());</span></a>
<a name="6568"><span class="lineNum">    6568 </span>            : </a>
<a name="6569"><span class="lineNum">    6569 </span>            :             // DQ (2/21/2010): Relaxed this constraint because it failes in fixupPrettyFunction test.</a>
<a name="6570"><span class="lineNum">    6570 </span>            :             // ROSE_ASSERT(memberFunctionRefExp != NULL);</a>
<a name="6571"><span class="lineNum">    6571 </span><span class="lineCov">       5776 :                if (memberFunctionRefExp != nullptr)</span></a>
<a name="6572"><span class="lineNum">    6572 </span>            :                   {</a>
<a name="6573"><span class="lineNum">    6573 </span><span class="lineCov">       1436 :                     returnSymbol = memberFunctionRefExp-&gt;get_symbol();</span></a>
<a name="6574"><span class="lineNum">    6574 </span>            : </a>
<a name="6575"><span class="lineNum">    6575 </span>            :                  // DQ (2/8/2009): Can we assert this! What about pointers to functions?</a>
<a name="6576"><span class="lineNum">    6576 </span><span class="lineCov">       1436 :                     ASSERT_not_null(returnSymbol);</span></a>
<a name="6577"><span class="lineNum">    6577 </span>            :                   }</a>
<a name="6578"><span class="lineNum">    6578 </span>            :                break;</a>
<a name="6579"><span class="lineNum">    6579 </span>            :              }</a>
<a name="6580"><span class="lineNum">    6580 </span>            : </a>
<a name="6581"><span class="lineNum">    6581 </span><span class="lineCov">       5254 :           case V_SgDotExp:</span></a>
<a name="6582"><span class="lineNum">    6582 </span><span class="lineCov">       5254 :              {</span></a>
<a name="6583"><span class="lineNum">    6583 </span><span class="lineCov">       5254 :                SgDotExp * dotExp = isSgDotExp(functionExp);</span></a>
<a name="6584"><span class="lineNum">    6584 </span><span class="lineCov">       5254 :                ASSERT_not_null(dotExp);</span></a>
<a name="6585"><span class="lineNum">    6585 </span><span class="lineCov">       5254 :                ASSERT_not_null(dotExp-&gt;get_rhs_operand());</span></a>
<a name="6586"><span class="lineNum">    6586 </span>            : #if 0</a>
<a name="6587"><span class="lineNum">    6587 </span>            :                printf (&quot;In SgFunctionCallExp::getAssociatedFunctionSymbol(): case V_SgDotExp: dotExp-&gt;get_rhs_operand() = %p = %s \n&quot;,dotExp-&gt;get_rhs_operand(),dotExp-&gt;get_rhs_operand()-&gt;class_name().c_str());</a>
<a name="6588"><span class="lineNum">    6588 </span>            : #endif</a>
<a name="6589"><span class="lineNum">    6589 </span>            :             // There are four different types of function call reference expression in ROSE.</a>
<a name="6590"><span class="lineNum">    6590 </span><span class="lineCov">       5254 :                SgMemberFunctionRefExp* memberFunctionRefExp = isSgMemberFunctionRefExp(dotExp-&gt;get_rhs_operand());</span></a>
<a name="6591"><span class="lineNum">    6591 </span><span class="lineCov">       5254 :                if (memberFunctionRefExp == nullptr)</span></a>
<a name="6592"><span class="lineNum">    6592 </span>            :                   {</a>
<a name="6593"><span class="lineNum">    6593 </span>            :                  // This could be a SgTemplateMemberFunctionRefExp (not derived from SgMemberFunctionRefExp or SgFunctionRefExp). See test2013_70.C</a>
<a name="6594"><span class="lineNum">    6594 </span><span class="lineCov">       3399 :                     SgTemplateMemberFunctionRefExp* templateMemberFunctionRefExp = isSgTemplateMemberFunctionRefExp(dotExp-&gt;get_rhs_operand());</span></a>
<a name="6595"><span class="lineNum">    6595 </span><span class="lineCov">       3399 :                     if (templateMemberFunctionRefExp == nullptr)</span></a>
<a name="6596"><span class="lineNum">    6596 </span>            :                        {</a>
<a name="6597"><span class="lineNum">    6597 </span><span class="lineCov">       2427 :                          SgTemplateFunctionRefExp* templateFunctionRefExp = isSgTemplateFunctionRefExp(dotExp-&gt;get_rhs_operand());</span></a>
<a name="6598"><span class="lineNum">    6598 </span><span class="lineCov">       2427 :                          if (templateFunctionRefExp == nullptr)</span></a>
<a name="6599"><span class="lineNum">    6599 </span>            :                             {</a>
<a name="6600"><span class="lineNum">    6600 </span><span class="lineCov">       2427 :                               SgFunctionRefExp* functionRefExp = isSgFunctionRefExp(dotExp-&gt;get_rhs_operand());</span></a>
<a name="6601"><span class="lineNum">    6601 </span><span class="lineCov">       2427 :                               if (functionRefExp == nullptr)</span></a>
<a name="6602"><span class="lineNum">    6602 </span>            :                                  {</a>
<a name="6603"><span class="lineNum">    6603 </span><span class="lineCov">       2427 :                                    SgVarRefExp* varRefExp = isSgVarRefExp(dotExp-&gt;get_rhs_operand());</span></a>
<a name="6604"><span class="lineNum">    6604 </span><span class="lineCov">       2427 :                                    if (varRefExp == nullptr)</span></a>
<a name="6605"><span class="lineNum">    6605 </span>            :                                       {</a>
<a name="6606"><span class="lineNum">    6606 </span><span class="lineCov">       2425 :                                         SgNonrealRefExp* nrRefExp = isSgNonrealRefExp(dotExp-&gt;get_rhs_operand());</span></a>
<a name="6607"><span class="lineNum">    6607 </span><span class="lineCov">       2425 :                                         if (nrRefExp == nullptr) {</span></a>
<a name="6608"><span class="lineNum">    6608 </span><span class="lineNoCov">          0 :                                           dotExp-&gt;get_rhs_operand()-&gt;get_file_info()-&gt;display(&quot;In SgFunctionCallExp::getAssociatedFunctionSymbol(): case of SgDotExp: templateMemberFunctionRefExp == NULL: debug&quot;);</span></a>
<a name="6609"><span class="lineNum">    6609 </span><span class="lineNoCov">          0 :                                           printf (&quot;In SgFunctionCallExp::getAssociatedFunctionSymbol(): case of SgDotExp: dotExp-&gt;get_rhs_operand() = %p = %s \n&quot;,dotExp-&gt;get_rhs_operand(),dotExp-&gt;get_rhs_operand()-&gt;class_name().c_str());</span></a>
<a name="6610"><span class="lineNum">    6610 </span>            :                                         } else {</a>
<a name="6611"><span class="lineNum">    6611 </span>            :                                           // FIXME should we return the non-real symbol?</a>
<a name="6612"><span class="lineNum">    6612 </span>            :                                         }</a>
<a name="6613"><span class="lineNum">    6613 </span>            :                                       }</a>
<a name="6614"><span class="lineNum">    6614 </span>            :                                      else</a>
<a name="6615"><span class="lineNum">    6615 </span>            :                                       {</a>
<a name="6616"><span class="lineNum">    6616 </span><span class="lineCov">          2 :                                         ASSERT_not_null(varRefExp);</span></a>
<a name="6617"><span class="lineNum">    6617 </span>            : </a>
<a name="6618"><span class="lineNum">    6618 </span>            :                                      // DQ (8/20/2013): This is not a SgFunctionSymbol so we can't return a valid symbol from this case of a function call from a pointer to a function.</a>
<a name="6619"><span class="lineNum">    6619 </span>            :                                      // returnSymbol = varRefExp-&gt;get_symbol();</a>
<a name="6620"><span class="lineNum">    6620 </span>            :                                       }</a>
<a name="6621"><span class="lineNum">    6621 </span>            :                                  }</a>
<a name="6622"><span class="lineNum">    6622 </span>            :                                 else</a>
<a name="6623"><span class="lineNum">    6623 </span>            :                                  {</a>
<a name="6624"><span class="lineNum">    6624 </span>            :                                 // I am unclear when this is possible, but STL code exercises it.</a>
<a name="6625"><span class="lineNum">    6625 </span><span class="lineNoCov">          0 :                                    ASSERT_not_null(functionRefExp);</span></a>
<a name="6626"><span class="lineNum">    6626 </span><span class="lineNoCov">          0 :                                    returnSymbol = functionRefExp-&gt;get_symbol();</span></a>
<a name="6627"><span class="lineNum">    6627 </span>            : </a>
<a name="6628"><span class="lineNum">    6628 </span><span class="lineNoCov">          0 :                                    ASSERT_not_null(returnSymbol);</span></a>
<a name="6629"><span class="lineNum">    6629 </span>            :                                  }</a>
<a name="6630"><span class="lineNum">    6630 </span>            :                             }</a>
<a name="6631"><span class="lineNum">    6631 </span>            :                            else</a>
<a name="6632"><span class="lineNum">    6632 </span>            :                             {</a>
<a name="6633"><span class="lineNum">    6633 </span>            :                            // I am unclear when this is possible, but STL code exercises it.</a>
<a name="6634"><span class="lineNum">    6634 </span><span class="lineNoCov">          0 :                               ASSERT_not_null(templateFunctionRefExp);</span></a>
<a name="6635"><span class="lineNum">    6635 </span><span class="lineNoCov">          0 :                               returnSymbol = templateFunctionRefExp-&gt;get_symbol();</span></a>
<a name="6636"><span class="lineNum">    6636 </span>            : </a>
<a name="6637"><span class="lineNum">    6637 </span><span class="lineNoCov">          0 :                               ASSERT_not_null(returnSymbol);</span></a>
<a name="6638"><span class="lineNum">    6638 </span>            :                             }</a>
<a name="6639"><span class="lineNum">    6639 </span>            :                        }</a>
<a name="6640"><span class="lineNum">    6640 </span>            :                       else</a>
<a name="6641"><span class="lineNum">    6641 </span>            :                        {</a>
<a name="6642"><span class="lineNum">    6642 </span><span class="lineCov">        972 :                          ASSERT_not_null(templateMemberFunctionRefExp);</span></a>
<a name="6643"><span class="lineNum">    6643 </span><span class="lineCov">        972 :                          returnSymbol = templateMemberFunctionRefExp-&gt;get_symbol();</span></a>
<a name="6644"><span class="lineNum">    6644 </span>            : </a>
<a name="6645"><span class="lineNum">    6645 </span><span class="lineCov">        972 :                          ASSERT_not_null(returnSymbol);</span></a>
<a name="6646"><span class="lineNum">    6646 </span>            :                        }</a>
<a name="6647"><span class="lineNum">    6647 </span>            :                   }</a>
<a name="6648"><span class="lineNum">    6648 </span>            :                  else</a>
<a name="6649"><span class="lineNum">    6649 </span>            :                   {</a>
<a name="6650"><span class="lineNum">    6650 </span><span class="lineCov">       1855 :                     ASSERT_not_null(memberFunctionRefExp);</span></a>
<a name="6651"><span class="lineNum">    6651 </span><span class="lineCov">       1855 :                     returnSymbol = memberFunctionRefExp-&gt;get_symbol();</span></a>
<a name="6652"><span class="lineNum">    6652 </span>            : </a>
<a name="6653"><span class="lineNum">    6653 </span><span class="lineCov">       1855 :                     ASSERT_not_null(returnSymbol);</span></a>
<a name="6654"><span class="lineNum">    6654 </span>            :                   }</a>
<a name="6655"><span class="lineNum">    6655 </span>            : </a>
<a name="6656"><span class="lineNum">    6656 </span>            :             // DQ (8/20/2013): Function pointers don't allow us to generate a proper valid SgFunctionSymbol.</a>
<a name="6657"><span class="lineNum">    6657 </span>            :             // DQ (2/8/2009): Can we assert this! What about pointers to functions?</a>
<a name="6658"><span class="lineNum">    6658 </span>            :             // ROSE_ASSERT(returnSymbol != NULL);</a>
<a name="6659"><span class="lineNum">    6659 </span>            : </a>
<a name="6660"><span class="lineNum">    6660 </span>            :            // Virtual functions called through the dot operator are resolved statically if they are not</a>
<a name="6661"><span class="lineNum">    6661 </span>            :            // called on reference types.</a>
<a name="6662"><span class="lineNum">    6662 </span><span class="lineCov">       5254 :               isAlwaysResolvedStatically = !isSgReferenceType(dotExp-&gt;get_lhs_operand());</span></a>
<a name="6663"><span class="lineNum">    6663 </span>            : </a>
<a name="6664"><span class="lineNum">    6664 </span><span class="lineCov">       5254 :               break;</span></a>
<a name="6665"><span class="lineNum">    6665 </span>            :             }</a>
<a name="6666"><span class="lineNum">    6666 </span>            : </a>
<a name="6667"><span class="lineNum">    6667 </span>            :        // DotStar (Section 5.5 of C++ standard) is used to call a member function pointer and implicitly specify</a>
<a name="6668"><span class="lineNum">    6668 </span>            :        // the associated 'this' parameter. In this case, we can't statically determine which function is getting called</a>
<a name="6669"><span class="lineNum">    6669 </span>            :        // and should return null.</a>
<a name="6670"><span class="lineNum">    6670 </span>            :           case V_SgDotStarOp:</a>
<a name="6671"><span class="lineNum">    6671 </span>            :              {</a>
<a name="6672"><span class="lineNum">    6672 </span>            :                break;</a>
<a name="6673"><span class="lineNum">    6673 </span>            :              }</a>
<a name="6674"><span class="lineNum">    6674 </span>            : </a>
<a name="6675"><span class="lineNum">    6675 </span>            :        // ArrowStar (Section 5.5 of C++ standard) is used to call a member function pointer and implicitly specify</a>
<a name="6676"><span class="lineNum">    6676 </span>            :        // the associated 'this' parameter. In this case, we can't statically determine which function is getting called</a>
<a name="6677"><span class="lineNum">    6677 </span>            :        // and should return null.</a>
<a name="6678"><span class="lineNum">    6678 </span>            :           case V_SgArrowStarOp:</a>
<a name="6679"><span class="lineNum">    6679 </span>            :              {</a>
<a name="6680"><span class="lineNum">    6680 </span>            :                break;</a>
<a name="6681"><span class="lineNum">    6681 </span>            :              }</a>
<a name="6682"><span class="lineNum">    6682 </span>            : </a>
<a name="6683"><span class="lineNum">    6683 </span>            :        // DQ (2/25/2013): Added support for this case, but I would like to review this (likely OK).</a>
<a name="6684"><span class="lineNum">    6684 </span>            :        // It might be that this should resolve to a symbol.</a>
<a name="6685"><span class="lineNum">    6685 </span><span class="lineCov">         51 :           case V_SgConstructorInitializer:</span></a>
<a name="6686"><span class="lineNum">    6686 </span><span class="lineCov">         51 :              {</span></a>
<a name="6687"><span class="lineNum">    6687 </span><span class="lineCov">         51 :                ASSERT_not_null(functionExp-&gt;get_file_info());</span></a>
<a name="6688"><span class="lineNum">    6688 </span>            : #if 0</a>
<a name="6689"><span class="lineNum">    6689 </span>            :                printf (&quot;In SgFunctionCallExp::getAssociatedFunctionSymbol(): Found a case of SgConstructorInitializer \n&quot;);</a>
<a name="6690"><span class="lineNum">    6690 </span>            :                functionExp-&gt;get_file_info()-&gt;display(&quot;In SgFunctionCallExp::getAssociatedFunctionSymbol(): new case to be supported: checking this out: debug&quot;);</a>
<a name="6691"><span class="lineNum">    6691 </span>            : #endif</a>
<a name="6692"><span class="lineNum">    6692 </span><span class="lineCov">         51 :                break;</span></a>
<a name="6693"><span class="lineNum">    6693 </span>            :              }</a>
<a name="6694"><span class="lineNum">    6694 </span>            : </a>
<a name="6695"><span class="lineNum">    6695 </span>            :        // schroder3 (2016-06-28): Commented out the assignment of returnSymbol. Reason:</a>
<a name="6696"><span class="lineNum">    6696 </span>            :        //  I think we should not return a symbol in this case because we can not say anything about the function that is actually called by this function call expression.</a>
<a name="6697"><span class="lineNum">    6697 </span>            :        //  E.g. in case of a call C of the return value of get_random_func_address (&quot;get_random_func_address()()&quot;) get_random_func_address has nothing to do with the</a>
<a name="6698"><span class="lineNum">    6698 </span>            :        //                                                                                                     ^-C</a>
<a name="6699"><span class="lineNum">    6699 </span>            :        //  function called by C. Previously the returned symbol was therefore not the associated function symbol of this function call expression.</a>
<a name="6700"><span class="lineNum">    6700 </span>            :        //</a>
<a name="6701"><span class="lineNum">    6701 </span>            :        // DQ (2/25/2013): Added support for this case, but I would like to review this (likely OK).</a>
<a name="6702"><span class="lineNum">    6702 </span><span class="lineCov">          9 :           case V_SgFunctionCallExp:</span></a>
<a name="6703"><span class="lineNum">    6703 </span><span class="lineCov">          9 :              {</span></a>
<a name="6704"><span class="lineNum">    6704 </span><span class="lineCov">          9 :                ASSERT_not_null(functionExp-&gt;get_file_info());</span></a>
<a name="6705"><span class="lineNum">    6705 </span>            : #if 0</a>
<a name="6706"><span class="lineNum">    6706 </span>            :                printf (&quot;In SgFunctionCallExp::getAssociatedFunctionSymbol(): Found a case of SgFunctionCallExp \n&quot;);</a>
<a name="6707"><span class="lineNum">    6707 </span>            :                functionExp-&gt;get_file_info()-&gt;display(&quot;In SgFunctionCallExp::getAssociatedFunctionSymbol(): new case to be supported: checking this out: debug&quot;);</a>
<a name="6708"><span class="lineNum">    6708 </span>            : #endif</a>
<a name="6709"><span class="lineNum">    6709 </span>            : </a>
<a name="6710"><span class="lineNum">    6710 </span>            : //               SgFunctionCallExp* nestedFunctionCallExp = isSgFunctionCallExp(functionExp);</a>
<a name="6711"><span class="lineNum">    6711 </span>            : //               ROSE_ASSERT(nestedFunctionCallExp != NULL);</a>
<a name="6712"><span class="lineNum">    6712 </span>            : //</a>
<a name="6713"><span class="lineNum">    6713 </span>            : //               returnSymbol = nestedFunctionCallExp-&gt;getAssociatedFunctionSymbol();</a>
<a name="6714"><span class="lineNum">    6714 </span><span class="lineCov">          9 :                break;</span></a>
<a name="6715"><span class="lineNum">    6715 </span>            :              }</a>
<a name="6716"><span class="lineNum">    6716 </span>            : </a>
<a name="6717"><span class="lineNum">    6717 </span>            :        // DQ (2/25/2013): Added support for this case, verify as function call off of an array of function pointers.</a>
<a name="6718"><span class="lineNum">    6718 </span>            :        // This should not resolve to a symbol.</a>
<a name="6719"><span class="lineNum">    6719 </span>            :           case V_SgPntrArrRefExp:</a>
<a name="6720"><span class="lineNum">    6720 </span>            :              {</a>
<a name="6721"><span class="lineNum">    6721 </span>            : #if 0</a>
<a name="6722"><span class="lineNum">    6722 </span>            :                printf (&quot;In SgFunctionCallExp::getAssociatedFunctionSymbol(): Found a case of SgPntrArrRefExp \n&quot;);</a>
<a name="6723"><span class="lineNum">    6723 </span>            :                ASSERT_not_null(functionExp-&gt;get_file_info());</a>
<a name="6724"><span class="lineNum">    6724 </span>            :                functionExp-&gt;get_file_info()-&gt;display(&quot;In SgFunctionCallExp::getAssociatedFunctionSymbol(): new case to be supported: checking this out: debug&quot;);</a>
<a name="6725"><span class="lineNum">    6725 </span>            : #endif</a>
<a name="6726"><span class="lineNum">    6726 </span>            :                break;</a>
<a name="6727"><span class="lineNum">    6727 </span>            :              }</a>
<a name="6728"><span class="lineNum">    6728 </span>            : </a>
<a name="6729"><span class="lineNum">    6729 </span>            :        // DQ (2/25/2013): Added support for this case, from test2012_102.c.</a>
<a name="6730"><span class="lineNum">    6730 </span>            :        // Not clear if this should resolve to a symbol (I think likely yes).</a>
<a name="6731"><span class="lineNum">    6731 </span>            :           case V_SgCastExp:</a>
<a name="6732"><span class="lineNum">    6732 </span>            :              {</a>
<a name="6733"><span class="lineNum">    6733 </span>            :                break;</a>
<a name="6734"><span class="lineNum">    6734 </span>            :              }</a>
<a name="6735"><span class="lineNum">    6735 </span>            : </a>
<a name="6736"><span class="lineNum">    6736 </span>            :        // DQ (2/25/2013): Added support for this case, from test2012_133.c.</a>
<a name="6737"><span class="lineNum">    6737 </span>            :        // This should not resolve to a symbol.</a>
<a name="6738"><span class="lineNum">    6738 </span>            :           case V_SgConditionalExp:</a>
<a name="6739"><span class="lineNum">    6739 </span>            :              {</a>
<a name="6740"><span class="lineNum">    6740 </span>            :                break;</a>
<a name="6741"><span class="lineNum">    6741 </span>            :              }</a>
<a name="6742"><span class="lineNum">    6742 </span>            : </a>
<a name="6743"><span class="lineNum">    6743 </span>            :        // DQ (2/22/2013): added case to support something reported in test2013_68.C, but not yet verified.</a>
<a name="6744"><span class="lineNum">    6744 </span>            :           case V_SgVarRefExp:</a>
<a name="6745"><span class="lineNum">    6745 </span>            :              {</a>
<a name="6746"><span class="lineNum">    6746 </span>            : #ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION</a>
<a name="6747"><span class="lineNum">    6747 </span>            :                printf (&quot;In SgFunctionCallExp::getAssociatedFunctionSymbol(): case of SgVarRefExp: returning NULL \n&quot;);</a>
<a name="6748"><span class="lineNum">    6748 </span>            : #endif</a>
<a name="6749"><span class="lineNum">    6749 </span>            : #if 0</a>
<a name="6750"><span class="lineNum">    6750 </span>            :                printf (&quot;I would like to verify that I can trap this case \n&quot;);</a>
<a name="6751"><span class="lineNum">    6751 </span>            :                ROSE_ABORT();</a>
<a name="6752"><span class="lineNum">    6752 </span>            : #endif</a>
<a name="6753"><span class="lineNum">    6753 </span>            :                break;</a>
<a name="6754"><span class="lineNum">    6754 </span>            :              }</a>
<a name="6755"><span class="lineNum">    6755 </span>            : </a>
<a name="6756"><span class="lineNum">    6756 </span>            :        // DQ (12/17/2016): added case to support reducing output spew from C++11 tests and applications.</a>
<a name="6757"><span class="lineNum">    6757 </span>            :           case V_SgThisExp:</a>
<a name="6758"><span class="lineNum">    6758 </span>            :              {</a>
<a name="6759"><span class="lineNum">    6759 </span>            : #if 0</a>
<a name="6760"><span class="lineNum">    6760 </span>            :                printf (&quot;I would like to verify that I can trap this case \n&quot;);</a>
<a name="6761"><span class="lineNum">    6761 </span>            :                ROSE_ABORT();</a>
<a name="6762"><span class="lineNum">    6762 </span>            : #endif</a>
<a name="6763"><span class="lineNum">    6763 </span>            :                break;</a>
<a name="6764"><span class="lineNum">    6764 </span>            :              }</a>
<a name="6765"><span class="lineNum">    6765 </span><span class="lineNoCov">          0 :           case V_SgFunctionSymbol:</span></a>
<a name="6766"><span class="lineNum">    6766 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="6767"><span class="lineNum">    6767 </span><span class="lineNoCov">          0 :                returnSymbol = isSgFunctionSymbol(functionExp);</span></a>
<a name="6768"><span class="lineNum">    6768 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="6769"><span class="lineNum">    6769 </span>            :              }</a>
<a name="6770"><span class="lineNum">    6770 </span><span class="lineCov">       3135 :           default:</span></a>
<a name="6771"><span class="lineNum">    6771 </span><span class="lineCov">       3135 :              {</span></a>
<a name="6772"><span class="lineNum">    6772 </span>            :                // Send out error message before the assertion, which may fail and stop first otherwise.</a>
<a name="6773"><span class="lineNum">    6773 </span><span class="lineCov">       3135 :                  mprintf(&quot;Error: There should be no other cases functionExp = %p = %s \n&quot;, functionExp, functionExp-&gt;class_name().c_str());</span></a>
<a name="6774"><span class="lineNum">    6774 </span>            : </a>
<a name="6775"><span class="lineNum">    6775 </span><span class="lineCov">       3135 :                ASSERT_not_null(functionExp-&gt;get_file_info());</span></a>
<a name="6776"><span class="lineNum">    6776 </span>            : </a>
<a name="6777"><span class="lineNum">    6777 </span>            :             // DQ (3/15/2017): Fixed to use mlog message logging.</a>
<a name="6778"><span class="lineNum">    6778 </span><span class="lineCov">       3135 :                if (Rose::ir_node_mlog[Rose::Diagnostics::DEBUG])</span></a>
<a name="6779"><span class="lineNum">    6779 </span>            :                   {</a>
<a name="6780"><span class="lineNum">    6780 </span><span class="lineNoCov">          0 :                     functionExp-&gt;get_file_info()-&gt;display(&quot;In SgFunctionCallExp::getAssociatedFunctionSymbol(): case not supported: debug&quot;);</span></a>
<a name="6781"><span class="lineNum">    6781 </span>            :                   }</a>
<a name="6782"><span class="lineNum">    6782 </span>            : </a>
<a name="6783"><span class="lineNum">    6783 </span>            :                // schroder3 (2016-07-25): Changed &quot;#if 1&quot; to &quot;#if 0&quot; to remove ROSE_ASSERT. If this member function is unable to determine the</a>
<a name="6784"><span class="lineNum">    6784 </span>            :                //  associated function then it should return 0 instead of raising an assertion.</a>
<a name="6785"><span class="lineNum">    6785 </span>            : #if 0</a>
<a name="6786"><span class="lineNum">    6786 </span>            :             // DQ (2/23/2013): Allow this to be commented out so that I can generate the DOT graphs to better understand the problem in test2013_69.C.</a>
<a name="6787"><span class="lineNum">    6787 </span>            :                ROSE_ABORT();</a>
<a name="6788"><span class="lineNum">    6788 </span>            : #endif</a>
<a name="6789"><span class="lineNum">    6789 </span>            :              }</a>
<a name="6790"><span class="lineNum">    6790 </span>            :         }</a>
<a name="6791"><span class="lineNum">    6791 </span>            : </a>
<a name="6792"><span class="lineNum">    6792 </span>            :   // If the function is virtual, the function call might actually be to a different symbol.</a>
<a name="6793"><span class="lineNum">    6793 </span>            :   // We should return NULL in this case to preserve correctness</a>
<a name="6794"><span class="lineNum">    6794 </span><span class="lineCov">      25922 :      if (returnSymbol != nullptr &amp;&amp; !isAlwaysResolvedStatically)</span></a>
<a name="6795"><span class="lineNum">    6795 </span>            :         {</a>
<a name="6796"><span class="lineNum">    6796 </span><span class="lineCov">      12541 :           SgFunctionModifier&amp; functionModifier = returnSymbol-&gt;get_declaration()-&gt;get_functionModifier();</span></a>
<a name="6797"><span class="lineNum">    6797 </span><span class="lineCov">      12541 :           if (functionModifier.isVirtual() || functionModifier.isPureVirtual())</span></a>
<a name="6798"><span class="lineNum">    6798 </span>            :              {</a>
<a name="6799"><span class="lineNum">    6799 </span>            :                returnSymbol = nullptr;</a>
<a name="6800"><span class="lineNum">    6800 </span>            :              }</a>
<a name="6801"><span class="lineNum">    6801 </span>            :         }</a>
<a name="6802"><span class="lineNum">    6802 </span>            : </a>
<a name="6803"><span class="lineNum">    6803 </span><span class="lineCov">      25922 :      return returnSymbol;</span></a>
<a name="6804"><span class="lineNum">    6804 </span>            :    }</a>
<a name="6805"><span class="lineNum">    6805 </span>            : </a>
<a name="6806"><span class="lineNum">    6806 </span>            : </a>
<a name="6807"><span class="lineNum">    6807 </span>            : // DQ (10/19/2010): This is moved from src/ROSETTA/Grammar/Cxx_GlobalDeclarations.macro to here</a>
<a name="6808"><span class="lineNum">    6808 </span>            : // since it is code in the header files that we would like to avoid.  My fear is that because of</a>
<a name="6809"><span class="lineNum">    6809 </span>            : // the way it works it is required to be inlined onto the stack of the calling function.</a>
<a name="6810"><span class="lineNum">    6810 </span>            : // #ifndef ROSE_PREVENT_CONSTRUCTION_ON_STACK</a>
<a name="6811"><span class="lineNum">    6811 </span>            : // #define ROSE_PREVENT_CONSTRUCTION_ON_STACK</a>
<a name="6812"><span class="lineNum">    6812 </span>            : // inline void preventConstructionOnStack(SgNode* n)</a>
<a name="6813"><span class="lineNum">    6813 </span><span class="lineCov">   89154300 : void preventConstructionOnStack(SgNode* n)</span></a>
<a name="6814"><span class="lineNum">    6814 </span>            :    {</a>
<a name="6815"><span class="lineNum">    6815 </span>            : #ifndef NDEBUG</a>
<a name="6816"><span class="lineNum">    6816 </span>            : #ifdef _MSC_VER</a>
<a name="6817"><span class="lineNum">    6817 </span>            :   // DQ (11/28/2009): This was a fix suggested by Robb.</a>
<a name="6818"><span class="lineNum">    6818 </span>            :   // void* frameaddr = 0;</a>
<a name="6819"><span class="lineNum">    6819 </span>            :   // Build an &quot;auto&quot; variable (should be located near the stack frame, I think).</a>
<a name="6820"><span class="lineNum">    6820 </span>            :   // tps (12/4/2009)</a>
<a name="6821"><span class="lineNum">    6821 </span>            : #if _MSC_VER &gt;= 1600  // 1600 == VC++ 10.0</a>
<a name="6822"><span class="lineNum">    6822 </span>            :   // ../Grammar/Cxx_GlobalDeclarations.macro(32): error C3530: 'auto' cannot be combined with any other type-specifier</a>
<a name="6823"><span class="lineNum">    6823 </span>            :      unsigned int nonStackFrameReferenceVariable;</a>
<a name="6824"><span class="lineNum">    6824 </span>            :     #pragma message ( &quot; Cxx_GlobalDeclarations.macro: __builtin_frame_address not known in Windows. Workaround in VS 10.0&quot;)</a>
<a name="6825"><span class="lineNum">    6825 </span>            : #else</a>
<a name="6826"><span class="lineNum">    6826 </span>            :      auto unsigned int nonStackFrameReferenceVariable;</a>
<a name="6827"><span class="lineNum">    6827 </span>            : #endif</a>
<a name="6828"><span class="lineNum">    6828 </span>            :      void* frameaddr = &amp;nonStackFrameReferenceVariable;</a>
<a name="6829"><span class="lineNum">    6829 </span>            : </a>
<a name="6830"><span class="lineNum">    6830 </span>            : #else</a>
<a name="6831"><span class="lineNum">    6831 </span>            :   // GNU compiler specific code</a>
<a name="6832"><span class="lineNum">    6832 </span><span class="lineCov">   89154300 :      void* frameaddr = __builtin_frame_address(0);</span></a>
<a name="6833"><span class="lineNum">    6833 </span>            : #endif // _MSC_VER</a>
<a name="6834"><span class="lineNum">    6834 </span>            : </a>
<a name="6835"><span class="lineNum">    6835 </span><span class="lineCov">   89154300 :      signed long dist = (char*)n - (char*)frameaddr;</span></a>
<a name="6836"><span class="lineNum">    6836 </span>            : </a>
<a name="6837"><span class="lineNum">    6837 </span>            :   // DQ (12/6/2009): This fails for the 4.0.4 compiler, but only in 64-bit when run with Hudson.</a>
<a name="6838"><span class="lineNum">    6838 </span>            :   // I can't reporduce the problem using the 4.0.4 compiler, but it is uniformally a problem</a>
<a name="6839"><span class="lineNum">    6839 </span>            :   // since it fails on all tests (via hudson) which are using Boost 1.40 and either minimal or</a>
<a name="6840"><span class="lineNum">    6840 </span>            :   // full configurations (and also for the tests of the EDG binary).</a>
<a name="6841"><span class="lineNum">    6841 </span>            :   // assert (dist &lt; -10000 || dist &gt; 10000);</a>
<a name="6842"><span class="lineNum">    6842 </span>            : </a>
<a name="6843"><span class="lineNum">    6843 </span>            : #ifdef __GNUC__</a>
<a name="6844"><span class="lineNum">    6844 </span>            :   // Note that this is a test of the backend compiler, it seems that we don't track</a>
<a name="6845"><span class="lineNum">    6845 </span>            :   // the compiler used to compile ROSE, but this is what we would want.</a>
<a name="6846"><span class="lineNum">    6846 </span>            : </a>
<a name="6847"><span class="lineNum">    6847 </span>            : #if (BACKEND_CXX_COMPILER_MAJOR_VERSION_NUMBER == 4) &amp;&amp; (BACKEND_CXX_COMPILER_MINOR_VERSION_NUMBER == 0)</a>
<a name="6848"><span class="lineNum">    6848 </span>            :   // For the GNU 4.0.x make this a warning, since it appears to fail due to a</a>
<a name="6849"><span class="lineNum">    6849 </span>            :   // poor implementaiton for just this compiler and no other version of GNU.</a>
<a name="6850"><span class="lineNum">    6850 </span>            :   // Just that we are pringing this warning is a problem for many tests (maybe this should be enable within verbose mode).</a>
<a name="6851"><span class="lineNum">    6851 </span>            :      if (dist &lt; -10000 || dist &gt; 10000)</a>
<a name="6852"><span class="lineNum">    6852 </span>            :         {</a>
<a name="6853"><span class="lineNum">    6853 </span>            : #if 0</a>
<a name="6854"><span class="lineNum">    6854 </span>            :           printf (&quot;Warning: preventConstructionOnStack() reporting object on stack, not allowed. dist = %ld \n&quot;,dist);</a>
<a name="6855"><span class="lineNum">    6855 </span>            : #endif</a>
<a name="6856"><span class="lineNum">    6856 </span>            :         }</a>
<a name="6857"><span class="lineNum">    6857 </span>            : #else</a>
<a name="6858"><span class="lineNum">    6858 </span>            :   // For all other versions of the GNU compiler make this an error.</a>
<a name="6859"><span class="lineNum">    6859 </span><span class="lineCov">   89154300 :      assert (dist &lt; -10000 || dist &gt; 10000);</span></a>
<a name="6860"><span class="lineNum">    6860 </span>            : #endif</a>
<a name="6861"><span class="lineNum">    6861 </span>            : #else</a>
<a name="6862"><span class="lineNum">    6862 </span>            :   // For all other compilers make this an error (e.g. on Windows MSVC, Intel icc, etc.).</a>
<a name="6863"><span class="lineNum">    6863 </span>            :      assert (dist &lt; -10000 || dist &gt; 10000);</a>
<a name="6864"><span class="lineNum">    6864 </span>            : #endif // __GNUC__</a>
<a name="6865"><span class="lineNum">    6865 </span>            : </a>
<a name="6866"><span class="lineNum">    6866 </span>            : #endif // NDEBUG</a>
<a name="6867"><span class="lineNum">    6867 </span><span class="lineCov">   89154300 :    }</span></a>
<a name="6868"><span class="lineNum">    6868 </span>            : // #endif // ROSE_PREVENT_CONSTRUCTION_ON_STACK</a>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.14</a></td></tr>
  </table>
  <br>

</body>
</html>
