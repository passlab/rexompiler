<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - ROSE - /home/yyan7/compiler/rexompiler/src/midend/programAnalysis/genericDataflow/simpleAnalyses/liveDeadVarAnalysis.C</title>
  <link rel="stylesheet" type="text/css" href="../../../../../../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../../../../../../index.html">top level</a> - <a href="index.html">home/yyan7/compiler/rexompiler/src/midend/programAnalysis/genericDataflow/simpleAnalyses</a> - liveDeadVarAnalysis.C<span style="font-size: 80%;"> (source / <a href="liveDeadVarAnalysis.C.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">ROSE</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">560</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2022-12-08 13:48:47</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">94</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : #include &lt;featureTests.h&gt;</a>
<a name="2"><span class="lineNum">       2 </span>            : #ifdef ROSE_ENABLE_SOURCE_ANALYSIS</a>
<a name="3"><span class="lineNum">       3 </span>            : </a>
<a name="4"><span class="lineNum">       4 </span>            : #include &quot;liveDeadVarAnalysis.h&quot;</a>
<a name="5"><span class="lineNum">       5 </span>            : </a>
<a name="6"><span class="lineNum">       6 </span>            : int liveDeadAnalysisDebugLevel=0;</a>
<a name="7"><span class="lineNum">       7 </span>            : </a>
<a name="8"><span class="lineNum">       8 </span>            : // ###########################</a>
<a name="9"><span class="lineNum">       9 </span>            : // ##### LiveVarsLattice #####</a>
<a name="10"><span class="lineNum">      10 </span>            : // ###########################</a>
<a name="11"><span class="lineNum">      11 </span>            : </a>
<a name="12"><span class="lineNum">      12 </span><span class="lineNoCov">          0 : LiveVarsLattice::LiveVarsLattice() {}</span></a>
<a name="13"><span class="lineNum">      13 </span>            :         </a>
<a name="14"><span class="lineNum">      14 </span><span class="lineNoCov">          0 : LiveVarsLattice::LiveVarsLattice(const varID&amp; var)</span></a>
<a name="15"><span class="lineNum">      15 </span>            : {</a>
<a name="16"><span class="lineNum">      16 </span><span class="lineNoCov">          0 :         liveVars.insert(var);</span></a>
<a name="17"><span class="lineNum">      17 </span><span class="lineNoCov">          0 : }</span></a>
<a name="18"><span class="lineNum">      18 </span>            : </a>
<a name="19"><span class="lineNum">      19 </span><span class="lineNoCov">          0 : LiveVarsLattice::LiveVarsLattice(const set&lt;varID&gt;&amp; liveVars) : liveVars(liveVars)</span></a>
<a name="20"><span class="lineNum">      20 </span><span class="lineNoCov">          0 : { }</span></a>
<a name="21"><span class="lineNum">      21 </span>            :         </a>
<a name="22"><span class="lineNum">      22 </span>            : // Initializes this Lattice to its default state, if it is not already initialized</a>
<a name="23"><span class="lineNum">      23 </span><span class="lineNoCov">          0 : void LiveVarsLattice::initialize()</span></a>
<a name="24"><span class="lineNum">      24 </span><span class="lineNoCov">          0 : {}</span></a>
<a name="25"><span class="lineNum">      25 </span>            : </a>
<a name="26"><span class="lineNum">      26 </span>            : // Returns a copy of this lattice</a>
<a name="27"><span class="lineNum">      27 </span><span class="lineNoCov">          0 : Lattice* LiveVarsLattice::copy() const</span></a>
<a name="28"><span class="lineNum">      28 </span><span class="lineNoCov">          0 : { return new LiveVarsLattice(); }</span></a>
<a name="29"><span class="lineNum">      29 </span>            : </a>
<a name="30"><span class="lineNum">      30 </span>            : // Overwrites the state of this Lattice with that of that Lattice</a>
<a name="31"><span class="lineNum">      31 </span><span class="lineNoCov">          0 : void LiveVarsLattice::copy(Lattice* that)</span></a>
<a name="32"><span class="lineNum">      32 </span>            : {</a>
<a name="33"><span class="lineNum">      33 </span><span class="lineNoCov">          0 :         liveVars = dynamic_cast&lt;LiveVarsLattice*&gt;(that)-&gt;liveVars;</span></a>
<a name="34"><span class="lineNum">      34 </span><span class="lineNoCov">          0 : }</span></a>
<a name="35"><span class="lineNum">      35 </span>            : </a>
<a name="36"><span class="lineNum">      36 </span>            : </a>
<a name="37"><span class="lineNum">      37 </span>            : // replace variables with a new set of variables</a>
<a name="38"><span class="lineNum">      38 </span>            : // varNameMap - maps all variable names that have changed, in each mapping pair, pair-&gt;first is the </a>
<a name="39"><span class="lineNum">      39 </span>            : //              old variable and pair-&gt;second is the new variable</a>
<a name="40"><span class="lineNum">      40 </span>            : // func - the function that the copy Lattice will now be associated with</a>
<a name="41"><span class="lineNum">      41 </span><span class="lineNoCov">          0 : void LiveVarsLattice::remapVars(const map&lt;varID, varID&gt;&amp; varNameMap, const Function&amp; newFunc)</span></a>
<a name="42"><span class="lineNum">      42 </span>            : {</a>
<a name="43"><span class="lineNum">      43 </span>            :         // Iterate over all the remapped variables</a>
<a name="44"><span class="lineNum">      44 </span><span class="lineNoCov">          0 :         for(map&lt;varID, varID&gt;::const_iterator var=varNameMap.begin(); var!=varNameMap.end(); var++) {</span></a>
<a name="45"><span class="lineNum">      45 </span>            :                 // If the current remapped variable is live, replace its old name with its new one</a>
<a name="46"><span class="lineNum">      46 </span><span class="lineNoCov">          0 :                 if(liveVars.find(var-&gt;first) != liveVars.end()) {</span></a>
<a name="47"><span class="lineNum">      47 </span><span class="lineNoCov">          0 :                         liveVars.erase(var-&gt;first);</span></a>
<a name="48"><span class="lineNum">      48 </span><span class="lineNoCov">          0 :                         liveVars.insert(var-&gt;second);</span></a>
<a name="49"><span class="lineNum">      49 </span>            :                 }</a>
<a name="50"><span class="lineNum">      50 </span>            :         }</a>
<a name="51"><span class="lineNum">      51 </span><span class="lineNoCov">          0 : }</span></a>
<a name="52"><span class="lineNum">      52 </span>            : </a>
<a name="53"><span class="lineNum">      53 </span>            : // Called by analyses to copy over from the that Lattice dataflow information into this Lattice.</a>
<a name="54"><span class="lineNum">      54 </span>            : // that contains data for a set of variables and incorporateVars must overwrite the state of just</a>
<a name="55"><span class="lineNum">      55 </span>            : // those variables, while leaving its state for other variables alone.</a>
<a name="56"><span class="lineNum">      56 </span>            : // We do not force child classes to define their own versions of this function since not all</a>
<a name="57"><span class="lineNum">      57 </span>            : //    Lattices have per-variable information.</a>
<a name="58"><span class="lineNum">      58 </span><span class="lineNoCov">          0 : void LiveVarsLattice::incorporateVars(Lattice* that_arg)</span></a>
<a name="59"><span class="lineNum">      59 </span>            : {</a>
<a name="60"><span class="lineNum">      60 </span><span class="lineNoCov">          0 :         LiveVarsLattice* that = dynamic_cast&lt;LiveVarsLattice*&gt;(that_arg);</span></a>
<a name="61"><span class="lineNum">      61 </span><span class="lineNoCov">          0 :         for(set&lt;varID&gt;::iterator var=that-&gt;liveVars.begin(); var!=that-&gt;liveVars.end(); var++)</span></a>
<a name="62"><span class="lineNum">      62 </span><span class="lineNoCov">          0 :                 liveVars.insert(*var);</span></a>
<a name="63"><span class="lineNum">      63 </span><span class="lineNoCov">          0 : }</span></a>
<a name="64"><span class="lineNum">      64 </span>            : </a>
<a name="65"><span class="lineNum">      65 </span>            : // Returns a Lattice that describes the information known within this lattice</a>
<a name="66"><span class="lineNum">      66 </span>            : // about the given expression. By default this could be the entire lattice or any portion of it.</a>
<a name="67"><span class="lineNum">      67 </span>            : // For example, a lattice that maintains lattices for different known variables and expression will </a>
<a name="68"><span class="lineNum">      68 </span>            : // return a lattice for the given expression. Similarly, a lattice that keeps track of constraints</a>
<a name="69"><span class="lineNum">      69 </span>            : // on values of variables and expressions will return the portion of the lattice that relates to</a>
<a name="70"><span class="lineNum">      70 </span>            : // the given expression. </a>
<a name="71"><span class="lineNum">      71 </span>            : </a>
<a name="72"><span class="lineNum">      72 </span>            : // It is legal for this function to return NULL if no information is available.</a>
<a name="73"><span class="lineNum">      73 </span>            : // The function's caller is responsible for deallocating the returned object</a>
<a name="74"><span class="lineNum">      74 </span><span class="lineNoCov">          0 : Lattice* LiveVarsLattice::project(SgExpression* expr) { </span></a>
<a name="75"><span class="lineNum">      75 </span><span class="lineNoCov">          0 :         varID var = SgExpr2Var(expr);</span></a>
<a name="76"><span class="lineNum">      76 </span><span class="lineNoCov">          0 :         if(liveVars.find(var) != liveVars.end())</span></a>
<a name="77"><span class="lineNum">      77 </span><span class="lineNoCov">          0 :                 return new LiveVarsLattice(var);</span></a>
<a name="78"><span class="lineNum">      78 </span>            :         else</a>
<a name="79"><span class="lineNum">      79 </span><span class="lineNoCov">          0 :                 return new LiveVarsLattice();</span></a>
<a name="80"><span class="lineNum">      80 </span>            : }</a>
<a name="81"><span class="lineNum">      81 </span>            : </a>
<a name="82"><span class="lineNum">      82 </span>            : // The inverse of project(). The call is provided with an expression and a Lattice that describes</a>
<a name="83"><span class="lineNum">      83 </span>            : // the dataflow state that relates to expression. This Lattice must be of the same type as the lattice</a>
<a name="84"><span class="lineNum">      84 </span>            : // returned by project(). unProject() must incorporate this dataflow state into the overall state it holds.</a>
<a name="85"><span class="lineNum">      85 </span>            : // Call must make an internal copy of the passed-in lattice and the caller is responsible for deallocating it.</a>
<a name="86"><span class="lineNum">      86 </span>            : // Returns true if this causes this to change and false otherwise.</a>
<a name="87"><span class="lineNum">      87 </span><span class="lineNoCov">          0 : bool LiveVarsLattice::unProject(SgExpression* expr, Lattice* exprState) { </span></a>
<a name="88"><span class="lineNum">      88 </span><span class="lineNoCov">          0 :         LiveVarsLattice* that = dynamic_cast&lt;LiveVarsLattice*&gt;(exprState);</span></a>
<a name="89"><span class="lineNum">      89 </span><span class="lineNoCov">          0 :         varID var = SgExpr2Var(expr);</span></a>
<a name="90"><span class="lineNum">      90 </span><span class="lineNoCov">          0 :         bool modified = false;</span></a>
<a name="91"><span class="lineNum">      91 </span><span class="lineNoCov">          0 :         if(that-&gt;liveVars.find(var) != that-&gt;liveVars.end()) {</span></a>
<a name="92"><span class="lineNum">      92 </span><span class="lineNoCov">          0 :                 modified = modified || (liveVars.find(var) == liveVars.end());</span></a>
<a name="93"><span class="lineNum">      93 </span><span class="lineNoCov">          0 :                 liveVars.insert(var);</span></a>
<a name="94"><span class="lineNum">      94 </span>            :         }</a>
<a name="95"><span class="lineNum">      95 </span><span class="lineNoCov">          0 :         return modified;</span></a>
<a name="96"><span class="lineNum">      96 </span>            : }</a>
<a name="97"><span class="lineNum">      97 </span>            : </a>
<a name="98"><span class="lineNum">      98 </span>            : // computes the meet of this and that and saves the result in this</a>
<a name="99"><span class="lineNum">      99 </span>            : // returns true if this causes this to change and false otherwise</a>
<a name="100"><span class="lineNum">     100 </span><span class="lineNoCov">          0 : bool LiveVarsLattice::meetUpdate(Lattice* that_arg)</span></a>
<a name="101"><span class="lineNum">     101 </span>            : {</a>
<a name="102"><span class="lineNum">     102 </span><span class="lineNoCov">          0 :         bool modified = false;</span></a>
<a name="103"><span class="lineNum">     103 </span><span class="lineNoCov">          0 :         LiveVarsLattice* that = dynamic_cast&lt;LiveVarsLattice*&gt;(that_arg);</span></a>
<a name="104"><span class="lineNum">     104 </span>            :         </a>
<a name="105"><span class="lineNum">     105 </span>            :         // Add all variables from that to this</a>
<a name="106"><span class="lineNum">     106 </span><span class="lineNoCov">          0 :         for(set&lt;varID&gt;::iterator var=that-&gt;liveVars.begin(); var!=that-&gt;liveVars.end(); var++) {</span></a>
<a name="107"><span class="lineNum">     107 </span>            :                 // If this lattice doesn't yet record *var as being live</a>
<a name="108"><span class="lineNum">     108 </span><span class="lineNoCov">          0 :                 if(liveVars.find(*var) == liveVars.end()) {</span></a>
<a name="109"><span class="lineNum">     109 </span><span class="lineNoCov">          0 :                         modified = true;</span></a>
<a name="110"><span class="lineNum">     110 </span><span class="lineNoCov">          0 :                         liveVars.insert(*var);</span></a>
<a name="111"><span class="lineNum">     111 </span>            :                 }</a>
<a name="112"><span class="lineNum">     112 </span>            :         }</a>
<a name="113"><span class="lineNum">     113 </span>            :         </a>
<a name="114"><span class="lineNum">     114 </span><span class="lineNoCov">          0 :         return modified;        </span></a>
<a name="115"><span class="lineNum">     115 </span>            : }</a>
<a name="116"><span class="lineNum">     116 </span>            : </a>
<a name="117"><span class="lineNum">     117 </span><span class="lineNoCov">          0 : bool LiveVarsLattice::operator==(Lattice* that_arg)</span></a>
<a name="118"><span class="lineNum">     118 </span>            : {</a>
<a name="119"><span class="lineNum">     119 </span><span class="lineNoCov">          0 :         LiveVarsLattice* that = dynamic_cast&lt;LiveVarsLattice*&gt;(that_arg);</span></a>
<a name="120"><span class="lineNum">     120 </span><span class="lineNoCov">          0 :         return liveVars == that-&gt;liveVars;</span></a>
<a name="121"><span class="lineNum">     121 </span>            : }</a>
<a name="122"><span class="lineNum">     122 </span>            : </a>
<a name="123"><span class="lineNum">     123 </span>            : // Functions used to inform this lattice that a given variable is now in use (e.g. a variable has entered </a>
<a name="124"><span class="lineNum">     124 </span>            : //    scope or an expression is being analyzed) or is no longer in use (e.g. a variable has exited scope or</a>
<a name="125"><span class="lineNum">     125 </span>            : //    an expression or variable is dead).</a>
<a name="126"><span class="lineNum">     126 </span>            : // It is assumed that a newly-added variable has not been added before and that a variable that is being</a>
<a name="127"><span class="lineNum">     127 </span>            : //    removed was previously added</a>
<a name="128"><span class="lineNum">     128 </span>            : // Returns true if this causes the lattice to change and false otherwise.</a>
<a name="129"><span class="lineNum">     129 </span><span class="lineNoCov">          0 : bool LiveVarsLattice::addVar(const varID&amp; var)</span></a>
<a name="130"><span class="lineNum">     130 </span>            : {</a>
<a name="131"><span class="lineNum">     131 </span><span class="lineNoCov">          0 :         if(liveVars.find(var) == liveVars.end()) {</span></a>
<a name="132"><span class="lineNum">     132 </span><span class="lineNoCov">          0 :                 liveVars.insert(var);</span></a>
<a name="133"><span class="lineNum">     133 </span><span class="lineNoCov">          0 :                 return true;</span></a>
<a name="134"><span class="lineNum">     134 </span>            :         }</a>
<a name="135"><span class="lineNum">     135 </span>            :         return false;</a>
<a name="136"><span class="lineNum">     136 </span>            : }</a>
<a name="137"><span class="lineNum">     137 </span><span class="lineNoCov">          0 : bool LiveVarsLattice::remVar(const varID&amp; var)</span></a>
<a name="138"><span class="lineNum">     138 </span>            : {</a>
<a name="139"><span class="lineNum">     139 </span><span class="lineNoCov">          0 :         if(liveVars.find(var) != liveVars.end()) {</span></a>
<a name="140"><span class="lineNum">     140 </span><span class="lineNoCov">          0 :                 liveVars.erase(var);</span></a>
<a name="141"><span class="lineNum">     141 </span><span class="lineNoCov">          0 :                 return true;</span></a>
<a name="142"><span class="lineNum">     142 </span>            :         }</a>
<a name="143"><span class="lineNum">     143 </span>            :         return false;</a>
<a name="144"><span class="lineNum">     144 </span>            : }</a>
<a name="145"><span class="lineNum">     145 </span>            : </a>
<a name="146"><span class="lineNum">     146 </span>            : // Returns true if the given variable is recorded as live and false otherwise</a>
<a name="147"><span class="lineNum">     147 </span><span class="lineNoCov">          0 : bool LiveVarsLattice::isLiveVar(varID var)</span></a>
<a name="148"><span class="lineNum">     148 </span>            : {</a>
<a name="149"><span class="lineNum">     149 </span><span class="lineNoCov">          0 :         return liveVars.find(var) != liveVars.end();</span></a>
<a name="150"><span class="lineNum">     150 </span>            : }</a>
<a name="151"><span class="lineNum">     151 </span>            : </a>
<a name="152"><span class="lineNum">     152 </span>            : // The string that represents this object</a>
<a name="153"><span class="lineNum">     153 </span>            : // If indent!=&quot;&quot;, every line of this string must be prefixed by indent</a>
<a name="154"><span class="lineNum">     154 </span>            : // The last character of the returned string should not be '\n', even if it is a multi-line string.</a>
<a name="155"><span class="lineNum">     155 </span><span class="lineNoCov">          0 : string LiveVarsLattice::str(string indent)</span></a>
<a name="156"><span class="lineNum">     156 </span>            : {</a>
<a name="157"><span class="lineNum">     157 </span><span class="lineNoCov">          0 :         ostringstream oss;</span></a>
<a name="158"><span class="lineNum">     158 </span><span class="lineNoCov">          0 :         oss &lt;&lt; &quot;[LiveVarsLattice: liveVars=[&quot;;</span></a>
<a name="159"><span class="lineNum">     159 </span><span class="lineNoCov">          0 :         for(set&lt;varID&gt;::iterator var=liveVars.begin(); var!=liveVars.end(); ) {</span></a>
<a name="160"><span class="lineNum">     160 </span><span class="lineNoCov">          0 :                 oss &lt;&lt; *var;</span></a>
<a name="161"><span class="lineNum">     161 </span><span class="lineNoCov">          0 :                 var++;</span></a>
<a name="162"><span class="lineNum">     162 </span><span class="lineNoCov">          0 :                 if(var!=liveVars.end())</span></a>
<a name="163"><span class="lineNum">     163 </span><span class="lineNoCov">          0 :                         oss &lt;&lt; &quot;, &quot;;</span></a>
<a name="164"><span class="lineNum">     164 </span>            :         }</a>
<a name="165"><span class="lineNum">     165 </span><span class="lineNoCov">          0 :         oss &lt;&lt; &quot;]]&quot;;</span></a>
<a name="166"><span class="lineNum">     166 </span><span class="lineNoCov">          0 :         return oss.str();</span></a>
<a name="167"><span class="lineNum">     167 </span>            : }</a>
<a name="168"><span class="lineNum">     168 </span>            : </a>
<a name="169"><span class="lineNum">     169 </span>            : // ################################</a>
<a name="170"><span class="lineNum">     170 </span>            : // ##### LiveDeadVarsAnalysis #####</a>
<a name="171"><span class="lineNum">     171 </span>            : // ################################</a>
<a name="172"><span class="lineNum">     172 </span>            : </a>
<a name="173"><span class="lineNum">     173 </span><span class="lineNoCov">          0 : LiveDeadVarsAnalysis::LiveDeadVarsAnalysis(SgProject *project, funcSideEffectUses* fseu): fseu(fseu)</span></a>
<a name="174"><span class="lineNum">     174 </span>            : {</a>
<a name="175"><span class="lineNum">     175 </span><span class="lineNoCov">          0 : }</span></a>
<a name="176"><span class="lineNum">     176 </span>            : </a>
<a name="177"><span class="lineNum">     177 </span>            : // Generates the initial lattice state for the given dataflow node, in the given function, with the given NodeState</a>
<a name="178"><span class="lineNum">     178 </span><span class="lineNoCov">          0 : void LiveDeadVarsAnalysis::genInitState(const Function&amp; func, const DataflowNode&amp; n, const NodeState&amp; state,</span></a>
<a name="179"><span class="lineNum">     179 </span>            :                   vector&lt;Lattice*&gt;&amp; initLattices, vector&lt;NodeFact*&gt;&amp; initFacts)</a>
<a name="180"><span class="lineNum">     180 </span>            : {</a>
<a name="181"><span class="lineNum">     181 </span><span class="lineNoCov">          0 :         initLattices.push_back(new LiveVarsLattice());  </span></a>
<a name="182"><span class="lineNum">     182 </span><span class="lineNoCov">          0 : }</span></a>
<a name="183"><span class="lineNum">     183 </span>            : </a>
<a name="184"><span class="lineNum">     184 </span>            : /// Visits live expressions - helper to LiveDeadVarsTransfer</a>
<a name="185"><span class="lineNum">     185 </span><span class="lineNoCov">          0 : class LDVAExpressionTransfer : public ROSE_VisitorPatternDefaultBase</span></a>
<a name="186"><span class="lineNum">     186 </span>            : {</a>
<a name="187"><span class="lineNum">     187 </span>            :   LiveDeadVarsTransfer &amp;ldva;</a>
<a name="188"><span class="lineNum">     188 </span>            : </a>
<a name="189"><span class="lineNum">     189 </span>            : public:</a>
<a name="190"><span class="lineNum">     190 </span>            :   // Should only be called on expressions</a>
<a name="191"><span class="lineNum">     191 </span><span class="lineNoCov">          0 :   void visit(SgNode *) { ROSE_ABORT(); }</span></a>
<a name="192"><span class="lineNum">     192 </span>            :   // Catch up any other expressions that are not yet handled</a>
<a name="193"><span class="lineNum">     193 </span><span class="lineNoCov">          0 :   void visit(SgExpression *)</span></a>
<a name="194"><span class="lineNum">     194 </span>            :   {</a>
<a name="195"><span class="lineNum">     195 </span>            :     // Function Reference</a>
<a name="196"><span class="lineNum">     196 </span>            :     // !!! CURRENTLY WE HAVE NO NOTION OF VARIABLES THAT IDENTIFY FUNCTIONS, SO THIS CASE IS EXCLUDED FOR NOW</a>
<a name="197"><span class="lineNum">     197 </span>            :     /*} else if(isSgFunctionRefExp(sgn)) {*/</a>
<a name="198"><span class="lineNum">     198 </span>            :     /*} else if(isSgMemberFunctionRefExp(sgn)) {*/</a>
<a name="199"><span class="lineNum">     199 </span>            : </a>
<a name="200"><span class="lineNum">     200 </span>            :     // !!! DON'T KNOW HOW TO HANDLE THESE</a>
<a name="201"><span class="lineNum">     201 </span>            :     /*} else if(isSgStatementExpression(sgn)) {(*/</a>
<a name="202"><span class="lineNum">     202 </span>            : </a>
<a name="203"><span class="lineNum">     203 </span>            :     // Typeid</a>
<a name="204"><span class="lineNum">     204 </span>            :     // !!! DON'T KNOW WHAT TO DO HERE SINCE THE RETURN VALUE IS A TYPE AND THE ARGUMENT'S VALUE IS NOT USED</a>
<a name="205"><span class="lineNum">     205 </span>            :     /*} else if(isSgTypeIdOp(sgn)) {*/</a>
<a name="206"><span class="lineNum">     206 </span>            :     // Var Args</a>
<a name="207"><span class="lineNum">     207 </span>            :     // !!! DON'T HANDLE THESE RIGHT NOW. WILL HAVE TO IN THE FUTURE</a>
<a name="208"><span class="lineNum">     208 </span>            :     /*  SgVarArgOp </a>
<a name="209"><span class="lineNum">     209 </span>            :         SgExpression *  get_operand_expr () const </a>
<a name="210"><span class="lineNum">     210 </span>            :         SgVarArgCopyOp</a>
<a name="211"><span class="lineNum">     211 </span>            :         SgExpression *  get_lhs_operand () const</a>
<a name="212"><span class="lineNum">     212 </span>            :         SgExpression *  get_rhs_operand () const  </a>
<a name="213"><span class="lineNum">     213 </span>            :         SgVarArgEndOp </a>
<a name="214"><span class="lineNum">     214 </span>            :         SgExpression *  get_operand_expr </a>
<a name="215"><span class="lineNum">     215 </span>            :         SgVarArgStartOneOperandOp </a>
<a name="216"><span class="lineNum">     216 </span>            :         SgExpression *  get_operand_expr () const </a>
<a name="217"><span class="lineNum">     217 </span>            :         SgVarArgStartOp </a>
<a name="218"><span class="lineNum">     218 </span>            :         SgExpression *  get_lhs_operand () const</a>
<a name="219"><span class="lineNum">     219 </span>            :         SgExpression *  get_rhs_operand () const */</a>
<a name="220"><span class="lineNum">     220 </span>            :     // !!! WHAT IS THIS?</a>
<a name="221"><span class="lineNum">     221 </span>            :     /*  SgVariantExpression*/</a>
<a name="222"><span class="lineNum">     222 </span>            : </a>
<a name="223"><span class="lineNum">     223 </span>            : </a>
<a name="224"><span class="lineNum">     224 </span>            :     // TODO: Make this assert(0), because unhandled expression types are likely to give wrong results</a>
<a name="225"><span class="lineNum">     225 </span><span class="lineNoCov">          0 :   }</span></a>
<a name="226"><span class="lineNum">     226 </span>            :   // Plain assignment: lhs = rhs</a>
<a name="227"><span class="lineNum">     227 </span><span class="lineNoCov">          0 :   void visit(SgAssignOp *sgn) {</span></a>
<a name="228"><span class="lineNum">     228 </span><span class="lineNoCov">          0 :     ldva.assignedExprs.insert(sgn-&gt;get_lhs_operand());</span></a>
<a name="229"><span class="lineNum">     229 </span>            :                                 </a>
<a name="230"><span class="lineNum">     230 </span>            :     // If the lhs of the assignment is a complex expression (i.e. it refers to a variable that may be live) OR</a>
<a name="231"><span class="lineNum">     231 </span>            :     // if is a known expression that is known to may-be-live</a>
<a name="232"><span class="lineNum">     232 </span>            :     // THIS CODE ONLY APPLIES TO RHSs THAT ARE SIDE-EFFECT-FREE AND WE DON'T HAVE AN ANALYSIS FOR THAT YET</a>
<a name="233"><span class="lineNum">     233 </span>            :     /*if(!isVarExpr(sgn-&gt;get_lhs_operand()) || </a>
<a name="234"><span class="lineNum">     234 </span>            :       (isVarExpr(sgn-&gt;get_lhs_operand()) &amp;&amp; </a>
<a name="235"><span class="lineNum">     235 </span>            :       liveLat-&gt;isLiveVar(SgExpr2Var(sgn-&gt;get_lhs_operand()))))</a>
<a name="236"><span class="lineNum">     236 </span>            :       { */</a>
<a name="237"><span class="lineNum">     237 </span><span class="lineNoCov">          0 :     ldva.used(sgn-&gt;get_rhs_operand());</span></a>
<a name="238"><span class="lineNum">     238 </span><span class="lineNoCov">          0 :   }</span></a>
<a name="239"><span class="lineNum">     239 </span>            :   // Initializer for a variable</a>
<a name="240"><span class="lineNum">     240 </span><span class="lineNoCov">          0 :   void visit(SgAssignInitializer *sgn) {</span></a>
<a name="241"><span class="lineNum">     241 </span><span class="lineNoCov">          0 :     ldva.used(sgn-&gt;get_operand());</span></a>
<a name="242"><span class="lineNum">     242 </span><span class="lineNoCov">          0 :   }</span></a>
<a name="243"><span class="lineNum">     243 </span>            :   // Initializer for a function arguments</a>
<a name="244"><span class="lineNum">     244 </span><span class="lineNoCov">          0 :   void visit(SgConstructorInitializer *sgn) {</span></a>
<a name="245"><span class="lineNum">     245 </span><span class="lineNoCov">          0 :     SgExprListExp* exprList = sgn-&gt;get_args();</span></a>
<a name="246"><span class="lineNum">     246 </span><span class="lineNoCov">          0 :     for(SgExpressionPtrList::iterator expr=exprList-&gt;get_expressions().begin();</span></a>
<a name="247"><span class="lineNum">     247 </span><span class="lineNoCov">          0 :         expr!=exprList-&gt;get_expressions().end(); expr++)</span></a>
<a name="248"><span class="lineNum">     248 </span><span class="lineNoCov">          0 :       ldva.used(*expr);</span></a>
<a name="249"><span class="lineNum">     249 </span><span class="lineNoCov">          0 :   }</span></a>
<a name="250"><span class="lineNum">     250 </span>            :   // Initializer that captures internal stucture of structs or arrays (&quot;int x[2] = {1,2};&quot;, it is the &quot;1,2&quot;)</a>
<a name="251"><span class="lineNum">     251 </span><span class="lineNoCov">          0 :   void visit(SgAggregateInitializer *sgn) {</span></a>
<a name="252"><span class="lineNum">     252 </span><span class="lineNoCov">          0 :     SgExprListExp* exprList = sgn-&gt;get_initializers();</span></a>
<a name="253"><span class="lineNum">     253 </span><span class="lineNoCov">          0 :     for(SgExpressionPtrList::iterator expr=exprList-&gt;get_expressions().begin();</span></a>
<a name="254"><span class="lineNum">     254 </span><span class="lineNoCov">          0 :         expr!=exprList-&gt;get_expressions().end(); expr++)</span></a>
<a name="255"><span class="lineNum">     255 </span><span class="lineNoCov">          0 :       ldva.used(*expr);</span></a>
<a name="256"><span class="lineNum">     256 </span><span class="lineNoCov">          0 :   }</span></a>
<a name="257"><span class="lineNum">     257 </span>            :   // Designated Initializer </a>
<a name="258"><span class="lineNum">     258 </span><span class="lineNoCov">          0 :   void visit(SgDesignatedInitializer *sgn) {</span></a>
<a name="259"><span class="lineNum">     259 </span><span class="lineNoCov">          0 :     SgExprListExp* exprList = sgn-&gt;get_designatorList();</span></a>
<a name="260"><span class="lineNum">     260 </span><span class="lineNoCov">          0 :     for(SgExpressionPtrList::iterator expr=exprList-&gt;get_expressions().begin();</span></a>
<a name="261"><span class="lineNum">     261 </span><span class="lineNoCov">          0 :         expr!=exprList-&gt;get_expressions().end(); expr++)</span></a>
<a name="262"><span class="lineNum">     262 </span><span class="lineNoCov">          0 :       ldva.used(*expr);</span></a>
<a name="263"><span class="lineNum">     263 </span><span class="lineNoCov">          0 :   }</span></a>
<a name="264"><span class="lineNum">     264 </span>            :   // Binary Operations</a>
<a name="265"><span class="lineNum">     265 </span><span class="lineNoCov">          0 :   void visit(SgBinaryOp *sgn) {</span></a>
<a name="266"><span class="lineNum">     266 </span>            :     // Self-update expressions, where the lhs is assigned</a>
<a name="267"><span class="lineNum">     267 </span><span class="lineNoCov">          0 :     if(isSgCompoundAssignOp(sgn)) {</span></a>
<a name="268"><span class="lineNum">     268 </span><span class="lineNoCov">          0 :       ldva.assignedExprs.insert(sgn-&gt;get_lhs_operand());</span></a>
<a name="269"><span class="lineNum">     269 </span>            :     }</a>
<a name="270"><span class="lineNum">     270 </span>            :     // Both the lhs and rhs are used</a>
<a name="271"><span class="lineNum">     271 </span><span class="lineNoCov">          0 :     ldva.used(sgn-&gt;get_lhs_operand());</span></a>
<a name="272"><span class="lineNum">     272 </span><span class="lineNoCov">          0 :     ldva.used(sgn-&gt;get_rhs_operand());</span></a>
<a name="273"><span class="lineNum">     273 </span><span class="lineNoCov">          0 :   }</span></a>
<a name="274"><span class="lineNum">     274 </span>            :   // Unary Operations</a>
<a name="275"><span class="lineNum">     275 </span><span class="lineNoCov">          0 :   void visit(SgUnaryOp *sgn) {</span></a>
<a name="276"><span class="lineNum">     276 </span>            :     // If this is an auto-update operation</a>
<a name="277"><span class="lineNum">     277 </span><span class="lineNoCov">          0 :     if(isSgMinusMinusOp(sgn) || isSgPlusPlusOp(sgn)) {</span></a>
<a name="278"><span class="lineNum">     278 </span>            :       // The argument is defined</a>
<a name="279"><span class="lineNum">     279 </span><span class="lineNoCov">          0 :       ldva.assignedExprs.insert(sgn-&gt;get_operand());</span></a>
<a name="280"><span class="lineNum">     280 </span>            :     }</a>
<a name="281"><span class="lineNum">     281 </span>            :     // The argument is used</a>
<a name="282"><span class="lineNum">     282 </span><span class="lineNoCov">          0 :     ldva.used(sgn-&gt;get_operand());</span></a>
<a name="283"><span class="lineNum">     283 </span><span class="lineNoCov">          0 :   }</span></a>
<a name="284"><span class="lineNum">     284 </span>            :   // Conditionals (condE ? trueE : falseE)</a>
<a name="285"><span class="lineNum">     285 </span><span class="lineNoCov">          0 :   void visit(SgConditionalExp *sgn) {</span></a>
<a name="286"><span class="lineNum">     286 </span>            :     // The arguments are used</a>
<a name="287"><span class="lineNum">     287 </span><span class="lineNoCov">          0 :     ldva.used(sgn-&gt;get_conditional_exp());</span></a>
<a name="288"><span class="lineNum">     288 </span><span class="lineNoCov">          0 :     ldva.used(sgn-&gt;get_true_exp());</span></a>
<a name="289"><span class="lineNum">     289 </span><span class="lineNoCov">          0 :     ldva.used(sgn-&gt;get_false_exp());</span></a>
<a name="290"><span class="lineNum">     290 </span><span class="lineNoCov">          0 :   }</span></a>
<a name="291"><span class="lineNum">     291 </span>            :   // Delete</a>
<a name="292"><span class="lineNum">     292 </span><span class="lineNoCov">          0 :   void visit(SgDeleteExp *sgn) {</span></a>
<a name="293"><span class="lineNum">     293 </span>            :     // Delete expressions return nothing</a>
<a name="294"><span class="lineNum">     294 </span>            :     // The arguments are used</a>
<a name="295"><span class="lineNum">     295 </span><span class="lineNoCov">          0 :     ldva.used(sgn-&gt;get_variable());</span></a>
<a name="296"><span class="lineNum">     296 </span><span class="lineNoCov">          0 :   }</span></a>
<a name="297"><span class="lineNum">     297 </span>            :   // New</a>
<a name="298"><span class="lineNum">     298 </span><span class="lineNoCov">          0 :   void visit(SgNewExp *sgn) {</span></a>
<a name="299"><span class="lineNum">     299 </span>            :     // The placement arguments are used</a>
<a name="300"><span class="lineNum">     300 </span><span class="lineNoCov">          0 :     SgExprListExp* exprList = sgn-&gt;get_placement_args();</span></a>
<a name="301"><span class="lineNum">     301 </span>            :     // NOTE: placement args are optional</a>
<a name="302"><span class="lineNum">     302 </span>            :     // exprList could be NULL</a>
<a name="303"><span class="lineNum">     303 </span>            :     // check for NULL before adding to used set</a>
<a name="304"><span class="lineNum">     304 </span><span class="lineNoCov">          0 :     if(exprList) {</span></a>
<a name="305"><span class="lineNum">     305 </span><span class="lineNoCov">          0 :         for(SgExpressionPtrList::iterator expr=exprList-&gt;get_expressions().begin();</span></a>
<a name="306"><span class="lineNum">     306 </span><span class="lineNoCov">          0 :             expr!=exprList-&gt;get_expressions().end(); expr++)</span></a>
<a name="307"><span class="lineNum">     307 </span><span class="lineNoCov">          0 :             ldva.used(*expr);</span></a>
<a name="308"><span class="lineNum">     308 </span>            :     }</a>
<a name="309"><span class="lineNum">     309 </span>            :                                 </a>
<a name="310"><span class="lineNum">     310 </span>            :     // The placement arguments are used</a>
<a name="311"><span class="lineNum">     311 </span>            :     // check for NULL before adding to used set</a>
<a name="312"><span class="lineNum">     312 </span>            :     // not sure if this check is required for get_constructor_args()</a>
<a name="313"><span class="lineNum">     313 </span><span class="lineNoCov">          0 :     exprList = sgn-&gt;get_constructor_args()-&gt;get_args();</span></a>
<a name="314"><span class="lineNum">     314 </span><span class="lineNoCov">          0 :     if(exprList) {</span></a>
<a name="315"><span class="lineNum">     315 </span><span class="lineNoCov">          0 :         for(SgExpressionPtrList::iterator expr=exprList-&gt;get_expressions().begin();</span></a>
<a name="316"><span class="lineNum">     316 </span><span class="lineNoCov">          0 :             expr!=exprList-&gt;get_expressions().end(); expr++)</span></a>
<a name="317"><span class="lineNum">     317 </span><span class="lineNoCov">          0 :             ldva.used(*expr);</span></a>
<a name="318"><span class="lineNum">     318 </span>            :     }</a>
<a name="319"><span class="lineNum">     319 </span>            :                                 </a>
<a name="320"><span class="lineNum">     320 </span>            :     // The built-in arguments are used (DON'T KNOW WHAT THESE ARE!)</a>
<a name="321"><span class="lineNum">     321 </span>            :     // check for NULL before adding to used set</a>
<a name="322"><span class="lineNum">     322 </span>            :     // not sure if this check is required for get_builtin_args()</a>
<a name="323"><span class="lineNum">     323 </span><span class="lineNoCov">          0 :     if(sgn-&gt;get_builtin_args()) {</span></a>
<a name="324"><span class="lineNum">     324 </span><span class="lineNoCov">          0 :         ldva.used(sgn-&gt;get_builtin_args());</span></a>
<a name="325"><span class="lineNum">     325 </span>            :     }</a>
<a name="326"><span class="lineNum">     326 </span><span class="lineNoCov">          0 :   }</span></a>
<a name="327"><span class="lineNum">     327 </span>            :   // Function Calls</a>
<a name="328"><span class="lineNum">     328 </span><span class="lineNoCov">          0 :   void visit(SgFunctionCallExp *sgn) {</span></a>
<a name="329"><span class="lineNum">     329 </span>            :     // !!! CURRENTLY WE HAVE NO NOTION OF VARIABLES THAT IDENTIFY FUNCTIONS, SO THIS CASE IS EXCLUDED FOR NOW</a>
<a name="330"><span class="lineNum">     330 </span>            :     /*// The expression that identifies the called function is used</a>
<a name="331"><span class="lineNum">     331 </span>            :       ldva.used(sgn-&gt;get_function());*/</a>
<a name="332"><span class="lineNum">     332 </span>            :                                 </a>
<a name="333"><span class="lineNum">     333 </span>            :     // The function call's arguments are used</a>
<a name="334"><span class="lineNum">     334 </span><span class="lineNoCov">          0 :     SgExprListExp* exprList = sgn-&gt;get_args();</span></a>
<a name="335"><span class="lineNum">     335 </span><span class="lineNoCov">          0 :     for(SgExpressionPtrList::iterator expr=exprList-&gt;get_expressions().begin();</span></a>
<a name="336"><span class="lineNum">     336 </span><span class="lineNoCov">          0 :         expr!=exprList-&gt;get_expressions().end(); expr++)</span></a>
<a name="337"><span class="lineNum">     337 </span><span class="lineNoCov">          0 :       ldva.used(*expr);</span></a>
<a name="338"><span class="lineNum">     338 </span>            :                                 </a>
<a name="339"><span class="lineNum">     339 </span>            :     // If this function has no definition and the user provided a class to provide </a>
<a name="340"><span class="lineNum">     340 </span>            :     // the variables that are used by such functions</a>
<a name="341"><span class="lineNum">     341 </span><span class="lineNoCov">          0 :     if(sgn-&gt;getAssociatedFunctionDeclaration() &amp;&amp; </span></a>
<a name="342"><span class="lineNum">     342 </span><span class="lineNoCov">          0 :        sgn-&gt;getAssociatedFunctionDeclaration()-&gt;get_definition()==NULL &amp;&amp;</span></a>
<a name="343"><span class="lineNum">     343 </span><span class="lineNoCov">          0 :        ldva.fseu) {</span></a>
<a name="344"><span class="lineNum">     344 </span><span class="lineNoCov">          0 :       set&lt;varID&gt; funcUsedVars = ldva.fseu-&gt;usedVarsInFunc(Function(sgn-&gt;getAssociatedFunctionDeclaration()), ldva.dfNode, ldva.nodeState);</span></a>
<a name="345"><span class="lineNum">     345 </span><span class="lineNoCov">          0 :       ldva.usedVars.insert(funcUsedVars.begin(), funcUsedVars.end());</span></a>
<a name="346"><span class="lineNum">     346 </span>            :     }</a>
<a name="347"><span class="lineNum">     347 </span><span class="lineNoCov">          0 :   }</span></a>
<a name="348"><span class="lineNum">     348 </span>            :   // Sizeof</a>
<a name="349"><span class="lineNum">     349 </span><span class="lineNoCov">          0 :   void visit(SgSizeOfOp *sgn) {</span></a>
<a name="350"><span class="lineNum">     350 </span>            :     // XXX: The argument is NOT used, but its type is</a>
<a name="351"><span class="lineNum">     351 </span>            :     // NOTE: get_operand_expr() returns NULL when sizeof(type)</a>
<a name="352"><span class="lineNum">     352 </span>            :     // FIX: use get_operand_expr() only when sizeof() involves expr</a>
<a name="353"><span class="lineNum">     353 </span>            :     // ldva.used(sgn-&gt;get_operand_expr());</a>
<a name="354"><span class="lineNum">     354 </span><span class="lineNoCov">          0 :       if(sgn-&gt;get_operand_expr()) {</span></a>
<a name="355"><span class="lineNum">     355 </span><span class="lineNoCov">          0 :           ldva.used(sgn-&gt;get_operand_expr());</span></a>
<a name="356"><span class="lineNum">     356 </span>            :       }</a>
<a name="357"><span class="lineNum">     357 </span><span class="lineNoCov">          0 :   }</span></a>
<a name="358"><span class="lineNum">     358 </span>            :   // This</a>
<a name="359"><span class="lineNum">     359 </span><span class="lineNoCov">          0 :   void visit(SgThisExp *sgn) {</span></a>
<a name="360"><span class="lineNum">     360 </span><span class="lineNoCov">          0 :   }</span></a>
<a name="361"><span class="lineNum">     361 </span>            :   // Variable Reference (we know this expression is live)</a>
<a name="362"><span class="lineNum">     362 </span><span class="lineNoCov">          0 :   void visit(SgVarRefExp *sgn) {</span></a>
<a name="363"><span class="lineNum">     363 </span>            : //  Liao, 4/5/2012. We cannot decide if a SgVarRefExp is read or written</a>
<a name="364"><span class="lineNum">     364 </span>            : //    without its context information: for example, in  a = b; both a and b are represented as</a>
<a name="365"><span class="lineNum">     365 </span>            : //    SgVarRefExp. But a is written and b is read.</a>
<a name="366"><span class="lineNum">     366 </span>            : //    We should let the ancestor node (like SgAssignOp) decide on the READ/Written of SgVarRefExp.</a>
<a name="367"><span class="lineNum">     367 </span>            : //    This is already done.   </a>
<a name="368"><span class="lineNum">     368 </span>            : //    ldva.used(sgn); </a>
<a name="369"><span class="lineNum">     369 </span><span class="lineNoCov">          0 :   }</span></a>
<a name="370"><span class="lineNum">     370 </span>            : </a>
<a name="371"><span class="lineNum">     371 </span><span class="lineNoCov">          0 :   LDVAExpressionTransfer(LiveDeadVarsTransfer &amp;base)</span></a>
<a name="372"><span class="lineNum">     372 </span><span class="lineNoCov">          0 :     : ldva(base)</span></a>
<a name="373"><span class="lineNum">     373 </span>            :   { }</a>
<a name="374"><span class="lineNum">     374 </span>            : };</a>
<a name="375"><span class="lineNum">     375 </span>            : </a>
<a name="376"><span class="lineNum">     376 </span><span class="lineNoCov">          0 : void LiveDeadVarsTransfer::used(SgExpression *sgn)</span></a>
<a name="377"><span class="lineNum">     377 </span>            : {</a>
<a name="378"><span class="lineNum">     378 </span><span class="lineNoCov">          0 :   usedVars.insert(SgExpr2Var(sgn));</span></a>
<a name="379"><span class="lineNum">     379 </span><span class="lineNoCov">          0 : }</span></a>
<a name="380"><span class="lineNum">     380 </span>            : </a>
<a name="381"><span class="lineNum">     381 </span><span class="lineNoCov">          0 : void LiveDeadVarsTransfer::visit(SgExpression *sgn)</span></a>
<a name="382"><span class="lineNum">     382 </span>            : {</a>
<a name="383"><span class="lineNum">     383 </span><span class="lineNoCov">          0 :   bool isLive = liveLat-&gt;isLiveVar(SgExpr2Var(sgn));</span></a>
<a name="384"><span class="lineNum">     384 </span><span class="lineNoCov">          0 :   if(liveDeadAnalysisDebugLevel&gt;=1)</span></a>
<a name="385"><span class="lineNum">     385 </span><span class="lineNoCov">          0 :     Dbg::dbg &lt;&lt; indent &lt;&lt; (isLive ? &quot;Live Expression&quot; : &quot;Dead Expression&quot;) &lt;&lt;endl;</span></a>
<a name="386"><span class="lineNum">     386 </span>            : </a>
<a name="387"><span class="lineNum">     387 </span><span class="lineNoCov">          0 :   if(isLive) {</span></a>
<a name="388"><span class="lineNum">     388 </span><span class="lineNoCov">          0 :     LDVAExpressionTransfer helper(*this);</span></a>
<a name="389"><span class="lineNum">     389 </span><span class="lineNoCov">          0 :     sgn-&gt;accept(helper);</span></a>
<a name="390"><span class="lineNum">     390 </span>            :   }</a>
<a name="391"><span class="lineNum">     391 </span>            : </a>
<a name="392"><span class="lineNum">     392 </span>            :   // Remove the expression itself since it has no uses above itself</a>
<a name="393"><span class="lineNum">     393 </span><span class="lineNoCov">          0 :   if (!isSgVarRefExp(sgn)) // Liao 4/5/2012, we should not remove SgVarRef since it may have uses above itself</span></a>
<a name="394"><span class="lineNum">     394 </span>            :   {</a>
<a name="395"><span class="lineNum">     395 </span><span class="lineNoCov">          0 :     if(liveDeadAnalysisDebugLevel&gt;=1) Dbg::dbg &lt;&lt; indent &lt;&lt; &quot;   Removing the expression itself&quot;&lt;&lt;SgExpr2Var(sgn)&lt;&lt;endl;</span></a>
<a name="396"><span class="lineNum">     396 </span><span class="lineNoCov">          0 :     modified = liveLat-&gt;remVar(SgExpr2Var(sgn)) || modified;</span></a>
<a name="397"><span class="lineNum">     397 </span>            :   }</a>
<a name="398"><span class="lineNum">     398 </span><span class="lineNoCov">          0 : }</span></a>
<a name="399"><span class="lineNum">     399 </span>            : </a>
<a name="400"><span class="lineNum">     400 </span><span class="lineNoCov">          0 : void LiveDeadVarsTransfer::visit(SgInitializedName *sgn) {</span></a>
<a name="401"><span class="lineNum">     401 </span><span class="lineNoCov">          0 :   varID var(sgn);</span></a>
<a name="402"><span class="lineNum">     402 </span><span class="lineNoCov">          0 :   assignedVars.insert(var);</span></a>
<a name="403"><span class="lineNum">     403 </span>            :   // If this is the instance of SgInitializedName that occurrs immediately after the declaration's initializer AND</a>
<a name="404"><span class="lineNum">     404 </span>            :   // this declaration has an initializer, add it as a use</a>
<a name="405"><span class="lineNum">     405 </span><span class="lineNoCov">          0 :   if(dfNode.getIndex()==1 &amp;&amp; sgn-&gt;get_initializer())</span></a>
<a name="406"><span class="lineNum">     406 </span><span class="lineNoCov">          0 :     used(sgn-&gt;get_initializer());</span></a>
<a name="407"><span class="lineNum">     407 </span><span class="lineNoCov">          0 : }</span></a>
<a name="408"><span class="lineNum">     408 </span>            : </a>
<a name="409"><span class="lineNum">     409 </span><span class="lineNoCov">          0 : void LiveDeadVarsTransfer::visit(SgReturnStmt *sgn) {</span></a>
<a name="410"><span class="lineNum">     410 </span><span class="lineNoCov">          0 :   used(sgn-&gt;get_expression());</span></a>
<a name="411"><span class="lineNum">     411 </span><span class="lineNoCov">          0 : }</span></a>
<a name="412"><span class="lineNum">     412 </span><span class="lineNoCov">          0 : void LiveDeadVarsTransfer::visit(SgExprStatement *sgn) {</span></a>
<a name="413"><span class="lineNum">     413 </span><span class="lineNoCov">          0 :   used(sgn-&gt;get_expression());</span></a>
<a name="414"><span class="lineNum">     414 </span><span class="lineNoCov">          0 : }</span></a>
<a name="415"><span class="lineNum">     415 </span><span class="lineNoCov">          0 : void LiveDeadVarsTransfer::visit(SgCaseOptionStmt *sgn) {</span></a>
<a name="416"><span class="lineNum">     416 </span><span class="lineNoCov">          0 :   used(sgn-&gt;get_key());</span></a>
<a name="417"><span class="lineNum">     417 </span><span class="lineNoCov">          0 :   if (sgn-&gt;get_key_range_end())</span></a>
<a name="418"><span class="lineNum">     418 </span><span class="lineNoCov">          0 :       used(sgn-&gt;get_key_range_end());</span></a>
<a name="419"><span class="lineNum">     419 </span><span class="lineNoCov">          0 : }</span></a>
<a name="420"><span class="lineNum">     420 </span><span class="lineNoCov">          0 : void LiveDeadVarsTransfer::visit(SgIfStmt *sgn) {</span></a>
<a name="421"><span class="lineNum">     421 </span>            :   //Dbg::dbg &lt;&lt; &quot;SgIfStmt&quot;&lt;&lt;endl;</a>
<a name="422"><span class="lineNum">     422 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(isSgExprStatement(sgn-&gt;get_conditional()));</span></a>
<a name="423"><span class="lineNum">     423 </span>            :   //Dbg::dbg &lt;&lt; &quot;    conditional stmt=&quot;&lt;&lt;Dbg::escape(isSgExprStatement(sgn-&gt;get_conditional())-&gt;unparseToString()) &lt;&lt; &quot; | &quot; &lt;&lt; isSgExprStatement(sgn-&gt;get_conditional())-&gt;class_name()&lt;&lt;endl;</a>
<a name="424"><span class="lineNum">     424 </span>            :   //Dbg::dbg &lt;&lt; &quot;    conditional expr=&quot;&lt;&lt;Dbg::escape(isSgExprStatement(sgn-&gt;get_conditional())-&gt;get_expression()-&gt;unparseToString()) &lt;&lt; &quot; | &quot; &lt;&lt; isSgExprStatement(sgn-&gt;get_conditional())-&gt;get_expression()-&gt;class_name()&lt;&lt;endl;</a>
<a name="425"><span class="lineNum">     425 </span>            :   //Dbg::dbg &lt;&lt; &quot;    conditional var=&quot;&lt;&lt;SgExpr2Var(isSgExprStatement(sgn-&gt;get_conditional())-&gt;get_expression())&lt;&lt;endl;</a>
<a name="426"><span class="lineNum">     426 </span><span class="lineNoCov">          0 :   used(isSgExprStatement(sgn-&gt;get_conditional())-&gt;get_expression());</span></a>
<a name="427"><span class="lineNum">     427 </span><span class="lineNoCov">          0 : }</span></a>
<a name="428"><span class="lineNum">     428 </span><span class="lineNoCov">          0 : void LiveDeadVarsTransfer::visit(SgForStatement *sgn) {</span></a>
<a name="429"><span class="lineNum">     429 </span><span class="lineNoCov">          0 :     if (isSgExprStatement(sgn-&gt;get_test())) {</span></a>
<a name="430"><span class="lineNum">     430 </span><span class="lineNoCov">          0 :         used(isSgExprStatement(sgn-&gt;get_test())-&gt;get_expression());</span></a>
<a name="431"><span class="lineNum">     431 </span><span class="lineNoCov">          0 :         used(sgn-&gt;get_increment());</span></a>
<a name="432"><span class="lineNum">     432 </span><span class="lineNoCov">          0 :     } else if (isSgNullStatement(sgn-&gt;get_test())) {</span></a>
<a name="433"><span class="lineNum">     433 </span>            :         // void: no def or use</a>
<a name="434"><span class="lineNum">     434 </span>            :     } else {</a>
<a name="435"><span class="lineNum">     435 </span><span class="lineNoCov">          0 :         std::cerr &lt;&lt;&quot;LiveDeadVarsTransfer::visit() \&quot;for\&quot; test statement type is not handled yet: &quot;</span></a>
<a name="436"><span class="lineNum">     436 </span><span class="lineNoCov">          0 :                   &lt;&lt;sgn-&gt;get_test()-&gt;class_name() &lt;&lt;&quot;\n&quot;;</span></a>
<a name="437"><span class="lineNum">     437 </span><span class="lineNoCov">          0 :         ROSE_ASSERT(!&quot;statement type not handled&quot;);</span></a>
<a name="438"><span class="lineNum">     438 </span>            :     }</a>
<a name="439"><span class="lineNum">     439 </span><span class="lineNoCov">          0 : }</span></a>
<a name="440"><span class="lineNum">     440 </span><span class="lineNoCov">          0 : void LiveDeadVarsTransfer::visit(SgWhileStmt *sgn) {</span></a>
<a name="441"><span class="lineNum">     441 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(isSgExprStatement(sgn-&gt;get_condition()));</span></a>
<a name="442"><span class="lineNum">     442 </span>            :   //Dbg::dbg &lt;&lt; &quot;condition=&quot;&lt;&lt;Dbg::escape(sgn-&gt;get_condition()-&gt;unparseToString()) &lt;&lt; &quot; | &quot; &lt;&lt; sgn-&gt;get_condition()-&gt;class_name()&lt;&lt;endl;</a>
<a name="443"><span class="lineNum">     443 </span><span class="lineNoCov">          0 :   used(isSgExprStatement(sgn-&gt;get_condition())-&gt;get_expression());</span></a>
<a name="444"><span class="lineNum">     444 </span><span class="lineNoCov">          0 : }</span></a>
<a name="445"><span class="lineNum">     445 </span><span class="lineNoCov">          0 : void LiveDeadVarsTransfer::visit(SgDoWhileStmt *sgn) {</span></a>
<a name="446"><span class="lineNum">     446 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(isSgExprStatement(sgn-&gt;get_condition()));</span></a>
<a name="447"><span class="lineNum">     447 </span>            :   //Dbg::dbg &lt;&lt; &quot;condition=&quot;&lt;&lt;Dbg::escape(sgn-&gt;get_condition()-&gt;unparseToString()) &lt;&lt; &quot; | &quot; &lt;&lt; sgn-&gt;get_condition()-&gt;class_name()&lt;&lt;endl;</a>
<a name="448"><span class="lineNum">     448 </span><span class="lineNoCov">          0 :   used(isSgExprStatement(sgn-&gt;get_condition())-&gt;get_expression());</span></a>
<a name="449"><span class="lineNum">     449 </span><span class="lineNoCov">          0 : }</span></a>
<a name="450"><span class="lineNum">     450 </span>            : </a>
<a name="451"><span class="lineNum">     451 </span><span class="lineNoCov">          0 : bool LiveDeadVarsTransfer::finish()</span></a>
<a name="452"><span class="lineNum">     452 </span>            : {</a>
<a name="453"><span class="lineNum">     453 </span>            :         // First process assignments, then uses since we may assign and use the same variable</a>
<a name="454"><span class="lineNum">     454 </span>            :         // and in the end we want to first remove it and then re-insert it.</a>
<a name="455"><span class="lineNum">     455 </span>            :         </a>
<a name="456"><span class="lineNum">     456 </span><span class="lineNoCov">          0 :         if(liveDeadAnalysisDebugLevel&gt;=1) {</span></a>
<a name="457"><span class="lineNum">     457 </span><span class="lineNoCov">          0 :                 Dbg::dbg &lt;&lt; indent &lt;&lt; &quot;    usedVars=&lt;&quot;;</span></a>
<a name="458"><span class="lineNum">     458 </span><span class="lineNoCov">          0 :                 for(set&lt;varID&gt;::iterator var=usedVars.begin(); var!=usedVars.end(); var++)</span></a>
<a name="459"><span class="lineNum">     459 </span><span class="lineNoCov">          0 :                         Dbg::dbg &lt;&lt; var &lt;&lt; &quot;, &quot;;</span></a>
<a name="460"><span class="lineNum">     460 </span><span class="lineNoCov">          0 :                 Dbg::dbg &lt;&lt; &quot;&gt;&quot;&lt;&lt;endl;</span></a>
<a name="461"><span class="lineNum">     461 </span><span class="lineNoCov">          0 :                 Dbg::dbg &lt;&lt; indent &lt;&lt; &quot;    assignedVars=&lt;&quot;;</span></a>
<a name="462"><span class="lineNum">     462 </span><span class="lineNoCov">          0 :                 for(set&lt;varID&gt;::iterator var=assignedVars.begin(); var!=assignedVars.end(); var++)</span></a>
<a name="463"><span class="lineNum">     463 </span><span class="lineNoCov">          0 :                         Dbg::dbg &lt;&lt; var &lt;&lt; &quot;, &quot;;</span></a>
<a name="464"><span class="lineNum">     464 </span><span class="lineNoCov">          0 :                 Dbg::dbg &lt;&lt; &quot;&gt;&quot;&lt;&lt;endl;</span></a>
<a name="465"><span class="lineNum">     465 </span><span class="lineNoCov">          0 :                 Dbg::dbg &lt;&lt; indent &lt;&lt; &quot;    assignedExprs=&lt;&quot;;</span></a>
<a name="466"><span class="lineNum">     466 </span><span class="lineNoCov">          0 :                 for(set&lt;SgExpression*&gt;::iterator exp=assignedExprs.begin(); exp!=assignedExprs.end(); exp++)</span></a>
<a name="467"><span class="lineNum">     467 </span><span class="lineNoCov">          0 :                         Dbg::dbg &lt;&lt; (*exp)-&gt;class_name() &lt;&lt;&quot;:&quot;&lt;&lt; (*exp)-&gt;unparseToString() &lt;&lt; &quot;, &quot;;</span></a>
<a name="468"><span class="lineNum">     468 </span><span class="lineNoCov">          0 :                 Dbg::dbg &lt;&lt; &quot;&gt;&quot;&lt;&lt;endl;</span></a>
<a name="469"><span class="lineNum">     469 </span>            :         }</a>
<a name="470"><span class="lineNum">     470 </span>            :          /* Live-In (node) = Used(node) + (Live-Out (node) - Assigned (b))  </a>
<a name="471"><span class="lineNum">     471 </span>            :           * Live-Out (node) is the lattice after merging ???</a>
<a name="472"><span class="lineNum">     472 </span>            :           * */ </a>
<a name="473"><span class="lineNum">     473 </span>            :         // Record for each assigned expression:</a>
<a name="474"><span class="lineNum">     474 </span>            :         //    If the expression corresponds to a variable, record that the variable is dead.</a>
<a name="475"><span class="lineNum">     475 </span>            :         //    Otherwise, record that the expression that computes the assigned memory location is live</a>
<a name="476"><span class="lineNum">     476 </span><span class="lineNoCov">          0 :         for(set&lt;SgExpression*&gt;::iterator asgn=assignedExprs.begin(); asgn!=assignedExprs.end(); asgn++) {</span></a>
<a name="477"><span class="lineNum">     477 </span>            :                 // If the lhs is a variable reference, remove it from live variables unless we also use this variable</a>
<a name="478"><span class="lineNum">     478 </span><span class="lineNoCov">          0 :                 if(isVarExpr(*asgn))</span></a>
<a name="479"><span class="lineNum">     479 </span>            :                 { </a>
<a name="480"><span class="lineNum">     480 </span>            :                   // if(usedVars.find(SgExpr2Var(*asgn)) != usedVars.end()) // found in use?  Wrong condition!!</a>
<a name="481"><span class="lineNum">     481 </span><span class="lineNoCov">          0 :                   if(usedVars.find(SgExpr2Var(*asgn)) == usedVars.end()) // if not found in use, then remove it, Liao 4/5/2012</span></a>
<a name="482"><span class="lineNum">     482 </span>            :                   {</a>
<a name="483"><span class="lineNum">     483 </span><span class="lineNoCov">          0 :                     modified = liveLat-&gt;remVar(SgExpr2Var(*asgn)) || modified; </span></a>
<a name="484"><span class="lineNum">     484 </span><span class="lineNoCov">          0 :                     if(liveDeadAnalysisDebugLevel&gt;=1) {</span></a>
<a name="485"><span class="lineNum">     485 </span><span class="lineNoCov">          0 :                       Dbg::dbg &lt;&lt; indent &lt;&lt; &quot;    removing assigned expr &lt;&quot; &lt;&lt; (*asgn)-&gt;class_name() &lt;&lt;&quot;:&quot;&lt;&lt;(*asgn)-&gt;unparseToString();</span></a>
<a name="486"><span class="lineNum">     486 </span><span class="lineNoCov">          0 :                       Dbg::dbg &lt;&lt; &quot;&gt;&quot;&lt;&lt;endl;</span></a>
<a name="487"><span class="lineNum">     487 </span>            :                     }</a>
<a name="488"><span class="lineNum">     488 </span>            :                   }</a>
<a name="489"><span class="lineNum">     489 </span>            :                 }</a>
<a name="490"><span class="lineNum">     490 </span>            :                 else</a>
<a name="491"><span class="lineNum">     491 </span>            :                 {</a>
<a name="492"><span class="lineNum">     492 </span><span class="lineNoCov">          0 :                   modified = liveLat-&gt;addVar(SgExpr2Var(*asgn)) || modified;</span></a>
<a name="493"><span class="lineNum">     493 </span><span class="lineNoCov">          0 :                   if(liveDeadAnalysisDebugLevel&gt;=1) {</span></a>
<a name="494"><span class="lineNum">     494 </span><span class="lineNoCov">          0 :                     Dbg::dbg &lt;&lt; indent &lt;&lt; &quot;    add assigned expr as live &lt;&quot; &lt;&lt; (*asgn)-&gt;class_name() &lt;&lt;&quot;:&quot;&lt;&lt;(*asgn)-&gt;unparseToString();</span></a>
<a name="495"><span class="lineNum">     495 </span>            :                   }</a>
<a name="496"><span class="lineNum">     496 </span>            :                 }</a>
<a name="497"><span class="lineNum">     497 </span>            :         }</a>
<a name="498"><span class="lineNum">     498 </span><span class="lineNoCov">          0 :         for(set&lt;varID&gt;::iterator asgn=assignedVars.begin(); asgn!=assignedVars.end(); asgn++) {</span></a>
<a name="499"><span class="lineNum">     499 </span>            :                 // Remove this variable from live variables unless we also use this variable</a>
<a name="500"><span class="lineNum">     500 </span><span class="lineNoCov">          0 :                 if(usedVars.find(*asgn) == usedVars.end())</span></a>
<a name="501"><span class="lineNum">     501 </span><span class="lineNoCov">          0 :                         modified = liveLat-&gt;remVar(*asgn) || modified;</span></a>
<a name="502"><span class="lineNum">     502 </span>            :         }</a>
<a name="503"><span class="lineNum">     503 </span>            :         </a>
<a name="504"><span class="lineNum">     504 </span>            :         // Record that the used variables are live</a>
<a name="505"><span class="lineNum">     505 </span><span class="lineNoCov">          0 :         for(set&lt;varID&gt;::iterator var=usedVars.begin(); var!=usedVars.end(); var++)</span></a>
<a name="506"><span class="lineNum">     506 </span><span class="lineNoCov">          0 :                 modified = liveLat-&gt;addVar(*var) || modified;</span></a>
<a name="507"><span class="lineNum">     507 </span>            :         </a>
<a name="508"><span class="lineNum">     508 </span><span class="lineNoCov">          0 :         if(liveDeadAnalysisDebugLevel&gt;=1) Dbg::dbg &lt;&lt; indent &lt;&lt; &quot;    #usedVars=&quot;&lt;&lt;usedVars.size()&lt;&lt;&quot; #assignedExprs=&quot;&lt;&lt;assignedExprs.size()&lt;&lt;endl;</span></a>
<a name="509"><span class="lineNum">     509 </span>            :         </a>
<a name="510"><span class="lineNum">     510 </span><span class="lineNoCov">          0 :         return modified;</span></a>
<a name="511"><span class="lineNum">     511 </span>            : }</a>
<a name="512"><span class="lineNum">     512 </span>            : </a>
<a name="513"><span class="lineNum">     513 </span>            : // Initialize vars to hold all the variables and expressions that are live at DataflowNode n</a>
<a name="514"><span class="lineNum">     514 </span>            : //void getAllLiveVarsAt(LiveDeadVarsAnalysis* ldva, const DataflowNode&amp; n, const NodeState&amp; state, set&lt;varID&gt;&amp; vars, string indent)</a>
<a name="515"><span class="lineNum">     515 </span><span class="lineNoCov">          0 : void getAllLiveVarsAt(LiveDeadVarsAnalysis* ldva, const NodeState&amp; state, set&lt;varID&gt;&amp; vars, string indent)</span></a>
<a name="516"><span class="lineNum">     516 </span>            : {</a>
<a name="517"><span class="lineNum">     517 </span>            :         //Dbg::dbg &lt;&lt; &quot;getAllLiveVarsAt() n=&quot;&lt;&lt;Dbg::escape(n.getNode()-&gt;unparseToString()) &lt;&lt; &quot; | &quot; &lt;&lt; n.getNode()-&gt;class_name()&lt;&lt;&quot; | &quot;&lt;&lt;n.getIndex()&lt;&lt;endl;</a>
<a name="518"><span class="lineNum">     518 </span>            :         //Dbg::dbg &lt;&lt; &quot;    state.getLatticeAbove(ldva): #=&quot;&lt;&lt;state.getLatticeAbove(ldva).size()&lt;&lt;endl;</a>
<a name="519"><span class="lineNum">     519 </span>            :         //for(vector&lt;Lattice*&gt;::const_iterator lat=state.getLatticeAbove(ldva).begin(); lat!=state.getLatticeAbove(ldva).end(); lat++) {</a>
<a name="520"><span class="lineNum">     520 </span>            :         //      Dbg::dbg &lt;&lt;&quot;        lat=&quot;&lt;&lt;*lat&lt;&lt;endl;</a>
<a name="521"><span class="lineNum">     521 </span>            :         //      Dbg::dbg &lt;&lt;&quot;        lat=&quot;&lt;&lt;(*lat)-&gt;str(&quot;            &quot;)&lt;&lt;endl;</a>
<a name="522"><span class="lineNum">     522 </span>            :         //}</a>
<a name="523"><span class="lineNum">     523 </span>            :         //Dbg::dbg &lt;&lt; &quot;    state.getLatticeBelow(ldva): #=&quot;&lt;&lt;state.getLatticeBelow(ldva).size()&lt;&lt;endl;</a>
<a name="524"><span class="lineNum">     524 </span>            :         //for(vector&lt;Lattice*&gt;::const_iterator lat=state.getLatticeBelow(ldva).begin(); lat!=state.getLatticeBelow(ldva).end(); lat++) {</a>
<a name="525"><span class="lineNum">     525 </span>            :         //      Dbg::dbg &lt;&lt;&quot;        lat=&quot;&lt;&lt;*lat&lt;&lt;endl;</a>
<a name="526"><span class="lineNum">     526 </span>            :         //      Dbg::dbg &lt;&lt;&quot;        lat=&quot;&lt;&lt;(*lat)-&gt;str(&quot;            &quot;)&lt;&lt;endl;</a>
<a name="527"><span class="lineNum">     527 </span>            :         //}</a>
<a name="528"><span class="lineNum">     528 </span>            :         //Dbg::dbg &lt;&lt; &quot;    state = &quot;&lt;&lt;state.str(ldva, &quot;        &quot;)&lt;&lt;endl;</a>
<a name="529"><span class="lineNum">     529 </span>            :         //Dbg::dbg.flush();</a>
<a name="530"><span class="lineNum">     530 </span><span class="lineNoCov">          0 :         LiveVarsLattice* liveLAbove = dynamic_cast&lt;LiveVarsLattice*&gt;(*(state.getLatticeAbove(ldva).begin()));</span></a>
<a name="531"><span class="lineNum">     531 </span><span class="lineNoCov">          0 :         LiveVarsLattice* liveLBelow = dynamic_cast&lt;LiveVarsLattice*&gt;(*(state.getLatticeBelow(ldva).begin()));</span></a>
<a name="532"><span class="lineNum">     532 </span>            : </a>
<a name="533"><span class="lineNum">     533 </span>            :         // The set of live vars AT this node is the union of vars that are live above it and below it</a>
<a name="534"><span class="lineNum">     534 </span><span class="lineNoCov">          0 :         for(set&lt;varID&gt;::iterator var=liveLAbove-&gt;liveVars.begin(); var!=liveLAbove-&gt;liveVars.end(); var++)</span></a>
<a name="535"><span class="lineNum">     535 </span><span class="lineNoCov">          0 :                 vars.insert(*var);</span></a>
<a name="536"><span class="lineNum">     536 </span><span class="lineNoCov">          0 :         for(set&lt;varID&gt;::iterator var=liveLBelow-&gt;liveVars.begin(); var!=liveLBelow-&gt;liveVars.end(); var++)</span></a>
<a name="537"><span class="lineNum">     537 </span><span class="lineNoCov">          0 :                 vars.insert(*var);</span></a>
<a name="538"><span class="lineNum">     538 </span><span class="lineNoCov">          0 : }</span></a>
<a name="539"><span class="lineNum">     539 </span>            : </a>
<a name="540"><span class="lineNum">     540 </span>            : // Returns the set of variables and expressions that are live at DataflowNode n</a>
<a name="541"><span class="lineNum">     541 </span>            : //set&lt;varID&gt; getAllLiveVarsAt(LiveDeadVarsAnalysis* ldva, const DataflowNode&amp; n, const NodeState&amp; state, string indent)</a>
<a name="542"><span class="lineNum">     542 </span><span class="lineNoCov">          0 : set&lt;varID&gt; getAllLiveVarsAt(LiveDeadVarsAnalysis* ldva, const NodeState&amp; state, string indent)</span></a>
<a name="543"><span class="lineNum">     543 </span>            : {</a>
<a name="544"><span class="lineNum">     544 </span><span class="lineNoCov">          0 :         set&lt;varID&gt; vars;</span></a>
<a name="545"><span class="lineNum">     545 </span>            :         //getAllLiveVarsAt(ldva, n, state, vars, indent);</a>
<a name="546"><span class="lineNum">     546 </span><span class="lineNoCov">          0 :         getAllLiveVarsAt(ldva, state, vars, indent);</span></a>
<a name="547"><span class="lineNum">     547 </span><span class="lineNoCov">          0 :         return vars;</span></a>
<a name="548"><span class="lineNum">     548 </span>            : }</a>
<a name="549"><span class="lineNum">     549 </span>            : </a>
<a name="550"><span class="lineNum">     550 </span>            : // get Live-In variable lattice for a control flow graph node generated from a SgNode with an index</a>
<a name="551"><span class="lineNum">     551 </span><span class="lineNoCov">          0 : LiveVarsLattice* getLiveInVarsAt(LiveDeadVarsAnalysis* ldva, SgNode* n, unsigned int index /*= 0 */)</span></a>
<a name="552"><span class="lineNum">     552 </span>            : {</a>
<a name="553"><span class="lineNum">     553 </span>            : </a>
<a name="554"><span class="lineNum">     554 </span><span class="lineNoCov">          0 :   assert (ldva != NULL); </span></a>
<a name="555"><span class="lineNum">     555 </span><span class="lineNoCov">          0 :   assert (n != NULL); </span></a>
<a name="556"><span class="lineNum">     556 </span>            : </a>
<a name="557"><span class="lineNum">     557 </span><span class="lineNoCov">          0 :   NodeState *state =  NodeState::getNodeState(n, index);</span></a>
<a name="558"><span class="lineNum">     558 </span><span class="lineNoCov">          0 :   assert (state != NULL);</span></a>
<a name="559"><span class="lineNum">     559 </span><span class="lineNoCov">          0 :   LiveVarsLattice* liveLAbove = dynamic_cast&lt;LiveVarsLattice*&gt;(*(state-&gt;getLatticeAbove(ldva).begin()));</span></a>
<a name="560"><span class="lineNum">     560 </span><span class="lineNoCov">          0 :   return liveLAbove;</span></a>
<a name="561"><span class="lineNum">     561 </span>            : }</a>
<a name="562"><span class="lineNum">     562 </span>            : </a>
<a name="563"><span class="lineNum">     563 </span>            : // get Live-Out variable lattice for a control flow graph node generated from a SgNode with an index</a>
<a name="564"><span class="lineNum">     564 </span><span class="lineNoCov">          0 : LiveVarsLattice* getLiveOutVarsAt(LiveDeadVarsAnalysis* ldva, SgNode* n, unsigned int index /* = 0 */)</span></a>
<a name="565"><span class="lineNum">     565 </span>            : {</a>
<a name="566"><span class="lineNum">     566 </span><span class="lineNoCov">          0 :   assert (ldva != NULL); </span></a>
<a name="567"><span class="lineNum">     567 </span><span class="lineNoCov">          0 :   assert (n != NULL); </span></a>
<a name="568"><span class="lineNum">     568 </span>            : </a>
<a name="569"><span class="lineNum">     569 </span><span class="lineNoCov">          0 :   NodeState *state =  NodeState::getNodeState(n, index);</span></a>
<a name="570"><span class="lineNum">     570 </span><span class="lineNoCov">          0 :   assert (state != NULL);</span></a>
<a name="571"><span class="lineNum">     571 </span><span class="lineNoCov">          0 :   LiveVarsLattice* liveLBelow = dynamic_cast&lt;LiveVarsLattice*&gt;(*(state-&gt;getLatticeBelow(ldva).begin()));</span></a>
<a name="572"><span class="lineNum">     572 </span><span class="lineNoCov">          0 :   return liveLBelow;</span></a>
<a name="573"><span class="lineNum">     573 </span>            : }</a>
<a name="574"><span class="lineNum">     574 </span>            : </a>
<a name="575"><span class="lineNum">     575 </span>            : // ###################################</a>
<a name="576"><span class="lineNum">     576 </span>            : // ##### VarsExprsProductLattice #####</a>
<a name="577"><span class="lineNum">     577 </span>            : // ###################################</a>
<a name="578"><span class="lineNum">     578 </span>            : </a>
<a name="579"><span class="lineNum">     579 </span>            : // Minimal constructor that initializes just the portions of the object required to make an </a>
<a name="580"><span class="lineNum">     580 </span>            : // initial blank VarsExprsProductLattice</a>
<a name="581"><span class="lineNum">     581 </span><span class="lineNoCov">          0 : VarsExprsProductLattice::VarsExprsProductLattice(const DataflowNode&amp; n, const NodeState&amp; state, bool (*filter) (CFGNode cfgn)) </span></a>
<a name="582"><span class="lineNum">     582 </span>            : // DQ (12/6/2016): Fixed compiler warning: -Wreorder.</a>
<a name="583"><span class="lineNum">     583 </span>            : // : n(n), state(state), filter(filter)</a>
<a name="584"><span class="lineNum">     584 </span>            :    : filter(filter), </a>
<a name="585"><span class="lineNum">     585 </span>            :      n(n), </a>
<a name="586"><span class="lineNum">     586 </span><span class="lineNoCov">          0 :      state(state)</span></a>
<a name="587"><span class="lineNum">     587 </span>            :    {</a>
<a name="588"><span class="lineNum">     588 </span><span class="lineNoCov">          0 :    }</span></a>
<a name="589"><span class="lineNum">     589 </span>            : </a>
<a name="590"><span class="lineNum">     590 </span>            : //Collect all expressions, not just variable reference expression, in the AST</a>
<a name="591"><span class="lineNum">     591 </span>            : // The reason is that the temp expressions are often useful to propagate data flow information (lattices)</a>
<a name="592"><span class="lineNum">     592 </span>            : // example:  for a+b, the SgAddOp can be used to calculate the addition of two operands.</a>
<a name="593"><span class="lineNum">     593 </span><span class="lineNoCov">          0 : class collectAllVarRefs: public AstSimpleProcessing {</span></a>
<a name="594"><span class="lineNum">     594 </span>            :         public:</a>
<a name="595"><span class="lineNum">     595 </span>            :         //set&lt;SgVarRefExp*&gt; refs;</a>
<a name="596"><span class="lineNum">     596 </span>            :         set&lt;SgExpression*&gt; refs;</a>
<a name="597"><span class="lineNum">     597 </span><span class="lineNoCov">          0 :         void visit(SgNode* n) {</span></a>
<a name="598"><span class="lineNum">     598 </span><span class="lineNoCov">          0 :                 if(isSgExpression(n)) refs.insert(isSgExpression(n));</span></a>
<a name="599"><span class="lineNum">     599 </span><span class="lineNoCov">          0 :         }</span></a>
<a name="600"><span class="lineNum">     600 </span>            : };</a>
<a name="601"><span class="lineNum">     601 </span>            : </a>
<a name="602"><span class="lineNum">     602 </span>            : // creates a new VarsExprsProductLattice</a>
<a name="603"><span class="lineNum">     603 </span>            : // perVarLattice - sample lattice that will be associated with every variable in scope at node n</a>
<a name="604"><span class="lineNum">     604 </span>            : //     it should be assumed that the object pointed to by perVarLattice will be either</a>
<a name="605"><span class="lineNum">     605 </span>            : //     used internally by this VarsExprsProductLatticeobject or deallocated</a>
<a name="606"><span class="lineNum">     606 </span>            : // constVarLattices - map of additional variables and their associated lattices, that will be </a>
<a name="607"><span class="lineNum">     607 </span>            : //     incorporated into this VarsExprsProductLatticein addition to any other lattices for </a>
<a name="608"><span class="lineNum">     608 </span>            : //     currently live variables (these correspond to various useful constant variables like zeroVar)</a>
<a name="609"><span class="lineNum">     609 </span>            : // allVarLattice - the lattice associated with allVar (the variable that represents all of memory)</a>
<a name="610"><span class="lineNum">     610 </span>            : //     if allVarLattice==NULL, no support is provided for allVar</a>
<a name="611"><span class="lineNum">     611 </span>            : // ldva - liveness analysis result. This can be set to NULL. Or only live variables at a CFG node will be used to initialize the product lattice</a>
<a name="612"><span class="lineNum">     612 </span>            : // n - the dataflow node that this lattice will be associated with</a>
<a name="613"><span class="lineNum">     613 </span>            : // state - the NodeState at this dataflow node</a>
<a name="614"><span class="lineNum">     614 </span><span class="lineNoCov">          0 : VarsExprsProductLattice::VarsExprsProductLattice</span></a>
<a name="615"><span class="lineNum">     615 </span>            :                        (Lattice* perVarLattice, </a>
<a name="616"><span class="lineNum">     616 </span>            :                         const map&lt;varID, Lattice*&gt;&amp; constVarLattices, </a>
<a name="617"><span class="lineNum">     617 </span>            :                         Lattice* allVarLattice,</a>
<a name="618"><span class="lineNum">     618 </span>            :                         LiveDeadVarsAnalysis* ldva, </a>
<a name="619"><span class="lineNum">     619 </span>            :                         const DataflowNode&amp; n, </a>
<a name="620"><span class="lineNum">     620 </span><span class="lineNoCov">          0 :                         const NodeState&amp; state) : </span></a>
<a name="621"><span class="lineNum">     621 </span><span class="lineNoCov">          0 :                               perVarLattice(perVarLattice), allVarLattice(allVarLattice), constVarLattices(constVarLattices), ldva(ldva), n(n), state(state)</span></a>
<a name="622"><span class="lineNum">     622 </span>            : {</a>
<a name="623"><span class="lineNum">     623 </span>            :         // If a LiveDeadVarsAnalysis was provided, create a lattice only for each live object</a>
<a name="624"><span class="lineNum">     624 </span><span class="lineNoCov">          0 :         if(ldva) { </span></a>
<a name="625"><span class="lineNum">     625 </span>            :                 // Initialize varLatticeIndex with instances of perVarLattice for each variable that is live at n</a>
<a name="626"><span class="lineNum">     626 </span><span class="lineNoCov">          0 :                 varIDSet liveVars = getAllLiveVarsAt(ldva, state, &quot;    &quot;);</span></a>
<a name="627"><span class="lineNum">     627 </span><span class="lineNoCov">          0 :                 int idx=0;</span></a>
<a name="628"><span class="lineNum">     628 </span><span class="lineNoCov">          0 :                 for(varIDSet::iterator var=liveVars.begin(); var!=liveVars.end(); var++, idx++) {</span></a>
<a name="629"><span class="lineNum">     629 </span><span class="lineNoCov">          0 :                         varLatticeIndex[*var] = idx;</span></a>
<a name="630"><span class="lineNum">     630 </span><span class="lineNoCov">          0 :                         lattices.push_back(perVarLattice-&gt;copy());</span></a>
<a name="631"><span class="lineNum">     631 </span>            :                 }</a>
<a name="632"><span class="lineNum">     632 </span>            :         } else {</a>
<a name="633"><span class="lineNum">     633 </span>            :                 //Dbg::dbg &lt;&lt; &quot;n=&lt;&quot;&lt;&lt;Dbg::escape(n.getNode()-&gt;unparseToString()) &lt;&lt; &quot; | &quot; &lt;&lt; n.getNode()-&gt;class_name()&lt;&lt;&quot; | &quot;&lt;&lt;n.getIndex()&lt;&lt;&quot;&gt;&quot;&lt;&lt;endl;</a>
<a name="634"><span class="lineNum">     634 </span>            :                 /*Dbg::dbg &lt;&lt; &quot;n-&gt;get_parent()=&lt;&quot;&lt;&lt;Dbg::escape(n.getNode()-&gt;get_parent()-&gt;unparseToString()) &lt;&lt; &quot; | &quot; &lt;&lt; n.getNode()-&gt;get_parent()-&gt;class_name()&lt;&lt;&quot;&gt;&quot;&lt;&lt;endl;*/</a>
<a name="635"><span class="lineNum">     635 </span>            :                 </a>
<a name="636"><span class="lineNum">     636 </span>            :                 // Get all the variables that were accessed in the function that contains the given DataflowNode</a>
<a name="637"><span class="lineNum">     637 </span><span class="lineNoCov">          0 :                 set&lt;SgInitializedName *&gt; readVars, writeVars;</span></a>
<a name="638"><span class="lineNum">     638 </span><span class="lineNoCov">          0 :                 SgNode* cur = n.getNode();</span></a>
<a name="639"><span class="lineNum">     639 </span><span class="lineNoCov">          0 :                 while(cur &amp;&amp; !isSgFunctionDefinition(cur)) </span></a>
<a name="640"><span class="lineNum">     640 </span>            :                 { /*Dbg::dbg &lt;&lt; &quot;    cur=&lt;&quot;&lt;&lt;Dbg::escape(cur-&gt;unparseToString()) &lt;&lt; &quot; | &quot; &lt;&lt; cur-&gt;class_name()&lt;&lt;&quot;&gt;&quot;&lt;&lt;endl;*/</a>
<a name="641"><span class="lineNum">     641 </span><span class="lineNoCov">          0 :                  cur = cur-&gt;get_parent(); </span></a>
<a name="642"><span class="lineNum">     642 </span>            :                 }</a>
<a name="643"><span class="lineNum">     643 </span>            :                 /*SgFunctionDefinition *func;</a>
<a name="644"><span class="lineNum">     644 </span>            :                      if(isSgFunctionDefinition(n.getNode()))    func = isSgFunctionDefinition(n.getNode());</a>
<a name="645"><span class="lineNum">     645 </span>            :                 else if(isSgFunctionParameterList(n.getNode())) func = isSgFunctionDefinition(isSgFunctionDeclaration(n.getNode()-&gt;get_parent())-&gt;get_definition());</a>
<a name="646"><span class="lineNum">     646 </span>            :                 else                                            func = SageInterface::getEnclosingFunctionDefinition(n.getNode(), false);*/</a>
<a name="647"><span class="lineNum">     647 </span><span class="lineNoCov">          0 :                 SgFunctionDefinition *func = isSgFunctionDefinition(cur);</span></a>
<a name="648"><span class="lineNum">     648 </span>            :                 </a>
<a name="649"><span class="lineNum">     649 </span><span class="lineNoCov">          0 :                 if(func) {</span></a>
<a name="650"><span class="lineNum">     650 </span>            :                         //Dbg::dbg &lt;&lt;&quot;    func name=&quot;&lt;&lt;func-&gt;get_mangled_name().getString()&lt;&lt;endl;</a>
<a name="651"><span class="lineNum">     651 </span>            :                         //Rose_STL_Container&lt;SgVarRefExp*&gt; refs = NodeQuery::queryNodeList(((SgNode*)(func-&gt;get_body()), V_SgVarRefExp);</a>
<a name="652"><span class="lineNum">     652 </span><span class="lineNoCov">          0 :                         collectAllVarRefs collect;</span></a>
<a name="653"><span class="lineNum">     653 </span><span class="lineNoCov">          0 :                         collect.traverse(func, preorder);</span></a>
<a name="654"><span class="lineNum">     654 </span><span class="lineNoCov">          0 :                         for(set&lt;SgExpression*&gt;::iterator ref=collect.refs.begin(); ref!=collect.refs.end(); ref++) {</span></a>
<a name="655"><span class="lineNum">     655 </span>            :                                 //Dbg::dbg &lt;&lt; &quot;        ref=&quot;&lt;&lt;Dbg::escape((*ref)-&gt;unparseToString()) &lt;&lt; &quot; | &quot; &lt;&lt; (*ref)-&gt;class_name()&lt;&lt;&quot;&gt;&quot;&lt;&lt;endl;</a>
<a name="656"><span class="lineNum">     656 </span>            :                                 // Liao 7/1/2012. skip temp expression which is a descendant of the current node</a>
<a name="657"><span class="lineNum">     657 </span>            :                                 // we only need to preserve them in their current scope, not beyond</a>
<a name="658"><span class="lineNum">     658 </span>            :                                 //if (SageInterface::isAncestor(n.getNode(), *ref))</a>
<a name="659"><span class="lineNum">     659 </span>            :                                 //  continue;</a>
<a name="660"><span class="lineNum">     660 </span><span class="lineNoCov">          0 :                                 varID var = SgExpr2Var(*ref);</span></a>
<a name="661"><span class="lineNum">     661 </span><span class="lineNoCov">          0 :                                 if(varLatticeIndex.find(var) == varLatticeIndex.end()) {</span></a>
<a name="662"><span class="lineNum">     662 </span><span class="lineNoCov">          0 :                                         varLatticeIndex[var] = lattices.size();</span></a>
<a name="663"><span class="lineNum">     663 </span><span class="lineNoCov">          0 :                                         lattices.push_back(perVarLattice-&gt;copy());</span></a>
<a name="664"><span class="lineNum">     664 </span>            :                                 }</a>
<a name="665"><span class="lineNum">     665 </span>            :                         }</a>
<a name="666"><span class="lineNum">     666 </span>            :                         /*SageInterface::collectReadWriteVariables(func-&gt;get_body(), readVars, writeVars);</a>
<a name="667"><span class="lineNum">     667 </span>            :         </a>
<a name="668"><span class="lineNum">     668 </span>            :                         // Add these </a>
<a name="669"><span class="lineNum">     669 </span>            :                         int idx=0;</a>
<a name="670"><span class="lineNum">     670 </span>            :                         for(set&lt;SgInitializedName *&gt;::iterator name=readVars.begin(); name!=readVars.end(); name++, idx++) {</a>
<a name="671"><span class="lineNum">     671 </span>            :                                 varID var(*name);</a>
<a name="672"><span class="lineNum">     672 </span>            :                                 Dbg::dbg &lt;&lt; &quot;    &quot;&lt;&lt;var&lt;&lt;endl;</a>
<a name="673"><span class="lineNum">     673 </span>            :                                 if(varLatticeIndex.find(var) == varLatticeIndex.end()) {</a>
<a name="674"><span class="lineNum">     674 </span>            :                                         varLatticeIndex[var] = idx;</a>
<a name="675"><span class="lineNum">     675 </span>            :                                         lattices.push_back(perVarLattice-&gt;copy());</a>
<a name="676"><span class="lineNum">     676 </span>            :                                 }</a>
<a name="677"><span class="lineNum">     677 </span>            :                         }</a>
<a name="678"><span class="lineNum">     678 </span>            :                         for(set&lt;SgInitializedName *&gt;::iterator name=writeVars.begin(); name!=writeVars.end(); name++, idx++) {</a>
<a name="679"><span class="lineNum">     679 </span>            :                                 varID var(*name);</a>
<a name="680"><span class="lineNum">     680 </span>            :                                 Dbg::dbg &lt;&lt; &quot;    &quot;&lt;&lt;var&lt;&lt;endl;</a>
<a name="681"><span class="lineNum">     681 </span>            :                                 if(varLatticeIndex.find(var) == varLatticeIndex.end()) {</a>
<a name="682"><span class="lineNum">     682 </span>            :                                         varLatticeIndex[var] = idx;</a>
<a name="683"><span class="lineNum">     683 </span>            :                                         lattices.push_back(perVarLattice-&gt;copy());</a>
<a name="684"><span class="lineNum">     684 </span>            :                                 }</a>
<a name="685"><span class="lineNum">     685 </span>            :                         }*/</a>
<a name="686"><span class="lineNum">     686 </span>            :                         //collectUseByAddressVariableRefs (const SgStatement *s, std::set&lt; SgVarRefExp * &gt; &amp;varSetB)</a>
<a name="687"><span class="lineNum">     687 </span>            :                 }</a>
<a name="688"><span class="lineNum">     688 </span>            :         }       </a>
<a name="689"><span class="lineNum">     689 </span><span class="lineNoCov">          0 : }</span></a>
<a name="690"><span class="lineNum">     690 </span>            : </a>
<a name="691"><span class="lineNum">     691 </span>            : // Create a copy of that. It is assumed that the types of all the lattices in  VarsExprsProductLattice that are</a>
<a name="692"><span class="lineNum">     692 </span>            : // the same as in this.</a>
<a name="693"><span class="lineNum">     693 </span><span class="lineNoCov">          0 : VarsExprsProductLattice::VarsExprsProductLattice(const VarsExprsProductLattice&amp; that) : n(that.n), state(that.state)</span></a>
<a name="694"><span class="lineNum">     694 </span>            : {</a>
<a name="695"><span class="lineNum">     695 </span>            :         //Dbg::dbg &lt;&lt; &quot;    VarsExprsProductLattice::VarsExprsProductLattice(const VarsExprsProductLattice&amp; that)&quot;&lt;&lt;endl;</a>
<a name="696"><span class="lineNum">     696 </span><span class="lineNoCov">          0 :         allVarLattice=NULL;</span></a>
<a name="697"><span class="lineNum">     697 </span><span class="lineNoCov">          0 :         perVarLattice = NULL;</span></a>
<a name="698"><span class="lineNum">     698 </span><span class="lineNoCov">          0 :         copy(&amp;that);</span></a>
<a name="699"><span class="lineNum">     699 </span><span class="lineNoCov">          0 : }</span></a>
<a name="700"><span class="lineNum">     700 </span>            : </a>
<a name="701"><span class="lineNum">     701 </span><span class="lineNoCov">          0 : VarsExprsProductLattice::~VarsExprsProductLattice()</span></a>
<a name="702"><span class="lineNum">     702 </span>            : {</a>
<a name="703"><span class="lineNum">     703 </span><span class="lineNoCov">          0 :         delete(allVarLattice);</span></a>
<a name="704"><span class="lineNum">     704 </span><span class="lineNoCov">          0 :         delete(perVarLattice);</span></a>
<a name="705"><span class="lineNum">     705 </span>            :         </a>
<a name="706"><span class="lineNum">     706 </span>            :         // The destructor for ProductLattice deallocates the Lattices in lattices</a>
<a name="707"><span class="lineNum">     707 </span><span class="lineNoCov">          0 : }</span></a>
<a name="708"><span class="lineNum">     708 </span>            : </a>
<a name="709"><span class="lineNum">     709 </span>            : // Returns the Lattice mapped to the given variable or NULL if nothing is mapped to it</a>
<a name="710"><span class="lineNum">     710 </span><span class="lineNoCov">          0 : Lattice* VarsExprsProductLattice::getVarLattice(const varID&amp; var)</span></a>
<a name="711"><span class="lineNum">     711 </span>            : {</a>
<a name="712"><span class="lineNum">     712 </span><span class="lineNoCov">          0 :         if(varLatticeIndex.find(var) != varLatticeIndex.end())</span></a>
<a name="713"><span class="lineNum">     713 </span><span class="lineNoCov">          0 :                 return lattices[varLatticeIndex[var]];</span></a>
<a name="714"><span class="lineNum">     714 </span>            :         else</a>
<a name="715"><span class="lineNum">     715 </span>            :                 return NULL;</a>
<a name="716"><span class="lineNum">     716 </span>            : }</a>
<a name="717"><span class="lineNum">     717 </span>            : </a>
<a name="718"><span class="lineNum">     718 </span>            : // Returns the set of all variables mapped by this VarsExprsProductLattice</a>
<a name="719"><span class="lineNum">     719 </span><span class="lineNoCov">          0 : set&lt;varID&gt; VarsExprsProductLattice::getAllVars()</span></a>
<a name="720"><span class="lineNum">     720 </span>            : {</a>
<a name="721"><span class="lineNum">     721 </span><span class="lineNoCov">          0 :         set&lt;varID&gt; vars;</span></a>
<a name="722"><span class="lineNum">     722 </span><span class="lineNoCov">          0 :         for(map&lt;varID, int&gt;::iterator v=varLatticeIndex.begin(); v!=varLatticeIndex.end(); v++)</span></a>
<a name="723"><span class="lineNum">     723 </span><span class="lineNoCov">          0 :                 vars.insert(v-&gt;first);</span></a>
<a name="724"><span class="lineNum">     724 </span><span class="lineNoCov">          0 :         return vars;</span></a>
<a name="725"><span class="lineNum">     725 </span>            : }</a>
<a name="726"><span class="lineNum">     726 </span>            : </a>
<a name="727"><span class="lineNum">     727 </span>            : // Returns the index of var among the variables associated with func</a>
<a name="728"><span class="lineNum">     728 </span>            : // or -1 otherwise</a>
<a name="729"><span class="lineNum">     729 </span><span class="lineNoCov">          0 : int VarsExprsProductLattice::getVarIndex(const varID&amp; var)</span></a>
<a name="730"><span class="lineNum">     730 </span>            : {</a>
<a name="731"><span class="lineNum">     731 </span><span class="lineNoCov">          0 :         if(varLatticeIndex.find(var) != varLatticeIndex.end()) return varLatticeIndex[var];</span></a>
<a name="732"><span class="lineNum">     732 </span>            :         </a>
<a name="733"><span class="lineNum">     733 </span>            :         return -1;</a>
<a name="734"><span class="lineNum">     734 </span>            : }</a>
<a name="735"><span class="lineNum">     735 </span>            : </a>
<a name="736"><span class="lineNum">     736 </span>            : // Overwrites the state of this Lattice with that of that Lattice</a>
<a name="737"><span class="lineNum">     737 </span><span class="lineNoCov">          0 : void VarsExprsProductLattice::copy(Lattice* that_arg)</span></a>
<a name="738"><span class="lineNum">     738 </span>            : {</a>
<a name="739"><span class="lineNum">     739 </span><span class="lineNoCov">          0 :         VarsExprsProductLattice* that = dynamic_cast&lt;VarsExprsProductLattice*&gt;(that_arg);</span></a>
<a name="740"><span class="lineNum">     740 </span><span class="lineNoCov">          0 :         ROSE_ASSERT(that);</span></a>
<a name="741"><span class="lineNum">     741 </span><span class="lineNoCov">          0 :         copy(that);</span></a>
<a name="742"><span class="lineNum">     742 </span><span class="lineNoCov">          0 : }</span></a>
<a name="743"><span class="lineNum">     743 </span>            : // Overwrites the state of this Lattice with that of that Lattice</a>
<a name="744"><span class="lineNum">     744 </span><span class="lineNoCov">          0 : void VarsExprsProductLattice::copy(const VarsExprsProductLattice* that)</span></a>
<a name="745"><span class="lineNum">     745 </span>            : {</a>
<a name="746"><span class="lineNum">     746 </span><span class="lineNoCov">          0 :         ROSE_ASSERT(that);</span></a>
<a name="747"><span class="lineNum">     747 </span><span class="lineNoCov">          0 :         level = that-&gt;level;</span></a>
<a name="748"><span class="lineNum">     748 </span><span class="lineNoCov">          0 :         ldva = that-&gt;ldva;</span></a>
<a name="749"><span class="lineNum">     749 </span>            :         </a>
<a name="750"><span class="lineNum">     750 </span>            :         //if(&amp;n != &amp;that-&gt;n) {</a>
<a name="751"><span class="lineNum">     751 </span>            :         //      Dbg::dbg &lt;&lt; &quot;VarsExprsProductLattice::copy() this=&quot;&lt;&lt;this&lt;&lt;&quot; that=&quot;&lt;&lt;that&lt;&lt;endl;</a>
<a name="752"><span class="lineNum">     752 </span>            :         //      Dbg::dbg &lt;&lt; &quot;    n=&quot;&lt;&lt;n.getNode()&lt;&lt;&quot; that-&gt;n=&quot;&lt;&lt;that-&gt;n.getNode()&lt;&lt;endl;</a>
<a name="753"><span class="lineNum">     753 </span>            :         //      Dbg::dbg &lt;&lt; &quot;    this-&gt;n=&quot;&lt;&lt;Dbg::escape(n.getNode()-&gt;unparseToString()) &lt;&lt; &quot; | &quot; &lt;&lt; n.getNode()-&gt;class_name()&lt;&lt;&quot; | &quot;&lt;&lt;n.getIndex()&lt;&lt;endl;</a>
<a name="754"><span class="lineNum">     754 </span>            :         //      Dbg::dbg &lt;&lt; &quot;    that-&gt;n=&quot;&lt;&lt;Dbg::escape(that-&gt;n.getNode()-&gt;unparseToString()) &lt;&lt; &quot; | &quot; &lt;&lt; that-&gt;n.getNode()-&gt;class_name()&lt;&lt;&quot; | &quot;&lt;&lt;that-&gt;n.getIndex()&lt;&lt;endl;</a>
<a name="755"><span class="lineNum">     755 </span>            :         //}</a>
<a name="756"><span class="lineNum">     756 </span>            :         //ROSE_ASSERT(n.getNode() == that-&gt;n.getNode() &amp;&amp; n.getIndex() == that-&gt;n.getIndex());// &amp;&amp; (&amp;state == &amp;that-&gt;state));</a>
<a name="757"><span class="lineNum">     757 </span>            : </a>
<a name="758"><span class="lineNum">     758 </span>            :         //Dbg::dbg &lt;&lt; &quot;VarsExprsProductLattice::copy() allVarLattice=&quot;&lt;&lt;allVarLattice&lt;&lt;&quot; that-&gt;allVarLattice=&quot;&lt;&lt;that-&gt;allVarLattice&lt;&lt;&quot; perVarLattice=&quot;&lt;&lt;perVarLattice&lt;&lt;&quot; that-&gt;perVarLattice=&quot;&lt;&lt;perVarLattice&lt;&lt;endl;</a>
<a name="759"><span class="lineNum">     759 </span><span class="lineNoCov">          0 :         if(that-&gt;allVarLattice) {</span></a>
<a name="760"><span class="lineNum">     760 </span><span class="lineNoCov">          0 :                 if(allVarLattice) allVarLattice-&gt;copy(that-&gt;allVarLattice);</span></a>
<a name="761"><span class="lineNum">     761 </span><span class="lineNoCov">          0 :                 else              allVarLattice = that-&gt;allVarLattice-&gt;copy();</span></a>
<a name="762"><span class="lineNum">     762 </span>            :         } else {</a>
<a name="763"><span class="lineNum">     763 </span><span class="lineNoCov">          0 :                 if(allVarLattice) {</span></a>
<a name="764"><span class="lineNum">     764 </span><span class="lineNoCov">          0 :                         delete allVarLattice;</span></a>
<a name="765"><span class="lineNum">     765 </span><span class="lineNoCov">          0 :                         allVarLattice = NULL;</span></a>
<a name="766"><span class="lineNum">     766 </span>            :                 }</a>
<a name="767"><span class="lineNum">     767 </span>            :         }</a>
<a name="768"><span class="lineNum">     768 </span>            :         </a>
<a name="769"><span class="lineNum">     769 </span><span class="lineNoCov">          0 :         if(that-&gt;perVarLattice) {</span></a>
<a name="770"><span class="lineNum">     770 </span><span class="lineNoCov">          0 :                 if(perVarLattice) perVarLattice-&gt;copy(that-&gt;perVarLattice);</span></a>
<a name="771"><span class="lineNum">     771 </span><span class="lineNoCov">          0 :                 else              perVarLattice = that-&gt;perVarLattice-&gt;copy();</span></a>
<a name="772"><span class="lineNum">     772 </span>            :         } else {</a>
<a name="773"><span class="lineNum">     773 </span><span class="lineNoCov">          0 :                 if(perVarLattice) {</span></a>
<a name="774"><span class="lineNum">     774 </span><span class="lineNoCov">          0 :                         delete perVarLattice;</span></a>
<a name="775"><span class="lineNum">     775 </span><span class="lineNoCov">          0 :                         perVarLattice = NULL;</span></a>
<a name="776"><span class="lineNum">     776 </span>            :                 }</a>
<a name="777"><span class="lineNum">     777 </span>            :         }</a>
<a name="778"><span class="lineNum">     778 </span>            :         //Dbg::dbg &lt;&lt; &quot;        that=&quot;&lt;&lt;((VarsExprsProductLattice*)that)-&gt;str(&quot;        &quot;)&lt;&lt;endl;</a>
<a name="779"><span class="lineNum">     779 </span>            :         </a>
<a name="780"><span class="lineNum">     780 </span>            :         // Remove all lattices in constVarLattices that don't appear in that-&gt;constVarLattices</a>
<a name="781"><span class="lineNum">     781 </span><span class="lineNoCov">          0 :         set&lt;varID&gt; varsToDelete;</span></a>
<a name="782"><span class="lineNum">     782 </span><span class="lineNoCov">          0 :         for(map&lt;varID, Lattice*&gt;::iterator var=constVarLattices.begin(); var!=constVarLattices.end(); var++) {</span></a>
<a name="783"><span class="lineNum">     783 </span><span class="lineNoCov">          0 :                 if(that-&gt;constVarLattices.find(var-&gt;first) == that-&gt;constVarLattices.end())</span></a>
<a name="784"><span class="lineNum">     784 </span><span class="lineNoCov">          0 :                         varsToDelete.insert(var-&gt;first);</span></a>
<a name="785"><span class="lineNum">     785 </span>            :         }</a>
<a name="786"><span class="lineNum">     786 </span><span class="lineNoCov">          0 :         for(set&lt;varID&gt;::iterator var=varsToDelete.begin(); var!=varsToDelete.end(); var++) {</span></a>
<a name="787"><span class="lineNum">     787 </span><span class="lineNoCov">          0 :                 delete constVarLattices[*var];</span></a>
<a name="788"><span class="lineNum">     788 </span><span class="lineNoCov">          0 :                 constVarLattices.erase(*var);</span></a>
<a name="789"><span class="lineNum">     789 </span>            :         }</a>
<a name="790"><span class="lineNum">     790 </span>            :         </a>
<a name="791"><span class="lineNum">     791 </span>            :         // Copy all lattices in that-&gt;constVarLattices to This</a>
<a name="792"><span class="lineNum">     792 </span><span class="lineNoCov">          0 :         for(map&lt;varID, Lattice*&gt;::const_iterator var=that-&gt;constVarLattices.begin(); var!=that-&gt;constVarLattices.end(); var++) {</span></a>
<a name="793"><span class="lineNum">     793 </span><span class="lineNoCov">          0 :                 if(constVarLattices[var-&gt;first]) constVarLattices[var-&gt;first]-&gt;copy(var-&gt;second);</span></a>
<a name="794"><span class="lineNum">     794 </span><span class="lineNoCov">          0 :                 else                             constVarLattices.insert(make_pair(var-&gt;first, var-&gt;second-&gt;copy()));</span></a>
<a name="795"><span class="lineNum">     795 </span>            :         }</a>
<a name="796"><span class="lineNum">     796 </span>            :         </a>
<a name="797"><span class="lineNum">     797 </span>            :         // Remove all lattices in lattices/varLatticeIndex that don't appear in that.lattices/that.varLatticeIndex</a>
<a name="798"><span class="lineNum">     798 </span><span class="lineNoCov">          0 :         varsToDelete.clear();</span></a>
<a name="799"><span class="lineNum">     799 </span><span class="lineNoCov">          0 :         for(map&lt;varID, int&gt;::const_iterator varIdx=that-&gt;varLatticeIndex.begin(); varIdx!=that-&gt;varLatticeIndex.end(); varIdx++) {</span></a>
<a name="800"><span class="lineNum">     800 </span><span class="lineNoCov">          0 :                 if(that-&gt;varLatticeIndex.find(varIdx-&gt;first) == that-&gt;varLatticeIndex.end())</span></a>
<a name="801"><span class="lineNum">     801 </span><span class="lineNoCov">          0 :                         varsToDelete.insert(varIdx-&gt;first);</span></a>
<a name="802"><span class="lineNum">     802 </span>            :         }</a>
<a name="803"><span class="lineNum">     803 </span><span class="lineNoCov">          0 :         for(set&lt;varID&gt;::iterator var=varsToDelete.begin(); var!=varsToDelete.end(); var++) {</span></a>
<a name="804"><span class="lineNum">     804 </span><span class="lineNoCov">          0 :                 delete constVarLattices[*var];</span></a>
<a name="805"><span class="lineNum">     805 </span><span class="lineNoCov">          0 :                 constVarLattices.erase(*var);</span></a>
<a name="806"><span class="lineNum">     806 </span>            :         }</a>
<a name="807"><span class="lineNum">     807 </span>            :         </a>
<a name="808"><span class="lineNum">     808 </span>            :         //Dbg::dbg &lt;&lt; &quot;VarsExprsProductLattice::copy() lattices.size()=&quot;&lt;&lt;lattices.size()&lt;&lt;&quot; varLatticeIndex.size()=&quot;&lt;&lt;varLatticeIndex.size()&lt;&lt;endl;</a>
<a name="809"><span class="lineNum">     809 </span>            :         //Dbg::dbg &lt;&lt;&quot;     varLatticeIndex=&quot;&lt;&lt;endl;</a>
<a name="810"><span class="lineNum">     810 </span>            :         //for(map&lt;varID, int&gt;::iterator varIdx=varLatticeIndex.begin(); varIdx!=varLatticeIndex.end(); varIdx++)</a>
<a name="811"><span class="lineNum">     811 </span>            :         //      Dbg::dbg &lt;&lt; &quot;        &quot;&lt;&lt;varIdx-&gt;first&lt;&lt;&quot;, &quot;&lt;&lt;varIdx-&gt;second&lt;&lt;&quot;: &quot;&lt;&lt;lattices[varIdx-&gt;second]&lt;&lt;endl;</a>
<a name="812"><span class="lineNum">     812 </span>            :         //Dbg::dbg &lt;&lt;&quot;     that-&gt;varLatticeIndex    lattices.size()=&quot;&lt;&lt;that-&gt;lattices.size()&lt;&lt;&quot; varLatticeIndex.size()=&quot;&lt;&lt;that-&gt;varLatticeIndex.size()&lt;&lt;endl;</a>
<a name="813"><span class="lineNum">     813 </span>            :         //for(map&lt;varID, int&gt;::const_iterator varIdx=that-&gt;varLatticeIndex.begin(); varIdx!=that-&gt;varLatticeIndex.end(); varIdx++) {</a>
<a name="814"><span class="lineNum">     814 </span>            :         //      Dbg::dbg &lt;&lt; &quot;        &quot;&lt;&lt;varIdx-&gt;first&lt;&lt;&quot;, &quot;&lt;&lt;varIdx-&gt;second&lt;&lt;&quot; : &quot;&lt;&lt;that-&gt;lattices[varIdx-&gt;second]&lt;&lt;endl;</a>
<a name="815"><span class="lineNum">     815 </span>            :         //}</a>
<a name="816"><span class="lineNum">     816 </span>            :                 </a>
<a name="817"><span class="lineNum">     817 </span>            :         // Copy all lattices in that-&gt;lattices/that-&gt;varLatticeIndex to This, placing the lattices in </a>
<a name="818"><span class="lineNum">     818 </span>            :         // This in the same order as they had in That</a>
<a name="819"><span class="lineNum">     819 </span><span class="lineNoCov">          0 :         vector&lt;Lattice*&gt; newLattices;</span></a>
<a name="820"><span class="lineNum">     820 </span><span class="lineNoCov">          0 :         newLattices.resize(that-&gt;lattices.size());</span></a>
<a name="821"><span class="lineNum">     821 </span><span class="lineNoCov">          0 :         for(map&lt;varID, int&gt;::const_iterator varIdx=that-&gt;varLatticeIndex.begin(); varIdx!=that-&gt;varLatticeIndex.end(); varIdx++) {</span></a>
<a name="822"><span class="lineNum">     822 </span><span class="lineNoCov">          0 :                 if(varLatticeIndex.find(varIdx-&gt;first) != varLatticeIndex.end()) {</span></a>
<a name="823"><span class="lineNum">     823 </span><span class="lineNoCov">          0 :                         ROSE_ASSERT(that-&gt;lattices[varIdx-&gt;second]);</span></a>
<a name="824"><span class="lineNum">     824 </span><span class="lineNoCov">          0 :                         ROSE_ASSERT(lattices[varLatticeIndex[varIdx-&gt;first]]);</span></a>
<a name="825"><span class="lineNum">     825 </span><span class="lineNoCov">          0 :                         lattices[varLatticeIndex[varIdx-&gt;first]]-&gt;copy(that-&gt;lattices[varIdx-&gt;second]);</span></a>
<a name="826"><span class="lineNum">     826 </span><span class="lineNoCov">          0 :                         newLattices[varIdx-&gt;second] = lattices[varLatticeIndex[varIdx-&gt;first]];</span></a>
<a name="827"><span class="lineNum">     827 </span>            :                 } else {</a>
<a name="828"><span class="lineNum">     828 </span><span class="lineNoCov">          0 :                         newLattices[varIdx-&gt;second] = that-&gt;lattices[varIdx-&gt;second]-&gt;copy();</span></a>
<a name="829"><span class="lineNum">     829 </span>            :                 }</a>
<a name="830"><span class="lineNum">     830 </span>            :         }</a>
<a name="831"><span class="lineNum">     831 </span><span class="lineNoCov">          0 :         varLatticeIndex = that-&gt;varLatticeIndex;</span></a>
<a name="832"><span class="lineNum">     832 </span><span class="lineNoCov">          0 :         lattices = newLattices;</span></a>
<a name="833"><span class="lineNum">     833 </span>            :         //Dbg::dbg &lt;&lt; &quot;VarsExprsProductLattice::copy() DONE&quot;&lt;&lt;endl;</a>
<a name="834"><span class="lineNum">     834 </span>            :         //Dbg::dbg &lt;&lt; &quot;    varLatticeIndex=&quot;&lt;&lt;endl;</a>
<a name="835"><span class="lineNum">     835 </span>            :         //for(map&lt;varID, int&gt;::iterator varIdx=varLatticeIndex.begin(); varIdx!=varLatticeIndex.end(); varIdx++)</a>
<a name="836"><span class="lineNum">     836 </span>            :         //      Dbg::dbg &lt;&lt; &quot;        &quot;&lt;&lt;varIdx-&gt;first&lt;&lt;&quot;, &quot;&lt;&lt;varIdx-&gt;second&lt;&lt;endl;</a>
<a name="837"><span class="lineNum">     837 </span>            :         //Dbg::dbg &lt;&lt; &quot;    lattices (#=&quot;&lt;&lt;lattices.size()&lt;&lt;&quot;=&quot;&lt;&lt;endl;</a>
<a name="838"><span class="lineNum">     838 </span>            :         //int i=0;</a>
<a name="839"><span class="lineNum">     839 </span>            :         //for(vector&lt;Lattice*&gt;::iterator lat=lattices.begin(); lat!=lattices.end(); lat++, i++)</a>
<a name="840"><span class="lineNum">     840 </span>            :         //      Dbg::dbg &lt;&lt; &quot;        &quot;&lt;&lt;i&lt;&lt;&quot;: &quot;&lt;&lt;*lat&lt;&lt;endl;</a>
<a name="841"><span class="lineNum">     841 </span>            :         //Dbg::dbg &lt;&lt; &quot;    &quot;&lt;&lt;str(&quot;        &quot;)&lt;&lt;endl;</a>
<a name="842"><span class="lineNum">     842 </span><span class="lineNoCov">          0 : }</span></a>
<a name="843"><span class="lineNum">     843 </span>            : </a>
<a name="844"><span class="lineNum">     844 </span><span class="lineNoCov">          0 : bool VarsExprsProductLattice::meetUpdate(Lattice *lThat)</span></a>
<a name="845"><span class="lineNum">     845 </span>            : {</a>
<a name="846"><span class="lineNum">     846 </span><span class="lineNoCov">          0 :   bool modified = false;</span></a>
<a name="847"><span class="lineNum">     847 </span><span class="lineNoCov">          0 :   VarsExprsProductLattice *that = dynamic_cast&lt;VarsExprsProductLattice *&gt;(lThat);</span></a>
<a name="848"><span class="lineNum">     848 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(that);</span></a>
<a name="849"><span class="lineNum">     849 </span>            : </a>
<a name="850"><span class="lineNum">     850 </span><span class="lineNoCov">          0 :   int newLevel = std::max(level, that-&gt;level);</span></a>
<a name="851"><span class="lineNum">     851 </span><span class="lineNoCov">          0 :   if (newLevel != level) {</span></a>
<a name="852"><span class="lineNum">     852 </span><span class="lineNoCov">          0 :     modified = true;</span></a>
<a name="853"><span class="lineNum">     853 </span><span class="lineNoCov">          0 :     level = newLevel;</span></a>
<a name="854"><span class="lineNum">     854 </span>            :   }</a>
<a name="855"><span class="lineNum">     855 </span>            : </a>
<a name="856"><span class="lineNum">     856 </span><span class="lineNoCov">          0 :   for (map&lt;varID, int&gt;::iterator i_that = that-&gt;varLatticeIndex.begin(); i_that != that-&gt;varLatticeIndex.end(); ++i_that) {</span></a>
<a name="857"><span class="lineNum">     857 </span><span class="lineNoCov">          0 :     map&lt;varID, int&gt;::iterator i_this = varLatticeIndex.find(i_that-&gt;first);</span></a>
<a name="858"><span class="lineNum">     858 </span><span class="lineNoCov">          0 :     if (varLatticeIndex.end() == i_this) {</span></a>
<a name="859"><span class="lineNum">     859 </span><span class="lineNoCov">          0 :       Dbg::dbg &lt;&lt; &quot;VarsExprsProductLattice::meetUpdate is missing variable w/ ID&quot; &lt;&lt; i_that-&gt;first &lt;&lt; endl;</span></a>
<a name="860"><span class="lineNum">     860 </span><span class="lineNoCov">          0 :       continue; // XXX: Perhaps this should be an assertion failure? Must *this contain at least the elements of *that?</span></a>
<a name="861"><span class="lineNum">     861 </span>            :     }</a>
<a name="862"><span class="lineNum">     862 </span>            : </a>
<a name="863"><span class="lineNum">     863 </span><span class="lineNoCov">          0 :     modified = lattices[i_this-&gt;second]-&gt;meetUpdate(that-&gt;lattices[i_that-&gt;second]) || modified;</span></a>
<a name="864"><span class="lineNum">     864 </span>            :   }</a>
<a name="865"><span class="lineNum">     865 </span>            : </a>
<a name="866"><span class="lineNum">     866 </span><span class="lineNoCov">          0 :   return modified;</span></a>
<a name="867"><span class="lineNum">     867 </span>            : }</a>
<a name="868"><span class="lineNum">     868 </span>            : </a>
<a name="869"><span class="lineNum">     869 </span>            : // Called by analyses to create a copy of this lattice. However, if this lattice maintains any </a>
<a name="870"><span class="lineNum">     870 </span>            : //    information on a per-variable basis, these per-variable mappings must be converted from </a>
<a name="871"><span class="lineNum">     871 </span>            : //    the current set of variables to another set. This may be needed during function calls, </a>
<a name="872"><span class="lineNum">     872 </span>            : //    when dataflow information from the caller/callee needs to be transferred to the callee/calleer.</a>
<a name="873"><span class="lineNum">     873 </span>            : // varNameMap - maps all variable names that have changed, in each mapping pair, pair-&gt;first is the </a>
<a name="874"><span class="lineNum">     874 </span>            : //              old variable and pair-&gt;second is the new variable</a>
<a name="875"><span class="lineNum">     875 </span>            : // func - the function that the copy Lattice will now be associated with</a>
<a name="876"><span class="lineNum">     876 </span><span class="lineNoCov">          0 : void VarsExprsProductLattice::remapVars(const map&lt;varID, varID&gt;&amp; varNameMap, const Function&amp; newFunc)</span></a>
<a name="877"><span class="lineNum">     877 </span>            : {</a>
<a name="878"><span class="lineNum">     878 </span>            : //      Dbg::dbg &lt;&lt; &quot;remapVars(&quot;&lt;&lt;newFunc.get_name().getString()&lt;&lt;&quot;()), func=&quot;&lt;&lt;func.get_name().getString&lt;&lt;endl;</a>
<a name="879"><span class="lineNum">     879 </span>            :         </a>
<a name="880"><span class="lineNum">     880 </span>            :         // The lattices associated with the variables at the top of new Func and the corresponding mapping </a>
<a name="881"><span class="lineNum">     881 </span>            :         // of variables to indexes in newLattices. The original lattices and varLatticeIndex will be replaced</a>
<a name="882"><span class="lineNum">     882 </span>            :         // with these objects.</a>
<a name="883"><span class="lineNum">     883 </span><span class="lineNoCov">          0 :         vector&lt;Lattice*&gt; newLattices;</span></a>
<a name="884"><span class="lineNum">     884 </span><span class="lineNoCov">          0 :         map&lt;varID, int&gt; newVarLatticeIndex;</span></a>
<a name="885"><span class="lineNum">     885 </span>            :         </a>
<a name="886"><span class="lineNum">     886 </span>            :         // Fill newLattices with lattices associated with variables in the new function </a>
<a name="887"><span class="lineNum">     887 </span><span class="lineNoCov">          0 :         ROSE_ASSERT(newFunc.get_definition() != NULL);    </span></a>
<a name="888"><span class="lineNum">     888 </span><span class="lineNoCov">          0 :         DataflowNode funcCFGStart = cfgUtils::getFuncStartCFG(newFunc.get_definition(),filter); //TODO This function is never being used somehow</span></a>
<a name="889"><span class="lineNum">     889 </span>            : </a>
<a name="890"><span class="lineNum">     890 </span>            :         //Akshatha(08/12): To handle cases which do not require LiveDeadVars Analysis        </a>
<a name="891"><span class="lineNum">     891 </span><span class="lineNoCov">          0 :         varIDSet newRefVars;</span></a>
<a name="892"><span class="lineNum">     892 </span><span class="lineNoCov">          0 :         if(ldva)</span></a>
<a name="893"><span class="lineNum">     893 </span><span class="lineNoCov">          0 :             newRefVars = getAllLiveVarsAt(ldva, *NodeState::getNodeState(funcCFGStart, 0), &quot;    &quot;);</span></a>
<a name="894"><span class="lineNum">     894 </span>            :         else</a>
<a name="895"><span class="lineNum">     895 </span>            :         {</a>
<a name="896"><span class="lineNum">     896 </span>            : </a>
<a name="897"><span class="lineNum">     897 </span>            :             //Obtain the SgNode for newFunc, traverse up to get its FunctionDefinition, and finally populate the newRefVars vector with varID's of all the variables present in this function</a>
<a name="898"><span class="lineNum">     898 </span>            :             </a>
<a name="899"><span class="lineNum">     899 </span><span class="lineNoCov">          0 :             SgNode* cur = newFunc.get_definition();</span></a>
<a name="900"><span class="lineNum">     900 </span>            :             //SgNode* cur = n.getNode();</a>
<a name="901"><span class="lineNum">     901 </span>            :         </a>
<a name="902"><span class="lineNum">     902 </span><span class="lineNoCov">          0 :             ROSE_ASSERT(cur != NULL);    </span></a>
<a name="903"><span class="lineNum">     903 </span><span class="lineNoCov">          0 :             while(cur &amp;&amp; !isSgFunctionDefinition(cur))</span></a>
<a name="904"><span class="lineNum">     904 </span>            :             { /*Dbg::dbg &lt;&lt; &quot;    cur=&lt;&quot;&lt;&lt;Dbg::escape(cur-&gt;unparseToString()) &lt;&lt; &quot; | &quot; &lt;&lt; cur-&gt;class_name()&lt;&lt;&quot;&gt;&quot;&lt;&lt;endl;*/</a>
<a name="905"><span class="lineNum">     905 </span><span class="lineNoCov">          0 :                  cur = cur-&gt;get_parent();</span></a>
<a name="906"><span class="lineNum">     906 </span>            :             }</a>
<a name="907"><span class="lineNum">     907 </span>            : </a>
<a name="908"><span class="lineNum">     908 </span><span class="lineNoCov">          0 :             ROSE_ASSERT(cur != NULL);</span></a>
<a name="909"><span class="lineNum">     909 </span><span class="lineNoCov">          0 :             SgFunctionDefinition *func = isSgFunctionDefinition(cur);</span></a>
<a name="910"><span class="lineNum">     910 </span><span class="lineNoCov">          0 :             if(func){</span></a>
<a name="911"><span class="lineNum">     911 </span><span class="lineNoCov">          0 :                 collectAllVarRefs collect;</span></a>
<a name="912"><span class="lineNum">     912 </span><span class="lineNoCov">          0 :                 collect.traverse(func,preorder);</span></a>
<a name="913"><span class="lineNum">     913 </span><span class="lineNoCov">          0 :                 for(set&lt;SgExpression*&gt;::iterator ref = collect.refs.begin(); ref!=collect.refs.end();ref++){</span></a>
<a name="914"><span class="lineNum">     914 </span><span class="lineNoCov">          0 :                     varID var = SgExpr2Var(*ref);</span></a>
<a name="915"><span class="lineNum">     915 </span><span class="lineNoCov">          0 :                     newRefVars.insert(var);</span></a>
<a name="916"><span class="lineNum">     916 </span>            :                 }</a>
<a name="917"><span class="lineNum">     917 </span>            :             }</a>
<a name="918"><span class="lineNum">     918 </span>            :         }</a>
<a name="919"><span class="lineNum">     919 </span>            :         //Akshatha(08/12): End of Code changes</a>
<a name="920"><span class="lineNum">     920 </span>            : </a>
<a name="921"><span class="lineNum">     921 </span>            :         // Iterate through all the variables that are live at the top of newFunc and for each one </a>
<a name="922"><span class="lineNum">     922 </span><span class="lineNoCov">          0 :         int idx=0;</span></a>
<a name="923"><span class="lineNum">     923 </span><span class="lineNoCov">          0 :         for(varIDSet::iterator it = newRefVars.begin(); it!=newRefVars.end(); it++ /*, idx++*/)</span></a>
<a name="924"><span class="lineNum">     924 </span>            :         {</a>
<a name="925"><span class="lineNum">     925 </span><span class="lineNoCov">          0 :                 varID newVar = *it;</span></a>
<a name="926"><span class="lineNum">     926 </span>            : //              printf(&quot;remapVars() newVar = %s\n&quot;, newVar.str().c_str());</a>
<a name="927"><span class="lineNum">     927 </span><span class="lineNoCov">          0 :                 bool found = false;</span></a>
<a name="928"><span class="lineNum">     928 </span>            :                 </a>
<a name="929"><span class="lineNum">     929 </span>            :                 // If this variable is a copy of some variable currently in lattices, transfer this lattice over to newLattices</a>
<a name="930"><span class="lineNum">     930 </span><span class="lineNoCov">          0 :                 for(map&lt;varID, varID&gt;::const_iterator itR = varNameMap.begin(); itR != varNameMap.end(); itR++)</span></a>
<a name="931"><span class="lineNum">     931 </span>            :                 {</a>
<a name="932"><span class="lineNum">     932 </span>            : //                      printf(&quot;remapVars() varNameMap[%s] = %s, newVar=%s, match=%d\n&quot;, itR-&gt;first.str().c_str(), itR-&gt;second.str().c_str(), newVar.str().c_str(), itR-&gt;second == newVar);</a>
<a name="933"><span class="lineNum">     933 </span>            :                         // If this mapping corresponds to newVar</a>
<a name="934"><span class="lineNum">     934 </span><span class="lineNoCov">          0 :                         if(itR-&gt;second == newVar) {</span></a>
<a name="935"><span class="lineNum">     935 </span>            :                                 // The original variable that got mapped to newVar</a>
<a name="936"><span class="lineNum">     936 </span><span class="lineNoCov">          0 :                                 varID oldVar = itR-&gt;first;</span></a>
<a name="937"><span class="lineNum">     937 </span>            :                                 </a>
<a name="938"><span class="lineNum">     938 </span><span class="lineNoCov">          0 :                                 Lattice* l = getVarLattice(oldVar);</span></a>
<a name="939"><span class="lineNum">     939 </span><span class="lineNoCov">          0 :                                 ROSE_ASSERT(l);</span></a>
<a name="940"><span class="lineNum">     940 </span><span class="lineNoCov">          0 :                                 newLattices.push_back(l);</span></a>
<a name="941"><span class="lineNum">     941 </span><span class="lineNoCov">          0 :                                 newVarLatticeIndex[newVar] = idx;</span></a>
<a name="942"><span class="lineNum">     942 </span><span class="lineNoCov">          0 :                                 idx++;</span></a>
<a name="943"><span class="lineNum">     943 </span>            :                                 </a>
<a name="944"><span class="lineNum">     944 </span>            :                                 // Erase the mapping of oldVar in varLatticeIndex</a>
<a name="945"><span class="lineNum">     945 </span><span class="lineNoCov">          0 :                                 varLatticeIndex.erase(oldVar);</span></a>
<a name="946"><span class="lineNum">     946 </span>            :                                 </a>
<a name="947"><span class="lineNum">     947 </span><span class="lineNoCov">          0 :                                 found = true;</span></a>
<a name="948"><span class="lineNum">     948 </span>            :                         }</a>
<a name="949"><span class="lineNum">     949 </span>            :                 }</a>
<a name="950"><span class="lineNum">     950 </span>            :                 </a>
<a name="951"><span class="lineNum">     951 </span>            :                 // If this new variable is not a remapped old variable</a>
<a name="952"><span class="lineNum">     952 </span><span class="lineNoCov">          0 :                 if(!found)</span></a>
<a name="953"><span class="lineNum">     953 </span>            :                 {</a>
<a name="954"><span class="lineNum">     954 </span>            :                         // Check if this new variable is in fact an old variable </a>
<a name="955"><span class="lineNum">     955 </span><span class="lineNoCov">          0 :                         Lattice* l = getVarLattice(newVar);</span></a>
<a name="956"><span class="lineNum">     956 </span>            :                         </a>
<a name="957"><span class="lineNum">     957 </span>            :                         //Dbg::dbg &lt;&lt; &quot;      getVarIndex(newFunc, newVar)=&quot; &lt;&lt; getVarIndex(newFunc, newVar) &lt;&lt; endl;</a>
<a name="958"><span class="lineNum">     958 </span>            :                         // If it is, add it at its new index</a>
<a name="959"><span class="lineNum">     959 </span><span class="lineNoCov">          0 :                         if(l) {</span></a>
<a name="960"><span class="lineNum">     960 </span>            :                                 //Dbg::dbg &lt;&lt; &quot;VarsExprsProductLattice::remapVars() l = [&quot;&lt;&lt;newVar&lt;&lt;&quot;] &quot;&lt;&lt; l-&gt;str(&quot;&quot;) &lt;&lt; endl;</a>
<a name="961"><span class="lineNum">     961 </span>            :                                 //newLattices[getVarIndex(newFunc, newVar)] = l;</a>
<a name="962"><span class="lineNum">     962 </span><span class="lineNoCov">          0 :                                 newLattices.push_back(l);</span></a>
<a name="963"><span class="lineNum">     963 </span>            :                                 // Erase the original mapping of newVar in varLatticeIndex</a>
<a name="964"><span class="lineNum">     964 </span><span class="lineNoCov">          0 :                                 newVarLatticeIndex[newVar] = idx;</span></a>
<a name="965"><span class="lineNum">     965 </span><span class="lineNoCov">          0 :                                 idx++;</span></a>
<a name="966"><span class="lineNum">     966 </span>            :                </a>
<a name="967"><span class="lineNum">     967 </span><span class="lineNoCov">          0 :                                 varLatticeIndex.erase(newVar);</span></a>
<a name="968"><span class="lineNum">     968 </span>            :                         // If not, add a fresh lattice for this variable</a>
<a name="969"><span class="lineNum">     969 </span>            :                         } else</a>
<a name="970"><span class="lineNum">     970 </span>            :                           {</a>
<a name="971"><span class="lineNum">     971 </span><span class="lineNoCov">          0 :                             Dbg::dbg &lt;&lt; &quot;No Lattice found: [&quot;;</span></a>
<a name="972"><span class="lineNum">     972 </span>            :                             //Akshatha(08/12): We do not push a variable which is not in scope</a>
<a name="973"><span class="lineNum">     973 </span>            :                             //newLattices.push_back(perVarLattice-&gt;copy()); These changes were made to avoid pushing empty lattices for variables which were not in scope between caller and callee. This resulted in local variable lattices being wiped out while mapping variables from caller to callee and vice-versa.</a>
<a name="974"><span class="lineNum">     974 </span>            :                           }</a>
<a name="975"><span class="lineNum">     975 </span>            :                 }</a>
<a name="976"><span class="lineNum">     976 </span>            :                 </a>
<a name="977"><span class="lineNum">     977 </span>            :                 // Record that newVar is at index idx</a>
<a name="978"><span class="lineNum">     978 </span>            :                 //newVarLatticeIndex[newVar] = idx;</a>
<a name="979"><span class="lineNum">     979 </span>            :         }</a>
<a name="980"><span class="lineNum">     980 </span>            :         </a>
<a name="981"><span class="lineNum">     981 </span>            :         // Deallocate the lattices of all the variables that do not exist in newFunc are are not </a>
<a name="982"><span class="lineNum">     982 </span>            :         // remapped into its set of variables </a>
<a name="983"><span class="lineNum">     983 </span><span class="lineNoCov">          0 :         for(map&lt;varID, int&gt;::iterator varIdx=varLatticeIndex.begin(); varIdx!=varLatticeIndex.end(); varIdx++) {</span></a>
<a name="984"><span class="lineNum">     984 </span><span class="lineNoCov">          0 :                 ROSE_ASSERT(lattices[varIdx-&gt;second]);</span></a>
<a name="985"><span class="lineNum">     985 </span><span class="lineNoCov">          0 :                 delete lattices[varIdx-&gt;second];</span></a>
<a name="986"><span class="lineNum">     986 </span>            :         }</a>
<a name="987"><span class="lineNum">     987 </span>            :       </a>
<a name="988"><span class="lineNum">     988 </span><span class="lineNoCov">          0 :         Dbg::dbg&lt;&lt;&quot;Index :&quot;&lt;&lt;idx;</span></a>
<a name="989"><span class="lineNum">     989 </span><span class="lineNoCov">          0 :         ROSE_ASSERT(newLattices.size() == newVarLatticeIndex.size());</span></a>
<a name="990"><span class="lineNum">     990 </span>            :         // Replace newVPL information with the remapped information</a>
<a name="991"><span class="lineNum">     991 </span><span class="lineNoCov">          0 :         lattices        = newLattices;</span></a>
<a name="992"><span class="lineNum">     992 </span><span class="lineNoCov">          0 :         varLatticeIndex = newVarLatticeIndex;</span></a>
<a name="993"><span class="lineNum">     993 </span><span class="lineNoCov">          0 :         ROSE_ASSERT(lattices.size() == varLatticeIndex.size());</span></a>
<a name="994"><span class="lineNum">     994 </span><span class="lineNoCov">          0 : }</span></a>
<a name="995"><span class="lineNum">     995 </span>            : </a>
<a name="996"><span class="lineNum">     996 </span>            : // Called by analyses to copy over from the that Lattice dataflow information into this Lattice.</a>
<a name="997"><span class="lineNum">     997 </span>            : // that contains data for a set of variables and incorporateVars must overwrite the state of just</a>
<a name="998"><span class="lineNum">     998 </span>            : // those variables, while leaving its state for other variables alone.</a>
<a name="999"><span class="lineNum">     999 </span>            : // We do not force child classes to define their own versions of this function since not all</a>
<a name="1000"><span class="lineNum">    1000 </span>            : //    Lattices have per-variable information.</a>
<a name="1001"><span class="lineNum">    1001 </span><span class="lineNoCov">          0 : void VarsExprsProductLattice::incorporateVars(Lattice* that_arg)</span></a>
<a name="1002"><span class="lineNum">    1002 </span>            : {</a>
<a name="1003"><span class="lineNum">    1003 </span><span class="lineNoCov">          0 :         initialize();</span></a>
<a name="1004"><span class="lineNum">    1004 </span>            :         </a>
<a name="1005"><span class="lineNum">    1005 </span><span class="lineNoCov">          0 :         VarsExprsProductLattice* that = dynamic_cast&lt;VarsExprsProductLattice*&gt;(that_arg); ROSE_ASSERT(that);</span></a>
<a name="1006"><span class="lineNum">    1006 </span>            :         // Both lattices need to be talking about variables in the same function</a>
<a name="1007"><span class="lineNum">    1007 </span>            :         //ROSE_ASSERT(&amp;n == &amp;that-&gt;n);</a>
<a name="1008"><span class="lineNum">    1008 </span>            :         //ROSE_ASSERT(&amp;state == &amp;that-&gt;state);</a>
<a name="1009"><span class="lineNum">    1009 </span><span class="lineNoCov">          0 :         if(that-&gt;allVarLattice) { </span></a>
<a name="1010"><span class="lineNum">    1010 </span><span class="lineNoCov">          0 :                 ROSE_ASSERT(allVarLattice);</span></a>
<a name="1011"><span class="lineNum">    1011 </span><span class="lineNoCov">          0 :                 this-&gt;allVarLattice-&gt;copy(that-&gt;allVarLattice);</span></a>
<a name="1012"><span class="lineNum">    1012 </span>            :         }</a>
<a name="1013"><span class="lineNum">    1013 </span>            :         </a>
<a name="1014"><span class="lineNum">    1014 </span>            :         // Iterate through all the lattices of constant variables, copying any lattices in That to This</a>
<a name="1015"><span class="lineNum">    1015 </span><span class="lineNoCov">          0 :         for(map&lt;varID, Lattice*&gt;::iterator var=that-&gt;constVarLattices.begin(); var!=that-&gt;constVarLattices.end(); var++) {</span></a>
<a name="1016"><span class="lineNum">    1016 </span><span class="lineNoCov">          0 :                 if(constVarLattices.find(var-&gt;first) != constVarLattices.end()) {</span></a>
<a name="1017"><span class="lineNum">    1017 </span><span class="lineNoCov">          0 :                         ROSE_ASSERT(constVarLattices[var-&gt;first]);</span></a>
<a name="1018"><span class="lineNum">    1018 </span><span class="lineNoCov">          0 :                         constVarLattices[var-&gt;first]-&gt;copy(var-&gt;second);</span></a>
<a name="1019"><span class="lineNum">    1019 </span>            :                 } else {</a>
<a name="1020"><span class="lineNum">    1020 </span><span class="lineNoCov">          0 :                         ROSE_ASSERT(var-&gt;second);</span></a>
<a name="1021"><span class="lineNum">    1021 </span><span class="lineNoCov">          0 :                         constVarLattices.insert(make_pair(var-&gt;first, var-&gt;second-&gt;copy()));</span></a>
<a name="1022"><span class="lineNum">    1022 </span>            :                 }</a>
<a name="1023"><span class="lineNum">    1023 </span>            :         }</a>
<a name="1024"><span class="lineNum">    1024 </span>            :         </a>
<a name="1025"><span class="lineNum">    1025 </span>            :         // Iterate through all the variables mapped by this lattice, copying any lattices in That to This</a>
<a name="1026"><span class="lineNum">    1026 </span><span class="lineNoCov">          0 :         for(map&lt;varID, int&gt;::iterator var = that-&gt;varLatticeIndex.begin(); var != that-&gt;varLatticeIndex.end(); var++)</span></a>
<a name="1027"><span class="lineNum">    1027 </span>            :         {</a>
<a name="1028"><span class="lineNum">    1028 </span><span class="lineNoCov">          0 :                 if(varLatticeIndex.find(var-&gt;first) != varLatticeIndex.end()) {</span></a>
<a name="1029"><span class="lineNum">    1029 </span><span class="lineNoCov">          0 :                         ROSE_ASSERT(lattices[varLatticeIndex[var-&gt;first]]);</span></a>
<a name="1030"><span class="lineNum">    1030 </span><span class="lineNoCov">          0 :                         lattices[varLatticeIndex[var-&gt;first]]-&gt;copy(that-&gt;lattices[var-&gt;second]);</span></a>
<a name="1031"><span class="lineNum">    1031 </span>            :                 } else {</a>
<a name="1032"><span class="lineNum">    1032 </span><span class="lineNoCov">          0 :                         varLatticeIndex[var-&gt;first] = lattices.size();</span></a>
<a name="1033"><span class="lineNum">    1033 </span><span class="lineNoCov">          0 :                         ROSE_ASSERT(that-&gt;lattices[var-&gt;second]);</span></a>
<a name="1034"><span class="lineNum">    1034 </span><span class="lineNoCov">          0 :                         lattices.push_back(that-&gt;lattices[var-&gt;second]-&gt;copy());</span></a>
<a name="1035"><span class="lineNum">    1035 </span>            :                 }</a>
<a name="1036"><span class="lineNum">    1036 </span>            :         }</a>
<a name="1037"><span class="lineNum">    1037 </span><span class="lineNoCov">          0 : }</span></a>
<a name="1038"><span class="lineNum">    1038 </span>            : </a>
<a name="1039"><span class="lineNum">    1039 </span>            : // Returns a Lattice that describes the information known within this lattice</a>
<a name="1040"><span class="lineNum">    1040 </span>            : // about the given expression. By default this could be the entire lattice or any portion of it.</a>
<a name="1041"><span class="lineNum">    1041 </span>            : // For example, a lattice that maintains lattices for different known variables and expression will </a>
<a name="1042"><span class="lineNum">    1042 </span>            : // return a lattice for the given expression. Similarly, a lattice that keeps track of constraints</a>
<a name="1043"><span class="lineNum">    1043 </span>            : // on values of variables and expressions will return the portion of the lattice that relates to</a>
<a name="1044"><span class="lineNum">    1044 </span>            : // the given expression. </a>
<a name="1045"><span class="lineNum">    1045 </span>            : // It it legal for this function to return NULL if no information is available.</a>
<a name="1046"><span class="lineNum">    1046 </span>            : // The function's caller is responsible for deallocating the returned object</a>
<a name="1047"><span class="lineNum">    1047 </span><span class="lineNoCov">          0 : Lattice* VarsExprsProductLattice::project(SgExpression* expr) </span></a>
<a name="1048"><span class="lineNum">    1048 </span>            : {</a>
<a name="1049"><span class="lineNum">    1049 </span><span class="lineNoCov">          0 :         varID exprVar = SgExpr2Var(expr);</span></a>
<a name="1050"><span class="lineNum">    1050 </span><span class="lineNoCov">          0 :         VarsExprsProductLattice* exprState = blankVEPL(n, state);</span></a>
<a name="1051"><span class="lineNum">    1051 </span>            :         </a>
<a name="1052"><span class="lineNum">    1052 </span><span class="lineNoCov">          0 :         exprState-&gt;ldva = ldva;</span></a>
<a name="1053"><span class="lineNum">    1053 </span>            :         </a>
<a name="1054"><span class="lineNum">    1054 </span>            :         // Copy over all the default lattices</a>
<a name="1055"><span class="lineNum">    1055 </span><span class="lineNoCov">          0 :         if(perVarLattice) exprState-&gt;perVarLattice = perVarLattice-&gt;copy();</span></a>
<a name="1056"><span class="lineNum">    1056 </span><span class="lineNoCov">          0 :         else              exprState-&gt;perVarLattice = NULL;</span></a>
<a name="1057"><span class="lineNum">    1057 </span><span class="lineNoCov">          0 :         if(allVarLattice) exprState-&gt;allVarLattice = allVarLattice-&gt;copy();</span></a>
<a name="1058"><span class="lineNum">    1058 </span><span class="lineNoCov">          0 :         else              exprState-&gt;allVarLattice = NULL;</span></a>
<a name="1059"><span class="lineNum">    1059 </span>            :         </a>
<a name="1060"><span class="lineNum">    1060 </span><span class="lineNoCov">          0 :         for(map&lt;varID, Lattice*&gt;::iterator lat=constVarLattices.begin(); lat!=constVarLattices.end(); lat++) {</span></a>
<a name="1061"><span class="lineNum">    1061 </span><span class="lineNoCov">          0 :                 ROSE_ASSERT(lat-&gt;second);</span></a>
<a name="1062"><span class="lineNum">    1062 </span><span class="lineNoCov">          0 :                 exprState-&gt;constVarLattices.insert(make_pair(lat-&gt;first, lat-&gt;second-&gt;copy()));</span></a>
<a name="1063"><span class="lineNum">    1063 </span>            :         }</a>
<a name="1064"><span class="lineNum">    1064 </span>            :         </a>
<a name="1065"><span class="lineNum">    1065 </span>            :         // Copy over the lattice associated with exprVar</a>
<a name="1066"><span class="lineNum">    1066 </span><span class="lineNoCov">          0 :         if(varLatticeIndex.find(exprVar) != varLatticeIndex.end()) {</span></a>
<a name="1067"><span class="lineNum">    1067 </span><span class="lineNoCov">          0 :           int index = varLatticeIndex[exprVar];</span></a>
<a name="1068"><span class="lineNum">    1068 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(lattices[index]);</span></a>
<a name="1069"><span class="lineNum">    1069 </span>            : </a>
<a name="1070"><span class="lineNum">    1070 </span><span class="lineNoCov">          0 :           exprState-&gt;varLatticeIndex[varID(&quot;$&quot;)] = 0;</span></a>
<a name="1071"><span class="lineNum">    1071 </span><span class="lineNoCov">          0 :           exprState-&gt;lattices.push_back(lattices[index]-&gt;copy());</span></a>
<a name="1072"><span class="lineNum">    1072 </span>            :         }</a>
<a name="1073"><span class="lineNum">    1073 </span>            :         </a>
<a name="1074"><span class="lineNum">    1074 </span><span class="lineNoCov">          0 :         return exprState;</span></a>
<a name="1075"><span class="lineNum">    1075 </span>            : }</a>
<a name="1076"><span class="lineNum">    1076 </span>            : </a>
<a name="1077"><span class="lineNum">    1077 </span>            : // The inverse of project(). The call is provided with an expression and a Lattice that describes</a>
<a name="1078"><span class="lineNum">    1078 </span>            : // the dataflow state that relates to expression. This Lattice must be of the same type as the lattice</a>
<a name="1079"><span class="lineNum">    1079 </span>            : // returned by project(). unProject() must incorporate this dataflow state into the overall state it holds.</a>
<a name="1080"><span class="lineNum">    1080 </span>            : // Call must make an internal copy of the passed-in lattice and the caller is responsible for deallocating it.</a>
<a name="1081"><span class="lineNum">    1081 </span>            : // Returns true if this causes this to change and false otherwise.</a>
<a name="1082"><span class="lineNum">    1082 </span><span class="lineNoCov">          0 : bool VarsExprsProductLattice::unProject(SgExpression* expr, Lattice* exprState_arg)</span></a>
<a name="1083"><span class="lineNum">    1083 </span>            : { </a>
<a name="1084"><span class="lineNum">    1084 </span><span class="lineNoCov">          0 :         varID exprVar = SgExpr2Var(expr);</span></a>
<a name="1085"><span class="lineNum">    1085 </span><span class="lineNoCov">          0 :         VarsExprsProductLattice* exprState = dynamic_cast&lt;VarsExprsProductLattice*&gt;(exprState_arg);</span></a>
<a name="1086"><span class="lineNum">    1086 </span><span class="lineNoCov">          0 :         ROSE_ASSERT(exprState);</span></a>
<a name="1087"><span class="lineNum">    1087 </span>            :         </a>
<a name="1088"><span class="lineNum">    1088 </span>            :         // Make sure that exprState has a mapping for exprVar</a>
<a name="1089"><span class="lineNum">    1089 </span><span class="lineNoCov">          0 :         varID thatVar(&quot;$&quot;);</span></a>
<a name="1090"><span class="lineNum">    1090 </span><span class="lineNoCov">          0 :         ROSE_ASSERT(exprState-&gt;varLatticeIndex.find(thatVar) != exprState-&gt;varLatticeIndex.end());</span></a>
<a name="1091"><span class="lineNum">    1091 </span><span class="lineNoCov">          0 :         int thatIndex = exprState-&gt;varLatticeIndex[thatVar];</span></a>
<a name="1092"><span class="lineNum">    1092 </span><span class="lineNoCov">          0 :         Lattice *thatLattice = exprState-&gt;lattices[thatIndex];</span></a>
<a name="1093"><span class="lineNum">    1093 </span><span class="lineNoCov">          0 :         ROSE_ASSERT(thatLattice);</span></a>
<a name="1094"><span class="lineNum">    1094 </span>            :         </a>
<a name="1095"><span class="lineNum">    1095 </span>            :         // If This lattice has a mapping for exprVar, meet its Lattice in This with its lattice in exprState </a>
<a name="1096"><span class="lineNum">    1096 </span><span class="lineNoCov">          0 :         if(varLatticeIndex.find(exprVar) != varLatticeIndex.end()) {</span></a>
<a name="1097"><span class="lineNum">    1097 </span><span class="lineNoCov">          0 :                 ROSE_ASSERT(lattices[varLatticeIndex[exprVar]]);</span></a>
<a name="1098"><span class="lineNum">    1098 </span><span class="lineNoCov">          0 :                 return lattices[varLatticeIndex[exprVar]]-&gt;meetUpdate(thatLattice);</span></a>
<a name="1099"><span class="lineNum">    1099 </span>            :         // Else, if This lattice has no mapping for exprVar, simply copy it from exprState to This</a>
<a name="1100"><span class="lineNum">    1100 </span>            :         } else {</a>
<a name="1101"><span class="lineNum">    1101 </span><span class="lineNoCov">          0 :                 addVar(exprVar, thatLattice);</span></a>
<a name="1102"><span class="lineNum">    1102 </span>            :                 return true;</a>
<a name="1103"><span class="lineNum">    1103 </span>            :         }</a>
<a name="1104"><span class="lineNum">    1104 </span>            : }</a>
<a name="1105"><span class="lineNum">    1105 </span>            : </a>
<a name="1106"><span class="lineNum">    1106 </span>            : // Functions used to inform this lattice that a given variable is now in use (e.g. a variable has entered</a>
<a name="1107"><span class="lineNum">    1107 </span>            : //    scope or an expression is being analyzed) or is no longer in use (e.g. a variable has exited scope or</a>
<a name="1108"><span class="lineNum">    1108 </span>            : //    an expression or variable is dead).</a>
<a name="1109"><span class="lineNum">    1109 </span>            : // Returns true if this causes this Lattice to change and false otherwise.</a>
<a name="1110"><span class="lineNum">    1110 </span><span class="lineNoCov">          0 : bool VarsExprsProductLattice::addVar(const varID&amp; var)</span></a>
<a name="1111"><span class="lineNum">    1111 </span>            : {</a>
<a name="1112"><span class="lineNum">    1112 </span><span class="lineNoCov">          0 :         if(varLatticeIndex.find(var) == varLatticeIndex.end()) {</span></a>
<a name="1113"><span class="lineNum">    1113 </span><span class="lineNoCov">          0 :                 varLatticeIndex.insert(make_pair(var, lattices.size()));</span></a>
<a name="1114"><span class="lineNum">    1114 </span><span class="lineNoCov">          0 :                 lattices.push_back(perVarLattice-&gt;copy());</span></a>
<a name="1115"><span class="lineNum">    1115 </span><span class="lineNoCov">          0 :                 return true;</span></a>
<a name="1116"><span class="lineNum">    1116 </span>            :         } else</a>
<a name="1117"><span class="lineNum">    1117 </span>            :                 return false;</a>
<a name="1118"><span class="lineNum">    1118 </span>            : }</a>
<a name="1119"><span class="lineNum">    1119 </span><span class="lineNoCov">          0 : bool VarsExprsProductLattice::remVar(const varID&amp; var)</span></a>
<a name="1120"><span class="lineNum">    1120 </span>            : {</a>
<a name="1121"><span class="lineNum">    1121 </span><span class="lineNoCov">          0 :         map&lt;varID, int&gt;::iterator it;</span></a>
<a name="1122"><span class="lineNum">    1122 </span><span class="lineNoCov">          0 :         if((it = varLatticeIndex.find(var)) == varLatticeIndex.end())</span></a>
<a name="1123"><span class="lineNum">    1123 </span>            :                 return false;</a>
<a name="1124"><span class="lineNum">    1124 </span>            :         else {</a>
<a name="1125"><span class="lineNum">    1125 </span><span class="lineNoCov">          0 :                 delete lattices[it-&gt;second];</span></a>
<a name="1126"><span class="lineNum">    1126 </span><span class="lineNoCov">          0 :                 lattices[it-&gt;second]=NULL;</span></a>
<a name="1127"><span class="lineNum">    1127 </span>            :                 // !!! NOTE: THIS INTRODUCES A MINOR DATA LEAK SINCE THE LATTICES VECTOR MAY END UP WITH A LOT OF </a>
<a name="1128"><span class="lineNum">    1128 </span>            :                 // !!!       EMPTY REGIONS. WE MAY NEED TO COME UP WITH A SCHEME TO COMPRESS IT.</a>
<a name="1129"><span class="lineNum">    1129 </span><span class="lineNoCov">          0 :                 varLatticeIndex.erase(var);</span></a>
<a name="1130"><span class="lineNum">    1130 </span><span class="lineNoCov">          0 :                 return true;</span></a>
<a name="1131"><span class="lineNum">    1131 </span>            :         }</a>
<a name="1132"><span class="lineNum">    1132 </span>            : }</a>
<a name="1133"><span class="lineNum">    1133 </span>            : </a>
<a name="1134"><span class="lineNum">    1134 </span>            : // Sets the lattice of the given var to be lat. </a>
<a name="1135"><span class="lineNum">    1135 </span>            : // If the variable is already mapped to some other Lattice, </a>
<a name="1136"><span class="lineNum">    1136 </span>            : //   If *(the current lattice) == *lat, the mapping is not changed</a>
<a name="1137"><span class="lineNum">    1137 </span>            : //   If *(the current lattice) != *lat, the current lattice is deallocated and var is mapped to lat-&gt;copy()</a>
<a name="1138"><span class="lineNum">    1138 </span>            : // Returns true if this causes this Lattice to change and false otherwise.</a>
<a name="1139"><span class="lineNum">    1139 </span><span class="lineNoCov">          0 : bool VarsExprsProductLattice::addVar(const varID&amp; var, Lattice* lat)</span></a>
<a name="1140"><span class="lineNum">    1140 </span>            : {</a>
<a name="1141"><span class="lineNum">    1141 </span><span class="lineNoCov">          0 :         if(varLatticeIndex.find(var) == varLatticeIndex.end())</span></a>
<a name="1142"><span class="lineNum">    1142 </span>            :         {</a>
<a name="1143"><span class="lineNum">    1143 </span><span class="lineNoCov">          0 :                 varLatticeIndex.insert(make_pair(var, lattices.size()));</span></a>
<a name="1144"><span class="lineNum">    1144 </span><span class="lineNoCov">          0 :                 lattices.push_back(lat);</span></a>
<a name="1145"><span class="lineNum">    1145 </span><span class="lineNoCov">          0 :                 return true;</span></a>
<a name="1146"><span class="lineNum">    1146 </span>            :         } else {</a>
<a name="1147"><span class="lineNum">    1147 </span><span class="lineNoCov">          0 :                 ROSE_ASSERT(lattices[varLatticeIndex[var]]);</span></a>
<a name="1148"><span class="lineNum">    1148 </span><span class="lineNoCov">          0 :                 bool modified = (*(lattices[varLatticeIndex[var]]) != *lat);</span></a>
<a name="1149"><span class="lineNum">    1149 </span><span class="lineNoCov">          0 :                 if(modified) {</span></a>
<a name="1150"><span class="lineNum">    1150 </span><span class="lineNoCov">          0 :                         delete lattices[varLatticeIndex[var]];</span></a>
<a name="1151"><span class="lineNum">    1151 </span><span class="lineNoCov">          0 :                         lattices[varLatticeIndex[var]] = lat-&gt;copy();</span></a>
<a name="1152"><span class="lineNum">    1152 </span>            :                 }</a>
<a name="1153"><span class="lineNum">    1153 </span><span class="lineNoCov">          0 :                 return modified;</span></a>
<a name="1154"><span class="lineNum">    1154 </span>            :         }</a>
<a name="1155"><span class="lineNum">    1155 </span>            : }</a>
<a name="1156"><span class="lineNum">    1156 </span>            : </a>
<a name="1157"><span class="lineNum">    1157 </span>            : // The string that represents this object</a>
<a name="1158"><span class="lineNum">    1158 </span>            : // If indent!=&quot;&quot;, every line of this string must be prefixed by indent</a>
<a name="1159"><span class="lineNum">    1159 </span>            : // The last character of the returned string should not be '\n', even if it is a multi-line string.</a>
<a name="1160"><span class="lineNum">    1160 </span><span class="lineNoCov">          0 : string VarsExprsProductLattice::str(string indent)</span></a>
<a name="1161"><span class="lineNum">    1161 </span>            : {</a>
<a name="1162"><span class="lineNum">    1162 </span>            :         //printf(&quot;VarsExprsProductLattice::str() this-&gt;allVarLattice=%p\n&quot;, this-&gt;allVarLattice);</a>
<a name="1163"><span class="lineNum">    1163 </span>            :         </a>
<a name="1164"><span class="lineNum">    1164 </span><span class="lineNoCov">          0 :         ostringstream outs;</span></a>
<a name="1165"><span class="lineNum">    1165 </span>            :         //outs &lt;&lt; &quot;[VarsExprsProductLattice: n=&quot;&lt;&lt;n.getNode()&lt;&lt;&quot; = &lt;&quot;&lt;&lt;Dbg::escape(n.getNode()-&gt;unparseToString())&lt;&lt;&quot; | &quot;&lt;&lt;n.getNode()-&gt;class_name()&lt;&lt;&quot; | &quot;&lt;&lt;n.getIndex()&lt;&lt;&quot;&gt; level=&quot;&lt;&lt;(getLevel()==uninitialized ? &quot;uninitialized&quot; : &quot;initialized&quot;)&lt;&lt;endl;</a>
<a name="1166"><span class="lineNum">    1166 </span>            :         //outs &lt;&lt; &quot;[VarsExprsProductLattice: n=&quot;&lt;&lt;n.getNode()&lt;&lt;&quot; level=&quot;&lt;&lt;(getLevel()==uninitialized ? &quot;uninitialized&quot; : &quot;initialized&quot;)&lt;&lt;endl;</a>
<a name="1167"><span class="lineNum">    1167 </span>            :         // Liao 7/1/2012, avoid print out changing memory address info. so the string output can be used to verify correctness of analysis</a>
<a name="1168"><span class="lineNum">    1168 </span><span class="lineNoCov">          0 :         outs &lt;&lt; &quot;[VarsExprsProductLattice: level=&quot;&lt;&lt;(getLevel()==uninitialized ? &quot;uninitialized&quot; : &quot;initialized&quot;)&lt;&lt;endl;</span></a>
<a name="1169"><span class="lineNum">    1169 </span>            :         //varIDSet refVars;// = getVisibleVars(func);</a>
<a name="1170"><span class="lineNum">    1170 </span>            :         //for(varIDSet::iterator it = refVars.begin(); it!=refVars.end(); it++)</a>
<a name="1171"><span class="lineNum">    1171 </span><span class="lineNoCov">          0 :         for(map&lt;varID, int&gt;::iterator varIdx=varLatticeIndex.begin(); varIdx!=varLatticeIndex.end(); varIdx++)</span></a>
<a name="1172"><span class="lineNum">    1172 </span>            :         {</a>
<a name="1173"><span class="lineNum">    1173 </span><span class="lineNoCov">          0 :                 outs  &lt;&lt; indent;</span></a>
<a name="1174"><span class="lineNum">    1174 </span><span class="lineNoCov">          0 :                 outs  &lt;&lt; &quot;    &quot;;</span></a>
<a name="1175"><span class="lineNum">    1175 </span><span class="lineNoCov">          0 :                 outs  &lt;&lt; varIdx-&gt;first;</span></a>
<a name="1176"><span class="lineNum">    1176 </span><span class="lineNoCov">          0 :                 outs  &lt;&lt; &quot;: &quot;; // &lt;&lt; lattices[varIdx-&gt;second] &lt;&lt; &quot; : &quot;;</span></a>
<a name="1177"><span class="lineNum">    1177 </span><span class="lineNoCov">          0 :                 ROSE_ASSERT(lattices[varIdx-&gt;second]);</span></a>
<a name="1178"><span class="lineNum">    1178 </span><span class="lineNoCov">          0 :                 outs  &lt;&lt; lattices[varIdx-&gt;second]-&gt;str(&quot;&quot;);</span></a>
<a name="1179"><span class="lineNum">    1179 </span><span class="lineNoCov">          0 :                 outs  &lt;&lt; endl;</span></a>
<a name="1180"><span class="lineNum">    1180 </span>            :         }</a>
<a name="1181"><span class="lineNum">    1181 </span>            :         </a>
<a name="1182"><span class="lineNum">    1182 </span><span class="lineNoCov">          0 :         if(allVarLattice)</span></a>
<a name="1183"><span class="lineNum">    1183 </span><span class="lineNoCov">          0 :                 outs &lt;&lt; indent &lt;&lt; &quot;allVarLattice: &quot;&lt;&lt;endl&lt;&lt;allVarLattice-&gt;str(indent)&lt;&lt;endl;</span></a>
<a name="1184"><span class="lineNum">    1184 </span>            :         </a>
<a name="1185"><span class="lineNum">    1185 </span><span class="lineNoCov">          0 :         if(constVarLattices.size()&gt;0)</span></a>
<a name="1186"><span class="lineNum">    1186 </span>            :         {</a>
<a name="1187"><span class="lineNum">    1187 </span><span class="lineNoCov">          0 :                 outs &lt;&lt; indent &lt;&lt; &quot;constVarLattices: &quot;&lt;&lt;endl;fflush(stdout);</span></a>
<a name="1188"><span class="lineNum">    1188 </span><span class="lineNoCov">          0 :                 for(map&lt;varID, Lattice*&gt;::const_iterator itC = constVarLattices.begin(); itC!=constVarLattices.end(); itC++)</span></a>
<a name="1189"><span class="lineNum">    1189 </span>            :                 {</a>
<a name="1190"><span class="lineNum">    1190 </span><span class="lineNoCov">          0 :                         outs &lt;&lt; indent &lt;&lt; &quot;    &quot; &lt;&lt; itC-&gt;first.str() &lt;&lt; &quot;: &quot; &lt;&lt; itC-&gt;second-&gt;str(&quot;&quot;)&lt;&lt;endl;</span></a>
<a name="1191"><span class="lineNum">    1191 </span>            :                 }</a>
<a name="1192"><span class="lineNum">    1192 </span>            :         }</a>
<a name="1193"><span class="lineNum">    1193 </span><span class="lineNoCov">          0 :         outs &lt;&lt; indent &lt;&lt; &quot;]&quot;&lt;&lt;endl;</span></a>
<a name="1194"><span class="lineNum">    1194 </span><span class="lineNoCov">          0 :         return outs.str();</span></a>
<a name="1195"><span class="lineNum">    1195 </span>            : }</a>
<a name="1196"><span class="lineNum">    1196 </span>            : </a>
<a name="1197"><span class="lineNum">    1197 </span>            : /*****************************************</a>
<a name="1198"><span class="lineNum">    1198 </span>            :  ***** FiniteVarsExprsProductLattice *****</a>
<a name="1199"><span class="lineNum">    1199 </span>            :  *****************************************/</a>
<a name="1200"><span class="lineNum">    1200 </span>            : </a>
<a name="1201"><span class="lineNum">    1201 </span>            : // Initial blank FiniteVarsExprsProductLattice</a>
<a name="1202"><span class="lineNum">    1202 </span><span class="lineNoCov">          0 : FiniteVarsExprsProductLattice::FiniteVarsExprsProductLattice(const DataflowNode&amp; n, const NodeState&amp; state) :</span></a>
<a name="1203"><span class="lineNum">    1203 </span><span class="lineNoCov">          0 :                 VarsExprsProductLattice(n, state,filter)</span></a>
<a name="1204"><span class="lineNum">    1204 </span><span class="lineNoCov">          0 : {}</span></a>
<a name="1205"><span class="lineNum">    1205 </span>            : </a>
<a name="1206"><span class="lineNum">    1206 </span>            : // Retrns a blank instance of a VarsExprsProductLattice that only has the fields n and state set</a>
<a name="1207"><span class="lineNum">    1207 </span><span class="lineNoCov">          0 : VarsExprsProductLattice* FiniteVarsExprsProductLattice::blankVEPL(const DataflowNode&amp; n, const NodeState&amp; state)</span></a>
<a name="1208"><span class="lineNum">    1208 </span>            : {</a>
<a name="1209"><span class="lineNum">    1209 </span><span class="lineNoCov">          0 :         return new FiniteVarsExprsProductLattice(n, state);</span></a>
<a name="1210"><span class="lineNum">    1210 </span>            : }</a>
<a name="1211"><span class="lineNum">    1211 </span>            : </a>
<a name="1212"><span class="lineNum">    1212 </span>            : // creates a new VarsExprsProductLattice</a>
<a name="1213"><span class="lineNum">    1213 </span>            : // perVarLattice - sample lattice that will be associated with every variable in scope at node n</a>
<a name="1214"><span class="lineNum">    1214 </span>            : //     it should be assumed that the object pointed to by perVarLattice will be either</a>
<a name="1215"><span class="lineNum">    1215 </span>            : //     used internally by this VarsExprsProductLattice object or deallocated</a>
<a name="1216"><span class="lineNum">    1216 </span>            : // constVarLattices - map of additional variables and their associated lattices, that will be </a>
<a name="1217"><span class="lineNum">    1217 </span>            : //     incorporated into this VarsExprsProductLattice in addition to any other lattices for </a>
<a name="1218"><span class="lineNum">    1218 </span>            : //     currently live variables (these correspond to various useful constant variables like zeroVar)</a>
<a name="1219"><span class="lineNum">    1219 </span>            : // allVarLattice - the lattice associated with allVar (the variable that represents all of memory)</a>
<a name="1220"><span class="lineNum">    1220 </span>            : //     if allVarLattice==NULL, no support is provided for allVar</a>
<a name="1221"><span class="lineNum">    1221 </span>            : // func - the current function</a>
<a name="1222"><span class="lineNum">    1222 </span>            : // n - the dataflow node that this lattice will be associated with</a>
<a name="1223"><span class="lineNum">    1223 </span>            : // state - the NodeState at this dataflow node</a>
<a name="1224"><span class="lineNum">    1224 </span><span class="lineNoCov">          0 : FiniteVarsExprsProductLattice::FiniteVarsExprsProductLattice(</span></a>
<a name="1225"><span class="lineNum">    1225 </span>            :                                       Lattice* perVarLattice, </a>
<a name="1226"><span class="lineNum">    1226 </span>            :                                       const map&lt;varID, Lattice*&gt;&amp; constVarLattices, </a>
<a name="1227"><span class="lineNum">    1227 </span>            :                                       Lattice* allVarLattice,</a>
<a name="1228"><span class="lineNum">    1228 </span>            :                                       LiveDeadVarsAnalysis* ldva, </a>
<a name="1229"><span class="lineNum">    1229 </span><span class="lineNoCov">          0 :                                       const DataflowNode&amp; n, const NodeState&amp; state) :</span></a>
<a name="1230"><span class="lineNum">    1230 </span>            :     VarsExprsProductLattice(perVarLattice, constVarLattices, allVarLattice, ldva, n, state), </a>
<a name="1231"><span class="lineNum">    1231 </span><span class="lineNoCov">          0 :     FiniteProductLattice()</span></a>
<a name="1232"><span class="lineNum">    1232 </span>            : {</a>
<a name="1233"><span class="lineNum">    1233 </span>            :         //Dbg::dbg &lt;&lt; &quot;FiniteVarsExprsProductLattice n=&quot;&lt;&lt;n.getNode()&lt;&lt;&quot; = &lt;&quot;&lt;&lt;Dbg::escape(n.getNode()-&gt;unparseToString())&lt;&lt;&quot; | &quot;&lt;&lt;n.getNode()-&gt;class_name()&lt;&lt;&quot; | &quot;&lt;&lt;n.getIndex()&lt;&lt;&quot;&gt;&quot;&lt;&lt;endl;</a>
<a name="1234"><span class="lineNum">    1234 </span><span class="lineNoCov">          0 :         verifyFinite();</span></a>
<a name="1235"><span class="lineNum">    1235 </span><span class="lineNoCov">          0 : }</span></a>
<a name="1236"><span class="lineNum">    1236 </span>            : </a>
<a name="1237"><span class="lineNum">    1237 </span><span class="lineNoCov">          0 : FiniteVarsExprsProductLattice::FiniteVarsExprsProductLattice(const FiniteVarsExprsProductLattice&amp; that) : </span></a>
<a name="1238"><span class="lineNum">    1238 </span><span class="lineNoCov">          0 :         VarsExprsProductLattice(that), FiniteProductLattice()</span></a>
<a name="1239"><span class="lineNum">    1239 </span>            : {</a>
<a name="1240"><span class="lineNum">    1240 </span>            :         //Dbg::dbg &lt;&lt; &quot;FiniteVarsExprsProductLattice::copy n=&quot;&lt;&lt;n.getNode()&lt;&lt;&quot; = &lt;&quot;&lt;&lt;Dbg::escape(n.getNode()-&gt;unparseToString())&lt;&lt;&quot; | &quot;&lt;&lt;n.getNode()-&gt;class_name()&lt;&lt;&quot; | &quot;&lt;&lt;n.getIndex()&lt;&lt;&quot;&gt;&quot;&lt;&lt;endl;</a>
<a name="1241"><span class="lineNum">    1241 </span><span class="lineNoCov">          0 :         verifyFinite();</span></a>
<a name="1242"><span class="lineNum">    1242 </span><span class="lineNoCov">          0 : }</span></a>
<a name="1243"><span class="lineNum">    1243 </span>            : </a>
<a name="1244"><span class="lineNum">    1244 </span>            : // returns a copy of this lattice</a>
<a name="1245"><span class="lineNum">    1245 </span><span class="lineNoCov">          0 : Lattice* FiniteVarsExprsProductLattice::copy() const</span></a>
<a name="1246"><span class="lineNum">    1246 </span>            : {</a>
<a name="1247"><span class="lineNum">    1247 </span><span class="lineNoCov">          0 :         return new FiniteVarsExprsProductLattice(*this);</span></a>
<a name="1248"><span class="lineNum">    1248 </span>            : }</a>
<a name="1249"><span class="lineNum">    1249 </span>            : </a>
<a name="1250"><span class="lineNum">    1250 </span>            : /*******************************************</a>
<a name="1251"><span class="lineNum">    1251 </span>            :  ***** InfiniteVarsExprsProductLattice *****</a>
<a name="1252"><span class="lineNum">    1252 </span>            :  *******************************************/</a>
<a name="1253"><span class="lineNum">    1253 </span>            : </a>
<a name="1254"><span class="lineNum">    1254 </span>            : // Minimal constructor that initializes just the portions of the object required to make an </a>
<a name="1255"><span class="lineNum">    1255 </span>            : // initial blank VarsExprsProductLattice</a>
<a name="1256"><span class="lineNum">    1256 </span><span class="lineNoCov">          0 : InfiniteVarsExprsProductLattice::InfiniteVarsExprsProductLattice(const DataflowNode&amp; n, const NodeState&amp; state) : </span></a>
<a name="1257"><span class="lineNum">    1257 </span><span class="lineNoCov">          0 :                 VarsExprsProductLattice(n, state,filter)</span></a>
<a name="1258"><span class="lineNum">    1258 </span><span class="lineNoCov">          0 : {}</span></a>
<a name="1259"><span class="lineNum">    1259 </span>            : </a>
<a name="1260"><span class="lineNum">    1260 </span>            : // Retrns a blank instance of a VarsExprsProductLattice that only has the fields n and state set</a>
<a name="1261"><span class="lineNum">    1261 </span><span class="lineNoCov">          0 : VarsExprsProductLattice* InfiniteVarsExprsProductLattice::blankVEPL(const DataflowNode&amp; n, const NodeState&amp; state)</span></a>
<a name="1262"><span class="lineNum">    1262 </span>            : {</a>
<a name="1263"><span class="lineNum">    1263 </span><span class="lineNoCov">          0 :         return new InfiniteVarsExprsProductLattice(n, state);</span></a>
<a name="1264"><span class="lineNum">    1264 </span>            : }</a>
<a name="1265"><span class="lineNum">    1265 </span>            : </a>
<a name="1266"><span class="lineNum">    1266 </span>            : // creates a new VarsExprsProductLattice</a>
<a name="1267"><span class="lineNum">    1267 </span>            : // perVarLattice - sample lattice that will be associated with every variable in scope at node n</a>
<a name="1268"><span class="lineNum">    1268 </span>            : //     it should be assumed that the object pointed to by perVarLattice will be either</a>
<a name="1269"><span class="lineNum">    1269 </span>            : //     used internally by this VarsExprsProductLatticeobject or deallocated</a>
<a name="1270"><span class="lineNum">    1270 </span>            : // constVarLattices - map of additional variables and their associated lattices, that will be </a>
<a name="1271"><span class="lineNum">    1271 </span>            : //     incorporated into this VarsExprsProductLatticein addition to any other lattices for </a>
<a name="1272"><span class="lineNum">    1272 </span>            : //     currently live variables (these correspond to various useful constant variables like zeroVar)</a>
<a name="1273"><span class="lineNum">    1273 </span>            : // allVarLattice - the lattice associated with allVar (the variable that represents all of memory)</a>
<a name="1274"><span class="lineNum">    1274 </span>            : //     if allVarLattice==NULL, no support is provided for allVar</a>
<a name="1275"><span class="lineNum">    1275 </span>            : // func - the current function</a>
<a name="1276"><span class="lineNum">    1276 </span>            : // n - the dataflow node that this lattice will be associated with</a>
<a name="1277"><span class="lineNum">    1277 </span>            : // state - the NodeState at this dataflow node</a>
<a name="1278"><span class="lineNum">    1278 </span><span class="lineNoCov">          0 : InfiniteVarsExprsProductLattice::InfiniteVarsExprsProductLattice(Lattice* perVarLattice, </span></a>
<a name="1279"><span class="lineNum">    1279 </span>            :                                         const map&lt;varID, Lattice*&gt;&amp; constVarLattices, </a>
<a name="1280"><span class="lineNum">    1280 </span>            :                                         Lattice* allVarLattice,</a>
<a name="1281"><span class="lineNum">    1281 </span>            :                                         LiveDeadVarsAnalysis* ldva, </a>
<a name="1282"><span class="lineNum">    1282 </span><span class="lineNoCov">          0 :                                         const DataflowNode&amp; n, const NodeState&amp; state) :</span></a>
<a name="1283"><span class="lineNum">    1283 </span>            :     VarsExprsProductLattice(perVarLattice, constVarLattices, allVarLattice, ldva, n, state), </a>
<a name="1284"><span class="lineNum">    1284 </span><span class="lineNoCov">          0 :     InfiniteProductLattice()</span></a>
<a name="1285"><span class="lineNum">    1285 </span>            : {</a>
<a name="1286"><span class="lineNum">    1286 </span><span class="lineNoCov">          0 : }</span></a>
<a name="1287"><span class="lineNum">    1287 </span>            : </a>
<a name="1288"><span class="lineNum">    1288 </span><span class="lineNoCov">          0 : InfiniteVarsExprsProductLattice::InfiniteVarsExprsProductLattice(const FiniteVarsExprsProductLattice&amp; that) : </span></a>
<a name="1289"><span class="lineNum">    1289 </span><span class="lineNoCov">          0 :         VarsExprsProductLattice(that), InfiniteProductLattice()</span></a>
<a name="1290"><span class="lineNum">    1290 </span>            : {</a>
<a name="1291"><span class="lineNum">    1291 </span><span class="lineNoCov">          0 : }</span></a>
<a name="1292"><span class="lineNum">    1292 </span>            : </a>
<a name="1293"><span class="lineNum">    1293 </span>            : // returns a copy of this lattice</a>
<a name="1294"><span class="lineNum">    1294 </span><span class="lineNoCov">          0 : Lattice* InfiniteVarsExprsProductLattice::copy() const</span></a>
<a name="1295"><span class="lineNum">    1295 </span>            : {</a>
<a name="1296"><span class="lineNum">    1296 </span><span class="lineNoCov">          0 :         return new InfiniteVarsExprsProductLattice(*this);</span></a>
<a name="1297"><span class="lineNum">    1297 </span>            : }</a>
<a name="1298"><span class="lineNum">    1298 </span>            : </a>
<a name="1299"><span class="lineNum">    1299 </span>            : </a>
<a name="1300"><span class="lineNum">    1300 </span>            : </a>
<a name="1301"><span class="lineNum">    1301 </span>            : </a>
<a name="1302"><span class="lineNum">    1302 </span>            : // prints the Lattices set by the given LiveDeadVarsAnalysis </a>
<a name="1303"><span class="lineNum">    1303 </span><span class="lineNoCov">          0 : void printLiveDeadVarsAnalysisStates(LiveDeadVarsAnalysis* ldva, string indent)</span></a>
<a name="1304"><span class="lineNum">    1304 </span>            : {</a>
<a name="1305"><span class="lineNum">    1305 </span><span class="lineNoCov">          0 :         vector&lt;int&gt; factNames;</span></a>
<a name="1306"><span class="lineNum">    1306 </span><span class="lineNoCov">          0 :         vector&lt;int&gt; latticeNames;</span></a>
<a name="1307"><span class="lineNum">    1307 </span><span class="lineNoCov">          0 :         latticeNames.push_back(0);</span></a>
<a name="1308"><span class="lineNum">    1308 </span><span class="lineNoCov">          0 :         printAnalysisStates pas(ldva, factNames, latticeNames, printAnalysisStates::above, indent);</span></a>
<a name="1309"><span class="lineNum">    1309 </span><span class="lineNoCov">          0 :         UnstructuredPassInterAnalysis upia_pas(pas);</span></a>
<a name="1310"><span class="lineNum">    1310 </span><span class="lineNoCov">          0 :         upia_pas.runAnalysis();</span></a>
<a name="1311"><span class="lineNum">    1311 </span><span class="lineNoCov">          0 : }</span></a>
<a name="1312"><span class="lineNum">    1312 </span>            : </a>
<a name="1313"><span class="lineNum">    1313 </span>            : #endif</a>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.14</a></td></tr>
  </table>
  <br>

</body>
</html>
