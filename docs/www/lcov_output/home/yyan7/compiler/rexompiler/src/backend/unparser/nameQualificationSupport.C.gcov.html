<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - ROSE - /home/yyan7/compiler/rexompiler/src/backend/unparser/nameQualificationSupport.C</title>
  <link rel="stylesheet" type="text/css" href="../../../../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../../../../index.html">top level</a> - <a href="index.html">home/yyan7/compiler/rexompiler/src/backend/unparser</a> - nameQualificationSupport.C<span style="font-size: 80%;"> (source / <a href="nameQualificationSupport.C.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">ROSE</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">2306</td>
            <td class="headerCovTableEntry">2998</td>
            <td class="headerCovTableEntryMed">76.9 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2022-12-08 13:48:47</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">65</td>
            <td class="headerCovTableEntry">78</td>
            <td class="headerCovTableEntryMed">83.3 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : #include &quot;sage3basic.h&quot;</a>
<a name="2"><span class="lineNum">       2 </span>            : #include &lt;Rose/Diagnostics.h&gt;</a>
<a name="3"><span class="lineNum">       3 </span>            : #include &quot;nameQualificationSupport.h&quot;</a>
<a name="4"><span class="lineNum">       4 </span>            : </a>
<a name="5"><span class="lineNum">       5 </span>            : #include &quot;sageGeneric.h&quot;</a>
<a name="6"><span class="lineNum">       6 </span>            : </a>
<a name="7"><span class="lineNum">       7 </span>            : using namespace std;</a>
<a name="8"><span class="lineNum">       8 </span>            : </a>
<a name="9"><span class="lineNum">       9 </span>            : // DQ (3/24/2016): Adding Robb's message logging mechanism to contrl output debug message from the EDG/ROSE connection code.</a>
<a name="10"><span class="lineNum">      10 </span>            : using namespace Rose::Diagnostics;</a>
<a name="11"><span class="lineNum">      11 </span>            : </a>
<a name="12"><span class="lineNum">      12 </span>            : namespace si = SageInterface;</a>
<a name="13"><span class="lineNum">      13 </span>            : </a>
<a name="14"><span class="lineNum">      14 </span>            : // This value must be greater than 3 to cause most output to be generated.</a>
<a name="15"><span class="lineNum">      15 </span>            : #define DEBUG_NAME_QUALIFICATION_LEVEL 0</a>
<a name="16"><span class="lineNum">      16 </span>            : </a>
<a name="17"><span class="lineNum">      17 </span>            : #ifndef WARNING_FOR_NONREAL_DEVEL</a>
<a name="18"><span class="lineNum">      18 </span>            : #  define WARNING_FOR_NONREAL_DEVEL 0</a>
<a name="19"><span class="lineNum">      19 </span>            : #endif</a>
<a name="20"><span class="lineNum">      20 </span>            : </a>
<a name="21"><span class="lineNum">      21 </span>            : // DQ (9/2/2020): Moved to the top of the file from the SgInitializedName case in the evaluate inherited attribute function.</a>
<a name="22"><span class="lineNum">      22 </span>            : // DQ (4/27/2019): Set these to be the same for now.</a>
<a name="23"><span class="lineNum">      23 </span>            : #define DEBUG_INITIALIZED_NAME 0</a>
<a name="24"><span class="lineNum">      24 </span>            : // #define DEBUG_INITIALIZED_NAME DEBUG_NAME_QUALIFICATION_LEVEL</a>
<a name="25"><span class="lineNum">      25 </span>            : </a>
<a name="26"><span class="lineNum">      26 </span>            : // DQ (10/17/2020): Worked with Tristan, but this was the only way that I could turn on the debug output for my tool in ROSE_GARDEN.</a>
<a name="27"><span class="lineNum">      27 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="28"><span class="lineNum">      28 </span>            : #define mfprintf(a) printf</a>
<a name="29"><span class="lineNum">      29 </span>            : #endif</a>
<a name="30"><span class="lineNum">      30 </span>            : </a>
<a name="31"><span class="lineNum">      31 </span>            : // ***********************************************************</a>
<a name="32"><span class="lineNum">      32 </span>            : // Main calling function to support name qualification support</a>
<a name="33"><span class="lineNum">      33 </span>            : // ***********************************************************</a>
<a name="34"><span class="lineNum">      34 </span>            : </a>
<a name="35"><span class="lineNum">      35 </span>            : </a>
<a name="36"><span class="lineNum">      36 </span>            : </a>
<a name="37"><span class="lineNum">      37 </span>            : </a>
<a name="38"><span class="lineNum">      38 </span>            : void</a>
<a name="39"><span class="lineNum">      39 </span><span class="lineCov">         66 : generateNameQualificationSupport( SgNode* node, std::set&lt;SgNode*&gt;&amp; referencedNameSet )</span></a>
<a name="40"><span class="lineNum">      40 </span>            :    {</a>
<a name="41"><span class="lineNum">      41 </span>            :   // This function is the top level API for Name Qualification support.</a>
<a name="42"><span class="lineNum">      42 </span>            :   // This is the only function that need be seen by ROSE.  This function</a>
<a name="43"><span class="lineNum">      43 </span>            :   // is called in the function:</a>
<a name="44"><span class="lineNum">      44 </span>            :   //      Unparser::unparseFile(SgSourceFile* file, SgUnparse_Info&amp; info )</a>
<a name="45"><span class="lineNum">      45 </span>            :   // in the unparser.C file.  Thus the name qualification is computed</a>
<a name="46"><span class="lineNum">      46 </span>            :   // as we start to process a file and the computed values saved into the</a>
<a name="47"><span class="lineNum">      47 </span>            :   // SgNode static data member maps. Two maps are used:</a>
<a name="48"><span class="lineNum">      48 </span>            :   //    one to support qualification of IR nodes that are named, and</a>
<a name="49"><span class="lineNum">      49 </span>            :   //    one to support name qualification of types.</a>
<a name="50"><span class="lineNum">      50 </span>            :   // These are passed by reference and references are stored to them in</a>
<a name="51"><span class="lineNum">      51 </span>            :   // the NameQualificationTraversal class.</a>
<a name="52"><span class="lineNum">      52 </span>            : </a>
<a name="53"><span class="lineNum">      53 </span><span class="lineCov">        132 :      TimingPerformance timer (&quot;Name qualification support:&quot;);</span></a>
<a name="54"><span class="lineNum">      54 </span>            : </a>
<a name="55"><span class="lineNum">      55 </span>            :   // DQ (5/28/2011): Initialize the local maps to the static maps in SgNode.  This is requires so the</a>
<a name="56"><span class="lineNum">      56 </span>            :   // types used in template arguments can call the unparser to support there generation of name qualified</a>
<a name="57"><span class="lineNum">      57 </span>            :   // nested types.</a>
<a name="58"><span class="lineNum">      58 </span>            : </a>
<a name="59"><span class="lineNum">      59 </span>            : #if 0</a>
<a name="60"><span class="lineNum">      60 </span>            :      printf (&quot;In generateNameQualificationSupport(): node = %p = %s \n&quot;,node,node-&gt;class_name().c_str());</a>
<a name="61"><span class="lineNum">      61 </span>            :      SgSourceFile* sourceFile = isSgSourceFile(node);</a>
<a name="62"><span class="lineNum">      62 </span>            :      if (sourceFile != NULL)</a>
<a name="63"><span class="lineNum">      63 </span>            :         {</a>
<a name="64"><span class="lineNum">      64 </span>            :           printf (&quot; --- sourceFile = %p filename = %s \n&quot;,sourceFile,sourceFile-&gt;getFileName().c_str());</a>
<a name="65"><span class="lineNum">      65 </span>            :         }</a>
<a name="66"><span class="lineNum">      66 </span>            : #endif</a>
<a name="67"><span class="lineNum">      67 </span>            : </a>
<a name="68"><span class="lineNum">      68 </span>            : #if 0</a>
<a name="69"><span class="lineNum">      69 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In generateNameQualificationSupport(): MangledNameSupport::visitedTemplateDefinitions.size() = %zu \n&quot;,MangledNameSupport::visitedTemplateDefinitions.size());</a>
<a name="70"><span class="lineNum">      70 </span>            : #endif</a>
<a name="71"><span class="lineNum">      71 </span>            : </a>
<a name="72"><span class="lineNum">      72 </span>            :   // DQ (9/7/2014): Modified to handle template header map (for template declarations).</a>
<a name="73"><span class="lineNum">      73 </span>            :   // NameQualificationTraversal t(SgNode::get_globalQualifiedNameMapForNames(),SgNode::get_globalQualifiedNameMapForTypes(),SgNode::get_globalTypeNameMap(),referencedNameSet);</a>
<a name="74"><span class="lineNum">      74 </span>            :   // NameQualificationTraversal t(SgNode::get_globalQualifiedNameMapForNames(),SgNode::get_globalQualifiedNameMapForTypes(),</a>
<a name="75"><span class="lineNum">      75 </span>            :   //                              SgNode::get_globalQualifiedNameMapForTemplateHeaders(),SgNode::get_globalTypeNameMap(),referencedNameSet);</a>
<a name="76"><span class="lineNum">      76 </span><span class="lineCov">         66 :      NameQualificationTraversal t(SgNode::get_globalQualifiedNameMapForNames(),SgNode::get_globalQualifiedNameMapForTypes(),</span></a>
<a name="77"><span class="lineNum">      77 </span>            :                                   SgNode::get_globalQualifiedNameMapForTemplateHeaders(),SgNode::get_globalTypeNameMap(),</a>
<a name="78"><span class="lineNum">      78 </span><span class="lineCov">         66 :                                   SgNode::get_globalQualifiedNameMapForMapsOfTypes(),referencedNameSet);</span></a>
<a name="79"><span class="lineNum">      79 </span>            : </a>
<a name="80"><span class="lineNum">      80 </span><span class="lineCov">         66 :      NameQualificationInheritedAttribute ih;</span></a>
<a name="81"><span class="lineNum">      81 </span>            : </a>
<a name="82"><span class="lineNum">      82 </span>            : #if 0</a>
<a name="83"><span class="lineNum">      83 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;Calling SageInterface::buildDeclarationSets(node = %p = %s) \n&quot;,node,node-&gt;class_name().c_str());</a>
<a name="84"><span class="lineNum">      84 </span>            : #endif</a>
<a name="85"><span class="lineNum">      85 </span>            : </a>
<a name="86"><span class="lineNum">      86 </span>            :   // DQ (4/3/2014): Added assertion.</a>
<a name="87"><span class="lineNum">      87 </span><span class="lineCov">         66 :      t.declarationSet = SageInterface::buildDeclarationSets(node);</span></a>
<a name="88"><span class="lineNum">      88 </span><span class="lineCov">         66 :      ASSERT_not_null(t.declarationSet);</span></a>
<a name="89"><span class="lineNum">      89 </span>            : </a>
<a name="90"><span class="lineNum">      90 </span>            : #if 0</a>
<a name="91"><span class="lineNum">      91 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;DONE: Calling SageInterface::buildDeclarationSets(node = %p = %s) t.declarationSet = %p \n&quot;,node,node-&gt;class_name().c_str(),t.declarationSet);</a>
<a name="92"><span class="lineNum">      92 </span>            : #endif</a>
<a name="93"><span class="lineNum">      93 </span>            : </a>
<a name="94"><span class="lineNum">      94 </span>            :   // Call the traversal.</a>
<a name="95"><span class="lineNum">      95 </span><span class="lineCov">        132 :      t.traverse(node,ih);</span></a>
<a name="96"><span class="lineNum">      96 </span>            : </a>
<a name="97"><span class="lineNum">      97 </span>            : </a>
<a name="98"><span class="lineNum">      98 </span>            : #if 0</a>
<a name="99"><span class="lineNum">      99 </span>            :      printf(&quot;Exiting as a test! \n&quot;);</a>
<a name="100"><span class="lineNum">     100 </span>            :      ROSE_ABORT();</a>
<a name="101"><span class="lineNum">     101 </span>            : #endif</a>
<a name="102"><span class="lineNum">     102 </span><span class="lineCov">         66 :    }</span></a>
<a name="103"><span class="lineNum">     103 </span>            : </a>
<a name="104"><span class="lineNum">     104 </span><span class="lineCov">        356 : void NameQualificationTraversal::initDiagnostics()</span></a>
<a name="105"><span class="lineNum">     105 </span>            :    {</a>
<a name="106"><span class="lineNum">     106 </span><span class="lineCov">        356 :      static bool initialized = false;</span></a>
<a name="107"><span class="lineNum">     107 </span><span class="lineCov">        356 :      if (!initialized)</span></a>
<a name="108"><span class="lineNum">     108 </span>            :         {</a>
<a name="109"><span class="lineNum">     109 </span><span class="lineCov">        356 :           initialized = true;</span></a>
<a name="110"><span class="lineNum">     110 </span>            :         }</a>
<a name="111"><span class="lineNum">     111 </span><span class="lineCov">        356 :    }</span></a>
<a name="112"><span class="lineNum">     112 </span>            : </a>
<a name="113"><span class="lineNum">     113 </span>            : void</a>
<a name="114"><span class="lineNum">     114 </span><span class="lineCov">     271866 : NameQualificationTraversal::generateNestedTraversalWithExplicitScope( SgNode* node, SgScopeStatement* input_currentScope, SgStatement* input_currentStatement, SgNode* input_referenceNode )</span></a>
<a name="115"><span class="lineNum">     115 </span>            :    {</a>
<a name="116"><span class="lineNum">     116 </span><span class="lineCov">     271866 :      ASSERT_not_null(input_currentScope);</span></a>
<a name="117"><span class="lineNum">     117 </span>            : </a>
<a name="118"><span class="lineNum">     118 </span>            :   // DQ (9/7/2014): Modified to handle template header map (for template declarations).</a>
<a name="119"><span class="lineNum">     119 </span>            :   // NameQualificationTraversal t(this-&gt;qualifiedNameMapForNames,this-&gt;qualifiedNameMapForTypes,this-&gt;typeNameMap,this-&gt;referencedNameSet);</a>
<a name="120"><span class="lineNum">     120 </span>            :   // NameQualificationTraversal t(this-&gt;qualifiedNameMapForNames,this-&gt;qualifiedNameMapForTypes,this-&gt;qualifiedNameMapForTemplateHeaders,this-&gt;typeNameMap,this-&gt;referencedNameSet);</a>
<a name="121"><span class="lineNum">     121 </span><span class="lineCov">     271866 :      NameQualificationTraversal t(this-&gt;qualifiedNameMapForNames,this-&gt;qualifiedNameMapForTypes,this-&gt;qualifiedNameMapForTemplateHeaders,</span></a>
<a name="122"><span class="lineNum">     122 </span><span class="lineCov">     271866 :                                   this-&gt;typeNameMap,this-&gt;qualifiedNameMapForMapsOfTypes,this-&gt;referencedNameSet);</span></a>
<a name="123"><span class="lineNum">     123 </span>            : </a>
<a name="124"><span class="lineNum">     124 </span><span class="lineCov">     271866 :      t.explictlySpecifiedCurrentScope     = input_currentScope;</span></a>
<a name="125"><span class="lineNum">     125 </span>            : </a>
<a name="126"><span class="lineNum">     126 </span>            :   // DQ (4/19/2019): This might not be required (passin it via the inherited attribute might be all thisis required.</a>
<a name="127"><span class="lineNum">     127 </span>            :   // DQ (4/19/2019): Added support to include current statement (required for nested traversals</a>
<a name="128"><span class="lineNum">     128 </span>            :   // of types to support name qualification for SgPointerMemberType).</a>
<a name="129"><span class="lineNum">     129 </span><span class="lineCov">     271866 :      t.explictlySpecifiedCurrentStatement = input_currentStatement;</span></a>
<a name="130"><span class="lineNum">     130 </span>            : </a>
<a name="131"><span class="lineNum">     131 </span>            :   // DQ (4/7/2014): Set this explicitly using the one already built.</a>
<a name="132"><span class="lineNum">     132 </span><span class="lineCov">     271866 :      ASSERT_not_null(declarationSet);</span></a>
<a name="133"><span class="lineNum">     133 </span><span class="lineCov">     271866 :      t.declarationSet = declarationSet;</span></a>
<a name="134"><span class="lineNum">     134 </span><span class="lineCov">     271866 :      ASSERT_not_null(t.declarationSet);</span></a>
<a name="135"><span class="lineNum">     135 </span>            : </a>
<a name="136"><span class="lineNum">     136 </span><span class="lineCov">     271866 :      NameQualificationInheritedAttribute ih;</span></a>
<a name="137"><span class="lineNum">     137 </span>            : </a>
<a name="138"><span class="lineNum">     138 </span>            :   // DQ (4/3/2014): Added assertion.</a>
<a name="139"><span class="lineNum">     139 </span><span class="lineCov">     271866 :      ASSERT_not_null(declarationSet);</span></a>
<a name="140"><span class="lineNum">     140 </span>            : </a>
<a name="141"><span class="lineNum">     141 </span>            :   // This fails for test2001_02.C.</a>
<a name="142"><span class="lineNum">     142 </span>            :   // ROSE_ASSERT(declarationSet == NULL);</a>
<a name="143"><span class="lineNum">     143 </span>            : </a>
<a name="144"><span class="lineNum">     144 </span>            :   // DQ (5/24/2013): Added scope to inherited attribute.</a>
<a name="145"><span class="lineNum">     145 </span><span class="lineCov">     271866 :      ih.set_currentScope(input_currentScope);</span></a>
<a name="146"><span class="lineNum">     146 </span>            : </a>
<a name="147"><span class="lineNum">     147 </span>            :   // DQ (4/19/2019): Added support to include current statement (required for nested traversals</a>
<a name="148"><span class="lineNum">     148 </span>            :   // of types to support name qualification for SgPointerMemberType).</a>
<a name="149"><span class="lineNum">     149 </span><span class="lineCov">     271866 :      ih.set_currentStatement(input_currentStatement);</span></a>
<a name="150"><span class="lineNum">     150 </span><span class="lineCov">     271866 :      ih.set_referenceNode(input_referenceNode);</span></a>
<a name="151"><span class="lineNum">     151 </span>            : </a>
<a name="152"><span class="lineNum">     152 </span>            : #if 0</a>
<a name="153"><span class="lineNum">     153 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;**************************************************************** \n&quot;);</a>
<a name="154"><span class="lineNum">     154 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;**************************************************************** \n&quot;);</a>
<a name="155"><span class="lineNum">     155 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;********************* RECURSIVE TRAVERSAL ********************** \n&quot;);</a>
<a name="156"><span class="lineNum">     156 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;**************************************************************** \n&quot;);</a>
<a name="157"><span class="lineNum">     157 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;**************************************************************** \n&quot;);</a>
<a name="158"><span class="lineNum">     158 </span>            : #endif</a>
<a name="159"><span class="lineNum">     159 </span>            : </a>
<a name="160"><span class="lineNum">     160 </span>            :   // Call the traversal.</a>
<a name="161"><span class="lineNum">     161 </span><span class="lineCov">     543732 :      t.traverse(node,ih);</span></a>
<a name="162"><span class="lineNum">     162 </span>            : </a>
<a name="163"><span class="lineNum">     163 </span>            : #if 0</a>
<a name="164"><span class="lineNum">     164 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;**************************************************************** \n&quot;);</a>
<a name="165"><span class="lineNum">     165 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;**************************************************************** \n&quot;);</a>
<a name="166"><span class="lineNum">     166 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;****************** DONE: RECURSIVE TRAVERSAL ******************* \n&quot;);</a>
<a name="167"><span class="lineNum">     167 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;**************************************************************** \n&quot;);</a>
<a name="168"><span class="lineNum">     168 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;**************************************************************** \n&quot;);</a>
<a name="169"><span class="lineNum">     169 </span>            : #endif</a>
<a name="170"><span class="lineNum">     170 </span><span class="lineCov">     271866 :    }</span></a>
<a name="171"><span class="lineNum">     171 </span>            : </a>
<a name="172"><span class="lineNum">     172 </span>            : </a>
<a name="173"><span class="lineNum">     173 </span>            : // *******************</a>
<a name="174"><span class="lineNum">     174 </span>            : // Inherited Attribute</a>
<a name="175"><span class="lineNum">     175 </span>            : // *******************</a>
<a name="176"><span class="lineNum">     176 </span>            : </a>
<a name="177"><span class="lineNum">     177 </span><span class="lineCov">     271932 : NameQualificationInheritedAttribute::NameQualificationInheritedAttribute()</span></a>
<a name="178"><span class="lineNum">     178 </span>            :    {</a>
<a name="179"><span class="lineNum">     179 </span>            :   // Default constructor</a>
<a name="180"><span class="lineNum">     180 </span>            : </a>
<a name="181"><span class="lineNum">     181 </span>            :   // DQ (5/24/2013): Allow the current scope to be tracked from the traversal of the AST</a>
<a name="182"><span class="lineNum">     182 </span>            :   // instead of being computed at each IR node which is a problem for template arguments.</a>
<a name="183"><span class="lineNum">     183 </span>            :   // See test2013_187.C for an example of this.</a>
<a name="184"><span class="lineNum">     184 </span><span class="lineCov">     271932 :      currentScope     = NULL;</span></a>
<a name="185"><span class="lineNum">     185 </span><span class="lineCov">     271932 :      currentStatement = NULL;</span></a>
<a name="186"><span class="lineNum">     186 </span><span class="lineCov">     271932 :      referenceNode    = NULL;</span></a>
<a name="187"><span class="lineNum">     187 </span>            : </a>
<a name="188"><span class="lineNum">     188 </span>            : #if 0</a>
<a name="189"><span class="lineNum">     189 </span>            :   // DQ (2/8/2019): And then I woke up in the morning and had a better idea.</a>
<a name="190"><span class="lineNum">     190 </span>            : </a>
<a name="191"><span class="lineNum">     191 </span>            :   // DQ (2/7/2019): Namen qualification can under rare circumstances depend on the type.</a>
<a name="192"><span class="lineNum">     192 </span>            :      usingPointerToMemberType = NULL;</a>
<a name="193"><span class="lineNum">     193 </span>            : </a>
<a name="194"><span class="lineNum">     194 </span>            :   // DQ (2/7/2019): Name qualification can under rare circumstances depends on the type.</a>
<a name="195"><span class="lineNum">     195 </span>            :      containsFunctionArgumentsOfPointerMemberType = false;</a>
<a name="196"><span class="lineNum">     196 </span>            : #endif</a>
<a name="197"><span class="lineNum">     197 </span><span class="lineCov">     271932 :    }</span></a>
<a name="198"><span class="lineNum">     198 </span>            : </a>
<a name="199"><span class="lineNum">     199 </span><span class="lineCov">   13858600 : NameQualificationInheritedAttribute::NameQualificationInheritedAttribute ( const NameQualificationInheritedAttribute &amp; X )</span></a>
<a name="200"><span class="lineNum">     200 </span>            :    {</a>
<a name="201"><span class="lineNum">     201 </span>            :   // Copy constructor.</a>
<a name="202"><span class="lineNum">     202 </span>            : </a>
<a name="203"><span class="lineNum">     203 </span>            :   // DQ (5/24/2013): Allow the current scope to be tracked from the traversal of the AST</a>
<a name="204"><span class="lineNum">     204 </span>            :   // instead of being computed at each IR node which is a problem for template arguments.</a>
<a name="205"><span class="lineNum">     205 </span>            :   // See test2013_187.C for an example of this.</a>
<a name="206"><span class="lineNum">     206 </span><span class="lineCov">   13858600 :      currentScope     = X.currentScope;</span></a>
<a name="207"><span class="lineNum">     207 </span><span class="lineCov">   13858600 :      currentStatement = X.currentStatement;</span></a>
<a name="208"><span class="lineNum">     208 </span><span class="lineCov">   13858600 :      referenceNode    = X.referenceNode;</span></a>
<a name="209"><span class="lineNum">     209 </span>            : </a>
<a name="210"><span class="lineNum">     210 </span>            : #if 0</a>
<a name="211"><span class="lineNum">     211 </span>            :   // DQ (8/1/2020): Need to copy the STL map.</a>
<a name="212"><span class="lineNum">     212 </span>            :      namespaceAliasDeclarationMap = X.namespaceAliasDeclarationMap;</a>
<a name="213"><span class="lineNum">     213 </span>            : #endif</a>
<a name="214"><span class="lineNum">     214 </span>            : #if 0</a>
<a name="215"><span class="lineNum">     215 </span>            :   // DQ (2/8/2019): And then I woke up in the morning and had a better idea.</a>
<a name="216"><span class="lineNum">     216 </span>            : </a>
<a name="217"><span class="lineNum">     217 </span>            :   // DQ (2/7/2019): Name qualification can under rare circumstances depends on the type.</a>
<a name="218"><span class="lineNum">     218 </span>            :      usingPointerToMemberType = X.usingPointerToMemberType;</a>
<a name="219"><span class="lineNum">     219 </span>            : </a>
<a name="220"><span class="lineNum">     220 </span>            :   // DQ (2/7/2019): Namen qualification can under rare circumstances depend on the type.</a>
<a name="221"><span class="lineNum">     221 </span>            :      containsFunctionArgumentsOfPointerMemberType = X.containsFunctionArgumentsOfPointerMemberType;</a>
<a name="222"><span class="lineNum">     222 </span>            : #endif</a>
<a name="223"><span class="lineNum">     223 </span>            : #if 0</a>
<a name="224"><span class="lineNum">     224 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationInheritedAttribute(): copy constructor: currentScope     = %p = %s \n&quot;,currentScope,currentScope != NULL ? currentScope-&gt;class_name().c_str() : &quot;NULL&quot;);</a>
<a name="225"><span class="lineNum">     225 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationInheritedAttribute(): copy constructor: currentStatement = %p = %s \n&quot;,currentStatement,currentStatement != NULL ? currentStatement-&gt;class_name().c_str() : &quot;NULL&quot;);</a>
<a name="226"><span class="lineNum">     226 </span>            : #endif</a>
<a name="227"><span class="lineNum">     227 </span><span class="lineCov">   13858600 :    }</span></a>
<a name="228"><span class="lineNum">     228 </span>            : </a>
<a name="229"><span class="lineNum">     229 </span><span class="lineCov">    2838170 : SgScopeStatement* NameQualificationInheritedAttribute::get_currentScope()</span></a>
<a name="230"><span class="lineNum">     230 </span>            :    {</a>
<a name="231"><span class="lineNum">     231 </span><span class="lineCov">    2838170 :      return currentScope;</span></a>
<a name="232"><span class="lineNum">     232 </span>            :    }</a>
<a name="233"><span class="lineNum">     233 </span>            : </a>
<a name="234"><span class="lineNum">     234 </span><span class="lineCov">     337606 : void NameQualificationInheritedAttribute::set_currentScope(SgScopeStatement* scope)</span></a>
<a name="235"><span class="lineNum">     235 </span>            :    {</a>
<a name="236"><span class="lineNum">     236 </span><span class="lineCov">     337606 :      currentScope = scope;</span></a>
<a name="237"><span class="lineNum">     237 </span><span class="lineCov">     337606 :    }</span></a>
<a name="238"><span class="lineNum">     238 </span>            : </a>
<a name="239"><span class="lineNum">     239 </span><span class="lineCov">        382 : SgStatement* NameQualificationInheritedAttribute::get_currentStatement()</span></a>
<a name="240"><span class="lineNum">     240 </span>            :    {</a>
<a name="241"><span class="lineNum">     241 </span><span class="lineCov">        382 :      return currentStatement;</span></a>
<a name="242"><span class="lineNum">     242 </span>            :    }</a>
<a name="243"><span class="lineNum">     243 </span>            : </a>
<a name="244"><span class="lineNum">     244 </span><span class="lineCov">     271866 : void NameQualificationInheritedAttribute::set_currentStatement(SgStatement* statement)</span></a>
<a name="245"><span class="lineNum">     245 </span>            :    {</a>
<a name="246"><span class="lineNum">     246 </span><span class="lineCov">     271866 :      currentStatement = statement;</span></a>
<a name="247"><span class="lineNum">     247 </span><span class="lineCov">     271866 :    }</span></a>
<a name="248"><span class="lineNum">     248 </span>            : </a>
<a name="249"><span class="lineNum">     249 </span><span class="lineCov">    2810820 : SgNode* NameQualificationInheritedAttribute::get_referenceNode()</span></a>
<a name="250"><span class="lineNum">     250 </span>            :    {</a>
<a name="251"><span class="lineNum">     251 </span><span class="lineCov">    2810820 :      return referenceNode;</span></a>
<a name="252"><span class="lineNum">     252 </span>            :    }</a>
<a name="253"><span class="lineNum">     253 </span>            : </a>
<a name="254"><span class="lineNum">     254 </span><span class="lineCov">     271866 : void NameQualificationInheritedAttribute::set_referenceNode(SgNode* node)</span></a>
<a name="255"><span class="lineNum">     255 </span>            :    {</a>
<a name="256"><span class="lineNum">     256 </span><span class="lineCov">     271866 :      referenceNode = node;</span></a>
<a name="257"><span class="lineNum">     257 </span><span class="lineCov">     271866 :    }</span></a>
<a name="258"><span class="lineNum">     258 </span>            : </a>
<a name="259"><span class="lineNum">     259 </span>            : #if 0</a>
<a name="260"><span class="lineNum">     260 </span>            : NameQualificationInheritedAttribute::namespaceAliasMapType &amp;</a>
<a name="261"><span class="lineNum">     261 </span>            : NameQualificationInheritedAttribute::get_namespaceAliasDeclarationMap()</a>
<a name="262"><span class="lineNum">     262 </span>            :    {</a>
<a name="263"><span class="lineNum">     263 </span>            :      return namespaceAliasDeclarationMap;</a>
<a name="264"><span class="lineNum">     264 </span>            :    }</a>
<a name="265"><span class="lineNum">     265 </span>            : #endif</a>
<a name="266"><span class="lineNum">     266 </span>            : </a>
<a name="267"><span class="lineNum">     267 </span>            : #if 0</a>
<a name="268"><span class="lineNum">     268 </span>            :   // DQ (2/8/2019): And then I woke up in the morning and had a better idea.</a>
<a name="269"><span class="lineNum">     269 </span>            : </a>
<a name="270"><span class="lineNum">     270 </span>            : SgPointerMemberType* NameQualificationInheritedAttribute::get_usingPointerToMemberType()</a>
<a name="271"><span class="lineNum">     271 </span>            :    {</a>
<a name="272"><span class="lineNum">     272 </span>            :      return usingPointerToMemberType;</a>
<a name="273"><span class="lineNum">     273 </span>            :    }</a>
<a name="274"><span class="lineNum">     274 </span>            : </a>
<a name="275"><span class="lineNum">     275 </span>            : void NameQualificationInheritedAttribute::set_usingPointerToMemberType(SgPointerMemberType* type)</a>
<a name="276"><span class="lineNum">     276 </span>            :    {</a>
<a name="277"><span class="lineNum">     277 </span>            :      usingPointerToMemberType = type;</a>
<a name="278"><span class="lineNum">     278 </span>            :    }</a>
<a name="279"><span class="lineNum">     279 </span>            : </a>
<a name="280"><span class="lineNum">     280 </span>            : bool NameQualificationInheritedAttribute::get_containsFunctionArgumentsOfPointerMemberType()</a>
<a name="281"><span class="lineNum">     281 </span>            :    {</a>
<a name="282"><span class="lineNum">     282 </span>            :      return containsFunctionArgumentsOfPointerMemberType;</a>
<a name="283"><span class="lineNum">     283 </span>            :    }</a>
<a name="284"><span class="lineNum">     284 </span>            : </a>
<a name="285"><span class="lineNum">     285 </span>            : void NameQualificationInheritedAttribute::set_containsFunctionArgumentsOfPointerMemberType( bool x )</a>
<a name="286"><span class="lineNum">     286 </span>            :    {</a>
<a name="287"><span class="lineNum">     287 </span>            :      containsFunctionArgumentsOfPointerMemberType = x;</a>
<a name="288"><span class="lineNum">     288 </span>            :    }</a>
<a name="289"><span class="lineNum">     289 </span>            : #endif</a>
<a name="290"><span class="lineNum">     290 </span>            : </a>
<a name="291"><span class="lineNum">     291 </span>            : // *********************</a>
<a name="292"><span class="lineNum">     292 </span>            : // Synthesized Attribute</a>
<a name="293"><span class="lineNum">     293 </span>            : // *********************</a>
<a name="294"><span class="lineNum">     294 </span>            : </a>
<a name="295"><span class="lineNum">     295 </span><span class="lineCov">    2072990 : NameQualificationSynthesizedAttribute::NameQualificationSynthesizedAttribute()</span></a>
<a name="296"><span class="lineNum">     296 </span>            :    {</a>
<a name="297"><span class="lineNum">     297 </span>            :   // Default constructor</a>
<a name="298"><span class="lineNum">     298 </span><span class="lineCov">    2072990 :      node = NULL;</span></a>
<a name="299"><span class="lineNum">     299 </span><span class="lineCov">    2072990 :    }</span></a>
<a name="300"><span class="lineNum">     300 </span>            : </a>
<a name="301"><span class="lineNum">     301 </span><span class="lineCov">    2810440 : NameQualificationSynthesizedAttribute::NameQualificationSynthesizedAttribute( SgNode* astNode )</span></a>
<a name="302"><span class="lineNum">     302 </span>            :    {</a>
<a name="303"><span class="lineNum">     303 </span>            :   // DQ (8/2/2020): Added support for debugging.</a>
<a name="304"><span class="lineNum">     304 </span><span class="lineCov">    2810440 :      node = astNode;</span></a>
<a name="305"><span class="lineNum">     305 </span><span class="lineCov">    2810440 :    }</span></a>
<a name="306"><span class="lineNum">     306 </span>            : </a>
<a name="307"><span class="lineNum">     307 </span>            : </a>
<a name="308"><span class="lineNum">     308 </span><span class="lineCov">    6731960 : NameQualificationSynthesizedAttribute::NameQualificationSynthesizedAttribute ( const NameQualificationSynthesizedAttribute &amp; X )</span></a>
<a name="309"><span class="lineNum">     309 </span>            :    {</a>
<a name="310"><span class="lineNum">     310 </span>            :   // Copy constructor.</a>
<a name="311"><span class="lineNum">     311 </span>            : </a>
<a name="312"><span class="lineNum">     312 </span>            :   // DQ (8/2/2020): Added support for debugging.</a>
<a name="313"><span class="lineNum">     313 </span><span class="lineCov">    6731960 :      node = X.node;</span></a>
<a name="314"><span class="lineNum">     314 </span><span class="lineCov">    6731960 :    }</span></a>
<a name="315"><span class="lineNum">     315 </span>            : </a>
<a name="316"><span class="lineNum">     316 </span>            : </a>
<a name="317"><span class="lineNum">     317 </span>            : // *******************</a>
<a name="318"><span class="lineNum">     318 </span>            : // NameQualificationTraversal</a>
<a name="319"><span class="lineNum">     319 </span>            : // *******************</a>
<a name="320"><span class="lineNum">     320 </span>            : </a>
<a name="321"><span class="lineNum">     321 </span><span class="lineCov">     271932 : NameQualificationTraversal::NameQualificationTraversal(</span></a>
<a name="322"><span class="lineNum">     322 </span>            :      std::map&lt;SgNode*,std::string&gt; &amp; input_qualifiedNameMapForNames,</a>
<a name="323"><span class="lineNum">     323 </span>            :      std::map&lt;SgNode*,std::string&gt; &amp; input_qualifiedNameMapForTypes,</a>
<a name="324"><span class="lineNum">     324 </span>            :      std::map&lt;SgNode*,std::string&gt; &amp; input_qualifiedNameMapForTemplateHeaders,</a>
<a name="325"><span class="lineNum">     325 </span>            :      std::map&lt;SgNode*,std::string&gt; &amp; input_typeNameMap,</a>
<a name="326"><span class="lineNum">     326 </span>            :      std::map&lt;SgNode*,std::map&lt;SgNode*,std::string&gt; &gt; &amp; input_qualifiedNameMapForMapsOfTypes,</a>
<a name="327"><span class="lineNum">     327 </span><span class="lineCov">     271932 :      std::set&lt;SgNode*&gt; &amp; input_referencedNameSet)</span></a>
<a name="328"><span class="lineNum">     328 </span>            :    : referencedNameSet(input_referencedNameSet),</a>
<a name="329"><span class="lineNum">     329 </span>            :      qualifiedNameMapForNames(input_qualifiedNameMapForNames),</a>
<a name="330"><span class="lineNum">     330 </span>            :      qualifiedNameMapForTypes(input_qualifiedNameMapForTypes),</a>
<a name="331"><span class="lineNum">     331 </span>            :      qualifiedNameMapForTemplateHeaders(input_qualifiedNameMapForTemplateHeaders),</a>
<a name="332"><span class="lineNum">     332 </span>            :      typeNameMap(input_typeNameMap),</a>
<a name="333"><span class="lineNum">     333 </span><span class="lineCov">     271932 :      qualifiedNameMapForMapsOfTypes(input_qualifiedNameMapForMapsOfTypes)</span></a>
<a name="334"><span class="lineNum">     334 </span>            :    {</a>
<a name="335"><span class="lineNum">     335 </span>            :   // Nothing to do here.</a>
<a name="336"><span class="lineNum">     336 </span>            : </a>
<a name="337"><span class="lineNum">     337 </span><span class="lineCov">     271932 :      explictlySpecifiedCurrentScope     = NULL;</span></a>
<a name="338"><span class="lineNum">     338 </span><span class="lineCov">     271932 :      explictlySpecifiedCurrentStatement = NULL;</span></a>
<a name="339"><span class="lineNum">     339 </span>            : </a>
<a name="340"><span class="lineNum">     340 </span>            : #if 0</a>
<a name="341"><span class="lineNum">     341 </span>            :   // DQ (8/3/2019): Output a message so that I can verify this is called one per file.</a>
<a name="342"><span class="lineNum">     342 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;Inside NameQualificationTraversal() constructor \n&quot;);</a>
<a name="343"><span class="lineNum">     343 </span>            : #endif</a>
<a name="344"><span class="lineNum">     344 </span>            : </a>
<a name="345"><span class="lineNum">     345 </span>            :   // DQ (8/3/2019): Reset the static data member that holds the aliasSymbolCausalNodeSet.</a>
<a name="346"><span class="lineNum">     346 </span><span class="lineCov">     271932 :      SgSymbolTable::get_aliasSymbolCausalNodeSet().clear();</span></a>
<a name="347"><span class="lineNum">     347 </span><span class="lineCov">     271932 :      ROSE_ASSERT(SgSymbolTable::get_aliasSymbolCausalNodeSet().empty() == true);</span></a>
<a name="348"><span class="lineNum">     348 </span>            : </a>
<a name="349"><span class="lineNum">     349 </span><span class="lineCov">     271932 :      declarationSet = NULL;</span></a>
<a name="350"><span class="lineNum">     350 </span><span class="lineCov">     271932 :    }</span></a>
<a name="351"><span class="lineNum">     351 </span>            : </a>
<a name="352"><span class="lineNum">     352 </span>            : </a>
<a name="353"><span class="lineNum">     353 </span>            : // DQ (5/28/2011): Added support to set the static global qualified name map in SgNode.</a>
<a name="354"><span class="lineNum">     354 </span>            : const std::map&lt;SgNode*,std::string&gt; &amp;</a>
<a name="355"><span class="lineNum">     355 </span><span class="lineNoCov">          0 : NameQualificationTraversal::get_qualifiedNameMapForNames() const</span></a>
<a name="356"><span class="lineNum">     356 </span>            :    {</a>
<a name="357"><span class="lineNum">     357 </span><span class="lineNoCov">          0 :      return qualifiedNameMapForNames;</span></a>
<a name="358"><span class="lineNum">     358 </span>            :    }</a>
<a name="359"><span class="lineNum">     359 </span>            : </a>
<a name="360"><span class="lineNum">     360 </span>            : // DQ (5/28/2011): Added support to set the static global qualified name map in SgNode.</a>
<a name="361"><span class="lineNum">     361 </span>            : const std::map&lt;SgNode*,std::string&gt; &amp;</a>
<a name="362"><span class="lineNum">     362 </span><span class="lineNoCov">          0 : NameQualificationTraversal::get_qualifiedNameMapForTypes() const</span></a>
<a name="363"><span class="lineNum">     363 </span>            :    {</a>
<a name="364"><span class="lineNum">     364 </span><span class="lineNoCov">          0 :      return qualifiedNameMapForTypes;</span></a>
<a name="365"><span class="lineNum">     365 </span>            :    }</a>
<a name="366"><span class="lineNum">     366 </span>            : </a>
<a name="367"><span class="lineNum">     367 </span>            : // DQ (3/13/2019): Added support to set the static global qualified name map in SgNode.</a>
<a name="368"><span class="lineNum">     368 </span>            : const std::map&lt;SgNode*,std::map&lt;SgNode*,std::string&gt; &gt; &amp;</a>
<a name="369"><span class="lineNum">     369 </span><span class="lineNoCov">          0 : NameQualificationTraversal::get_qualifiedNameMapForMapsOfTypes() const</span></a>
<a name="370"><span class="lineNum">     370 </span>            :    {</a>
<a name="371"><span class="lineNum">     371 </span><span class="lineNoCov">          0 :      return qualifiedNameMapForMapsOfTypes;</span></a>
<a name="372"><span class="lineNum">     372 </span>            :    }</a>
<a name="373"><span class="lineNum">     373 </span>            : </a>
<a name="374"><span class="lineNum">     374 </span>            : // DQ (9/7/2014): Added support to set the template headers in template declarations.</a>
<a name="375"><span class="lineNum">     375 </span>            : const std::map&lt;SgNode*,std::string&gt; &amp;</a>
<a name="376"><span class="lineNum">     376 </span><span class="lineNoCov">          0 : NameQualificationTraversal::get_qualifiedNameMapForTemplateHeaders() const</span></a>
<a name="377"><span class="lineNum">     377 </span>            :    {</a>
<a name="378"><span class="lineNum">     378 </span><span class="lineNoCov">          0 :      return qualifiedNameMapForTemplateHeaders;</span></a>
<a name="379"><span class="lineNum">     379 </span>            :    }</a>
<a name="380"><span class="lineNum">     380 </span>            : </a>
<a name="381"><span class="lineNum">     381 </span>            : </a>
<a name="382"><span class="lineNum">     382 </span>            : int</a>
<a name="383"><span class="lineNum">     383 </span><span class="lineNoCov">          0 : numberOfSymbolsWithName( const SgName &amp; name, SgScopeStatement* scope )</span></a>
<a name="384"><span class="lineNum">     384 </span>            :    {</a>
<a name="385"><span class="lineNum">     385 </span>            :   // DQ (6/20/2011): This function counts the number of symbols associated with the same name.</a>
<a name="386"><span class="lineNum">     386 </span>            :   // This function should be put into the SgScopeStatement for more general use.</a>
<a name="387"><span class="lineNum">     387 </span>            : </a>
<a name="388"><span class="lineNum">     388 </span>            :   // We might have to have separate functions specific to functions, variables, etc.</a>
<a name="389"><span class="lineNum">     389 </span>            :   // This function addresses a requirement associated with a bug demonstrated by test2011_84.C.</a>
<a name="390"><span class="lineNum">     390 </span>            : </a>
<a name="391"><span class="lineNum">     391 </span><span class="lineNoCov">          0 :      ASSERT_not_null(scope);</span></a>
<a name="392"><span class="lineNum">     392 </span><span class="lineNoCov">          0 :      SgSymbol* symbol = scope-&gt;lookup_function_symbol(name);</span></a>
<a name="393"><span class="lineNum">     393 </span>            : </a>
<a name="394"><span class="lineNum">     394 </span><span class="lineNoCov">          0 :      int count = 0;</span></a>
<a name="395"><span class="lineNum">     395 </span>            : </a>
<a name="396"><span class="lineNum">     396 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="397"><span class="lineNum">     397 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In numberOfSymbolsWithName(): symbol = %p scope = %p = %s \n&quot;,symbol,scope,scope-&gt;class_name().c_str());</a>
<a name="398"><span class="lineNum">     398 </span>            : #endif</a>
<a name="399"><span class="lineNum">     399 </span>            : </a>
<a name="400"><span class="lineNum">     400 </span><span class="lineNoCov">          0 :      while (symbol != NULL)</span></a>
<a name="401"><span class="lineNum">     401 </span>            :         {</a>
<a name="402"><span class="lineNum">     402 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="403"><span class="lineNum">     403 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;     In loop: symbol = %p = %s \n&quot;,symbol,symbol-&gt;class_name().c_str());</a>
<a name="404"><span class="lineNum">     404 </span>            : #endif</a>
<a name="405"><span class="lineNum">     405 </span><span class="lineNoCov">          0 :           count++;</span></a>
<a name="406"><span class="lineNum">     406 </span><span class="lineNoCov">          0 :           symbol = scope-&gt;next_any_symbol();</span></a>
<a name="407"><span class="lineNum">     407 </span>            :         }</a>
<a name="408"><span class="lineNum">     408 </span>            : </a>
<a name="409"><span class="lineNum">     409 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="410"><span class="lineNum">     410 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In numberOfSymbolsWithName(): count = %d \n&quot;,count);</a>
<a name="411"><span class="lineNum">     411 </span>            : #endif</a>
<a name="412"><span class="lineNum">     412 </span>            : </a>
<a name="413"><span class="lineNum">     413 </span><span class="lineNoCov">          0 :      return count;</span></a>
<a name="414"><span class="lineNum">     414 </span>            :    }</a>
<a name="415"><span class="lineNum">     415 </span>            : </a>
<a name="416"><span class="lineNum">     416 </span>            : SgDeclarationStatement*</a>
<a name="417"><span class="lineNum">     417 </span><span class="lineCov">     139543 : NameQualificationTraversal::associatedDeclaration(SgScopeStatement* scope)</span></a>
<a name="418"><span class="lineNum">     418 </span>            :    {</a>
<a name="419"><span class="lineNum">     419 </span><span class="lineCov">     139543 :      SgDeclarationStatement* return_declaration = NULL;</span></a>
<a name="420"><span class="lineNum">     420 </span><span class="lineCov">     139543 :      switch (scope-&gt;variantT())</span></a>
<a name="421"><span class="lineNum">     421 </span>            :         {</a>
<a name="422"><span class="lineNum">     422 </span><span class="lineCov">       7927 :           case V_SgClassDefinition:</span></a>
<a name="423"><span class="lineNum">     423 </span><span class="lineCov">       7927 :              {</span></a>
<a name="424"><span class="lineNum">     424 </span><span class="lineCov">       7927 :                SgClassDefinition* definition = isSgClassDefinition(scope);</span></a>
<a name="425"><span class="lineNum">     425 </span><span class="lineCov">       7927 :                ASSERT_not_null(definition);</span></a>
<a name="426"><span class="lineNum">     426 </span>            : </a>
<a name="427"><span class="lineNum">     427 </span><span class="lineCov">       7927 :                SgClassDeclaration* declaration = definition-&gt;get_declaration();</span></a>
<a name="428"><span class="lineNum">     428 </span><span class="lineCov">       7927 :                ASSERT_not_null(declaration);</span></a>
<a name="429"><span class="lineNum">     429 </span>            : </a>
<a name="430"><span class="lineNum">     430 </span><span class="lineCov">       7927 :                return_declaration = declaration;</span></a>
<a name="431"><span class="lineNum">     431 </span><span class="lineCov">       7927 :                break;</span></a>
<a name="432"><span class="lineNum">     432 </span>            :              }</a>
<a name="433"><span class="lineNum">     433 </span>            : </a>
<a name="434"><span class="lineNum">     434 </span>            :        // DQ (11/20/2011): Added support for template declarations (template class declarations)</a>
<a name="435"><span class="lineNum">     435 </span><span class="lineCov">      12027 :           case V_SgTemplateClassDefinition:</span></a>
<a name="436"><span class="lineNum">     436 </span><span class="lineCov">      12027 :              {</span></a>
<a name="437"><span class="lineNum">     437 </span><span class="lineCov">      12027 :                SgTemplateClassDefinition* definition = isSgTemplateClassDefinition(scope);</span></a>
<a name="438"><span class="lineNum">     438 </span><span class="lineCov">      12027 :                ASSERT_not_null(definition);</span></a>
<a name="439"><span class="lineNum">     439 </span>            : </a>
<a name="440"><span class="lineNum">     440 </span><span class="lineCov">      12027 :                SgTemplateClassDeclaration* declaration = definition-&gt;get_declaration();</span></a>
<a name="441"><span class="lineNum">     441 </span><span class="lineCov">      12027 :                ASSERT_not_null(declaration);</span></a>
<a name="442"><span class="lineNum">     442 </span>            : </a>
<a name="443"><span class="lineNum">     443 </span><span class="lineCov">      12027 :                return_declaration = declaration;</span></a>
<a name="444"><span class="lineNum">     444 </span><span class="lineCov">      12027 :                break;</span></a>
<a name="445"><span class="lineNum">     445 </span>            :              }</a>
<a name="446"><span class="lineNum">     446 </span>            : </a>
<a name="447"><span class="lineNum">     447 </span><span class="lineCov">      57006 :           case V_SgNamespaceDefinitionStatement:</span></a>
<a name="448"><span class="lineNum">     448 </span><span class="lineCov">      57006 :              {</span></a>
<a name="449"><span class="lineNum">     449 </span><span class="lineCov">      57006 :                SgNamespaceDefinitionStatement* definition = isSgNamespaceDefinitionStatement(scope);</span></a>
<a name="450"><span class="lineNum">     450 </span><span class="lineCov">      57006 :                ASSERT_not_null(definition);</span></a>
<a name="451"><span class="lineNum">     451 </span>            : </a>
<a name="452"><span class="lineNum">     452 </span>            :             // Let the first definition be used to get the associated first declaration so that we</a>
<a name="453"><span class="lineNum">     453 </span>            :             // are always refering to a consistant declaration for any chain of namespaces.  If not</a>
<a name="454"><span class="lineNum">     454 </span>            :             // the first then perhaps the last?</a>
<a name="455"><span class="lineNum">     455 </span><span class="lineCov">      91851 :                while (definition-&gt;get_previousNamespaceDefinition() != NULL)</span></a>
<a name="456"><span class="lineNum">     456 </span>            :                   {</a>
<a name="457"><span class="lineNum">     457 </span>            :                  // mfprintf(mlog [ WARN ] ) (&quot;Iterating through the namespace chain... \n&quot;);</a>
<a name="458"><span class="lineNum">     458 </span><span class="lineCov">      34845 :                     definition = definition-&gt;get_previousNamespaceDefinition();</span></a>
<a name="459"><span class="lineNum">     459 </span>            :                   }</a>
<a name="460"><span class="lineNum">     460 </span>            : </a>
<a name="461"><span class="lineNum">     461 </span><span class="lineCov">      57006 :                SgNamespaceDeclarationStatement* declaration = definition-&gt;get_namespaceDeclaration();</span></a>
<a name="462"><span class="lineNum">     462 </span><span class="lineCov">      57006 :                ASSERT_not_null(declaration);</span></a>
<a name="463"><span class="lineNum">     463 </span>            : </a>
<a name="464"><span class="lineNum">     464 </span><span class="lineCov">      57006 :                return_declaration = declaration;</span></a>
<a name="465"><span class="lineNum">     465 </span><span class="lineCov">      57006 :                break;</span></a>
<a name="466"><span class="lineNum">     466 </span>            :              }</a>
<a name="467"><span class="lineNum">     467 </span>            : </a>
<a name="468"><span class="lineNum">     468 </span><span class="lineCov">      19988 :           case V_SgTemplateInstantiationDefn:</span></a>
<a name="469"><span class="lineNum">     469 </span><span class="lineCov">      19988 :              {</span></a>
<a name="470"><span class="lineNum">     470 </span><span class="lineCov">      19988 :                SgTemplateInstantiationDefn* definition = isSgTemplateInstantiationDefn(scope);</span></a>
<a name="471"><span class="lineNum">     471 </span><span class="lineCov">      19988 :                ASSERT_not_null(definition);</span></a>
<a name="472"><span class="lineNum">     472 </span>            : </a>
<a name="473"><span class="lineNum">     473 </span><span class="lineCov">      19988 :                SgTemplateInstantiationDecl* declaration = isSgTemplateInstantiationDecl(definition-&gt;get_declaration());</span></a>
<a name="474"><span class="lineNum">     474 </span><span class="lineCov">      19988 :                ASSERT_not_null(declaration);</span></a>
<a name="475"><span class="lineNum">     475 </span>            : </a>
<a name="476"><span class="lineNum">     476 </span><span class="lineCov">      19988 :                return_declaration = declaration;</span></a>
<a name="477"><span class="lineNum">     477 </span><span class="lineCov">      19988 :                break;</span></a>
<a name="478"><span class="lineNum">     478 </span>            :              }</a>
<a name="479"><span class="lineNum">     479 </span>            : </a>
<a name="480"><span class="lineNum">     480 </span>            :        // DQ (7/11/2014): Added this case to support test2014_84.C.</a>
<a name="481"><span class="lineNum">     481 </span><span class="lineNoCov">          0 :           case V_SgFunctionDefinition:</span></a>
<a name="482"><span class="lineNum">     482 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="483"><span class="lineNum">     483 </span><span class="lineNoCov">          0 :                SgFunctionDefinition* definition = isSgFunctionDefinition(scope);</span></a>
<a name="484"><span class="lineNum">     484 </span><span class="lineNoCov">          0 :                ASSERT_not_null(definition);</span></a>
<a name="485"><span class="lineNum">     485 </span>            : </a>
<a name="486"><span class="lineNum">     486 </span><span class="lineNoCov">          0 :                SgFunctionDeclaration* declaration = isSgFunctionDeclaration(definition-&gt;get_declaration());</span></a>
<a name="487"><span class="lineNum">     487 </span><span class="lineNoCov">          0 :                ASSERT_not_null(declaration);</span></a>
<a name="488"><span class="lineNum">     488 </span>            : </a>
<a name="489"><span class="lineNum">     489 </span><span class="lineNoCov">          0 :                return_declaration = declaration;</span></a>
<a name="490"><span class="lineNum">     490 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="491"><span class="lineNum">     491 </span>            :              }</a>
<a name="492"><span class="lineNum">     492 </span>            : </a>
<a name="493"><span class="lineNum">     493 </span>            :        // DQ (7/19/2017): Adding support for new SgDeclarationScope, though it might be that we want the parent defining or non-defining declaration.</a>
<a name="494"><span class="lineNum">     494 </span>            :           case V_SgDeclarationScope:</a>
<a name="495"><span class="lineNum">     495 </span>            : </a>
<a name="496"><span class="lineNum">     496 </span>            :        // DQ (6/26/2019): Added rage-based for loop (see test2019_483.C).</a>
<a name="497"><span class="lineNum">     497 </span>            :           case V_SgRangeBasedForStatement:</a>
<a name="498"><span class="lineNum">     498 </span>            : </a>
<a name="499"><span class="lineNum">     499 </span>            :        // Some scopes don't have an associated declaration (return NULL in these cases).</a>
<a name="500"><span class="lineNum">     500 </span>            :        // Also missing some of the Fortran specific scopes.</a>
<a name="501"><span class="lineNum">     501 </span>            :           case V_SgGlobal:</a>
<a name="502"><span class="lineNum">     502 </span>            :           case V_SgIfStmt:</a>
<a name="503"><span class="lineNum">     503 </span>            :           case V_SgWhileStmt:</a>
<a name="504"><span class="lineNum">     504 </span>            :           case V_SgDoWhileStmt:</a>
<a name="505"><span class="lineNum">     505 </span>            :           case V_SgForStatement:</a>
<a name="506"><span class="lineNum">     506 </span>            :           case V_SgForAllStatement:</a>
<a name="507"><span class="lineNum">     507 </span>            :           case V_SgBasicBlock:</a>
<a name="508"><span class="lineNum">     508 </span>            :           case V_SgSwitchStatement:</a>
<a name="509"><span class="lineNum">     509 </span>            :           case V_SgCatchOptionStmt:</a>
<a name="510"><span class="lineNum">     510 </span>            :           case V_SgUpcForAllStatement:</a>
<a name="511"><span class="lineNum">     511 </span>            :              {</a>
<a name="512"><span class="lineNum">     512 </span>            :                return_declaration = NULL;</a>
<a name="513"><span class="lineNum">     513 </span>            :                break;</a>
<a name="514"><span class="lineNum">     514 </span>            :              }</a>
<a name="515"><span class="lineNum">     515 </span>            : </a>
<a name="516"><span class="lineNum">     516 </span>            :        // Catch anything that migh have been missed (and exit so it can be identified and fixed).</a>
<a name="517"><span class="lineNum">     517 </span><span class="lineNoCov">          0 :           default:</span></a>
<a name="518"><span class="lineNum">     518 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="519"><span class="lineNum">     519 </span><span class="lineNoCov">          0 :                mfprintf(mlog [ WARN ] ) (&quot;Default reached in NameQualificationTraversal::associatedDeclaration() scope = %s \n&quot;,scope-&gt;class_name().c_str());</span></a>
<a name="520"><span class="lineNum">     520 </span><span class="lineNoCov">          0 :                ROSE_ABORT();</span></a>
<a name="521"><span class="lineNum">     521 </span>            :              }</a>
<a name="522"><span class="lineNum">     522 </span>            :         }</a>
<a name="523"><span class="lineNum">     523 </span>            : </a>
<a name="524"><span class="lineNum">     524 </span><span class="lineCov">     139543 :      return return_declaration;</span></a>
<a name="525"><span class="lineNum">     525 </span>            :    }</a>
<a name="526"><span class="lineNum">     526 </span>            : </a>
<a name="527"><span class="lineNum">     527 </span>            : SgDeclarationStatement*</a>
<a name="528"><span class="lineNum">     528 </span><span class="lineCov">    1483520 : NameQualificationTraversal::associatedDeclaration(SgType* type)</span></a>
<a name="529"><span class="lineNum">     529 </span>            :    {</a>
<a name="530"><span class="lineNum">     530 </span><span class="lineCov">    1483520 :      SgDeclarationStatement* return_declaration = NULL;</span></a>
<a name="531"><span class="lineNum">     531 </span>            : </a>
<a name="532"><span class="lineNum">     532 </span>            :   // DQ (1/26/2013): Added assertion.</a>
<a name="533"><span class="lineNum">     533 </span><span class="lineCov">    1483520 :      ASSERT_not_null(type);</span></a>
<a name="534"><span class="lineNum">     534 </span>            : </a>
<a name="535"><span class="lineNum">     535 </span>            :   // DQ (4/15/2019): This is a new default that appears to work well for all of our ROSE regression tests.</a>
<a name="536"><span class="lineNum">     536 </span>            :   // mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::associatedDeclaration(): Calling stripType() with SgType::STRIP_POINTER_MEMBER_TYPE explicitly \n&quot;);</a>
<a name="537"><span class="lineNum">     537 </span>            : </a>
<a name="538"><span class="lineNum">     538 </span>            :   // DQ (Don't skip over SgPointerMemberType.</a>
<a name="539"><span class="lineNum">     539 </span>            :   // DQ (4/15/2019): Adding SgType::STRIP_POINTER_MEMBER_TYPE to the stripType() call.</a>
<a name="540"><span class="lineNum">     540 </span>            :   // We want to strip away all by typedef types.</a>
<a name="541"><span class="lineNum">     541 </span>            :   // SgType* strippedType = type-&gt;stripType(SgType::STRIP_MODIFIER_TYPE|SgType::STRIP_REFERENCE_TYPE|SgType::STRIP_RVALUE_REFERENCE_TYPE|SgType::STRIP_POINTER_TYPE|SgType::STRIP_ARRAY_TYPE);</a>
<a name="542"><span class="lineNum">     542 </span>            :   // SgType* strippedType = type-&gt;stripType(SgType::STRIP_MODIFIER_TYPE|SgType::STRIP_REFERENCE_TYPE|SgType::STRIP_RVALUE_REFERENCE_TYPE|SgType::STRIP_POINTER_TYPE|SgType::STRIP_ARRAY_TYPE|SgType::STRIP_POINTER_MEMBER_TYPE);</a>
<a name="543"><span class="lineNum">     543 </span><span class="lineCov">    1483520 :      SgType* strippedType = type-&gt;stripType(SgType::STRIP_MODIFIER_TYPE|SgType::STRIP_REFERENCE_TYPE|SgType::STRIP_RVALUE_REFERENCE_TYPE|SgType::STRIP_POINTER_TYPE|SgType::STRIP_ARRAY_TYPE);</span></a>
<a name="544"><span class="lineNum">     544 </span><span class="lineCov">    1483520 :      ASSERT_not_null(strippedType);</span></a>
<a name="545"><span class="lineNum">     545 </span>            : </a>
<a name="546"><span class="lineNum">     546 </span>            :   // switch (type-&gt;variantT())</a>
<a name="547"><span class="lineNum">     547 </span><span class="lineCov">    1483520 :      switch (strippedType-&gt;variantT())</span></a>
<a name="548"><span class="lineNum">     548 </span>            :         {</a>
<a name="549"><span class="lineNum">     549 </span><span class="lineCov">      32232 :           case V_SgClassType:</span></a>
<a name="550"><span class="lineNum">     550 </span><span class="lineCov">      32232 :              {</span></a>
<a name="551"><span class="lineNum">     551 </span><span class="lineCov">      32232 :                SgClassType* classType = isSgClassType(strippedType);</span></a>
<a name="552"><span class="lineNum">     552 </span><span class="lineCov">      32232 :                ASSERT_not_null(classType);</span></a>
<a name="553"><span class="lineNum">     553 </span>            : </a>
<a name="554"><span class="lineNum">     554 </span><span class="lineCov">      32232 :                SgClassDeclaration* declaration = isSgClassDeclaration(classType-&gt;get_declaration());</span></a>
<a name="555"><span class="lineNum">     555 </span><span class="lineCov">      32232 :                ASSERT_not_null(declaration);</span></a>
<a name="556"><span class="lineNum">     556 </span>            : </a>
<a name="557"><span class="lineNum">     557 </span><span class="lineCov">      32232 :                return_declaration = declaration;</span></a>
<a name="558"><span class="lineNum">     558 </span><span class="lineCov">      32232 :                break;</span></a>
<a name="559"><span class="lineNum">     559 </span>            :              }</a>
<a name="560"><span class="lineNum">     560 </span>            : </a>
<a name="561"><span class="lineNum">     561 </span><span class="lineCov">    1383550 :           case V_SgTypedefType:</span></a>
<a name="562"><span class="lineNum">     562 </span><span class="lineCov">    1383550 :              {</span></a>
<a name="563"><span class="lineNum">     563 </span><span class="lineCov">    1383550 :                SgTypedefType* typedefType = isSgTypedefType(strippedType);</span></a>
<a name="564"><span class="lineNum">     564 </span><span class="lineCov">    1383550 :                ASSERT_not_null(typedefType);</span></a>
<a name="565"><span class="lineNum">     565 </span>            : </a>
<a name="566"><span class="lineNum">     566 </span><span class="lineCov">    1383550 :                SgTypedefDeclaration* declaration = isSgTypedefDeclaration(typedefType-&gt;get_declaration());</span></a>
<a name="567"><span class="lineNum">     567 </span><span class="lineCov">    1383550 :                ASSERT_not_null(declaration);</span></a>
<a name="568"><span class="lineNum">     568 </span>            : </a>
<a name="569"><span class="lineNum">     569 </span><span class="lineCov">    1383550 :                return_declaration = declaration;</span></a>
<a name="570"><span class="lineNum">     570 </span><span class="lineCov">    1383550 :                break;</span></a>
<a name="571"><span class="lineNum">     571 </span>            :              }</a>
<a name="572"><span class="lineNum">     572 </span>            : </a>
<a name="573"><span class="lineNum">     573 </span><span class="lineCov">       2157 :           case V_SgEnumType:</span></a>
<a name="574"><span class="lineNum">     574 </span><span class="lineCov">       2157 :              {</span></a>
<a name="575"><span class="lineNum">     575 </span><span class="lineCov">       2157 :                SgEnumType* enumType = isSgEnumType(strippedType);</span></a>
<a name="576"><span class="lineNum">     576 </span><span class="lineCov">       2157 :                ASSERT_not_null(enumType);</span></a>
<a name="577"><span class="lineNum">     577 </span>            : </a>
<a name="578"><span class="lineNum">     578 </span><span class="lineCov">       2157 :                SgEnumDeclaration* declaration = isSgEnumDeclaration(enumType-&gt;get_declaration());</span></a>
<a name="579"><span class="lineNum">     579 </span><span class="lineCov">       2157 :                ASSERT_not_null(declaration);</span></a>
<a name="580"><span class="lineNum">     580 </span>            : </a>
<a name="581"><span class="lineNum">     581 </span><span class="lineCov">       2157 :                return_declaration = declaration;</span></a>
<a name="582"><span class="lineNum">     582 </span><span class="lineCov">       2157 :                break;</span></a>
<a name="583"><span class="lineNum">     583 </span>            :              }</a>
<a name="584"><span class="lineNum">     584 </span>            : </a>
<a name="585"><span class="lineNum">     585 </span>            :        // DQ (11/20/2011): Adding support for template declarations in the AST.</a>
<a name="586"><span class="lineNum">     586 </span><span class="lineNoCov">          0 :           case V_SgTemplateType:</span></a>
<a name="587"><span class="lineNum">     587 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="588"><span class="lineNum">     588 </span><span class="lineNoCov">          0 :                SgTemplateType* templateType = isSgTemplateType(strippedType);</span></a>
<a name="589"><span class="lineNum">     589 </span><span class="lineNoCov">          0 :                ASSERT_not_null(templateType);</span></a>
<a name="590"><span class="lineNum">     590 </span>            : #if 0</a>
<a name="591"><span class="lineNum">     591 </span>            :                SgTemplateDeclaration* declaration = isSgTemplateDeclaration(templateType-&gt;get_declaration());</a>
<a name="592"><span class="lineNum">     592 </span>            :                ASSERT_not_null(declaration);</a>
<a name="593"><span class="lineNum">     593 </span>            : </a>
<a name="594"><span class="lineNum">     594 </span>            :                return_declaration = declaration;</a>
<a name="595"><span class="lineNum">     595 </span>            : #else</a>
<a name="596"><span class="lineNum">     596 </span><span class="lineNoCov">          0 :                return_declaration = NULL;</span></a>
<a name="597"><span class="lineNum">     597 </span>            : #endif</a>
<a name="598"><span class="lineNum">     598 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="599"><span class="lineNum">     599 </span>            :              }</a>
<a name="600"><span class="lineNum">     600 </span>            : </a>
<a name="601"><span class="lineNum">     601 </span>            :           case V_SgFunctionType:</a>
<a name="602"><span class="lineNum">     602 </span>            :           case V_SgMemberFunctionType:</a>
<a name="603"><span class="lineNum">     603 </span>            :              {</a>
<a name="604"><span class="lineNum">     604 </span>            :             // Not clear if I have to resolve declarations associated with function types.</a>
<a name="605"><span class="lineNum">     605 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 0)</a>
<a name="606"><span class="lineNum">     606 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::associatedDeclaration(): Case of SgFunctionType not implemented strippedType = %s \n&quot;,strippedType-&gt;class_name().c_str());</a>
<a name="607"><span class="lineNum">     607 </span>            : #endif</a>
<a name="608"><span class="lineNum">     608 </span>            :                return_declaration = NULL;</a>
<a name="609"><span class="lineNum">     609 </span>            :                break;</a>
<a name="610"><span class="lineNum">     610 </span>            :              }</a>
<a name="611"><span class="lineNum">     611 </span>            : </a>
<a name="612"><span class="lineNum">     612 </span>            :        // DQ (6/25/2011): Demonstrated by calling unparseToString on all possible type.</a>
<a name="613"><span class="lineNum">     613 </span>            :           case V_SgTypeDefault:</a>
<a name="614"><span class="lineNum">     614 </span>            : </a>
<a name="615"><span class="lineNum">     615 </span>            :        // Some scopes don't have an associated declaration (return NULL in these cases).</a>
<a name="616"><span class="lineNum">     616 </span>            :        // Also missing some of the Fortran specific scopes.</a>
<a name="617"><span class="lineNum">     617 </span>            :           case V_SgTypeInt:</a>
<a name="618"><span class="lineNum">     618 </span>            :           case V_SgTypeUnsignedLong:</a>
<a name="619"><span class="lineNum">     619 </span>            :           case V_SgTypeUnsignedLongLong:</a>
<a name="620"><span class="lineNum">     620 </span>            :           case V_SgTypeUnsignedChar:</a>
<a name="621"><span class="lineNum">     621 </span>            :           case V_SgTypeUnsignedShort:</a>
<a name="622"><span class="lineNum">     622 </span>            :           case V_SgTypeUnsignedInt:</a>
<a name="623"><span class="lineNum">     623 </span>            :           case V_SgTypeSignedChar:</a>
<a name="624"><span class="lineNum">     624 </span>            :           case V_SgTypeSignedShort:</a>
<a name="625"><span class="lineNum">     625 </span>            :           case V_SgTypeSignedInt:</a>
<a name="626"><span class="lineNum">     626 </span>            :           case V_SgTypeSignedLong:</a>
<a name="627"><span class="lineNum">     627 </span>            :           case V_SgTypeSignedLongLong:</a>
<a name="628"><span class="lineNum">     628 </span>            : </a>
<a name="629"><span class="lineNum">     629 </span>            :        // DQ (11/6/2014): Added support for C++11 rvalue references.</a>
<a name="630"><span class="lineNum">     630 </span>            :           case V_SgRvalueReferenceType:</a>
<a name="631"><span class="lineNum">     631 </span>            : </a>
<a name="632"><span class="lineNum">     632 </span>            :        // DQ (3/24/2014): Added support for 128-bit integers.</a>
<a name="633"><span class="lineNum">     633 </span>            :           case V_SgTypeSigned128bitInteger:</a>
<a name="634"><span class="lineNum">     634 </span>            :           case V_SgTypeUnsigned128bitInteger:</a>
<a name="635"><span class="lineNum">     635 </span>            : </a>
<a name="636"><span class="lineNum">     636 </span>            :        // DQ (7/30/2014): Adding C++11 support.</a>
<a name="637"><span class="lineNum">     637 </span>            :           case V_SgTypeNullptr:</a>
<a name="638"><span class="lineNum">     638 </span>            : </a>
<a name="639"><span class="lineNum">     639 </span>            :        // DQ (8/12/2014): Adding C++11 support.</a>
<a name="640"><span class="lineNum">     640 </span>            :           case V_SgDeclType:</a>
<a name="641"><span class="lineNum">     641 </span>            : </a>
<a name="642"><span class="lineNum">     642 </span>            :        // DQ (3/28/2015): Adding GNU C language extension.</a>
<a name="643"><span class="lineNum">     643 </span>            :           case V_SgTypeOfType:</a>
<a name="644"><span class="lineNum">     644 </span>            : </a>
<a name="645"><span class="lineNum">     645 </span>            :        // DQ (4/29/2016): Added support for complex types.</a>
<a name="646"><span class="lineNum">     646 </span>            :           case V_SgTypeComplex:</a>
<a name="647"><span class="lineNum">     647 </span>            :           //  pp (7/16/2016) Matrix and tuple  (Matlab)</a>
<a name="648"><span class="lineNum">     648 </span>            :           case V_SgTypeMatrix:</a>
<a name="649"><span class="lineNum">     649 </span>            :           case V_SgTypeTuple:</a>
<a name="650"><span class="lineNum">     650 </span>            :           case V_SgTypeShort:</a>
<a name="651"><span class="lineNum">     651 </span>            :           case V_SgTypeLong:</a>
<a name="652"><span class="lineNum">     652 </span>            :           case V_SgTypeLongLong:</a>
<a name="653"><span class="lineNum">     653 </span>            :           case V_SgTypeVoid:</a>
<a name="654"><span class="lineNum">     654 </span>            :           case V_SgTypeChar:</a>
<a name="655"><span class="lineNum">     655 </span>            : </a>
<a name="656"><span class="lineNum">     656 </span>            :        // DQ (2/16/2018): Adding support for char16_t and char32_t (C99 and C++11 specific types).</a>
<a name="657"><span class="lineNum">     657 </span>            :           case V_SgTypeChar16:</a>
<a name="658"><span class="lineNum">     658 </span>            :           case V_SgTypeChar32:</a>
<a name="659"><span class="lineNum">     659 </span>            : </a>
<a name="660"><span class="lineNum">     660 </span>            :           case V_SgTypeFloat:</a>
<a name="661"><span class="lineNum">     661 </span>            :           case V_SgTypeDouble:</a>
<a name="662"><span class="lineNum">     662 </span>            :           case V_SgTypeLongDouble:</a>
<a name="663"><span class="lineNum">     663 </span>            :           case V_SgTypeBool:</a>
<a name="664"><span class="lineNum">     664 </span>            :           case V_SgTypeWchar:</a>
<a name="665"><span class="lineNum">     665 </span>            : </a>
<a name="666"><span class="lineNum">     666 </span>            :           case V_SgTypeFloat80:</a>
<a name="667"><span class="lineNum">     667 </span>            :           case V_SgTypeFloat128:</a>
<a name="668"><span class="lineNum">     668 </span>            : </a>
<a name="669"><span class="lineNum">     669 </span>            :           case V_SgTypeFixed:</a>
<a name="670"><span class="lineNum">     670 </span>            :        // TV (09/06/2018): Type of an unresolved auto keyword</a>
<a name="671"><span class="lineNum">     671 </span>            :           case V_SgAutoType:</a>
<a name="672"><span class="lineNum">     672 </span>            :              {</a>
<a name="673"><span class="lineNum">     673 </span>            :                return_declaration = NULL;</a>
<a name="674"><span class="lineNum">     674 </span>            :                break;</a>
<a name="675"><span class="lineNum">     675 </span>            :              }</a>
<a name="676"><span class="lineNum">     676 </span>            : </a>
<a name="677"><span class="lineNum">     677 </span><span class="lineCov">      38584 :           case V_SgNonrealType:</span></a>
<a name="678"><span class="lineNum">     678 </span><span class="lineCov">      38584 :              {</span></a>
<a name="679"><span class="lineNum">     679 </span><span class="lineCov">      38584 :                SgNonrealType * nrtype = isSgNonrealType(strippedType);</span></a>
<a name="680"><span class="lineNum">     680 </span><span class="lineCov">      38584 :                ASSERT_not_null(nrtype);</span></a>
<a name="681"><span class="lineNum">     681 </span><span class="lineCov">      38584 :                return_declaration = nrtype-&gt;get_declaration();</span></a>
<a name="682"><span class="lineNum">     682 </span><span class="lineCov">      38584 :                ASSERT_not_null(return_declaration);</span></a>
<a name="683"><span class="lineNum">     683 </span><span class="lineCov">      38584 :                break;</span></a>
<a name="684"><span class="lineNum">     684 </span>            :              }</a>
<a name="685"><span class="lineNum">     685 </span>            : </a>
<a name="686"><span class="lineNum">     686 </span>            :        // DQ (4/10/2019): Needing to support this case after recompiling ROSE (debugging SgPointerMemberType</a>
<a name="687"><span class="lineNum">     687 </span>            :        // and cleaning up handling of SgInitializedName name qualification support).</a>
<a name="688"><span class="lineNum">     688 </span>            :           case V_SgTypeEllipse:</a>
<a name="689"><span class="lineNum">     689 </span>            :              {</a>
<a name="690"><span class="lineNum">     690 </span>            :                return_declaration = NULL;</a>
<a name="691"><span class="lineNum">     691 </span>            :                break;</a>
<a name="692"><span class="lineNum">     692 </span>            :              }</a>
<a name="693"><span class="lineNum">     693 </span>            : </a>
<a name="694"><span class="lineNum">     694 </span>            :        // DQ (4/11/2019): This case appears in the testRoseHeaders_03.C test code (ROSE compiling ROSE).</a>
<a name="695"><span class="lineNum">     695 </span>            :           case V_SgTypeUnknown:</a>
<a name="696"><span class="lineNum">     696 </span>            :              {</a>
<a name="697"><span class="lineNum">     697 </span>            :                return_declaration = NULL;</a>
<a name="698"><span class="lineNum">     698 </span>            :                break;</a>
<a name="699"><span class="lineNum">     699 </span>            :              }</a>
<a name="700"><span class="lineNum">     700 </span>            : </a>
<a name="701"><span class="lineNum">     701 </span>            :        // DQ (4/12/2019): This case appears in the roseTests/astInterfaceTests/inputbuildIfStmt.C code.</a>
<a name="702"><span class="lineNum">     702 </span>            :           case V_SgTypeString:</a>
<a name="703"><span class="lineNum">     703 </span>            :              {</a>
<a name="704"><span class="lineNum">     704 </span>            :                return_declaration = NULL;</a>
<a name="705"><span class="lineNum">     705 </span>            :                break;</a>
<a name="706"><span class="lineNum">     706 </span>            :              }</a>
<a name="707"><span class="lineNum">     707 </span>            : </a>
<a name="708"><span class="lineNum">     708 </span>            :        // DQ (4/18/2019): This case is required because we need to process chains of SgPointerMemberType IR nodes (see test2019_373.C).</a>
<a name="709"><span class="lineNum">     709 </span><span class="lineCov">        404 :           case V_SgPointerMemberType:</span></a>
<a name="710"><span class="lineNum">     710 </span><span class="lineCov">        404 :              {</span></a>
<a name="711"><span class="lineNum">     711 </span><span class="lineCov">        404 :                SgPointerMemberType* pointerMemberType = isSgPointerMemberType(strippedType);</span></a>
<a name="712"><span class="lineNum">     712 </span><span class="lineCov">        404 :                return_declaration = pointerMemberType-&gt;get_class_declaration_of();</span></a>
<a name="713"><span class="lineNum">     713 </span><span class="lineCov">        404 :                ASSERT_not_null(return_declaration);</span></a>
<a name="714"><span class="lineNum">     714 </span><span class="lineCov">        404 :                break;</span></a>
<a name="715"><span class="lineNum">     715 </span>            :              }</a>
<a name="716"><span class="lineNum">     716 </span>            :        // Catch anything that migh have been missed (and exit so it can be identified and fixed).</a>
<a name="717"><span class="lineNum">     717 </span><span class="lineNoCov">          0 :           default:</span></a>
<a name="718"><span class="lineNum">     718 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="719"><span class="lineNum">     719 </span><span class="lineNoCov">          0 :                mfprintf(mlog [ WARN ] ) (&quot;Default reached in NameQualificationTraversal::associatedDeclaration() type = %s strippedType = %s \n&quot;,type-&gt;class_name().c_str(),strippedType-&gt;class_name().c_str());</span></a>
<a name="720"><span class="lineNum">     720 </span><span class="lineNoCov">          0 :                ROSE_ABORT();</span></a>
<a name="721"><span class="lineNum">     721 </span>            :              }</a>
<a name="722"><span class="lineNum">     722 </span>            :         }</a>
<a name="723"><span class="lineNum">     723 </span>            : </a>
<a name="724"><span class="lineNum">     724 </span><span class="lineCov">    1483520 :      return return_declaration;</span></a>
<a name="725"><span class="lineNum">     725 </span>            :    }</a>
<a name="726"><span class="lineNum">     726 </span>            : </a>
<a name="727"><span class="lineNum">     727 </span>            : </a>
<a name="728"><span class="lineNum">     728 </span>            : void</a>
<a name="729"><span class="lineNum">     729 </span><span class="lineCov">    3156910 : NameQualificationTraversal::evaluateTemplateInstantiationDeclaration ( SgDeclarationStatement* declaration, SgScopeStatement* currentScope, SgStatement* positionStatement )</span></a>
<a name="730"><span class="lineNum">     730 </span>            :    {</a>
<a name="731"><span class="lineNum">     731 </span>            :   // DQ (9/23/2012): Added assertions.</a>
<a name="732"><span class="lineNum">     732 </span><span class="lineCov">    3156910 :      ASSERT_not_null(declaration);</span></a>
<a name="733"><span class="lineNum">     733 </span><span class="lineCov">    3156910 :      ASSERT_not_null(currentScope);</span></a>
<a name="734"><span class="lineNum">     734 </span><span class="lineCov">    3156910 :      ASSERT_not_null(positionStatement);</span></a>
<a name="735"><span class="lineNum">     735 </span>            : </a>
<a name="736"><span class="lineNum">     736 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="737"><span class="lineNum">     737 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;11111111111111111111111111111111111111111111111111111111111111111111 \n&quot;);</a>
<a name="738"><span class="lineNum">     738 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In evaluateTemplateInstantiationDeclaration(): declaration = %p = %s currentScope = %p = %s positionStatement = %p = %s \n&quot;,</a>
<a name="739"><span class="lineNum">     739 </span>            :           declaration,declaration-&gt;class_name().c_str(),currentScope,currentScope-&gt;class_name().c_str(),positionStatement,positionStatement-&gt;class_name().c_str());</a>
<a name="740"><span class="lineNum">     740 </span>            : #endif</a>
<a name="741"><span class="lineNum">     741 </span>            : </a>
<a name="742"><span class="lineNum">     742 </span>            :   // DQ (10/31/2015): This code is designed to eliminate the infinite recursion possible in some rare cases of</a>
<a name="743"><span class="lineNum">     743 </span>            :   // template instantiation (see test2015_105.C extracted from ROSE compiling ROSE header files and the boost</a>
<a name="744"><span class="lineNum">     744 </span>            :   // usage present there).  Note that this could be restricted to the handling of SgTemplateInstantiationDecl</a>
<a name="745"><span class="lineNum">     745 </span>            :   // instead (I think).  But it might be that I have just not yet seen a recursive case using template functions</a>
<a name="746"><span class="lineNum">     746 </span>            :   // instantiations, template member function instantiations and template variable instantiations.</a>
<a name="747"><span class="lineNum">     747 </span><span class="lineCov">    3156910 :      SgTemplateInstantiationDecl* templateInstantiationDeclaration = isSgTemplateInstantiationDecl(declaration);</span></a>
<a name="748"><span class="lineNum">     748 </span><span class="lineCov">    3156910 :      SgClassDefinition* nonconst_def = templateInstantiationDeclaration != NULL ? isSgClassDefinition(templateInstantiationDeclaration-&gt;get_definition()) : NULL;</span></a>
<a name="749"><span class="lineNum">     749 </span>            : </a>
<a name="750"><span class="lineNum">     750 </span>            : #if 0</a>
<a name="751"><span class="lineNum">     751 </span>            :   // Note that nonconst_def can be NULL when the template instantiation has no defining declaration and is used in a template instantiation directive (see test2017_56.C).</a>
<a name="752"><span class="lineNum">     752 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In evaluateTemplateInstantiationDeclaration(): nonconst_def = %p \n&quot;,nonconst_def);</a>
<a name="753"><span class="lineNum">     753 </span>            : #endif</a>
<a name="754"><span class="lineNum">     754 </span>            : </a>
<a name="755"><span class="lineNum">     755 </span><span class="lineCov">    6313810 :      if (MangledNameSupport::visitedTemplateDefinitions.find(nonconst_def) != MangledNameSupport::visitedTemplateDefinitions.end())</span></a>
<a name="756"><span class="lineNum">     756 </span>            :         {</a>
<a name="757"><span class="lineNum">     757 </span>            :        // Skip the call that would result in infinte recursion.</a>
<a name="758"><span class="lineNum">     758 </span>            : #if 0</a>
<a name="759"><span class="lineNum">     759 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;In nameQualificationSupport.C: evaluateTemplateInstantiationDeclaration(): skipping the call to process the template class instantiation definition: def = %p = %s \n&quot;,declaration,declaration-&gt;class_name().c_str());</a>
<a name="760"><span class="lineNum">     760 </span>            : #endif</a>
<a name="761"><span class="lineNum">     761 </span>            :         }</a>
<a name="762"><span class="lineNum">     762 </span>            :        else</a>
<a name="763"><span class="lineNum">     763 </span>            :         {</a>
<a name="764"><span class="lineNum">     764 </span>            :        // Only handle the case of a SgTemplateInstantiationDecl.</a>
<a name="765"><span class="lineNum">     765 </span><span class="lineCov">    3156910 :           SgClassDefinition* templateInstantiationDefinition = isSgTemplateInstantiationDefn(nonconst_def);</span></a>
<a name="766"><span class="lineNum">     766 </span><span class="lineCov">    3156910 :           if (templateInstantiationDefinition != NULL)</span></a>
<a name="767"><span class="lineNum">     767 </span>            :              {</a>
<a name="768"><span class="lineNum">     768 </span>            : #if 0</a>
<a name="769"><span class="lineNum">     769 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Insert templateInstantiationDefinition = %p into visitedTemplateDeclarations (stl set)\n&quot;,templateInstantiationDefinition);</a>
<a name="770"><span class="lineNum">     770 </span>            : #endif</a>
<a name="771"><span class="lineNum">     771 </span>            :             // Not clear why we need to use an iterator to simply insert a pointer into the set.</a>
<a name="772"><span class="lineNum">     772 </span>            :             // SgTemplateInstantiationDefn* nonconst_templateInstantiationDefinition = const_cast&lt;SgTemplateInstantiationDefn*&gt;(templateInstantiationDefinition);</a>
<a name="773"><span class="lineNum">     773 </span><span class="lineCov">      25996 :                MangledNameSupport::setType::iterator it = MangledNameSupport::visitedTemplateDefinitions.begin();</span></a>
<a name="774"><span class="lineNum">     774 </span>            :             // MangledNameSupport::visitedTemplateDeclarations.insert(it,nonconst_templateInstantiationDefinition);</a>
<a name="775"><span class="lineNum">     775 </span><span class="lineCov">      25996 :                MangledNameSupport::visitedTemplateDefinitions.insert(it,nonconst_def);</span></a>
<a name="776"><span class="lineNum">     776 </span>            :              }</a>
<a name="777"><span class="lineNum">     777 </span>            : </a>
<a name="778"><span class="lineNum">     778 </span>            :        // DQ (11/1/2015): Indented this code (switch statement) to conform to new block layout.</a>
<a name="779"><span class="lineNum">     779 </span>            :        // DQ (6/1/2011): Added support for template arguments.</a>
<a name="780"><span class="lineNum">     780 </span><span class="lineCov">    3156910 :           switch (declaration-&gt;variantT())</span></a>
<a name="781"><span class="lineNum">     781 </span>            :              {</a>
<a name="782"><span class="lineNum">     782 </span><span class="lineCov">     129593 :                case V_SgTemplateInstantiationDecl:</span></a>
<a name="783"><span class="lineNum">     783 </span><span class="lineCov">     129593 :                   {</span></a>
<a name="784"><span class="lineNum">     784 </span><span class="lineCov">     129593 :                     SgTemplateInstantiationDecl* templateInstantiationDeclaration = isSgTemplateInstantiationDecl(declaration);</span></a>
<a name="785"><span class="lineNum">     785 </span><span class="lineCov">     129593 :                     ASSERT_not_null(templateInstantiationDeclaration);</span></a>
<a name="786"><span class="lineNum">     786 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="787"><span class="lineNum">     787 </span>            :                  // mfprintf(mlog [ WARN ] ) (&quot;$$$$$$$$$ --- templateInstantiationDeclaration = %p \n&quot;,templateInstantiationDeclaration);</a>
<a name="788"><span class="lineNum">     788 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;$$$$$$$$$ --- templateInstantiationDeclaration = %p templateInstantiationDeclaration-&gt;get_templateArguments().size() = %&quot; PRIuPTR &quot; \n&quot;,templateInstantiationDeclaration,templateInstantiationDeclaration-&gt;get_templateArguments().size());</a>
<a name="789"><span class="lineNum">     789 </span>            : #endif</a>
<a name="790"><span class="lineNum">     790 </span>            : </a>
<a name="791"><span class="lineNum">     791 </span>            :                  // Evaluate all template arguments.</a>
<a name="792"><span class="lineNum">     792 </span><span class="lineCov">     129593 :                     evaluateNameQualificationForTemplateArgumentList (templateInstantiationDeclaration-&gt;get_templateArguments(),currentScope,positionStatement);</span></a>
<a name="793"><span class="lineNum">     793 </span>            :                     break;</a>
<a name="794"><span class="lineNum">     794 </span>            :                   }</a>
<a name="795"><span class="lineNum">     795 </span>            : </a>
<a name="796"><span class="lineNum">     796 </span><span class="lineCov">       3708 :                case V_SgTemplateInstantiationFunctionDecl:</span></a>
<a name="797"><span class="lineNum">     797 </span><span class="lineCov">       3708 :                   {</span></a>
<a name="798"><span class="lineNum">     798 </span><span class="lineCov">       3708 :                     SgTemplateInstantiationFunctionDecl* templateInstantiationFunctionDeclaration = isSgTemplateInstantiationFunctionDecl(declaration);</span></a>
<a name="799"><span class="lineNum">     799 </span><span class="lineCov">       3708 :                     ASSERT_not_null(templateInstantiationFunctionDeclaration);</span></a>
<a name="800"><span class="lineNum">     800 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="801"><span class="lineNum">     801 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;$$$$$$$$$ --- templateInstantiationFunctionDeclaration = %p \n&quot;,templateInstantiationFunctionDeclaration);</a>
<a name="802"><span class="lineNum">     802 </span>            : #endif</a>
<a name="803"><span class="lineNum">     803 </span>            :                  // Evaluate all template arguments.</a>
<a name="804"><span class="lineNum">     804 </span><span class="lineCov">       3708 :                     evaluateNameQualificationForTemplateArgumentList (templateInstantiationFunctionDeclaration-&gt;get_templateArguments(),currentScope,positionStatement);</span></a>
<a name="805"><span class="lineNum">     805 </span>            :                     break;</a>
<a name="806"><span class="lineNum">     806 </span>            :                   }</a>
<a name="807"><span class="lineNum">     807 </span>            : </a>
<a name="808"><span class="lineNum">     808 </span><span class="lineCov">       8456 :                case V_SgTemplateInstantiationMemberFunctionDecl:</span></a>
<a name="809"><span class="lineNum">     809 </span><span class="lineCov">       8456 :                   {</span></a>
<a name="810"><span class="lineNum">     810 </span><span class="lineCov">       8456 :                     SgTemplateInstantiationMemberFunctionDecl* templateInstantiationMemberFunctionDeclaration = isSgTemplateInstantiationMemberFunctionDecl(declaration);</span></a>
<a name="811"><span class="lineNum">     811 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="812"><span class="lineNum">     812 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;$$$$$$$$$ --- templateInstantiationMemberFunctionDeclaration = %p \n&quot;,templateInstantiationMemberFunctionDeclaration);</a>
<a name="813"><span class="lineNum">     813 </span>            : #endif</a>
<a name="814"><span class="lineNum">     814 </span><span class="lineCov">       8456 :                     ASSERT_not_null(templateInstantiationMemberFunctionDeclaration);</span></a>
<a name="815"><span class="lineNum">     815 </span>            : </a>
<a name="816"><span class="lineNum">     816 </span>            :                  // Evaluate all template arguments.</a>
<a name="817"><span class="lineNum">     817 </span>            :                  // evaluateNameQualificationForTemplateArgumentList (templateInstantiationMemberFunctionDeclaration-&gt;get_templateArguments(),currentScope,positionStatement);</a>
<a name="818"><span class="lineNum">     818 </span><span class="lineCov">       8456 :                     SgTemplateArgumentPtrList &amp; templateArgumentList = templateInstantiationMemberFunctionDeclaration-&gt;get_templateArguments();</span></a>
<a name="819"><span class="lineNum">     819 </span><span class="lineCov">       8456 :                     evaluateNameQualificationForTemplateArgumentList(templateArgumentList,currentScope,positionStatement);</span></a>
<a name="820"><span class="lineNum">     820 </span>            :                     break;</a>
<a name="821"><span class="lineNum">     821 </span>            :                   }</a>
<a name="822"><span class="lineNum">     822 </span>            : </a>
<a name="823"><span class="lineNum">     823 </span>            :             // DQ (3/31/2018): Added code to help debug strange case (see Cxx11_tests/test2018_68.C).</a>
<a name="824"><span class="lineNum">     824 </span>            :                case V_SgTemplateFunctionDeclaration:</a>
<a name="825"><span class="lineNum">     825 </span>            :                   {</a>
<a name="826"><span class="lineNum">     826 </span>            :                  // Actually there is nothing to do here.</a>
<a name="827"><span class="lineNum">     827 </span>            : #if 0</a>
<a name="828"><span class="lineNum">     828 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Note: Template arguments being evaluated against template declaration (which has only template parameters) \n&quot;);</a>
<a name="829"><span class="lineNum">     829 </span>            : #endif</a>
<a name="830"><span class="lineNum">     830 </span>            : #if 0</a>
<a name="831"><span class="lineNum">     831 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="832"><span class="lineNum">     832 </span>            :                     ROSE_ABORT();</a>
<a name="833"><span class="lineNum">     833 </span>            : #endif</a>
<a name="834"><span class="lineNum">     834 </span>            :                     break;</a>
<a name="835"><span class="lineNum">     835 </span>            :                   }</a>
<a name="836"><span class="lineNum">     836 </span>            : </a>
<a name="837"><span class="lineNum">     837 </span>            :             // DQ (4/14/2018): Added case for template typedef instantiations (see test2018_83.C for an example where name qualification of the template arguments is required).</a>
<a name="838"><span class="lineNum">     838 </span><span class="lineCov">       3000 :                case V_SgTemplateInstantiationTypedefDeclaration:</span></a>
<a name="839"><span class="lineNum">     839 </span><span class="lineCov">       3000 :                   {</span></a>
<a name="840"><span class="lineNum">     840 </span><span class="lineCov">       3000 :                     SgTemplateInstantiationTypedefDeclaration* templateInstantiationTypedefDeclaration = isSgTemplateInstantiationTypedefDeclaration(declaration);</span></a>
<a name="841"><span class="lineNum">     841 </span><span class="lineCov">       3000 :                     ASSERT_not_null(templateInstantiationTypedefDeclaration);</span></a>
<a name="842"><span class="lineNum">     842 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="843"><span class="lineNum">     843 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;$$$$$$$$$ --- templateInstantiationTypedefDeclaration = %p \n&quot;,templateInstantiationTypedefDeclaration);</a>
<a name="844"><span class="lineNum">     844 </span>            : #endif</a>
<a name="845"><span class="lineNum">     845 </span>            :                  // Evaluate all template arguments.</a>
<a name="846"><span class="lineNum">     846 </span><span class="lineCov">       3000 :                     evaluateNameQualificationForTemplateArgumentList (templateInstantiationTypedefDeclaration-&gt;get_templateArguments(),currentScope,positionStatement);</span></a>
<a name="847"><span class="lineNum">     847 </span>            :                     break;</a>
<a name="848"><span class="lineNum">     848 </span>            :                   }</a>
<a name="849"><span class="lineNum">     849 </span>            : </a>
<a name="850"><span class="lineNum">     850 </span><span class="lineCov">      74909 :                case V_SgNonrealDecl:</span></a>
<a name="851"><span class="lineNum">     851 </span><span class="lineCov">      74909 :                   {</span></a>
<a name="852"><span class="lineNum">     852 </span><span class="lineCov">      74909 :                     SgNonrealDecl* nrdecl = isSgNonrealDecl(declaration);</span></a>
<a name="853"><span class="lineNum">     853 </span><span class="lineCov">      74909 :                     ASSERT_not_null(nrdecl);</span></a>
<a name="854"><span class="lineNum">     854 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="855"><span class="lineNum">     855 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;$$$$$$$$$ --- nrdecl = %p \n&quot;,nrdecl);</a>
<a name="856"><span class="lineNum">     856 </span>            : #endif</a>
<a name="857"><span class="lineNum">     857 </span><span class="lineCov">      74909 :                     evaluateNameQualificationForTemplateArgumentList (nrdecl-&gt;get_tpl_args(),currentScope,positionStatement);</span></a>
<a name="858"><span class="lineNum">     858 </span>            : </a>
<a name="859"><span class="lineNum">     859 </span>            :                     break;</a>
<a name="860"><span class="lineNum">     860 </span>            :                   }</a>
<a name="861"><span class="lineNum">     861 </span>            : </a>
<a name="862"><span class="lineNum">     862 </span>            : </a>
<a name="863"><span class="lineNum">     863 </span><span class="lineCov">    3156910 :                default:</span></a>
<a name="864"><span class="lineNum">     864 </span><span class="lineCov">    3156910 :                   {</span></a>
<a name="865"><span class="lineNum">     865 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="866"><span class="lineNum">     866 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;This IR node does not contain template arguments to process: declaration = %p = %s \n&quot;,declaration,declaration-&gt;class_name().c_str());</a>
<a name="867"><span class="lineNum">     867 </span>            : #endif</a>
<a name="868"><span class="lineNum">     868 </span>            :                   }</a>
<a name="869"><span class="lineNum">     869 </span>            :              }</a>
<a name="870"><span class="lineNum">     870 </span>            : </a>
<a name="871"><span class="lineNum">     871 </span>            :        // DQ (10/31/2015): The rule here is that after processing as a mangled name we remove the</a>
<a name="872"><span class="lineNum">     872 </span>            :        // template instantiation from the list so that other non-nested uses of the template</a>
<a name="873"><span class="lineNum">     873 </span>            :        // instantiation will force the manged name to be generated.</a>
<a name="874"><span class="lineNum">     874 </span><span class="lineCov">    3156910 :           if (templateInstantiationDefinition != NULL)</span></a>
<a name="875"><span class="lineNum">     875 </span>            :              {</a>
<a name="876"><span class="lineNum">     876 </span>            : #if 0</a>
<a name="877"><span class="lineNum">     877 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Erase templateInstantiationDefinition = %p from visitedTemplateDeclarations (stl set)\n&quot;,templateInstantiationDefinition);</a>
<a name="878"><span class="lineNum">     878 </span>            : #endif</a>
<a name="879"><span class="lineNum">     879 </span><span class="lineCov">      25996 :                MangledNameSupport::visitedTemplateDefinitions.erase(nonconst_def);</span></a>
<a name="880"><span class="lineNum">     880 </span>            :              }</a>
<a name="881"><span class="lineNum">     881 </span>            :         }</a>
<a name="882"><span class="lineNum">     882 </span>            : </a>
<a name="883"><span class="lineNum">     883 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="884"><span class="lineNum">     884 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;Leaving evaluateTemplateInstantiationDeclaration(): declaration = %p = %s currentScope = %p = %s positionStatement = %p = %s \n&quot;,</a>
<a name="885"><span class="lineNum">     885 </span>            :           declaration,declaration-&gt;class_name().c_str(),currentScope,currentScope-&gt;class_name().c_str(),positionStatement,positionStatement-&gt;class_name().c_str());</a>
<a name="886"><span class="lineNum">     886 </span>            : #endif</a>
<a name="887"><span class="lineNum">     887 </span><span class="lineCov">    3156910 :    }</span></a>
<a name="888"><span class="lineNum">     888 </span>            : </a>
<a name="889"><span class="lineNum">     889 </span>            : </a>
<a name="890"><span class="lineNum">     890 </span>            : int</a>
<a name="891"><span class="lineNum">     891 </span><span class="lineCov">     216758 : NameQualificationTraversal::nameQualificationDepthOfParent(SgDeclarationStatement* declaration, SgScopeStatement* currentScope, SgStatement* positionStatement )</span></a>
<a name="892"><span class="lineNum">     892 </span>            :    {</a>
<a name="893"><span class="lineNum">     893 </span>            :   // Now resolve how much name qualification is required.</a>
<a name="894"><span class="lineNum">     894 </span><span class="lineCov">     216758 :      int qualificationDepth = 0;</span></a>
<a name="895"><span class="lineNum">     895 </span>            : </a>
<a name="896"><span class="lineNum">     896 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="897"><span class="lineNum">     897 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;***** Inside of NameQualificationTraversal::nameQualificationDepthOfParent() ***** \n&quot;);</a>
<a name="898"><span class="lineNum">     898 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;   declaration  = %p = %s = %s \n&quot;,declaration,declaration-&gt;class_name().c_str(),SageInterface::get_name(declaration).c_str());</a>
<a name="899"><span class="lineNum">     899 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;   currentScope = %p = %s = %s \n&quot;,currentScope,currentScope-&gt;class_name().c_str(),SageInterface::get_name(currentScope).c_str());</a>
<a name="900"><span class="lineNum">     900 </span>            : #endif</a>
<a name="901"><span class="lineNum">     901 </span>            : </a>
<a name="902"><span class="lineNum">     902 </span>            :   // qualificationDepth++;</a>
<a name="903"><span class="lineNum">     903 </span>            :   // SgDeclaration* classOrNamespaceDefinition = classDefinition-&gt;get_declaration()-&gt;get_scope();</a>
<a name="904"><span class="lineNum">     904 </span><span class="lineCov">     216758 :      SgScopeStatement* parentScope = declaration-&gt;get_scope();</span></a>
<a name="905"><span class="lineNum">     905 </span>            :   // SgName parentName = associatedName(parentScope);</a>
<a name="906"><span class="lineNum">     906 </span>            : </a>
<a name="907"><span class="lineNum">     907 </span>            :   // DQ (6/24/2018): Added assertion.</a>
<a name="908"><span class="lineNum">     908 </span><span class="lineCov">     216758 :      ASSERT_not_null(parentScope);</span></a>
<a name="909"><span class="lineNum">     909 </span>            : </a>
<a name="910"><span class="lineNum">     910 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="911"><span class="lineNum">     911 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;***** Inside of NameQualificationTraversal::nameQualificationDepthOfParent() ***** \n&quot;);</a>
<a name="912"><span class="lineNum">     912 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;   parentScope = %p = %s = %s \n&quot;,parentScope,parentScope-&gt;class_name().c_str(),SageInterface::get_name(parentScope).c_str());</a>
<a name="913"><span class="lineNum">     913 </span>            : #endif</a>
<a name="914"><span class="lineNum">     914 </span>            : </a>
<a name="915"><span class="lineNum">     915 </span>            :   // qualificationDepth = nameQualificationDepth(parentName,parentScope,positionStatement) + 1;</a>
<a name="916"><span class="lineNum">     916 </span><span class="lineCov">     216758 :      SgGlobal* globalScope = isSgGlobal(parentScope);</span></a>
<a name="917"><span class="lineNum">     917 </span><span class="lineCov">     216758 :      if (globalScope != NULL)</span></a>
<a name="918"><span class="lineNum">     918 </span>            :         {</a>
<a name="919"><span class="lineNum">     919 </span>            :        // There is no declaration associated with global scope so we have to process the case of a null pointer...</a>
<a name="920"><span class="lineNum">     920 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 1)</a>
<a name="921"><span class="lineNum">     921 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;parentDeclaration == NULL: parentScope = %p = %s \n&quot;,parentScope,parentScope-&gt;class_name().c_str());</a>
<a name="922"><span class="lineNum">     922 </span>            : #endif</a>
<a name="923"><span class="lineNum">     923 </span>            : #if 0</a>
<a name="924"><span class="lineNum">     924 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;This case is not handled yet! \n&quot;);</a>
<a name="925"><span class="lineNum">     925 </span>            :           ROSE_ABORT();</a>
<a name="926"><span class="lineNum">     926 </span>            : #endif</a>
<a name="927"><span class="lineNum">     927 </span>            :         }</a>
<a name="928"><span class="lineNum">     928 </span>            :        else</a>
<a name="929"><span class="lineNum">     929 </span>            :         {</a>
<a name="930"><span class="lineNum">     930 </span>            :        // Now ask the same question recursively using the parent declaration and the same currentScope (is it visible from the same point in the code).</a>
<a name="931"><span class="lineNum">     931 </span><span class="lineCov">     139198 :           SgDeclarationStatement* parentDeclaration = associatedDeclaration(parentScope);</span></a>
<a name="932"><span class="lineNum">     932 </span>            : </a>
<a name="933"><span class="lineNum">     933 </span>            :        // In some cases the declaration can be in a scope with is not associated with a declaration (e.g. SgBasicBlock or SgForStatement).</a>
<a name="934"><span class="lineNum">     934 </span><span class="lineCov">     139198 :           if (parentDeclaration != NULL)</span></a>
<a name="935"><span class="lineNum">     935 </span>            :              {</a>
<a name="936"><span class="lineNum">     936 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="937"><span class="lineNum">     937 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::nameQualificationDepthOfParent(): calling nameQualificationDepth(): parentDeclaration = %p = %s = %s \n&quot;,</a>
<a name="938"><span class="lineNum">     938 </span>            :                     parentDeclaration,parentDeclaration-&gt;class_name().c_str(),SageInterface::get_name(parentDeclaration).c_str());</a>
<a name="939"><span class="lineNum">     939 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;   --- currentScope = %p = %s \n&quot;,currentScope,currentScope-&gt;class_name().c_str());</a>
<a name="940"><span class="lineNum">     940 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;   --- parentScope = %p = %s \n&quot;,parentScope,parentScope-&gt;class_name().c_str());</a>
<a name="941"><span class="lineNum">     941 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;   --- positionStatement = %p = %s \n&quot;,positionStatement,positionStatement-&gt;class_name().c_str());</a>
<a name="942"><span class="lineNum">     942 </span>            : #endif</a>
<a name="943"><span class="lineNum">     943 </span>            :             // qualificationDepth = nameQualificationDepth(parentDeclaration,parentScope,positionStatement);</a>
<a name="944"><span class="lineNum">     944 </span><span class="lineCov">      96722 :                qualificationDepth = nameQualificationDepth(parentDeclaration,currentScope,positionStatement);</span></a>
<a name="945"><span class="lineNum">     945 </span>            :              }</a>
<a name="946"><span class="lineNum">     946 </span>            :         }</a>
<a name="947"><span class="lineNum">     947 </span>            : </a>
<a name="948"><span class="lineNum">     948 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="949"><span class="lineNum">     949 </span>            : // #if 0</a>
<a name="950"><span class="lineNum">     950 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;Leaving nameQualificationDepthOfParent(): declaration = %p = %s \n&quot;,declaration,declaration-&gt;class_name().c_str());</a>
<a name="951"><span class="lineNum">     951 </span>            : #endif</a>
<a name="952"><span class="lineNum">     952 </span>            : </a>
<a name="953"><span class="lineNum">     953 </span><span class="lineCov">     216758 :      return qualificationDepth;</span></a>
<a name="954"><span class="lineNum">     954 </span>            :    }</a>
<a name="955"><span class="lineNum">     955 </span>            : </a>
<a name="956"><span class="lineNum">     956 </span>            : bool</a>
<a name="957"><span class="lineNum">     957 </span><span class="lineCov">       7586 : NameQualificationTraversal::requiresTypeElaboration(SgSymbol* symbol)</span></a>
<a name="958"><span class="lineNum">     958 </span>            :    {</a>
<a name="959"><span class="lineNum">     959 </span>            :   // DQ (5/14/2011): type elaboration only works between non-types and types.  Different types must be distinquished using name qualification.</a>
<a name="960"><span class="lineNum">     960 </span>            :   // If this is a type then since all types are given equal weight we need more name qualification to distinquish them.</a>
<a name="961"><span class="lineNum">     961 </span>            :   // However, if this is a non-type then type elaboration is sufficent to distinquish the type (e.g. from a variable name).</a>
<a name="962"><span class="lineNum">     962 </span><span class="lineCov">       7586 :      bool typeElaborationRequired = false;</span></a>
<a name="963"><span class="lineNum">     963 </span>            : </a>
<a name="964"><span class="lineNum">     964 </span><span class="lineCov">       7586 :      ASSERT_not_null(symbol);</span></a>
<a name="965"><span class="lineNum">     965 </span><span class="lineCov">       7586 :      switch (symbol-&gt;variantT())</span></a>
<a name="966"><span class="lineNum">     966 </span>            :         {</a>
<a name="967"><span class="lineNum">     967 </span>            :        // DQ (7/23/2011): Class elaboration can be required....</a>
<a name="968"><span class="lineNum">     968 </span>            :           case V_SgClassSymbol:</a>
<a name="969"><span class="lineNum">     969 </span>            : </a>
<a name="970"><span class="lineNum">     970 </span>            :        // DQ (2/25/2012): Added support for SgTemplateClassSymbol.</a>
<a name="971"><span class="lineNum">     971 </span>            :           case V_SgTemplateClassSymbol:</a>
<a name="972"><span class="lineNum">     972 </span>            : </a>
<a name="973"><span class="lineNum">     973 </span>            :        // DQ (2/12/2012): Added support for SgTemplateMemberFunctionSymbol.</a>
<a name="974"><span class="lineNum">     974 </span>            :           case V_SgTemplateMemberFunctionSymbol:</a>
<a name="975"><span class="lineNum">     975 </span>            : </a>
<a name="976"><span class="lineNum">     976 </span>            :        // DQ (2/12/2013): Added support for SgTemplateFunctionSymbol.</a>
<a name="977"><span class="lineNum">     977 </span>            :           case V_SgTemplateFunctionSymbol:</a>
<a name="978"><span class="lineNum">     978 </span>            : </a>
<a name="979"><span class="lineNum">     979 </span>            :        // TV (05/24/2018): Added support for SgTemplateTypedefSymbol</a>
<a name="980"><span class="lineNum">     980 </span>            :           case V_SgTemplateTypedefSymbol:</a>
<a name="981"><span class="lineNum">     981 </span>            : </a>
<a name="982"><span class="lineNum">     982 </span>            :        // DQ (6/21/2011): Added case for SgFunctionSymbol (triggers type elaboration).</a>
<a name="983"><span class="lineNum">     983 </span>            :           case V_SgFunctionSymbol:</a>
<a name="984"><span class="lineNum">     984 </span>            :           case V_SgMemberFunctionSymbol:</a>
<a name="985"><span class="lineNum">     985 </span>            :           case V_SgTemplateVariableSymbol:</a>
<a name="986"><span class="lineNum">     986 </span>            :           case V_SgVariableSymbol:</a>
<a name="987"><span class="lineNum">     987 </span>            :              {</a>
<a name="988"><span class="lineNum">     988 </span>            :                typeElaborationRequired = true;</a>
<a name="989"><span class="lineNum">     989 </span>            :                break;</a>
<a name="990"><span class="lineNum">     990 </span>            :              }</a>
<a name="991"><span class="lineNum">     991 </span>            : </a>
<a name="992"><span class="lineNum">     992 </span>            :        // DQ (3/31/2013): We need an example of this before I allow it (I don't think type elaboration is required here).</a>
<a name="993"><span class="lineNum">     993 </span><span class="lineCov">        126 :           case V_SgEnumFieldSymbol:</span></a>
<a name="994"><span class="lineNum">     994 </span>            : </a>
<a name="995"><span class="lineNum">     995 </span>            :        // DQ (6/22/2011): Added case for SgEnumSymbol (see test2011_95.C)</a>
<a name="996"><span class="lineNum">     996 </span><span class="lineCov">        126 :           case V_SgEnumSymbol:</span></a>
<a name="997"><span class="lineNum">     997 </span><span class="lineCov">        126 :           case V_SgNamespaceSymbol: // Note sure about this!!!</span></a>
<a name="998"><span class="lineNum">     998 </span><span class="lineCov">        126 :           case V_SgTemplateSymbol: // Note sure about this!!!</span></a>
<a name="999"><span class="lineNum">     999 </span><span class="lineCov">        126 :           case V_SgNonrealSymbol: // Note sure about this!!!</span></a>
<a name="1000"><span class="lineNum">    1000 </span><span class="lineCov">        126 :           case V_SgTypedefSymbol:</span></a>
<a name="1001"><span class="lineNum">    1001 </span><span class="lineCov">        126 :              {</span></a>
<a name="1002"><span class="lineNum">    1002 </span><span class="lineCov">        126 :                typeElaborationRequired = false;</span></a>
<a name="1003"><span class="lineNum">    1003 </span><span class="lineCov">        126 :                break;</span></a>
<a name="1004"><span class="lineNum">    1004 </span>            :              }</a>
<a name="1005"><span class="lineNum">    1005 </span>            : </a>
<a name="1006"><span class="lineNum">    1006 </span>            :        // DQ (9/21/2011): Added support for alias symbol (recursive call).</a>
<a name="1007"><span class="lineNum">    1007 </span><span class="lineNoCov">          0 :           case V_SgAliasSymbol:</span></a>
<a name="1008"><span class="lineNum">    1008 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="1009"><span class="lineNum">    1009 </span><span class="lineNoCov">          0 :                SgAliasSymbol* alias = isSgAliasSymbol(symbol);</span></a>
<a name="1010"><span class="lineNum">    1010 </span><span class="lineNoCov">          0 :                ASSERT_not_null(alias);</span></a>
<a name="1011"><span class="lineNum">    1011 </span>            : </a>
<a name="1012"><span class="lineNum">    1012 </span>            :             // DQ (7/12/2014): The newer design of the symbol table handling means that we will never see a SgAliasSymbol at this level.</a>
<a name="1013"><span class="lineNum">    1013 </span><span class="lineNoCov">          0 :                ROSE_ABORT();</span></a>
<a name="1014"><span class="lineNum">    1014 </span>            : #if 0 // [Robb Matzke 2021-03-24]</a>
<a name="1015"><span class="lineNum">    1015 </span>            :                SgSymbol* baseSymbol = alias-&gt;get_alias();</a>
<a name="1016"><span class="lineNum">    1016 </span>            :                ASSERT_not_null(baseSymbol);</a>
<a name="1017"><span class="lineNum">    1017 </span>            : #if 1</a>
<a name="1018"><span class="lineNum">    1018 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;NameQualificationTraversal::requiresTypeElaboration(): Detected a SgAliasSymbol: alias = %p baseSymbol = %p = %s \n&quot;,alias,baseSymbol,baseSymbol-&gt;class_name().c_str());</a>
<a name="1019"><span class="lineNum">    1019 </span>            : #endif</a>
<a name="1020"><span class="lineNum">    1020 </span>            :                typeElaborationRequired = requiresTypeElaboration(baseSymbol);</a>
<a name="1021"><span class="lineNum">    1021 </span>            :                break;</a>
<a name="1022"><span class="lineNum">    1022 </span>            : #endif</a>
<a name="1023"><span class="lineNum">    1023 </span>            :              }</a>
<a name="1024"><span class="lineNum">    1024 </span>            : </a>
<a name="1025"><span class="lineNum">    1025 </span><span class="lineNoCov">          0 :           default:</span></a>
<a name="1026"><span class="lineNum">    1026 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="1027"><span class="lineNum">    1027 </span><span class="lineNoCov">          0 :                mfprintf(mlog [ WARN ] ) (&quot;Default reached in NameQualificationTraversal::requiresTypeElaboration(): symbol = %p = %s \n&quot;,symbol,symbol-&gt;class_name().c_str());</span></a>
<a name="1028"><span class="lineNum">    1028 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(false);</span></a>
<a name="1029"><span class="lineNum">    1029 </span>            :              }</a>
<a name="1030"><span class="lineNum">    1030 </span>            :         }</a>
<a name="1031"><span class="lineNum">    1031 </span>            : </a>
<a name="1032"><span class="lineNum">    1032 </span><span class="lineCov">       7586 :      return typeElaborationRequired;</span></a>
<a name="1033"><span class="lineNum">    1033 </span>            :    }</a>
<a name="1034"><span class="lineNum">    1034 </span>            : </a>
<a name="1035"><span class="lineNum">    1035 </span>            : </a>
<a name="1036"><span class="lineNum">    1036 </span>            : void</a>
<a name="1037"><span class="lineNum">    1037 </span><span class="lineCov">       1313 : NameQualificationTraversal::processNameQualificationArrayType(SgArrayType* arrayType, SgScopeStatement* currentScope)</span></a>
<a name="1038"><span class="lineNum">    1038 </span>            :    {</a>
<a name="1039"><span class="lineNum">    1039 </span>            :   // Note that we may have to traverse base types in case they include other SgArrayType IR nodes where their index requires name qualification.</a>
<a name="1040"><span class="lineNum">    1040 </span>            :   // SgType* strippedArrayType = arrayType-&gt;stripType(SgType::STRIP_MODIFIER_TYPE|SgType::STRIP_REFERENCE_TYPE|SgType::STRIP_POINTER_TYPE);</a>
<a name="1041"><span class="lineNum">    1041 </span>            :   // ASSERT_not_null(strippedArrayType);</a>
<a name="1042"><span class="lineNum">    1042 </span>            : </a>
<a name="1043"><span class="lineNum">    1043 </span><span class="lineCov">       1313 :      SgExpression* index = arrayType-&gt;get_index();</span></a>
<a name="1044"><span class="lineNum">    1044 </span><span class="lineCov">       1313 :      if (index != NULL)</span></a>
<a name="1045"><span class="lineNum">    1045 </span>            :         {</a>
<a name="1046"><span class="lineNum">    1046 </span>            : #if 0</a>
<a name="1047"><span class="lineNum">    1047 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;~~~~~ Handling case of SgArrayType: currentScope = %p = %s \n&quot;,currentScope,currentScope-&gt;class_name().c_str());</a>
<a name="1048"><span class="lineNum">    1048 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;~~~~~ Handling case of SgArrayType: index        = %p = %s \n&quot;,index,index-&gt;class_name().c_str());</a>
<a name="1049"><span class="lineNum">    1049 </span>            : #endif</a>
<a name="1050"><span class="lineNum">    1050 </span>            :        // DQ (7/23/2011): This will not work since the current scope is not know and can't be determined from the type (which is shared).</a>
<a name="1051"><span class="lineNum">    1051 </span><span class="lineCov">       1313 :           ASSERT_not_null(currentScope);</span></a>
<a name="1052"><span class="lineNum">    1052 </span><span class="lineCov">       1313 :           generateNestedTraversalWithExplicitScope(index,currentScope);</span></a>
<a name="1053"><span class="lineNum">    1053 </span>            : #if 0</a>
<a name="1054"><span class="lineNum">    1054 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;DONE: Support name qualification on the array index expression if required (recursive call) \n&quot;);</a>
<a name="1055"><span class="lineNum">    1055 </span>            : #endif</a>
<a name="1056"><span class="lineNum">    1056 </span>            :        // DQ (8/21/2014): It appears that test2014_137.C is not being caught by this trap.</a>
<a name="1057"><span class="lineNum">    1057 </span><span class="lineCov">       1313 :           SgVarRefExp* varRefExp = isSgVarRefExp(index);</span></a>
<a name="1058"><span class="lineNum">    1058 </span><span class="lineCov">       1313 :           if (varRefExp != NULL)</span></a>
<a name="1059"><span class="lineNum">    1059 </span>            :              {</a>
<a name="1060"><span class="lineNum">    1060 </span>            : #if 0</a>
<a name="1061"><span class="lineNum">    1061 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;ERROR: Case of SgArrayType with a SgVarRefExp index (exiting as a test) \n&quot;);</a>
<a name="1062"><span class="lineNum">    1062 </span>            :                ROSE_ABORT();</a>
<a name="1063"><span class="lineNum">    1063 </span>            : #endif</a>
<a name="1064"><span class="lineNum">    1064 </span>            :              }</a>
<a name="1065"><span class="lineNum">    1065 </span>            :         }</a>
<a name="1066"><span class="lineNum">    1066 </span>            : </a>
<a name="1067"><span class="lineNum">    1067 </span>            : #if 0</a>
<a name="1068"><span class="lineNum">    1068 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;ERROR: Case of SgArrayType not supported yet! \n&quot;);</a>
<a name="1069"><span class="lineNum">    1069 </span>            :      ROSE_ABORT();</a>
<a name="1070"><span class="lineNum">    1070 </span>            : #endif</a>
<a name="1071"><span class="lineNum">    1071 </span><span class="lineCov">       1313 :    }</span></a>
<a name="1072"><span class="lineNum">    1072 </span>            : </a>
<a name="1073"><span class="lineNum">    1073 </span>            : void</a>
<a name="1074"><span class="lineNum">    1074 </span><span class="lineCov">    1864860 : NameQualificationTraversal::processNameQualificationForPossibleArrayType(SgType* possibleArrayType, SgScopeStatement* currentScope)</span></a>
<a name="1075"><span class="lineNum">    1075 </span>            :    {</a>
<a name="1076"><span class="lineNum">    1076 </span>            :   // DQ (7/23/2011): Refactored support for name qualification of the index expressions used in array types.</a>
<a name="1077"><span class="lineNum">    1077 </span>            : </a>
<a name="1078"><span class="lineNum">    1078 </span>            : #if 0</a>
<a name="1079"><span class="lineNum">    1079 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In processNameQualificationForPossibleArrayType(): possibleArrayType = %p = %s \n&quot;,possibleArrayType,possibleArrayType-&gt;class_name().c_str());</a>
<a name="1080"><span class="lineNum">    1080 </span>            : #endif</a>
<a name="1081"><span class="lineNum">    1081 </span>            : </a>
<a name="1082"><span class="lineNum">    1082 </span><span class="lineCov">    1864860 :      SgType* strippedPossibleArrayType = possibleArrayType-&gt;stripType(SgType::STRIP_MODIFIER_TYPE|SgType::STRIP_REFERENCE_TYPE|SgType::STRIP_RVALUE_REFERENCE_TYPE|SgType::STRIP_POINTER_TYPE);</span></a>
<a name="1083"><span class="lineNum">    1083 </span><span class="lineCov">    1864860 :      ASSERT_not_null(strippedPossibleArrayType);</span></a>
<a name="1084"><span class="lineNum">    1084 </span><span class="lineCov">    1864860 :      SgArrayType* arrayType = isSgArrayType(strippedPossibleArrayType);</span></a>
<a name="1085"><span class="lineNum">    1085 </span><span class="lineCov">    1864860 :      if (arrayType != NULL)</span></a>
<a name="1086"><span class="lineNum">    1086 </span>            :         {</a>
<a name="1087"><span class="lineNum">    1087 </span><span class="lineCov">       1313 :           processNameQualificationArrayType(arrayType,currentScope);</span></a>
<a name="1088"><span class="lineNum">    1088 </span>            : </a>
<a name="1089"><span class="lineNum">    1089 </span>            :        // Now process the base type, since it might be part of a multi-dimentional array type (in C/C++ these are a chain of array types).</a>
<a name="1090"><span class="lineNum">    1090 </span><span class="lineCov">       1313 :           processNameQualificationForPossibleArrayType(arrayType-&gt;get_base_type(),currentScope);</span></a>
<a name="1091"><span class="lineNum">    1091 </span>            :         }</a>
<a name="1092"><span class="lineNum">    1092 </span>            : </a>
<a name="1093"><span class="lineNum">    1093 </span>            : #if 0</a>
<a name="1094"><span class="lineNum">    1094 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In processNameQualificationForPossibleArrayType(): Case of SgArrayType not supported yet! \n&quot;);</a>
<a name="1095"><span class="lineNum">    1095 </span>            :      ROSE_ABORT();</a>
<a name="1096"><span class="lineNum">    1096 </span>            : #endif</a>
<a name="1097"><span class="lineNum">    1097 </span><span class="lineCov">    1864860 :    }</span></a>
<a name="1098"><span class="lineNum">    1098 </span>            : </a>
<a name="1099"><span class="lineNum">    1099 </span>            : </a>
<a name="1100"><span class="lineNum">    1100 </span>            : </a>
<a name="1101"><span class="lineNum">    1101 </span>            : void</a>
<a name="1102"><span class="lineNum">    1102 </span><span class="lineNoCov">          0 : NameQualificationTraversal::functionReport(SgFunctionDeclaration* functionDeclaration)</span></a>
<a name="1103"><span class="lineNum">    1103 </span>            :    {</a>
<a name="1104"><span class="lineNum">    1104 </span>            :   // Report on the details of functions as part of debugging.  This function supports</a>
<a name="1105"><span class="lineNum">    1105 </span>            :   // an analysis of the use of the getline function in iostream header file.  It is used</a>
<a name="1106"><span class="lineNum">    1106 </span>            :   // as a template, it is overloaded, and it is instantiationed in several ways.  As a</a>
<a name="1107"><span class="lineNum">    1107 </span>            :   // result it is a subject for a case study in the name qualification to eveluate the</a>
<a name="1108"><span class="lineNum">    1108 </span>            :   // influence of different instances (kinds) of the same function function and how</a>
<a name="1109"><span class="lineNum">    1109 </span>            :   // the logic for name qualification and detection of functions hiding other functions</a>
<a name="1110"><span class="lineNum">    1110 </span>            :   // works to drive the name qualification.</a>
<a name="1111"><span class="lineNum">    1111 </span>            : </a>
<a name="1112"><span class="lineNum">    1112 </span>            :   // SgFunctionDeclaration* functionDeclaration = isSgFunctionDeclaration(astNode);</a>
<a name="1113"><span class="lineNum">    1113 </span><span class="lineNoCov">          0 :      if (functionDeclaration != NULL)</span></a>
<a name="1114"><span class="lineNum">    1114 </span>            :         {</a>
<a name="1115"><span class="lineNum">    1115 </span><span class="lineNoCov">          0 :           string name = functionDeclaration-&gt;get_name();</span></a>
<a name="1116"><span class="lineNum">    1116 </span><span class="lineNoCov">          0 :           std::size_t pos = name.find(&quot;getline&quot;);</span></a>
<a name="1117"><span class="lineNum">    1117 </span><span class="lineNoCov">          0 :           if (pos != string::npos)</span></a>
<a name="1118"><span class="lineNum">    1118 </span>            :              {</a>
<a name="1119"><span class="lineNum">    1119 </span><span class="lineNoCov">          0 :                mfprintf(mlog [ WARN ] ) (&quot;found getline function: pos = %zu \n&quot;,pos);</span></a>
<a name="1120"><span class="lineNum">    1120 </span><span class="lineNoCov">          0 :                mfprintf(mlog [ WARN ] ) (&quot;   --- function name = %s \n&quot;,name.c_str());</span></a>
<a name="1121"><span class="lineNum">    1121 </span><span class="lineNoCov">          0 :                mfprintf(mlog [ WARN ] ) (&quot;   --- functionDeclaration = %p = %s \n&quot;,functionDeclaration,functionDeclaration-&gt;class_name().c_str());</span></a>
<a name="1122"><span class="lineNum">    1122 </span><span class="lineNoCov">          0 :                mfprintf(mlog [ WARN ] ) (&quot;   --- function mangled name = %s \n&quot;,functionDeclaration-&gt;get_mangled_name().str());</span></a>
<a name="1123"><span class="lineNum">    1123 </span><span class="lineNoCov">          0 :                SgTemplateInstantiationFunctionDecl*       templateInstantiationFunctionDecl       = isSgTemplateInstantiationFunctionDecl(functionDeclaration);</span></a>
<a name="1124"><span class="lineNum">    1124 </span><span class="lineNoCov">          0 :                SgTemplateInstantiationMemberFunctionDecl* templateInstantiationMemberFunctionDecl = isSgTemplateInstantiationMemberFunctionDecl(functionDeclaration);</span></a>
<a name="1125"><span class="lineNum">    1125 </span>            : </a>
<a name="1126"><span class="lineNum">    1126 </span><span class="lineNoCov">          0 :                if (templateInstantiationFunctionDecl != NULL)</span></a>
<a name="1127"><span class="lineNum">    1127 </span>            :                   {</a>
<a name="1128"><span class="lineNum">    1128 </span><span class="lineNoCov">          0 :                     SgTemplateFunctionDeclaration* templateFunctionDeclaration = isSgTemplateFunctionDeclaration(templateInstantiationFunctionDecl-&gt;get_templateDeclaration());</span></a>
<a name="1129"><span class="lineNum">    1129 </span><span class="lineNoCov">          0 :                     ASSERT_not_null(templateFunctionDeclaration);</span></a>
<a name="1130"><span class="lineNum">    1130 </span><span class="lineNoCov">          0 :                     mfprintf(mlog [ WARN ] ) (&quot;   --- templateFunctionDeclaration = %p = %s \n&quot;,templateFunctionDeclaration,templateFunctionDeclaration-&gt;class_name().c_str());</span></a>
<a name="1131"><span class="lineNum">    1131 </span><span class="lineNoCov">          0 :                     mfprintf(mlog [ WARN ] ) (&quot;   --- templateFunctionDeclaration-&gt;get_file_info()-&gt;get_filename() = %s \n&quot;,templateFunctionDeclaration-&gt;get_file_info()-&gt;get_filename());</span></a>
<a name="1132"><span class="lineNum">    1132 </span><span class="lineNoCov">          0 :                     mfprintf(mlog [ WARN ] ) (&quot;   --- templateFunctionDeclaration-&gt;get_file_info()-&gt;get_line()     = %d \n&quot;,templateFunctionDeclaration-&gt;get_file_info()-&gt;get_line());</span></a>
<a name="1133"><span class="lineNum">    1133 </span>            :                   }</a>
<a name="1134"><span class="lineNum">    1134 </span>            :                  else</a>
<a name="1135"><span class="lineNum">    1135 </span>            :                   {</a>
<a name="1136"><span class="lineNum">    1136 </span><span class="lineNoCov">          0 :                     if (templateInstantiationMemberFunctionDecl != NULL)</span></a>
<a name="1137"><span class="lineNum">    1137 </span>            :                        {</a>
<a name="1138"><span class="lineNum">    1138 </span><span class="lineNoCov">          0 :                          SgTemplateMemberFunctionDeclaration* templateMemberFunctionDeclaration = isSgTemplateMemberFunctionDeclaration(templateInstantiationMemberFunctionDecl-&gt;get_templateDeclaration());</span></a>
<a name="1139"><span class="lineNum">    1139 </span><span class="lineNoCov">          0 :                          ASSERT_not_null(templateMemberFunctionDeclaration);</span></a>
<a name="1140"><span class="lineNum">    1140 </span><span class="lineNoCov">          0 :                          mfprintf(mlog [ WARN ] ) (&quot;   --- templateMemberFunctionDeclaration = %p = %s \n&quot;,templateMemberFunctionDeclaration,templateMemberFunctionDeclaration-&gt;class_name().c_str());</span></a>
<a name="1141"><span class="lineNum">    1141 </span><span class="lineNoCov">          0 :                          mfprintf(mlog [ WARN ] ) (&quot;   --- templateMemberFunctionDeclaration-&gt;get_file_info()-&gt;get_filename() = %s \n&quot;,templateMemberFunctionDeclaration-&gt;get_file_info()-&gt;get_filename());</span></a>
<a name="1142"><span class="lineNum">    1142 </span><span class="lineNoCov">          0 :                          mfprintf(mlog [ WARN ] ) (&quot;   --- templateMemberFunctionDeclaration-&gt;get_file_info()-&gt;get_line()     = %d \n&quot;,templateMemberFunctionDeclaration-&gt;get_file_info()-&gt;get_line());</span></a>
<a name="1143"><span class="lineNum">    1143 </span>            :                        }</a>
<a name="1144"><span class="lineNum">    1144 </span>            :                       else</a>
<a name="1145"><span class="lineNum">    1145 </span>            :                        {</a>
<a name="1146"><span class="lineNum">    1146 </span><span class="lineNoCov">          0 :                          mfprintf(mlog [ WARN ] ) (&quot;   --- functionDeclaration-&gt;get_file_info()-&gt;get_filename() = %s \n&quot;,functionDeclaration-&gt;get_file_info()-&gt;get_filename());</span></a>
<a name="1147"><span class="lineNum">    1147 </span><span class="lineNoCov">          0 :                          mfprintf(mlog [ WARN ] ) (&quot;   --- functionDeclaration-&gt;get_file_info()-&gt;get_line()     = %d \n&quot;,functionDeclaration-&gt;get_file_info()-&gt;get_line());</span></a>
<a name="1148"><span class="lineNum">    1148 </span>            :                        }</a>
<a name="1149"><span class="lineNum">    1149 </span>            :                   }</a>
<a name="1150"><span class="lineNum">    1150 </span>            : </a>
<a name="1151"><span class="lineNum">    1151 </span><span class="lineNoCov">          0 :                mfprintf(mlog [ WARN ] ) (&quot;   --- functionDeclaration-&gt;isCompilerGenerated() = %s \n&quot;,functionDeclaration-&gt;isCompilerGenerated() ? &quot;true&quot; : &quot;false&quot;);</span></a>
<a name="1152"><span class="lineNum">    1152 </span><span class="lineNoCov">          0 :                mfprintf(mlog [ WARN ] ) (&quot;   --- functionDeclaration-&gt;isTransformation()    = %s \n&quot;,functionDeclaration-&gt;isTransformation()    ? &quot;true&quot; : &quot;false&quot;);</span></a>
<a name="1153"><span class="lineNum">    1153 </span>            :             // mfprintf(mlog [ WARN ] ) (&quot;   --- function: %s \n&quot;,functionDeclaration-&gt;unparseToString().c_str());</a>
<a name="1154"><span class="lineNum">    1154 </span><span class="lineNoCov">          0 :                if (functionDeclaration-&gt;isCompilerGenerated() == true)</span></a>
<a name="1155"><span class="lineNum">    1155 </span>            :                   {</a>
<a name="1156"><span class="lineNum">    1156 </span><span class="lineNoCov">          0 :                     ROSE_ASSERT(functionDeclaration-&gt;isTransformation() == false);</span></a>
<a name="1157"><span class="lineNum">    1157 </span>            : </a>
<a name="1158"><span class="lineNum">    1158 </span><span class="lineNoCov">          0 :                     functionDeclaration-&gt;setTransformation();</span></a>
<a name="1159"><span class="lineNum">    1159 </span><span class="lineNoCov">          0 :                     functionDeclaration-&gt;setOutputInCodeGeneration();</span></a>
<a name="1160"><span class="lineNum">    1160 </span>            : </a>
<a name="1161"><span class="lineNum">    1161 </span><span class="lineNoCov">          0 :                     mfprintf(mlog [ WARN ] ) (&quot;   --- (before unparse) functionDeclaration-&gt;isTransformation()    = %s \n&quot;,functionDeclaration-&gt;isTransformation()    ? &quot;true&quot; : &quot;false&quot;);</span></a>
<a name="1162"><span class="lineNum">    1162 </span>            : </a>
<a name="1163"><span class="lineNum">    1163 </span><span class="lineNoCov">          0 :                     mfprintf(mlog [ WARN ] ) (&quot;   --- function: %s \n&quot;,functionDeclaration-&gt;unparseToString().c_str());</span></a>
<a name="1164"><span class="lineNum">    1164 </span>            : </a>
<a name="1165"><span class="lineNum">    1165 </span><span class="lineNoCov">          0 :                     functionDeclaration-&gt;unsetOutputInCodeGeneration();</span></a>
<a name="1166"><span class="lineNum">    1166 </span><span class="lineNoCov">          0 :                     functionDeclaration-&gt;unsetTransformation();</span></a>
<a name="1167"><span class="lineNum">    1167 </span>            : #if 0</a>
<a name="1168"><span class="lineNum">    1168 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="1169"><span class="lineNum">    1169 </span>            :                     ROSE_ABORT();</a>
<a name="1170"><span class="lineNum">    1170 </span>            : #endif</a>
<a name="1171"><span class="lineNum">    1171 </span>            :                   }</a>
<a name="1172"><span class="lineNum">    1172 </span>            :                  else</a>
<a name="1173"><span class="lineNum">    1173 </span>            :                   {</a>
<a name="1174"><span class="lineNum">    1174 </span>            :                  // mfprintf(mlog [ WARN ] ) (&quot;   --- (non-compiler-generated) function: %s \n&quot;,functionDeclaration-&gt;unparseToString().c_str());</a>
<a name="1175"><span class="lineNum">    1175 </span><span class="lineNoCov">          0 :                     mfprintf(mlog [ WARN ] ) (&quot;   --- function: %s \n&quot;,functionDeclaration-&gt;unparseToString().c_str());</span></a>
<a name="1176"><span class="lineNum">    1176 </span>            :                   }</a>
<a name="1177"><span class="lineNum">    1177 </span>            :              }</a>
<a name="1178"><span class="lineNum">    1178 </span>            :         }</a>
<a name="1179"><span class="lineNum">    1179 </span><span class="lineNoCov">          0 :    }</span></a>
<a name="1180"><span class="lineNum">    1180 </span>            : </a>
<a name="1181"><span class="lineNum">    1181 </span>            : </a>
<a name="1182"><span class="lineNum">    1182 </span>            : </a>
<a name="1183"><span class="lineNum">    1183 </span>            : </a>
<a name="1184"><span class="lineNum">    1184 </span>            : </a>
<a name="1185"><span class="lineNum">    1185 </span>            : // int NameQualificationTraversal::nameQualificationDepth ( SgScopeStatement* classOrNamespaceDefinition )</a>
<a name="1186"><span class="lineNum">    1186 </span>            : int</a>
<a name="1187"><span class="lineNum">    1187 </span><span class="lineCov">    1714820 : NameQualificationTraversal::nameQualificationDepth ( SgDeclarationStatement* declaration, SgScopeStatement* currentScope, SgStatement* positionStatement, bool forceMoreNameQualification )</span></a>
<a name="1188"><span class="lineNum">    1188 </span>            :    {</a>
<a name="1189"><span class="lineNum">    1189 </span>            :   // Note that the input must be a declaration because it can include enums (SgDeclarationStatement IR nodes)</a>
<a name="1190"><span class="lineNum">    1190 </span>            :   // that don't have a corresponding definition (SgScopeStatement IR nodes).</a>
<a name="1191"><span class="lineNum">    1191 </span>            : </a>
<a name="1192"><span class="lineNum">    1192 </span>            :   // This function computes the number of qualified names required to uniquely qualify and input reference.</a>
<a name="1193"><span class="lineNum">    1193 </span>            :   // It evaluates how much name qualification is required (typically 0 (no qualification), but sometimes</a>
<a name="1194"><span class="lineNum">    1194 </span>            :   // the depth of the nesting of scopes plus 1 (full qualification with global scoping operator)).</a>
<a name="1195"><span class="lineNum">    1195 </span>            : </a>
<a name="1196"><span class="lineNum">    1196 </span>            :   // The positionStatement is the position of the associated reference to the declaration.</a>
<a name="1197"><span class="lineNum">    1197 </span>            :   // It is used when &quot;using declarations&quot; are not at the top of the scope.  Initially</a>
<a name="1198"><span class="lineNum">    1198 </span>            :   // we will assume that the such &quot;using declarations&quot; are at the top of the scope.</a>
<a name="1199"><span class="lineNum">    1199 </span>            : </a>
<a name="1200"><span class="lineNum">    1200 </span>            :   // How this works:</a>
<a name="1201"><span class="lineNum">    1201 </span>            :   // The function inputs are:</a>
<a name="1202"><span class="lineNum">    1202 </span>            :   //    1) the declaration whose reference we are evaluating for name qualification.</a>
<a name="1203"><span class="lineNum">    1203 </span>            :   //    2) the current scope of the reference to the declaration (the computed name qualification will be</a>
<a name="1204"><span class="lineNum">    1204 </span>            :   //       prepended to the name of the declaration which is a reference to the declaration passed to this function).</a>
<a name="1205"><span class="lineNum">    1205 </span>            :   //    3) The positonStatement is required to allow name qualification decisions to be based on the reference</a>
<a name="1206"><span class="lineNum">    1206 </span>            :   //       declarations position in scope relative to the input declaration.  Some function declarations require</a>
<a name="1207"><span class="lineNum">    1207 </span>            :   //       name qualification depending on if they appear before or after a prototype declaration for the function</a>
<a name="1208"><span class="lineNum">    1208 </span>            :   //       that would define it's scope (seperate from its visability.</a>
<a name="1209"><span class="lineNum">    1209 </span>            : </a>
<a name="1210"><span class="lineNum">    1210 </span>            :   // Note: we are evaluating the name qualification for references to declarations (e.g. the defining member</a>
<a name="1211"><span class="lineNum">    1211 </span>            :   // function outside of the class which contains the non-defining (prototype) member function declaration).</a>
<a name="1212"><span class="lineNum">    1212 </span>            : </a>
<a name="1213"><span class="lineNum">    1213 </span>            :   // At this point, the symbol for the input function has been looked up in the parent scope of the declaration we are</a>
<a name="1214"><span class="lineNum">    1214 </span>            :   // evaluating for name qualification.  The lookup is for any symbol matching the name, not the name plus the kind of</a>
<a name="1215"><span class="lineNum">    1215 </span>            :   // declaration (which will come in a next step). If it is not found, then it is not visible, and thus at least one level</a>
<a name="1216"><span class="lineNum">    1216 </span>            :   // of name qualification will be required.  If it is found then we need an additional step to decide if the existence of</a>
<a name="1217"><span class="lineNum">    1217 </span>            :   // some declaration with that name will force name elaboration (type elaboration) or name qualification.</a>
<a name="1218"><span class="lineNum">    1218 </span>            : </a>
<a name="1219"><span class="lineNum">    1219 </span>            :   // A test is done on the kind of symbol to determine if its associated declaration will force qualification or type</a>
<a name="1220"><span class="lineNum">    1220 </span>            :   // elaboration.  If the symbol kind (of the kind of declaration associated with the symbol) matches the input declaration</a>
<a name="1221"><span class="lineNum">    1221 </span>            :   // then name qualification will be required, if it is a different kind of declaration the type elaboration might be all</a>
<a name="1222"><span class="lineNum">    1222 </span>            :   // that is required.  For example, a variable name may be the same as a class name, but where this happens, only type</a>
<a name="1223"><span class="lineNum">    1223 </span>            :   // elaboration is required to distinquish the two.  However, if a declaration name is classing with another declaration</a>
<a name="1224"><span class="lineNum">    1224 </span>            :   // name of the same kind, then only name qualification will distinguish the two.</a>
<a name="1225"><span class="lineNum">    1225 </span>            : </a>
<a name="1226"><span class="lineNum">    1226 </span>            :   // If name qualification is required, then we repeat the lookup in the symbol table, using a more refined search to only</a>
<a name="1227"><span class="lineNum">    1227 </span>            :   // get symbols of the type that would force name qualification.</a>
<a name="1228"><span class="lineNum">    1228 </span>            : </a>
<a name="1229"><span class="lineNum">    1229 </span>            :   // Note that this function is recursive, the current scope will remain fixed, but the declaration associated with the</a>
<a name="1230"><span class="lineNum">    1230 </span>            :   // target decaration will be walked up in the AST toward the global scope, each time computing the associated declaration</a>
<a name="1231"><span class="lineNum">    1231 </span>            :   // for each new scope where we evaluated.  The count of the number of scopes (scope depth) required for name qualification</a>
<a name="1232"><span class="lineNum">    1232 </span>            :   // (until the scope containing the input declaration is found) is all that this function returns.</a>
<a name="1233"><span class="lineNum">    1233 </span>            : </a>
<a name="1234"><span class="lineNum">    1234 </span>            :   // Note: this function is overloaded to take other kinds of IR nodes that require name qualification, but are not</a>
<a name="1235"><span class="lineNum">    1235 </span>            :   // SgDeclarationStatements (e.g. SgInitializedName).</a>
<a name="1236"><span class="lineNum">    1236 </span>            : </a>
<a name="1237"><span class="lineNum">    1237 </span><span class="lineCov">    1714820 :      ASSERT_not_null(declaration);</span></a>
<a name="1238"><span class="lineNum">    1238 </span><span class="lineCov">    1714820 :      ASSERT_not_null(currentScope);</span></a>
<a name="1239"><span class="lineNum">    1239 </span>            : </a>
<a name="1240"><span class="lineNum">    1240 </span>            :   // DQ (6/22/2011): Assert this as a preliminary step to its removal.</a>
<a name="1241"><span class="lineNum">    1241 </span><span class="lineCov">    1714820 :      ROSE_ASSERT(forceMoreNameQualification == false);</span></a>
<a name="1242"><span class="lineNum">    1242 </span>            : </a>
<a name="1243"><span class="lineNum">    1243 </span>            :   // DQ (4/4/2014): Added assertion.</a>
<a name="1244"><span class="lineNum">    1244 </span><span class="lineCov">    1714820 :      ASSERT_not_null(positionStatement);</span></a>
<a name="1245"><span class="lineNum">    1245 </span>            : </a>
<a name="1246"><span class="lineNum">    1246 </span><span class="lineCov">    1714820 :      int  qualificationDepth        = 0;</span></a>
<a name="1247"><span class="lineNum">    1247 </span>            : </a>
<a name="1248"><span class="lineNum">    1248 </span><span class="lineCov">    1714820 :      bool typeElaborationIsRequired = false;</span></a>
<a name="1249"><span class="lineNum">    1249 </span>            :   // bool globalQualifierIsRequired = false;</a>
<a name="1250"><span class="lineNum">    1250 </span>            : </a>
<a name="1251"><span class="lineNum">    1251 </span>            : #define DEBUG_FUNCTION_RESOLUTION 0</a>
<a name="1252"><span class="lineNum">    1252 </span>            : </a>
<a name="1253"><span class="lineNum">    1253 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="1254"><span class="lineNum">    1254 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;\n\n########################################################################## \n&quot;);</a>
<a name="1255"><span class="lineNum">    1255 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;########################################################################## \n&quot;);</a>
<a name="1256"><span class="lineNum">    1256 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;########################################################################## \n&quot;);</a>
<a name="1257"><span class="lineNum">    1257 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;########################################################################## \n&quot;);</a>
<a name="1258"><span class="lineNum">    1258 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;##### Inside of NameQualificationTraversal::nameQualificationDepth() ##### \n&quot;);</a>
<a name="1259"><span class="lineNum">    1259 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;########################################################################## \n&quot;);</a>
<a name="1260"><span class="lineNum">    1260 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;########################################################################## \n&quot;);</a>
<a name="1261"><span class="lineNum">    1261 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;########################################################################## \n&quot;);</a>
<a name="1262"><span class="lineNum">    1262 </span>            : </a>
<a name="1263"><span class="lineNum">    1263 </span>            :   // The use of SageInterface::generateUniqueName() can cause the unparser to be called and triggers the name</a>
<a name="1264"><span class="lineNum">    1264 </span>            :   // qualification recursively but only for template declaration (SgTemplateInstantiationDecl, I think).</a>
<a name="1265"><span class="lineNum">    1265 </span>            :   // mfprintf(mlog [ WARN ] ) (&quot;declaration  = %p = %s = %s = %s \n&quot;,declaration,declaration-&gt;class_name().c_str(),SageInterface::get_name(declaration).c_str(),SageInterface::generateUniqueName(declaration,true).c_str());</a>
<a name="1266"><span class="lineNum">    1266 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;   --- declaration  = %p = %s = %s \n&quot;,declaration,declaration-&gt;class_name().c_str(),SageInterface::get_name(declaration).c_str());</a>
<a name="1267"><span class="lineNum">    1267 </span>            :      declaration-&gt;get_startOfConstruct()-&gt;display(&quot;declaration&quot;);</a>
<a name="1268"><span class="lineNum">    1268 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;   --- currentScope = %p = %s = %s \n&quot;,currentScope,currentScope-&gt;class_name().c_str(),SageInterface::get_name(currentScope).c_str());</a>
<a name="1269"><span class="lineNum">    1269 </span>            :      currentScope-&gt;get_startOfConstruct()-&gt;display(&quot;currentScope&quot;);</a>
<a name="1270"><span class="lineNum">    1270 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;   --- positionStatement = %p = %s \n&quot;,positionStatement,positionStatement-&gt;class_name().c_str());</a>
<a name="1271"><span class="lineNum">    1271 </span>            :      positionStatement-&gt;get_startOfConstruct()-&gt;display(&quot;positionStatement&quot;);</a>
<a name="1272"><span class="lineNum">    1272 </span>            : #endif</a>
<a name="1273"><span class="lineNum">    1273 </span>            : </a>
<a name="1274"><span class="lineNum">    1274 </span><span class="lineCov">    1714820 :      SgNonrealDecl*                        nonrealDecl               = isSgNonrealDecl(declaration);</span></a>
<a name="1275"><span class="lineNum">    1275 </span><span class="lineCov">    1714820 :      SgClassDeclaration*                   classDeclaration          = isSgClassDeclaration(declaration);</span></a>
<a name="1276"><span class="lineNum">    1276 </span><span class="lineCov">    1714820 :      SgVariableDeclaration*                variableDeclaration       = isSgVariableDeclaration(declaration);</span></a>
<a name="1277"><span class="lineNum">    1277 </span><span class="lineCov">    1714820 :      SgFunctionDeclaration*                functionDeclaration       = isSgFunctionDeclaration(declaration);</span></a>
<a name="1278"><span class="lineNum">    1278 </span><span class="lineCov">    1714820 :      SgTypedefDeclaration*                 typedefDeclaration        = isSgTypedefDeclaration(declaration);</span></a>
<a name="1279"><span class="lineNum">    1279 </span><span class="lineCov">    1714820 :      SgTemplateDeclaration*                templateDeclaration       = isSgTemplateDeclaration(declaration);</span></a>
<a name="1280"><span class="lineNum">    1280 </span><span class="lineCov">    1714820 :      SgEnumDeclaration*                    enumDeclaration           = isSgEnumDeclaration(declaration);</span></a>
<a name="1281"><span class="lineNum">    1281 </span><span class="lineCov">    1714820 :      SgNamespaceDeclarationStatement*      namespaceDeclaration      = isSgNamespaceDeclarationStatement(declaration);</span></a>
<a name="1282"><span class="lineNum">    1282 </span>            : </a>
<a name="1283"><span class="lineNum">    1283 </span>            :   // DQ (4/9/2018): Added support for namespace alias declarations.</a>
<a name="1284"><span class="lineNum">    1284 </span><span class="lineCov">    1714820 :      SgNamespaceAliasDeclarationStatement* namespaceAliasDeclaration = isSgNamespaceAliasDeclarationStatement(declaration);</span></a>
<a name="1285"><span class="lineNum">    1285 </span>            : </a>
<a name="1286"><span class="lineNum">    1286 </span>            : #if 0</a>
<a name="1287"><span class="lineNum">    1287 </span>            :   // SgClassDefinition*  classDefinition  = classDeclaration != NULL ? classDeclaration-&gt;get_definition() : NULL;</a>
<a name="1288"><span class="lineNum">    1288 </span>            :   // ASSERT_not_null(classDeclaration);</a>
<a name="1289"><span class="lineNum">    1289 </span>            :      SgClassDefinition*  classDefinition  = classDeclaration != NULL ? isSgClassDeclaration(classDeclaration-&gt;get_definingDeclaration())-&gt;get_definition() : NULL;</a>
<a name="1290"><span class="lineNum">    1290 </span>            : </a>
<a name="1291"><span class="lineNum">    1291 </span>            :      if (classDefinition != NULL)</a>
<a name="1292"><span class="lineNum">    1292 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;classDefinition = %p = %s = %s \n&quot;,classDefinition,classDefinition-&gt;class_name().c_str(),SageInterface::get_name(classDefinition).c_str());</a>
<a name="1293"><span class="lineNum">    1293 </span>            :        else</a>
<a name="1294"><span class="lineNum">    1294 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;classDefinition == NULL \n&quot;);</a>
<a name="1295"><span class="lineNum">    1295 </span>            : </a>
<a name="1296"><span class="lineNum">    1296 </span>            :   // SgNamespaceDefinitionStatement*  namespaceDefinition  = namespaceDeclaration != NULL ? namespaceDeclaration-&gt;get_definition() : NULL;</a>
<a name="1297"><span class="lineNum">    1297 </span>            : #endif</a>
<a name="1298"><span class="lineNum">    1298 </span>            : </a>
<a name="1299"><span class="lineNum">    1299 </span>            :   // Make sure that the definitions and declarations are consistant.</a>
<a name="1300"><span class="lineNum">    1300 </span>            :   // ROSE_ASSERT(classDefinition != NULL || namespaceDefinition != NULL);</a>
<a name="1301"><span class="lineNum">    1301 </span>            :   // ROSE_ASSERT((classDefinition != NULL &amp;&amp; classDeclaration != NULL) || (namespaceDefinition != NULL &amp;&amp; namespaceDeclaration != NULL));</a>
<a name="1302"><span class="lineNum">    1302 </span>            :   // ROSE_ASSERT(classDeclaration != NULL || namespaceDeclaration != NULL);</a>
<a name="1303"><span class="lineNum">    1303 </span>            :   // ROSE_ASSERT(classDeclaration != NULL || namespaceDeclaration != NULL || variableDeclaration != NULL || functionDeclaration != NULL || typedefDeclaration != NULL || templateDeclaration != NULL || enumDeclaration != NULL );</a>
<a name="1304"><span class="lineNum">    1304 </span><span class="lineCov">    1714820 :      ROSE_ASSERT(classDeclaration != NULL || namespaceDeclaration != NULL || namespaceAliasDeclaration != NULL || variableDeclaration != NULL || functionDeclaration != NULL || typedefDeclaration != NULL || templateDeclaration != NULL || enumDeclaration != NULL || nonrealDecl != NULL );</span></a>
<a name="1305"><span class="lineNum">    1305 </span>            : </a>
<a name="1306"><span class="lineNum">    1306 </span>            :   // ROSE_ASSERT((classDeclaration != NULL &amp;&amp; classDefinition != NULL) || (namespaceDeclaration != NULL &amp;&amp; namespaceDefinition != NULL) || variableDeclaration != NULL);</a>
<a name="1307"><span class="lineNum">    1307 </span>            : </a>
<a name="1308"><span class="lineNum">    1308 </span>            :   // SgName name = (classDeclaration != NULL) ? classDeclaration-&gt;get_name() : ((namespaceDeclaration != NULL) ? namespaceDeclaration-&gt;get_name() : &quot;unknown&quot;);</a>
<a name="1309"><span class="lineNum">    1309 </span><span class="lineCov">    1714820 :      SgName name = (nonrealDecl               != NULL) ? nonrealDecl-&gt;get_name()          :</span></a>
<a name="1310"><span class="lineNum">    1310 </span>            :                    (classDeclaration          != NULL) ? classDeclaration-&gt;get_name()     :</a>
<a name="1311"><span class="lineNum">    1311 </span>            :                    (namespaceDeclaration      != NULL) ? namespaceDeclaration-&gt;get_name() :</a>
<a name="1312"><span class="lineNum">    1312 </span>            :                    (namespaceAliasDeclaration != NULL) ? namespaceAliasDeclaration-&gt;get_name() :</a>
<a name="1313"><span class="lineNum">    1313 </span>            :                    (variableDeclaration       != NULL) ? SageInterface::getFirstInitializedName(variableDeclaration)-&gt;get_name() :</a>
<a name="1314"><span class="lineNum">    1314 </span>            :                    (functionDeclaration       != NULL) ? functionDeclaration-&gt;get_name()  :</a>
<a name="1315"><span class="lineNum">    1315 </span>            :                    (typedefDeclaration        != NULL) ? typedefDeclaration-&gt;get_name()   :</a>
<a name="1316"><span class="lineNum">    1316 </span>            :                    (templateDeclaration       != NULL) ? templateDeclaration-&gt;get_name()  :</a>
<a name="1317"><span class="lineNum">    1317 </span><span class="lineCov">    3429630 :                    (enumDeclaration           != NULL) ? enumDeclaration-&gt;get_name()      : &quot;unknown_name&quot;;</span></a>
<a name="1318"><span class="lineNum">    1318 </span>            : </a>
<a name="1319"><span class="lineNum">    1319 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="1320"><span class="lineNum">    1320 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In nameQualificationDepth(SgDeclarationStatement*,...): declaration = %p = %s name = %s \n&quot;,declaration,declaration-&gt;class_name().c_str(),name.str());</a>
<a name="1321"><span class="lineNum">    1321 </span>            : #endif</a>
<a name="1322"><span class="lineNum">    1322 </span>            : </a>
<a name="1323"><span class="lineNum">    1323 </span>            : #if 0</a>
<a name="1324"><span class="lineNum">    1324 </span>            :   // ROSE_ASSERT(name.is_null() == false);</a>
<a name="1325"><span class="lineNum">    1325 </span>            : </a>
<a name="1326"><span class="lineNum">    1326 </span>            :   // DQ (8/31/2014): The handling of this as a special case is funtamentally the problem with the test code (test2014_183.C)</a>
<a name="1327"><span class="lineNum">    1327 </span>            :   // which demonstrates a namespace nested in a namespace with the same name (when this happens it is likely a bug, however</a>
<a name="1328"><span class="lineNum">    1328 </span>            :   // it is legal C++ code and ROSE was having problem with this that sort of language construct and the issue is traced to</a>
<a name="1329"><span class="lineNum">    1329 </span>            :   // the handling of un-named constructs in this code below.</a>
<a name="1330"><span class="lineNum">    1330 </span>            :      if (name.is_null() == true)</a>
<a name="1331"><span class="lineNum">    1331 </span>            :         {</a>
<a name="1332"><span class="lineNum">    1332 </span>            :        // This name is empty so we need to keep going to evaluate the qualified name (see test2006_121.C).</a>
<a name="1333"><span class="lineNum">    1333 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="1334"><span class="lineNum">    1334 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;CASE OF EMPTY NAME: declaration = %p = %s but has no valid name (it has and empty name), thus we have to recurse to the next level \n&quot;,declaration,declaration-&gt;class_name().c_str());</a>
<a name="1335"><span class="lineNum">    1335 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;   --- currentScope      = %p = %s \n&quot;,currentScope,currentScope-&gt;class_name().c_str());</a>
<a name="1336"><span class="lineNum">    1336 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;   --- positionStatement = %p = %s \n&quot;,positionStatement,positionStatement-&gt;class_name().c_str());</a>
<a name="1337"><span class="lineNum">    1337 </span>            : #endif</a>
<a name="1338"><span class="lineNum">    1338 </span>            : </a>
<a name="1339"><span class="lineNum">    1339 </span>            :        // DQ (8/20/2014): Add support for un-named namespaces (see test2014_132.C for an example).</a>
<a name="1340"><span class="lineNum">    1340 </span>            :        // qualificationDepth = nameQualificationDepthOfParent(declaration,currentScope,positionStatement) + 1;</a>
<a name="1341"><span class="lineNum">    1341 </span>            :           if (namespaceDeclaration != NULL)</a>
<a name="1342"><span class="lineNum">    1342 </span>            :              {</a>
<a name="1343"><span class="lineNum">    1343 </span>            :             // I am clearer on the case that for a namespace declaration we do not want to increment the qualificationDepth.</a>
<a name="1344"><span class="lineNum">    1344 </span>            :                qualificationDepth = nameQualificationDepthOfParent(declaration,currentScope,positionStatement) + 0;</a>
<a name="1345"><span class="lineNum">    1345 </span>            :              }</a>
<a name="1346"><span class="lineNum">    1346 </span>            :             else</a>
<a name="1347"><span class="lineNum">    1347 </span>            :              {</a>
<a name="1348"><span class="lineNum">    1348 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;NEW CASE OF EMPTY NAME: declaration = %p = %s but has no valid name (it has and empty name), thus we add 1 to the qualificationDepth and have to recurse to the next level \n&quot;,declaration,declaration-&gt;class_name().c_str());</a>
<a name="1349"><span class="lineNum">    1349 </span>            : </a>
<a name="1350"><span class="lineNum">    1350 </span>            :                qualificationDepth = nameQualificationDepthOfParent(declaration,currentScope,positionStatement) + 1;</a>
<a name="1351"><span class="lineNum">    1351 </span>            :              }</a>
<a name="1352"><span class="lineNum">    1352 </span>            :         }</a>
<a name="1353"><span class="lineNum">    1353 </span>            : #else</a>
<a name="1354"><span class="lineNum">    1354 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="1355"><span class="lineNum">    1355 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In nameQualificationDepth(SgDeclarationStatement*,...): Skipping special handling of un-named constructs (not required): declaration = %p = %s \n&quot;,declaration,declaration-&gt;class_name().c_str());</a>
<a name="1356"><span class="lineNum">    1356 </span>            : #endif</a>
<a name="1357"><span class="lineNum">    1357 </span>            : #endif</a>
<a name="1358"><span class="lineNum">    1358 </span>            : </a>
<a name="1359"><span class="lineNum">    1359 </span>            :   // DQ (8/16/2013): Build the template parameters and template arguments as appropriate (will be NULL pointers for some types of declarations).</a>
<a name="1360"><span class="lineNum">    1360 </span><span class="lineCov">    1714820 :      SgTemplateParameterPtrList* templateParameterList = SageBuilder::getTemplateParameterList(declaration);</span></a>
<a name="1361"><span class="lineNum">    1361 </span><span class="lineCov">    1714820 :      SgTemplateArgumentPtrList*  templateArgumentList  = SageBuilder::getTemplateArgumentList(declaration);</span></a>
<a name="1362"><span class="lineNum">    1362 </span>            : </a>
<a name="1363"><span class="lineNum">    1363 </span>            : #if 0</a>
<a name="1364"><span class="lineNum">    1364 </span>            :   // DQ (5/8/2011): I think we don't need to handle this special case.</a>
<a name="1365"><span class="lineNum">    1365 </span>            : </a>
<a name="1366"><span class="lineNum">    1366 </span>            :   // The global scope is the root of the tree of scopes so we can't ask for the parent of this scope and thus it is a special case.</a>
<a name="1367"><span class="lineNum">    1367 </span>            :      SgGlobal* globalScope = isSgGlobal(currentScope);</a>
<a name="1368"><span class="lineNum">    1368 </span>            :      if (globalScope != NULL)</a>
<a name="1369"><span class="lineNum">    1369 </span>            :         {</a>
<a name="1370"><span class="lineNum">    1370 </span>            :        // We could have a using declaration include another declaration with the same name into the current</a>
<a name="1371"><span class="lineNum">    1371 </span>            :        // scope.  If there is more than one then name qalification is required to dismbiguate them.</a>
<a name="1372"><span class="lineNum">    1372 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;We still need to check for more than one name in currentScope = %s \n&quot;,currentScope-&gt;class_name().c_str());</a>
<a name="1373"><span class="lineNum">    1373 </span>            : </a>
<a name="1374"><span class="lineNum">    1374 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="1375"><span class="lineNum">    1375 </span>            : </a>
<a name="1376"><span class="lineNum">    1376 </span>            :        // Make sure that there is no ambiguity (should be only one symbol with this name).</a>
<a name="1377"><span class="lineNum">    1377 </span>            :           size_t numberOfSymbols = globalScope-&gt;count_symbol(name);</a>
<a name="1378"><span class="lineNum">    1378 </span>            :           if (numberOfSymbols &gt; 1)</a>
<a name="1379"><span class="lineNum">    1379 </span>            :              {</a>
<a name="1380"><span class="lineNum">    1380 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Found a case of ambiguity in the global scope (trigger global name qualifier). \n&quot;);</a>
<a name="1381"><span class="lineNum">    1381 </span>            :                qualificationDepth++;</a>
<a name="1382"><span class="lineNum">    1382 </span>            : </a>
<a name="1383"><span class="lineNum">    1383 </span>            :             // I think that this means that global qualification is required.</a>
<a name="1384"><span class="lineNum">    1384 </span>            :                globalQualifierIsRequired = true;</a>
<a name="1385"><span class="lineNum">    1385 </span>            :              }</a>
<a name="1386"><span class="lineNum">    1386 </span>            : </a>
<a name="1387"><span class="lineNum">    1387 </span>            :        // To debug this for now, just handle the case of a single symbol with this name.</a>
<a name="1388"><span class="lineNum">    1388 </span>            :        // ROSE_ASSERT(numberOfSymbols == 1);</a>
<a name="1389"><span class="lineNum">    1389 </span>            :         }</a>
<a name="1390"><span class="lineNum">    1390 </span>            :        else</a>
<a name="1391"><span class="lineNum">    1391 </span>            : #endif</a>
<a name="1392"><span class="lineNum">    1392 </span><span class="lineCov">    1714820 :         {</span></a>
<a name="1393"><span class="lineNum">    1393 </span>            :        // Note that there can be more than one symbol if the name is hidden in a base class scope (and thus there are SgAliasSymbols using the same name).</a>
<a name="1394"><span class="lineNum">    1394 </span><span class="lineCov">    1714820 :           ASSERT_not_null(currentScope);</span></a>
<a name="1395"><span class="lineNum">    1395 </span>            : </a>
<a name="1396"><span class="lineNum">    1396 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="1397"><span class="lineNum">    1397 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Initial lookup: name = %s currentScope = %p = %s \n&quot;,name.str(),currentScope,currentScope-&gt;class_name().c_str());</a>
<a name="1398"><span class="lineNum">    1398 </span>            : #endif</a>
<a name="1399"><span class="lineNum">    1399 </span>            : </a>
<a name="1400"><span class="lineNum">    1400 </span>            : </a>
<a name="1401"><span class="lineNum">    1401 </span>            : #if 0</a>
<a name="1402"><span class="lineNum">    1402 </span>            :        // DQ (8/9/2020): Alternatively, I will try a different fix for Cxx_tests/test2020_20.C.  It might be better to use the</a>
<a name="1403"><span class="lineNum">    1403 </span>            :        // unmodified name qualification, and instead fix the support for using namespace directives and control which symbols are</a>
<a name="1404"><span class="lineNum">    1404 </span>            :        // introduced as SgAliasSymbols.</a>
<a name="1405"><span class="lineNum">    1405 </span>            :        // DQ (8/5/2020): When a using namespace declaration is used, the name qualification rules are different because the symbols</a>
<a name="1406"><span class="lineNum">    1406 </span>            :        // from the using namespace directive's namespace are not allowed to hide existing symbols from lookups not accounting for</a>
<a name="1407"><span class="lineNum">    1407 </span>            :        // alias symbols.  So we need to see if the target symbol is visable through the parent, but skipping matches that would</a>
<a name="1408"><span class="lineNum">    1408 </span>            :        // come from SgAliasSymbols (which are introduced to represent symbols that are shared bewteeen where they are declared and</a>
<a name="1409"><span class="lineNum">    1409 </span>            :        // where they are aliased via a using namespace directive.</a>
<a name="1410"><span class="lineNum">    1410 </span>            :        // bool symbol_is_visible_ignoring_alias_symbols = false;</a>
<a name="1411"><span class="lineNum">    1411 </span>            :           SgSymbol* trial_lookup_symbol = SageInterface::lookupSymbolInParentScopesIgnoringAliasSymbols (name,currentScope,templateParameterList,templateArgumentList);</a>
<a name="1412"><span class="lineNum">    1412 </span>            : </a>
<a name="1413"><span class="lineNum">    1413 </span>            : #define DEBUG_NONALIAS_SYMBOL_SUPPORT 0</a>
<a name="1414"><span class="lineNum">    1414 </span>            : </a>
<a name="1415"><span class="lineNum">    1415 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="1416"><span class="lineNum">    1416 </span>            : </a>
<a name="1417"><span class="lineNum">    1417 </span>            :           if (trial_lookup_symbol != NULL)</a>
<a name="1418"><span class="lineNum">    1418 </span>            :              {</a>
<a name="1419"><span class="lineNum">    1419 </span>            : // #if 0</a>
<a name="1420"><span class="lineNum">    1420 </span>            : #if DEBUG_NONALIAS_SYMBOL_SUPPORT</a>
<a name="1421"><span class="lineNum">    1421 </span>            :                printf (&quot;Found a symbol via the lookup ignoring alias symbols \n&quot;);</a>
<a name="1422"><span class="lineNum">    1422 </span>            : </a>
<a name="1423"><span class="lineNum">    1423 </span>            :             // Check is this is the kind of symbol that matches the declaration sought.</a>
<a name="1424"><span class="lineNum">    1424 </span>            :                printf (&quot;Check is this is the kind of symbol that matches the declaration sought \n&quot;);</a>
<a name="1425"><span class="lineNum">    1425 </span>            : #endif</a>
<a name="1426"><span class="lineNum">    1426 </span>            :             // This can not be a SgAliasSymbol.</a>
<a name="1427"><span class="lineNum">    1427 </span>            :                ROSE_ASSERT(isSgAliasSymbol(trial_lookup_symbol) == NULL);</a>
<a name="1428"><span class="lineNum">    1428 </span>            : </a>
<a name="1429"><span class="lineNum">    1429 </span>            :             // Still need to verify this is the symbol associated with the target declaration.</a>
<a name="1430"><span class="lineNum">    1430 </span>            :             // symbol_is_visible_ignoring_alias_symbols = true;</a>
<a name="1431"><span class="lineNum">    1431 </span>            : </a>
<a name="1432"><span class="lineNum">    1432 </span>            :                int numberOfSymbols = currentScope-&gt;count_symbol(name);</a>
<a name="1433"><span class="lineNum">    1433 </span>            : </a>
<a name="1434"><span class="lineNum">    1434 </span>            : #if DEBUG_NONALIAS_SYMBOL_SUPPORT</a>
<a name="1435"><span class="lineNum">    1435 </span>            :                printf (&quot;trial_lookup_symbol = %p = %s \n&quot;,trial_lookup_symbol,trial_lookup_symbol-&gt;class_name().c_str());</a>
<a name="1436"><span class="lineNum">    1436 </span>            :                printf (&quot; --- numberOfSymbols = %d \n&quot;,numberOfSymbols);</a>
<a name="1437"><span class="lineNum">    1437 </span>            : #endif</a>
<a name="1438"><span class="lineNum">    1438 </span>            :                SgDeclarationStatement* trial_declaration = NULL;</a>
<a name="1439"><span class="lineNum">    1439 </span>            :                SgInitializedName* trial_initializedName = NULL;</a>
<a name="1440"><span class="lineNum">    1440 </span>            :                switch (trial_lookup_symbol-&gt;variantT())</a>
<a name="1441"><span class="lineNum">    1441 </span>            :                   {</a>
<a name="1442"><span class="lineNum">    1442 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="1443"><span class="lineNum">    1443 </span>            : </a>
<a name="1444"><span class="lineNum">    1444 </span>            :                     case V_SgClassSymbol:</a>
<a name="1445"><span class="lineNum">    1445 </span>            :                        {</a>
<a name="1446"><span class="lineNum">    1446 </span>            :                          SgClassSymbol* class_symbol = isSgClassSymbol(trial_lookup_symbol);</a>
<a name="1447"><span class="lineNum">    1447 </span>            :                          ROSE_ASSERT(class_symbol != NULL);</a>
<a name="1448"><span class="lineNum">    1448 </span>            : </a>
<a name="1449"><span class="lineNum">    1449 </span>            :                          trial_declaration = class_symbol-&gt;get_declaration();</a>
<a name="1450"><span class="lineNum">    1450 </span>            :                          break;</a>
<a name="1451"><span class="lineNum">    1451 </span>            :                        }</a>
<a name="1452"><span class="lineNum">    1452 </span>            : </a>
<a name="1453"><span class="lineNum">    1453 </span>            :                     case V_SgVariableSymbol:</a>
<a name="1454"><span class="lineNum">    1454 </span>            :                        {</a>
<a name="1455"><span class="lineNum">    1455 </span>            :                          SgVariableSymbol* variable_symbol = isSgVariableSymbol(trial_lookup_symbol);</a>
<a name="1456"><span class="lineNum">    1456 </span>            :                          ROSE_ASSERT(variable_symbol != NULL);</a>
<a name="1457"><span class="lineNum">    1457 </span>            : </a>
<a name="1458"><span class="lineNum">    1458 </span>            :                          trial_initializedName = variable_symbol-&gt;get_declaration();</a>
<a name="1459"><span class="lineNum">    1459 </span>            :                          trial_declaration = NULL;</a>
<a name="1460"><span class="lineNum">    1460 </span>            :                          break;</a>
<a name="1461"><span class="lineNum">    1461 </span>            :                        }</a>
<a name="1462"><span class="lineNum">    1462 </span>            : </a>
<a name="1463"><span class="lineNum">    1463 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="1464"><span class="lineNum">    1464 </span>            : </a>
<a name="1465"><span class="lineNum">    1465 </span>            :                     case V_SgFunctionSymbol:</a>
<a name="1466"><span class="lineNum">    1466 </span>            :                        {</a>
<a name="1467"><span class="lineNum">    1467 </span>            :                          SgFunctionSymbol* function_symbol = isSgFunctionSymbol(trial_lookup_symbol);</a>
<a name="1468"><span class="lineNum">    1468 </span>            :                          ROSE_ASSERT(function_symbol != NULL);</a>
<a name="1469"><span class="lineNum">    1469 </span>            : </a>
<a name="1470"><span class="lineNum">    1470 </span>            :                          trial_declaration = function_symbol-&gt;get_declaration();</a>
<a name="1471"><span class="lineNum">    1471 </span>            :                          break;</a>
<a name="1472"><span class="lineNum">    1472 </span>            :                        }</a>
<a name="1473"><span class="lineNum">    1473 </span>            : </a>
<a name="1474"><span class="lineNum">    1474 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="1475"><span class="lineNum">    1475 </span>            : </a>
<a name="1476"><span class="lineNum">    1476 </span>            :                     case V_SgTypedefSymbol:</a>
<a name="1477"><span class="lineNum">    1477 </span>            :                        {</a>
<a name="1478"><span class="lineNum">    1478 </span>            :                          SgTypedefSymbol* typedef_symbol = isSgTypedefSymbol(trial_lookup_symbol);</a>
<a name="1479"><span class="lineNum">    1479 </span>            :                          ROSE_ASSERT(typedef_symbol != NULL);</a>
<a name="1480"><span class="lineNum">    1480 </span>            : </a>
<a name="1481"><span class="lineNum">    1481 </span>            :                          trial_declaration = typedef_symbol-&gt;get_declaration();</a>
<a name="1482"><span class="lineNum">    1482 </span>            :                          break;</a>
<a name="1483"><span class="lineNum">    1483 </span>            :                        }</a>
<a name="1484"><span class="lineNum">    1484 </span>            : </a>
<a name="1485"><span class="lineNum">    1485 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="1486"><span class="lineNum">    1486 </span>            : </a>
<a name="1487"><span class="lineNum">    1487 </span>            :                     case V_SgEnumSymbol:</a>
<a name="1488"><span class="lineNum">    1488 </span>            :                        {</a>
<a name="1489"><span class="lineNum">    1489 </span>            :                          SgEnumSymbol* enum_symbol = isSgEnumSymbol(trial_lookup_symbol);</a>
<a name="1490"><span class="lineNum">    1490 </span>            :                          ROSE_ASSERT(enum_symbol != NULL);</a>
<a name="1491"><span class="lineNum">    1491 </span>            : </a>
<a name="1492"><span class="lineNum">    1492 </span>            :                          trial_declaration = enum_symbol-&gt;get_declaration();</a>
<a name="1493"><span class="lineNum">    1493 </span>            :                          break;</a>
<a name="1494"><span class="lineNum">    1494 </span>            :                        }</a>
<a name="1495"><span class="lineNum">    1495 </span>            : </a>
<a name="1496"><span class="lineNum">    1496 </span>            :                     case V_SgNamespaceSymbol:</a>
<a name="1497"><span class="lineNum">    1497 </span>            :                        {</a>
<a name="1498"><span class="lineNum">    1498 </span>            :                          SgNamespaceSymbol* namespace_symbol = isSgNamespaceSymbol(trial_lookup_symbol);</a>
<a name="1499"><span class="lineNum">    1499 </span>            :                          ROSE_ASSERT(namespace_symbol != NULL);</a>
<a name="1500"><span class="lineNum">    1500 </span>            : </a>
<a name="1501"><span class="lineNum">    1501 </span>            :                          trial_declaration = namespace_symbol-&gt;get_declaration();</a>
<a name="1502"><span class="lineNum">    1502 </span>            :                          break;</a>
<a name="1503"><span class="lineNum">    1503 </span>            :                        }</a>
<a name="1504"><span class="lineNum">    1504 </span>            : </a>
<a name="1505"><span class="lineNum">    1505 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="1506"><span class="lineNum">    1506 </span>            : </a>
<a name="1507"><span class="lineNum">    1507 </span>            :                     case V_SgTemplateClassSymbol:</a>
<a name="1508"><span class="lineNum">    1508 </span>            :                        {</a>
<a name="1509"><span class="lineNum">    1509 </span>            :                          SgTemplateClassSymbol* templateClass_symbol = isSgTemplateClassSymbol(trial_lookup_symbol);</a>
<a name="1510"><span class="lineNum">    1510 </span>            :                          ROSE_ASSERT(templateClass_symbol != NULL);</a>
<a name="1511"><span class="lineNum">    1511 </span>            : </a>
<a name="1512"><span class="lineNum">    1512 </span>            :                          trial_declaration = templateClass_symbol-&gt;get_declaration();</a>
<a name="1513"><span class="lineNum">    1513 </span>            :                          break;</a>
<a name="1514"><span class="lineNum">    1514 </span>            :                        }</a>
<a name="1515"><span class="lineNum">    1515 </span>            : </a>
<a name="1516"><span class="lineNum">    1516 </span>            :                     case V_SgEnumFieldSymbol:</a>
<a name="1517"><span class="lineNum">    1517 </span>            :                        {</a>
<a name="1518"><span class="lineNum">    1518 </span>            :                          SgEnumFieldSymbol* enumField_symbol = isSgEnumFieldSymbol(trial_lookup_symbol);</a>
<a name="1519"><span class="lineNum">    1519 </span>            :                          ROSE_ASSERT(enumField_symbol != NULL);</a>
<a name="1520"><span class="lineNum">    1520 </span>            : </a>
<a name="1521"><span class="lineNum">    1521 </span>            :                          trial_initializedName = enumField_symbol-&gt;get_declaration();</a>
<a name="1522"><span class="lineNum">    1522 </span>            :                          trial_declaration = NULL;</a>
<a name="1523"><span class="lineNum">    1523 </span>            :                          break;</a>
<a name="1524"><span class="lineNum">    1524 </span>            :                        }</a>
<a name="1525"><span class="lineNum">    1525 </span>            : </a>
<a name="1526"><span class="lineNum">    1526 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="1527"><span class="lineNum">    1527 </span>            : </a>
<a name="1528"><span class="lineNum">    1528 </span>            :                     case V_SgTemplateFunctionSymbol:</a>
<a name="1529"><span class="lineNum">    1529 </span>            :                        {</a>
<a name="1530"><span class="lineNum">    1530 </span>            :                          SgTemplateFunctionSymbol* templateFunction_symbol = isSgTemplateFunctionSymbol(trial_lookup_symbol);</a>
<a name="1531"><span class="lineNum">    1531 </span>            :                          ROSE_ASSERT(templateFunction_symbol != NULL);</a>
<a name="1532"><span class="lineNum">    1532 </span>            : </a>
<a name="1533"><span class="lineNum">    1533 </span>            :                          trial_declaration = templateFunction_symbol-&gt;get_declaration();</a>
<a name="1534"><span class="lineNum">    1534 </span>            :                          break;</a>
<a name="1535"><span class="lineNum">    1535 </span>            :                        }</a>
<a name="1536"><span class="lineNum">    1536 </span>            : </a>
<a name="1537"><span class="lineNum">    1537 </span>            :                     case V_SgTemplateVariableSymbol:</a>
<a name="1538"><span class="lineNum">    1538 </span>            :                        {</a>
<a name="1539"><span class="lineNum">    1539 </span>            :                          SgTemplateVariableSymbol* templateVariable_symbol = isSgTemplateVariableSymbol(trial_lookup_symbol);</a>
<a name="1540"><span class="lineNum">    1540 </span>            :                          ROSE_ASSERT(templateVariable_symbol != NULL);</a>
<a name="1541"><span class="lineNum">    1541 </span>            : </a>
<a name="1542"><span class="lineNum">    1542 </span>            :                          trial_initializedName = templateVariable_symbol-&gt;get_declaration();</a>
<a name="1543"><span class="lineNum">    1543 </span>            :                          trial_declaration = NULL;</a>
<a name="1544"><span class="lineNum">    1544 </span>            :                          break;</a>
<a name="1545"><span class="lineNum">    1545 </span>            :                        }</a>
<a name="1546"><span class="lineNum">    1546 </span>            : </a>
<a name="1547"><span class="lineNum">    1547 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="1548"><span class="lineNum">    1548 </span>            : </a>
<a name="1549"><span class="lineNum">    1549 </span>            :                     case V_SgNonrealSymbol:</a>
<a name="1550"><span class="lineNum">    1550 </span>            :                        {</a>
<a name="1551"><span class="lineNum">    1551 </span>            :                          SgNonrealSymbol* nonreal_symbol = isSgNonrealSymbol(trial_lookup_symbol);</a>
<a name="1552"><span class="lineNum">    1552 </span>            :                          ROSE_ASSERT(nonreal_symbol != NULL);</a>
<a name="1553"><span class="lineNum">    1553 </span>            : </a>
<a name="1554"><span class="lineNum">    1554 </span>            :                          trial_declaration = nonreal_symbol-&gt;get_declaration();</a>
<a name="1555"><span class="lineNum">    1555 </span>            :                          break;</a>
<a name="1556"><span class="lineNum">    1556 </span>            :                        }</a>
<a name="1557"><span class="lineNum">    1557 </span>            : </a>
<a name="1558"><span class="lineNum">    1558 </span>            :                     case V_SgTemplateTypedefSymbol:</a>
<a name="1559"><span class="lineNum">    1559 </span>            :                        {</a>
<a name="1560"><span class="lineNum">    1560 </span>            :                          SgTemplateTypedefSymbol* templateTypedef_symbol = isSgTemplateTypedefSymbol(trial_lookup_symbol);</a>
<a name="1561"><span class="lineNum">    1561 </span>            :                          ROSE_ASSERT(templateTypedef_symbol != NULL);</a>
<a name="1562"><span class="lineNum">    1562 </span>            : </a>
<a name="1563"><span class="lineNum">    1563 </span>            :                          trial_declaration = templateTypedef_symbol-&gt;get_declaration();</a>
<a name="1564"><span class="lineNum">    1564 </span>            :                          break;</a>
<a name="1565"><span class="lineNum">    1565 </span>            :                        }</a>
<a name="1566"><span class="lineNum">    1566 </span>            : </a>
<a name="1567"><span class="lineNum">    1567 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="1568"><span class="lineNum">    1568 </span>            : </a>
<a name="1569"><span class="lineNum">    1569 </span>            :                     case V_SgTemplateMemberFunctionSymbol:</a>
<a name="1570"><span class="lineNum">    1570 </span>            :                        {</a>
<a name="1571"><span class="lineNum">    1571 </span>            :                          SgTemplateMemberFunctionSymbol* templateMemberFunction_symbol = isSgTemplateMemberFunctionSymbol(trial_lookup_symbol);</a>
<a name="1572"><span class="lineNum">    1572 </span>            :                          ROSE_ASSERT(templateMemberFunction_symbol != NULL);</a>
<a name="1573"><span class="lineNum">    1573 </span>            : </a>
<a name="1574"><span class="lineNum">    1574 </span>            :                          trial_declaration = templateMemberFunction_symbol-&gt;get_declaration();</a>
<a name="1575"><span class="lineNum">    1575 </span>            :                          break;</a>
<a name="1576"><span class="lineNum">    1576 </span>            :                        }</a>
<a name="1577"><span class="lineNum">    1577 </span>            : </a>
<a name="1578"><span class="lineNum">    1578 </span>            :                     case V_SgMemberFunctionSymbol:</a>
<a name="1579"><span class="lineNum">    1579 </span>            :                        {</a>
<a name="1580"><span class="lineNum">    1580 </span>            :                          SgMemberFunctionSymbol* memberFunction_symbol = isSgMemberFunctionSymbol(trial_lookup_symbol);</a>
<a name="1581"><span class="lineNum">    1581 </span>            :                          ROSE_ASSERT(memberFunction_symbol != NULL);</a>
<a name="1582"><span class="lineNum">    1582 </span>            : </a>
<a name="1583"><span class="lineNum">    1583 </span>            :                          trial_declaration = memberFunction_symbol-&gt;get_declaration();</a>
<a name="1584"><span class="lineNum">    1584 </span>            :                          break;</a>
<a name="1585"><span class="lineNum">    1585 </span>            :                        }</a>
<a name="1586"><span class="lineNum">    1586 </span>            : </a>
<a name="1587"><span class="lineNum">    1587 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="1588"><span class="lineNum">    1588 </span>            : </a>
<a name="1589"><span class="lineNum">    1589 </span>            :                     default:</a>
<a name="1590"><span class="lineNum">    1590 </span>            :                        {</a>
<a name="1591"><span class="lineNum">    1591 </span>            :                          printf (&quot;Switch default reached: trial_lookup_symbol = %p = %s \n&quot;,trial_lookup_symbol,trial_lookup_symbol-&gt;class_name().c_str());</a>
<a name="1592"><span class="lineNum">    1592 </span>            :                          ROSE_ABORT();</a>
<a name="1593"><span class="lineNum">    1593 </span>            :                        }</a>
<a name="1594"><span class="lineNum">    1594 </span>            :                   }</a>
<a name="1595"><span class="lineNum">    1595 </span>            : #if 0</a>
<a name="1596"><span class="lineNum">    1596 </span>            :               printf (&quot;Not yet implemented! \n&quot;);</a>
<a name="1597"><span class="lineNum">    1597 </span>            :               ROSE_ABORT();</a>
<a name="1598"><span class="lineNum">    1598 </span>            : #endif</a>
<a name="1599"><span class="lineNum">    1599 </span>            : </a>
<a name="1600"><span class="lineNum">    1600 </span>            : #if DEBUG_NONALIAS_SYMBOL_SUPPORT</a>
<a name="1601"><span class="lineNum">    1601 </span>            :               printf (&quot;declaration       = %p = %s \n&quot;,declaration,declaration-&gt;class_name().c_str());</a>
<a name="1602"><span class="lineNum">    1602 </span>            : #endif</a>
<a name="1603"><span class="lineNum">    1603 </span>            :               if (trial_declaration != NULL)</a>
<a name="1604"><span class="lineNum">    1604 </span>            :                  {</a>
<a name="1605"><span class="lineNum">    1605 </span>            : #if DEBUG_NONALIAS_SYMBOL_SUPPORT</a>
<a name="1606"><span class="lineNum">    1606 </span>            :                    printf (&quot;trial_declaration = %p = %s \n&quot;,trial_declaration,trial_declaration-&gt;class_name().c_str());</a>
<a name="1607"><span class="lineNum">    1607 </span>            : #endif</a>
<a name="1608"><span class="lineNum">    1608 </span>            : </a>
<a name="1609"><span class="lineNum">    1609 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="1610"><span class="lineNum">    1610 </span>            : </a>
<a name="1611"><span class="lineNum">    1611 </span>            :                    if (trial_declaration-&gt;variantT() == declaration-&gt;variantT())</a>
<a name="1612"><span class="lineNum">    1612 </span>            :                       {</a>
<a name="1613"><span class="lineNum">    1613 </span>            :                      // We can return zero, since the symbol is visible.</a>
<a name="1614"><span class="lineNum">    1614 </span>            :                      // return return_value;</a>
<a name="1615"><span class="lineNum">    1615 </span>            :                      // return 0;</a>
<a name="1616"><span class="lineNum">    1616 </span>            :                         if (trial_declaration == declaration)</a>
<a name="1617"><span class="lineNum">    1617 </span>            :                            {</a>
<a name="1618"><span class="lineNum">    1618 </span>            : #if DEBUG_NONALIAS_SYMBOL_SUPPORT</a>
<a name="1619"><span class="lineNum">    1619 </span>            :                              printf (&quot;Addressing possible namespace aliasing: trial_declaration == declaration: returning zero \n&quot;);</a>
<a name="1620"><span class="lineNum">    1620 </span>            : #endif</a>
<a name="1621"><span class="lineNum">    1621 </span>            :                           // DQ (8/8/2020): Uncomment so that we can test Cxx_tests/test2020_20.C.</a>
<a name="1622"><span class="lineNum">    1622 </span>            :                           // return 0;</a>
<a name="1623"><span class="lineNum">    1623 </span>            : </a>
<a name="1624"><span class="lineNum">    1624 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="1625"><span class="lineNum">    1625 </span>            : </a>
<a name="1626"><span class="lineNum">    1626 </span>            :                           // DQ (8/6/2020): Need to addess examples such as Cxx_tests/test2017_40.C.</a>
<a name="1627"><span class="lineNum">    1627 </span>            :                              SgTemplateInstantiationFunctionDecl* templateInstantiationFunctionDecl = isSgTemplateInstantiationFunctionDecl(trial_declaration);</a>
<a name="1628"><span class="lineNum">    1628 </span>            :                              if (templateInstantiationFunctionDecl != NULL)</a>
<a name="1629"><span class="lineNum">    1629 </span>            :                                 {</a>
<a name="1630"><span class="lineNum">    1630 </span>            :                                // Keep going with the rest of the function.</a>
<a name="1631"><span class="lineNum">    1631 </span>            :                                 }</a>
<a name="1632"><span class="lineNum">    1632 </span>            :                                else</a>
<a name="1633"><span class="lineNum">    1633 </span>            :                                 {</a>
<a name="1634"><span class="lineNum">    1634 </span>            :                                // For other cases we can return 0.</a>
<a name="1635"><span class="lineNum">    1635 </span>            :                                   SgScopeStatement* local_scope = declaration-&gt;get_scope();</a>
<a name="1636"><span class="lineNum">    1636 </span>            :                                   ROSE_ASSERT(local_scope != NULL);</a>
<a name="1637"><span class="lineNum">    1637 </span>            :                                   size_t numberOfSymbols      = local_scope-&gt;count_symbol(name);</a>
<a name="1638"><span class="lineNum">    1638 </span>            :                                   size_t numberOfAliasSymbols = local_scope-&gt;count_alias_symbol(name);</a>
<a name="1639"><span class="lineNum">    1639 </span>            : #if DEBUG_NONALIAS_SYMBOL_SUPPORT</a>
<a name="1640"><span class="lineNum">    1640 </span>            :                                   printf (&quot;Addressing possible namespace aliasing: trial_declaration != NULL: templateInstantiationFunctionDecl != NULL: local_scope = %p = %s \n&quot;,local_scope,local_scope-&gt;class_name().c_str());</a>
<a name="1641"><span class="lineNum">    1641 </span>            :                                   printf (&quot;Addressing possible namespace aliasing: trial_declaration != NULL: templateInstantiationFunctionDecl != NULL: numberOfSymbols      = %zu \n&quot;,numberOfSymbols);</a>
<a name="1642"><span class="lineNum">    1642 </span>            :                                   printf (&quot;Addressing possible namespace aliasing: trial_declaration != NULL: templateInstantiationFunctionDecl != NULL: numberOfAliasSymbols = %zu \n&quot;,numberOfAliasSymbols);</a>
<a name="1643"><span class="lineNum">    1643 </span>            : #endif</a>
<a name="1644"><span class="lineNum">    1644 </span>            : #if DEBUG_NONALIAS_SYMBOL_SUPPORT</a>
<a name="1645"><span class="lineNum">    1645 </span>            :                                   printf (&quot;Addressing possible namespace aliasing: trial_declaration != NULL: templateInstantiationFunctionDecl != NULL: returning zero \n&quot;);</a>
<a name="1646"><span class="lineNum">    1646 </span>            : #endif</a>
<a name="1647"><span class="lineNum">    1647 </span>            :                                // DQ (8/8/2020): Comment this out as a test to make Cxx11_tests/test2020_08.C work.</a>
<a name="1648"><span class="lineNum">    1648 </span>            :                                   return 0;</a>
<a name="1649"><span class="lineNum">    1649 </span>            :                                 }</a>
<a name="1650"><span class="lineNum">    1650 </span>            :                            }</a>
<a name="1651"><span class="lineNum">    1651 </span>            :                           else</a>
<a name="1652"><span class="lineNum">    1652 </span>            :                            {</a>
<a name="1653"><span class="lineNum">    1653 </span>            :                           // Keep going with the rest of the function.</a>
<a name="1654"><span class="lineNum">    1654 </span>            :                            }</a>
<a name="1655"><span class="lineNum">    1655 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="1656"><span class="lineNum">    1656 </span>            : </a>
<a name="1657"><span class="lineNum">    1657 </span>            :                       }</a>
<a name="1658"><span class="lineNum">    1658 </span>            :                      else</a>
<a name="1659"><span class="lineNum">    1659 </span>            :                       {</a>
<a name="1660"><span class="lineNum">    1660 </span>            :                      // Keep going with the rest of the function.</a>
<a name="1661"><span class="lineNum">    1661 </span>            :                       }</a>
<a name="1662"><span class="lineNum">    1662 </span>            :                  }</a>
<a name="1663"><span class="lineNum">    1663 </span>            :                 else</a>
<a name="1664"><span class="lineNum">    1664 </span>            :                  {</a>
<a name="1665"><span class="lineNum">    1665 </span>            :                    if (trial_initializedName != NULL)</a>
<a name="1666"><span class="lineNum">    1666 </span>            :                       {</a>
<a name="1667"><span class="lineNum">    1667 </span>            :                      // The solution here is to find the variable declaration associated with the trial_initializedName.</a>
<a name="1668"><span class="lineNum">    1668 </span>            : #if 1</a>
<a name="1669"><span class="lineNum">    1669 </span>            : </a>
<a name="1670"><span class="lineNum">    1670 </span>            : #if DEBUG_NONALIAS_SYMBOL_SUPPORT</a>
<a name="1671"><span class="lineNum">    1671 </span>            :                         printf (&quot;Addressing possible namespace aliasing: trial_initializedName = %p name = %s: declaration = %p = %s \n&quot;,</a>
<a name="1672"><span class="lineNum">    1672 </span>            :                              trial_initializedName,trial_initializedName-&gt;get_name().str(),declaration,declaration-&gt;class_name().c_str());</a>
<a name="1673"><span class="lineNum">    1673 </span>            : #endif</a>
<a name="1674"><span class="lineNum">    1674 </span>            :                         bool includingSelf = false;</a>
<a name="1675"><span class="lineNum">    1675 </span>            :                         SgVariableDeclaration* enclosing_variableDeclaration = SageInterface::getEnclosingNode&lt;SgVariableDeclaration&gt;(trial_initializedName,includingSelf);</a>
<a name="1676"><span class="lineNum">    1676 </span>            : </a>
<a name="1677"><span class="lineNum">    1677 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="1678"><span class="lineNum">    1678 </span>            : </a>
<a name="1679"><span class="lineNum">    1679 </span>            : #if DEBUG_NONALIAS_SYMBOL_SUPPORT</a>
<a name="1680"><span class="lineNum">    1680 </span>            :                         printf (&quot;Addressing possible namespace aliasing: trial_initializedName != NULL: enclosing_variableDeclaration = %p \n&quot;,enclosing_variableDeclaration);</a>
<a name="1681"><span class="lineNum">    1681 </span>            : #endif</a>
<a name="1682"><span class="lineNum">    1682 </span>            :                         if (enclosing_variableDeclaration != NULL)</a>
<a name="1683"><span class="lineNum">    1683 </span>            :                            {</a>
<a name="1684"><span class="lineNum">    1684 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="1685"><span class="lineNum">    1685 </span>            : </a>
<a name="1686"><span class="lineNum">    1686 </span>            :                              if (enclosing_variableDeclaration == declaration)</a>
<a name="1687"><span class="lineNum">    1687 </span>            :                                 {</a>
<a name="1688"><span class="lineNum">    1688 </span>            : #if DEBUG_NONALIAS_SYMBOL_SUPPORT</a>
<a name="1689"><span class="lineNum">    1689 </span>            :                                   printf (&quot;Addressing possible namespace aliasing: trial_initializedName != NULL: enclosing_variableDeclaration == declaration: returning zero \n&quot;);</a>
<a name="1690"><span class="lineNum">    1690 </span>            : #endif</a>
<a name="1691"><span class="lineNum">    1691 </span>            : #if 0</a>
<a name="1692"><span class="lineNum">    1692 </span>            : #if DEBUG_NONALIAS_SYMBOL_SUPPORT</a>
<a name="1693"><span class="lineNum">    1693 </span>            :                                   printf (&quot;Calling nameQualificationTypeSupport(): trial_initializedName = %p name = %s \n&quot;,trial_initializedName,trial_initializedName-&gt;get_name().str());</a>
<a name="1694"><span class="lineNum">    1694 </span>            : #endif</a>
<a name="1695"><span class="lineNum">    1695 </span>            :                                // Refactored this code.</a>
<a name="1696"><span class="lineNum">    1696 </span>            :                                // nameQualificationTypeSupport (type,currentScope,initializedName);</a>
<a name="1697"><span class="lineNum">    1697 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="1698"><span class="lineNum">    1698 </span>            : </a>
<a name="1699"><span class="lineNum">    1699 </span>            :                                   ROSE_ASSERT(trial_initializedName != NULL);</a>
<a name="1700"><span class="lineNum">    1700 </span>            :                                   nameQualificationTypeSupport (trial_initializedName-&gt;get_type(),currentScope,trial_initializedName);</a>
<a name="1701"><span class="lineNum">    1701 </span>            : #endif</a>
<a name="1702"><span class="lineNum">    1702 </span>            :                                // DQ (8/8/2020): Trying to debug Cxx_tests/test2020_20.C</a>
<a name="1703"><span class="lineNum">    1703 </span>            :                                   return 0;</a>
<a name="1704"><span class="lineNum">    1704 </span>            :                                 }</a>
<a name="1705"><span class="lineNum">    1705 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="1706"><span class="lineNum">    1706 </span>            : </a>
<a name="1707"><span class="lineNum">    1707 </span>            :                                else</a>
<a name="1708"><span class="lineNum">    1708 </span>            :                                 {</a>
<a name="1709"><span class="lineNum">    1709 </span>            :                                // Might need to check if there is another one, but if there is (see Cxx_tests/test2007_09.C) then we still need to keep going.</a>
<a name="1710"><span class="lineNum">    1710 </span>            :                                // Keep going with the rest of the function.</a>
<a name="1711"><span class="lineNum">    1711 </span>            : </a>
<a name="1712"><span class="lineNum">    1712 </span>            : #if DEBUG_NONALIAS_SYMBOL_SUPPORT</a>
<a name="1713"><span class="lineNum">    1713 </span>            :                                   printf (&quot;Addressing possible namespace aliasing: trial_initializedName != NULL: enclosing_variableDeclaration != declaration: returning zero \n&quot;);</a>
<a name="1714"><span class="lineNum">    1714 </span>            : #endif</a>
<a name="1715"><span class="lineNum">    1715 </span>            :                                // DQ (8/8/2020): return 0 to debug Cxx_tests/test2020_20.C</a>
<a name="1716"><span class="lineNum">    1716 </span>            :                                // return 0;</a>
<a name="1717"><span class="lineNum">    1717 </span>            :                                 }</a>
<a name="1718"><span class="lineNum">    1718 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="1719"><span class="lineNum">    1719 </span>            : </a>
<a name="1720"><span class="lineNum">    1720 </span>            :                            }</a>
<a name="1721"><span class="lineNum">    1721 </span>            :                           else</a>
<a name="1722"><span class="lineNum">    1722 </span>            :                            {</a>
<a name="1723"><span class="lineNum">    1723 </span>            : #if 0</a>
<a name="1724"><span class="lineNum">    1724 </span>            :                              printf (&quot;enclosing_variableDeclaration == NULL \n&quot;);</a>
<a name="1725"><span class="lineNum">    1725 </span>            :                              ROSE_ABORT();</a>
<a name="1726"><span class="lineNum">    1726 </span>            : #else</a>
<a name="1727"><span class="lineNum">    1727 </span>            :                              printf (&quot; --- not associated with a SgVariableDeclaration: so keep going \n&quot;);</a>
<a name="1728"><span class="lineNum">    1728 </span>            :                              SgNonrealDecl* nonrealDecl = isSgNonrealDecl(declaration);</a>
<a name="1729"><span class="lineNum">    1729 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="1730"><span class="lineNum">    1730 </span>            : </a>
<a name="1731"><span class="lineNum">    1731 </span>            :                              if (nonrealDecl != NULL)</a>
<a name="1732"><span class="lineNum">    1732 </span>            :                                 {</a>
<a name="1733"><span class="lineNum">    1733 </span>            :                                // Keep going with the rest of the function.</a>
<a name="1734"><span class="lineNum">    1734 </span>            :                                 }</a>
<a name="1735"><span class="lineNum">    1735 </span>            :                                else</a>
<a name="1736"><span class="lineNum">    1736 </span>            :                                 {</a>
<a name="1737"><span class="lineNum">    1737 </span>            : #if DEBUG_NONALIAS_SYMBOL_SUPPORT</a>
<a name="1738"><span class="lineNum">    1738 </span>            :                                   printf (&quot;enclosing_variableDeclaration == NULL &amp;&amp; nonrealDecl != NULL: but keep going \n&quot;);</a>
<a name="1739"><span class="lineNum">    1739 </span>            : #endif</a>
<a name="1740"><span class="lineNum">    1740 </span>            : #if 0</a>
<a name="1741"><span class="lineNum">    1741 </span>            :                                   printf (&quot;enclosing_variableDeclaration == NULL &amp;&amp; nonrealDecl != NULL \n&quot;);</a>
<a name="1742"><span class="lineNum">    1742 </span>            :                                   ROSE_ABORT();</a>
<a name="1743"><span class="lineNum">    1743 </span>            : #endif</a>
<a name="1744"><span class="lineNum">    1744 </span>            :                                 }</a>
<a name="1745"><span class="lineNum">    1745 </span>            : #endif</a>
<a name="1746"><span class="lineNum">    1746 </span>            :                            }</a>
<a name="1747"><span class="lineNum">    1747 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="1748"><span class="lineNum">    1748 </span>            : </a>
<a name="1749"><span class="lineNum">    1749 </span>            : #endif</a>
<a name="1750"><span class="lineNum">    1750 </span>            : </a>
<a name="1751"><span class="lineNum">    1751 </span>            : #if 0</a>
<a name="1752"><span class="lineNum">    1752 </span>            : </a>
<a name="1753"><span class="lineNum">    1753 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="1754"><span class="lineNum">    1754 </span>            : </a>
<a name="1755"><span class="lineNum">    1755 </span>            : #if 1</a>
<a name="1756"><span class="lineNum">    1756 </span>            : #if 1</a>
<a name="1757"><span class="lineNum">    1757 </span>            :                         printf (&quot;Addressing possible namespace aliasing: trial_initializedName != NULL: returning zero \n&quot;);</a>
<a name="1758"><span class="lineNum">    1758 </span>            : #endif</a>
<a name="1759"><span class="lineNum">    1759 </span>            :                         return 0;</a>
<a name="1760"><span class="lineNum">    1760 </span>            : #else</a>
<a name="1761"><span class="lineNum">    1761 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="1762"><span class="lineNum">    1762 </span>            :                      // The declaration is the not a SgInitializedName, so need to think about this case.</a>
<a name="1763"><span class="lineNum">    1763 </span>            :                         if (trial_initializedName == declaration)</a>
<a name="1764"><span class="lineNum">    1764 </span>            :                            {</a>
<a name="1765"><span class="lineNum">    1765 </span>            :                              return 0;</a>
<a name="1766"><span class="lineNum">    1766 </span>            :                            }</a>
<a name="1767"><span class="lineNum">    1767 </span>            :                           else</a>
<a name="1768"><span class="lineNum">    1768 </span>            :                            {</a>
<a name="1769"><span class="lineNum">    1769 </span>            :                           // Keep going with the rest of the function.</a>
<a name="1770"><span class="lineNum">    1770 </span>            :                            }</a>
<a name="1771"><span class="lineNum">    1771 </span>            : #endif</a>
<a name="1772"><span class="lineNum">    1772 </span>            : </a>
<a name="1773"><span class="lineNum">    1773 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="1774"><span class="lineNum">    1774 </span>            : </a>
<a name="1775"><span class="lineNum">    1775 </span>            : #endif</a>
<a name="1776"><span class="lineNum">    1776 </span>            :                       }</a>
<a name="1777"><span class="lineNum">    1777 </span>            :                      else</a>
<a name="1778"><span class="lineNum">    1778 </span>            :                       {</a>
<a name="1779"><span class="lineNum">    1779 </span>            :                      // Keep going with the rest of the function.</a>
<a name="1780"><span class="lineNum">    1780 </span>            :                       }</a>
<a name="1781"><span class="lineNum">    1781 </span>            :                  }</a>
<a name="1782"><span class="lineNum">    1782 </span>            : </a>
<a name="1783"><span class="lineNum">    1783 </span>            :            // We can return zero, since the symbol is visible.</a>
<a name="1784"><span class="lineNum">    1784 </span>            :            // return return_value;</a>
<a name="1785"><span class="lineNum">    1785 </span>            :             }</a>
<a name="1786"><span class="lineNum">    1786 </span>            : #endif</a>
<a name="1787"><span class="lineNum">    1787 </span>            : </a>
<a name="1788"><span class="lineNum">    1788 </span>            :        // DQ (8/16/2013): Added support for more precise symbol lookup (which requires the template parameters and template arguments).</a>
<a name="1789"><span class="lineNum">    1789 </span>            :        // DQ 8/21/2012): this is looking in the parent scopes of the currentScope and thus not including the currentScope.</a>
<a name="1790"><span class="lineNum">    1790 </span>            :        // This is a bug for test2011_31.C where there is a variable who's name hides the name in the parent scopes (and it not detected).</a>
<a name="1791"><span class="lineNum">    1791 </span>            :        // SgSymbol* symbol = SageInterface::lookupSymbolInParentScopes(name,currentScope);</a>
<a name="1792"><span class="lineNum">    1792 </span><span class="lineCov">    1714820 :           SgSymbol* symbol = SageInterface::lookupSymbolInParentScopes(name,currentScope,templateParameterList,templateArgumentList);</span></a>
<a name="1793"><span class="lineNum">    1793 </span>            : </a>
<a name="1794"><span class="lineNum">    1794 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || DEBUG_FUNCTION_RESOLUTION</a>
<a name="1795"><span class="lineNum">    1795 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Initial lookup: symbol = %p = %s \n&quot;,symbol,(symbol != NULL) ? symbol-&gt;class_name().c_str() : &quot;NULL&quot;);</a>
<a name="1796"><span class="lineNum">    1796 </span>            : #endif</a>
<a name="1797"><span class="lineNum">    1797 </span>            : </a>
<a name="1798"><span class="lineNum">    1798 </span>            :        // This is used to count the number of symbols of the same type in a single scope.</a>
<a name="1799"><span class="lineNum">    1799 </span>            :        // size_t numberOfSymbols = 0;</a>
<a name="1800"><span class="lineNum">    1800 </span>            :        // bool forceMoreNameQualification = false;</a>
<a name="1801"><span class="lineNum">    1801 </span>            : </a>
<a name="1802"><span class="lineNum">    1802 </span>            :        // DQ (4/12/2014): we need to record that there was another function identified in the parent scopes that we will want to have force name qualification.</a>
<a name="1803"><span class="lineNum">    1803 </span><span class="lineCov">    1714820 :           bool foundAnOverloadedFunctionWithSameName = false;</span></a>
<a name="1804"><span class="lineNum">    1804 </span><span class="lineCov">    1714820 :           bool foundAnOverloadedFunctionInSameScope  = false;</span></a>
<a name="1805"><span class="lineNum">    1805 </span>            : </a>
<a name="1806"><span class="lineNum">    1806 </span>            :        // DQ (2/14/2019): Save a copy of the symbol looked up by name so that we can resolve if a</a>
<a name="1807"><span class="lineNum">    1807 </span>            :        // variable hides a type (which is where name qualification is not appropriate).</a>
<a name="1808"><span class="lineNum">    1808 </span><span class="lineCov">    1714820 :           SgSymbol* original_symbol_lookedup_by_name = symbol;</span></a>
<a name="1809"><span class="lineNum">    1809 </span>            : </a>
<a name="1810"><span class="lineNum">    1810 </span><span class="lineCov">    1714820 :           if (symbol != NULL)</span></a>
<a name="1811"><span class="lineNum">    1811 </span>            :              {</a>
<a name="1812"><span class="lineNum">    1812 </span>            :             // mfprintf(mlog [ WARN ] ) (&quot;Lookup symbol based on name only: symbol = %p = %s \n&quot;,symbol,symbol-&gt;class_name().c_str());</a>
<a name="1813"><span class="lineNum">    1813 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || DEBUG_FUNCTION_RESOLUTION</a>
<a name="1814"><span class="lineNum">    1814 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Lookup symbol based on name only (via parents starting at currentScope = %p = %s: name = %s symbol = %p = %s) \n&quot;,</a>
<a name="1815"><span class="lineNum">    1815 </span>            :                     currentScope,currentScope-&gt;class_name().c_str(),name.str(),symbol,symbol-&gt;class_name().c_str());</a>
<a name="1816"><span class="lineNum">    1816 </span>            :                if (isSgFunctionSymbol(symbol) != NULL)</a>
<a name="1817"><span class="lineNum">    1817 </span>            :                   {</a>
<a name="1818"><span class="lineNum">    1818 </span>            :                     SgFunctionSymbol* functionSymbol = isSgFunctionSymbol(symbol);</a>
<a name="1819"><span class="lineNum">    1819 </span>            :                     SgFunctionDeclaration* functionDeclaration = functionSymbol-&gt;get_declaration();</a>
<a name="1820"><span class="lineNum">    1820 </span>            :                     ASSERT_not_null(functionDeclaration);</a>
<a name="1821"><span class="lineNum">    1821 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;functionSymbol = %p functionDeclaration = %p = %s name = %s \n&quot;,functionSymbol,</a>
<a name="1822"><span class="lineNum">    1822 </span>            :                          functionDeclaration,functionDeclaration-&gt;class_name().c_str(),functionDeclaration-&gt;get_name().str());</a>
<a name="1823"><span class="lineNum">    1823 </span>            :                   }</a>
<a name="1824"><span class="lineNum">    1824 </span>            : #endif</a>
<a name="1825"><span class="lineNum">    1825 </span><span class="lineCov">    1590620 :                SgAliasSymbol* aliasSymbol = isSgAliasSymbol(symbol);</span></a>
<a name="1826"><span class="lineNum">    1826 </span>            : </a>
<a name="1827"><span class="lineNum">    1827 </span>            :             // DQ (7/12/2014): The newer design of the symbol table handling means that we will never see a SgAliasSymbol at this level.</a>
<a name="1828"><span class="lineNum">    1828 </span><span class="lineCov">    1590620 :                ROSE_ASSERT(aliasSymbol == NULL);</span></a>
<a name="1829"><span class="lineNum">    1829 </span>            : </a>
<a name="1830"><span class="lineNum">    1830 </span><span class="lineCov">    1590620 :                if (aliasSymbol != NULL)</span></a>
<a name="1831"><span class="lineNum">    1831 </span>            :                   {</a>
<a name="1832"><span class="lineNum">    1832 </span>            :                     symbol = aliasSymbol-&gt;get_alias();</a>
<a name="1833"><span class="lineNum">    1833 </span>            :                     ASSERT_not_null(symbol);</a>
<a name="1834"><span class="lineNum">    1834 </span>            : </a>
<a name="1835"><span class="lineNum">    1835 </span>            :                  // DQ (7/12/2014): The newer design of the symbol table handling means that we will never see a SgAliasSymbol at this level.</a>
<a name="1836"><span class="lineNum">    1836 </span>            :                     ROSE_ABORT();</a>
<a name="1837"><span class="lineNum">    1837 </span>            : #if 1</a>
<a name="1838"><span class="lineNum">    1838 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::nameQualificationDepth(): Detected a SgAliasSymbol: alias = %p baseSymbol = %p = %s \n&quot;,aliasSymbol,symbol,symbol-&gt;class_name().c_str());</a>
<a name="1839"><span class="lineNum">    1839 </span>            : #endif</a>
<a name="1840"><span class="lineNum">    1840 </span>            : #if 1</a>
<a name="1841"><span class="lineNum">    1841 </span>            :                  // DQ (8/21/2012): Commented out the assertion, but warn about how nesting appears to be present.</a>
<a name="1842"><span class="lineNum">    1842 </span>            :                  // DQ (8/20/2012): The symbol in side the SgAliasSymbol should not be another alias. This fails for test2004_48.C).</a>
<a name="1843"><span class="lineNum">    1843 </span>            :                     if (isSgAliasSymbol(symbol) != NULL)</a>
<a name="1844"><span class="lineNum">    1844 </span>            :                        {</a>
<a name="1845"><span class="lineNum">    1845 </span>            :                       // DQ (8/24/2012): Allow this to be output a little less often.</a>
<a name="1846"><span class="lineNum">    1846 </span>            :                          static int counter = 0;</a>
<a name="1847"><span class="lineNum">    1847 </span>            :                          if (counter++ % 100 == 0)</a>
<a name="1848"><span class="lineNum">    1848 </span>            :                             {</a>
<a name="1849"><span class="lineNum">    1849 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;WARNING: can't assert isSgAliasSymbol(symbol) == NULL after processing SgAliasSymbol (might require loop to strip away nested SgAliasSymbol symbols. \n&quot;);</a>
<a name="1850"><span class="lineNum">    1850 </span>            :                             }</a>
<a name="1851"><span class="lineNum">    1851 </span>            :                        }</a>
<a name="1852"><span class="lineNum">    1852 </span>            :                  // ROSE_ASSERT(isSgAliasSymbol(symbol) == NULL);</a>
<a name="1853"><span class="lineNum">    1853 </span>            : #endif</a>
<a name="1854"><span class="lineNum">    1854 </span>            :                   }</a>
<a name="1855"><span class="lineNum">    1855 </span>            : </a>
<a name="1856"><span class="lineNum">    1856 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || DEBUG_FUNCTION_RESOLUTION</a>
<a name="1857"><span class="lineNum">    1857 </span>            :             // We have to check the kind of declaration against the kind of symbol found. A local variable (for example)</a>
<a name="1858"><span class="lineNum">    1858 </span>            :             // could hide the same name used for the declaration.  This if we find symbol inconsistant with the declaration</a>
<a name="1859"><span class="lineNum">    1859 </span>            :             // then we need some form of qualification (sometimes just type elaboration).</a>
<a name="1860"><span class="lineNum">    1860 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;### Targeting a declaration = %p = %s \n&quot;,declaration,declaration-&gt;class_name().c_str());</a>
<a name="1861"><span class="lineNum">    1861 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;   --- declaration-&gt;get_firstNondefiningDeclaration() = %p \n&quot;,declaration-&gt;get_firstNondefiningDeclaration());</a>
<a name="1862"><span class="lineNum">    1862 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;   --- declaration-&gt;get_definingDeclaration()         = %p \n&quot;,declaration-&gt;get_definingDeclaration());</a>
<a name="1863"><span class="lineNum">    1863 </span>            : #endif</a>
<a name="1864"><span class="lineNum">    1864 </span><span class="lineCov">    1590620 :                switch (declaration-&gt;variantT())</span></a>
<a name="1865"><span class="lineNum">    1865 </span>            :                   {</a>
<a name="1866"><span class="lineNum">    1866 </span>            :                  // DQ (12/26/2011): Added support for template class declarations (part of new design for template declarations).</a>
<a name="1867"><span class="lineNum">    1867 </span><span class="lineCov">      43600 :                     case V_SgTemplateClassDeclaration:</span></a>
<a name="1868"><span class="lineNum">    1868 </span><span class="lineCov">      43600 :                     case V_SgClassDeclaration:</span></a>
<a name="1869"><span class="lineNum">    1869 </span><span class="lineCov">      43600 :                        {</span></a>
<a name="1870"><span class="lineNum">    1870 </span><span class="lineCov">      43600 :                          SgClassDeclaration* classDeclaration = isSgClassDeclaration(declaration);</span></a>
<a name="1871"><span class="lineNum">    1871 </span><span class="lineCov">      43600 :                          ASSERT_not_null(classDeclaration);</span></a>
<a name="1872"><span class="lineNum">    1872 </span>            : </a>
<a name="1873"><span class="lineNum">    1873 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="1874"><span class="lineNum">    1874 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;classDeclaration name = %s \n&quot;,classDeclaration-&gt;get_name().str());</a>
<a name="1875"><span class="lineNum">    1875 </span>            : #endif</a>
<a name="1876"><span class="lineNum">    1876 </span><span class="lineCov">      43600 :                          SgClassSymbol* classSymbol = isSgClassSymbol(symbol);</span></a>
<a name="1877"><span class="lineNum">    1877 </span>            :                       // ASSERT_not_null(classSymbol);</a>
<a name="1878"><span class="lineNum">    1878 </span><span class="lineCov">      43600 :                          if (classSymbol == NULL)</span></a>
<a name="1879"><span class="lineNum">    1879 </span>            :                             {</a>
<a name="1880"><span class="lineNum">    1880 </span>            :                            // This is only type elaboration if it is a variable that is the conflict, if it is a typedef then more qualification is required. (see test2011_37.C).</a>
<a name="1881"><span class="lineNum">    1881 </span>            :                            // mfprintf(mlog [ WARN ] ) (&quot;Type elaboration is required: declaration = %s symbol = %s \n&quot;,declaration-&gt;class_name().c_str(),symbol-&gt;class_name().c_str());</a>
<a name="1882"><span class="lineNum">    1882 </span>            :                            // typeElaborationIsRequired = true;</a>
<a name="1883"><span class="lineNum">    1883 </span><span class="lineCov">       7586 :                               if (requiresTypeElaboration(symbol) == true)</span></a>
<a name="1884"><span class="lineNum">    1884 </span>            :                                  {</a>
<a name="1885"><span class="lineNum">    1885 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="1886"><span class="lineNum">    1886 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;Type elaboration is required: declaration = %s symbol = %s \n&quot;,declaration-&gt;class_name().c_str(),symbol-&gt;class_name().c_str());</a>
<a name="1887"><span class="lineNum">    1887 </span>            : #endif</a>
<a name="1888"><span class="lineNum">    1888 </span>            :                                    typeElaborationIsRequired = true;</a>
<a name="1889"><span class="lineNum">    1889 </span>            : </a>
<a name="1890"><span class="lineNum">    1890 </span>            :                                 // DQ (2/13/2019): Adding more name qualification (debugging test2011_33.C).</a>
<a name="1891"><span class="lineNum">    1891 </span>            :                                 // forceMoreNameQualification = true;</a>
<a name="1892"><span class="lineNum">    1892 </span>            :                                  }</a>
<a name="1893"><span class="lineNum">    1893 </span>            :                                 else</a>
<a name="1894"><span class="lineNum">    1894 </span>            :                                  {</a>
<a name="1895"><span class="lineNum">    1895 </span>            :                                 // I think we have to force an extra level of name qualification.</a>
<a name="1896"><span class="lineNum">    1896 </span>            : #if 1</a>
<a name="1897"><span class="lineNum">    1897 </span>            :                                 // DQ (2/13/2019): I think we need to check if a qualified nondefining declaration</a>
<a name="1898"><span class="lineNum">    1898 </span>            :                                 // has been made for this class, else no qualification should be output.</a>
<a name="1899"><span class="lineNum">    1899 </span><span class="lineCov">        126 :                                    SgDeclarationStatement* declarationToSearchForInReferencedNameSet =</span></a>
<a name="1900"><span class="lineNum">    1900 </span><span class="lineCov">        126 :                                         declaration-&gt;get_firstNondefiningDeclaration() != NULL ? declaration-&gt;get_firstNondefiningDeclaration() : declaration;</span></a>
<a name="1901"><span class="lineNum">    1901 </span><span class="lineCov">        126 :                                    ASSERT_not_null(declarationToSearchForInReferencedNameSet);</span></a>
<a name="1902"><span class="lineNum">    1902 </span><span class="lineCov">        126 :                                    bool skipNameQualification = false;</span></a>
<a name="1903"><span class="lineNum">    1903 </span><span class="lineCov">        252 :                                    if (referencedNameSet.find(declarationToSearchForInReferencedNameSet) == referencedNameSet.end())</span></a>
<a name="1904"><span class="lineNum">    1904 </span>            :                                       {</a>
<a name="1905"><span class="lineNum">    1905 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="1906"><span class="lineNum">    1906 </span>            :                                         mfprintf(mlog [ WARN ] ) (&quot;   --- $$$$$$$$$$ NOT Found: declaration %p = %s in referencedNameSet referencedNameSet.size() = %&quot; PRIuPTR &quot; \n&quot;,</a>
<a name="1907"><span class="lineNum">    1907 </span>            :                                              declaration,declaration-&gt;class_name().c_str(),referencedNameSet.size());</a>
<a name="1908"><span class="lineNum">    1908 </span>            : #endif</a>
<a name="1909"><span class="lineNum">    1909 </span><span class="lineNoCov">          0 :                                         skipNameQualification = true;</span></a>
<a name="1910"><span class="lineNum">    1910 </span>            :                                       }</a>
<a name="1911"><span class="lineNum">    1911 </span>            :                                      else</a>
<a name="1912"><span class="lineNum">    1912 </span>            :                                       {</a>
<a name="1913"><span class="lineNum">    1913 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="1914"><span class="lineNum">    1914 </span>            :                                         mfprintf(mlog [ WARN ] ) (&quot;   --- $$$$$$$$$$ FOUND: declaration %p = %s in referencedNameSet \n&quot;,declaration,declaration-&gt;class_name().c_str());</a>
<a name="1915"><span class="lineNum">    1915 </span>            : #endif</a>
<a name="1916"><span class="lineNum">    1916 </span>            :                                       }</a>
<a name="1917"><span class="lineNum">    1917 </span>            : </a>
<a name="1918"><span class="lineNum">    1918 </span>            :                                 // Check if a nondefining declaration has been seen already, if so then this may be a non-defining</a>
<a name="1919"><span class="lineNum">    1919 </span>            :                                 // or defining declaration in another scope and they name qualification would be required.</a>
<a name="1920"><span class="lineNum">    1920 </span>            :                                 // forceMoreNameQualification = true;</a>
<a name="1921"><span class="lineNum">    1921 </span><span class="lineNoCov">          0 :                                    if (skipNameQualification == false)</span></a>
<a name="1922"><span class="lineNum">    1922 </span>            :                                       {</a>
<a name="1923"><span class="lineNum">    1923 </span>            :                                         forceMoreNameQualification = true;</a>
<a name="1924"><span class="lineNum">    1924 </span>            :                                       }</a>
<a name="1925"><span class="lineNum">    1925 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="1926"><span class="lineNum">    1926 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;Forcing an extra level of name qualification forceMoreNameQualification = %s \n&quot;,forceMoreNameQualification ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="1927"><span class="lineNum">    1927 </span>            : #endif</a>
<a name="1928"><span class="lineNum">    1928 </span>            : #else</a>
<a name="1929"><span class="lineNum">    1929 </span>            :                                 // DQ (2/13/2019): Disabled forcing more name qualification.</a>
<a name="1930"><span class="lineNum">    1930 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;Disabled forcing more name qualification \n&quot;);</a>
<a name="1931"><span class="lineNum">    1931 </span>            : #endif</a>
<a name="1932"><span class="lineNum">    1932 </span>            : #if 0</a>
<a name="1933"><span class="lineNum">    1933 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;I think we have to force an extra level of name qualification (not implemented) \n&quot;);</a>
<a name="1934"><span class="lineNum">    1934 </span>            :                                    ROSE_ABORT();</a>
<a name="1935"><span class="lineNum">    1935 </span>            : #endif</a>
<a name="1936"><span class="lineNum">    1936 </span>            :                                  }</a>
<a name="1937"><span class="lineNum">    1937 </span>            : </a>
<a name="1938"><span class="lineNum">    1938 </span>            :                            // DQ (8/16/2013): Modified API for symbol lookup.</a>
<a name="1939"><span class="lineNum">    1939 </span>            :                            // Reset the symbol to one that will match the declaration.</a>
<a name="1940"><span class="lineNum">    1940 </span>            :                            // symbol = SageInterface::lookupClassSymbolInParentScopes(name,currentScope);</a>
<a name="1941"><span class="lineNum">    1941 </span><span class="lineCov">       7586 :                               symbol = SageInterface::lookupClassSymbolInParentScopes(name,currentScope,NULL);</span></a>
<a name="1942"><span class="lineNum">    1942 </span>            :                            // ASSERT_not_null(symbol);</a>
<a name="1943"><span class="lineNum">    1943 </span>            : </a>
<a name="1944"><span class="lineNum">    1944 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="1945"><span class="lineNum">    1945 </span>            :                               if (symbol != NULL)</a>
<a name="1946"><span class="lineNum">    1946 </span>            :                                  {</a>
<a name="1947"><span class="lineNum">    1947 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;Lookup symbol based symbol type: reset symbol = %p = %s \n&quot;,symbol,symbol-&gt;class_name().c_str());</a>
<a name="1948"><span class="lineNum">    1948 </span>            :                                  }</a>
<a name="1949"><span class="lineNum">    1949 </span>            :                                 else</a>
<a name="1950"><span class="lineNum">    1950 </span>            :                                  {</a>
<a name="1951"><span class="lineNum">    1951 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::nameQualificationDepth(): classSymbol == NULL \n&quot;);</a>
<a name="1952"><span class="lineNum">    1952 </span>            :                                  }</a>
<a name="1953"><span class="lineNum">    1953 </span>            : #endif</a>
<a name="1954"><span class="lineNum">    1954 </span>            :                             }</a>
<a name="1955"><span class="lineNum">    1955 </span>            :                            else</a>
<a name="1956"><span class="lineNum">    1956 </span>            :                             {</a>
<a name="1957"><span class="lineNum">    1957 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="1958"><span class="lineNum">    1958 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;Symbol matches the class declaration (classDeclaration-&gt;get_firstNondefiningDeclaration()) classSymbol-&gt;get_declaration() = %p \n&quot;,classSymbol-&gt;get_declaration());</a>
<a name="1959"><span class="lineNum">    1959 </span>            : #endif</a>
<a name="1960"><span class="lineNum">    1960 </span>            :                            // DQ (6/9/2011): I would prefer to have this be true and it might work if it is not, but I would like to have this be a warning for now!</a>
<a name="1961"><span class="lineNum">    1961 </span>            :                            // ROSE_ASSERT(classDeclaration-&gt;get_firstNondefiningDeclaration() == classSymbol-&gt;get_declaration());</a>
<a name="1962"><span class="lineNum">    1962 </span><span class="lineCov">      36014 :                               if (classDeclaration-&gt;get_firstNondefiningDeclaration() != classSymbol-&gt;get_declaration())</span></a>
<a name="1963"><span class="lineNum">    1963 </span>            :                                  {</a>
<a name="1964"><span class="lineNum">    1964 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="1965"><span class="lineNum">    1965 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;WARNING: classDeclaration-&gt;get_firstNondefiningDeclaration() != classSymbol-&gt;get_declaration() \n&quot;);</a>
<a name="1966"><span class="lineNum">    1966 </span>            : #endif</a>
<a name="1967"><span class="lineNum">    1967 </span>            :                                  }</a>
<a name="1968"><span class="lineNum">    1968 </span>            : </a>
<a name="1969"><span class="lineNum">    1969 </span>            :                            // DQ (1/24/2019): Find any associated (outer) class definition scope and check if we need global qualification.</a>
<a name="1970"><span class="lineNum">    1970 </span>            : #if 0</a>
<a name="1971"><span class="lineNum">    1971 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;currentScope = %p = %s \n&quot;,currentScope,currentScope-&gt;class_name().c_str());</a>
<a name="1972"><span class="lineNum">    1972 </span>            : #endif</a>
<a name="1973"><span class="lineNum">    1973 </span><span class="lineCov">      74644 :                               SgScopeStatement* temp_scope = currentScope;</span></a>
<a name="1974"><span class="lineNum">    1974 </span><span class="lineCov">      74644 :                               while (isSgGlobal(temp_scope) == NULL &amp;&amp; isSgClassDefinition(temp_scope) == NULL)</span></a>
<a name="1975"><span class="lineNum">    1975 </span>            :                                  {</a>
<a name="1976"><span class="lineNum">    1976 </span>            : #if 0</a>
<a name="1977"><span class="lineNum">    1977 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;  --- temp_scope = %p = %s \n&quot;,temp_scope,temp_scope-&gt;class_name().c_str());</a>
<a name="1978"><span class="lineNum">    1978 </span>            : #endif</a>
<a name="1979"><span class="lineNum">    1979 </span><span class="lineCov">      38630 :                                    temp_scope = temp_scope-&gt;get_scope();</span></a>
<a name="1980"><span class="lineNum">    1980 </span>            :                                  }</a>
<a name="1981"><span class="lineNum">    1981 </span>            : #if 0</a>
<a name="1982"><span class="lineNum">    1982 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;After loop over parent scopes: temp_scope = %p = %s \n&quot;,temp_scope,temp_scope-&gt;class_name().c_str());</a>
<a name="1983"><span class="lineNum">    1983 </span>            : #endif</a>
<a name="1984"><span class="lineNum">    1984 </span><span class="lineCov">      36014 :                               SgClassDefinition* classDefinition = isSgClassDefinition(temp_scope);</span></a>
<a name="1985"><span class="lineNum">    1985 </span><span class="lineCov">      36014 :                               if (classDefinition != NULL)</span></a>
<a name="1986"><span class="lineNum">    1986 </span>            :                                  {</a>
<a name="1987"><span class="lineNum">    1987 </span><span class="lineCov">      15602 :                                    SgClassDeclaration* definingClassDeclaration = classDefinition-&gt;get_declaration();</span></a>
<a name="1988"><span class="lineNum">    1988 </span><span class="lineCov">      15602 :                                    ASSERT_not_null(definingClassDeclaration);</span></a>
<a name="1989"><span class="lineNum">    1989 </span><span class="lineCov">      15602 :                                    SgClassDeclaration* nondefiningClassDeclaration = isSgClassDeclaration(definingClassDeclaration-&gt;get_firstNondefiningDeclaration());</span></a>
<a name="1990"><span class="lineNum">    1990 </span><span class="lineCov">      15602 :                                    ASSERT_not_null(nondefiningClassDeclaration);</span></a>
<a name="1991"><span class="lineNum">    1991 </span>            : </a>
<a name="1992"><span class="lineNum">    1992 </span><span class="lineCov">      31204 :                                    if (inaccessibleClassSets.find(nondefiningClassDeclaration) != inaccessibleClassSets.end())</span></a>
<a name="1993"><span class="lineNum">    1993 </span>            :                                       {</a>
<a name="1994"><span class="lineNum">    1994 </span>            :                                      // If any of the class declarations in the list of inaccessible class declaration match, then we have to add global qualification.</a>
<a name="1995"><span class="lineNum">    1995 </span><span class="lineNoCov">          0 :                                         std::set&lt;SgClassDeclaration*&gt; &amp; inaccessible_classes = inaccessibleClassSets[nondefiningClassDeclaration];</span></a>
<a name="1996"><span class="lineNum">    1996 </span>            : #if 0</a>
<a name="1997"><span class="lineNum">    1997 </span>            :                                         mfprintf(mlog [ WARN ] ) (&quot;classDeclaration = %p = %s name = %s \n&quot;,classDeclaration,classDeclaration-&gt;class_name().c_str(),classDeclaration-&gt;get_name().str());</a>
<a name="1998"><span class="lineNum">    1998 </span>            : #endif</a>
<a name="1999"><span class="lineNum">    1999 </span><span class="lineNoCov">          0 :                                         SgClassDeclaration* nondefiningClassDeclaration = isSgClassDeclaration(classDeclaration-&gt;get_firstNondefiningDeclaration());</span></a>
<a name="2000"><span class="lineNum">    2000 </span>            :                                      // ROSE_ASSERT(nondefiningClassDeclaration == classDeclaration-&gt;get_firstNondefiningDeclaration());</a>
<a name="2001"><span class="lineNum">    2001 </span>            : </a>
<a name="2002"><span class="lineNum">    2002 </span><span class="lineNoCov">          0 :                                         if (inaccessible_classes.find(nondefiningClassDeclaration) != inaccessible_classes.end())</span></a>
<a name="2003"><span class="lineNum">    2003 </span>            :                                            {</a>
<a name="2004"><span class="lineNum">    2004 </span><span class="lineNoCov">          0 :                                              qualificationDepth++;</span></a>
<a name="2005"><span class="lineNum">    2005 </span>            : #if 0</a>
<a name="2006"><span class="lineNum">    2006 </span>            :                                              mfprintf(mlog [ WARN ] ) (&quot;Found a reference to an inaccessible class --- add global name qualification: qualificationDepth = %d \n&quot;,qualificationDepth);</a>
<a name="2007"><span class="lineNum">    2007 </span>            : #endif</a>
<a name="2008"><span class="lineNum">    2008 </span>            : #if 0</a>
<a name="2009"><span class="lineNum">    2009 </span>            :                                              mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="2010"><span class="lineNum">    2010 </span>            :                                              ROSE_ABORT();</a>
<a name="2011"><span class="lineNum">    2011 </span>            : #endif</a>
<a name="2012"><span class="lineNum">    2012 </span>            :                                            }</a>
<a name="2013"><span class="lineNum">    2013 </span>            :                                       }</a>
<a name="2014"><span class="lineNum">    2014 </span>            :                                  }</a>
<a name="2015"><span class="lineNum">    2015 </span>            :                             }</a>
<a name="2016"><span class="lineNum">    2016 </span>            : </a>
<a name="2017"><span class="lineNum">    2017 </span>            :                          break;</a>
<a name="2018"><span class="lineNum">    2018 </span>            :                        }</a>
<a name="2019"><span class="lineNum">    2019 </span>            : </a>
<a name="2020"><span class="lineNum">    2020 </span><span class="lineCov">      52570 :                     case V_SgNamespaceDeclarationStatement:</span></a>
<a name="2021"><span class="lineNum">    2021 </span><span class="lineCov">      52570 :                        {</span></a>
<a name="2022"><span class="lineNum">    2022 </span>            :                       // There is no type elaboration for a reference to a namespace, so I am not sure what to do here.</a>
<a name="2023"><span class="lineNum">    2023 </span><span class="lineCov">      52570 :                          SgNamespaceDeclarationStatement* namespaceDeclaration = isSgNamespaceDeclarationStatement(declaration);</span></a>
<a name="2024"><span class="lineNum">    2024 </span><span class="lineCov">      52570 :                          ASSERT_not_null(namespaceDeclaration);</span></a>
<a name="2025"><span class="lineNum">    2025 </span>            : </a>
<a name="2026"><span class="lineNum">    2026 </span><span class="lineCov">      52570 :                          SgNamespaceSymbol* namespaceSymbol = isSgNamespaceSymbol(symbol);</span></a>
<a name="2027"><span class="lineNum">    2027 </span>            : </a>
<a name="2028"><span class="lineNum">    2028 </span>            :                       // DQ (6/5/2011): Added support for case where namespaceSymbol == NULL.</a>
<a name="2029"><span class="lineNum">    2029 </span>            :                       // ASSERT_not_null(namespaceSymbol);</a>
<a name="2030"><span class="lineNum">    2030 </span><span class="lineCov">      52570 :                          if (namespaceSymbol == NULL)</span></a>
<a name="2031"><span class="lineNum">    2031 </span>            :                             {</a>
<a name="2032"><span class="lineNum">    2032 </span>            :                            // This is the case of test2011_72.C (where there is a function with a name matching the name of the namespace).</a>
<a name="2033"><span class="lineNum">    2033 </span>            :                            // There is no such think a namespace elaboration, but if there was it might be required at this point.</a>
<a name="2034"><span class="lineNum">    2034 </span>            : </a>
<a name="2035"><span class="lineNum">    2035 </span>            :                            // Reset the symbol to one that will match the declaration.</a>
<a name="2036"><span class="lineNum">    2036 </span><span class="lineNoCov">          0 :                               symbol = SageInterface::lookupNamespaceSymbolInParentScopes(name,currentScope);</span></a>
<a name="2037"><span class="lineNum">    2037 </span>            : </a>
<a name="2038"><span class="lineNum">    2038 </span>            :                            // ASSERT_not_null(symbol);</a>
<a name="2039"><span class="lineNum">    2039 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="2040"><span class="lineNum">    2040 </span>            :                               if (symbol != NULL)</a>
<a name="2041"><span class="lineNum">    2041 </span>            :                                  {</a>
<a name="2042"><span class="lineNum">    2042 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;Lookup symbol based symbol type: reset symbol = %p = %s \n&quot;,symbol,symbol-&gt;class_name().c_str());</a>
<a name="2043"><span class="lineNum">    2043 </span>            :                                  }</a>
<a name="2044"><span class="lineNum">    2044 </span>            :                                 else</a>
<a name="2045"><span class="lineNum">    2045 </span>            :                                  {</a>
<a name="2046"><span class="lineNum">    2046 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::nameQualificationDepth(): functionSymbol == NULL \n&quot;);</a>
<a name="2047"><span class="lineNum">    2047 </span>            :                                  }</a>
<a name="2048"><span class="lineNum">    2048 </span>            : #endif</a>
<a name="2049"><span class="lineNum">    2049 </span>            :                             }</a>
<a name="2050"><span class="lineNum">    2050 </span>            :                            else</a>
<a name="2051"><span class="lineNum">    2051 </span>            :                             {</a>
<a name="2052"><span class="lineNum">    2052 </span>            :                            // This is the typical case.</a>
<a name="2053"><span class="lineNum">    2053 </span>            :                             }</a>
<a name="2054"><span class="lineNum">    2054 </span>            : </a>
<a name="2055"><span class="lineNum">    2055 </span>            :                          break;</a>
<a name="2056"><span class="lineNum">    2056 </span>            :                        }</a>
<a name="2057"><span class="lineNum">    2057 </span>            : </a>
<a name="2058"><span class="lineNum">    2058 </span><span class="lineNoCov">          0 :                     case V_SgNamespaceAliasDeclarationStatement:</span></a>
<a name="2059"><span class="lineNum">    2059 </span><span class="lineNoCov">          0 :                        {</span></a>
<a name="2060"><span class="lineNum">    2060 </span>            :                       // There is no type elaboration for a reference to a namespace, so I am not sure what to do here.</a>
<a name="2061"><span class="lineNum">    2061 </span><span class="lineNoCov">          0 :                          SgNamespaceAliasDeclarationStatement* namespaceAliasDeclaration = isSgNamespaceAliasDeclarationStatement(declaration);</span></a>
<a name="2062"><span class="lineNum">    2062 </span><span class="lineNoCov">          0 :                          ASSERT_not_null(namespaceAliasDeclaration);</span></a>
<a name="2063"><span class="lineNum">    2063 </span>            : </a>
<a name="2064"><span class="lineNum">    2064 </span><span class="lineNoCov">          0 :                          SgNamespaceSymbol* namespaceSymbol = isSgNamespaceSymbol(symbol);</span></a>
<a name="2065"><span class="lineNum">    2065 </span>            : </a>
<a name="2066"><span class="lineNum">    2066 </span>            :                       // DQ (8/1/2020): Record the associated NamespaceAliasDeclarationStatement so it can be used instead in namequalification.</a>
<a name="2067"><span class="lineNum">    2067 </span>            :                       // SgNamespaceDeclarationStatement* namespaceDeclaration = namespaceAliasDeclaration-&gt;get_namespaceDeclaration();</a>
<a name="2068"><span class="lineNum">    2068 </span>            :                       // namespaceAliasDeclarationMap.insert(pair&lt;SgNamespaceDeclarationStatement,SgNamespaceAliasDeclarationStatement&gt;(namespaceDeclaration,namespaceAliasDeclaration));</a>
<a name="2069"><span class="lineNum">    2069 </span>            :                       // printf (&quot;case V_SgNamespaceAliasDeclarationStatement: namespaceAliasDeclarationMap.size() = %zu \n&quot;,namespaceAliasDeclarationMap.size());</a>
<a name="2070"><span class="lineNum">    2070 </span>            : </a>
<a name="2071"><span class="lineNum">    2071 </span>            :                       // DQ (6/5/2011): Added support for case where namespaceSymbol == NULL.</a>
<a name="2072"><span class="lineNum">    2072 </span>            :                       // ASSERT_not_null(namespaceSymbol);</a>
<a name="2073"><span class="lineNum">    2073 </span><span class="lineNoCov">          0 :                          if (namespaceSymbol == NULL)</span></a>
<a name="2074"><span class="lineNum">    2074 </span>            :                             {</a>
<a name="2075"><span class="lineNum">    2075 </span>            :                            // This is the case of test2011_72.C (where there is a function with a name matching the name of the namespace).</a>
<a name="2076"><span class="lineNum">    2076 </span>            :                            // There is no such think a namespace elaboration, but if there was it might be required at this point.</a>
<a name="2077"><span class="lineNum">    2077 </span>            : </a>
<a name="2078"><span class="lineNum">    2078 </span>            :                            // Reset the symbol to one that will match the declaration.</a>
<a name="2079"><span class="lineNum">    2079 </span><span class="lineNoCov">          0 :                               symbol = SageInterface::lookupNamespaceSymbolInParentScopes(name,currentScope);</span></a>
<a name="2080"><span class="lineNum">    2080 </span>            : </a>
<a name="2081"><span class="lineNum">    2081 </span>            :                            // ASSERT_not_null(symbol);</a>
<a name="2082"><span class="lineNum">    2082 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="2083"><span class="lineNum">    2083 </span>            :                               if (symbol != NULL)</a>
<a name="2084"><span class="lineNum">    2084 </span>            :                                  {</a>
<a name="2085"><span class="lineNum">    2085 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;Lookup symbol based symbol type: reset symbol = %p = %s \n&quot;,symbol,symbol-&gt;class_name().c_str());</a>
<a name="2086"><span class="lineNum">    2086 </span>            :                                  }</a>
<a name="2087"><span class="lineNum">    2087 </span>            :                                 else</a>
<a name="2088"><span class="lineNum">    2088 </span>            :                                  {</a>
<a name="2089"><span class="lineNum">    2089 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::nameQualificationDepth(): functionSymbol == NULL \n&quot;);</a>
<a name="2090"><span class="lineNum">    2090 </span>            :                                  }</a>
<a name="2091"><span class="lineNum">    2091 </span>            : #endif</a>
<a name="2092"><span class="lineNum">    2092 </span>            :                             }</a>
<a name="2093"><span class="lineNum">    2093 </span>            :                            else</a>
<a name="2094"><span class="lineNum">    2094 </span>            :                             {</a>
<a name="2095"><span class="lineNum">    2095 </span>            :                            // This is the typical case.</a>
<a name="2096"><span class="lineNum">    2096 </span>            :                             }</a>
<a name="2097"><span class="lineNum">    2097 </span>            : #if 0</a>
<a name="2098"><span class="lineNum">    2098 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="2099"><span class="lineNum">    2099 </span>            :                          ROSE_ABORT();</a>
<a name="2100"><span class="lineNum">    2100 </span>            : #endif</a>
<a name="2101"><span class="lineNum">    2101 </span>            :                          break;</a>
<a name="2102"><span class="lineNum">    2102 </span>            :                        }</a>
<a name="2103"><span class="lineNum">    2103 </span>            : </a>
<a name="2104"><span class="lineNum">    2104 </span>            :                  // DQ (12/28/2011): Added support for template functions and template member functions.</a>
<a name="2105"><span class="lineNum">    2105 </span><span class="lineCov">       9831 :                     case V_SgTemplateFunctionDeclaration:</span></a>
<a name="2106"><span class="lineNum">    2106 </span><span class="lineCov">       9831 :                     case V_SgTemplateMemberFunctionDeclaration:</span></a>
<a name="2107"><span class="lineNum">    2107 </span>            : </a>
<a name="2108"><span class="lineNum">    2108 </span>            :                  // DQ (6/1/2011): Added case for SgTemplateInstantiationFunctionDecl.</a>
<a name="2109"><span class="lineNum">    2109 </span>            :                  // case V_SgTemplateInstantiationFunctionDecl:</a>
<a name="2110"><span class="lineNum">    2110 </span><span class="lineCov">       9831 :                     case V_SgTemplateInstantiationMemberFunctionDecl:</span></a>
<a name="2111"><span class="lineNum">    2111 </span><span class="lineCov">       9831 :                     case V_SgMemberFunctionDeclaration:</span></a>
<a name="2112"><span class="lineNum">    2112 </span><span class="lineCov">       9831 :                     case V_SgFunctionDeclaration:</span></a>
<a name="2113"><span class="lineNum">    2113 </span><span class="lineCov">       9831 :                        {</span></a>
<a name="2114"><span class="lineNum">    2114 </span><span class="lineCov">       9831 :                          SgFunctionDeclaration* functionDeclaration = isSgFunctionDeclaration(declaration);</span></a>
<a name="2115"><span class="lineNum">    2115 </span><span class="lineCov">       9831 :                          ASSERT_not_null(functionDeclaration);</span></a>
<a name="2116"><span class="lineNum">    2116 </span>            : #if DEBUG_FUNCTION_RESOLUTION</a>
<a name="2117"><span class="lineNum">    2117 </span>            :                          printf (&quot;functionDeclaration = %p = %s name = %s \n&quot;,functionDeclaration,functionDeclaration-&gt;class_name().c_str(),functionDeclaration-&gt;get_name().str());</a>
<a name="2118"><span class="lineNum">    2118 </span>            : #endif</a>
<a name="2119"><span class="lineNum">    2119 </span><span class="lineCov">       9831 :                          SgFunctionSymbol* functionSymbol = isSgFunctionSymbol(symbol);</span></a>
<a name="2120"><span class="lineNum">    2120 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || DEBUG_FUNCTION_RESOLUTION</a>
<a name="2121"><span class="lineNum">    2121 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;case function declaration: functionSymbol = %p \n&quot;,functionSymbol);</a>
<a name="2122"><span class="lineNum">    2122 </span>            : #endif</a>
<a name="2123"><span class="lineNum">    2123 </span>            :                       // DQ (7/22/2017): Added test for SgTemplateInstantiationDirectiveStatement, so that we can process the</a>
<a name="2124"><span class="lineNum">    2124 </span>            :                       // template arguments correctly (using the scope of the SgTemplateInstantiationDirectiveStatement instead</a>
<a name="2125"><span class="lineNum">    2125 </span>            :                       // of the scope of the SgTemplateInstantiationMemberFunctionDecl (which can be different)).</a>
<a name="2126"><span class="lineNum">    2126 </span>            :                       // DQ (6/3/2017): Add test to check if this is part of a template instantiation directive.</a>
<a name="2127"><span class="lineNum">    2127 </span>            :                       // However, I think that out use of name qualification is independent of this result.</a>
<a name="2128"><span class="lineNum">    2128 </span><span class="lineCov">       9831 :                          SgTemplateInstantiationDirectiveStatement* templateInstantiationDirectiveStatement = isSgTemplateInstantiationDirectiveStatement(functionDeclaration-&gt;get_parent());</span></a>
<a name="2129"><span class="lineNum">    2129 </span><span class="lineCov">       9831 :                          if (templateInstantiationDirectiveStatement != NULL)</span></a>
<a name="2130"><span class="lineNum">    2130 </span>            :                             {</a>
<a name="2131"><span class="lineNum">    2131 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || DEBUG_FUNCTION_RESOLUTION</a>
<a name="2132"><span class="lineNum">    2132 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;******** Found a member function template instantiation that is a part of a SgTemplateInstantiationDirectiveStatement \n&quot;);</a>
<a name="2133"><span class="lineNum">    2133 </span>            : #endif</a>
<a name="2134"><span class="lineNum">    2134 </span>            : #if 1</a>
<a name="2135"><span class="lineNum">    2135 </span><span class="lineNoCov">          0 :                               mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</span></a>
<a name="2136"><span class="lineNum">    2136 </span><span class="lineNoCov">          0 :                               ROSE_ABORT();</span></a>
<a name="2137"><span class="lineNum">    2137 </span>            : #endif</a>
<a name="2138"><span class="lineNum">    2138 </span>            :                             }</a>
<a name="2139"><span class="lineNum">    2139 </span>            : </a>
<a name="2140"><span class="lineNum">    2140 </span><span class="lineCov">       9831 :                          SgFunctionType* functionType = functionDeclaration-&gt;get_type();</span></a>
<a name="2141"><span class="lineNum">    2141 </span><span class="lineCov">       9831 :                          ASSERT_not_null(functionType);</span></a>
<a name="2142"><span class="lineNum">    2142 </span>            : #if DEBUG_FUNCTION_RESOLUTION</a>
<a name="2143"><span class="lineNum">    2143 </span>            :                          printf (&quot;functionSymbol = %p \n&quot;,functionSymbol);</a>
<a name="2144"><span class="lineNum">    2144 </span>            : #endif</a>
<a name="2145"><span class="lineNum">    2145 </span>            :                       // ASSERT_not_null(classSymbol);</a>
<a name="2146"><span class="lineNum">    2146 </span><span class="lineCov">       9831 :                          if (functionSymbol == NULL)</span></a>
<a name="2147"><span class="lineNum">    2147 </span>            :                             {</a>
<a name="2148"><span class="lineNum">    2148 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || DEBUG_FUNCTION_RESOLUTION</a>
<a name="2149"><span class="lineNum">    2149 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;Type elaboration is required: declaration = %s symbol = %s \n&quot;,declaration-&gt;class_name().c_str(),symbol-&gt;class_name().c_str());</a>
<a name="2150"><span class="lineNum">    2150 </span>            : #endif</a>
<a name="2151"><span class="lineNum">    2151 </span>            :                            // DQ (7/25/2018): Type elaboration does not make sense for functions.  This is a case where name qualification</a>
<a name="2152"><span class="lineNum">    2152 </span>            :                            // is required because the function is hidden by some non-function. The symbol was non-null and it was not a</a>
<a name="2153"><span class="lineNum">    2153 </span>            :                            // function.  Question: could it be a function that hides the function name from another function (I think so)?</a>
<a name="2154"><span class="lineNum">    2154 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || DEBUG_FUNCTION_RESOLUTION</a>
<a name="2155"><span class="lineNum">    2155 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;########### NOTE: NEED TO FORCE NAME QUALIFICATION SINCE TYPE ELABLORATION IS NOT A SOLUTION FOR declarations hiding a function \n&quot;);</a>
<a name="2156"><span class="lineNum">    2156 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;functionSymbol == NULL: symbol = %p = %s \n&quot;,symbol,symbol-&gt;class_name().c_str());</a>
<a name="2157"><span class="lineNum">    2157 </span>            : #endif</a>
<a name="2158"><span class="lineNum">    2158 </span>            : #if 0</a>
<a name="2159"><span class="lineNum">    2159 </span>            :                               typeElaborationIsRequired = true;</a>
<a name="2160"><span class="lineNum">    2160 </span>            : #else</a>
<a name="2161"><span class="lineNum">    2161 </span>            :                            // DQ (9/2/2020): Name qualification of functions for SgCtorInitializionList should not force name qualification.</a>
<a name="2162"><span class="lineNum">    2162 </span>            :                            // I think we have to force an extra level of name qualification (see Cxx11_tests/test2018_121.C).</a>
<a name="2163"><span class="lineNum">    2163 </span>            : #if 1</a>
<a name="2164"><span class="lineNum">    2164 </span>            : #if 0</a>
<a name="2165"><span class="lineNum">    2165 </span>            :                               printf (&quot;Setting forceMoreNameQualification = true \n&quot;);</a>
<a name="2166"><span class="lineNum">    2166 </span>            : #endif</a>
<a name="2167"><span class="lineNum">    2167 </span><span class="lineCov">        510 :                               forceMoreNameQualification = true;</span></a>
<a name="2168"><span class="lineNum">    2168 </span>            : #else</a>
<a name="2169"><span class="lineNum">    2169 </span>            : #if ( (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) &amp;&amp; 0) || DEBUG_FUNCTION_RESOLUTION</a>
<a name="2170"><span class="lineNum">    2170 </span>            :                               printf (&quot;In NameQualificationTraversal::nameQualificationDepth(): Skip setting forceMoreNameQualification = true: forceMoreNameQualification = %s \n&quot;,</a>
<a name="2171"><span class="lineNum">    2171 </span>            :                                    forceMoreNameQualification ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="2172"><span class="lineNum">    2172 </span>            :                               printf (&quot;In NameQualificationTraversal::nameQualificationDepth(): Skip setting forceMoreNameQualification = true: declaration = %p = %s name = %s \n&quot;,</a>
<a name="2173"><span class="lineNum">    2173 </span>            :                                    declaration,declaration-&gt;class_name().c_str(),SageInterface::get_name(declaration).c_str());</a>
<a name="2174"><span class="lineNum">    2174 </span>            :                               printf (&quot;In NameQualificationTraversal::nameQualificationDepth(): Skip setting forceMoreNameQualification = true: currentScope = %p = %s name = %s \n&quot;,currentScope,</a>
<a name="2175"><span class="lineNum">    2175 </span>            :                                    currentScope-&gt;class_name().c_str(),SageInterface::get_name(currentScope).c_str());</a>
<a name="2176"><span class="lineNum">    2176 </span>            :                               printf (&quot;In NameQualificationTraversal::nameQualificationDepth(): Skip setting forceMoreNameQualification = true: positionStatement = %p = %s name = %s \n&quot;,positionStatement,</a>
<a name="2177"><span class="lineNum">    2177 </span>            :                                    positionStatement-&gt;class_name().c_str(),SageInterface::get_name(positionStatement).c_str());</a>
<a name="2178"><span class="lineNum">    2178 </span>            : #endif</a>
<a name="2179"><span class="lineNum">    2179 </span>            :                               printf (&quot;Skip setting forceMoreNameQualification = true \n&quot;);</a>
<a name="2180"><span class="lineNum">    2180 </span>            : #endif</a>
<a name="2181"><span class="lineNum">    2181 </span>            : #endif</a>
<a name="2182"><span class="lineNum">    2182 </span>            : #if 0</a>
<a name="2183"><span class="lineNum">    2183 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="2184"><span class="lineNum">    2184 </span>            :                               ROSE_ABORT();</a>
<a name="2185"><span class="lineNum">    2185 </span>            : #endif</a>
<a name="2186"><span class="lineNum">    2186 </span>            : </a>
<a name="2187"><span class="lineNum">    2187 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || DEBUG_FUNCTION_RESOLUTION</a>
<a name="2188"><span class="lineNum">    2188 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;WARNING: Present implementation of symbol table will not find alias symbols of SgFunctionSymbol \n&quot;);</a>
<a name="2189"><span class="lineNum">    2189 </span>            : #endif</a>
<a name="2190"><span class="lineNum">    2190 </span>            :                            // Reset the symbol to one that will match the declaration.</a>
<a name="2191"><span class="lineNum">    2191 </span>            :                            // DQ (4/12/2014): I think we need to use the version of the function that matches the function type.</a>
<a name="2192"><span class="lineNum">    2192 </span>            :                            // See test2014_42.C for an example of this.</a>
<a name="2193"><span class="lineNum">    2193 </span>            :                            // symbol = SageInterface::lookupFunctionSymbolInParentScopes(name,currentScope);</a>
<a name="2194"><span class="lineNum">    2194 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || DEBUG_FUNCTION_RESOLUTION</a>
<a name="2195"><span class="lineNum">    2195 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;NOTE: we are now using the function type in the initial function symbol lookup? \n&quot;);</a>
<a name="2196"><span class="lineNum">    2196 </span>            : #endif</a>
<a name="2197"><span class="lineNum">    2197 </span>            : </a>
<a name="2198"><span class="lineNum">    2198 </span>            :                            // DQ (4/6/2018): Note that since we use the function type, we are getting the subset of</a>
<a name="2199"><span class="lineNum">    2199 </span>            :                            // matching function that would force additional name qualification.</a>
<a name="2200"><span class="lineNum">    2200 </span><span class="lineCov">        510 :                               symbol = SageInterface::lookupFunctionSymbolInParentScopes(name,functionType,currentScope);</span></a>
<a name="2201"><span class="lineNum">    2201 </span>            : </a>
<a name="2202"><span class="lineNum">    2202 </span>            :                            // ASSERT_not_null(symbol);</a>
<a name="2203"><span class="lineNum">    2203 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || DEBUG_FUNCTION_RESOLUTION</a>
<a name="2204"><span class="lineNum">    2204 </span>            :                               if (symbol != NULL)</a>
<a name="2205"><span class="lineNum">    2205 </span>            :                                  {</a>
<a name="2206"><span class="lineNum">    2206 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;Lookup symbol based symbol type: reset symbol = %p = %s \n&quot;,symbol,symbol-&gt;class_name().c_str());</a>
<a name="2207"><span class="lineNum">    2207 </span>            :                                  }</a>
<a name="2208"><span class="lineNum">    2208 </span>            :                                 else</a>
<a name="2209"><span class="lineNum">    2209 </span>            :                                  {</a>
<a name="2210"><span class="lineNum">    2210 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::nameQualificationDepth(): functionSymbol == NULL \n&quot;);</a>
<a name="2211"><span class="lineNum">    2211 </span>            :                                  }</a>
<a name="2212"><span class="lineNum">    2212 </span>            : #endif</a>
<a name="2213"><span class="lineNum">    2213 </span>            :                             }</a>
<a name="2214"><span class="lineNum">    2214 </span>            :                            else</a>
<a name="2215"><span class="lineNum">    2215 </span>            :                             {</a>
<a name="2216"><span class="lineNum">    2216 </span>            :                            // DQ (4/12/2014): But is this the correct symbol for a function of the same type.</a>
<a name="2217"><span class="lineNum">    2217 </span>            :                            // See test2014_42.C for an example where this is an overloaded function declaration and the WRONG one.</a>
<a name="2218"><span class="lineNum">    2218 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || DEBUG_FUNCTION_RESOLUTION</a>
<a name="2219"><span class="lineNum">    2219 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;case function declaration: functionSymbol = %p: but is it associated with the correct type \n&quot;,functionSymbol);</a>
<a name="2220"><span class="lineNum">    2220 </span>            : #endif</a>
<a name="2221"><span class="lineNum">    2221 </span><span class="lineCov">       9321 :                               SgFunctionType* functionTypeAssociatedWithSymbol = isSgFunctionType(functionSymbol-&gt;get_type());</span></a>
<a name="2222"><span class="lineNum">    2222 </span><span class="lineCov">       9321 :                               ASSERT_not_null(functionTypeAssociatedWithSymbol);</span></a>
<a name="2223"><span class="lineNum">    2223 </span>            : </a>
<a name="2224"><span class="lineNum">    2224 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || DEBUG_FUNCTION_RESOLUTION</a>
<a name="2225"><span class="lineNum">    2225 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;case function declaration: functionType = %p \n&quot;,functionType);</a>
<a name="2226"><span class="lineNum">    2226 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;case function declaration: functionTypeAssociatedWithSymbol = %p \n&quot;,functionTypeAssociatedWithSymbol);</a>
<a name="2227"><span class="lineNum">    2227 </span>            : #endif</a>
<a name="2228"><span class="lineNum">    2228 </span><span class="lineCov">       9321 :                               if (functionType != functionTypeAssociatedWithSymbol)</span></a>
<a name="2229"><span class="lineNum">    2229 </span>            :                                  {</a>
<a name="2230"><span class="lineNum">    2230 </span>            : #if ((DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) &amp;&amp; 0) || DEBUG_FUNCTION_RESOLUTION</a>
<a name="2231"><span class="lineNum">    2231 </span>            :                                    printf (&quot;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ \n&quot;);</a>
<a name="2232"><span class="lineNum">    2232 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;NOTE: we are now using the function type in the initial function symbol lookup? \n&quot;);</a>
<a name="2233"><span class="lineNum">    2233 </span>            :                                    printf (&quot;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ \n&quot;);</a>
<a name="2234"><span class="lineNum">    2234 </span>            : #endif</a>
<a name="2235"><span class="lineNum">    2235 </span>            :                                 // DQ (4/12/2014): we need to record that there was another function identified in the parent scopes that we will want to have force name qualification.</a>
<a name="2236"><span class="lineNum">    2236 </span><span class="lineCov">       1910 :                                    foundAnOverloadedFunctionWithSameName = true;</span></a>
<a name="2237"><span class="lineNum">    2237 </span>            : </a>
<a name="2238"><span class="lineNum">    2238 </span>            :                                 // DQ (4/12/2014): Check if the scopes are the same.  If the same then we don't need name qualification.</a>
<a name="2239"><span class="lineNum">    2239 </span><span class="lineCov">       1910 :                                    SgScopeStatement* scopeAssociatedWithSymbol = functionSymbol-&gt;get_declaration()-&gt;get_scope();</span></a>
<a name="2240"><span class="lineNum">    2240 </span><span class="lineCov">       1910 :                                    ASSERT_not_null(scopeAssociatedWithSymbol);</span></a>
<a name="2241"><span class="lineNum">    2241 </span><span class="lineCov">       1910 :                                    SgScopeStatement* scopeOfDeclaration = declaration-&gt;get_scope();</span></a>
<a name="2242"><span class="lineNum">    2242 </span><span class="lineCov">       1910 :                                    ASSERT_not_null(scopeOfDeclaration);</span></a>
<a name="2243"><span class="lineNum">    2243 </span>            : </a>
<a name="2244"><span class="lineNum">    2244 </span><span class="lineCov">       1910 :                                    if (scopeAssociatedWithSymbol == scopeOfDeclaration)</span></a>
<a name="2245"><span class="lineNum">    2245 </span>            :                                       {</a>
<a name="2246"><span class="lineNum">    2246 </span><span class="lineCov">       1129 :                                         foundAnOverloadedFunctionInSameScope = true;</span></a>
<a name="2247"><span class="lineNum">    2247 </span>            :                                       }</a>
<a name="2248"><span class="lineNum">    2248 </span>            : </a>
<a name="2249"><span class="lineNum">    2249 </span>            :                                 // DQ (4/6/2018): Note that since we use the function type, we are getting the subset of</a>
<a name="2250"><span class="lineNum">    2250 </span>            :                                 // matching function that would force additional name qualification.</a>
<a name="2251"><span class="lineNum">    2251 </span><span class="lineCov">       1910 :                                    symbol = SageInterface::lookupFunctionSymbolInParentScopes(name,functionType,currentScope);</span></a>
<a name="2252"><span class="lineNum">    2252 </span>            : </a>
<a name="2253"><span class="lineNum">    2253 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || DEBUG_FUNCTION_RESOLUTION</a>
<a name="2254"><span class="lineNum">    2254 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;After using the function type: symbol = %p \n&quot;,symbol);</a>
<a name="2255"><span class="lineNum">    2255 </span>            : #endif</a>
<a name="2256"><span class="lineNum">    2256 </span>            :                                  }</a>
<a name="2257"><span class="lineNum">    2257 </span>            :                                 else</a>
<a name="2258"><span class="lineNum">    2258 </span>            :                                  {</a>
<a name="2259"><span class="lineNum">    2259 </span>            : </a>
<a name="2260"><span class="lineNum">    2260 </span>            :                                 // DQ (9/21/2020): Cxx11_tests/test2020_95.C and test2020_100.C demonstrate that this is not enough.</a>
<a name="2261"><span class="lineNum">    2261 </span>            :                                 // DQ (8/30/2020): Adding support for a more sophisticated level of function ambiguity resolution.</a>
<a name="2262"><span class="lineNum">    2262 </span>            :                                 // Here we add the lookup of same named functions in the scopes defined by the types associated</a>
<a name="2263"><span class="lineNum">    2263 </span>            :                                 // with function parameters.</a>
<a name="2264"><span class="lineNum">    2264 </span>            : </a>
<a name="2265"><span class="lineNum">    2265 </span>            : #define DEBUG_FUNCTION_AMBIGUITY (0 || DEBUG_FUNCTION_RESOLUTION)</a>
<a name="2266"><span class="lineNum">    2266 </span>            : </a>
<a name="2267"><span class="lineNum">    2267 </span>            : #if DEBUG_FUNCTION_AMBIGUITY</a>
<a name="2268"><span class="lineNum">    2268 </span>            :                                    printf (&quot;\n\nWe found the correct function, but now we need to check for any other possible matches that would drive more name qualification \n&quot;);</a>
<a name="2269"><span class="lineNum">    2269 </span>            : </a>
<a name="2270"><span class="lineNum">    2270 </span>            :                                    printf (&quot;Before loop over function parameter types: foundAnOverloadedFunctionWithSameName = %s \n&quot;,foundAnOverloadedFunctionWithSameName ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="2271"><span class="lineNum">    2271 </span>            :                                    printf (&quot;Before loop over function parameter types: foundAnOverloadedFunctionInSameScope = %s \n&quot;,foundAnOverloadedFunctionInSameScope   ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="2272"><span class="lineNum">    2272 </span>            :                                    printf (&quot; --- currentScope   = %p = %s name = %s \n&quot;,currentScope,currentScope-&gt;class_name().c_str(),SageInterface::get_name(currentScope).c_str());</a>
<a name="2273"><span class="lineNum">    2273 </span>            :                                    printf (&quot; --- functionSymbol = %p = %s name = %s \n&quot;,functionSymbol,functionSymbol-&gt;class_name().c_str(),SageInterface::get_name(functionSymbol).c_str());</a>
<a name="2274"><span class="lineNum">    2274 </span>            : #endif</a>
<a name="2275"><span class="lineNum">    2275 </span><span class="lineCov">       7411 :                                    SgDeclarationStatement* declaration = functionSymbol-&gt;get_declaration();</span></a>
<a name="2276"><span class="lineNum">    2276 </span><span class="lineCov">       7411 :                                    ROSE_ASSERT(declaration != NULL);</span></a>
<a name="2277"><span class="lineNum">    2277 </span><span class="lineCov">       7411 :                                    bool isFriendFunction = (declaration-&gt;get_declarationModifier().isFriend() == true);</span></a>
<a name="2278"><span class="lineNum">    2278 </span>            : </a>
<a name="2279"><span class="lineNum">    2279 </span>            :                                 // Compute a scope outside of the scope where the function is recognized.</a>
<a name="2280"><span class="lineNum">    2280 </span><span class="lineCov">       7411 :                                    SgScopeStatement* alternate_scope = declaration-&gt;get_scope();</span></a>
<a name="2281"><span class="lineNum">    2281 </span><span class="lineCov">       7411 :                                    if (isSgGlobal(alternate_scope) == NULL)</span></a>
<a name="2282"><span class="lineNum">    2282 </span>            :                                       {</a>
<a name="2283"><span class="lineNum">    2283 </span><span class="lineCov">       4545 :                                         alternate_scope = alternate_scope-&gt;get_scope();</span></a>
<a name="2284"><span class="lineNum">    2284 </span>            :                                       }</a>
<a name="2285"><span class="lineNum">    2285 </span>            : </a>
<a name="2286"><span class="lineNum">    2286 </span>            : #if ((DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) &amp;&amp; 0) || DEBUG_FUNCTION_RESOLUTION</a>
<a name="2287"><span class="lineNum">    2287 </span>            :                                    printf (&quot;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp; \n&quot;);</a>
<a name="2288"><span class="lineNum">    2288 </span>            :                                    printf (&quot;In NameQualificationTraversal::nameQualificationDepth(): check if we need function parameter resolution: forceMoreNameQualification = %s \n&quot;,</a>
<a name="2289"><span class="lineNum">    2289 </span>            :                                         forceMoreNameQualification ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="2290"><span class="lineNum">    2290 </span>            :                                    printf (&quot;In NameQualificationTraversal::nameQualificationDepth(): check if we need function parameter resolution: name = %s \n&quot;,name.str());</a>
<a name="2291"><span class="lineNum">    2291 </span>            :                                    printf (&quot;In NameQualificationTraversal::nameQualificationDepth(): check if we need function parameter resolution: declaration = %p = %s name = %s \n&quot;,</a>
<a name="2292"><span class="lineNum">    2292 </span>            :                                         declaration,declaration-&gt;class_name().c_str(),SageInterface::get_name(declaration).c_str());</a>
<a name="2293"><span class="lineNum">    2293 </span>            :                                    printf (&quot;In NameQualificationTraversal::nameQualificationDepth(): check if we need function parameter resolution: currentScope = %p = %s name = %s \n&quot;,currentScope,</a>
<a name="2294"><span class="lineNum">    2294 </span>            :                                         currentScope-&gt;class_name().c_str(),SageInterface::get_name(currentScope).c_str());</a>
<a name="2295"><span class="lineNum">    2295 </span>            :                                    printf (&quot;In NameQualificationTraversal::nameQualificationDepth(): check if we need function parameter resolution: alternate_scope = %p = %s name = %s \n&quot;,alternate_scope,</a>
<a name="2296"><span class="lineNum">    2296 </span>            :                                         alternate_scope-&gt;class_name().c_str(),SageInterface::get_name(alternate_scope).c_str());</a>
<a name="2297"><span class="lineNum">    2297 </span>            :                                    printf (&quot;In NameQualificationTraversal::nameQualificationDepth(): check if we need function parameter resolution: positionStatement = %p = %s name = %s \n&quot;,positionStatement,</a>
<a name="2298"><span class="lineNum">    2298 </span>            :                                         positionStatement-&gt;class_name().c_str(),SageInterface::get_name(positionStatement).c_str());</a>
<a name="2299"><span class="lineNum">    2299 </span>            :                                    printf (&quot;In NameQualificationTraversal::nameQualificationDepth(): check if we need function parameter resolution: functionType = %p = %s name = %s \n&quot;,functionType,</a>
<a name="2300"><span class="lineNum">    2300 </span>            :                                         functionType-&gt;class_name().c_str(),SageInterface::get_name(functionType).c_str());</a>
<a name="2301"><span class="lineNum">    2301 </span>            : #endif</a>
<a name="2302"><span class="lineNum">    2302 </span><span class="lineCov">       7411 :                                    SgSymbol* alternate_symbol = SageInterface::lookupFunctionSymbolInParentScopes(name,functionType,alternate_scope);</span></a>
<a name="2303"><span class="lineNum">    2303 </span>            : </a>
<a name="2304"><span class="lineNum">    2304 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || DEBUG_FUNCTION_RESOLUTION</a>
<a name="2305"><span class="lineNum">    2305 </span>            :                                    printf (&quot;alternate_symbol = %p = %s name = %s \n&quot;,alternate_symbol,alternate_symbol-&gt;class_name().c_str(),alternate_symbol-&gt;get_name().str());</a>
<a name="2306"><span class="lineNum">    2306 </span>            : #endif</a>
<a name="2307"><span class="lineNum">    2307 </span>            : </a>
<a name="2308"><span class="lineNum">    2308 </span>            : </a>
<a name="2309"><span class="lineNum">    2309 </span>            : #if DEBUG_FUNCTION_AMBIGUITY</a>
<a name="2310"><span class="lineNum">    2310 </span>            :                                    printf (&quot; --- declaration = %p = %s name = %s \n&quot;,declaration,declaration-&gt;class_name().c_str(),SageInterface::get_name(declaration).c_str());</a>
<a name="2311"><span class="lineNum">    2311 </span>            :                                    printf (&quot; --- isFriendFunction = %s \n&quot;,isFriendFunction ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="2312"><span class="lineNum">    2312 </span>            : #endif</a>
<a name="2313"><span class="lineNum">    2313 </span><span class="lineCov">       7411 :                                    bool symbols_match = ((alternate_symbol != NULL) &amp;&amp; (functionSymbol == alternate_symbol));</span></a>
<a name="2314"><span class="lineNum">    2314 </span>            : #if DEBUG_FUNCTION_AMBIGUITY</a>
<a name="2315"><span class="lineNum">    2315 </span>            :                                    printf (&quot; --- symbols_match = %s \n&quot;,symbols_match ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="2316"><span class="lineNum">    2316 </span>            : #endif</a>
<a name="2317"><span class="lineNum">    2317 </span>            : #if 1</a>
<a name="2318"><span class="lineNum">    2318 </span>            :                                 // DQ (9/22/2020): Cxx11_tests/test2020_95.C demonstrated that we needed more than just</a>
<a name="2319"><span class="lineNum">    2319 </span>            :                                 // this code below to handle Cxx11_tests/test2020_101.C.</a>
<a name="2320"><span class="lineNum">    2320 </span>            :                                 // DQ (8/31/2020): friend functions are not processed using this parameter based lookup.</a>
<a name="2321"><span class="lineNum">    2321 </span>            :                                 // Specifically, less name qualification is allowed for GNU versions after 7.x and in</a>
<a name="2322"><span class="lineNum">    2322 </span>            :                                 // particular version 10.2. Also an error for clang version 10.x.</a>
<a name="2323"><span class="lineNum">    2323 </span>            :                                 // if (isFriendFunction == false)</a>
<a name="2324"><span class="lineNum">    2324 </span><span class="lineCov">       7411 :                                    if (isFriendFunction == false &amp;&amp; symbols_match == false)</span></a>
<a name="2325"><span class="lineNum">    2325 </span>            :                                       {</a>
<a name="2326"><span class="lineNum">    2326 </span>            :                                      // Use the scopes of the function parameters to look for where there could be an ambiguity.</a>
<a name="2327"><span class="lineNum">    2327 </span><span class="lineCov">       4010 :                                         SgFunctionParameterTypeList* functionParameterTypeList = functionType-&gt;get_argument_list();</span></a>
<a name="2328"><span class="lineNum">    2328 </span><span class="lineCov">       4010 :                                         ROSE_ASSERT(functionParameterTypeList != NULL);</span></a>
<a name="2329"><span class="lineNum">    2329 </span>            : </a>
<a name="2330"><span class="lineNum">    2330 </span><span class="lineCov">       4010 :                                         SgTypePtrList &amp; typeList = functionParameterTypeList-&gt;get_arguments();</span></a>
<a name="2331"><span class="lineNum">    2331 </span><span class="lineCov">       8539 :                                         for (SgTypePtrList::iterator i = typeList.begin(); i != typeList.end(); i++)</span></a>
<a name="2332"><span class="lineNum">    2332 </span>            :                                            {</a>
<a name="2333"><span class="lineNum">    2333 </span>            :                                           // for each type in the parameter type list.</a>
<a name="2334"><span class="lineNum">    2334 </span><span class="lineCov">       4529 :                                              SgType* parameter_type = *i;</span></a>
<a name="2335"><span class="lineNum">    2335 </span>            : #if DEBUG_FUNCTION_AMBIGUITY</a>
<a name="2336"><span class="lineNum">    2336 </span>            :                                              printf (&quot;parameter_type = %p = %s \n&quot;,parameter_type,parameter_type-&gt;class_name().c_str());</a>
<a name="2337"><span class="lineNum">    2337 </span>            : #endif</a>
<a name="2338"><span class="lineNum">    2338 </span><span class="lineCov">       4529 :                                              unsigned char strip_bit_array = SgType::STRIP_MODIFIER_TYPE | SgType::STRIP_REFERENCE_TYPE |</span></a>
<a name="2339"><span class="lineNum">    2339 </span>            :                                                   SgType::STRIP_RVALUE_REFERENCE_TYPE | SgType::STRIP_POINTER_TYPE | SgType::STRIP_ARRAY_TYPE |</a>
<a name="2340"><span class="lineNum">    2340 </span>            :                                                   SgType::STRIP_TYPEDEF_TYPE | SgType::STRIP_POINTER_MEMBER_TYPE;</a>
<a name="2341"><span class="lineNum">    2341 </span>            : </a>
<a name="2342"><span class="lineNum">    2342 </span><span class="lineCov">       4529 :                                              SgType* stripped_parameter_type = parameter_type-&gt;stripType(strip_bit_array);</span></a>
<a name="2343"><span class="lineNum">    2343 </span>            : #if DEBUG_FUNCTION_AMBIGUITY</a>
<a name="2344"><span class="lineNum">    2344 </span>            :                                              printf (&quot;stripped_parameter_type = %p = %s \n&quot;,stripped_parameter_type,stripped_parameter_type-&gt;class_name().c_str());</a>
<a name="2345"><span class="lineNum">    2345 </span>            : #endif</a>
<a name="2346"><span class="lineNum">    2346 </span><span class="lineCov">       4529 :                                              SgNamedType* parameter_namedType = isSgNamedType(stripped_parameter_type);</span></a>
<a name="2347"><span class="lineNum">    2347 </span><span class="lineCov">       4529 :                                              if (parameter_namedType != NULL)</span></a>
<a name="2348"><span class="lineNum">    2348 </span>            :                                                 {</a>
<a name="2349"><span class="lineNum">    2349 </span><span class="lineCov">       2046 :                                                   SgDeclarationStatement* parameter_declaration = parameter_namedType-&gt;get_declaration();</span></a>
<a name="2350"><span class="lineNum">    2350 </span><span class="lineCov">       2046 :                                                   ROSE_ASSERT(parameter_declaration != NULL);</span></a>
<a name="2351"><span class="lineNum">    2351 </span>            : #if DEBUG_FUNCTION_AMBIGUITY</a>
<a name="2352"><span class="lineNum">    2352 </span>            :                                                   printf (&quot;parameter_declaration = %p = %s \n&quot;,parameter_declaration,parameter_declaration-&gt;class_name().c_str());</a>
<a name="2353"><span class="lineNum">    2353 </span>            : #endif</a>
<a name="2354"><span class="lineNum">    2354 </span><span class="lineCov">       2046 :                                                   SgScopeStatement* parameter_scope = declaration-&gt;get_scope();</span></a>
<a name="2355"><span class="lineNum">    2355 </span><span class="lineCov">       2046 :                                                   ROSE_ASSERT(parameter_scope != NULL);</span></a>
<a name="2356"><span class="lineNum">    2356 </span>            : #if DEBUG_FUNCTION_AMBIGUITY</a>
<a name="2357"><span class="lineNum">    2357 </span>            :                                                // printf (&quot;parameter_scope = %p = %s \n&quot;,parameter_scope,parameter_scope-&gt;class_name().c_str());</a>
<a name="2358"><span class="lineNum">    2358 </span>            :                                                   printf (&quot;parameter_scope = %p = %s name = %s \n&quot;,parameter_scope,parameter_scope-&gt;class_name().c_str(),SageInterface::get_name(parameter_scope).c_str());</a>
<a name="2359"><span class="lineNum">    2359 </span>            : #endif</a>
<a name="2360"><span class="lineNum">    2360 </span>            : </a>
<a name="2361"><span class="lineNum">    2361 </span>            :                                                // Check if this is in the parent scopes.</a>
<a name="2362"><span class="lineNum">    2362 </span><span class="lineCov">       2046 :                                                   bool detectedInParentScope = false;</span></a>
<a name="2363"><span class="lineNum">    2363 </span><span class="lineCov">       2046 :                                                   SgScopeStatement* tmp_scope = currentScope;</span></a>
<a name="2364"><span class="lineNum">    2364 </span>            :                                                // while (tmp_scope != NULL &amp;&amp; tmp_scope != parameter_scope)</a>
<a name="2365"><span class="lineNum">    2365 </span><span class="lineCov">       8098 :                                                   while (tmp_scope != NULL &amp;&amp; isSgGlobal(tmp_scope) == NULL &amp;&amp; tmp_scope != parameter_scope)</span></a>
<a name="2366"><span class="lineNum">    2366 </span>            :                                                      {</a>
<a name="2367"><span class="lineNum">    2367 </span>            : #if DEBUG_FUNCTION_AMBIGUITY</a>
<a name="2368"><span class="lineNum">    2368 </span>            :                                                        printf (&quot;tmp_scope = %p = %s name = %s \n&quot;,tmp_scope,tmp_scope-&gt;class_name().c_str(),SageInterface::get_name(tmp_scope).c_str());</a>
<a name="2369"><span class="lineNum">    2369 </span>            : #endif</a>
<a name="2370"><span class="lineNum">    2370 </span><span class="lineCov">       6052 :                                                        tmp_scope = tmp_scope-&gt;get_scope();</span></a>
<a name="2371"><span class="lineNum">    2371 </span><span class="lineCov">       6052 :                                                        if (tmp_scope != NULL &amp;&amp; tmp_scope == parameter_scope)</span></a>
<a name="2372"><span class="lineNum">    2372 </span>            :                                                           {</a>
<a name="2373"><span class="lineNum">    2373 </span>            : #if DEBUG_FUNCTION_AMBIGUITY</a>
<a name="2374"><span class="lineNum">    2374 </span>            :                                                             printf (&quot;Found parameter_scope in parent scopes \n&quot;);</a>
<a name="2375"><span class="lineNum">    2375 </span>            : #endif</a>
<a name="2376"><span class="lineNum">    2376 </span><span class="lineCov">       1984 :                                                             detectedInParentScope = true;</span></a>
<a name="2377"><span class="lineNum">    2377 </span>            :                                                           }</a>
<a name="2378"><span class="lineNum">    2378 </span>            :                                                      }</a>
<a name="2379"><span class="lineNum">    2379 </span>            : </a>
<a name="2380"><span class="lineNum">    2380 </span><span class="lineCov">       2046 :                                                   ROSE_ASSERT(tmp_scope != NULL);</span></a>
<a name="2381"><span class="lineNum">    2381 </span>            : #if DEBUG_FUNCTION_AMBIGUITY</a>
<a name="2382"><span class="lineNum">    2382 </span>            :                                                   printf (&quot;detectedInParentScope = %s \n&quot;,detectedInParentScope ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="2383"><span class="lineNum">    2383 </span>            :                                                   printf (&quot;After loop: tmp_scope = %p = %s name = %s \n&quot;,tmp_scope,tmp_scope-&gt;class_name().c_str(),SageInterface::get_name(tmp_scope).c_str());</a>
<a name="2384"><span class="lineNum">    2384 </span>            : #endif</a>
<a name="2385"><span class="lineNum">    2385 </span><span class="lineCov">       2046 :                                                   SgGlobal* globalScope = isSgGlobal(tmp_scope);</span></a>
<a name="2386"><span class="lineNum">    2386 </span>            :                                                // if (detectedInParentScope == true)</a>
<a name="2387"><span class="lineNum">    2387 </span><span class="lineCov">       2046 :                                                   if (detectedInParentScope == true &amp;&amp; globalScope == NULL)</span></a>
<a name="2388"><span class="lineNum">    2388 </span>            :                                                      {</a>
<a name="2389"><span class="lineNum">    2389 </span><span class="lineCov">       1984 :                                                        SgSymbol* parameter_symbol = SageInterface::lookupFunctionSymbolInParentScopes(name,functionType,parameter_scope);</span></a>
<a name="2390"><span class="lineNum">    2390 </span><span class="lineCov">       1984 :                                                        if (parameter_symbol != NULL)</span></a>
<a name="2391"><span class="lineNum">    2391 </span>            :                                                           {</a>
<a name="2392"><span class="lineNum">    2392 </span>            : #if DEBUG_FUNCTION_AMBIGUITY</a>
<a name="2393"><span class="lineNum">    2393 </span>            :                                                             printf (&quot;Found an ambiguity: parameter_symbol = %p = %s \n&quot;,parameter_symbol,parameter_symbol-&gt;class_name().c_str());</a>
<a name="2394"><span class="lineNum">    2394 </span>            : #endif</a>
<a name="2395"><span class="lineNum">    2395 </span><span class="lineCov">       1984 :                                                             foundAnOverloadedFunctionWithSameName = true;</span></a>
<a name="2396"><span class="lineNum">    2396 </span><span class="lineCov">       1984 :                                                             foundAnOverloadedFunctionInSameScope  = false;</span></a>
<a name="2397"><span class="lineNum">    2397 </span>            :                                                           }</a>
<a name="2398"><span class="lineNum">    2398 </span>            :                                                      }</a>
<a name="2399"><span class="lineNum">    2399 </span>            :                                                 }</a>
<a name="2400"><span class="lineNum">    2400 </span>            :                                            }</a>
<a name="2401"><span class="lineNum">    2401 </span>            :                                       }</a>
<a name="2402"><span class="lineNum">    2402 </span>            : #else</a>
<a name="2403"><span class="lineNum">    2403 </span>            :                                    printf (&quot;Skipping parameter based function lookup \n&quot;);</a>
<a name="2404"><span class="lineNum">    2404 </span>            : #endif</a>
<a name="2405"><span class="lineNum">    2405 </span>            : #if DEBUG_FUNCTION_AMBIGUITY</a>
<a name="2406"><span class="lineNum">    2406 </span>            :                                    printf (&quot;After loop over function parameter types: foundAnOverloadedFunctionWithSameName = %s \n&quot;,foundAnOverloadedFunctionWithSameName ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="2407"><span class="lineNum">    2407 </span>            :                                    printf (&quot;After loop over function parameter types: foundAnOverloadedFunctionInSameScope = %s \n&quot;,foundAnOverloadedFunctionInSameScope   ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="2408"><span class="lineNum">    2408 </span>            :                                    printf (&quot;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp; \n&quot;);</a>
<a name="2409"><span class="lineNum">    2409 </span>            : #endif</a>
<a name="2410"><span class="lineNum">    2410 </span>            : #if 0</a>
<a name="2411"><span class="lineNum">    2411 </span>            :                                    printf(&quot;Exiting as a test! \n&quot;);</a>
<a name="2412"><span class="lineNum">    2412 </span>            :                                    ROSE_ABORT();</a>
<a name="2413"><span class="lineNum">    2413 </span>            : #endif</a>
<a name="2414"><span class="lineNum">    2414 </span>            :                                  }</a>
<a name="2415"><span class="lineNum">    2415 </span>            : #if 0</a>
<a name="2416"><span class="lineNum">    2416 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="2417"><span class="lineNum">    2417 </span>            :                               ROSE_ABORT();</a>
<a name="2418"><span class="lineNum">    2418 </span>            : #endif</a>
<a name="2419"><span class="lineNum">    2419 </span>            :                             }</a>
<a name="2420"><span class="lineNum">    2420 </span>            : #if 0</a>
<a name="2421"><span class="lineNum">    2421 </span>            :                       // DQ (6/1/2011): Added support for template arguments.</a>
<a name="2422"><span class="lineNum">    2422 </span>            :                          SgTemplateInstantiationMemberFunctionDecl* templateInstantiationMemberFunctionDeclaration = isSgTemplateInstantiationMemberFunctionDecl(declaration);</a>
<a name="2423"><span class="lineNum">    2423 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;$$$$$$$$$ --- templateInstantiationMemberFunctionDeclaration = %p \n&quot;,templateInstantiationMemberFunctionDeclaration);</a>
<a name="2424"><span class="lineNum">    2424 </span>            :                          if (templateInstantiationMemberFunctionDeclaration != NULL)</a>
<a name="2425"><span class="lineNum">    2425 </span>            :                             {</a>
<a name="2426"><span class="lineNum">    2426 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="2427"><span class="lineNum">    2427 </span>            :                            // Evaluate all template arguments.</a>
<a name="2428"><span class="lineNum">    2428 </span>            :                               evaluateNameQualificationForTemplateArgumentList (templateInstantiationMemberFunctionDeclaration-&gt;get_templateArguments(),currentScope,positionStatement);</a>
<a name="2429"><span class="lineNum">    2429 </span>            :                             }</a>
<a name="2430"><span class="lineNum">    2430 </span>            : #endif</a>
<a name="2431"><span class="lineNum">    2431 </span>            :                       // numberOfSymbols = currentScope-&gt;count_symbol(name);</a>
<a name="2432"><span class="lineNum">    2432 </span>            :                          break;</a>
<a name="2433"><span class="lineNum">    2433 </span>            :                        }</a>
<a name="2434"><span class="lineNum">    2434 </span>            : </a>
<a name="2435"><span class="lineNum">    2435 </span>            : #if 0</a>
<a name="2436"><span class="lineNum">    2436 </span>            :                     case V_SgMemberFunctionDeclaration:</a>
<a name="2437"><span class="lineNum">    2437 </span>            :                        {</a>
<a name="2438"><span class="lineNum">    2438 </span>            :                          SgMemberFunctionDeclaration* functionDeclaration = isSgMemberFunctionDeclaration(declaration);</a>
<a name="2439"><span class="lineNum">    2439 </span>            :                          ASSERT_not_null(functionDeclaration);</a>
<a name="2440"><span class="lineNum">    2440 </span>            : </a>
<a name="2441"><span class="lineNum">    2441 </span>            :                          SgMemberFunctionSymbol* functionSymbol = isSgFunctionSymbol(symbol);</a>
<a name="2442"><span class="lineNum">    2442 </span>            :                       // ASSERT_not_null(classSymbol);</a>
<a name="2443"><span class="lineNum">    2443 </span>            :                          if (functionSymbol == NULL)</a>
<a name="2444"><span class="lineNum">    2444 </span>            :                             {</a>
<a name="2445"><span class="lineNum">    2445 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;Type elaboration is required: declaration = %s symbol = %s \n&quot;,declaration-&gt;class_name().c_str(),symbol-&gt;class_name().c_str());</a>
<a name="2446"><span class="lineNum">    2446 </span>            :                               typeElaborationIsRequired = true;</a>
<a name="2447"><span class="lineNum">    2447 </span>            : </a>
<a name="2448"><span class="lineNum">    2448 </span>            :                            // Reset the symbol to one that will match the declaration (this uses the same interface as for .</a>
<a name="2449"><span class="lineNum">    2449 </span>            :                               symbol = SageInterface::lookupFunctionSymbolInParentScopes(name,currentScope);</a>
<a name="2450"><span class="lineNum">    2450 </span>            :                               ASSERT_not_null(symbol);</a>
<a name="2451"><span class="lineNum">    2451 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;Lookup symbol based symbol type: reset symbol = %p = %s \n&quot;,symbol,symbol-&gt;class_name().c_str());</a>
<a name="2452"><span class="lineNum">    2452 </span>            :                             }</a>
<a name="2453"><span class="lineNum">    2453 </span>            : </a>
<a name="2454"><span class="lineNum">    2454 </span>            :                          break;</a>
<a name="2455"><span class="lineNum">    2455 </span>            :                        }</a>
<a name="2456"><span class="lineNum">    2456 </span>            : #endif</a>
<a name="2457"><span class="lineNum">    2457 </span>            : </a>
<a name="2458"><span class="lineNum">    2458 </span>            : </a>
<a name="2459"><span class="lineNum">    2459 </span>            :                  // DQ (11/10/2014): Added support for templated typedefs (and their instantiations).</a>
<a name="2460"><span class="lineNum">    2460 </span><span class="lineCov">    1371850 :                     case V_SgTemplateTypedefDeclaration:</span></a>
<a name="2461"><span class="lineNum">    2461 </span><span class="lineCov">    1371850 :                     case V_SgTemplateInstantiationTypedefDeclaration:</span></a>
<a name="2462"><span class="lineNum">    2462 </span>            : </a>
<a name="2463"><span class="lineNum">    2463 </span><span class="lineCov">    1371850 :                     case V_SgTypedefDeclaration:</span></a>
<a name="2464"><span class="lineNum">    2464 </span><span class="lineCov">    1371850 :                        {</span></a>
<a name="2465"><span class="lineNum">    2465 </span><span class="lineCov">    1371850 :                          SgTypedefDeclaration* typedefDeclaration = isSgTypedefDeclaration(declaration);</span></a>
<a name="2466"><span class="lineNum">    2466 </span><span class="lineCov">    1371850 :                          ASSERT_not_null(typedefDeclaration);</span></a>
<a name="2467"><span class="lineNum">    2467 </span>            : </a>
<a name="2468"><span class="lineNum">    2468 </span>            :                       // DQ (7/22/2017): Added test for SgTemplateInstantiationDirectiveStatement, so that we can process the</a>
<a name="2469"><span class="lineNum">    2469 </span>            :                       // template arguments correctly (using the scope of the SgTemplateInstantiationDirectiveStatement instead</a>
<a name="2470"><span class="lineNum">    2470 </span>            :                       // of the scope of the SgTemplateInstantiationTypedefDeclaration (which can be different)).</a>
<a name="2471"><span class="lineNum">    2471 </span>            :                       // DQ (6/3/2017): Add test to check if this is part of a template instantiation directive.</a>
<a name="2472"><span class="lineNum">    2472 </span>            :                       // However, I think that out use of name qualification is independent of this result.</a>
<a name="2473"><span class="lineNum">    2473 </span><span class="lineCov">    1371850 :                          SgTemplateInstantiationDirectiveStatement* templateInstantiationDirectiveStatement = isSgTemplateInstantiationDirectiveStatement(typedefDeclaration-&gt;get_parent());</span></a>
<a name="2474"><span class="lineNum">    2474 </span><span class="lineCov">    1371850 :                          if (templateInstantiationDirectiveStatement != NULL)</span></a>
<a name="2475"><span class="lineNum">    2475 </span>            :                             {</a>
<a name="2476"><span class="lineNum">    2476 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="2477"><span class="lineNum">    2477 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;******** Found a typedef template instantiation that is a part of a SgTemplateInstantiationDirectiveStatement \n&quot;);</a>
<a name="2478"><span class="lineNum">    2478 </span>            : #endif</a>
<a name="2479"><span class="lineNum">    2479 </span>            : #if 1</a>
<a name="2480"><span class="lineNum">    2480 </span><span class="lineNoCov">          0 :                               mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</span></a>
<a name="2481"><span class="lineNum">    2481 </span><span class="lineNoCov">          0 :                               ROSE_ABORT();</span></a>
<a name="2482"><span class="lineNum">    2482 </span>            : #endif</a>
<a name="2483"><span class="lineNum">    2483 </span>            :                             }</a>
<a name="2484"><span class="lineNum">    2484 </span>            : </a>
<a name="2485"><span class="lineNum">    2485 </span><span class="lineCov">    1371850 :                          SgTypedefSymbol* typedefSymbol = isSgTypedefSymbol(symbol);</span></a>
<a name="2486"><span class="lineNum">    2486 </span><span class="lineCov">    1371850 :                          if (typedefSymbol == NULL)</span></a>
<a name="2487"><span class="lineNum">    2487 </span>            :                             {</a>
<a name="2488"><span class="lineNum">    2488 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="2489"><span class="lineNum">    2489 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;Type elaboration is required: declaration = %s symbol = %s \n&quot;,declaration-&gt;class_name().c_str(),symbol-&gt;class_name().c_str());</a>
<a name="2490"><span class="lineNum">    2490 </span>            : #endif</a>
<a name="2491"><span class="lineNum">    2491 </span><span class="lineCov">        652 :                               typeElaborationIsRequired = true;</span></a>
<a name="2492"><span class="lineNum">    2492 </span>            : </a>
<a name="2493"><span class="lineNum">    2493 </span>            :                            // mfprintf(mlog [ WARN ] ) (&quot;WARNING: Present implementation of symbol table will not find alias symbols of SgTypedefSymbol \n&quot;);</a>
<a name="2494"><span class="lineNum">    2494 </span>            : </a>
<a name="2495"><span class="lineNum">    2495 </span>            :                            // Reset the symbol to one that will match the declaration.</a>
<a name="2496"><span class="lineNum">    2496 </span><span class="lineCov">        652 :                               symbol = SageInterface::lookupTypedefSymbolInParentScopes(name,currentScope);</span></a>
<a name="2497"><span class="lineNum">    2497 </span>            : #if 0</a>
<a name="2498"><span class="lineNum">    2498 </span>            :                               if (symbol != NULL)</a>
<a name="2499"><span class="lineNum">    2499 </span>            :                                  {</a>
<a name="2500"><span class="lineNum">    2500 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;Lookup symbol based symbol type: reset symbol = %p = %s \n&quot;,symbol,symbol-&gt;class_name().c_str());</a>
<a name="2501"><span class="lineNum">    2501 </span>            :                                  }</a>
<a name="2502"><span class="lineNum">    2502 </span>            :                                 else</a>
<a name="2503"><span class="lineNum">    2503 </span>            :                                  {</a>
<a name="2504"><span class="lineNum">    2504 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::nameQualificationDepth(): typedefSymbol == NULL \n&quot;);</a>
<a name="2505"><span class="lineNum">    2505 </span>            :                                  }</a>
<a name="2506"><span class="lineNum">    2506 </span>            : #else</a>
<a name="2507"><span class="lineNum">    2507 </span>            :                            // DQ (5/15/2011): Added this to support where symbol after moving name qualification</a>
<a name="2508"><span class="lineNum">    2508 </span>            :                            // support to the astPostProcessing phase instead of calling it in the unparser.</a>
<a name="2509"><span class="lineNum">    2509 </span>            :                               if (symbol != NULL)</a>
<a name="2510"><span class="lineNum">    2510 </span>            :                                  {</a>
<a name="2511"><span class="lineNum">    2511 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="2512"><span class="lineNum">    2512 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;Lookup symbol based symbol type: reset symbol = %p = %s \n&quot;,symbol,symbol-&gt;class_name().c_str());</a>
<a name="2513"><span class="lineNum">    2513 </span>            : #endif</a>
<a name="2514"><span class="lineNum">    2514 </span>            :                                  }</a>
<a name="2515"><span class="lineNum">    2515 </span>            :                                 else</a>
<a name="2516"><span class="lineNum">    2516 </span>            :                                  {</a>
<a name="2517"><span class="lineNum">    2517 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="2518"><span class="lineNum">    2518 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::nameQualificationDepth(): typedefSymbol == NULL \n&quot;);</a>
<a name="2519"><span class="lineNum">    2519 </span>            : #endif</a>
<a name="2520"><span class="lineNum">    2520 </span>            :                                 // DQ (7/24/2011): I don't understand this code...this appears to be a cut/paste error.</a>
<a name="2521"><span class="lineNum">    2521 </span>            :                                 // Look for a template symbol</a>
<a name="2522"><span class="lineNum">    2522 </span>            :                                 // symbol = SageInterface::lookupTemplateSymbolInParentScopes(name,currentScope);</a>
<a name="2523"><span class="lineNum">    2523 </span>            :                                 // ASSERT_not_null(symbol);</a>
<a name="2524"><span class="lineNum">    2524 </span>            :                                  }</a>
<a name="2525"><span class="lineNum">    2525 </span>            : #endif</a>
<a name="2526"><span class="lineNum">    2526 </span>            :                             }</a>
<a name="2527"><span class="lineNum">    2527 </span>            : #if 0</a>
<a name="2528"><span class="lineNum">    2528 </span>            :                       // DQ (4/14/2018): I think that this code might not be required here, noting to do at this location.</a>
<a name="2529"><span class="lineNum">    2529 </span>            :                          SgTemplateInstantiationTypedefDeclaration* templateInstantiationTypedefDeclaration = isSgTemplateInstantiationTypedefDeclaration(typedefDeclaration);</a>
<a name="2530"><span class="lineNum">    2530 </span>            :                          if (templateInstantiationTypedefDeclaration != NULL)</a>
<a name="2531"><span class="lineNum">    2531 </span>            :                             {</a>
<a name="2532"><span class="lineNum">    2532 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;$$$$$$$$$$$$$$$$$$ Processing a SgTemplateInstantiationTypedefDeclaration $$$$$$$$$$$$$$$$$$$$$ \n&quot;);</a>
<a name="2533"><span class="lineNum">    2533 </span>            :                            // Found a SgTemplateInstantiationTypedefDeclaration, we need to at least check the template arguments for name qualification.</a>
<a name="2534"><span class="lineNum">    2534 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;Found a SgTemplateInstantiationTypedefDeclaration, we need to at least check the template arguments for name qualification \n&quot;);</a>
<a name="2535"><span class="lineNum">    2535 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;$$$$$$$$$$$$$$$$$$ DONE: Processing a SgTemplateInstantiationTypedefDeclaration $$$$$$$$$$$$$$$$$$$$$ \n&quot;);</a>
<a name="2536"><span class="lineNum">    2536 </span>            : #if 0</a>
<a name="2537"><span class="lineNum">    2537 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="2538"><span class="lineNum">    2538 </span>            :                               ROSE_ABORT();</a>
<a name="2539"><span class="lineNum">    2539 </span>            : #endif</a>
<a name="2540"><span class="lineNum">    2540 </span>            :                             }</a>
<a name="2541"><span class="lineNum">    2541 </span>            : #endif</a>
<a name="2542"><span class="lineNum">    2542 </span>            :                          break;</a>
<a name="2543"><span class="lineNum">    2543 </span>            :                        }</a>
<a name="2544"><span class="lineNum">    2544 </span>            : </a>
<a name="2545"><span class="lineNum">    2545 </span>            : </a>
<a name="2546"><span class="lineNum">    2546 </span>            :                  // DQ (8/13/2013): I think that this case should not appear, since SgTemplateDeclaration is a part of pre-EDG4x work.</a>
<a name="2547"><span class="lineNum">    2547 </span><span class="lineNoCov">          0 :                     case V_SgTemplateDeclaration:</span></a>
<a name="2548"><span class="lineNum">    2548 </span><span class="lineNoCov">          0 :                        {</span></a>
<a name="2549"><span class="lineNum">    2549 </span><span class="lineNoCov">          0 :                          SgTemplateDeclaration* templateDeclaration = isSgTemplateDeclaration(declaration);</span></a>
<a name="2550"><span class="lineNum">    2550 </span><span class="lineNoCov">          0 :                          ASSERT_not_null(templateDeclaration);</span></a>
<a name="2551"><span class="lineNum">    2551 </span>            :                       // DQ (7/24/2018): This is output spew for Cxx11_tests/test2016_90.C and Cxx_tests/test2013_63.C (and others).</a>
<a name="2552"><span class="lineNum">    2552 </span>            :                       // It is not new, but it is also not clear that it is too much of an issue that we have some used of SgTemplateDeclaration</a>
<a name="2553"><span class="lineNum">    2553 </span>            :                       // in place since within templates we can at times not have enough information to build anything more specific.</a>
<a name="2554"><span class="lineNum">    2554 </span>            :                       // All of these issues appear to be related to input codes using boost: e.g. boost/graph/topological_sort.hpp.</a>
<a name="2555"><span class="lineNum">    2555 </span>            : #if 0</a>
<a name="2556"><span class="lineNum">    2556 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::nameQualificationDepth(): case V_SgTemplateDeclaration: still emitted for template template parameter (seen in template template argument of `this`)\n&quot;);</a>
<a name="2557"><span class="lineNum">    2557 </span>            : #endif</a>
<a name="2558"><span class="lineNum">    2558 </span>            : #if 0</a>
<a name="2559"><span class="lineNum">    2559 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="2560"><span class="lineNum">    2560 </span>            :                          ROSE_ABORT();</a>
<a name="2561"><span class="lineNum">    2561 </span>            : #endif</a>
<a name="2562"><span class="lineNum">    2562 </span><span class="lineNoCov">          0 :                          symbol = NULL;</span></a>
<a name="2563"><span class="lineNum">    2563 </span>            : </a>
<a name="2564"><span class="lineNum">    2564 </span><span class="lineNoCov">          0 :                          break;</span></a>
<a name="2565"><span class="lineNum">    2565 </span>            :                        }</a>
<a name="2566"><span class="lineNum">    2566 </span>            : </a>
<a name="2567"><span class="lineNum">    2567 </span>            :                  // DQ (11/16/2013): I think we do need this case and test2013_273.C demonstrates this.</a>
<a name="2568"><span class="lineNum">    2568 </span>            :                  // DQ (6/1/2011): Not clear if we need a special case for the case of SgTemplateInstantiationMemberFunctionDecl.</a>
<a name="2569"><span class="lineNum">    2569 </span>            :                  // I think we need to call: evaluateNameQualificationForTemplateArgumentList()</a>
<a name="2570"><span class="lineNum">    2570 </span>            :                  // to evaluate template arguments for both SgTemplateInstantiationFunctionDecl and SgTemplateInstantiationMemberFunctionDecl.</a>
<a name="2571"><span class="lineNum">    2571 </span><span class="lineCov">       1410 :                     case V_SgTemplateInstantiationFunctionDecl:</span></a>
<a name="2572"><span class="lineNum">    2572 </span><span class="lineCov">       1410 :                        {</span></a>
<a name="2573"><span class="lineNum">    2573 </span>            :                       // DQ (6/4/2017): Added notes on the additional complexity of name qualification for template instantiations.</a>
<a name="2574"><span class="lineNum">    2574 </span>            :                       // Note that there are several things that can cause name qualification for a template instantiation:</a>
<a name="2575"><span class="lineNum">    2575 </span>            :                       //    1) A different template instantiation that is visible from the same scope (current scope),</a>
<a name="2576"><span class="lineNum">    2576 </span>            :                       //       this would be the typical case most similar to other constructs.</a>
<a name="2577"><span class="lineNum">    2577 </span>            :                       //    2) A template declaration that is visible from the same scope (current scope) using the same</a>
<a name="2578"><span class="lineNum">    2578 </span>            :                       //       name as the template declaration associated with the template instantiation.</a>
<a name="2579"><span class="lineNum">    2579 </span>            :                       //    3) A non-template function declaration (member of non-member) that is visible from the same</a>
<a name="2580"><span class="lineNum">    2580 </span>            :                       //       scope (current scope) using the same name. See test2017_40.C.</a>
<a name="2581"><span class="lineNum">    2581 </span>            :                       // Note also that when the current scope is a namespace, that lookups have to be normalized in terms</a>
<a name="2582"><span class="lineNum">    2582 </span>            :                       // of the global namespace (unique namespace definition used to union all declaration across all</a>
<a name="2583"><span class="lineNum">    2583 </span>            :                       // namespaces that are equivalent (becuase namespaces are reentrent).</a>
<a name="2584"><span class="lineNum">    2584 </span>            : </a>
<a name="2585"><span class="lineNum">    2585 </span><span class="lineCov">       1410 :                          SgTemplateInstantiationFunctionDecl* templateInstantiationFunction = isSgTemplateInstantiationFunctionDecl(declaration);</span></a>
<a name="2586"><span class="lineNum">    2586 </span><span class="lineCov">       1410 :                          ASSERT_not_null(templateInstantiationFunction);</span></a>
<a name="2587"><span class="lineNum">    2587 </span>            : </a>
<a name="2588"><span class="lineNum">    2588 </span>            :                       // DQ (6/3/2017): Add test to check if this is part of a template instantiation directive.</a>
<a name="2589"><span class="lineNum">    2589 </span>            :                       // However, I think that out use of name qualification is independent of this result.</a>
<a name="2590"><span class="lineNum">    2590 </span><span class="lineCov">       1410 :                          SgTemplateInstantiationDirectiveStatement* templateInstantiationDirectiveStatement = isSgTemplateInstantiationDirectiveStatement(templateInstantiationFunction-&gt;get_parent());</span></a>
<a name="2591"><span class="lineNum">    2591 </span><span class="lineCov">       1410 :                          if (templateInstantiationDirectiveStatement != NULL)</span></a>
<a name="2592"><span class="lineNum">    2592 </span>            :                             {</a>
<a name="2593"><span class="lineNum">    2593 </span>            : #if 0</a>
<a name="2594"><span class="lineNum">    2594 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;******** Found a function template instantiation that is a part of a SgTemplateInstantiationDirectiveStatement \n&quot;);</a>
<a name="2595"><span class="lineNum">    2595 </span>            : #endif</a>
<a name="2596"><span class="lineNum">    2596 </span>            :                            // DQ (11/18/2017): Commented out the trap to force an exit here!</a>
<a name="2597"><span class="lineNum">    2597 </span>            : #if 0</a>
<a name="2598"><span class="lineNum">    2598 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="2599"><span class="lineNum">    2599 </span>            :                               ROSE_ABORT();</a>
<a name="2600"><span class="lineNum">    2600 </span>            : #endif</a>
<a name="2601"><span class="lineNum">    2601 </span>            :                             }</a>
<a name="2602"><span class="lineNum">    2602 </span>            : </a>
<a name="2603"><span class="lineNum">    2603 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="2604"><span class="lineNum">    2604 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::nameQualificationDepth(): case V_SgTemplateInstantiationFunctionDecl: templateInstantiationFunction = %p = %s \n&quot;,</a>
<a name="2605"><span class="lineNum">    2605 </span>            :                               templateInstantiationFunction,templateInstantiationFunction-&gt;class_name().c_str());</a>
<a name="2606"><span class="lineNum">    2606 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;   --- templateInstantiationFunction-&gt;get_name()         = %s \n&quot;,templateInstantiationFunction-&gt;get_name().str());</a>
<a name="2607"><span class="lineNum">    2607 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;   --- templateInstantiationFunction-&gt;get_templateName() = %s \n&quot;,templateInstantiationFunction-&gt;get_templateName().str());</a>
<a name="2608"><span class="lineNum">    2608 </span>            : #endif</a>
<a name="2609"><span class="lineNum">    2609 </span>            : #if 0</a>
<a name="2610"><span class="lineNum">    2610 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="2611"><span class="lineNum">    2611 </span>            :                          ROSE_ABORT();</a>
<a name="2612"><span class="lineNum">    2612 </span>            : #endif</a>
<a name="2613"><span class="lineNum">    2613 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="2614"><span class="lineNum">    2614 </span>            :                       // If this is a SgNamespaceDefinition, then we need to reset it to the uniquly represented namespace definition.</a>
<a name="2615"><span class="lineNum">    2615 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;currentScope = %p = %s \n&quot;,currentScope,currentScope-&gt;class_name().c_str());</a>
<a name="2616"><span class="lineNum">    2616 </span>            : #endif</a>
<a name="2617"><span class="lineNum">    2617 </span>            :                       // DQ (6/3/2017): Adding code to normalize the scope where it is a namespace definition, since that can be more</a>
<a name="2618"><span class="lineNum">    2618 </span>            :                       // than one that are the same namespace and we have a mechanism to resolve equivalents for this special case.</a>
<a name="2619"><span class="lineNum">    2619 </span>            :                       // BTW, I worry that this should be done more generally and uniformally within the name qualification support.</a>
<a name="2620"><span class="lineNum">    2620 </span><span class="lineCov">       1410 :                          SgNamespaceDefinitionStatement* namespaceDefinitionStatement = isSgNamespaceDefinitionStatement(currentScope);</span></a>
<a name="2621"><span class="lineNum">    2621 </span><span class="lineCov">       1410 :                          if (namespaceDefinitionStatement != NULL)</span></a>
<a name="2622"><span class="lineNum">    2622 </span>            :                             {</a>
<a name="2623"><span class="lineNum">    2623 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="2624"><span class="lineNum">    2624 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;Reset the currentScope to the namespace's global definition (namespace normalization) \n&quot;);</a>
<a name="2625"><span class="lineNum">    2625 </span>            : #endif</a>
<a name="2626"><span class="lineNum">    2626 </span><span class="lineCov">        818 :                               currentScope = namespaceDefinitionStatement-&gt;get_global_definition();</span></a>
<a name="2627"><span class="lineNum">    2627 </span><span class="lineCov">        818 :                               ASSERT_not_null(currentScope);</span></a>
<a name="2628"><span class="lineNum">    2628 </span>            : </a>
<a name="2629"><span class="lineNum">    2629 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="2630"><span class="lineNum">    2630 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;calling lookupFunctionSymbolInParentScopes(): name = %s currentScope = %p = %s \n&quot;,name.str(),currentScope,currentScope-&gt;class_name().c_str());</a>
<a name="2631"><span class="lineNum">    2631 </span>            : #endif</a>
<a name="2632"><span class="lineNum">    2632 </span>            :                            // Reset the symbol to be consistant with the unique scope (in case the currentScope was reset above.</a>
<a name="2633"><span class="lineNum">    2633 </span><span class="lineCov">        818 :                               symbol = SageInterface::lookupFunctionSymbolInParentScopes(name,currentScope);</span></a>
<a name="2634"><span class="lineNum">    2634 </span><span class="lineCov">        818 :                               ASSERT_not_null(symbol);</span></a>
<a name="2635"><span class="lineNum">    2635 </span>            : </a>
<a name="2636"><span class="lineNum">    2636 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="2637"><span class="lineNum">    2637 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;@@@@@@@@ name = %s declaration = %p = %s symbol = %s \n&quot;,name.str(),declaration,declaration-&gt;class_name().c_str(),symbol-&gt;class_name().c_str());</a>
<a name="2638"><span class="lineNum">    2638 </span>            : #endif</a>
<a name="2639"><span class="lineNum">    2639 </span>            : #if 0</a>
<a name="2640"><span class="lineNum">    2640 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! (current scope is a SgNamespaceDefinitionStatement) \n&quot;);</a>
<a name="2641"><span class="lineNum">    2641 </span>            :                               ROSE_ABORT();</a>
<a name="2642"><span class="lineNum">    2642 </span>            : #endif</a>
<a name="2643"><span class="lineNum">    2643 </span>            :                             }</a>
<a name="2644"><span class="lineNum">    2644 </span>            : </a>
<a name="2645"><span class="lineNum">    2645 </span><span class="lineCov">       1410 :                          SgTemplateSymbol* templateSymbol = isSgTemplateSymbol(symbol);</span></a>
<a name="2646"><span class="lineNum">    2646 </span>            : </a>
<a name="2647"><span class="lineNum">    2647 </span>            :                       // DQ (5/21/2017): I think this is never a SgTemplateSymbol (checking).</a>
<a name="2648"><span class="lineNum">    2648 </span>            :                       // DQ (6/4/2017): Maybe if it was a template specialization that was forcing the name qualification</a>
<a name="2649"><span class="lineNum">    2649 </span>            :                       // (then the names might match, we would need to have a test code example of this).</a>
<a name="2650"><span class="lineNum">    2650 </span><span class="lineCov">       1410 :                          ROSE_ASSERT(templateSymbol == NULL);</span></a>
<a name="2651"><span class="lineNum">    2651 </span>            : </a>
<a name="2652"><span class="lineNum">    2652 </span><span class="lineCov">       1410 :                          if (templateSymbol == NULL)</span></a>
<a name="2653"><span class="lineNum">    2653 </span>            :                             {</a>
<a name="2654"><span class="lineNum">    2654 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="2655"><span class="lineNum">    2655 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;Type elaboration is required: declaration = %s symbol = %s \n&quot;,declaration-&gt;class_name().c_str(),symbol-&gt;class_name().c_str());</a>
<a name="2656"><span class="lineNum">    2656 </span>            : #endif</a>
<a name="2657"><span class="lineNum">    2657 </span>            :                            // The existance of any symbol identified to hide the current statement is cause for at least type elaboration.</a>
<a name="2658"><span class="lineNum">    2658 </span><span class="lineCov">       1410 :                               typeElaborationIsRequired = true;</span></a>
<a name="2659"><span class="lineNum">    2659 </span>            : </a>
<a name="2660"><span class="lineNum">    2660 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="2661"><span class="lineNum">    2661 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;calling lookupFunctionSymbolInParentScopes(): name = %s currentScope = %p = %s \n&quot;,name.str(),currentScope,currentScope-&gt;class_name().c_str());</a>
<a name="2662"><span class="lineNum">    2662 </span>            : #endif</a>
<a name="2663"><span class="lineNum">    2663 </span>            :                            // Reset the symbol to one that will match the declaration.</a>
<a name="2664"><span class="lineNum">    2664 </span>            :                            // DQ (4/12/2014): I think we need to use the function type here!</a>
<a name="2665"><span class="lineNum">    2665 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt;= 1) || 0</a>
<a name="2666"><span class="lineNum">    2666 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;Should we be using the function type in the initial SgTemplateInstantiationFunctionDecl symbol lookup? \n&quot;);</a>
<a name="2667"><span class="lineNum">    2667 </span>            : #endif</a>
<a name="2668"><span class="lineNum">    2668 </span>            :                            // Reset the symbol to be consistatn with the unique scope (in case the currentScope was reset above.</a>
<a name="2669"><span class="lineNum">    2669 </span>            :                            // symbol = SageInterface::lookupFunctionSymbolInParentScopes(name,currentScope);</a>
<a name="2670"><span class="lineNum">    2670 </span>            : </a>
<a name="2671"><span class="lineNum">    2671 </span>            :                            // DQ (6/23/2013): Fixing test2013_223.C (function hiding template function instantiation).</a>
<a name="2672"><span class="lineNum">    2672 </span><span class="lineCov">       2820 :                               SgName templateInstantiationFunctionNameWithoutTemplateArguments = templateInstantiationFunction-&gt;get_templateName();</span></a>
<a name="2673"><span class="lineNum">    2673 </span>            : </a>
<a name="2674"><span class="lineNum">    2674 </span>            :                            // DQ (5/21/2017): Get the name with template arguments (I think we need it instead).</a>
<a name="2675"><span class="lineNum">    2675 </span><span class="lineCov">       1410 :                               SgName templateInstantiationFunctionName = templateInstantiationFunction-&gt;get_name();</span></a>
<a name="2676"><span class="lineNum">    2676 </span>            : </a>
<a name="2677"><span class="lineNum">    2677 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="2678"><span class="lineNum">    2678 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;   --- templateInstantiationFunctionNameWithoutTemplateArguments = %s \n&quot;,templateInstantiationFunctionNameWithoutTemplateArguments.str());</a>
<a name="2679"><span class="lineNum">    2679 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;   --- templateInstantiationFunctionName                         = %s \n&quot;,templateInstantiationFunctionName.str());</a>
<a name="2680"><span class="lineNum">    2680 </span>            : #endif</a>
<a name="2681"><span class="lineNum">    2681 </span>            : </a>
<a name="2682"><span class="lineNum">    2682 </span>            :                            // DQ (4/6/2018): I think we should be using the function type in the lookupFunctionSymbolInParentScopes(),</a>
<a name="2683"><span class="lineNum">    2683 </span>            :                            // else we could be confusing overloaded function which would not require name qualification.</a>
<a name="2684"><span class="lineNum">    2684 </span>            :                            // mfprintf(mlog [ WARN ] ) (&quot;Shouldn't we be using the function type to refine the symbol table lookup? \n&quot;);</a>
<a name="2685"><span class="lineNum">    2685 </span>            : </a>
<a name="2686"><span class="lineNum">    2686 </span>            :                            // DQ (5/22/2017): Modified to use the name with the template arguments.</a>
<a name="2687"><span class="lineNum">    2687 </span>            :                            // DQ (4/4/2014): Modified this to use the SgFunctionSymbol type.</a>
<a name="2688"><span class="lineNum">    2688 </span>            :                            // SgSymbol* symbolHiddingTemplateSymbol = SageInterface::lookupFunctionSymbolInParentScopes(templateFunctionNameWithoutTemplateArguments,currentScope);</a>
<a name="2689"><span class="lineNum">    2689 </span>            :                            // SgFunctionSymbol* symbolHiddingTemplateInstantiationSymbol = SageInterface::lookupFunctionSymbolInParentScopes(templateInstantiationFunctionNameWithoutTemplateArguments,currentScope);</a>
<a name="2690"><span class="lineNum">    2690 </span>            : </a>
<a name="2691"><span class="lineNum">    2691 </span>            :                            // DQ (4/7/2018): Adding the function type to make this more precise (and avoid different overloaded functions).</a>
<a name="2692"><span class="lineNum">    2692 </span>            :                            // SgFunctionSymbol* symbolHiddingTemplateInstantiationSymbol = SageInterface::lookupFunctionSymbolInParentScopes(templateInstantiationFunctionName,currentScope);</a>
<a name="2693"><span class="lineNum">    2693 </span><span class="lineCov">       1410 :                               SgFunctionType* functionType = templateInstantiationFunction-&gt;get_type();</span></a>
<a name="2694"><span class="lineNum">    2694 </span><span class="lineCov">       1410 :                               ASSERT_not_null(functionType);</span></a>
<a name="2695"><span class="lineNum">    2695 </span><span class="lineCov">       1410 :                               SgFunctionSymbol* symbolHiddingTemplateInstantiationSymbol = SageInterface::lookupFunctionSymbolInParentScopes(templateInstantiationFunctionName,functionType,currentScope);</span></a>
<a name="2696"><span class="lineNum">    2696 </span>            : </a>
<a name="2697"><span class="lineNum">    2697 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="2698"><span class="lineNum">    2698 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;symbolHiddingTemplateInstantiationSymbol = %p \n&quot;,symbolHiddingTemplateInstantiationSymbol);</a>
<a name="2699"><span class="lineNum">    2699 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;symbol                                   = %p \n&quot;,symbol);</a>
<a name="2700"><span class="lineNum">    2700 </span>            : #endif</a>
<a name="2701"><span class="lineNum">    2701 </span>            :                            // Handle the case of a template instantiation hidding the template instantiation for which we want to determine</a>
<a name="2702"><span class="lineNum">    2702 </span>            :                            // name qualification.  See test2017_39.C</a>
<a name="2703"><span class="lineNum">    2703 </span><span class="lineCov">       1410 :                               if (symbolHiddingTemplateInstantiationSymbol != NULL &amp;&amp; symbolHiddingTemplateInstantiationSymbol != symbol)</span></a>
<a name="2704"><span class="lineNum">    2704 </span>            :                                  {</a>
<a name="2705"><span class="lineNum">    2705 </span>            :                                 // There is reason to think this template instantiation should have some name qualification.</a>
<a name="2706"><span class="lineNum">    2706 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || 0</a>
<a name="2707"><span class="lineNum">    2707 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;WARNING: There is reason to think this template instantiation should have some name qualification because it may be hidden by another template instantiation \n&quot;);</a>
<a name="2708"><span class="lineNum">    2708 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;   --- templateInstantiationFunctionName = %s \n&quot;,templateInstantiationFunctionName.str());</a>
<a name="2709"><span class="lineNum">    2709 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;   --- templateInstantiationFunction mangled name = %s \n&quot;,templateInstantiationFunction-&gt;get_mangled_name().str());</a>
<a name="2710"><span class="lineNum">    2710 </span>            :                                    SgFunctionDeclaration* functionHiddingInputFunction =  symbolHiddingTemplateInstantiationSymbol-&gt;get_declaration();</a>
<a name="2711"><span class="lineNum">    2711 </span>            :                                    ASSERT_not_null(functionHiddingInputFunction);</a>
<a name="2712"><span class="lineNum">    2712 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;   --- functionHiddingInputFunction = %s \n&quot;,functionHiddingInputFunction-&gt;get_name().str());</a>
<a name="2713"><span class="lineNum">    2713 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;   --- functionHiddingInputFunction mangled name = %s \n&quot;,functionHiddingInputFunction-&gt;get_mangled_name().str());</a>
<a name="2714"><span class="lineNum">    2714 </span>            : #endif</a>
<a name="2715"><span class="lineNum">    2715 </span>            : #if 0</a>
<a name="2716"><span class="lineNum">    2716 </span>            :                                 // DQ (6/3/2017): Commented out to explore behavior.</a>
<a name="2717"><span class="lineNum">    2717 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;There is reason to think this template instantiation should have some name qualification \n&quot;);</a>
<a name="2718"><span class="lineNum">    2718 </span>            :                                    ROSE_ABORT();</a>
<a name="2719"><span class="lineNum">    2719 </span>            : #endif</a>
<a name="2720"><span class="lineNum">    2720 </span>            :                                  }</a>
<a name="2721"><span class="lineNum">    2721 </span>            :                                 else</a>
<a name="2722"><span class="lineNum">    2722 </span>            :                                  {</a>
<a name="2723"><span class="lineNum">    2723 </span>            :                                 // There is no template instantiation hidding the template instantiation for which we are computing the name qualification.</a>
<a name="2724"><span class="lineNum">    2724 </span>            :                                  }</a>
<a name="2725"><span class="lineNum">    2725 </span>            : </a>
<a name="2726"><span class="lineNum">    2726 </span>            :                            // Now we need to check for a non-template instantiation function hidding the template instantiation.</a>
<a name="2727"><span class="lineNum">    2727 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="2728"><span class="lineNum">    2728 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;Look for symbols from name without template arguments: name = %s template declaration = %s symbol = %s \n&quot;,</a>
<a name="2729"><span class="lineNum">    2729 </span>            :                                    templateInstantiationFunctionNameWithoutTemplateArguments.str(),declaration-&gt;class_name().c_str(),symbol-&gt;class_name().c_str());</a>
<a name="2730"><span class="lineNum">    2730 </span>            : #endif</a>
<a name="2731"><span class="lineNum">    2731 </span>            :                            // DQ (4/7/2018): I think we should MAYBE be using the function type in the lookupFunctionSymbolInParentScopes(),</a>
<a name="2732"><span class="lineNum">    2732 </span>            :                            // else we could be confusing overloaded function which would not require name qualification.</a>
<a name="2733"><span class="lineNum">    2733 </span>            :                            // mfprintf(mlog [ WARN ] ) (&quot;Shouldn't we be using the function type to refine the symbol table lookup? \n&quot;);</a>
<a name="2734"><span class="lineNum">    2734 </span>            : </a>
<a name="2735"><span class="lineNum">    2735 </span>            :                            // Note name change to variable (for clarification).</a>
<a name="2736"><span class="lineNum">    2736 </span>            :                            // DQ (5/23/2017): Note that for template instatiations the template must be visible from the template instatiation (or name qualified to to be visible).</a>
<a name="2737"><span class="lineNum">    2737 </span><span class="lineCov">       1410 :                               SgFunctionSymbol* symbolHiddingTemplateSymbol = SageInterface::lookupFunctionSymbolInParentScopes(templateInstantiationFunctionNameWithoutTemplateArguments,currentScope);</span></a>
<a name="2738"><span class="lineNum">    2738 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="2739"><span class="lineNum">    2739 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;symbolHiddingTemplateSymbol              = %p \n&quot;,symbolHiddingTemplateSymbol);</a>
<a name="2740"><span class="lineNum">    2740 </span>            : #endif</a>
<a name="2741"><span class="lineNum">    2741 </span>            :                            // Handle the case of a non-template instnatiation hidding the template declaration for the template instantiation</a>
<a name="2742"><span class="lineNum">    2742 </span>            :                            // for which we want to determine name qualification. See test2017_40.C</a>
<a name="2743"><span class="lineNum">    2743 </span><span class="lineCov">       1410 :                               if (symbolHiddingTemplateSymbol != NULL &amp;&amp; symbolHiddingTemplateSymbol != symbol)</span></a>
<a name="2744"><span class="lineNum">    2744 </span>            :                                  {</a>
<a name="2745"><span class="lineNum">    2745 </span>            : #if 0</a>
<a name="2746"><span class="lineNum">    2746 </span>            :                                 // DQ (6/3/2017): Commented out to explore behavior.</a>
<a name="2747"><span class="lineNum">    2747 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;There is a declaration hidding the template associated with this template instantiation (should have some name qualification) \n&quot;);</a>
<a name="2748"><span class="lineNum">    2748 </span>            :                                    ROSE_ABORT();</a>
<a name="2749"><span class="lineNum">    2749 </span>            : #endif</a>
<a name="2750"><span class="lineNum">    2750 </span>            : #if 0</a>
<a name="2751"><span class="lineNum">    2751 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;symbol                                   = %p = %s \n&quot;,symbol,symbol-&gt;class_name().c_str());</a>
<a name="2752"><span class="lineNum">    2752 </span>            :                                    SgFunctionSymbol* temp_functionSymbol = isSgFunctionSymbol(symbol);</a>
<a name="2753"><span class="lineNum">    2753 </span>            :                                    ASSERT_not_null(temp_functionSymbol);</a>
<a name="2754"><span class="lineNum">    2754 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;   --- declaration                       = %p = %s \n&quot;,temp_functionSymbol-&gt;get_declaration(),temp_functionSymbol-&gt;get_declaration()-&gt;class_name().c_str());</a>
<a name="2755"><span class="lineNum">    2755 </span>            :                                 // mfprintf(mlog [ WARN ] ) (&quot;symbolHiddingTemplateInstantiationSymbol = %p = %s \n&quot;,symbolHiddingTemplateInstantiationSymbol,symbolHiddingTemplateInstantiationSymbol-&gt;class_name().c_str());</a>
<a name="2756"><span class="lineNum">    2756 </span>            :                                 // mfprintf(mlog [ WARN ] ) (&quot;   --- declaration                       = %p = %s \n&quot;,symbolHiddingTemplateInstantiationSymbol-&gt;get_declaration(),</a>
<a name="2757"><span class="lineNum">    2757 </span>            :                                 //      symbolHiddingTemplateInstantiationSymbol-&gt;get_declaration()-&gt;class_name().c_str());</a>
<a name="2758"><span class="lineNum">    2758 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;symbolHiddingTemplateInstantiationSymbol = %p = %s \n&quot;,symbolHiddingTemplateSymbol,symbolHiddingTemplateSymbol-&gt;class_name().c_str());</a>
<a name="2759"><span class="lineNum">    2759 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;   --- declaration                       = %p = %s \n&quot;,symbolHiddingTemplateSymbol-&gt;get_declaration(),</a>
<a name="2760"><span class="lineNum">    2760 </span>            :                                         symbolHiddingTemplateSymbol-&gt;get_declaration()-&gt;class_name().c_str());</a>
<a name="2761"><span class="lineNum">    2761 </span>            : #endif</a>
<a name="2762"><span class="lineNum">    2762 </span>            :                                 // This looks up the scope via the symbol table's parent (not sure that is a great approach).</a>
<a name="2763"><span class="lineNum">    2763 </span>            :                                 // SgScopeStatement* hiddingSymbolScope = isSgScopeStatement(symbolHiddingTemplateInstantiationSymbol-&gt;get_parent()-&gt;get_parent());</a>
<a name="2764"><span class="lineNum">    2764 </span>            : </a>
<a name="2765"><span class="lineNum">    2765 </span>            :                                 // Get the scope where this symbol is in the symbol table.</a>
<a name="2766"><span class="lineNum">    2766 </span>            :                                 // SgScopeStatement* hiddingSymbolScope = isSgScopeStatement(symbolHiddingTemplateInstantiationSymbol-&gt;get_parent()-&gt;get_parent());</a>
<a name="2767"><span class="lineNum">    2767 </span><span class="lineCov">       1410 :                                    SgScopeStatement* hiddingSymbolScope = isSgScopeStatement(symbolHiddingTemplateSymbol-&gt;get_parent()-&gt;get_parent());</span></a>
<a name="2768"><span class="lineNum">    2768 </span><span class="lineCov">       1410 :                                    ASSERT_not_null(hiddingSymbolScope);</span></a>
<a name="2769"><span class="lineNum">    2769 </span>            : </a>
<a name="2770"><span class="lineNum">    2770 </span>            :                                 // Get the scope of the template instantiation.</a>
<a name="2771"><span class="lineNum">    2771 </span><span class="lineCov">       1410 :                                    SgScopeStatement* functionScope = templateInstantiationFunction-&gt;get_scope();</span></a>
<a name="2772"><span class="lineNum">    2772 </span><span class="lineCov">       1410 :                                    ASSERT_not_null(functionScope);</span></a>
<a name="2773"><span class="lineNum">    2773 </span>            : #if 0</a>
<a name="2774"><span class="lineNum">    2774 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;functionScope = %p = %s \n&quot;,functionScope,functionScope-&gt;class_name().c_str());</a>
<a name="2775"><span class="lineNum">    2775 </span>            : #endif</a>
<a name="2776"><span class="lineNum">    2776 </span>            :                                 // DQ (4/4/2014): Look at the declarations associated with these symbols.</a>
<a name="2777"><span class="lineNum">    2777 </span>            :                                 // SgDeclarationStatement* declarationHidingCurrentDeclaration = symbolHiddingTemplateInstantiationSymbol-&gt;get_declaration();</a>
<a name="2778"><span class="lineNum">    2778 </span><span class="lineCov">       1410 :                                    SgDeclarationStatement* declarationHidingCurrentDeclaration = symbolHiddingTemplateSymbol-&gt;get_declaration();</span></a>
<a name="2779"><span class="lineNum">    2779 </span><span class="lineCov">       1410 :                                    ASSERT_not_null(declarationHidingCurrentDeclaration);</span></a>
<a name="2780"><span class="lineNum">    2780 </span>            : </a>
<a name="2781"><span class="lineNum">    2781 </span><span class="lineCov">       1410 :                                    SgFunctionSymbol* functionSymbol = isSgFunctionSymbol(symbol);</span></a>
<a name="2782"><span class="lineNum">    2782 </span><span class="lineCov">       1410 :                                    ASSERT_not_null(functionSymbol);</span></a>
<a name="2783"><span class="lineNum">    2783 </span>            : </a>
<a name="2784"><span class="lineNum">    2784 </span><span class="lineCov">       1410 :                                    SgDeclarationStatement* declarationFromSymbol = functionSymbol-&gt;get_declaration();</span></a>
<a name="2785"><span class="lineNum">    2785 </span><span class="lineCov">       1410 :                                    ASSERT_not_null(declarationFromSymbol);</span></a>
<a name="2786"><span class="lineNum">    2786 </span>            : </a>
<a name="2787"><span class="lineNum">    2787 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="2788"><span class="lineNum">    2788 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;hiddingSymbolScope                  = %p = %s \n&quot;,hiddingSymbolScope,hiddingSymbolScope-&gt;class_name().c_str());</a>
<a name="2789"><span class="lineNum">    2789 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;declaration from symbol             = %p = %s \n&quot;,declarationFromSymbol,declarationFromSymbol-&gt;class_name().c_str());</a>
<a name="2790"><span class="lineNum">    2790 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;declaration hidding template symbol = %p = %s \n&quot;,declarationHidingCurrentDeclaration,declarationHidingCurrentDeclaration-&gt;class_name().c_str());</a>
<a name="2791"><span class="lineNum">    2791 </span>            : #endif</a>
<a name="2792"><span class="lineNum">    2792 </span><span class="lineCov">       1410 :                                    bool currentScopeIsNestedWithinScopeOfHiddingDeclaration = false;</span></a>
<a name="2793"><span class="lineNum">    2793 </span>            : </a>
<a name="2794"><span class="lineNum">    2794 </span>            :                                 // SgScopeStatement* temp_symbolScope = symbolScope;</a>
<a name="2795"><span class="lineNum">    2795 </span><span class="lineCov">       1410 :                                    SgScopeStatement* temp_scope = currentScope;</span></a>
<a name="2796"><span class="lineNum">    2796 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="2797"><span class="lineNum">    2797 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;case SgTemplateInstantiationFunctionDecl (template declaration hidden): temp_scope = %p = %s \n&quot;,temp_scope,temp_scope-&gt;class_name().c_str());</a>
<a name="2798"><span class="lineNum">    2798 </span>            : #endif</a>
<a name="2799"><span class="lineNum">    2799 </span>            : #if 1</a>
<a name="2800"><span class="lineNum">    2800 </span><span class="lineCov">       3885 :                                    while (isSgGlobal(temp_scope) == NULL &amp;&amp; temp_scope != hiddingSymbolScope)</span></a>
<a name="2801"><span class="lineNum">    2801 </span>            :                                       {</a>
<a name="2802"><span class="lineNum">    2802 </span><span class="lineCov">       2475 :                                         temp_scope = temp_scope-&gt;get_scope();</span></a>
<a name="2803"><span class="lineNum">    2803 </span>            : #if 0</a>
<a name="2804"><span class="lineNum">    2804 </span>            :                                         mfprintf(mlog [ WARN ] ) (&quot;reset the temp_scope = %p = %s \n&quot;,temp_scope,temp_scope-&gt;class_name().c_str());</a>
<a name="2805"><span class="lineNum">    2805 </span>            : #endif</a>
<a name="2806"><span class="lineNum">    2806 </span>            : #if 0</a>
<a name="2807"><span class="lineNum">    2807 </span>            :                                      // DQ (5/19/2017): This is the root cause of the problem with test2017_39.C.</a>
<a name="2808"><span class="lineNum">    2808 </span>            :                                         mfprintf(mlog [ WARN ] ) (&quot;This is the current error \n&quot;);</a>
<a name="2809"><span class="lineNum">    2809 </span>            :                                         ROSE_ABORT();</a>
<a name="2810"><span class="lineNum">    2810 </span>            : #endif</a>
<a name="2811"><span class="lineNum">    2811 </span>            :                                       }</a>
<a name="2812"><span class="lineNum">    2812 </span>            : #endif</a>
<a name="2813"><span class="lineNum">    2813 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="2814"><span class="lineNum">    2814 </span>            :                                    if (temp_scope != NULL)</a>
<a name="2815"><span class="lineNum">    2815 </span>            :                                       {</a>
<a name="2816"><span class="lineNum">    2816 </span>            :                                         mfprintf(mlog [ WARN ] ) (&quot;final value of temp_scope = %p = %s \n&quot;,temp_scope,temp_scope-&gt;class_name().c_str());</a>
<a name="2817"><span class="lineNum">    2817 </span>            :                                       }</a>
<a name="2818"><span class="lineNum">    2818 </span>            :                                      else</a>
<a name="2819"><span class="lineNum">    2819 </span>            :                                       {</a>
<a name="2820"><span class="lineNum">    2820 </span>            :                                         mfprintf(mlog [ WARN ] ) (&quot;final value of temp_scope = NULL \n&quot;);</a>
<a name="2821"><span class="lineNum">    2821 </span>            :                                       }</a>
<a name="2822"><span class="lineNum">    2822 </span>            : </a>
<a name="2823"><span class="lineNum">    2823 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;currentScope = %p = %s \n&quot;,currentScope,currentScope-&gt;class_name().c_str());</a>
<a name="2824"><span class="lineNum">    2824 </span>            : #endif</a>
<a name="2825"><span class="lineNum">    2825 </span>            : #if 0</a>
<a name="2826"><span class="lineNum">    2826 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="2827"><span class="lineNum">    2827 </span>            :                                    ROSE_ABORT();</a>
<a name="2828"><span class="lineNum">    2828 </span>            : #endif</a>
<a name="2829"><span class="lineNum">    2829 </span>            :                                 // if (temp_scope == hiddingSymbolScope)</a>
<a name="2830"><span class="lineNum">    2830 </span><span class="lineCov">       1410 :                                    if (hiddingSymbolScope != currentScope &amp;&amp; temp_scope == hiddingSymbolScope)</span></a>
<a name="2831"><span class="lineNum">    2831 </span>            :                                       {</a>
<a name="2832"><span class="lineNum">    2832 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="2833"><span class="lineNum">    2833 </span>            :                                         mfprintf(mlog [ WARN ] ) (&quot;Note: hiddingSymbolScope != currentScope &amp;&amp; temp_scope == hiddingSymbolScope \n&quot;);</a>
<a name="2834"><span class="lineNum">    2834 </span>            : #endif</a>
<a name="2835"><span class="lineNum">    2835 </span>            :                                         currentScopeIsNestedWithinScopeOfHiddingDeclaration = true;</a>
<a name="2836"><span class="lineNum">    2836 </span>            : </a>
<a name="2837"><span class="lineNum">    2837 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="2838"><span class="lineNum">    2838 </span>            :                                         mfprintf(mlog [ WARN ] ) (&quot;   --- Resetting the recorded symbol to the hidding symbol  (triggering the name qualification evaluation) \n&quot;);</a>
<a name="2839"><span class="lineNum">    2839 </span>            : #endif</a>
<a name="2840"><span class="lineNum">    2840 </span>            :                                         symbol = symbolHiddingTemplateSymbol;</a>
<a name="2841"><span class="lineNum">    2841 </span>            :                                       }</a>
<a name="2842"><span class="lineNum">    2842 </span>            :                                      else</a>
<a name="2843"><span class="lineNum">    2843 </span>            :                                       {</a>
<a name="2844"><span class="lineNum">    2844 </span>            :                                      // if (hiddingSymbolScope == currentScope)</a>
<a name="2845"><span class="lineNum">    2845 </span><span class="lineCov">        936 :                                         if (hiddingSymbolScope == currentScope &amp;&amp; declarationFromSymbol != declarationHidingCurrentDeclaration)</span></a>
<a name="2846"><span class="lineNum">    2846 </span>            :                                            {</a>
<a name="2847"><span class="lineNum">    2847 </span>            :                                           // DQ (6/3/2017): In this case we need to detect when the template instantiation is hidden</a>
<a name="2848"><span class="lineNum">    2848 </span>            :                                           // by a non-template instantiation with the same name (sans template arguments).</a>
<a name="2849"><span class="lineNum">    2849 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="2850"><span class="lineNum">    2850 </span>            :                                              mfprintf(mlog [ WARN ] ) (&quot;Note: hiddingSymbolScope == currentScope \n&quot;);</a>
<a name="2851"><span class="lineNum">    2851 </span>            : #endif</a>
<a name="2852"><span class="lineNum">    2852 </span><span class="lineNoCov">          0 :                                              currentScopeIsNestedWithinScopeOfHiddingDeclaration = true;</span></a>
<a name="2853"><span class="lineNum">    2853 </span>            : </a>
<a name="2854"><span class="lineNum">    2854 </span>            :                                           // DQ (6/3/2017): Test resetting the symbol to NULL (triggering the name qualification evaluation).</a>
<a name="2855"><span class="lineNum">    2855 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="2856"><span class="lineNum">    2856 </span>            :                                              mfprintf(mlog [ WARN ] ) (&quot;   --- Resetting the recorded symbol to the hidding symbol  (triggering the name qualification evaluation) \n&quot;);</a>
<a name="2857"><span class="lineNum">    2857 </span>            : #endif</a>
<a name="2858"><span class="lineNum">    2858 </span>            :                                           // symbol = NULL;</a>
<a name="2859"><span class="lineNum">    2859 </span>            : </a>
<a name="2860"><span class="lineNum">    2860 </span><span class="lineNoCov">          0 :                                              symbol = symbolHiddingTemplateSymbol;</span></a>
<a name="2861"><span class="lineNum">    2861 </span>            :                                            }</a>
<a name="2862"><span class="lineNum">    2862 </span>            :                                       }</a>
<a name="2863"><span class="lineNum">    2863 </span>            : </a>
<a name="2864"><span class="lineNum">    2864 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="2865"><span class="lineNum">    2865 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;currentScopeIsNestedWithinScopeOfHiddingDeclaration = %s \n&quot;,currentScopeIsNestedWithinScopeOfHiddingDeclaration ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="2866"><span class="lineNum">    2866 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;currentScope       = %p = %s \n&quot;,currentScope,currentScope-&gt;class_name().c_str());</a>
<a name="2867"><span class="lineNum">    2867 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;hiddingSymbolScope = %p = %s \n&quot;,hiddingSymbolScope,hiddingSymbolScope-&gt;class_name().c_str());</a>
<a name="2868"><span class="lineNum">    2868 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;temp_scope         = %p = %s \n&quot;,temp_scope,temp_scope-&gt;class_name().c_str());</a>
<a name="2869"><span class="lineNum">    2869 </span>            : #endif</a>
<a name="2870"><span class="lineNum">    2870 </span>            :                                 // DQ (4/4/2014): We don't want to treat the template instantiation as be hidden by the template declaration</a>
<a name="2871"><span class="lineNum">    2871 </span>            :                                 // because that does not make sense. So check the declarations.  Also, if the template instatiation is</a>
<a name="2872"><span class="lineNum">    2872 </span>            :                                 // not output in the generated code, then it can't be name qualified.</a>
<a name="2873"><span class="lineNum">    2873 </span><span class="lineCov">       2694 :                                    bool willBeOutput = (declaration-&gt;get_file_info()-&gt;isCompilerGenerated() == false ||</span></a>
<a name="2874"><span class="lineNum">    2874 </span><span class="lineCov">       2568 :                                                        (declaration-&gt;get_file_info()-&gt;isCompilerGenerated() &amp;&amp;</span></a>
<a name="2875"><span class="lineNum">    2875 </span><span class="lineCov">       2694 :                                                         declaration-&gt;get_file_info()-&gt;isOutputInCodeGeneration()) );</span></a>
<a name="2876"><span class="lineNum">    2876 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="2877"><span class="lineNum">    2877 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;$$$$$ --- willBeOutput = %s \n&quot;,willBeOutput ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="2878"><span class="lineNum">    2878 </span>            : #endif</a>
<a name="2879"><span class="lineNum">    2879 </span>            :                                 // DQ (4/4/2014): I think that they don't have to be the same kid of function.</a>
<a name="2880"><span class="lineNum">    2880 </span>            :                                 // bool isSameKindOfFunction = (declarationHidingCurrentDeclaration-&gt;variant() == declarationFromSymbol-&gt;variant());</a>
<a name="2881"><span class="lineNum">    2881 </span>            : #if 0</a>
<a name="2882"><span class="lineNum">    2882 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="2883"><span class="lineNum">    2883 </span>            :                                    ROSE_ABORT();</a>
<a name="2884"><span class="lineNum">    2884 </span>            : #endif</a>
<a name="2885"><span class="lineNum">    2885 </span>            : #if 1</a>
<a name="2886"><span class="lineNum">    2886 </span>            :                                 // DQ (6/3/2017): Comment out the resetting of the symbol to NULL (as a test).</a>
<a name="2887"><span class="lineNum">    2887 </span>            : </a>
<a name="2888"><span class="lineNum">    2888 </span>            :                                 // If we visit the scope with the function hidding our template function then we will need some name qualification.</a>
<a name="2889"><span class="lineNum">    2889 </span>            :                                 // if (temp_scope == symbolScope)</a>
<a name="2890"><span class="lineNum">    2890 </span>            :                                 // if (willBeOutput &amp;&amp; isSameKindOfFunction &amp;&amp; temp_scope == symbolScope)</a>
<a name="2891"><span class="lineNum">    2891 </span>            :                                 // if (willBeOutput == true || (willBeOutput == false &amp;&amp; temp_scope == hiddingSymbolScope))</a>
<a name="2892"><span class="lineNum">    2892 </span><span class="lineCov">        976 :                                    if (willBeOutput == true || (willBeOutput == false &amp;&amp; currentScopeIsNestedWithinScopeOfHiddingDeclaration == true))</span></a>
<a name="2893"><span class="lineNum">    2893 </span>            :                                       {</a>
<a name="2894"><span class="lineNum">    2894 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="2895"><span class="lineNum">    2895 </span>            :                                         mfprintf(mlog [ WARN ] ) (&quot;WARNING: Some qualification is required to get past the non-template function hidding the template function = %p = %s \n&quot;,templateInstantiationFunction,templateInstantiationFunction-&gt;get_name().str());</a>
<a name="2896"><span class="lineNum">    2896 </span>            : #endif</a>
<a name="2897"><span class="lineNum">    2897 </span>            :                                      // mfprintf(mlog [ WARN ] ) (&quot;   --- Resetting the recorded symbol to NULL \n&quot;);</a>
<a name="2898"><span class="lineNum">    2898 </span>            :                                      // symbol = NULL;</a>
<a name="2899"><span class="lineNum">    2899 </span>            :                                       }</a>
<a name="2900"><span class="lineNum">    2900 </span>            : #endif</a>
<a name="2901"><span class="lineNum">    2901 </span>            : #if 0</a>
<a name="2902"><span class="lineNum">    2902 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;ERROR: declaration from symbolHiddingTemplateInstantiationSymbol = %p hides SgTemplateInstantiationFunctionDecl \n&quot;,symbolHiddingTemplateInstantiationSymbol);</a>
<a name="2903"><span class="lineNum">    2903 </span>            :                                    ROSE_ABORT();</a>
<a name="2904"><span class="lineNum">    2904 </span>            : #endif</a>
<a name="2905"><span class="lineNum">    2905 </span>            : #if 0</a>
<a name="2906"><span class="lineNum">    2906 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="2907"><span class="lineNum">    2907 </span>            :                                    ROSE_ABORT();</a>
<a name="2908"><span class="lineNum">    2908 </span>            : #endif</a>
<a name="2909"><span class="lineNum">    2909 </span>            :                                  }</a>
<a name="2910"><span class="lineNum">    2910 </span>            :                                 else</a>
<a name="2911"><span class="lineNum">    2911 </span>            :                                  {</a>
<a name="2912"><span class="lineNum">    2912 </span>            :                                 // DQ (5/23/2017): This case is not a problem because the template is visible</a>
<a name="2913"><span class="lineNum">    2913 </span>            :                                 // from the template instantiation is does not require name qualification.</a>
<a name="2914"><span class="lineNum">    2914 </span>            :                                  }</a>
<a name="2915"><span class="lineNum">    2915 </span>            : </a>
<a name="2916"><span class="lineNum">    2916 </span>            :                            // DQ (7/24/2011): The symbol is NULL for test2011_121.C</a>
<a name="2917"><span class="lineNum">    2917 </span>            :                            // ASSERT_not_null(symbol);</a>
<a name="2918"><span class="lineNum">    2918 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="2919"><span class="lineNum">    2919 </span>            :                               if (symbol != NULL)</a>
<a name="2920"><span class="lineNum">    2920 </span>            :                                  {</a>
<a name="2921"><span class="lineNum">    2921 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;Lookup symbol based symbol type: reset symbol = %p = %s \n&quot;,symbol,symbol-&gt;class_name().c_str());</a>
<a name="2922"><span class="lineNum">    2922 </span>            :                                  }</a>
<a name="2923"><span class="lineNum">    2923 </span>            :                                 else</a>
<a name="2924"><span class="lineNum">    2924 </span>            :                                  {</a>
<a name="2925"><span class="lineNum">    2925 </span>            :                                 // DQ (6/22/2011): This is demonstrated by test2011_121.C</a>
<a name="2926"><span class="lineNum">    2926 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;Detected no template function instantiation symbol in a parent scope (ignoring this case for now) \n&quot;);</a>
<a name="2927"><span class="lineNum">    2927 </span>            :                                  }</a>
<a name="2928"><span class="lineNum">    2928 </span>            : #endif</a>
<a name="2929"><span class="lineNum">    2929 </span>            : #if 0</a>
<a name="2930"><span class="lineNum">    2930 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="2931"><span class="lineNum">    2931 </span>            :                               ROSE_ABORT();</a>
<a name="2932"><span class="lineNum">    2932 </span>            : #endif</a>
<a name="2933"><span class="lineNum">    2933 </span>            :                             }</a>
<a name="2934"><span class="lineNum">    2934 </span>            : #if 0</a>
<a name="2935"><span class="lineNum">    2935 </span>            :                       // Note that this is handled (refactored) to another location.</a>
<a name="2936"><span class="lineNum">    2936 </span>            :                       // DQ (10/31/2013): I think this should be active code since test2013_273.C demonstrates a case where this is required.</a>
<a name="2937"><span class="lineNum">    2937 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp; Calling evaluateNameQualificationForTemplateArgumentList() templateInstantiationFunction = %p = %s \n&quot;,</a>
<a name="2938"><span class="lineNum">    2938 </span>            :                               templateInstantiationFunction,templateInstantiationFunction-&gt;class_name().c_str());</a>
<a name="2939"><span class="lineNum">    2939 </span>            : </a>
<a name="2940"><span class="lineNum">    2940 </span>            :                       // Evaluate all template arguments.</a>
<a name="2941"><span class="lineNum">    2941 </span>            :                          evaluateNameQualificationForTemplateArgumentList (templateInstantiationFunction-&gt;get_templateArguments(),currentScope,positionStatement);</a>
<a name="2942"><span class="lineNum">    2942 </span>            : #endif</a>
<a name="2943"><span class="lineNum">    2943 </span>            : #if 0</a>
<a name="2944"><span class="lineNum">    2944 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="2945"><span class="lineNum">    2945 </span>            :                          ROSE_ABORT();</a>
<a name="2946"><span class="lineNum">    2946 </span>            : #endif</a>
<a name="2947"><span class="lineNum">    2947 </span>            :                          break;</a>
<a name="2948"><span class="lineNum">    2948 </span>            :                        }</a>
<a name="2949"><span class="lineNum">    2949 </span>            : </a>
<a name="2950"><span class="lineNum">    2950 </span><span class="lineCov">       8837 :                     case V_SgEnumDeclaration:</span></a>
<a name="2951"><span class="lineNum">    2951 </span><span class="lineCov">       8837 :                        {</span></a>
<a name="2952"><span class="lineNum">    2952 </span><span class="lineCov">       8837 :                          SgEnumDeclaration* enumDeclaration = isSgEnumDeclaration(declaration);</span></a>
<a name="2953"><span class="lineNum">    2953 </span><span class="lineCov">       8837 :                          ASSERT_not_null(enumDeclaration);</span></a>
<a name="2954"><span class="lineNum">    2954 </span>            : </a>
<a name="2955"><span class="lineNum">    2955 </span><span class="lineCov">       8837 :                          SgEnumSymbol* enumSymbol = isSgEnumSymbol(symbol);</span></a>
<a name="2956"><span class="lineNum">    2956 </span><span class="lineCov">       8837 :                          if (enumSymbol == NULL)</span></a>
<a name="2957"><span class="lineNum">    2957 </span>            :                             {</a>
<a name="2958"><span class="lineNum">    2958 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="2959"><span class="lineNum">    2959 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;Type elaboration is required: declaration = %s symbol = %s \n&quot;,declaration-&gt;class_name().c_str(),symbol-&gt;class_name().c_str());</a>
<a name="2960"><span class="lineNum">    2960 </span>            : #endif</a>
<a name="2961"><span class="lineNum">    2961 </span><span class="lineNoCov">          0 :                               typeElaborationIsRequired = true;</span></a>
<a name="2962"><span class="lineNum">    2962 </span>            : </a>
<a name="2963"><span class="lineNum">    2963 </span>            :                            // Reset the symbol to one that will match the declaration.</a>
<a name="2964"><span class="lineNum">    2964 </span><span class="lineNoCov">          0 :                               symbol = SageInterface::lookupEnumSymbolInParentScopes(name,currentScope);</span></a>
<a name="2965"><span class="lineNum">    2965 </span>            : </a>
<a name="2966"><span class="lineNum">    2966 </span>            :                            // ASSERT_not_null(symbol);</a>
<a name="2967"><span class="lineNum">    2967 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="2968"><span class="lineNum">    2968 </span>            :                               if (symbol != NULL)</a>
<a name="2969"><span class="lineNum">    2969 </span>            :                                  {</a>
<a name="2970"><span class="lineNum">    2970 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;Lookup symbol based symbol type: reset symbol = %p = %s \n&quot;,symbol,symbol-&gt;class_name().c_str());</a>
<a name="2971"><span class="lineNum">    2971 </span>            :                                  }</a>
<a name="2972"><span class="lineNum">    2972 </span>            :                                 else</a>
<a name="2973"><span class="lineNum">    2973 </span>            :                                  {</a>
<a name="2974"><span class="lineNum">    2974 </span>            :                                 // DQ (6/22/2011): This is demonstrated by test2011_95.C</a>
<a name="2975"><span class="lineNum">    2975 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;Detected no enum symbol in a parent scope (ignoring this case for now) \n&quot;);</a>
<a name="2976"><span class="lineNum">    2976 </span>            :                                  }</a>
<a name="2977"><span class="lineNum">    2977 </span>            : #endif</a>
<a name="2978"><span class="lineNum">    2978 </span>            : </a>
<a name="2979"><span class="lineNum">    2979 </span>            : #if 0</a>
<a name="2980"><span class="lineNum">    2980 </span>            :                                 // DQ (2/13/2019): I think we have to force an extra level of name qualification.</a>
<a name="2981"><span class="lineNum">    2981 </span>            : #if 1</a>
<a name="2982"><span class="lineNum">    2982 </span>            :                                 // DQ (2/13/2019): I think we need to check if a qualified nondefining declaration</a>
<a name="2983"><span class="lineNum">    2983 </span>            :                                 // has been made for this class, else no qualification should be output.</a>
<a name="2984"><span class="lineNum">    2984 </span>            :                                    SgDeclarationStatement* declarationToSearchForInReferencedNameSet =</a>
<a name="2985"><span class="lineNum">    2985 </span>            :                                         declaration-&gt;get_firstNondefiningDeclaration() != NULL ? declaration-&gt;get_firstNondefiningDeclaration() : declaration;</a>
<a name="2986"><span class="lineNum">    2986 </span>            :                                    ASSERT_not_null(declarationToSearchForInReferencedNameSet);</a>
<a name="2987"><span class="lineNum">    2987 </span>            :                                    bool skipNameQualification = false;</a>
<a name="2988"><span class="lineNum">    2988 </span>            :                                    if (referencedNameSet.find(declarationToSearchForInReferencedNameSet) == referencedNameSet.end())</a>
<a name="2989"><span class="lineNum">    2989 </span>            :                                       {</a>
<a name="2990"><span class="lineNum">    2990 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="2991"><span class="lineNum">    2991 </span>            :                                         mfprintf(mlog [ WARN ] ) (&quot;   --- $$$$$$$$$$ NOT Found: declaration %p = %s in referencedNameSet referencedNameSet.size() = %&quot; PRIuPTR &quot; \n&quot;,</a>
<a name="2992"><span class="lineNum">    2992 </span>            :                                              declaration,declaration-&gt;class_name().c_str(),referencedNameSet.size());</a>
<a name="2993"><span class="lineNum">    2993 </span>            : #endif</a>
<a name="2994"><span class="lineNum">    2994 </span>            :                                         skipNameQualification = true;</a>
<a name="2995"><span class="lineNum">    2995 </span>            :                                       }</a>
<a name="2996"><span class="lineNum">    2996 </span>            :                                      else</a>
<a name="2997"><span class="lineNum">    2997 </span>            :                                       {</a>
<a name="2998"><span class="lineNum">    2998 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="2999"><span class="lineNum">    2999 </span>            :                                         mfprintf(mlog [ WARN ] ) (&quot;   --- $$$$$$$$$$ FOUND: declaration %p = %s in referencedNameSet \n&quot;,declaration,declaration-&gt;class_name().c_str());</a>
<a name="3000"><span class="lineNum">    3000 </span>            : #endif</a>
<a name="3001"><span class="lineNum">    3001 </span>            :                                       }</a>
<a name="3002"><span class="lineNum">    3002 </span>            : </a>
<a name="3003"><span class="lineNum">    3003 </span>            :                                 // Check if a nondefining declaration has been seen already, if so then this may be a non-defining</a>
<a name="3004"><span class="lineNum">    3004 </span>            :                                 // or defining declaration in another scope and they name qualification would be required.</a>
<a name="3005"><span class="lineNum">    3005 </span>            :                                 // forceMoreNameQualification = true;</a>
<a name="3006"><span class="lineNum">    3006 </span>            :                                    if (skipNameQualification == false)</a>
<a name="3007"><span class="lineNum">    3007 </span>            :                                       {</a>
<a name="3008"><span class="lineNum">    3008 </span>            :                                         forceMoreNameQualification = true;</a>
<a name="3009"><span class="lineNum">    3009 </span>            :                                       }</a>
<a name="3010"><span class="lineNum">    3010 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="3011"><span class="lineNum">    3011 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;Forcing an extra level of name qualification forceMoreNameQualification = %s \n&quot;,forceMoreNameQualification ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="3012"><span class="lineNum">    3012 </span>            : #endif</a>
<a name="3013"><span class="lineNum">    3013 </span>            : #else</a>
<a name="3014"><span class="lineNum">    3014 </span>            :                                 // DQ (2/13/2019): Disabled forcing more name qualification.</a>
<a name="3015"><span class="lineNum">    3015 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;Disabled forcing more name qualification \n&quot;);</a>
<a name="3016"><span class="lineNum">    3016 </span>            : #endif</a>
<a name="3017"><span class="lineNum">    3017 </span>            : #if 0</a>
<a name="3018"><span class="lineNum">    3018 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;I think we have to force an extra level of name qualification (not implemented) \n&quot;);</a>
<a name="3019"><span class="lineNum">    3019 </span>            :                                    ROSE_ABORT();</a>
<a name="3020"><span class="lineNum">    3020 </span>            : #endif</a>
<a name="3021"><span class="lineNum">    3021 </span>            : #endif</a>
<a name="3022"><span class="lineNum">    3022 </span>            :                             }</a>
<a name="3023"><span class="lineNum">    3023 </span>            :                            else</a>
<a name="3024"><span class="lineNum">    3024 </span>            :                             {</a>
<a name="3025"><span class="lineNum">    3025 </span>            :                            // DQ (5/30/2019): If this is a SgEnumSymbol then are they others such that we require name qualification</a>
<a name="3026"><span class="lineNum">    3026 </span>            :                            // to select the correct enum declaration (type).</a>
<a name="3027"><span class="lineNum">    3027 </span>            : </a>
<a name="3028"><span class="lineNum">    3028 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="3029"><span class="lineNum">    3029 </span>            :                               SgSymbol* symbol = SageInterface::lookupSymbolInParentScopes(name,currentScope,templateParameterList,templateArgumentList);</a>
<a name="3030"><span class="lineNum">    3030 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;Previous lookup: symbol = %p = %s \n&quot;,symbol,(symbol != NULL) ? symbol-&gt;class_name().c_str() : &quot;NULL&quot;);</a>
<a name="3031"><span class="lineNum">    3031 </span>            : #endif</a>
<a name="3032"><span class="lineNum">    3032 </span><span class="lineCov">       8837 :                               size_t symbol_count       = currentScope-&gt;count_symbol(name);</span></a>
<a name="3033"><span class="lineNum">    3033 </span><span class="lineCov">       8837 :                               bool isUnNamed            = enumDeclaration-&gt;get_isUnNamed();</span></a>
<a name="3034"><span class="lineNum">    3034 </span>            : #if 0</a>
<a name="3035"><span class="lineNum">    3035 </span>            :                               size_t table_size         = currentScope-&gt;symbol_table_size();</a>
<a name="3036"><span class="lineNum">    3036 </span>            :                               size_t alias_symbol_count = currentScope-&gt;count_alias_symbol(name);</a>
<a name="3037"><span class="lineNum">    3037 </span>            : </a>
<a name="3038"><span class="lineNum">    3038 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;\n\n&quot;);</a>
<a name="3039"><span class="lineNum">    3039 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot; --- currentScope       = %p = %s \n&quot;,currentScope,currentScope-&gt;class_name().c_str());</a>
<a name="3040"><span class="lineNum">    3040 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot; --- table_size         = %zu \n&quot;,table_size);</a>
<a name="3041"><span class="lineNum">    3041 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot; --- symbol_count       = %zu \n&quot;,symbol_count);</a>
<a name="3042"><span class="lineNum">    3042 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot; --- alias_symbol_count = %zu \n&quot;,alias_symbol_count);</a>
<a name="3043"><span class="lineNum">    3043 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot; --- isUnNamed          = %s \n&quot;,enumDeclaration-&gt;get_isUnNamed() ? &quot;true&quot; : &quot;false&quot;);;</a>
<a name="3044"><span class="lineNum">    3044 </span>            : </a>
<a name="3045"><span class="lineNum">    3045 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;\n\nOutput using print() API \n&quot;);</a>
<a name="3046"><span class="lineNum">    3046 </span>            :                               currentScope-&gt;get_symbol_table()-&gt;print();</a>
<a name="3047"><span class="lineNum">    3047 </span>            : </a>
<a name="3048"><span class="lineNum">    3048 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;\n\nOutput using print(string,SgSymbol) API \n&quot;);</a>
<a name="3049"><span class="lineNum">    3049 </span>            :                               currentScope-&gt;get_symbol_table()-&gt;print(&quot;How many of these enum symbols are there that match the same name&quot;,V_SgSymbol);</a>
<a name="3050"><span class="lineNum">    3050 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;\n\n&quot;);</a>
<a name="3051"><span class="lineNum">    3051 </span>            : #endif</a>
<a name="3052"><span class="lineNum">    3052 </span>            : #if 0</a>
<a name="3053"><span class="lineNum">    3053 </span>            :                               SgScopeStatement* enumScope  = enumDeclaration-&gt;get_scope();</a>
<a name="3054"><span class="lineNum">    3054 </span>            :                               ASSERT_not_null(enumDeclaration-&gt;get_parent());</a>
<a name="3055"><span class="lineNum">    3055 </span>            :                               SgStatement*      enumParent = isSgStatement(enumDeclaration-&gt;get_parent());</a>
<a name="3056"><span class="lineNum">    3056 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="3057"><span class="lineNum">    3057 </span>            :                               ASSERT_not_null(enumParent);</a>
<a name="3058"><span class="lineNum">    3058 </span>            :                               ASSERT_not_null(enumScope);</a>
<a name="3059"><span class="lineNum">    3059 </span>            : #if 0</a>
<a name="3060"><span class="lineNum">    3060 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;enumParent set to enumDeclaration-&gt;get_parent(): enumParent = %p = %s \n&quot;,enumParent,enumParent-&gt;class_name().c_str());</a>
<a name="3061"><span class="lineNum">    3061 </span>            : #endif</a>
<a name="3062"><span class="lineNum">    3062 </span>            :                               if (isSgTypedefDeclaration(enumParent) != NULL)</a>
<a name="3063"><span class="lineNum">    3063 </span>            :                                  {</a>
<a name="3064"><span class="lineNum">    3064 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;enumParent is SgTypedefDeclaration: get parent of enumParent \n&quot;);</a>
<a name="3065"><span class="lineNum">    3065 </span>            :                                    enumParent = isSgStatement(enumParent-&gt;get_parent());</a>
<a name="3066"><span class="lineNum">    3066 </span>            :                                    ASSERT_not_null(enumParent);</a>
<a name="3067"><span class="lineNum">    3067 </span>            :                                  }</a>
<a name="3068"><span class="lineNum">    3068 </span>            : #if 0</a>
<a name="3069"><span class="lineNum">    3069 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;currentScope = %p = %s \n&quot;,currentScope,currentScope-&gt;class_name().c_str());</a>
<a name="3070"><span class="lineNum">    3070 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;enumParent   = %p = %s \n&quot;,enumParent,enumParent-&gt;class_name().c_str());</a>
<a name="3071"><span class="lineNum">    3071 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;enumScope    = %p = %s \n&quot;,enumScope,enumScope-&gt;class_name().c_str());</a>
<a name="3072"><span class="lineNum">    3072 </span>            : #endif</a>
<a name="3073"><span class="lineNum">    3073 </span>            : </a>
<a name="3074"><span class="lineNum">    3074 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="3075"><span class="lineNum">    3075 </span>            :                               if (enumParent == enumScope &amp;&amp; false)</a>
<a name="3076"><span class="lineNum">    3076 </span>            :                                  {</a>
<a name="3077"><span class="lineNum">    3077 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;These locations match, so we don't want any name qualification on the declaration \n&quot;);</a>
<a name="3078"><span class="lineNum">    3078 </span>            :                                  }</a>
<a name="3079"><span class="lineNum">    3079 </span>            :                                 else</a>
<a name="3080"><span class="lineNum">    3080 </span>            :                                  {</a>
<a name="3081"><span class="lineNum">    3081 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="3082"><span class="lineNum">    3082 </span>            :                                    if (symbol_count &gt; 1 &amp;&amp; isUnNamed == false)</a>
<a name="3083"><span class="lineNum">    3083 </span>            :                                       {</a>
<a name="3084"><span class="lineNum">    3084 </span>            : #if 0</a>
<a name="3085"><span class="lineNum">    3085 </span>            :                                         mfprintf(mlog [ WARN ] ) (&quot;Detected multiple symbols with the same name, so force name qualification: symbol_count = %zu \n&quot;,symbol_count);</a>
<a name="3086"><span class="lineNum">    3086 </span>            : #endif</a>
<a name="3087"><span class="lineNum">    3087 </span>            :                                         forceMoreNameQualification = true;</a>
<a name="3088"><span class="lineNum">    3088 </span>            :                                       }</a>
<a name="3089"><span class="lineNum">    3089 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="3090"><span class="lineNum">    3090 </span>            :                                  }</a>
<a name="3091"><span class="lineNum">    3091 </span>            : #else</a>
<a name="3092"><span class="lineNum">    3092 </span><span class="lineCov">       8837 :                               if (symbol_count &gt; 1 &amp;&amp; isUnNamed == false)</span></a>
<a name="3093"><span class="lineNum">    3093 </span>            :                                  {</a>
<a name="3094"><span class="lineNum">    3094 </span>            : #if 0</a>
<a name="3095"><span class="lineNum">    3095 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;Detected multiple symbols with the same name, so force name qualification: symbol_count = %zu \n&quot;,symbol_count);</a>
<a name="3096"><span class="lineNum">    3096 </span>            : #endif</a>
<a name="3097"><span class="lineNum">    3097 </span><span class="lineCov">        155 :                                    forceMoreNameQualification = true;</span></a>
<a name="3098"><span class="lineNum">    3098 </span>            :                                  }</a>
<a name="3099"><span class="lineNum">    3099 </span>            : #endif</a>
<a name="3100"><span class="lineNum">    3100 </span>            : </a>
<a name="3101"><span class="lineNum">    3101 </span>            : #if 0</a>
<a name="3102"><span class="lineNum">    3102 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;How many of these enum symbols are there that match the same name? (not implemented) \n&quot;);</a>
<a name="3103"><span class="lineNum">    3103 </span>            :                               ROSE_ABORT();</a>
<a name="3104"><span class="lineNum">    3104 </span>            : #endif</a>
<a name="3105"><span class="lineNum">    3105 </span>            :                             }</a>
<a name="3106"><span class="lineNum">    3106 </span>            : </a>
<a name="3107"><span class="lineNum">    3107 </span>            :                          break;</a>
<a name="3108"><span class="lineNum">    3108 </span>            :                        }</a>
<a name="3109"><span class="lineNum">    3109 </span>            : </a>
<a name="3110"><span class="lineNum">    3110 </span><span class="lineCov">      77438 :                     case V_SgTemplateInstantiationDecl:</span></a>
<a name="3111"><span class="lineNum">    3111 </span><span class="lineCov">      77438 :                        {</span></a>
<a name="3112"><span class="lineNum">    3112 </span><span class="lineCov">      77438 :                          SgTemplateInstantiationDecl* templateInstantiationDeclaration = isSgTemplateInstantiationDecl(declaration);</span></a>
<a name="3113"><span class="lineNum">    3113 </span><span class="lineCov">      77438 :                          ASSERT_not_null(templateInstantiationDeclaration);</span></a>
<a name="3114"><span class="lineNum">    3114 </span>            : </a>
<a name="3115"><span class="lineNum">    3115 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="3116"><span class="lineNum">    3116 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;Found a case of declaration == SgTemplateInstantiationDecl \n&quot;);</a>
<a name="3117"><span class="lineNum">    3117 </span>            : #endif</a>
<a name="3118"><span class="lineNum">    3118 </span>            :                       // DQ (7/22/2017): Added test for SgTemplateInstantiationDirectiveStatement, so that we can process the</a>
<a name="3119"><span class="lineNum">    3119 </span>            :                       // template arguments correctly (using the scope of the SgTemplateInstantiationDirectiveStatement instead</a>
<a name="3120"><span class="lineNum">    3120 </span>            :                       // of the scope of the SgTemplateInstantiationDecl (which can be different)).</a>
<a name="3121"><span class="lineNum">    3121 </span>            :                       // DQ (6/3/2017): Add test to check if this is part of a template instantiation directive.</a>
<a name="3122"><span class="lineNum">    3122 </span>            :                       // However, I think that out use of name qualification is independent of this result.</a>
<a name="3123"><span class="lineNum">    3123 </span><span class="lineCov">      77438 :                          SgTemplateInstantiationDirectiveStatement* templateInstantiationDirectiveStatement = isSgTemplateInstantiationDirectiveStatement(templateInstantiationDeclaration-&gt;get_parent());</span></a>
<a name="3124"><span class="lineNum">    3124 </span><span class="lineCov">      77438 :                          if (templateInstantiationDirectiveStatement != NULL)</span></a>
<a name="3125"><span class="lineNum">    3125 </span>            :                             {</a>
<a name="3126"><span class="lineNum">    3126 </span>            : #if 0</a>
<a name="3127"><span class="lineNum">    3127 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;******** Found a class template instantiation that is a part of a SgTemplateInstantiationDirectiveStatement: symbol = %p = %s \n&quot;,symbol,symbol-&gt;class_name().c_str());</a>
<a name="3128"><span class="lineNum">    3128 </span>            : #endif</a>
<a name="3129"><span class="lineNum">    3129 </span>            : #if 0</a>
<a name="3130"><span class="lineNum">    3130 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="3131"><span class="lineNum">    3131 </span>            :                               ROSE_ABORT();</a>
<a name="3132"><span class="lineNum">    3132 </span>            : #endif</a>
<a name="3133"><span class="lineNum">    3133 </span>            :                             }</a>
<a name="3134"><span class="lineNum">    3134 </span>            : </a>
<a name="3135"><span class="lineNum">    3135 </span><span class="lineCov">      77438 :                          SgClassSymbol* classSymbol = isSgClassSymbol(symbol);</span></a>
<a name="3136"><span class="lineNum">    3136 </span><span class="lineCov">      77438 :                          if (classSymbol == NULL)</span></a>
<a name="3137"><span class="lineNum">    3137 </span>            :                             {</a>
<a name="3138"><span class="lineNum">    3138 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="3139"><span class="lineNum">    3139 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;Type elaboration is required: declaration = %s symbol = %s \n&quot;,declaration-&gt;class_name().c_str(),symbol-&gt;class_name().c_str());</a>
<a name="3140"><span class="lineNum">    3140 </span>            : #endif</a>
<a name="3141"><span class="lineNum">    3141 </span><span class="lineCov">         26 :                               typeElaborationIsRequired = true;</span></a>
<a name="3142"><span class="lineNum">    3142 </span>            : </a>
<a name="3143"><span class="lineNum">    3143 </span>            :                            // mfprintf(mlog [ WARN ] ) (&quot;We might need the template arguments to look up this template class instantiation. \n&quot;);</a>
<a name="3144"><span class="lineNum">    3144 </span>            : </a>
<a name="3145"><span class="lineNum">    3145 </span>            :                            // DQ (8/15/2013): This needs to be used in lookupClassSymbolInParentScopes(), but the function does not accept a SgTemplateArgumentPtrList pointer yet.</a>
<a name="3146"><span class="lineNum">    3146 </span><span class="lineCov">         26 :                               SgTemplateArgumentPtrList* templateArgumentsList = &amp;(templateInstantiationDeclaration-&gt;get_templateArguments());</span></a>
<a name="3147"><span class="lineNum">    3147 </span>            : </a>
<a name="3148"><span class="lineNum">    3148 </span>            :                            // DQ (8/16/2013): Modified API for symbol lookup.</a>
<a name="3149"><span class="lineNum">    3149 </span>            :                            // Reset the symbol to one that will match the declaration.</a>
<a name="3150"><span class="lineNum">    3150 </span>            :                            // symbol = SageInterface::lookupClassSymbolInParentScopes(name,currentScope);</a>
<a name="3151"><span class="lineNum">    3151 </span><span class="lineCov">         26 :                               symbol = SageInterface::lookupClassSymbolInParentScopes(name,currentScope,templateArgumentsList);</span></a>
<a name="3152"><span class="lineNum">    3152 </span>            : </a>
<a name="3153"><span class="lineNum">    3153 </span>            :                            // DQ (5/15/2011): Added this to support where symbol after moving name qualification</a>
<a name="3154"><span class="lineNum">    3154 </span>            :                            // support to the astPostProcessing phase instead of calling it in the unparser.</a>
<a name="3155"><span class="lineNum">    3155 </span><span class="lineCov">         26 :                               if (symbol != NULL)</span></a>
<a name="3156"><span class="lineNum">    3156 </span>            :                                  {</a>
<a name="3157"><span class="lineNum">    3157 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="3158"><span class="lineNum">    3158 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;Lookup symbol based symbol type: reset symbol = %p = %s \n&quot;,symbol,symbol-&gt;class_name().c_str());</a>
<a name="3159"><span class="lineNum">    3159 </span>            : #endif</a>
<a name="3160"><span class="lineNum">    3160 </span>            :                                  }</a>
<a name="3161"><span class="lineNum">    3161 </span>            :                                 else</a>
<a name="3162"><span class="lineNum">    3162 </span>            :                                  {</a>
<a name="3163"><span class="lineNum">    3163 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="3164"><span class="lineNum">    3164 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::nameQualificationDepth(): classSymbol == NULL \n&quot;);</a>
<a name="3165"><span class="lineNum">    3165 </span>            : #endif</a>
<a name="3166"><span class="lineNum">    3166 </span>            : #if 0</a>
<a name="3167"><span class="lineNum">    3167 </span>            :                                 // DQ (8/13/2013): This is older code that we should not have to support how.</a>
<a name="3168"><span class="lineNum">    3168 </span>            :                                 // template symbol lookup must be specific to classes, functions, or member functions to make sense now.</a>
<a name="3169"><span class="lineNum">    3169 </span>            : </a>
<a name="3170"><span class="lineNum">    3170 </span>            :                                 // Look for a template symbol</a>
<a name="3171"><span class="lineNum">    3171 </span>            :                                    symbol = SageInterface::lookupTemplateSymbolInParentScopes(name,currentScope);</a>
<a name="3172"><span class="lineNum">    3172 </span>            : #else</a>
<a name="3173"><span class="lineNum">    3173 </span><span class="lineNoCov">          0 :                                    SgTemplateClassDeclaration* templateClassDeclaration = templateInstantiationDeclaration-&gt;get_templateDeclaration();</span></a>
<a name="3174"><span class="lineNum">    3174 </span><span class="lineNoCov">          0 :                                    ASSERT_not_null(templateClassDeclaration);</span></a>
<a name="3175"><span class="lineNum">    3175 </span>            : </a>
<a name="3176"><span class="lineNum">    3176 </span><span class="lineNoCov">          0 :                                    SgTemplateParameterPtrList &amp; templateParameterList = templateClassDeclaration-&gt;get_templateParameters();</span></a>
<a name="3177"><span class="lineNum">    3177 </span><span class="lineNoCov">          0 :                                    SgTemplateArgumentPtrList  &amp; templateArgumentList  = templateClassDeclaration-&gt;get_templateSpecializationArguments();</span></a>
<a name="3178"><span class="lineNum">    3178 </span>            : </a>
<a name="3179"><span class="lineNum">    3179 </span>            :                                 // DQ (8/13/2013): This needs to be looked up as a SgTemplateClassSymbol.</a>
<a name="3180"><span class="lineNum">    3180 </span><span class="lineNoCov">          0 :                                    symbol = SageInterface::lookupTemplateClassSymbolInParentScopes(name,&amp;templateParameterList,&amp;templateArgumentList,currentScope);</span></a>
<a name="3181"><span class="lineNum">    3181 </span>            : #endif</a>
<a name="3182"><span class="lineNum">    3182 </span>            :                                 // DQ (5/15/2011): This fails for test2004_77.C)...</a>
<a name="3183"><span class="lineNum">    3183 </span>            :                                 // ASSERT_not_null(symbol);</a>
<a name="3184"><span class="lineNum">    3184 </span>            :                                  }</a>
<a name="3185"><span class="lineNum">    3185 </span>            : #if 0</a>
<a name="3186"><span class="lineNum">    3186 </span>            :                               ASSERT_not_null(symbol);</a>
<a name="3187"><span class="lineNum">    3187 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;Lookup symbol based symbol type: reset symbol = %p = %s \n&quot;,symbol,symbol-&gt;class_name().c_str());</a>
<a name="3188"><span class="lineNum">    3188 </span>            : #endif</a>
<a name="3189"><span class="lineNum">    3189 </span>            :                             }</a>
<a name="3190"><span class="lineNum">    3190 </span>            :                            else</a>
<a name="3191"><span class="lineNum">    3191 </span>            :                             {</a>
<a name="3192"><span class="lineNum">    3192 </span><span class="lineCov">      77412 :                               SgDeclarationStatement* nestedDeclaration = classSymbol-&gt;get_declaration();</span></a>
<a name="3193"><span class="lineNum">    3193 </span><span class="lineCov">      77412 :                               ASSERT_not_null(nestedDeclaration);</span></a>
<a name="3194"><span class="lineNum">    3194 </span>            : </a>
<a name="3195"><span class="lineNum">    3195 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="3196"><span class="lineNum">    3196 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;Need to dig deeper into this symbol! \n&quot;);</a>
<a name="3197"><span class="lineNum">    3197 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;nestedDeclaration = %p = %s \n&quot;,nestedDeclaration,nestedDeclaration-&gt;class_name().c_str());</a>
<a name="3198"><span class="lineNum">    3198 </span>            : #endif</a>
<a name="3199"><span class="lineNum">    3199 </span><span class="lineCov">      77412 :                               SgTemplateInstantiationDecl* nestedTemplateDeclaration = isSgTemplateInstantiationDecl(nestedDeclaration);</span></a>
<a name="3200"><span class="lineNum">    3200 </span>            :                               if (nestedTemplateDeclaration != NULL)</a>
<a name="3201"><span class="lineNum">    3201 </span>            :                                  {</a>
<a name="3202"><span class="lineNum">    3202 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="3203"><span class="lineNum">    3203 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;nestedTemplateDeclaration = %p = %s \n&quot;,nestedTemplateDeclaration,nestedTemplateDeclaration-&gt;get_name().str());</a>
<a name="3204"><span class="lineNum">    3204 </span>            : #endif</a>
<a name="3205"><span class="lineNum">    3205 </span>            :                                  }</a>
<a name="3206"><span class="lineNum">    3206 </span>            :                             }</a>
<a name="3207"><span class="lineNum">    3207 </span>            : </a>
<a name="3208"><span class="lineNum">    3208 </span>            :                          break;</a>
<a name="3209"><span class="lineNum">    3209 </span>            :                        }</a>
<a name="3210"><span class="lineNum">    3210 </span>            : </a>
<a name="3211"><span class="lineNum">    3211 </span>            :                  // DQ (3/13/2012): Added support for SgTemplateVariableDeclaration (I think it can just leverage the SgVariableDeclaration case).</a>
<a name="3212"><span class="lineNum">    3212 </span><span class="lineCov">      18722 :                     case V_SgTemplateVariableDeclaration:</span></a>
<a name="3213"><span class="lineNum">    3213 </span>            : </a>
<a name="3214"><span class="lineNum">    3214 </span>            :                  // DQ (7/22/2017): We will be added this support shortly.</a>
<a name="3215"><span class="lineNum">    3215 </span>            :                  // case V_SgTemplateInstantiationVariableDeclaration:</a>
<a name="3216"><span class="lineNum">    3216 </span>            : </a>
<a name="3217"><span class="lineNum">    3217 </span><span class="lineCov">      18722 :                     case V_SgVariableDeclaration:</span></a>
<a name="3218"><span class="lineNum">    3218 </span><span class="lineCov">      18722 :                        {</span></a>
<a name="3219"><span class="lineNum">    3219 </span><span class="lineCov">      18722 :                          SgVariableDeclaration* variableDeclaration = isSgVariableDeclaration(declaration);</span></a>
<a name="3220"><span class="lineNum">    3220 </span><span class="lineCov">      18722 :                          ASSERT_not_null(variableDeclaration);</span></a>
<a name="3221"><span class="lineNum">    3221 </span>            : </a>
<a name="3222"><span class="lineNum">    3222 </span><span class="lineCov">      18722 :                          SgVariableSymbol* variableSymbol = isSgVariableSymbol(symbol);</span></a>
<a name="3223"><span class="lineNum">    3223 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="3224"><span class="lineNum">    3224 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;variableSymbol = %p = %s \n&quot;,variableSymbol,symbol-&gt;class_name().c_str());</a>
<a name="3225"><span class="lineNum">    3225 </span>            : #endif</a>
<a name="3226"><span class="lineNum">    3226 </span>            : #if 0</a>
<a name="3227"><span class="lineNum">    3227 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::nameQualificationDepth(): variableSymbol = %p = %s \n&quot;,variableSymbol,(symbol != NULL) ? symbol-&gt;class_name().c_str() : &quot;null&quot;);</a>
<a name="3228"><span class="lineNum">    3228 </span>            : #endif</a>
<a name="3229"><span class="lineNum">    3229 </span>            :                       // DQ (7/22/2017): Added test for SgTemplateInstantiationDirectiveStatement, so that we can process the</a>
<a name="3230"><span class="lineNum">    3230 </span>            :                       // template arguments correctly (using the scope of the SgTemplateInstantiationDirectiveStatement instead</a>
<a name="3231"><span class="lineNum">    3231 </span>            :                       // of the scope of the SgTemplateInstantiationVariableDeclaration (which can be different)).</a>
<a name="3232"><span class="lineNum">    3232 </span>            :                       // DQ (6/3/2017): Add test to check if this is part of a template instantiation directive.</a>
<a name="3233"><span class="lineNum">    3233 </span>            :                       // However, I think that out use of name qualification is independent of this result.</a>
<a name="3234"><span class="lineNum">    3234 </span><span class="lineCov">      18722 :                          SgTemplateInstantiationDirectiveStatement* templateInstantiationDirectiveStatement = isSgTemplateInstantiationDirectiveStatement(variableDeclaration-&gt;get_parent());</span></a>
<a name="3235"><span class="lineNum">    3235 </span><span class="lineCov">      18722 :                          if (templateInstantiationDirectiveStatement != NULL)</span></a>
<a name="3236"><span class="lineNum">    3236 </span>            :                             {</a>
<a name="3237"><span class="lineNum">    3237 </span><span class="lineNoCov">          0 :                               mfprintf(mlog [ WARN ] ) (&quot;******** Found a variable template instantiation that is a part of a SgTemplateInstantiationDirectiveStatement \n&quot;);</span></a>
<a name="3238"><span class="lineNum">    3238 </span>            : #if 1</a>
<a name="3239"><span class="lineNum">    3239 </span><span class="lineNoCov">          0 :                               mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</span></a>
<a name="3240"><span class="lineNum">    3240 </span><span class="lineNoCov">          0 :                               ROSE_ABORT();</span></a>
<a name="3241"><span class="lineNum">    3241 </span>            : #endif</a>
<a name="3242"><span class="lineNum">    3242 </span>            :                             }</a>
<a name="3243"><span class="lineNum">    3243 </span>            : </a>
<a name="3244"><span class="lineNum">    3244 </span>            : #if 0</a>
<a name="3245"><span class="lineNum">    3245 </span>            :                       // DQ (8/21/2012): This is better fixed by another method that elimiated a redundant SgBasicBlock that was being generated (in edgRose.C).</a>
<a name="3246"><span class="lineNum">    3246 </span>            :                       // DQ (8/20/2012): Check that we have the correct symbol.</a>
<a name="3247"><span class="lineNum">    3247 </span>            :                          if (variableSymbol != NULL)</a>
<a name="3248"><span class="lineNum">    3248 </span>            :                             {</a>
<a name="3249"><span class="lineNum">    3249 </span>            :                            // DQ (8/20/2012): If this is NON-NULL then we still have to check that it is the correct symbol (see test2011_31.C).</a>
<a name="3250"><span class="lineNum">    3250 </span>            :                            // SgInitializedName* declarationForVariableAssociatedWithSymbol = variableSymbol-&gt;get_declaration();</a>
<a name="3251"><span class="lineNum">    3251 </span>            :                               SgInitializedName* initializedNameForVariableAssociatedWithSymbol = variableSymbol-&gt;get_declaration();</a>
<a name="3252"><span class="lineNum">    3252 </span>            :                               ASSERT_not_null(initializedNameForVariableAssociatedWithSymbol);</a>
<a name="3253"><span class="lineNum">    3253 </span>            :                               SgInitializedName* currentVariableDeclarationInitializedName = SageInterface::getFirstInitializedName(variableDeclaration);</a>
<a name="3254"><span class="lineNum">    3254 </span>            :                               ASSERT_not_null(currentVariableDeclarationInitializedName);</a>
<a name="3255"><span class="lineNum">    3255 </span>            : </a>
<a name="3256"><span class="lineNum">    3256 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;initializedNameForVariableAssociatedWithSymbol = %p \n&quot;,initializedNameForVariableAssociatedWithSymbol);</a>
<a name="3257"><span class="lineNum">    3257 </span>            :                               initializedNameForVariableAssociatedWithSymbol-&gt;get_startOfConstruct()-&gt;display(&quot;initializedNameForVariableAssociatedWithSymbol&quot;);</a>
<a name="3258"><span class="lineNum">    3258 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;currentVariableDeclarationInitializedName      = %p \n&quot;,currentVariableDeclarationInitializedName);</a>
<a name="3259"><span class="lineNum">    3259 </span>            :                               currentVariableDeclarationInitializedName-&gt;get_startOfConstruct()-&gt;display(&quot;currentVariableDeclarationInitializedName&quot;);</a>
<a name="3260"><span class="lineNum">    3260 </span>            : </a>
<a name="3261"><span class="lineNum">    3261 </span>            :                               if (initializedNameForVariableAssociatedWithSymbol != currentVariableDeclarationInitializedName)</a>
<a name="3262"><span class="lineNum">    3262 </span>            :                                  {</a>
<a name="3263"><span class="lineNum">    3263 </span>            :                                 // If this is not the correct then rest the variableSymbol to NULL and look for another symbol in an outer scope.</a>
<a name="3264"><span class="lineNum">    3264 </span>            :                                    variableSymbol = NULL;</a>
<a name="3265"><span class="lineNum">    3265 </span>            :                                  }</a>
<a name="3266"><span class="lineNum">    3266 </span>            :                             }</a>
<a name="3267"><span class="lineNum">    3267 </span>            : #endif</a>
<a name="3268"><span class="lineNum">    3268 </span><span class="lineCov">      18722 :                          if (variableSymbol == NULL)</span></a>
<a name="3269"><span class="lineNum">    3269 </span>            :                             {</a>
<a name="3270"><span class="lineNum">    3270 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="3271"><span class="lineNum">    3271 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;Type elaboration is required: declaration = %s symbol = %s \n&quot;,declaration-&gt;class_name().c_str(),symbol-&gt;class_name().c_str());</a>
<a name="3272"><span class="lineNum">    3272 </span>            : #endif</a>
<a name="3273"><span class="lineNum">    3273 </span><span class="lineCov">        135 :                               typeElaborationIsRequired = true;</span></a>
<a name="3274"><span class="lineNum">    3274 </span>            : </a>
<a name="3275"><span class="lineNum">    3275 </span>            :                            // Reset the symbol to one that will match the declaration.</a>
<a name="3276"><span class="lineNum">    3276 </span>            :                            // symbol = SageInterface::lookupVariableSymbolInParentScopes(name,currentScope);</a>
<a name="3277"><span class="lineNum">    3277 </span><span class="lineCov">        135 :                               variableSymbol = SageInterface::lookupVariableSymbolInParentScopes(name,currentScope);</span></a>
<a name="3278"><span class="lineNum">    3278 </span>            :                            // if (symbol != NULL)</a>
<a name="3279"><span class="lineNum">    3279 </span><span class="lineCov">        135 :                               if (variableSymbol != NULL)</span></a>
<a name="3280"><span class="lineNum">    3280 </span>            :                                  {</a>
<a name="3281"><span class="lineNum">    3281 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="3282"><span class="lineNum">    3282 </span>            :                                 // mfprintf(mlog [ WARN ] ) (&quot;Lookup symbol based symbol type: reset symbol = %p = %s \n&quot;,symbol,symbol-&gt;class_name().c_str());</a>
<a name="3283"><span class="lineNum">    3283 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;Lookup symbol based symbol type: reset symbol = %p = %s \n&quot;,variableSymbol,variableSymbol-&gt;class_name().c_str());</a>
<a name="3284"><span class="lineNum">    3284 </span>            : #endif</a>
<a name="3285"><span class="lineNum">    3285 </span>            :                                    symbol = variableSymbol;</a>
<a name="3286"><span class="lineNum">    3286 </span>            :                                  }</a>
<a name="3287"><span class="lineNum">    3287 </span>            :                                 else</a>
<a name="3288"><span class="lineNum">    3288 </span>            :                                  {</a>
<a name="3289"><span class="lineNum">    3289 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="3290"><span class="lineNum">    3290 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::nameQualificationDepth(): variableSymbol == NULL \n&quot;);</a>
<a name="3291"><span class="lineNum">    3291 </span>            : #endif</a>
<a name="3292"><span class="lineNum">    3292 </span>            : #if 0</a>
<a name="3293"><span class="lineNum">    3293 </span>            :                                 // DQ (8/13/2013): The function lookupTemplateSymbolInParentScopes() has been removed from the API</a>
<a name="3294"><span class="lineNum">    3294 </span>            :                                 // (it would have required template parameters and template arguments that are not available here).</a>
<a name="3295"><span class="lineNum">    3295 </span>            :                                 // Look for a template symbol</a>
<a name="3296"><span class="lineNum">    3296 </span>            :                                    symbol = SageInterface::lookupTemplateSymbolInParentScopes(name,currentScope);</a>
<a name="3297"><span class="lineNum">    3297 </span>            : #else</a>
<a name="3298"><span class="lineNum">    3298 </span>            : #if 0</a>
<a name="3299"><span class="lineNum">    3299 </span>            :                                 // DQ (8/13/2013): Output the source position of this problem.</a>
<a name="3300"><span class="lineNum">    3300 </span>            :                                    ASSERT_not_null(variableDeclaration-&gt;get_file_info());</a>
<a name="3301"><span class="lineNum">    3301 </span>            :                                    variableDeclaration-&gt;get_file_info()-&gt;display(&quot;variableDeclaration: debug&quot;);</a>
<a name="3302"><span class="lineNum">    3302 </span>            : #endif</a>
<a name="3303"><span class="lineNum">    3303 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="3304"><span class="lineNum">    3304 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;WARNING: In NameQualificationTraversal::nameQualificationDepth(): variableSymbol == NULL: searching for the associated symbol using the declaration \n&quot;);</a>
<a name="3305"><span class="lineNum">    3305 </span>            : #endif</a>
<a name="3306"><span class="lineNum">    3306 </span>            :                                 // DQ (8/14/2013): Use an alternative mechanism to get the correct symbol more directly</a>
<a name="3307"><span class="lineNum">    3307 </span>            :                                 // (might be more expensive, or perhaps this mechanism should be used more generally in</a>
<a name="3308"><span class="lineNum">    3308 </span>            :                                 // this name qualification support).</a>
<a name="3309"><span class="lineNum">    3309 </span><span class="lineCov">        135 :                                    SgInitializedName* currentVariableDeclarationInitializedName = SageInterface::getFirstInitializedName(variableDeclaration);</span></a>
<a name="3310"><span class="lineNum">    3310 </span><span class="lineCov">        135 :                                    ASSERT_not_null(currentVariableDeclarationInitializedName);</span></a>
<a name="3311"><span class="lineNum">    3311 </span>            : </a>
<a name="3312"><span class="lineNum">    3312 </span>            : #if 0</a>
<a name="3313"><span class="lineNum">    3313 </span>            :                                 // DQ (4/7/2014): We should not be resolving a symbol if we didn't find the correct symbol (see test2014_39.C).</a>
<a name="3314"><span class="lineNum">    3314 </span>            :                                    symbol = currentVariableDeclarationInitializedName-&gt;search_for_symbol_from_symbol_table();</a>
<a name="3315"><span class="lineNum">    3315 </span>            :                                    ASSERT_not_null(symbol);</a>
<a name="3316"><span class="lineNum">    3316 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="3317"><span class="lineNum">    3317 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::nameQualificationDepth(): variableSymbol != NULL: variableDeclaration = %p symbol = %p = %s \n&quot;,variableDeclaration,symbol,symbol-&gt;class_name().c_str());</a>
<a name="3318"><span class="lineNum">    3318 </span>            : #endif</a>
<a name="3319"><span class="lineNum">    3319 </span>            : #else</a>
<a name="3320"><span class="lineNum">    3320 </span>            :                                 // DQ (4/7/2014): Reset the symbol to NULL (snce we didn't find an associated SgVariableSymbol).</a>
<a name="3321"><span class="lineNum">    3321 </span>            :                                 // In the switch statement (below) we will use the declaration to obtain the correct</a>
<a name="3322"><span class="lineNum">    3322 </span>            :                                 // symbol and then compare if we have found the correct one using the name lookup through</a>
<a name="3323"><span class="lineNum">    3323 </span>            :                                 // parent scopes.  Then we will beable to know if name qualification is required. If we</a>
<a name="3324"><span class="lineNum">    3324 </span>            :                                 // use the declaration to find the symbol here, then we will detect that no name</a>
<a name="3325"><span class="lineNum">    3325 </span>            :                                 // qualification is required (where it might be).  Testcode test2014_39.C demonstrates</a>
<a name="3326"><span class="lineNum">    3326 </span>            :                                 // this issue.</a>
<a name="3327"><span class="lineNum">    3327 </span><span class="lineCov">        135 :                                    symbol = NULL;</span></a>
<a name="3328"><span class="lineNum">    3328 </span>            : #endif</a>
<a name="3329"><span class="lineNum">    3329 </span>            : #if 0</a>
<a name="3330"><span class="lineNum">    3330 </span>            :                                 // DQ (8/13/2013): I think this case should not come up if everything else works.  Since there are no templated variables I'm not sure what to do here.</a>
<a name="3331"><span class="lineNum">    3331 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;Error: In NameQualificationTraversal::nameQualificationDepth(): variableSymbol == NULL: I think we should not have to support this case! \n&quot;);</a>
<a name="3332"><span class="lineNum">    3332 </span>            :                                    ROSE_ABORT();</a>
<a name="3333"><span class="lineNum">    3333 </span>            : #endif</a>
<a name="3334"><span class="lineNum">    3334 </span>            : #endif</a>
<a name="3335"><span class="lineNum">    3335 </span>            :                                 // DQ (6/5/2011): This assert fails for test2005_107.C (this is OK, the referenced symbol is not visible from the current scope).</a>
<a name="3336"><span class="lineNum">    3336 </span>            :                                 // ASSERT_not_null(symbol);</a>
<a name="3337"><span class="lineNum">    3337 </span>            :                                  }</a>
<a name="3338"><span class="lineNum">    3338 </span>            :                            // ASSERT_not_null(symbol);</a>
<a name="3339"><span class="lineNum">    3339 </span>            :                            // mfprintf(mlog [ WARN ] ) (&quot;Lookup symbol based symbol type: reset symbol = %p = %s \n&quot;,symbol,symbol-&gt;class_name().c_str());</a>
<a name="3340"><span class="lineNum">    3340 </span>            :                             }</a>
<a name="3341"><span class="lineNum">    3341 </span>            : </a>
<a name="3342"><span class="lineNum">    3342 </span>            :                          break;</a>
<a name="3343"><span class="lineNum">    3343 </span>            :                        }</a>
<a name="3344"><span class="lineNum">    3344 </span>            : </a>
<a name="3345"><span class="lineNum">    3345 </span><span class="lineCov">       6363 :                     case V_SgNonrealDecl:</span></a>
<a name="3346"><span class="lineNum">    3346 </span><span class="lineCov">       6363 :                        {</span></a>
<a name="3347"><span class="lineNum">    3347 </span>            : #if 0</a>
<a name="3348"><span class="lineNum">    3348 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::nameQualificationDepth(): Found a case of declaration == SgNonrealDecl =&gt; return 0\n&quot;);</a>
<a name="3349"><span class="lineNum">    3349 </span>            : #endif</a>
<a name="3350"><span class="lineNum">    3350 </span><span class="lineCov">       6363 :                          ASSERT_not_null(symbol);</span></a>
<a name="3351"><span class="lineNum">    3351 </span><span class="lineCov">       6363 :                          if (!isSgNonrealSymbol(symbol)) {</span></a>
<a name="3352"><span class="lineNum">    3352 </span><span class="lineCov">       3760 :                            symbol = SageInterface::lookupNonrealSymbolInParentScopes(name,currentScope,templateParameterList,templateArgumentList);</span></a>
<a name="3353"><span class="lineNum">    3353 </span>            :                          }</a>
<a name="3354"><span class="lineNum">    3354 </span>            : </a>
<a name="3355"><span class="lineNum">    3355 </span>            :                          break;</a>
<a name="3356"><span class="lineNum">    3356 </span>            :                        }</a>
<a name="3357"><span class="lineNum">    3357 </span>            : </a>
<a name="3358"><span class="lineNum">    3358 </span>            :                     case V_SgProcedureHeaderStatement:</a>
<a name="3359"><span class="lineNum">    3359 </span>            :                        {</a>
<a name="3360"><span class="lineNum">    3360 </span>            :                          return 0;</a>
<a name="3361"><span class="lineNum">    3361 </span><span class="lineNoCov">          0 :                          break;</span></a>
<a name="3362"><span class="lineNum">    3362 </span>            :                        }</a>
<a name="3363"><span class="lineNum">    3363 </span>            : </a>
<a name="3364"><span class="lineNum">    3364 </span><span class="lineNoCov">          0 :                     default:</span></a>
<a name="3365"><span class="lineNum">    3365 </span><span class="lineNoCov">          0 :                        {</span></a>
<a name="3366"><span class="lineNum">    3366 </span>            :                       // Handle cases are we work through specific example codes.</a>
<a name="3367"><span class="lineNum">    3367 </span>            :                       // mfprintf(mlog [ WARN ] ) (&quot;default reached symbol = %s \n&quot;,symbol-&gt;class_name().c_str());</a>
<a name="3368"><span class="lineNum">    3368 </span><span class="lineNoCov">          0 :                          mfprintf(mlog [ WARN ] ) (&quot;default reached declaration = %p = %s \n&quot;,declaration,declaration-&gt;class_name().c_str());</span></a>
<a name="3369"><span class="lineNum">    3369 </span><span class="lineNoCov">          0 :                          ROSE_ABORT();</span></a>
<a name="3370"><span class="lineNum">    3370 </span>            :                        }</a>
<a name="3371"><span class="lineNum">    3371 </span>            :                   }</a>
<a name="3372"><span class="lineNum">    3372 </span>            :              }</a>
<a name="3373"><span class="lineNum">    3373 </span>            :             else</a>
<a name="3374"><span class="lineNum">    3374 </span>            :              {</a>
<a name="3375"><span class="lineNum">    3375 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="3376"><span class="lineNum">    3376 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;SageInterface::lookupSymbolInParentScopes(name,currentScope) returned NULL \n&quot;);</a>
<a name="3377"><span class="lineNum">    3377 </span>            : #endif</a>
<a name="3378"><span class="lineNum">    3378 </span>            :              }</a>
<a name="3379"><span class="lineNum">    3379 </span>            : </a>
<a name="3380"><span class="lineNum">    3380 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="3381"><span class="lineNum">    3381 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;2222222222222222222222222222222222222222222222222222222222222222222 \n&quot;);</a>
<a name="3382"><span class="lineNum">    3382 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Calling evaluateTemplateInstantiationDeclaration() from nameQualificationDepth() declaration = %p = %s currentScope = %p = %s \n&quot;,</a>
<a name="3383"><span class="lineNum">    3383 </span>            :                declaration,declaration-&gt;class_name().c_str(),currentScope,currentScope-&gt;class_name().c_str());</a>
<a name="3384"><span class="lineNum">    3384 </span>            : #endif</a>
<a name="3385"><span class="lineNum">    3385 </span>            : </a>
<a name="3386"><span class="lineNum">    3386 </span>            :        // Refactored this code to another member function so that it could also support evaluation of declarations found in types (more generally).</a>
<a name="3387"><span class="lineNum">    3387 </span><span class="lineCov">    1714820 :           evaluateTemplateInstantiationDeclaration(declaration,currentScope,positionStatement);</span></a>
<a name="3388"><span class="lineNum">    3388 </span>            : </a>
<a name="3389"><span class="lineNum">    3389 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="3390"><span class="lineNum">    3390 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;DONE: Calling evaluateTemplateInstantiationDeclaration() from nameQualificationDepth() declaration = %p = %s = %s currentScope = %p = %s \n&quot;,</a>
<a name="3391"><span class="lineNum">    3391 </span>            :                declaration,declaration-&gt;class_name().c_str(),SageInterface::get_name(declaration).c_str(),currentScope,currentScope-&gt;class_name().c_str());</a>
<a name="3392"><span class="lineNum">    3392 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;===== declaration-&gt;unparseToString() = %s \n&quot;,declaration-&gt;unparseToString().c_str());</a>
<a name="3393"><span class="lineNum">    3393 </span>            : #endif</a>
<a name="3394"><span class="lineNum">    3394 </span>            : </a>
<a name="3395"><span class="lineNum">    3395 </span>            : #if 0</a>
<a name="3396"><span class="lineNum">    3396 </span>            :        // DQ (4/14/2018): I think that this code might not be required here, noting to do at this location.</a>
<a name="3397"><span class="lineNum">    3397 </span>            :           SgTemplateInstantiationTypedefDeclaration* templateInstantiationTypedefDeclaration = isSgTemplateInstantiationTypedefDeclaration(typedefDeclaration);</a>
<a name="3398"><span class="lineNum">    3398 </span>            :           if (templateInstantiationTypedefDeclaration != NULL)</a>
<a name="3399"><span class="lineNum">    3399 </span>            :              {</a>
<a name="3400"><span class="lineNum">    3400 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;$$$$$$$$$$$$$$$$$$ Processing a SgTemplateInstantiationTypedefDeclaration $$$$$$$$$$$$$$$$$$$$$ \n&quot;);</a>
<a name="3401"><span class="lineNum">    3401 </span>            :             // Found a SgTemplateInstantiationTypedefDeclaration, we need to at least check the template arguments for name qualification.</a>
<a name="3402"><span class="lineNum">    3402 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Found a SgTemplateInstantiationTypedefDeclaration, we need to at least check the template arguments for name qualification \n&quot;);</a>
<a name="3403"><span class="lineNum">    3403 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;$$$$$$$$$$$$$$$$$$ DONE: Processing a SgTemplateInstantiationTypedefDeclaration $$$$$$$$$$$$$$$$$$$$$ \n&quot;);</a>
<a name="3404"><span class="lineNum">    3404 </span>            : #if 0</a>
<a name="3405"><span class="lineNum">    3405 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="3406"><span class="lineNum">    3406 </span>            :                ROSE_ABORT();</a>
<a name="3407"><span class="lineNum">    3407 </span>            : #endif</a>
<a name="3408"><span class="lineNum">    3408 </span>            :              }</a>
<a name="3409"><span class="lineNum">    3409 </span>            : #endif</a>
<a name="3410"><span class="lineNum">    3410 </span>            : </a>
<a name="3411"><span class="lineNum">    3411 </span>            : #if 0</a>
<a name="3412"><span class="lineNum">    3412 </span>            :           if (isSgTemplateInstantiationMemberFunctionDecl(declaration) != NULL)</a>
<a name="3413"><span class="lineNum">    3413 </span>            :              {</a>
<a name="3414"><span class="lineNum">    3414 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test: in nameQualificationDepth() \n&quot;);</a>
<a name="3415"><span class="lineNum">    3415 </span>            :                ROSE_ABORT();</a>
<a name="3416"><span class="lineNum">    3416 </span>            :              }</a>
<a name="3417"><span class="lineNum">    3417 </span>            : #endif</a>
<a name="3418"><span class="lineNum">    3418 </span>            : </a>
<a name="3419"><span class="lineNum">    3419 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="3420"><span class="lineNum">    3420 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::nameQualificationDepth(): symbol = %p \n&quot;,symbol);</a>
<a name="3421"><span class="lineNum">    3421 </span>            :           if (symbol != NULL)</a>
<a name="3422"><span class="lineNum">    3422 </span>            :              {</a>
<a name="3423"><span class="lineNum">    3423 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;   --- symbol = %s \n&quot;,symbol-&gt;class_name().c_str());</a>
<a name="3424"><span class="lineNum">    3424 </span>            :              }</a>
<a name="3425"><span class="lineNum">    3425 </span>            : #endif</a>
<a name="3426"><span class="lineNum">    3426 </span>            : </a>
<a name="3427"><span class="lineNum">    3427 </span>            :        // At this point if there was any ambiguity in the first matching symbol that was found, then</a>
<a name="3428"><span class="lineNum">    3428 </span>            :        // we have resolved this to the correct type of symbol (SgClassSymbol, SgFunctionSymbol, etc.).</a>
<a name="3429"><span class="lineNum">    3429 </span>            :        // Now we want to resolve it to the exact symbol that matches the declaration.</a>
<a name="3430"><span class="lineNum">    3430 </span><span class="lineCov">    1714820 :           if (symbol != NULL)</span></a>
<a name="3431"><span class="lineNum">    3431 </span>            :              {</a>
<a name="3432"><span class="lineNum">    3432 </span>            :             // DQ (5/6/2011): Now we have fixed derived class symbol tables to inject there base classes symbols into the derived class.</a>
<a name="3433"><span class="lineNum">    3433 </span><span class="lineCov">    1585060 :                SgAliasSymbol* aliasSymbol = isSgAliasSymbol(symbol);</span></a>
<a name="3434"><span class="lineNum">    3434 </span>            : </a>
<a name="3435"><span class="lineNum">    3435 </span>            :             // DQ (7/12/2014): The newer design of the symbol table handling means that we will never see a SgAliasSymbol at this level.</a>
<a name="3436"><span class="lineNum">    3436 </span><span class="lineCov">    1585060 :                ROSE_ASSERT(aliasSymbol == NULL);</span></a>
<a name="3437"><span class="lineNum">    3437 </span>            : #if 1</a>
<a name="3438"><span class="lineNum">    3438 </span>            :             // DQ (7/12/2014): debugging use of SgAliasSymbol.</a>
<a name="3439"><span class="lineNum">    3439 </span><span class="lineCov">    1585060 :                if (aliasSymbol != NULL)</span></a>
<a name="3440"><span class="lineNum">    3440 </span>            :                   {</a>
<a name="3441"><span class="lineNum">    3441 </span>            :                  // DQ (7/12/2014): The newer design of the symbol table handling means that we will never see a SgAliasSymbol at this level.</a>
<a name="3442"><span class="lineNum">    3442 </span>            :                     ROSE_ABORT();</a>
<a name="3443"><span class="lineNum">    3443 </span>            : #if 0 // [Robb Matzke 2021-03-24]</a>
<a name="3444"><span class="lineNum">    3444 </span>            :                     ASSERT_not_null(aliasSymbol-&gt;get_alias());</a>
<a name="3445"><span class="lineNum">    3445 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::nameQualificationDepth(): Detected a SgAliasSymbol: alias = %p baseSymbol = %p = %s \n&quot;,aliasSymbol,aliasSymbol-&gt;get_alias(),aliasSymbol-&gt;get_alias()-&gt;class_name().c_str());</a>
<a name="3446"><span class="lineNum">    3446 </span>            : #endif</a>
<a name="3447"><span class="lineNum">    3447 </span>            :                   }</a>
<a name="3448"><span class="lineNum">    3448 </span>            : #endif</a>
<a name="3449"><span class="lineNum">    3449 </span>            : </a>
<a name="3450"><span class="lineNum">    3450 </span>            : #if 0</a>
<a name="3451"><span class="lineNum">    3451 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Testing for a SgTemplateInstantiationFunctionDecl \n&quot;);</a>
<a name="3452"><span class="lineNum">    3452 </span>            :                if (isSgTemplateInstantiationFunctionDecl(declaration) != NULL)</a>
<a name="3453"><span class="lineNum">    3453 </span>            :                   {</a>
<a name="3454"><span class="lineNum">    3454 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="3455"><span class="lineNum">    3455 </span>            :                     ROSE_ASSERT(false);</a>
<a name="3456"><span class="lineNum">    3456 </span>            :                   }</a>
<a name="3457"><span class="lineNum">    3457 </span>            : #endif</a>
<a name="3458"><span class="lineNum">    3458 </span>            : </a>
<a name="3459"><span class="lineNum">    3459 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="3460"><span class="lineNum">    3460 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;forceMoreNameQualification = %s \n&quot;,forceMoreNameQualification ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="3461"><span class="lineNum">    3461 </span>            : #endif</a>
<a name="3462"><span class="lineNum">    3462 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) &amp;&amp; 0</a>
<a name="3463"><span class="lineNum">    3463 </span>            :                printf (&quot;In NameQualificationTraversal::nameQualificationDepth(): forceMoreNameQualification = %s \n&quot;,forceMoreNameQualification ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="3464"><span class="lineNum">    3464 </span>            :                printf (&quot;In NameQualificationTraversal::nameQualificationDepth(): declaration = %p = %s name = %s \n&quot;,</a>
<a name="3465"><span class="lineNum">    3465 </span>            :                     declaration,declaration-&gt;class_name().c_str(),SageInterface::get_name(declaration).c_str());</a>
<a name="3466"><span class="lineNum">    3466 </span>            :                printf (&quot;In NameQualificationTraversal::nameQualificationDepth(): currentScope = %p = %s name = %s \n&quot;,currentScope,</a>
<a name="3467"><span class="lineNum">    3467 </span>            :                     currentScope-&gt;class_name().c_str(),SageInterface::get_name(currentScope).c_str());</a>
<a name="3468"><span class="lineNum">    3468 </span>            :                printf (&quot;In NameQualificationTraversal::nameQualificationDepth(): positionStatement = %p = %s name = %s \n&quot;,positionStatement,</a>
<a name="3469"><span class="lineNum">    3469 </span>            :                     positionStatement-&gt;class_name().c_str(),SageInterface::get_name(positionStatement).c_str());</a>
<a name="3470"><span class="lineNum">    3470 </span>            : #endif</a>
<a name="3471"><span class="lineNum">    3471 </span>            : </a>
<a name="3472"><span class="lineNum">    3472 </span><span class="lineCov">    1585060 :                if (forceMoreNameQualification == true)</span></a>
<a name="3473"><span class="lineNum">    3473 </span>            :                   {</a>
<a name="3474"><span class="lineNum">    3474 </span>            :                  // If there is more than one symbol with the same name then name qualification is required to distinguish between them.</a>
<a name="3475"><span class="lineNum">    3475 </span>            :                  // The exception to this is overloaded member functions.  But might also be where type evaluation is required.</a>
<a name="3476"><span class="lineNum">    3476 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="3477"><span class="lineNum">    3477 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Found a case of ambiguity (forceMoreNameQualification == true) of declaration = %s in the currentScope = %p = %s = %s (trigger additional name qualifier). \n&quot;,</a>
<a name="3478"><span class="lineNum">    3478 </span>            :                          declaration-&gt;class_name().c_str(),currentScope,currentScope-&gt;class_name().c_str(),SageInterface::get_name(currentScope).c_str());</a>
<a name="3479"><span class="lineNum">    3479 </span>            : #endif</a>
<a name="3480"><span class="lineNum">    3480 </span><span class="lineCov">        155 :                     switch(declaration-&gt;variantT())</span></a>
<a name="3481"><span class="lineNum">    3481 </span>            :                        {</a>
<a name="3482"><span class="lineNum">    3482 </span><span class="lineNoCov">          0 :                          case V_SgFunctionDeclaration:</span></a>
<a name="3483"><span class="lineNum">    3483 </span><span class="lineNoCov">          0 :                             {</span></a>
<a name="3484"><span class="lineNum">    3484 </span>            :                            // DQ (7/25/2018): If in the original matching (for name collission) there was a match, then we need to force</a>
<a name="3485"><span class="lineNum">    3485 </span>            :                            // at least one more level of name qualification for functions since type elaboration can not be used to resolve</a>
<a name="3486"><span class="lineNum">    3486 </span>            :                            // an ambiguity on function (only makes sense for types).</a>
<a name="3487"><span class="lineNum">    3487 </span><span class="lineNoCov">          0 :                               qualificationDepth = nameQualificationDepthOfParent(declaration,currentScope,positionStatement) + 1;</span></a>
<a name="3488"><span class="lineNum">    3488 </span><span class="lineNoCov">          0 :                               break;</span></a>
<a name="3489"><span class="lineNum">    3489 </span>            :                             }</a>
<a name="3490"><span class="lineNum">    3490 </span>            : </a>
<a name="3491"><span class="lineNum">    3491 </span><span class="lineNoCov">          0 :                          case V_SgMemberFunctionDeclaration:</span></a>
<a name="3492"><span class="lineNum">    3492 </span><span class="lineNoCov">          0 :                             {</span></a>
<a name="3493"><span class="lineNum">    3493 </span>            :                            // Don't qualify member function defined in their associated class.</a>
<a name="3494"><span class="lineNum">    3494 </span><span class="lineNoCov">          0 :                               SgMemberFunctionDeclaration* memberFunctionDeclaration = isSgMemberFunctionDeclaration(declaration);</span></a>
<a name="3495"><span class="lineNum">    3495 </span><span class="lineNoCov">          0 :                               SgScopeStatement* structurallyAssociatedScope = isSgScopeStatement(memberFunctionDeclaration-&gt;get_parent());</span></a>
<a name="3496"><span class="lineNum">    3496 </span><span class="lineNoCov">          0 :                               ASSERT_not_null(structurallyAssociatedScope);</span></a>
<a name="3497"><span class="lineNum">    3497 </span>            : </a>
<a name="3498"><span class="lineNum">    3498 </span>            :                            // Note that structurallyAssociatedDeclaration could be NULL if the function declaration is in global scope.</a>
<a name="3499"><span class="lineNum">    3499 </span><span class="lineNoCov">          0 :                               SgDeclarationStatement* structurallyAssociatedDeclaration = associatedDeclaration(structurallyAssociatedScope);</span></a>
<a name="3500"><span class="lineNum">    3500 </span><span class="lineNoCov">          0 :                               SgDeclarationStatement* semanticallyAssociatedDeclaration = memberFunctionDeclaration-&gt;get_associatedClassDeclaration();</span></a>
<a name="3501"><span class="lineNum">    3501 </span>            : </a>
<a name="3502"><span class="lineNum">    3502 </span><span class="lineNoCov">          0 :                               ASSERT_not_null(semanticallyAssociatedDeclaration);</span></a>
<a name="3503"><span class="lineNum">    3503 </span>            : </a>
<a name="3504"><span class="lineNum">    3504 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="3505"><span class="lineNum">    3505 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;structurallyAssociatedDeclaration = %p \n&quot;,structurallyAssociatedDeclaration);</a>
<a name="3506"><span class="lineNum">    3506 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;semanticallyAssociatedDeclaration = %p \n&quot;,semanticallyAssociatedDeclaration);</a>
<a name="3507"><span class="lineNum">    3507 </span>            : #endif</a>
<a name="3508"><span class="lineNum">    3508 </span><span class="lineNoCov">          0 :                               if (structurallyAssociatedDeclaration != semanticallyAssociatedDeclaration)</span></a>
<a name="3509"><span class="lineNum">    3509 </span>            :                                  {</a>
<a name="3510"><span class="lineNum">    3510 </span>            :                                 // The associated class for the member function does not match its structural location so we require name qualification.</a>
<a name="3511"><span class="lineNum">    3511 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="3512"><span class="lineNum">    3512 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;The associated class for the member function does not match its structural location so we require name qualification \n&quot;);</a>
<a name="3513"><span class="lineNum">    3513 </span>            : #endif</a>
<a name="3514"><span class="lineNum">    3514 </span><span class="lineNoCov">          0 :                                    qualificationDepth = nameQualificationDepthOfParent(declaration,currentScope,positionStatement) + 1;</span></a>
<a name="3515"><span class="lineNum">    3515 </span>            :                                  }</a>
<a name="3516"><span class="lineNum">    3516 </span>            :                                 else</a>
<a name="3517"><span class="lineNum">    3517 </span>            :                                  {</a>
<a name="3518"><span class="lineNum">    3518 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="3519"><span class="lineNum">    3519 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;structurallyAssociatedDeclaration == semanticallyAssociatedDeclaration: qualificationDepth = %d \n&quot;,qualificationDepth);</a>
<a name="3520"><span class="lineNum">    3520 </span>            : #endif</a>
<a name="3521"><span class="lineNum">    3521 </span>            :                                 // DQ (4/27/2019): We need to force a level of qualification (I think).</a>
<a name="3522"><span class="lineNum">    3522 </span>            :                                 // DQ (4/28/2019): This does fix the ctor preinitialization list name qualification bug (represented by test2019_415.C).</a>
<a name="3523"><span class="lineNum">    3523 </span><span class="lineNoCov">          0 :                                    qualificationDepth += 1;</span></a>
<a name="3524"><span class="lineNum">    3524 </span>            : </a>
<a name="3525"><span class="lineNum">    3525 </span>            :                                 // DQ (4/28/2019): We can see that this is called twice, once from the SgInitialization's initializer, and once from the SgConstructorInitializer.</a>
<a name="3526"><span class="lineNum">    3526 </span>            : #if 0</a>
<a name="3527"><span class="lineNum">    3527 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;In nameQualificationDepth(): case V_SgMemberFunctionDeclaration: Incremented the qualificationDepth: declaration = %p = %s qualificationDepth = %d \n&quot;,</a>
<a name="3528"><span class="lineNum">    3528 </span>            :                                         declaration,declaration-&gt;class_name().c_str(),qualificationDepth);</a>
<a name="3529"><span class="lineNum">    3529 </span>            : #endif</a>
<a name="3530"><span class="lineNum">    3530 </span>            : #if 0</a>
<a name="3531"><span class="lineNum">    3531 </span>            :                                 // DQ (4/28/2019): Need to figure out how this is being called twice.</a>
<a name="3532"><span class="lineNum">    3532 </span>            :                                    static int counter = 0;</a>
<a name="3533"><span class="lineNum">    3533 </span>            :                                    if (counter &gt;= 1)</a>
<a name="3534"><span class="lineNum">    3534 </span>            :                                       {</a>
<a name="3535"><span class="lineNum">    3535 </span>            :                                         mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="3536"><span class="lineNum">    3536 </span>            :                                      // int* pointer = NULL;</a>
<a name="3537"><span class="lineNum">    3537 </span>            :                                      // *pointer = 42;</a>
<a name="3538"><span class="lineNum">    3538 </span>            :                                      // mfprintf(mlog [ WARN ] ) (&quot;*pointer = %d \n&quot;,*pointer);</a>
<a name="3539"><span class="lineNum">    3539 </span>            :                                         ROSE_ABORT();</a>
<a name="3540"><span class="lineNum">    3540 </span>            :                                      // ROSE_ABORT();</a>
<a name="3541"><span class="lineNum">    3541 </span>            :                                      // mfprintf(mlog [ WARN ] ) (&quot;Calling abort! \n&quot;);</a>
<a name="3542"><span class="lineNum">    3542 </span>            :                                      // abort();</a>
<a name="3543"><span class="lineNum">    3543 </span>            :                                       }</a>
<a name="3544"><span class="lineNum">    3544 </span>            :                                    counter++;</a>
<a name="3545"><span class="lineNum">    3545 </span>            : #endif</a>
<a name="3546"><span class="lineNum">    3546 </span>            :                                  }</a>
<a name="3547"><span class="lineNum">    3547 </span>            : </a>
<a name="3548"><span class="lineNum">    3548 </span>            :                               break;</a>
<a name="3549"><span class="lineNum">    3549 </span>            :                             }</a>
<a name="3550"><span class="lineNum">    3550 </span>            : </a>
<a name="3551"><span class="lineNum">    3551 </span><span class="lineCov">        155 :                          case V_SgEnumDeclaration:</span></a>
<a name="3552"><span class="lineNum">    3552 </span><span class="lineCov">        155 :                             {</span></a>
<a name="3553"><span class="lineNum">    3553 </span>            :                            // An Enum can have a tag and it will be the it scope and trigger unwanted name qualification.</a>
<a name="3554"><span class="lineNum">    3554 </span>            :                            // SgEnumDeclaration* enumDeclaration = isSgEnumDeclaration(declaration);</a>
<a name="3555"><span class="lineNum">    3555 </span>            : </a>
<a name="3556"><span class="lineNum">    3556 </span>            :                            // I think what we want to do is recognize when there enum declaration is declared directly in the typedef.</a>
<a name="3557"><span class="lineNum">    3557 </span>            :                            // We now make sure that name qualification is not called in this case, so we should not reach this point!</a>
<a name="3558"><span class="lineNum">    3558 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="3559"><span class="lineNum">    3559 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;Error: Skipping forced name qualification for enum types (sorry, not implemented) \n&quot;);</a>
<a name="3560"><span class="lineNum">    3560 </span>            : #endif</a>
<a name="3561"><span class="lineNum">    3561 </span>            :                            // DQ (5/30/2019): If we are forcing name qualification then I think we need to increment this variable.</a>
<a name="3562"><span class="lineNum">    3562 </span>            :                            // See test2019_448.C for an example of where this is needed.</a>
<a name="3563"><span class="lineNum">    3563 </span><span class="lineCov">        155 :                               qualificationDepth += 1;</span></a>
<a name="3564"><span class="lineNum">    3564 </span>            : #if 0</a>
<a name="3565"><span class="lineNum">    3565 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;case V_SgEnumDeclaration: after incrementing qualificationDepth: qualificationDepth = %d \n&quot;,qualificationDepth);</a>
<a name="3566"><span class="lineNum">    3566 </span>            : #endif</a>
<a name="3567"><span class="lineNum">    3567 </span>            :                            // We do reach this point in test2004_105.C</a>
<a name="3568"><span class="lineNum">    3568 </span>            :                            // ROSE_ASSERT(false);</a>
<a name="3569"><span class="lineNum">    3569 </span>            : </a>
<a name="3570"><span class="lineNum">    3570 </span><span class="lineCov">        155 :                               break;</span></a>
<a name="3571"><span class="lineNum">    3571 </span>            :                             }</a>
<a name="3572"><span class="lineNum">    3572 </span>            : </a>
<a name="3573"><span class="lineNum">    3573 </span><span class="lineNoCov">          0 :                          default:</span></a>
<a name="3574"><span class="lineNum">    3574 </span><span class="lineNoCov">          0 :                             {</span></a>
<a name="3575"><span class="lineNum">    3575 </span>            :                            // But we have to keep moving up the chain of scopes to see if the parent might also require qualification.</a>
<a name="3576"><span class="lineNum">    3576 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="3577"><span class="lineNum">    3577 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;We are forcing the name qualification so continue to resolve the name qualification depth... \n&quot;);</a>
<a name="3578"><span class="lineNum">    3578 </span>            : #endif</a>
<a name="3579"><span class="lineNum">    3579 </span><span class="lineNoCov">          0 :                               qualificationDepth = nameQualificationDepthOfParent(declaration,currentScope,positionStatement) + 1;</span></a>
<a name="3580"><span class="lineNum">    3580 </span>            :                             }</a>
<a name="3581"><span class="lineNum">    3581 </span>            :                        }</a>
<a name="3582"><span class="lineNum">    3582 </span>            :                   }</a>
<a name="3583"><span class="lineNum">    3583 </span>            :                  else</a>
<a name="3584"><span class="lineNum">    3584 </span>            :                   {</a>
<a name="3585"><span class="lineNum">    3585 </span>            :                  // The numberOfSymbols can be zero or one, because the symbol might not be the the current scope.</a>
<a name="3586"><span class="lineNum">    3586 </span>            :                  // If it is zero then it just means that the name is visible</a>
<a name="3587"><span class="lineNum">    3587 </span>            :                  // from the current scope by is not located in the current scope.  If it is one, then there is a</a>
<a name="3588"><span class="lineNum">    3588 </span>            :                  // symbol matching the name and we need to check if it is associated with the same declaration or not.</a>
<a name="3589"><span class="lineNum">    3589 </span>            : </a>
<a name="3590"><span class="lineNum">    3590 </span>            :                  // However, since symbol != NULL, the numberOfSymbols should be non-zero.</a>
<a name="3591"><span class="lineNum">    3591 </span>            :                  // ROSE_ASSERT(numberOfSymbols &gt; 0);</a>
<a name="3592"><span class="lineNum">    3592 </span>            : </a>
<a name="3593"><span class="lineNum">    3593 </span>            :                  // DQ (7/12/2014): The newer design of the symbol table handling means that we will never see a SgAliasSymbol at this level.</a>
<a name="3594"><span class="lineNum">    3594 </span><span class="lineCov">    1584910 :                     ROSE_ASSERT(aliasSymbol == NULL);</span></a>
<a name="3595"><span class="lineNum">    3595 </span>            : </a>
<a name="3596"><span class="lineNum">    3596 </span>            :                  // Not clear if we want to resolve this to another scope since the alias symbols scope</a>
<a name="3597"><span class="lineNum">    3597 </span>            :                  // is want might have to be qualified (not the scope of the aliased declaration).</a>
<a name="3598"><span class="lineNum">    3598 </span><span class="lineCov">    1584910 :                     if (aliasSymbol != NULL)</span></a>
<a name="3599"><span class="lineNum">    3599 </span>            :                        {</a>
<a name="3600"><span class="lineNum">    3600 </span>            :                       // DQ (7/12/2014): The newer design of the symbol table handling means that we will never see a SgAliasSymbol at this level.</a>
<a name="3601"><span class="lineNum">    3601 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;ERROR: The newer design of the symbol table handling means that we will never see a SgAliasSymbol at this level \n&quot;);</a>
<a name="3602"><span class="lineNum">    3602 </span>            :                          ROSE_ABORT();</a>
<a name="3603"><span class="lineNum">    3603 </span>            : </a>
<a name="3604"><span class="lineNum">    3604 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="3605"><span class="lineNum">    3605 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;Resetting the symbol to that stored in the SgAliasSymbol \n&quot;);</a>
<a name="3606"><span class="lineNum">    3606 </span>            : #endif</a>
<a name="3607"><span class="lineNum">    3607 </span>            :                          symbol = aliasSymbol-&gt;get_alias();</a>
<a name="3608"><span class="lineNum">    3608 </span>            : </a>
<a name="3609"><span class="lineNum">    3609 </span>            :                       // DQ (7/23/2011): If we can't assert this, then we need to loop through the chain of alias</a>
<a name="3610"><span class="lineNum">    3610 </span>            :                       // symbols to get to the non-alias (original) symbol.</a>
<a name="3611"><span class="lineNum">    3611 </span>            :                          ROSE_ASSERT(isSgAliasSymbol(symbol) == NULL);</a>
<a name="3612"><span class="lineNum">    3612 </span>            :                        }</a>
<a name="3613"><span class="lineNum">    3613 </span>            : </a>
<a name="3614"><span class="lineNum">    3614 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || 0</a>
<a name="3615"><span class="lineNum">    3615 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;AT SWITCH: symbol = %p = %s \n&quot;,symbol,symbol-&gt;class_name().c_str());</a>
<a name="3616"><span class="lineNum">    3616 </span>            : #endif</a>
<a name="3617"><span class="lineNum">    3617 </span><span class="lineCov">    1584910 :                     switch (symbol-&gt;variantT())</span></a>
<a name="3618"><span class="lineNum">    3618 </span>            :                        {</a>
<a name="3619"><span class="lineNum">    3619 </span>            :                       // DQ (12/27/2011): Added support for template class symbols.</a>
<a name="3620"><span class="lineNum">    3620 </span><span class="lineCov">     120768 :                          case V_SgTemplateClassSymbol:</span></a>
<a name="3621"><span class="lineNum">    3621 </span><span class="lineCov">     120768 :                          case V_SgClassSymbol:</span></a>
<a name="3622"><span class="lineNum">    3622 </span><span class="lineCov">     120768 :                             {</span></a>
<a name="3623"><span class="lineNum">    3623 </span><span class="lineCov">     120768 :                               SgClassSymbol* classSymbol = isSgClassSymbol(symbol);</span></a>
<a name="3624"><span class="lineNum">    3624 </span><span class="lineCov">     120768 :                               ASSERT_not_null(classSymbol);</span></a>
<a name="3625"><span class="lineNum">    3625 </span>            : </a>
<a name="3626"><span class="lineNum">    3626 </span>            :                            // This is a class symbol, check if the declaration is the same.</a>
<a name="3627"><span class="lineNum">    3627 </span>            :                            // SgClassDeclaration* associatedClassDeclaration = baseClass-&gt;get_base_class();</a>
<a name="3628"><span class="lineNum">    3628 </span><span class="lineCov">     120768 :                               SgClassDeclaration* associatedClassDeclaration = classSymbol-&gt;get_declaration();</span></a>
<a name="3629"><span class="lineNum">    3629 </span>            : </a>
<a name="3630"><span class="lineNum">    3630 </span><span class="lineCov">     120768 :                               ASSERT_not_null(classDeclaration);</span></a>
<a name="3631"><span class="lineNum">    3631 </span><span class="lineCov">     120768 :                               ASSERT_not_null(associatedClassDeclaration);</span></a>
<a name="3632"><span class="lineNum">    3632 </span>            : </a>
<a name="3633"><span class="lineNum">    3633 </span><span class="lineCov">     120768 :                               if (associatedClassDeclaration-&gt;get_firstNondefiningDeclaration() == classDeclaration-&gt;get_firstNondefiningDeclaration())</span></a>
<a name="3634"><span class="lineNum">    3634 </span>            :                                  {</a>
<a name="3635"><span class="lineNum">    3635 </span>            : // #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="3636"><span class="lineNum">    3636 </span>            : #if 0</a>
<a name="3637"><span class="lineNum">    3637 </span>            :                                 // This class is visible from where it is referenced.</a>
<a name="3638"><span class="lineNum">    3638 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;This class IS visible from where it is referenced \n&quot;);</a>
<a name="3639"><span class="lineNum">    3639 </span>            : </a>
<a name="3640"><span class="lineNum">    3640 </span>            :                                 // However, if this is a templated class then we have to dig deeper to identify if the template arguments require name qualification.</a>
<a name="3641"><span class="lineNum">    3641 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;symbol = %p = %s \n&quot;,symbol,symbol-&gt;class_name().c_str());</a>
<a name="3642"><span class="lineNum">    3642 </span>            : #endif</a>
<a name="3643"><span class="lineNum">    3643 </span>            : #if 0</a>
<a name="3644"><span class="lineNum">    3644 </span>            :                                 // DQ (1/24/2019): But we need to check if it is hidden by a base class or nested base class that would force name qualification.</a>
<a name="3645"><span class="lineNum">    3645 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;################## associatedClassDeclaration-&gt;get_name() = %s \n&quot;,associatedClassDeclaration-&gt;get_name().str());</a>
<a name="3646"><span class="lineNum">    3646 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;privateBaseClassSets.size()  = %zu \n&quot;,privateBaseClassSets.size());</a>
<a name="3647"><span class="lineNum">    3647 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;inaccessibleClassSets.size() = %zu \n&quot;,inaccessibleClassSets.size());</a>
<a name="3648"><span class="lineNum">    3648 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;currentScope = %p = %s \n&quot;,currentScope,currentScope-&gt;class_name().c_str());</a>
<a name="3649"><span class="lineNum">    3649 </span>            : #endif</a>
<a name="3650"><span class="lineNum">    3650 </span>            : #if 0</a>
<a name="3651"><span class="lineNum">    3651 </span>            :                                 // SgClassDeclaration* containingClassDeclaration = SageInterface::getEnclosingClassDeclaration(currentScope);</a>
<a name="3652"><span class="lineNum">    3652 </span>            :                                 // SgClassDefinition*  containingClassDefinition  = SageInterface::getEnclosingClassDefinition(currentScope);</a>
<a name="3653"><span class="lineNum">    3653 </span>            :                                 // SgClassDefinition*  containingClassDefinition  = TransformationSupport::getClassDefinition(currentScope);</a>
<a name="3654"><span class="lineNum">    3654 </span>            : </a>
<a name="3655"><span class="lineNum">    3655 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;currentScope = %p = %s \n&quot;,currentScope,currentScope-&gt;class_name().c_str());</a>
<a name="3656"><span class="lineNum">    3656 </span>            : </a>
<a name="3657"><span class="lineNum">    3657 </span>            :                                    SgScopeStatement*   scope                     = currentScope;</a>
<a name="3658"><span class="lineNum">    3658 </span>            :                                    SgClassDefinition*  containingClassDefinition = NULL;</a>
<a name="3659"><span class="lineNum">    3659 </span>            :                                    while (scope != NULL &amp;&amp; containingClassDefinition == NULL)</a>
<a name="3660"><span class="lineNum">    3660 </span>            :                                       {</a>
<a name="3661"><span class="lineNum">    3661 </span>            :                                         containingClassDefinition = isSgClassDefinition(scope);</a>
<a name="3662"><span class="lineNum">    3662 </span>            :                                      // SgScopeStatement* outer_scope = scope-&gt;get_scope();</a>
<a name="3663"><span class="lineNum">    3663 </span>            :                                         SgScopeStatement* outer_scope = SageInterface::getEnclosingScope(scope);</a>
<a name="3664"><span class="lineNum">    3664 </span>            : </a>
<a name="3665"><span class="lineNum">    3665 </span>            :                                         if (scope == outer_scope)</a>
<a name="3666"><span class="lineNum">    3666 </span>            :                                            {</a>
<a name="3667"><span class="lineNum">    3667 </span>            : #if 0</a>
<a name="3668"><span class="lineNum">    3668 </span>            :                                              mfprintf(mlog [ WARN ] ) (&quot;get_scope is not changed: scope = %p = %s \n&quot;,scope,scope-&gt;class_name().c_str());</a>
<a name="3669"><span class="lineNum">    3669 </span>            : #endif</a>
<a name="3670"><span class="lineNum">    3670 </span>            :                                            }</a>
<a name="3671"><span class="lineNum">    3671 </span>            :                                           else</a>
<a name="3672"><span class="lineNum">    3672 </span>            :                                            {</a>
<a name="3673"><span class="lineNum">    3673 </span>            :                                              scope = outer_scope;</a>
<a name="3674"><span class="lineNum">    3674 </span>            :                                            }</a>
<a name="3675"><span class="lineNum">    3675 </span>            :                                       }</a>
<a name="3676"><span class="lineNum">    3676 </span>            : #if 0</a>
<a name="3677"><span class="lineNum">    3677 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;containingClassDefinition = %p \n&quot;,containingClassDefinition);</a>
<a name="3678"><span class="lineNum">    3678 </span>            : #endif</a>
<a name="3679"><span class="lineNum">    3679 </span>            :                                    if (containingClassDefinition != NULL)</a>
<a name="3680"><span class="lineNum">    3680 </span>            :                                       {</a>
<a name="3681"><span class="lineNum">    3681 </span>            :                                         ASSERT_not_null(containingClassDefinition);</a>
<a name="3682"><span class="lineNum">    3682 </span>            :                                         SgClassDeclaration* containingClassDeclaration = containingClassDefinition-&gt;get_declaration();</a>
<a name="3683"><span class="lineNum">    3683 </span>            : #if 0</a>
<a name="3684"><span class="lineNum">    3684 </span>            :                                         mfprintf(mlog [ WARN ] ) (&quot;containingClassDeclaration = %p \n&quot;,containingClassDeclaration);</a>
<a name="3685"><span class="lineNum">    3685 </span>            : #endif</a>
<a name="3686"><span class="lineNum">    3686 </span>            :                                         if (containingClassDeclaration != NULL)</a>
<a name="3687"><span class="lineNum">    3687 </span>            :                                            {</a>
<a name="3688"><span class="lineNum">    3688 </span>            :                                              mfprintf(mlog [ WARN ] ) (&quot;################### containingClassDeclaration = %p = %s name = %s \n&quot;,containingClassDeclaration,</a>
<a name="3689"><span class="lineNum">    3689 </span>            :                                                   containingClassDeclaration-&gt;class_name().c_str(),containingClassDeclaration-&gt;get_name().str());</a>
<a name="3690"><span class="lineNum">    3690 </span>            :                                            }</a>
<a name="3691"><span class="lineNum">    3691 </span>            :                                       }</a>
<a name="3692"><span class="lineNum">    3692 </span>            : #endif</a>
<a name="3693"><span class="lineNum">    3693 </span>            : #if 0</a>
<a name="3694"><span class="lineNum">    3694 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;case V_SgClassSymbol: currentScope = %p = %s \n&quot;,currentScope,currentScope-&gt;class_name().c_str());</a>
<a name="3695"><span class="lineNum">    3695 </span>            : #endif</a>
<a name="3696"><span class="lineNum">    3696 </span>            :                                 // DQ (1/4/2020): This is the better implementation and it should be isolated into a seperate</a>
<a name="3697"><span class="lineNum">    3697 </span>            :                                 // function so that we can call it from the case V_SgTypedefSymbol and case V_SgEnumSymbol</a>
<a name="3698"><span class="lineNum">    3698 </span>            :                                 // (and maybe some other locations as well (generating more test codes to drive this would be helpful).</a>
<a name="3699"><span class="lineNum">    3699 </span>            : </a>
<a name="3700"><span class="lineNum">    3700 </span>            :                                 // DQ (1/4/2020): Need to check if there is an opportunity for an ambigous reference.</a>
<a name="3701"><span class="lineNum">    3701 </span>            :                                 // size_t numberOfAliasSymbols = currentScope-&gt;count_alias_symbol(name);</a>
<a name="3702"><span class="lineNum">    3702 </span>            :                                 // symbol = SageInterface::lookupTemplateSymbolInParentScopes(name,currentScope);</a>
<a name="3703"><span class="lineNum">    3703 </span>            :                                 // SgScopeStatement* scopeOfAssociatedTypedefDeclaration = associatedTypedefDeclaration-&gt;get_scope();</a>
<a name="3704"><span class="lineNum">    3704 </span>            :                                 // ASSERT_not_null(scopeOfAssociatedTypedefDeclaration);</a>
<a name="3705"><span class="lineNum">    3705 </span>            :                                 // size_t numberOfAliasSymbols = scopeOfAssociatedTypedefDeclaration-&gt;count_alias_symbol(name);</a>
<a name="3706"><span class="lineNum">    3706 </span><span class="lineCov">     120759 :                                    bool includeCurrentScope = true;</span></a>
<a name="3707"><span class="lineNum">    3707 </span><span class="lineCov">     120759 :                                    SgClassDefinition* current_classDefinition = SageInterface::getEnclosingNode&lt;SgClassDefinition&gt;(currentScope,includeCurrentScope);</span></a>
<a name="3708"><span class="lineNum">    3708 </span><span class="lineCov">     120759 :                                    if (current_classDefinition != NULL)</span></a>
<a name="3709"><span class="lineNum">    3709 </span>            :                                       {</a>
<a name="3710"><span class="lineNum">    3710 </span>            :                                      // DQ (2/4/2020): Check if there is an existing class in the current_classDefinition</a>
<a name="3711"><span class="lineNum">    3711 </span>            :                                      // (which is not an alias), and if so then we don't need to worry about any ambiguity.</a>
<a name="3712"><span class="lineNum">    3712 </span>            :                                      // See Cxx11_test/test2020_11.C for an example.</a>
<a name="3713"><span class="lineNum">    3713 </span>            :                                      // SgClassSymbol* lookupClassSymbol = current_classDefinition-&gt;lookup_class_symbol(name);</a>
<a name="3714"><span class="lineNum">    3714 </span><span class="lineCov">      53523 :                                         size_t symbolCount               = current_classDefinition-&gt;count_symbol(name);</span></a>
<a name="3715"><span class="lineNum">    3715 </span><span class="lineCov">      53523 :                                         size_t numberOfAliasSymbols      = current_classDefinition-&gt;count_alias_symbol(name);</span></a>
<a name="3716"><span class="lineNum">    3716 </span><span class="lineCov">      53523 :                                         ROSE_ASSERT(symbolCount &gt;= numberOfAliasSymbols);</span></a>
<a name="3717"><span class="lineNum">    3717 </span><span class="lineCov">      53523 :                                         size_t declarationsInThisScope = symbolCount - numberOfAliasSymbols;</span></a>
<a name="3718"><span class="lineNum">    3718 </span>            : #if 0</a>
<a name="3719"><span class="lineNum">    3719 </span>            :                                         mfprintf(mlog [ WARN ] ) (&quot;lookupClassSymbol = %p \n&quot;,lookupClassSymbol);</a>
<a name="3720"><span class="lineNum">    3720 </span>            :                                         if (lookupClassSymbol != NULL)</a>
<a name="3721"><span class="lineNum">    3721 </span>            :                                            {</a>
<a name="3722"><span class="lineNum">    3722 </span>            :                                              mfprintf(mlog [ WARN ] ) (&quot;lookupClassSymbol = %p = %s \n&quot;,lookupClassSymbol,lookupClassSymbol-&gt;class_name().c_str());</a>
<a name="3723"><span class="lineNum">    3723 </span>            :                                            }</a>
<a name="3724"><span class="lineNum">    3724 </span>            :                                         mfprintf(mlog [ WARN ] ) (&quot;symbolCount             = %zu \n&quot;,symbolCount);</a>
<a name="3725"><span class="lineNum">    3725 </span>            :                                         mfprintf(mlog [ WARN ] ) (&quot;numberOfAliasSymbols    = %zu \n&quot;,numberOfAliasSymbols);</a>
<a name="3726"><span class="lineNum">    3726 </span>            :                                         mfprintf(mlog [ WARN ] ) (&quot;declarationsInThisScope = %zu \n&quot;,declarationsInThisScope);</a>
<a name="3727"><span class="lineNum">    3727 </span>            : #endif</a>
<a name="3728"><span class="lineNum">    3728 </span>            :                                      // When all of the declarations are in base classes then there is an ambiguity to resolve.</a>
<a name="3729"><span class="lineNum">    3729 </span>            :                                      // if (lookupClassSymbol == NULL)</a>
<a name="3730"><span class="lineNum">    3730 </span><span class="lineCov">      53523 :                                         if (declarationsInThisScope == 0)</span></a>
<a name="3731"><span class="lineNum">    3731 </span>            :                                            {</a>
<a name="3732"><span class="lineNum">    3732 </span>            :                                           // size_t numberOfAliasSymbols = current_classDefinition-&gt;count_alias_symbol(name);</a>
<a name="3733"><span class="lineNum">    3733 </span>            : #if 0</a>
<a name="3734"><span class="lineNum">    3734 </span>            :                                              mfprintf(mlog [ WARN ] ) (&quot;case V_SgClassSymbol: numberOfAliasSymbols = %zu \n&quot;,numberOfAliasSymbols);</a>
<a name="3735"><span class="lineNum">    3735 </span>            : #endif</a>
<a name="3736"><span class="lineNum">    3736 </span><span class="lineCov">      48386 :                                              if (numberOfAliasSymbols &gt;= 2)</span></a>
<a name="3737"><span class="lineNum">    3737 </span>            :                                                 {</a>
<a name="3738"><span class="lineNum">    3738 </span>            : #if 0</a>
<a name="3739"><span class="lineNum">    3739 </span>            :                                                   mfprintf(mlog [ WARN ] ) (&quot;Detected numberOfAliasSymbols &gt;= 2: numberOfAliasSymbols = %zu \n&quot;,numberOfAliasSymbols);</a>
<a name="3740"><span class="lineNum">    3740 </span>            : #endif</a>
<a name="3741"><span class="lineNum">    3741 </span>            :                                                // DQ (1/4/2020): Comment out as test for test2020_11.C</a>
<a name="3742"><span class="lineNum">    3742 </span>            :                                                // qualificationDepth = nameQualificationDepthOfParent(declaration,currentScope,positionStatement) + 1;</a>
<a name="3743"><span class="lineNum">    3743 </span><span class="lineCov">        469 :                                                   qualificationDepth += 1;</span></a>
<a name="3744"><span class="lineNum">    3744 </span>            : </a>
<a name="3745"><span class="lineNum">    3745 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="3746"><span class="lineNum">    3746 </span>            :                                                   mfprintf(mlog [ WARN ] ) (&quot;   --- qualificationDepth = %d \n&quot;,qualificationDepth);</a>
<a name="3747"><span class="lineNum">    3747 </span>            : #endif</a>
<a name="3748"><span class="lineNum">    3748 </span>            :                                                 }</a>
<a name="3749"><span class="lineNum">    3749 </span>            :                                            }</a>
<a name="3750"><span class="lineNum">    3750 </span>            :                                       }</a>
<a name="3751"><span class="lineNum">    3751 </span>            : </a>
<a name="3752"><span class="lineNum">    3752 </span>            : #if 0</a>
<a name="3753"><span class="lineNum">    3753 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="3754"><span class="lineNum">    3754 </span>            :                                    ROSE_ABORT();</a>
<a name="3755"><span class="lineNum">    3755 </span>            : #endif</a>
<a name="3756"><span class="lineNum">    3756 </span>            : #if 0</a>
<a name="3757"><span class="lineNum">    3757 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;I think this is associated with a template, need to stop here! \n&quot;);</a>
<a name="3758"><span class="lineNum">    3758 </span>            :                                    ROSE_ABORT();</a>
<a name="3759"><span class="lineNum">    3759 </span>            : #endif</a>
<a name="3760"><span class="lineNum">    3760 </span>            :                                  }</a>
<a name="3761"><span class="lineNum">    3761 </span>            :                                 else</a>
<a name="3762"><span class="lineNum">    3762 </span>            :                                  {</a>
<a name="3763"><span class="lineNum">    3763 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="3764"><span class="lineNum">    3764 </span>            :                                 // The name does not match, so the associatedClassDeclaration is hidding the base class declaration.</a>
<a name="3765"><span class="lineNum">    3765 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;This class is NOT visible from where it is referenced (declaration with same name does not match) \n&quot;);</a>
<a name="3766"><span class="lineNum">    3766 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;   --- currentScope      = %p = %s \n&quot;,currentScope,currentScope-&gt;class_name().c_str());</a>
<a name="3767"><span class="lineNum">    3767 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;   --- positionStatement = %p = %s \n&quot;,positionStatement,positionStatement-&gt;class_name().c_str());</a>
<a name="3768"><span class="lineNum">    3768 </span>            : #endif</a>
<a name="3769"><span class="lineNum">    3769 </span>            :                                 // Now resolve how much name qualification is required; what ever is required for the parent plus 1.</a>
<a name="3770"><span class="lineNum">    3770 </span><span class="lineCov">          9 :                                    qualificationDepth = nameQualificationDepthOfParent(declaration,currentScope,positionStatement) + 1;</span></a>
<a name="3771"><span class="lineNum">    3771 </span>            : #if 0</a>
<a name="3772"><span class="lineNum">    3772 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;Exiting for unimplemented case (class) \n&quot;);</a>
<a name="3773"><span class="lineNum">    3773 </span>            :                                    ROSE_ABORT();</a>
<a name="3774"><span class="lineNum">    3774 </span>            : #endif</a>
<a name="3775"><span class="lineNum">    3775 </span>            :                                  }</a>
<a name="3776"><span class="lineNum">    3776 </span>            : </a>
<a name="3777"><span class="lineNum">    3777 </span>            :                               break;</a>
<a name="3778"><span class="lineNum">    3778 </span>            :                             }</a>
<a name="3779"><span class="lineNum">    3779 </span>            : </a>
<a name="3780"><span class="lineNum">    3780 </span><span class="lineCov">      52570 :                          case V_SgNamespaceSymbol:</span></a>
<a name="3781"><span class="lineNum">    3781 </span><span class="lineCov">      52570 :                             {</span></a>
<a name="3782"><span class="lineNum">    3782 </span><span class="lineCov">      52570 :                               SgNamespaceSymbol* namespaceSymbol = isSgNamespaceSymbol(symbol);</span></a>
<a name="3783"><span class="lineNum">    3783 </span><span class="lineCov">      52570 :                               ASSERT_not_null(namespaceSymbol);</span></a>
<a name="3784"><span class="lineNum">    3784 </span>            : #if 0</a>
<a name="3785"><span class="lineNum">    3785 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;This is the case of a namespace (sorry, not implemented) \n&quot;);</a>
<a name="3786"><span class="lineNum">    3786 </span>            :                               ROSE_ABORT();</a>
<a name="3787"><span class="lineNum">    3787 </span>            : #endif</a>
<a name="3788"><span class="lineNum">    3788 </span>            : #if 0</a>
<a name="3789"><span class="lineNum">    3789 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;namespaceSymbol = %p \n&quot;,namespaceSymbol);</a>
<a name="3790"><span class="lineNum">    3790 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;namespaceSymbol-&gt;get_declaration() = %p \n&quot;,namespaceSymbol-&gt;get_declaration());</a>
<a name="3791"><span class="lineNum">    3791 </span>            : #endif</a>
<a name="3792"><span class="lineNum">    3792 </span><span class="lineCov">      52570 :                               SgNamespaceDeclarationStatement*      associatedNamespaceDeclaration      = namespaceSymbol-&gt;get_declaration();</span></a>
<a name="3793"><span class="lineNum">    3793 </span><span class="lineCov">      52570 :                               SgNamespaceAliasDeclarationStatement* associatedNamespaceAliasDeclaration = namespaceSymbol-&gt;get_aliasDeclaration();</span></a>
<a name="3794"><span class="lineNum">    3794 </span>            : </a>
<a name="3795"><span class="lineNum">    3795 </span>            :                            // DQ (4/9/2018): Adding support for namespace alias.</a>
<a name="3796"><span class="lineNum">    3796 </span>            :                            // ASSERT_not_null(namespaceDeclaration);</a>
<a name="3797"><span class="lineNum">    3797 </span><span class="lineCov">      52570 :                               ROSE_ASSERT(namespaceDeclaration != NULL || namespaceAliasDeclaration != NULL);</span></a>
<a name="3798"><span class="lineNum">    3798 </span>            : </a>
<a name="3799"><span class="lineNum">    3799 </span>            :                            // DQ (4/9/2018): Adding support for namespace alias.</a>
<a name="3800"><span class="lineNum">    3800 </span>            :                            // ASSERT_not_null(associatedNamespaceDeclaration);</a>
<a name="3801"><span class="lineNum">    3801 </span><span class="lineCov">      52570 :                               ROSE_ASSERT(associatedNamespaceDeclaration != NULL || associatedNamespaceAliasDeclaration != NULL);</span></a>
<a name="3802"><span class="lineNum">    3802 </span>            : </a>
<a name="3803"><span class="lineNum">    3803 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || 0</a>
<a name="3804"><span class="lineNum">    3804 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;namespaceDeclaration                = %p \n&quot;,namespaceDeclaration);</a>
<a name="3805"><span class="lineNum">    3805 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;namespaceAliasDeclaration           = %p \n&quot;,namespaceAliasDeclaration);</a>
<a name="3806"><span class="lineNum">    3806 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;associatedNamespaceDeclaration      = %p \n&quot;,associatedNamespaceDeclaration);</a>
<a name="3807"><span class="lineNum">    3807 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;associatedNamespaceAliasDeclaration = %p \n&quot;,associatedNamespaceAliasDeclaration);</a>
<a name="3808"><span class="lineNum">    3808 </span>            : #endif</a>
<a name="3809"><span class="lineNum">    3809 </span>            :                            // if (associatedNamespaceDeclaration-&gt;get_firstNondefiningDeclaration() == namespaceDeclaration-&gt;get_firstNondefiningDeclaration())</a>
<a name="3810"><span class="lineNum">    3810 </span><span class="lineCov">     105140 :                               if (associatedNamespaceDeclaration != NULL &amp;&amp; namespaceDeclaration != NULL &amp;&amp;</span></a>
<a name="3811"><span class="lineNum">    3811 </span><span class="lineCov">      52570 :                                   associatedNamespaceDeclaration-&gt;get_firstNondefiningDeclaration() == namespaceDeclaration-&gt;get_firstNondefiningDeclaration())</span></a>
<a name="3812"><span class="lineNum">    3812 </span>            :                                  {</a>
<a name="3813"><span class="lineNum">    3813 </span>            :                                 // This class is visible from where it is referenced.</a>
<a name="3814"><span class="lineNum">    3814 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="3815"><span class="lineNum">    3815 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;This namespace IS visible from where it is referenced \n&quot;);</a>
<a name="3816"><span class="lineNum">    3816 </span>            : #endif</a>
<a name="3817"><span class="lineNum">    3817 </span>            :                                  }</a>
<a name="3818"><span class="lineNum">    3818 </span>            :                                 else</a>
<a name="3819"><span class="lineNum">    3819 </span>            :                                  {</a>
<a name="3820"><span class="lineNum">    3820 </span>            :                                 // DQ (4/9/2018): Added support for namespace alias.</a>
<a name="3821"><span class="lineNum">    3821 </span><span class="lineCov">       3078 :                                    if (associatedNamespaceAliasDeclaration != NULL &amp;&amp; namespaceAliasDeclaration != NULL &amp;&amp;</span></a>
<a name="3822"><span class="lineNum">    3822 </span><span class="lineNoCov">          0 :                                        associatedNamespaceAliasDeclaration-&gt;get_firstNondefiningDeclaration() == namespaceAliasDeclaration-&gt;get_firstNondefiningDeclaration())</span></a>
<a name="3823"><span class="lineNum">    3823 </span>            :                                       {</a>
<a name="3824"><span class="lineNum">    3824 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="3825"><span class="lineNum">    3825 </span>            :                                         mfprintf(mlog [ WARN ] ) (&quot;This namespace alias IS visible from where it is referenced \n&quot;);</a>
<a name="3826"><span class="lineNum">    3826 </span>            : #endif</a>
<a name="3827"><span class="lineNum">    3827 </span>            :                                       }</a>
<a name="3828"><span class="lineNum">    3828 </span>            :                                      else</a>
<a name="3829"><span class="lineNum">    3829 </span>            :                                       {</a>
<a name="3830"><span class="lineNum">    3830 </span>            :                                      // The name does not match, so the associatedClassDeclaration is hidding the base class declaration.</a>
<a name="3831"><span class="lineNum">    3831 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || 0</a>
<a name="3832"><span class="lineNum">    3832 </span>            :                                         mfprintf(mlog [ WARN ] ) (&quot;This namespace is NOT visible from where it is referenced (declaration with same name does not match) \n&quot;);</a>
<a name="3833"><span class="lineNum">    3833 </span>            :                                         mfprintf(mlog [ WARN ] ) (&quot;   --- currentScope      = %p = %s \n&quot;,currentScope,currentScope-&gt;class_name().c_str());</a>
<a name="3834"><span class="lineNum">    3834 </span>            :                                         mfprintf(mlog [ WARN ] ) (&quot;   --- positionStatement = %p = %s \n&quot;,positionStatement,positionStatement-&gt;class_name().c_str());</a>
<a name="3835"><span class="lineNum">    3835 </span>            : #endif</a>
<a name="3836"><span class="lineNum">    3836 </span>            :                                      // Now resolve how much name qualification is required; what ever is required for the parent plus 1.</a>
<a name="3837"><span class="lineNum">    3837 </span><span class="lineCov">       3078 :                                         qualificationDepth = nameQualificationDepthOfParent(declaration,currentScope,positionStatement) + 1;</span></a>
<a name="3838"><span class="lineNum">    3838 </span>            : #if 0</a>
<a name="3839"><span class="lineNum">    3839 </span>            :                                         mfprintf(mlog [ WARN ] ) (&quot;case (namespace): qualificationDepth = %d \n&quot;,qualificationDepth);</a>
<a name="3840"><span class="lineNum">    3840 </span>            : #endif</a>
<a name="3841"><span class="lineNum">    3841 </span>            : #if 0</a>
<a name="3842"><span class="lineNum">    3842 </span>            :                                         mfprintf(mlog [ WARN ] ) (&quot;Exiting for unimplemented case (namespace) \n&quot;);</a>
<a name="3843"><span class="lineNum">    3843 </span>            :                                         ROSE_ABORT();</a>
<a name="3844"><span class="lineNum">    3844 </span>            : #endif</a>
<a name="3845"><span class="lineNum">    3845 </span>            :                                       }</a>
<a name="3846"><span class="lineNum">    3846 </span>            :                                  }</a>
<a name="3847"><span class="lineNum">    3847 </span>            : </a>
<a name="3848"><span class="lineNum">    3848 </span>            : #if 0</a>
<a name="3849"><span class="lineNum">    3849 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;Exiting for unimplemented case (namespace alias) \n&quot;);</a>
<a name="3850"><span class="lineNum">    3850 </span>            :                               ROSE_ABORT();</a>
<a name="3851"><span class="lineNum">    3851 </span>            : #endif</a>
<a name="3852"><span class="lineNum">    3852 </span>            :                               break;</a>
<a name="3853"><span class="lineNum">    3853 </span>            :                             }</a>
<a name="3854"><span class="lineNum">    3854 </span>            : </a>
<a name="3855"><span class="lineNum">    3855 </span><span class="lineCov">      18587 :                          case V_SgTemplateVariableSymbol:</span></a>
<a name="3856"><span class="lineNum">    3856 </span><span class="lineCov">      18587 :                          case V_SgVariableSymbol:</span></a>
<a name="3857"><span class="lineNum">    3857 </span><span class="lineCov">      18587 :                             {</span></a>
<a name="3858"><span class="lineNum">    3858 </span><span class="lineCov">      18587 :                               SgVariableSymbol* variableSymbol = isSgVariableSymbol(symbol);</span></a>
<a name="3859"><span class="lineNum">    3859 </span><span class="lineCov">      18587 :                               ASSERT_not_null(variableSymbol);</span></a>
<a name="3860"><span class="lineNum">    3860 </span>            : </a>
<a name="3861"><span class="lineNum">    3861 </span>            :                            // This is a variable symbol, check if the declaration is the same.</a>
<a name="3862"><span class="lineNum">    3862 </span>            :                            // SgVariableDeclaration* associatedVariableDeclaration = variableSymbol-&gt;get_declaration();</a>
<a name="3863"><span class="lineNum">    3863 </span><span class="lineCov">      18587 :                               SgInitializedName* associatedInitializedName = variableSymbol-&gt;get_declaration();</span></a>
<a name="3864"><span class="lineNum">    3864 </span>            : </a>
<a name="3865"><span class="lineNum">    3865 </span><span class="lineCov">      18587 :                               ASSERT_not_null(variableDeclaration);</span></a>
<a name="3866"><span class="lineNum">    3866 </span><span class="lineCov">      18587 :                               ASSERT_not_null(associatedInitializedName);</span></a>
<a name="3867"><span class="lineNum">    3867 </span>            : </a>
<a name="3868"><span class="lineNum">    3868 </span>            :                            // if (associatedInitializedName-&gt;get_firstNondefiningDeclaration() == variableDeclaration-&gt;get_firstNondefiningDeclaration())</a>
<a name="3869"><span class="lineNum">    3869 </span><span class="lineCov">      18587 :                               if (associatedInitializedName == SageInterface::getFirstInitializedName(variableDeclaration))</span></a>
<a name="3870"><span class="lineNum">    3870 </span>            :                                  {</a>
<a name="3871"><span class="lineNum">    3871 </span>            :                                 // This variable is visible from where it is referenced.</a>
<a name="3872"><span class="lineNum">    3872 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="3873"><span class="lineNum">    3873 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;This variable IS visible from where it is referenced \n&quot;);</a>
<a name="3874"><span class="lineNum">    3874 </span>            : #endif</a>
<a name="3875"><span class="lineNum">    3875 </span>            :                                 // DQ (12/23/2015): Need to check if there is an opportunity for an ambigous reference.</a>
<a name="3876"><span class="lineNum">    3876 </span><span class="lineCov">      18587 :                                    size_t numberOfAliasSymbols = currentScope-&gt;count_alias_symbol(name);</span></a>
<a name="3877"><span class="lineNum">    3877 </span><span class="lineCov">      18587 :                                    if (numberOfAliasSymbols &gt;= 2)</span></a>
<a name="3878"><span class="lineNum">    3878 </span>            :                                       {</a>
<a name="3879"><span class="lineNum">    3879 </span><span class="lineNoCov">          0 :                                         qualificationDepth = nameQualificationDepthOfParent(declaration,currentScope,positionStatement) + 1;</span></a>
<a name="3880"><span class="lineNum">    3880 </span>            : </a>
<a name="3881"><span class="lineNum">    3881 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="3882"><span class="lineNum">    3882 </span>            :                                         mfprintf(mlog [ WARN ] ) (&quot;   --- qualificationDepth = %d \n&quot;,qualificationDepth);</a>
<a name="3883"><span class="lineNum">    3883 </span>            : #endif</a>
<a name="3884"><span class="lineNum">    3884 </span>            :                                       }</a>
<a name="3885"><span class="lineNum">    3885 </span>            :                                  }</a>
<a name="3886"><span class="lineNum">    3886 </span>            :                                 else</a>
<a name="3887"><span class="lineNum">    3887 </span>            :                                  {</a>
<a name="3888"><span class="lineNum">    3888 </span>            :                                 // The name does not match, so the associatedClassDeclaration is hidding the base class declaration.</a>
<a name="3889"><span class="lineNum">    3889 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="3890"><span class="lineNum">    3890 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;This variable is NOT visible from where it is referenced (declaration with same name does not match) \n&quot;);</a>
<a name="3891"><span class="lineNum">    3891 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;   --- currentScope      = %p = %s \n&quot;,currentScope,currentScope-&gt;class_name().c_str());</a>
<a name="3892"><span class="lineNum">    3892 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;   --- positionStatement = %p = %s \n&quot;,positionStatement,positionStatement-&gt;class_name().c_str());</a>
<a name="3893"><span class="lineNum">    3893 </span>            : #endif</a>
<a name="3894"><span class="lineNum">    3894 </span>            :                                 // Now resolve how much name qualification is required; what ever is required for the parent plus 1.</a>
<a name="3895"><span class="lineNum">    3895 </span><span class="lineNoCov">          0 :                                    qualificationDepth = nameQualificationDepthOfParent(declaration,currentScope,positionStatement) + 1;</span></a>
<a name="3896"><span class="lineNum">    3896 </span>            : #if 0</a>
<a name="3897"><span class="lineNum">    3897 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;Exiting for unimplemented case (class) \n&quot;);</a>
<a name="3898"><span class="lineNum">    3898 </span>            :                                    ROSE_ABORT();</a>
<a name="3899"><span class="lineNum">    3899 </span>            : #endif</a>
<a name="3900"><span class="lineNum">    3900 </span>            :                                  }</a>
<a name="3901"><span class="lineNum">    3901 </span>            : </a>
<a name="3902"><span class="lineNum">    3902 </span>            : #if 0</a>
<a name="3903"><span class="lineNum">    3903 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;This is the case of a variable (sorry, not implemented) \n&quot;);</a>
<a name="3904"><span class="lineNum">    3904 </span>            :                               ROSE_ABORT();</a>
<a name="3905"><span class="lineNum">    3905 </span>            : #endif</a>
<a name="3906"><span class="lineNum">    3906 </span>            :                               break;</a>
<a name="3907"><span class="lineNum">    3907 </span>            :                             }</a>
<a name="3908"><span class="lineNum">    3908 </span>            : </a>
<a name="3909"><span class="lineNum">    3909 </span>            :                       // DQ (12/28/2011): Added support for new template handling in the AST.</a>
<a name="3910"><span class="lineNum">    3910 </span><span class="lineCov">       9950 :                          case V_SgTemplateMemberFunctionSymbol:</span></a>
<a name="3911"><span class="lineNum">    3911 </span><span class="lineCov">       9950 :                          case V_SgTemplateFunctionSymbol:</span></a>
<a name="3912"><span class="lineNum">    3912 </span>            : </a>
<a name="3913"><span class="lineNum">    3913 </span><span class="lineCov">       9950 :                          case V_SgMemberFunctionSymbol:</span></a>
<a name="3914"><span class="lineNum">    3914 </span><span class="lineCov">       9950 :                          case V_SgFunctionSymbol:</span></a>
<a name="3915"><span class="lineNum">    3915 </span><span class="lineCov">       9950 :                             {</span></a>
<a name="3916"><span class="lineNum">    3916 </span><span class="lineCov">       9950 :                               SgFunctionSymbol* functionSymbol = isSgFunctionSymbol(symbol);</span></a>
<a name="3917"><span class="lineNum">    3917 </span><span class="lineCov">       9950 :                               ASSERT_not_null(functionSymbol);</span></a>
<a name="3918"><span class="lineNum">    3918 </span>            : </a>
<a name="3919"><span class="lineNum">    3919 </span><span class="lineCov">       9950 :                               ASSERT_not_null(functionDeclaration);</span></a>
<a name="3920"><span class="lineNum">    3920 </span>            : </a>
<a name="3921"><span class="lineNum">    3921 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="3922"><span class="lineNum">    3922 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;Case of SgFunctionSymbol or SgMemberFunctionSymbol: functionSymbol = %p = %s \n&quot;,functionSymbol,functionSymbol-&gt;class_name().c_str());</a>
<a name="3923"><span class="lineNum">    3923 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;   --- functionDeclaration = %p = %s = %s \n&quot;,functionDeclaration,functionDeclaration-&gt;class_name().c_str(),functionDeclaration-&gt;get_name().str());</a>
<a name="3924"><span class="lineNum">    3924 </span>            : #endif</a>
<a name="3925"><span class="lineNum">    3925 </span>            :                            // This is a function symbol, check if the declaration is the same.</a>
<a name="3926"><span class="lineNum">    3926 </span>            :                            // SgFunctionDeclaration* associatedFunctionDeclaration = functionSymbol-&gt;get_declaration();</a>
<a name="3927"><span class="lineNum">    3927 </span><span class="lineCov">       9950 :                               SgFunctionDeclaration* associatedFunctionDeclarationFromSymbol = functionSymbol-&gt;get_declaration();</span></a>
<a name="3928"><span class="lineNum">    3928 </span><span class="lineCov">       9950 :                               ASSERT_not_null(associatedFunctionDeclarationFromSymbol);</span></a>
<a name="3929"><span class="lineNum">    3929 </span>            : </a>
<a name="3930"><span class="lineNum">    3930 </span><span class="lineCov">       9950 :                               ASSERT_not_null(functionDeclaration);</span></a>
<a name="3931"><span class="lineNum">    3931 </span>            : </a>
<a name="3932"><span class="lineNum">    3932 </span>            :                            // DQ (11/19/2013): This is added to support testing cases where we would clearly fail the AST consistancy tests (e.g. LoopProcessing.C).</a>
<a name="3933"><span class="lineNum">    3933 </span>            :                            // I hate this work around, but I am hoping it will help identify a root cause of the problem.</a>
<a name="3934"><span class="lineNum">    3934 </span>            :                            // ASSERT_not_null(functionDeclaration-&gt;get_firstNondefiningDeclaration());</a>
<a name="3935"><span class="lineNum">    3935 </span><span class="lineCov">       9950 :                               if (functionDeclaration-&gt;get_firstNondefiningDeclaration() == NULL)</span></a>
<a name="3936"><span class="lineNum">    3936 </span>            :                                  {</a>
<a name="3937"><span class="lineNum">    3937 </span><span class="lineNoCov">          0 :                                    mfprintf(mlog [ WARN ] ) (&quot;***** ERROR: In NameQualificationTraversal::nameQualificationDepth(): we are supporting this case though it is a violation of the AST consistancy tests! ***** \n&quot;);</span></a>
<a name="3938"><span class="lineNum">    3938 </span><span class="lineNoCov">          0 :                                    return 0;</span></a>
<a name="3939"><span class="lineNum">    3939 </span>            :                                  }</a>
<a name="3940"><span class="lineNum">    3940 </span>            : </a>
<a name="3941"><span class="lineNum">    3941 </span>            :                            // DQ (11/18/2013): This is an assertion inside of get_declaration_associated_with_symbol() which we are now failing.</a>
<a name="3942"><span class="lineNum">    3942 </span><span class="lineCov">       9950 :                               ROSE_ASSERT(functionDeclaration-&gt;get_firstNondefiningDeclaration() == functionDeclaration-&gt;get_firstNondefiningDeclaration()-&gt;get_firstNondefiningDeclaration());</span></a>
<a name="3943"><span class="lineNum">    3943 </span>            : </a>
<a name="3944"><span class="lineNum">    3944 </span><span class="lineCov">       9950 :                               SgDeclarationStatement* declarationFromSymbol = functionDeclaration-&gt;get_declaration_associated_with_symbol();</span></a>
<a name="3945"><span class="lineNum">    3945 </span>            : #if 1</a>
<a name="3946"><span class="lineNum">    3946 </span>            :                            // DQ (11/18/2013): Try to reset this...</a>
<a name="3947"><span class="lineNum">    3947 </span><span class="lineCov">       9950 :                               if (declarationFromSymbol == NULL)</span></a>
<a name="3948"><span class="lineNum">    3948 </span>            :                                  {</a>
<a name="3949"><span class="lineNum">    3949 </span>            : #if 0</a>
<a name="3950"><span class="lineNum">    3950 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;In name qualification support: declarationFromSymbol == NULL: retry using functionDeclaration-&gt;get_firstNondefiningDeclaration() \n&quot;);</a>
<a name="3951"><span class="lineNum">    3951 </span>            : #endif</a>
<a name="3952"><span class="lineNum">    3952 </span><span class="lineNoCov">          0 :                                    declarationFromSymbol = functionDeclaration-&gt;get_firstNondefiningDeclaration()-&gt;get_declaration_associated_with_symbol();</span></a>
<a name="3953"><span class="lineNum">    3953 </span>            :                                  }</a>
<a name="3954"><span class="lineNum">    3954 </span>            : #endif</a>
<a name="3955"><span class="lineNum">    3955 </span><span class="lineCov">       9950 :                               ASSERT_not_null(declarationFromSymbol);</span></a>
<a name="3956"><span class="lineNum">    3956 </span>            : </a>
<a name="3957"><span class="lineNum">    3957 </span><span class="lineCov">       9950 :                               SgFunctionDeclaration* functionDeclarationFromSymbol = isSgFunctionDeclaration(declarationFromSymbol);</span></a>
<a name="3958"><span class="lineNum">    3958 </span><span class="lineCov">       9950 :                               ASSERT_not_null(functionDeclarationFromSymbol);</span></a>
<a name="3959"><span class="lineNum">    3959 </span>            : </a>
<a name="3960"><span class="lineNum">    3960 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="3961"><span class="lineNum">    3961 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;associatedFunctionDeclarationFromSymbol                 = %p = %s \n&quot;,associatedFunctionDeclarationFromSymbol,associatedFunctionDeclarationFromSymbol-&gt;class_name().c_str());</a>
<a name="3962"><span class="lineNum">    3962 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;--- associatedFunctionDeclarationFromSymbol-&gt;get_name() = %s \n&quot;,associatedFunctionDeclarationFromSymbol-&gt;get_name().str());</a>
<a name="3963"><span class="lineNum">    3963 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;functionDeclarationFromSymbol                           = %p = %s \n&quot;,functionDeclarationFromSymbol,functionDeclarationFromSymbol-&gt;class_name().c_str());</a>
<a name="3964"><span class="lineNum">    3964 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;--- functionDeclarationFromSymbol-&gt;get_name()           = %s \n&quot;,functionDeclarationFromSymbol-&gt;get_name().str());</a>
<a name="3965"><span class="lineNum">    3965 </span>            : </a>
<a name="3966"><span class="lineNum">    3966 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;associatedFunctionDeclarationFromSymbol-&gt;get_firstNondefiningDeclaration() = %p \n&quot;,associatedFunctionDeclarationFromSymbol-&gt;get_firstNondefiningDeclaration());</a>
<a name="3967"><span class="lineNum">    3967 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;functionDeclarationFromSymbol-&gt;get_firstNondefiningDeclaration()           = %p \n&quot;,functionDeclarationFromSymbol-&gt;get_firstNondefiningDeclaration());</a>
<a name="3968"><span class="lineNum">    3968 </span>            :                               if (associatedFunctionDeclarationFromSymbol-&gt;get_firstNondefiningDeclaration() == NULL)</a>
<a name="3969"><span class="lineNum">    3969 </span>            :                                  {</a>
<a name="3970"><span class="lineNum">    3970 </span>            :                                 // DQ (6/22/2011): This is the case when a function has only a defining declaration and in this case no nondefining declaration is built for a function.</a>
<a name="3971"><span class="lineNum">    3971 </span>            :                                 // This is true for both SgFunctionDeclaration and SgMemberFunctionDeclaration handling (but may change to be more uniform with other declarations in the future).</a>
<a name="3972"><span class="lineNum">    3972 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;Found a valid function with get_firstNondefiningDeclaration() == NULL (not a problem, just a special case)\n&quot;);</a>
<a name="3973"><span class="lineNum">    3973 </span>            :                                  }</a>
<a name="3974"><span class="lineNum">    3974 </span>            : #endif</a>
<a name="3975"><span class="lineNum">    3975 </span>            : </a>
<a name="3976"><span class="lineNum">    3976 </span>            :                            // if (associatedFunctionDeclaration-&gt;get_firstNondefiningDeclaration() == functionDeclaration-&gt;get_firstNondefiningDeclaration())</a>
<a name="3977"><span class="lineNum">    3977 </span><span class="lineCov">       9950 :                               if (associatedFunctionDeclarationFromSymbol == functionDeclarationFromSymbol)</span></a>
<a name="3978"><span class="lineNum">    3978 </span>            :                                  {</a>
<a name="3979"><span class="lineNum">    3979 </span>            :                                 // DQ (4/12/2014): Now we know that it can be found, but we still need to check if there would</a>
<a name="3980"><span class="lineNum">    3980 </span>            :                                 // be another function that could be used and for which we need name qualification to avoid.</a>
<a name="3981"><span class="lineNum">    3981 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) &amp;&amp; 0</a>
<a name="3982"><span class="lineNum">    3982 </span>            :                                    printf (&quot;Using foundAnOverloadedFunctionWithSameName = %s \n&quot;,foundAnOverloadedFunctionWithSameName ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="3983"><span class="lineNum">    3983 </span>            :                                    printf (&quot;Using foundAnOverloadedFunctionInSameScope  = %s \n&quot;,foundAnOverloadedFunctionInSameScope  ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="3984"><span class="lineNum">    3984 </span>            : #endif</a>
<a name="3985"><span class="lineNum">    3985 </span>            :                                 // DQ (4/12/2014): We need to use the recorded value foundAnOverloadedFunctionWithSameName because we may want to have force name qualification.</a>
<a name="3986"><span class="lineNum">    3986 </span><span class="lineCov">       9440 :                                    if (foundAnOverloadedFunctionWithSameName == true)</span></a>
<a name="3987"><span class="lineNum">    3987 </span>            :                                       {</a>
<a name="3988"><span class="lineNum">    3988 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="3989"><span class="lineNum">    3989 </span>            :                                         mfprintf(mlog [ WARN ] ) (&quot;There was another function identified in the process of resolving that this function could be found. thus we will require some name qualification \n&quot;);</a>
<a name="3990"><span class="lineNum">    3990 </span>            : #endif</a>
<a name="3991"><span class="lineNum">    3991 </span><span class="lineCov">       2612 :                                         if (foundAnOverloadedFunctionInSameScope == false)</span></a>
<a name="3992"><span class="lineNum">    3992 </span>            :                                            {</a>
<a name="3993"><span class="lineNum">    3993 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt;= 1)</a>
<a name="3994"><span class="lineNum">    3994 </span>            :                                              mfprintf(mlog [ WARN ] ) (&quot;In name qualification support: case V_SgFunctionSymbol: We need to compute the CORRECT name qualification depth: using 1 for now! \n&quot;);</a>
<a name="3995"><span class="lineNum">    3995 </span>            : #endif</a>
<a name="3996"><span class="lineNum">    3996 </span><span class="lineCov">       1483 :                                              qualificationDepth = 1;</span></a>
<a name="3997"><span class="lineNum">    3997 </span>            :                                            }</a>
<a name="3998"><span class="lineNum">    3998 </span>            : #if 0</a>
<a name="3999"><span class="lineNum">    3999 </span>            :                                           else</a>
<a name="4000"><span class="lineNum">    4000 </span>            :                                            {</a>
<a name="4001"><span class="lineNum">    4001 </span>            :                                              qualificationDepth = 0;</a>
<a name="4002"><span class="lineNum">    4002 </span>            :                                            }</a>
<a name="4003"><span class="lineNum">    4003 </span>            : #endif</a>
<a name="4004"><span class="lineNum">    4004 </span>            : #if 0</a>
<a name="4005"><span class="lineNum">    4005 </span>            :                                         mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="4006"><span class="lineNum">    4006 </span>            :                                         ROSE_ABORT();</a>
<a name="4007"><span class="lineNum">    4007 </span>            : #endif</a>
<a name="4008"><span class="lineNum">    4008 </span>            :                                       }</a>
<a name="4009"><span class="lineNum">    4009 </span>            : #if 0</a>
<a name="4010"><span class="lineNum">    4010 </span>            :                                    printf (&quot;Using qualificationDepth = %d \n&quot;,qualificationDepth);</a>
<a name="4011"><span class="lineNum">    4011 </span>            : #endif</a>
<a name="4012"><span class="lineNum">    4012 </span>            : #if 0</a>
<a name="4013"><span class="lineNum">    4013 </span>            :                                    printf(&quot;Exiting as a test! \n&quot;);</a>
<a name="4014"><span class="lineNum">    4014 </span>            :                                    ROSE_ABORT();</a>
<a name="4015"><span class="lineNum">    4015 </span>            : #endif</a>
<a name="4016"><span class="lineNum">    4016 </span>            :                                 // DQ (6/20/2011): But we don't check for if there was another declaration that might be a problem (overloaded functions don't count!)...</a>
<a name="4017"><span class="lineNum">    4017 </span>            :                                 // This function is visible from where it is referenced.</a>
<a name="4018"><span class="lineNum">    4018 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="4019"><span class="lineNum">    4019 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;This function or member function IS visible from where it is referenced (but there could still be ambiguity if this was just the first of several symbols found in the current scope) \n&quot;);</a>
<a name="4020"><span class="lineNum">    4020 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;   --- currentScope        = %p = %s \n&quot;,currentScope,currentScope-&gt;class_name().c_str());</a>
<a name="4021"><span class="lineNum">    4021 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;   --- functionDeclaration = %p = %s \n&quot;,functionDeclaration,functionDeclaration-&gt;class_name().c_str());</a>
<a name="4022"><span class="lineNum">    4022 </span>            : </a>
<a name="4023"><span class="lineNum">    4023 </span>            :                                 // But we need to check if there is another such symbol in the same scope that would trigger qualification.</a>
<a name="4024"><span class="lineNum">    4024 </span>            :                                 // SgScopeStatement* associatedScope = associatedFunctionDeclaration-&gt;get_scope();</a>
<a name="4025"><span class="lineNum">    4025 </span>            :                                 // ASSERT_not_null(associatedScope);</a>
<a name="4026"><span class="lineNum">    4026 </span>            :                                 // mfprintf(mlog [ WARN ] ) (&quot;Searching associatedScope = %p = %s \n&quot;,associatedScope,associatedScope-&gt;class_name().c_str());</a>
<a name="4027"><span class="lineNum">    4027 </span>            :                                    SgClassDefinition* classDefinition = isSgClassDefinition(functionDeclaration-&gt;get_parent());</a>
<a name="4028"><span class="lineNum">    4028 </span>            :                                    if (classDefinition != NULL)</a>
<a name="4029"><span class="lineNum">    4029 </span>            :                                       {</a>
<a name="4030"><span class="lineNum">    4030 </span>            :                                         mfprintf(mlog [ WARN ] ) (&quot;currentScope = %p = %s \n&quot;,currentScope,currentScope-&gt;class_name().c_str());</a>
<a name="4031"><span class="lineNum">    4031 </span>            :                                         mfprintf(mlog [ WARN ] ) (&quot;Searching classDefinition = %p \n&quot;,classDefinition);</a>
<a name="4032"><span class="lineNum">    4032 </span>            : </a>
<a name="4033"><span class="lineNum">    4033 </span>            :                                      // int numberOfSymbolsWithMatchingName = numberOfSymbolsWithName(name,associatedScope);</a>
<a name="4034"><span class="lineNum">    4034 </span>            :                                         int numberOfSymbolsWithMatchingName = numberOfSymbolsWithName(name,classDefinition);</a>
<a name="4035"><span class="lineNum">    4035 </span>            :                                         mfprintf(mlog [ WARN ] ) (&quot;numberOfSymbolsWithMatchingName = %d \n&quot;,numberOfSymbolsWithMatchingName);</a>
<a name="4036"><span class="lineNum">    4036 </span>            : </a>
<a name="4037"><span class="lineNum">    4037 </span>            :                                      // ROSE_ASSERT(numberOfSymbolsWithMatchingName == 1);</a>
<a name="4038"><span class="lineNum">    4038 </span>            :                                       }</a>
<a name="4039"><span class="lineNum">    4039 </span>            : #endif</a>
<a name="4040"><span class="lineNum">    4040 </span>            : #if 0</a>
<a name="4041"><span class="lineNum">    4041 </span>            :                                 // DQ (6/23/2013): Fixing test2013_223.C (function hiding template function instantiation).</a>
<a name="4042"><span class="lineNum">    4042 </span>            :                                    SgTemplateInstantiationFunctionDecl* templateInstantiationFunctionDeclaration = isSgTemplateInstantiationFunctionDecl(functionDeclaration);</a>
<a name="4043"><span class="lineNum">    4043 </span>            :                                    if (templateInstantiationFunctionDeclaration != NULL)</a>
<a name="4044"><span class="lineNum">    4044 </span>            :                                       {</a>
<a name="4045"><span class="lineNum">    4045 </span>            :                                         SgName templateFunctionNameWithoutTemplateArguments = templateInstantiationFunctionDeclaration-&gt;get_templateName();</a>
<a name="4046"><span class="lineNum">    4046 </span>            :                                         mfprintf(mlog [ WARN ] ) (&quot;   --- templateFunctionNameWithoutTemplateArguments = %s \n&quot;,templateFunctionNameWithoutTemplateArguments.str());</a>
<a name="4047"><span class="lineNum">    4047 </span>            :                                       }</a>
<a name="4048"><span class="lineNum">    4048 </span>            : #endif</a>
<a name="4049"><span class="lineNum">    4049 </span>            :                                  }</a>
<a name="4050"><span class="lineNum">    4050 </span>            :                                 else</a>
<a name="4051"><span class="lineNum">    4051 </span>            :                                  {</a>
<a name="4052"><span class="lineNum">    4052 </span>            :                                 // The name does not match, so the associatedFunctionDeclaration is hidding the function declaration.</a>
<a name="4053"><span class="lineNum">    4053 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="4054"><span class="lineNum">    4054 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;This function or member function is NOT visible from where it is referenced (declaration with same name does not match) \n&quot;);</a>
<a name="4055"><span class="lineNum">    4055 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;   --- currentScope      = %p = %s \n&quot;,currentScope,currentScope-&gt;class_name().c_str());</a>
<a name="4056"><span class="lineNum">    4056 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;   --- positionStatement = %p = %s \n&quot;,positionStatement,positionStatement-&gt;class_name().c_str());</a>
<a name="4057"><span class="lineNum">    4057 </span>            : #endif</a>
<a name="4058"><span class="lineNum">    4058 </span><span class="lineCov">       1020 :                                    SgName functionDeclarationFromSymbol_mangled_name           = functionDeclarationFromSymbol-&gt;get_mangled_name();</span></a>
<a name="4059"><span class="lineNum">    4059 </span><span class="lineCov">        510 :                                    SgName associatedFunctionDeclarationFromSymbol_mangled_name = associatedFunctionDeclarationFromSymbol-&gt;get_mangled_name();</span></a>
<a name="4060"><span class="lineNum">    4060 </span>            : </a>
<a name="4061"><span class="lineNum">    4061 </span>            :                                 // DQ (4/2/2018): Check the names to see if they could be the same (possible error checking).</a>
<a name="4062"><span class="lineNum">    4062 </span><span class="lineCov">        510 :                                    if (associatedFunctionDeclarationFromSymbol-&gt;get_name() == functionDeclarationFromSymbol-&gt;get_name())</span></a>
<a name="4063"><span class="lineNum">    4063 </span>            :                                       {</a>
<a name="4064"><span class="lineNum">    4064 </span>            : #if 0</a>
<a name="4065"><span class="lineNum">    4065 </span>            :                                         mfprintf(mlog [ WARN ] ) (&quot;This is an interesting comparision, but not sufficent to be a test for equivalence since each could be a different overloaded function. \n&quot;);</a>
<a name="4066"><span class="lineNum">    4066 </span>            :                                         mfprintf(mlog [ WARN ] ) (&quot;   --- functionDeclarationFromSymbol_mangled_name           = %s \n&quot;,functionDeclarationFromSymbol_mangled_name.str());</a>
<a name="4067"><span class="lineNum">    4067 </span>            :                                         mfprintf(mlog [ WARN ] ) (&quot;   --- associatedFunctionDeclarationFromSymbol_mangled_name = %s \n&quot;,associatedFunctionDeclarationFromSymbol_mangled_name.str());</a>
<a name="4068"><span class="lineNum">    4068 </span>            : </a>
<a name="4069"><span class="lineNum">    4069 </span>            :                                      // DQ (4/5/2018): Output date to understand this issue better.</a>
<a name="4070"><span class="lineNum">    4070 </span>            :                                         mfprintf(mlog [ WARN ] ) (&quot;functionDeclarationFromSymbol = %p = %s \n&quot;,functionDeclarationFromSymbol,functionDeclarationFromSymbol-&gt;class_name().c_str());</a>
<a name="4071"><span class="lineNum">    4071 </span>            :                                         functionReport(functionDeclarationFromSymbol);</a>
<a name="4072"><span class="lineNum">    4072 </span>            : </a>
<a name="4073"><span class="lineNum">    4073 </span>            :                                         mfprintf(mlog [ WARN ] ) (&quot;associatedFunctionDeclarationFromSymbol = %p = %s \n&quot;,associatedFunctionDeclarationFromSymbol,associatedFunctionDeclarationFromSymbol-&gt;class_name().c_str());</a>
<a name="4074"><span class="lineNum">    4074 </span>            :                                         functionReport(associatedFunctionDeclarationFromSymbol);</a>
<a name="4075"><span class="lineNum">    4075 </span>            : #endif</a>
<a name="4076"><span class="lineNum">    4076 </span>            :                                      // DQ (4/7/2018): I think we can assert this (this fails for Cxx_tests/test2017_29.C).</a>
<a name="4077"><span class="lineNum">    4077 </span>            :                                      // ROSE_ASSERT(functionDeclarationFromSymbol_mangled_name != associatedFunctionDeclarationFromSymbol_mangled_name);</a>
<a name="4078"><span class="lineNum">    4078 </span>            :                                       }</a>
<a name="4079"><span class="lineNum">    4079 </span>            : </a>
<a name="4080"><span class="lineNum">    4080 </span>            :                                 // SgName functionDeclarationFromSymbol_mangled_name           = functionDeclarationFromSymbol-&gt;get_mangled_name();</a>
<a name="4081"><span class="lineNum">    4081 </span>            :                                 // SgName associatedFunctionDeclarationFromSymbol_mangled_name = associatedFunctionDeclarationFromSymbol-&gt;get_mangled_name();</a>
<a name="4082"><span class="lineNum">    4082 </span>            :                                 // if (associatedFunctionDeclarationFromSymbol-&gt;get_name() == functionDeclarationFromSymbol-&gt;get_name())</a>
<a name="4083"><span class="lineNum">    4083 </span><span class="lineCov">        510 :                                    if (associatedFunctionDeclarationFromSymbol_mangled_name == functionDeclarationFromSymbol_mangled_name)</span></a>
<a name="4084"><span class="lineNum">    4084 </span>            :                                       {</a>
<a name="4085"><span class="lineNum">    4085 </span>            : #if 0</a>
<a name="4086"><span class="lineNum">    4086 </span>            :                                      // DQ (10/23/2019): This output is seen in the new tool_G.C, need to track this down, later.</a>
<a name="4087"><span class="lineNum">    4087 </span>            :                                         mfprintf(mlog [ WARN ] ) (&quot;Note: we have two mangled names from two symbols in the same scope using the same mangled name (investigate this) \n&quot;);</a>
<a name="4088"><span class="lineNum">    4088 </span>            :                                         mfprintf(mlog [ WARN ] ) (&quot;   --- functionDeclarationFromSymbol_mangled_name           = %s \n&quot;,functionDeclarationFromSymbol_mangled_name.str());</a>
<a name="4089"><span class="lineNum">    4089 </span>            :                                         mfprintf(mlog [ WARN ] ) (&quot;   --- associatedFunctionDeclarationFromSymbol_mangled_name = %s \n&quot;,associatedFunctionDeclarationFromSymbol_mangled_name.str());</a>
<a name="4090"><span class="lineNum">    4090 </span>            :                                         mfprintf(mlog [ WARN ] ) (&quot;   --- functionDeclarationFromSymbol           = %p = %s \n&quot;,functionDeclarationFromSymbol,functionDeclarationFromSymbol-&gt;class_name().c_str());</a>
<a name="4091"><span class="lineNum">    4091 </span>            :                                         mfprintf(mlog [ WARN ] ) (&quot;   --- associatedFunctionDeclarationFromSymbol = %p = %s \n&quot;,associatedFunctionDeclarationFromSymbol,associatedFunctionDeclarationFromSymbol-&gt;class_name().c_str());</a>
<a name="4092"><span class="lineNum">    4092 </span>            :                                         mfprintf(mlog [ WARN ] ) (&quot;   --- functionDeclarationFromSymbol-&gt;get_name()           = %s \n&quot;,functionDeclarationFromSymbol-&gt;get_name().str());</a>
<a name="4093"><span class="lineNum">    4093 </span>            :                                         mfprintf(mlog [ WARN ] ) (&quot;   --- associatedFunctionDeclarationFromSymbol-&gt;get_name() = %s \n&quot;,associatedFunctionDeclarationFromSymbol-&gt;get_name().str());</a>
<a name="4094"><span class="lineNum">    4094 </span>            : </a>
<a name="4095"><span class="lineNum">    4095 </span>            :                                         mfprintf(mlog [ WARN ] ) (&quot;   --- functionDeclarationFromSymbol           = %p first non-defining = %p defining = %p \n&quot;,functionDeclarationFromSymbol,</a>
<a name="4096"><span class="lineNum">    4096 </span>            :                                              functionDeclarationFromSymbol-&gt;get_firstNondefiningDeclaration(),functionDeclarationFromSymbol-&gt;get_definingDeclaration());</a>
<a name="4097"><span class="lineNum">    4097 </span>            :                                         mfprintf(mlog [ WARN ] ) (&quot;   --- associatedFunctionDeclarationFromSymbol = %p first non-defining = %p defining = %p \n&quot;,associatedFunctionDeclarationFromSymbol,</a>
<a name="4098"><span class="lineNum">    4098 </span>            :                                              associatedFunctionDeclarationFromSymbol-&gt;get_firstNondefiningDeclaration(),associatedFunctionDeclarationFromSymbol-&gt;get_definingDeclaration());</a>
<a name="4099"><span class="lineNum">    4099 </span>            : #endif</a>
<a name="4100"><span class="lineNum">    4100 </span>            : #if 0</a>
<a name="4101"><span class="lineNum">    4101 </span>            :                                         mfprintf(mlog [ WARN ] ) (&quot;functionDeclarationFromSymbol-&gt;get_name() = %s \n&quot;,functionDeclarationFromSymbol-&gt;get_name().str());</a>
<a name="4102"><span class="lineNum">    4102 </span>            :                                         SgNode* parent_functionDeclarationFromSymbol = functionDeclarationFromSymbol-&gt;get_parent();</a>
<a name="4103"><span class="lineNum">    4103 </span>            :                                         mfprintf(mlog [ WARN ] ) (&quot;parent_functionDeclarationFromSymbol = %p = %s \n&quot;,</a>
<a name="4104"><span class="lineNum">    4104 </span>            :                                              parent_functionDeclarationFromSymbol,parent_functionDeclarationFromSymbol-&gt;class_name().c_str());</a>
<a name="4105"><span class="lineNum">    4105 </span>            :                                         SgScopeStatement* scope_functionDeclarationFromSymbol = functionDeclarationFromSymbol-&gt;get_scope();</a>
<a name="4106"><span class="lineNum">    4106 </span>            :                                         mfprintf(mlog [ WARN ] ) (&quot;scope_functionDeclarationFromSymbol = %p = %s \n&quot;,</a>
<a name="4107"><span class="lineNum">    4107 </span>            :                                              scope_functionDeclarationFromSymbol,scope_functionDeclarationFromSymbol-&gt;class_name().c_str());</a>
<a name="4108"><span class="lineNum">    4108 </span>            : </a>
<a name="4109"><span class="lineNum">    4109 </span>            :                                         SgNode* parent_associatedFunctionDeclarationFromSymbol = associatedFunctionDeclarationFromSymbol-&gt;get_parent();</a>
<a name="4110"><span class="lineNum">    4110 </span>            :                                         mfprintf(mlog [ WARN ] ) (&quot;parent_associatedFunctionDeclarationFromSymbol = %p = %s \n&quot;,</a>
<a name="4111"><span class="lineNum">    4111 </span>            :                                              parent_associatedFunctionDeclarationFromSymbol,parent_associatedFunctionDeclarationFromSymbol-&gt;class_name().c_str());</a>
<a name="4112"><span class="lineNum">    4112 </span>            :                                         SgScopeStatement* scope_associatedFunctionDeclarationFromSymbol = associatedFunctionDeclarationFromSymbol-&gt;get_scope();</a>
<a name="4113"><span class="lineNum">    4113 </span>            :                                         mfprintf(mlog [ WARN ] ) (&quot;scope_associatedFunctionDeclarationFromSymbol = %p = %s \n&quot;,</a>
<a name="4114"><span class="lineNum">    4114 </span>            :                                              scope_associatedFunctionDeclarationFromSymbol,scope_associatedFunctionDeclarationFromSymbol-&gt;class_name().c_str());</a>
<a name="4115"><span class="lineNum">    4115 </span>            : </a>
<a name="4116"><span class="lineNum">    4116 </span>            :                                         SgNamespaceDefinitionStatement* namespaceDefinitionStatement_function           = isSgNamespaceDefinitionStatement(scope_functionDeclarationFromSymbol);</a>
<a name="4117"><span class="lineNum">    4117 </span>            :                                         SgNamespaceDefinitionStatement* namespaceDefinitionStatement_associatedFunction = isSgNamespaceDefinitionStatement(scope_associatedFunctionDeclarationFromSymbol);</a>
<a name="4118"><span class="lineNum">    4118 </span>            : </a>
<a name="4119"><span class="lineNum">    4119 </span>            :                                         if (namespaceDefinitionStatement_function != NULL)</a>
<a name="4120"><span class="lineNum">    4120 </span>            :                                            {</a>
<a name="4121"><span class="lineNum">    4121 </span>            :                                              mfprintf(mlog [ WARN ] ) (&quot;namespaceDefinitionStatement_function: name                        = %s \n&quot;,namespaceDefinitionStatement_function-&gt;get_namespaceDeclaration()-&gt;get_name().str());</a>
<a name="4122"><span class="lineNum">    4122 </span>            :                                              mfprintf(mlog [ WARN ] ) (&quot;namespaceDefinitionStatement_function: global_definition           = %p \n&quot;,namespaceDefinitionStatement_function-&gt;get_global_definition());</a>
<a name="4123"><span class="lineNum">    4123 </span>            :                                            }</a>
<a name="4124"><span class="lineNum">    4124 </span>            : </a>
<a name="4125"><span class="lineNum">    4125 </span>            :                                         if (namespaceDefinitionStatement_associatedFunction != NULL)</a>
<a name="4126"><span class="lineNum">    4126 </span>            :                                            {</a>
<a name="4127"><span class="lineNum">    4127 </span>            :                                              mfprintf(mlog [ WARN ] ) (&quot;namespaceDefinitionStatement_associatedFunction: name              = %s \n&quot;,namespaceDefinitionStatement_associatedFunction-&gt;get_namespaceDeclaration()-&gt;get_name().str());</a>
<a name="4128"><span class="lineNum">    4128 </span>            :                                              mfprintf(mlog [ WARN ] ) (&quot;namespaceDefinitionStatement_associatedFunction: global_definition = %p \n&quot;,namespaceDefinitionStatement_associatedFunction-&gt;get_global_definition());</a>
<a name="4129"><span class="lineNum">    4129 </span>            :                                            }</a>
<a name="4130"><span class="lineNum">    4130 </span>            : #endif</a>
<a name="4131"><span class="lineNum">    4131 </span>            : #if 0</a>
<a name="4132"><span class="lineNum">    4132 </span>            :                                      // DQ (4/5/2018): Output date to understand this issue better.</a>
<a name="4133"><span class="lineNum">    4133 </span>            :                                         mfprintf(mlog [ WARN ] ) (&quot;functionDeclarationFromSymbol = %p = %s \n&quot;,functionDeclarationFromSymbol,functionDeclarationFromSymbol-&gt;class_name().c_str());</a>
<a name="4134"><span class="lineNum">    4134 </span>            :                                         functionReport(functionDeclarationFromSymbol);</a>
<a name="4135"><span class="lineNum">    4135 </span>            : </a>
<a name="4136"><span class="lineNum">    4136 </span>            :                                         mfprintf(mlog [ WARN ] ) (&quot;associatedFunctionDeclarationFromSymbol = %p = %s \n&quot;,associatedFunctionDeclarationFromSymbol,associatedFunctionDeclarationFromSymbol-&gt;class_name().c_str());</a>
<a name="4137"><span class="lineNum">    4137 </span>            :                                         functionReport(associatedFunctionDeclarationFromSymbol);</a>
<a name="4138"><span class="lineNum">    4138 </span>            : #endif</a>
<a name="4139"><span class="lineNum">    4139 </span>            : #if 0</a>
<a name="4140"><span class="lineNum">    4140 </span>            :                                         mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="4141"><span class="lineNum">    4141 </span>            :                                         ROSE_ABORT();</a>
<a name="4142"><span class="lineNum">    4142 </span>            : #endif</a>
<a name="4143"><span class="lineNum">    4143 </span>            :                                       }</a>
<a name="4144"><span class="lineNum">    4144 </span>            : </a>
<a name="4145"><span class="lineNum">    4145 </span>            :                                 // DQ (4/7/2018): I think we can also assert this (unless the function parameters would make the difference)!</a>
<a name="4146"><span class="lineNum">    4146 </span>            :                                 // ROSE_ASSERT(associatedFunctionDeclarationFromSymbol-&gt;get_name() != functionDeclarationFromSymbol-&gt;get_name());</a>
<a name="4147"><span class="lineNum">    4147 </span>            : #if 0</a>
<a name="4148"><span class="lineNum">    4148 </span>            :                                 // DQ (4/12/2014): Since we have searched using the function type, we don't need to compare the function types here.</a>
<a name="4149"><span class="lineNum">    4149 </span>            :                                 // DQ (4/8/2014): Added test on function types.</a>
<a name="4150"><span class="lineNum">    4150 </span>            :                                    SgFunctionType* associatedfunctionTypeFromSymbol = associatedFunctionDeclarationFromSymbol-&gt;get_type();</a>
<a name="4151"><span class="lineNum">    4151 </span>            :                                    SgFunctionType* functionTypeFromSymbol           = functionDeclarationFromSymbol-&gt;get_type();</a>
<a name="4152"><span class="lineNum">    4152 </span>            : </a>
<a name="4153"><span class="lineNum">    4153 </span>            :                                    bool functionInSameScope = (associatedFunctionDeclarationFromSymbol-&gt;get_scope() == functionDeclarationFromSymbol-&gt;get_scope());</a>
<a name="4154"><span class="lineNum">    4154 </span>            :                                    bool functionTypesMatch  = (associatedfunctionTypeFromSymbol == functionTypeFromSymbol);</a>
<a name="4155"><span class="lineNum">    4155 </span>            : </a>
<a name="4156"><span class="lineNum">    4156 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="4157"><span class="lineNum">    4157 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;   --- functionTypesMatch = %s \n&quot;,functionTypesMatch ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="4158"><span class="lineNum">    4158 </span>            : #endif</a>
<a name="4159"><span class="lineNum">    4159 </span>            :                                 // int increment = functionTypesMatch ? 1 : 0;</a>
<a name="4160"><span class="lineNum">    4160 </span>            :                                    int increment = functionInSameScope &amp;&amp; functionTypesMatch ? 1 : 0;</a>
<a name="4161"><span class="lineNum">    4161 </span>            : #else</a>
<a name="4162"><span class="lineNum">    4162 </span>            :                                 // DQ (4/7/2018): Only increment the name qualification depth if these are the same function.</a>
<a name="4163"><span class="lineNum">    4163 </span>            :                                 // int increment = 1;</a>
<a name="4164"><span class="lineNum">    4164 </span>            : #if 0</a>
<a name="4165"><span class="lineNum">    4165 </span>            :                                 // DQ (4/7/2018): This must be set to 1, and Cxx_tests/test2011_39.C demonstrates this.</a>
<a name="4166"><span class="lineNum">    4166 </span>            :                                    int increment = 1;</a>
<a name="4167"><span class="lineNum">    4167 </span>            :                                    if (functionDeclarationFromSymbol_mangled_name != associatedFunctionDeclarationFromSymbol_mangled_name)</a>
<a name="4168"><span class="lineNum">    4168 </span>            :                                       {</a>
<a name="4169"><span class="lineNum">    4169 </span>            :                                         increment = 0;</a>
<a name="4170"><span class="lineNum">    4170 </span>            :                                       }</a>
<a name="4171"><span class="lineNum">    4171 </span>            : #else</a>
<a name="4172"><span class="lineNum">    4172 </span>            :                                 // DQ (4/7/2018): This must be set to 1, and Cxx_tests/test2011_39.C demonstrates this.</a>
<a name="4173"><span class="lineNum">    4173 </span><span class="lineCov">        510 :                                    int increment = 1;</span></a>
<a name="4174"><span class="lineNum">    4174 </span>            : #endif</a>
<a name="4175"><span class="lineNum">    4175 </span>            : #endif</a>
<a name="4176"><span class="lineNum">    4176 </span>            :                                 // DQ (4/8/2014): If the type match then use an increment of 1, else don't increment the qualificationDepth.</a>
<a name="4177"><span class="lineNum">    4177 </span>            :                                 // Now resolve how much name qualification is required; what ever is required for the parent plus 1.</a>
<a name="4178"><span class="lineNum">    4178 </span>            :                                 // qualificationDepth = nameQualificationDepthOfParent(declaration,currentScope,positionStatement) + 1;</a>
<a name="4179"><span class="lineNum">    4179 </span><span class="lineCov">        510 :                                    qualificationDepth = nameQualificationDepthOfParent(declaration,currentScope,positionStatement) + increment;</span></a>
<a name="4180"><span class="lineNum">    4180 </span>            : </a>
<a name="4181"><span class="lineNum">    4181 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || 0</a>
<a name="4182"><span class="lineNum">    4182 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;   --- qualificationDepth = %d \n&quot;,qualificationDepth);</a>
<a name="4183"><span class="lineNum">    4183 </span>            : #endif</a>
<a name="4184"><span class="lineNum">    4184 </span>            : #if 0</a>
<a name="4185"><span class="lineNum">    4185 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;Exiting for unimplemented case (function) \n&quot;);</a>
<a name="4186"><span class="lineNum">    4186 </span>            :                                    ROSE_ABORT();</a>
<a name="4187"><span class="lineNum">    4187 </span>            : #endif</a>
<a name="4188"><span class="lineNum">    4188 </span>            :                                  }</a>
<a name="4189"><span class="lineNum">    4189 </span>            : #if 0</a>
<a name="4190"><span class="lineNum">    4190 </span>            :                            // DQ (6/1/2011): Added support for template arguments.</a>
<a name="4191"><span class="lineNum">    4191 </span>            :                               SgTemplateInstantiationMemberFunctionDecl* templateInstantiationMemberFunctionDeclaration = isSgTemplateInstantiationMemberFunctionDecl(associatedFunctionDeclaration);</a>
<a name="4192"><span class="lineNum">    4192 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;$$$$$$$$$ --- templateInstantiationMemberFunctionDeclaration = %p \n&quot;,templateInstantiationMemberFunctionDeclaration);</a>
<a name="4193"><span class="lineNum">    4193 </span>            :                               if (templateInstantiationMemberFunctionDeclaration != NULL)</a>
<a name="4194"><span class="lineNum">    4194 </span>            :                                  {</a>
<a name="4195"><span class="lineNum">    4195 </span>            :                                 // Evaluate all template arguments.</a>
<a name="4196"><span class="lineNum">    4196 </span>            :                                    evaluateNameQualificationForTemplateArgumentList (templateInstantiationMemberFunctionDeclaration-&gt;get_templateArguments(),currentScope,positionStatement);</a>
<a name="4197"><span class="lineNum">    4197 </span>            :                                  }</a>
<a name="4198"><span class="lineNum">    4198 </span>            : #endif</a>
<a name="4199"><span class="lineNum">    4199 </span>            : #if 0</a>
<a name="4200"><span class="lineNum">    4200 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;Testing for a SgTemplateInstantiationFunctionDecl \n&quot;);</a>
<a name="4201"><span class="lineNum">    4201 </span>            :                               if (isSgTemplateInstantiationFunctionDecl(declaration) != NULL)</a>
<a name="4202"><span class="lineNum">    4202 </span>            :                                  {</a>
<a name="4203"><span class="lineNum">    4203 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="4204"><span class="lineNum">    4204 </span>            :                                    ROSE_ABORT();</a>
<a name="4205"><span class="lineNum">    4205 </span>            :                                  }</a>
<a name="4206"><span class="lineNum">    4206 </span>            : #endif</a>
<a name="4207"><span class="lineNum">    4207 </span>            :                               break;</a>
<a name="4208"><span class="lineNum">    4208 </span>            :                             }</a>
<a name="4209"><span class="lineNum">    4209 </span>            : </a>
<a name="4210"><span class="lineNum">    4210 </span>            :                       // DQ (11/10/2014): Adding support for templated typedef declarations.</a>
<a name="4211"><span class="lineNum">    4211 </span><span class="lineCov">    1371730 :                          case V_SgTemplateTypedefSymbol:</span></a>
<a name="4212"><span class="lineNum">    4212 </span>            : </a>
<a name="4213"><span class="lineNum">    4213 </span><span class="lineCov">    1371730 :                          case V_SgTypedefSymbol:</span></a>
<a name="4214"><span class="lineNum">    4214 </span><span class="lineCov">    1371730 :                             {</span></a>
<a name="4215"><span class="lineNum">    4215 </span><span class="lineCov">    1371730 :                               SgTypedefSymbol* typedefSymbol = isSgTypedefSymbol(symbol);</span></a>
<a name="4216"><span class="lineNum">    4216 </span><span class="lineCov">    1371730 :                               ASSERT_not_null(typedefSymbol);</span></a>
<a name="4217"><span class="lineNum">    4217 </span>            : </a>
<a name="4218"><span class="lineNum">    4218 </span>            :                            // This is a typdef symbol, check if the declaration is the same.</a>
<a name="4219"><span class="lineNum">    4219 </span><span class="lineCov">    1371730 :                               SgTypedefDeclaration* associatedTypedefDeclaration = typedefSymbol-&gt;get_declaration();</span></a>
<a name="4220"><span class="lineNum">    4220 </span>            : </a>
<a name="4221"><span class="lineNum">    4221 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="4222"><span class="lineNum">    4222 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;associatedTypedefDeclaration = %p = %s \n&quot;,associatedTypedefDeclaration,associatedTypedefDeclaration-&gt;get_name().str());</a>
<a name="4223"><span class="lineNum">    4223 </span>            : #endif</a>
<a name="4224"><span class="lineNum">    4224 </span><span class="lineCov">    1371730 :                               ASSERT_not_null(typedefDeclaration);</span></a>
<a name="4225"><span class="lineNum">    4225 </span><span class="lineCov">    1371730 :                               ASSERT_not_null(associatedTypedefDeclaration);</span></a>
<a name="4226"><span class="lineNum">    4226 </span>            : </a>
<a name="4227"><span class="lineNum">    4227 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="4228"><span class="lineNum">    4228 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;associatedTypedefDeclaration-&gt;get_firstNondefiningDeclaration() = %p \n&quot;,associatedTypedefDeclaration-&gt;get_firstNondefiningDeclaration());</a>
<a name="4229"><span class="lineNum">    4229 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;typedefDeclaration-&gt;get_firstNondefiningDeclaration()           = %p \n&quot;,typedefDeclaration-&gt;get_firstNondefiningDeclaration());</a>
<a name="4230"><span class="lineNum">    4230 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;currentScope                                                    = %p = %s \n&quot;,currentScope,currentScope-&gt;class_name().c_str());</a>
<a name="4231"><span class="lineNum">    4231 </span>            : #endif</a>
<a name="4232"><span class="lineNum">    4232 </span><span class="lineCov">    1371730 :                               if (associatedTypedefDeclaration-&gt;get_firstNondefiningDeclaration() == typedefDeclaration-&gt;get_firstNondefiningDeclaration())</span></a>
<a name="4233"><span class="lineNum">    4233 </span>            :                                  {</a>
<a name="4234"><span class="lineNum">    4234 </span>            :                                 // This typedef is visible from where it is referenced.</a>
<a name="4235"><span class="lineNum">    4235 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="4236"><span class="lineNum">    4236 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;This typedef IS visible from where it is referenced \n&quot;);</a>
<a name="4237"><span class="lineNum">    4237 </span>            : #endif</a>
<a name="4238"><span class="lineNum">    4238 </span>            :                                 // DQ (2/8/2019): If type elaboration was required, and the symbol is from a base class.</a>
<a name="4239"><span class="lineNum">    4239 </span>            :                                 // Then we need name qualification because the type elaboration will not protect the type</a>
<a name="4240"><span class="lineNum">    4240 </span>            :                                 // reference from being hidden.</a>
<a name="4241"><span class="lineNum">    4241 </span><span class="lineCov">    1288630 :                                    if (typeElaborationIsRequired == true)</span></a>
<a name="4242"><span class="lineNum">    4242 </span>            :                                       {</a>
<a name="4243"><span class="lineNum">    4243 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="4244"><span class="lineNum">    4244 </span>            :                                         mfprintf(mlog [ WARN ] ) (&quot;   --- Since type elaboration was required because it was hidden, add name qualification to support it being unambiguous \n&quot;);</a>
<a name="4245"><span class="lineNum">    4245 </span>            : #endif</a>
<a name="4246"><span class="lineNum">    4246 </span><span class="lineCov">        537 :                                         qualificationDepth = 1;</span></a>
<a name="4247"><span class="lineNum">    4247 </span>            :                                       }</a>
<a name="4248"><span class="lineNum">    4248 </span>            : #if 0</a>
<a name="4249"><span class="lineNum">    4249 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;case V_SgTypedefSymbol: name         = %s \n&quot;,name.str());</a>
<a name="4250"><span class="lineNum">    4250 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;case V_SgTypedefSymbol: currentScope = %p = %s \n&quot;,currentScope,currentScope-&gt;class_name().c_str());</a>
<a name="4251"><span class="lineNum">    4251 </span>            : #endif</a>
<a name="4252"><span class="lineNum">    4252 </span>            :                                 // DQ (1/4/2020): Need to check if there is an opportunity for an ambigous reference.</a>
<a name="4253"><span class="lineNum">    4253 </span>            :                                 // size_t numberOfAliasSymbols = currentScope-&gt;count_alias_symbol(name);</a>
<a name="4254"><span class="lineNum">    4254 </span>            :                                 // symbol = SageInterface::lookupTemplateSymbolInParentScopes(name,currentScope);</a>
<a name="4255"><span class="lineNum">    4255 </span>            :                                 // SgScopeStatement* scopeOfAssociatedTypedefDeclaration = associatedTypedefDeclaration-&gt;get_scope();</a>
<a name="4256"><span class="lineNum">    4256 </span>            :                                 // ASSERT_not_null(scopeOfAssociatedTypedefDeclaration);</a>
<a name="4257"><span class="lineNum">    4257 </span>            :                                 // size_t numberOfAliasSymbols = scopeOfAssociatedTypedefDeclaration-&gt;count_alias_symbol(name);</a>
<a name="4258"><span class="lineNum">    4258 </span><span class="lineCov">    1288630 :                                    bool includeCurrentScope = true;</span></a>
<a name="4259"><span class="lineNum">    4259 </span><span class="lineCov">    1288630 :                                    SgClassDefinition* current_classDefinition = SageInterface::getEnclosingNode&lt;SgClassDefinition&gt;(currentScope,includeCurrentScope);</span></a>
<a name="4260"><span class="lineNum">    4260 </span><span class="lineCov">    1288630 :                                    if (current_classDefinition != NULL)</span></a>
<a name="4261"><span class="lineNum">    4261 </span>            :                                       {</a>
<a name="4262"><span class="lineNum">    4262 </span><span class="lineCov">      52676 :                                         size_t numberOfAliasSymbols = current_classDefinition-&gt;count_alias_symbol(name);</span></a>
<a name="4263"><span class="lineNum">    4263 </span>            : #if 0</a>
<a name="4264"><span class="lineNum">    4264 </span>            :                                         mfprintf(mlog [ WARN ] ) (&quot;case V_SgTypedefSymbol: numberOfAliasSymbols = %zu \n&quot;,numberOfAliasSymbols);</a>
<a name="4265"><span class="lineNum">    4265 </span>            : #endif</a>
<a name="4266"><span class="lineNum">    4266 </span><span class="lineCov">      52676 :                                         if (numberOfAliasSymbols &gt;= 2)</span></a>
<a name="4267"><span class="lineNum">    4267 </span>            :                                            {</a>
<a name="4268"><span class="lineNum">    4268 </span>            : #if 0</a>
<a name="4269"><span class="lineNum">    4269 </span>            :                                              mfprintf(mlog [ WARN ] ) (&quot;Detected numberOfAliasSymbols &gt;= 2: numberOfAliasSymbols = %zu \n&quot;,numberOfAliasSymbols);</a>
<a name="4270"><span class="lineNum">    4270 </span>            : #endif</a>
<a name="4271"><span class="lineNum">    4271 </span><span class="lineCov">        288 :                                              qualificationDepth = nameQualificationDepthOfParent(declaration,currentScope,positionStatement) + 1;</span></a>
<a name="4272"><span class="lineNum">    4272 </span>            :                                           // qualificationDepth += 1;</a>
<a name="4273"><span class="lineNum">    4273 </span>            : </a>
<a name="4274"><span class="lineNum">    4274 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="4275"><span class="lineNum">    4275 </span>            :                                              mfprintf(mlog [ WARN ] ) (&quot;   --- qualificationDepth = %d \n&quot;,qualificationDepth);</a>
<a name="4276"><span class="lineNum">    4276 </span>            : #endif</a>
<a name="4277"><span class="lineNum">    4277 </span>            :                                            }</a>
<a name="4278"><span class="lineNum">    4278 </span>            :                                       }</a>
<a name="4279"><span class="lineNum">    4279 </span>            :                                  }</a>
<a name="4280"><span class="lineNum">    4280 </span>            :                                 else</a>
<a name="4281"><span class="lineNum">    4281 </span>            :                                  {</a>
<a name="4282"><span class="lineNum">    4282 </span>            :                                 // The name does not match, so the associatedFunctionDeclaration is hidding the base class declaration.</a>
<a name="4283"><span class="lineNum">    4283 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="4284"><span class="lineNum">    4284 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;This typedef is NOT visible from where it is referenced (declaration with same name does not match) \n&quot;);</a>
<a name="4285"><span class="lineNum">    4285 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;   --- currentScope      = %p = %s \n&quot;,currentScope,currentScope-&gt;class_name().c_str());</a>
<a name="4286"><span class="lineNum">    4286 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;   --- positionStatement = %p = %s \n&quot;,positionStatement,positionStatement-&gt;class_name().c_str());</a>
<a name="4287"><span class="lineNum">    4287 </span>            : #endif</a>
<a name="4288"><span class="lineNum">    4288 </span>            :                                 // Now resolve how much name qualification is required; what ever is required for the parent plus 1.</a>
<a name="4289"><span class="lineNum">    4289 </span><span class="lineCov">      83103 :                                    qualificationDepth = nameQualificationDepthOfParent(declaration,currentScope,positionStatement) + 1;</span></a>
<a name="4290"><span class="lineNum">    4290 </span>            : #if 0</a>
<a name="4291"><span class="lineNum">    4291 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;Exiting for unimplemented case (typedef) \n&quot;);</a>
<a name="4292"><span class="lineNum">    4292 </span>            :                                    ROSE_ABORT();</a>
<a name="4293"><span class="lineNum">    4293 </span>            : #endif</a>
<a name="4294"><span class="lineNum">    4294 </span>            :                                  }</a>
<a name="4295"><span class="lineNum">    4295 </span>            : </a>
<a name="4296"><span class="lineNum">    4296 </span>            :                               break;</a>
<a name="4297"><span class="lineNum">    4297 </span>            :                             }</a>
<a name="4298"><span class="lineNum">    4298 </span>            : </a>
<a name="4299"><span class="lineNum">    4299 </span><span class="lineNoCov">          0 :                          case V_SgTemplateSymbol:</span></a>
<a name="4300"><span class="lineNum">    4300 </span><span class="lineNoCov">          0 :                             {</span></a>
<a name="4301"><span class="lineNum">    4301 </span><span class="lineNoCov">          0 :                               SgTemplateSymbol* templateSymbol = isSgTemplateSymbol(symbol);</span></a>
<a name="4302"><span class="lineNum">    4302 </span><span class="lineNoCov">          0 :                               ASSERT_not_null(templateSymbol);</span></a>
<a name="4303"><span class="lineNum">    4303 </span>            : </a>
<a name="4304"><span class="lineNum">    4304 </span>            : #if 0</a>
<a name="4305"><span class="lineNum">    4305 </span>            :                            // This is a template symbol, check if the declaration is the same.</a>
<a name="4306"><span class="lineNum">    4306 </span>            :                               SgTemplateDeclaration* associatedTemplateDeclaration = templateSymbol-&gt;get_declaration();</a>
<a name="4307"><span class="lineNum">    4307 </span>            : </a>
<a name="4308"><span class="lineNum">    4308 </span>            :                            // Comment this out for now...</a>
<a name="4309"><span class="lineNum">    4309 </span>            :                               ASSERT_not_null(templateDeclaration);</a>
<a name="4310"><span class="lineNum">    4310 </span>            :                               ASSERT_not_null(associatedTemplateDeclaration);</a>
<a name="4311"><span class="lineNum">    4311 </span>            : </a>
<a name="4312"><span class="lineNum">    4312 </span>            :                               if (associatedTemplateDeclaration-&gt;get_firstNondefiningDeclaration() == templateDeclaration-&gt;get_firstNondefiningDeclaration())</a>
<a name="4313"><span class="lineNum">    4313 </span>            :                                  {</a>
<a name="4314"><span class="lineNum">    4314 </span>            :                                 // This class is visible from where it is referenced.</a>
<a name="4315"><span class="lineNum">    4315 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;This template IS visible from where it is referenced \n&quot;);</a>
<a name="4316"><span class="lineNum">    4316 </span>            :                                  }</a>
<a name="4317"><span class="lineNum">    4317 </span>            :                                 else</a>
<a name="4318"><span class="lineNum">    4318 </span>            :                                  {</a>
<a name="4319"><span class="lineNum">    4319 </span>            :                                 // The name does not match, so the associatedFunctionDeclaration is hidding the base class declaration.</a>
<a name="4320"><span class="lineNum">    4320 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;This template is NOT visible from where it is referenced (declaration with same name does not match) \n&quot;);</a>
<a name="4321"><span class="lineNum">    4321 </span>            : </a>
<a name="4322"><span class="lineNum">    4322 </span>            :                                 // Now resolve how much name qualification is required; what ever is required for the parent plus 1.</a>
<a name="4323"><span class="lineNum">    4323 </span>            :                                    qualificationDepth = nameQualificationDepthOfParent(declaration,currentScope,positionStatement) + 1;</a>
<a name="4324"><span class="lineNum">    4324 </span>            : #if 0</a>
<a name="4325"><span class="lineNum">    4325 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;Exiting for unimplemented case (typedef) \n&quot;);</a>
<a name="4326"><span class="lineNum">    4326 </span>            :                                    ROSE_ABORT();</a>
<a name="4327"><span class="lineNum">    4327 </span>            : #endif</a>
<a name="4328"><span class="lineNum">    4328 </span>            :                                  }</a>
<a name="4329"><span class="lineNum">    4329 </span>            : #else</a>
<a name="4330"><span class="lineNum">    4330 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="4331"><span class="lineNum">    4331 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;WARNING: Support for name qualification for SgTemplateInstantiationFunctionDecl is not implemented yet \n&quot;);</a>
<a name="4332"><span class="lineNum">    4332 </span>            : #endif</a>
<a name="4333"><span class="lineNum">    4333 </span>            : #endif</a>
<a name="4334"><span class="lineNum">    4334 </span><span class="lineNoCov">          0 :                               break;</span></a>
<a name="4335"><span class="lineNum">    4335 </span>            :                             }</a>
<a name="4336"><span class="lineNum">    4336 </span>            : </a>
<a name="4337"><span class="lineNum">    4337 </span><span class="lineCov">       8682 :                          case V_SgEnumSymbol:</span></a>
<a name="4338"><span class="lineNum">    4338 </span><span class="lineCov">       8682 :                             {</span></a>
<a name="4339"><span class="lineNum">    4339 </span><span class="lineCov">       8682 :                               SgEnumSymbol* enumSymbol = isSgEnumSymbol(symbol);</span></a>
<a name="4340"><span class="lineNum">    4340 </span><span class="lineCov">       8682 :                               ASSERT_not_null(enumSymbol);</span></a>
<a name="4341"><span class="lineNum">    4341 </span>            : </a>
<a name="4342"><span class="lineNum">    4342 </span>            :                            // This is a typdef symbol, check if the declaration is the same.</a>
<a name="4343"><span class="lineNum">    4343 </span><span class="lineCov">       8682 :                               SgEnumDeclaration* associatedEnumDeclaration = enumSymbol-&gt;get_declaration();</span></a>
<a name="4344"><span class="lineNum">    4344 </span>            : </a>
<a name="4345"><span class="lineNum">    4345 </span><span class="lineCov">       8682 :                               ASSERT_not_null(enumDeclaration);</span></a>
<a name="4346"><span class="lineNum">    4346 </span><span class="lineCov">       8682 :                               ASSERT_not_null(associatedEnumDeclaration);</span></a>
<a name="4347"><span class="lineNum">    4347 </span>            : </a>
<a name="4348"><span class="lineNum">    4348 </span><span class="lineCov">       8682 :                               if (associatedEnumDeclaration-&gt;get_firstNondefiningDeclaration() == enumDeclaration-&gt;get_firstNondefiningDeclaration())</span></a>
<a name="4349"><span class="lineNum">    4349 </span>            :                                  {</a>
<a name="4350"><span class="lineNum">    4350 </span>            :                                 // This class is visible from where it is referenced.</a>
<a name="4351"><span class="lineNum">    4351 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="4352"><span class="lineNum">    4352 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;This enum IS visible from where it is referenced \n&quot;);</a>
<a name="4353"><span class="lineNum">    4353 </span>            : #endif</a>
<a name="4354"><span class="lineNum">    4354 </span>            :                                 // DQ (2/8/2019): If type elaboration was required, and the symbol is from a base class.</a>
<a name="4355"><span class="lineNum">    4355 </span>            :                                 // Then we need name qualification because the type elaboration will not protect the type</a>
<a name="4356"><span class="lineNum">    4356 </span>            :                                 // reference from being hidden.</a>
<a name="4357"><span class="lineNum">    4357 </span><span class="lineCov">       8664 :                                    if (typeElaborationIsRequired == true)</span></a>
<a name="4358"><span class="lineNum">    4358 </span>            :                                       {</a>
<a name="4359"><span class="lineNum">    4359 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="4360"><span class="lineNum">    4360 </span>            :                                         mfprintf(mlog [ WARN ] ) (&quot;   --- Since type elaboration was required because it was hidden, add name qualification to support it being unambiguous \n&quot;);</a>
<a name="4361"><span class="lineNum">    4361 </span>            : #endif</a>
<a name="4362"><span class="lineNum">    4362 </span>            :                                      // DQ (2/14/2019): If this is a typedef that is hidden by a variable then we don't require extra name qualification.</a>
<a name="4363"><span class="lineNum">    4363 </span><span class="lineNoCov">          0 :                                         if (isSgVariableSymbol(original_symbol_lookedup_by_name) != NULL)</span></a>
<a name="4364"><span class="lineNum">    4364 </span>            :                                            {</a>
<a name="4365"><span class="lineNum">    4365 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="4366"><span class="lineNum">    4366 </span>            :                                              mfprintf(mlog [ WARN ] ) (&quot;This enum IS visible and variables can't hide types, so no extra name qualification is required \n&quot;);</a>
<a name="4367"><span class="lineNum">    4367 </span>            : #endif</a>
<a name="4368"><span class="lineNum">    4368 </span>            :                                            }</a>
<a name="4369"><span class="lineNum">    4369 </span>            :                                           else</a>
<a name="4370"><span class="lineNum">    4370 </span>            :                                            {</a>
<a name="4371"><span class="lineNum">    4371 </span><span class="lineNoCov">          0 :                                              qualificationDepth = 1;</span></a>
<a name="4372"><span class="lineNum">    4372 </span>            :                                            }</a>
<a name="4373"><span class="lineNum">    4373 </span>            :                                       }</a>
<a name="4374"><span class="lineNum">    4374 </span>            :                                 // DQ (1/4/2020): Need to check if there is an opportunity for an ambigous reference.</a>
<a name="4375"><span class="lineNum">    4375 </span>            :                                 // size_t numberOfAliasSymbols = currentScope-&gt;count_alias_symbol(name);</a>
<a name="4376"><span class="lineNum">    4376 </span>            :                                 // symbol = SageInterface::lookupTemplateSymbolInParentScopes(name,currentScope);</a>
<a name="4377"><span class="lineNum">    4377 </span>            :                                 // SgScopeStatement* scopeOfAssociatedTypedefDeclaration = associatedTypedefDeclaration-&gt;get_scope();</a>
<a name="4378"><span class="lineNum">    4378 </span>            :                                 // ASSERT_not_null(scopeOfAssociatedTypedefDeclaration);</a>
<a name="4379"><span class="lineNum">    4379 </span>            :                                 // size_t numberOfAliasSymbols = scopeOfAssociatedTypedefDeclaration-&gt;count_alias_symbol(name);</a>
<a name="4380"><span class="lineNum">    4380 </span><span class="lineCov">       8664 :                                    bool includeCurrentScope = true;</span></a>
<a name="4381"><span class="lineNum">    4381 </span><span class="lineCov">       8664 :                                    SgClassDefinition* current_classDefinition = SageInterface::getEnclosingNode&lt;SgClassDefinition&gt;(currentScope,includeCurrentScope);</span></a>
<a name="4382"><span class="lineNum">    4382 </span><span class="lineCov">       8664 :                                    if (current_classDefinition != NULL)</span></a>
<a name="4383"><span class="lineNum">    4383 </span>            :                                       {</a>
<a name="4384"><span class="lineNum">    4384 </span><span class="lineCov">       2723 :                                         size_t numberOfAliasSymbols = current_classDefinition-&gt;count_alias_symbol(name);</span></a>
<a name="4385"><span class="lineNum">    4385 </span>            : #if 0</a>
<a name="4386"><span class="lineNum">    4386 </span>            :                                         mfprintf(mlog [ WARN ] ) (&quot;case V_SgEnumSymbol: numberOfAliasSymbols = %zu \n&quot;,numberOfAliasSymbols);</a>
<a name="4387"><span class="lineNum">    4387 </span>            : #endif</a>
<a name="4388"><span class="lineNum">    4388 </span><span class="lineCov">       2723 :                                         if (numberOfAliasSymbols &gt;= 2)</span></a>
<a name="4389"><span class="lineNum">    4389 </span>            :                                            {</a>
<a name="4390"><span class="lineNum">    4390 </span>            : #if 0</a>
<a name="4391"><span class="lineNum">    4391 </span>            :                                              mfprintf(mlog [ WARN ] ) (&quot;Detected numberOfAliasSymbols &gt;= 2: numberOfAliasSymbols = %zu \n&quot;,numberOfAliasSymbols);</a>
<a name="4392"><span class="lineNum">    4392 </span>            : #endif</a>
<a name="4393"><span class="lineNum">    4393 </span><span class="lineNoCov">          0 :                                              qualificationDepth = nameQualificationDepthOfParent(declaration,currentScope,positionStatement) + 1;</span></a>
<a name="4394"><span class="lineNum">    4394 </span>            :                                           // qualificationDepth += 1;</a>
<a name="4395"><span class="lineNum">    4395 </span>            : </a>
<a name="4396"><span class="lineNum">    4396 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="4397"><span class="lineNum">    4397 </span>            :                                              mfprintf(mlog [ WARN ] ) (&quot;   --- qualificationDepth = %d \n&quot;,qualificationDepth);</a>
<a name="4398"><span class="lineNum">    4398 </span>            : #endif</a>
<a name="4399"><span class="lineNum">    4399 </span>            :                                            }</a>
<a name="4400"><span class="lineNum">    4400 </span>            :                                       }</a>
<a name="4401"><span class="lineNum">    4401 </span>            :                                  }</a>
<a name="4402"><span class="lineNum">    4402 </span>            :                                 else</a>
<a name="4403"><span class="lineNum">    4403 </span>            :                                  {</a>
<a name="4404"><span class="lineNum">    4404 </span>            :                                 // The name does not match, so the associatedFunctionDeclaration is hidding the base class declaration.</a>
<a name="4405"><span class="lineNum">    4405 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="4406"><span class="lineNum">    4406 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;This enum is NOT visible from where it is referenced (declaration with same name does not match) \n&quot;);</a>
<a name="4407"><span class="lineNum">    4407 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;   --- currentScope      = %p = %s \n&quot;,currentScope,currentScope-&gt;class_name().c_str());</a>
<a name="4408"><span class="lineNum">    4408 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;   --- positionStatement = %p = %s \n&quot;,positionStatement,positionStatement-&gt;class_name().c_str());</a>
<a name="4409"><span class="lineNum">    4409 </span>            : #endif</a>
<a name="4410"><span class="lineNum">    4410 </span>            :                                 // Now resolve how much name qualification is required; what ever is required for the parent plus 1.</a>
<a name="4411"><span class="lineNum">    4411 </span><span class="lineCov">         18 :                                    qualificationDepth = nameQualificationDepthOfParent(declaration,currentScope,positionStatement) + 1;</span></a>
<a name="4412"><span class="lineNum">    4412 </span>            : #if 0</a>
<a name="4413"><span class="lineNum">    4413 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;Exiting for unimplemented case (typedef) \n&quot;);</a>
<a name="4414"><span class="lineNum">    4414 </span>            :                                    ROSE_ABORT();</a>
<a name="4415"><span class="lineNum">    4415 </span>            : #endif</a>
<a name="4416"><span class="lineNum">    4416 </span>            :                                  }</a>
<a name="4417"><span class="lineNum">    4417 </span>            : </a>
<a name="4418"><span class="lineNum">    4418 </span>            :                               break;</a>
<a name="4419"><span class="lineNum">    4419 </span>            :                             }</a>
<a name="4420"><span class="lineNum">    4420 </span>            : </a>
<a name="4421"><span class="lineNum">    4421 </span>            :                          case V_SgNonrealSymbol:</a>
<a name="4422"><span class="lineNum">    4422 </span>            :                             {</a>
<a name="4423"><span class="lineNum">    4423 </span>            : #if WARNING_FOR_NONREAL_DEVEL</a>
<a name="4424"><span class="lineNum">    4424 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;WARNING: Support for name qualification depth for SgNonrealSymbol is not implemented yet \n&quot;);</a>
<a name="4425"><span class="lineNum">    4425 </span>            : #endif</a>
<a name="4426"><span class="lineNum">    4426 </span>            :                               break;</a>
<a name="4427"><span class="lineNum">    4427 </span>            :                             }</a>
<a name="4428"><span class="lineNum">    4428 </span>            : </a>
<a name="4429"><span class="lineNum">    4429 </span><span class="lineNoCov">          0 :                          default:</span></a>
<a name="4430"><span class="lineNum">    4430 </span><span class="lineNoCov">          0 :                             {</span></a>
<a name="4431"><span class="lineNum">    4431 </span>            :                            // Handle cases are we work through specific example codes.</a>
<a name="4432"><span class="lineNum">    4432 </span><span class="lineNoCov">          0 :                               mfprintf(mlog [ WARN ] ) (&quot;default reached symbol = %s \n&quot;,symbol-&gt;class_name().c_str());</span></a>
<a name="4433"><span class="lineNum">    4433 </span><span class="lineNoCov">          0 :                               ROSE_ABORT();</span></a>
<a name="4434"><span class="lineNum">    4434 </span>            :                             }</a>
<a name="4435"><span class="lineNum">    4435 </span>            :                        }</a>
<a name="4436"><span class="lineNum">    4436 </span>            :                   }</a>
<a name="4437"><span class="lineNum">    4437 </span>            : #if 0</a>
<a name="4438"><span class="lineNum">    4438 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Testing for a SgTemplateInstantiationFunctionDecl \n&quot;);</a>
<a name="4439"><span class="lineNum">    4439 </span>            :                if (isSgTemplateInstantiationFunctionDecl(declaration) != NULL)</a>
<a name="4440"><span class="lineNum">    4440 </span>            :                   {</a>
<a name="4441"><span class="lineNum">    4441 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="4442"><span class="lineNum">    4442 </span>            :                     ROSE_ABORT();</a>
<a name="4443"><span class="lineNum">    4443 </span>            :                   }</a>
<a name="4444"><span class="lineNum">    4444 </span>            : #endif</a>
<a name="4445"><span class="lineNum">    4445 </span>            : </a>
<a name="4446"><span class="lineNum">    4446 </span>            : #if 0</a>
<a name="4447"><span class="lineNum">    4447 </span>            :             // DQ (2/8/2019): Adding this test to make sure that we have caught all possible cases.</a>
<a name="4448"><span class="lineNum">    4448 </span>            :                if (typeElaborationIsRequired == true)</a>
<a name="4449"><span class="lineNum">    4449 </span>            :                   {</a>
<a name="4450"><span class="lineNum">    4450 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="4451"><span class="lineNum">    4451 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Check that since type elaboration was required because it was hidden, we should have added name qualification to support it being unambiguous \n&quot;);</a>
<a name="4452"><span class="lineNum">    4452 </span>            : #endif</a>
<a name="4453"><span class="lineNum">    4453 </span>            :                     ROSE_ASSERT(qualificationDepth &gt; 0);</a>
<a name="4454"><span class="lineNum">    4454 </span>            :                   }</a>
<a name="4455"><span class="lineNum">    4455 </span>            : #endif</a>
<a name="4456"><span class="lineNum">    4456 </span>            :              }</a>
<a name="4457"><span class="lineNum">    4457 </span>            :             else</a>
<a name="4458"><span class="lineNum">    4458 </span>            :              {</a>
<a name="4459"><span class="lineNum">    4459 </span>            :             // DQ (4/2/2018): This is the predicate for this false branch.</a>
<a name="4460"><span class="lineNum">    4460 </span><span class="lineCov">     129752 :                ROSE_ASSERT(symbol == NULL);</span></a>
<a name="4461"><span class="lineNum">    4461 </span>            : </a>
<a name="4462"><span class="lineNum">    4462 </span>            :             // This class is visible from where it is referenced.</a>
<a name="4463"><span class="lineNum">    4463 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="4464"><span class="lineNum">    4464 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;\n\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ \n&quot;);</a>
<a name="4465"><span class="lineNum">    4465 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ \n&quot;);</a>
<a name="4466"><span class="lineNum">    4466 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ \n&quot;);</a>
<a name="4467"><span class="lineNum">    4467 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ \n&quot;);</a>
<a name="4468"><span class="lineNum">    4468 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;This declaration = %p = %s is NOT visible from where it is referenced (no declaration with same name, calling nameQualificationDepthOfParent()) \n&quot;,</a>
<a name="4469"><span class="lineNum">    4469 </span>            :                     declaration,declaration-&gt;class_name().c_str());</a>
<a name="4470"><span class="lineNum">    4470 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;   --- currentScope = %p = %s \n&quot;,currentScope,currentScope-&gt;class_name().c_str());</a>
<a name="4471"><span class="lineNum">    4471 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;   --- positionStatement = %p = %s \n&quot;,positionStatement,positionStatement-&gt;class_name().c_str());</a>
<a name="4472"><span class="lineNum">    4472 </span>            : </a>
<a name="4473"><span class="lineNum">    4473 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Calling nameQualificationDepthOfParent() \n&quot;);</a>
<a name="4474"><span class="lineNum">    4474 </span>            : #endif</a>
<a name="4475"><span class="lineNum">    4475 </span><span class="lineCov">     129752 :                qualificationDepth = nameQualificationDepthOfParent(declaration,currentScope,positionStatement) + 1;</span></a>
<a name="4476"><span class="lineNum">    4476 </span>            : #if 0</a>
<a name="4477"><span class="lineNum">    4477 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;NOTE: If the class is visible from where it is referenced then why are are adding one? \n&quot;);</a>
<a name="4478"><span class="lineNum">    4478 </span>            : #endif</a>
<a name="4479"><span class="lineNum">    4479 </span>            :              }</a>
<a name="4480"><span class="lineNum">    4480 </span>            :         }</a>
<a name="4481"><span class="lineNum">    4481 </span>            : </a>
<a name="4482"><span class="lineNum">    4482 </span>            :   // DQ (12/10/2016): Eliminating a warning that we want to be an error: -Werror=unused-but-set-variable.</a>
<a name="4483"><span class="lineNum">    4483 </span>            :   // DQ (12/10/2016): Debugging information that makes sure that typeElaborationIsRequired is used and so will not generate a warning.</a>
<a name="4484"><span class="lineNum">    4484 </span>            :   // This is a variable that is essential for internal debugging so we certainly don't want to eliminate it.</a>
<a name="4485"><span class="lineNum">    4485 </span><span class="lineCov">    1714820 :      if (typeElaborationIsRequired == true)</span></a>
<a name="4486"><span class="lineNum">    4486 </span>            :         {</a>
<a name="4487"><span class="lineNum">    4487 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="4488"><span class="lineNum">    4488 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Note that typeElaborationIsRequired == true \n&quot;);</a>
<a name="4489"><span class="lineNum">    4489 </span>            : #endif</a>
<a name="4490"><span class="lineNum">    4490 </span>            :         }</a>
<a name="4491"><span class="lineNum">    4491 </span>            : </a>
<a name="4492"><span class="lineNum">    4492 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="4493"><span class="lineNum">    4493 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::nameQualificationDepth(): qualificationDepth = %d Report type elaboration: typeElaborationIsRequired = %s \n&quot;,</a>
<a name="4494"><span class="lineNum">    4494 </span>            :           qualificationDepth,(typeElaborationIsRequired == true) ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="4495"><span class="lineNum">    4495 </span>            : #endif</a>
<a name="4496"><span class="lineNum">    4496 </span>            : </a>
<a name="4497"><span class="lineNum">    4497 </span><span class="lineCov">    1714820 :      return qualificationDepth;</span></a>
<a name="4498"><span class="lineNum">    4498 </span>            :    }</a>
<a name="4499"><span class="lineNum">    4499 </span>            : </a>
<a name="4500"><span class="lineNum">    4500 </span>            : </a>
<a name="4501"><span class="lineNum">    4501 </span>            : </a>
<a name="4502"><span class="lineNum">    4502 </span>            : SgDeclarationStatement*</a>
<a name="4503"><span class="lineNum">    4503 </span><span class="lineCov">    4894270 : NameQualificationTraversal::getDeclarationAssociatedWithType( SgType* type )</span></a>
<a name="4504"><span class="lineNum">    4504 </span>            :    {</a>
<a name="4505"><span class="lineNum">    4505 </span>            :   // Note that this function could be eliminated since it only wraps another function.</a>
<a name="4506"><span class="lineNum">    4506 </span>            : </a>
<a name="4507"><span class="lineNum">    4507 </span><span class="lineCov">    4894270 :      ASSERT_not_null(type);</span></a>
<a name="4508"><span class="lineNum">    4508 </span>            : </a>
<a name="4509"><span class="lineNum">    4509 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="4510"><span class="lineNum">    4510 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In getDeclarationAssociatedWithType(): type = %s \n&quot;,type-&gt;class_name().c_str());</a>
<a name="4511"><span class="lineNum">    4511 </span>            : #endif</a>
<a name="4512"><span class="lineNum">    4512 </span>            : </a>
<a name="4513"><span class="lineNum">    4513 </span>            :   // DQ (4/15/2019): Strip away any wrapped types (e.g. pointers and references).</a>
<a name="4514"><span class="lineNum">    4514 </span>            :   // Note: SgPointerMemberType is processed explicitly.</a>
<a name="4515"><span class="lineNum">    4515 </span>            :   // SgType* strippedType = type-&gt;stripType(SgType::STRIP_MODIFIER_TYPE|SgType::STRIP_REFERENCE_TYPE|SgType::STRIP_RVALUE_REFERENCE_TYPE|SgType::STRIP_POINTER_TYPE|SgType::STRIP_ARRAY_TYPE);</a>
<a name="4516"><span class="lineNum">    4516 </span><span class="lineCov">    4894270 :      SgType* strippedType = type-&gt;stripType(SgType::STRIP_MODIFIER_TYPE|SgType::STRIP_REFERENCE_TYPE|SgType::STRIP_RVALUE_REFERENCE_TYPE|SgType::STRIP_POINTER_TYPE|SgType::STRIP_ARRAY_TYPE);</span></a>
<a name="4517"><span class="lineNum">    4517 </span><span class="lineCov">    4894270 :      ASSERT_not_null(strippedType);</span></a>
<a name="4518"><span class="lineNum">    4518 </span>            : </a>
<a name="4519"><span class="lineNum">    4519 </span>            : #if 0</a>
<a name="4520"><span class="lineNum">    4520 </span>            :      if (type != strippedType)</a>
<a name="4521"><span class="lineNum">    4521 </span>            :         {</a>
<a name="4522"><span class="lineNum">    4522 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;In getDeclarationAssociatedWithType(): stripped away wrapped types (type = %s  strippedType = %s) \n&quot;,</a>
<a name="4523"><span class="lineNum">    4523 </span>            :                type-&gt;class_name().c_str(),strippedType-&gt;class_name().c_str());</a>
<a name="4524"><span class="lineNum">    4524 </span>            :         }</a>
<a name="4525"><span class="lineNum">    4525 </span>            : #endif</a>
<a name="4526"><span class="lineNum">    4526 </span>            : </a>
<a name="4527"><span class="lineNum">    4527 </span>            :   // Use the stripped type to evaluate the associated declaration.</a>
<a name="4528"><span class="lineNum">    4528 </span><span class="lineCov">    4894270 :      type = strippedType;</span></a>
<a name="4529"><span class="lineNum">    4529 </span>            : </a>
<a name="4530"><span class="lineNum">    4530 </span>            :   // DQ (4/28/2019): Note that this function calls stripType(), so it's use above is redundant.</a>
<a name="4531"><span class="lineNum">    4531 </span><span class="lineCov">    4894270 :      SgDeclarationStatement* declaration = type-&gt;getAssociatedDeclaration();</span></a>
<a name="4532"><span class="lineNum">    4532 </span>            : </a>
<a name="4533"><span class="lineNum">    4533 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="4534"><span class="lineNum">    4534 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In getDeclarationAssociatedWithType(): declaration = %p \n&quot;,declaration);</a>
<a name="4535"><span class="lineNum">    4535 </span>            : #endif</a>
<a name="4536"><span class="lineNum">    4536 </span>            : </a>
<a name="4537"><span class="lineNum">    4537 </span>            : #if 0</a>
<a name="4538"><span class="lineNum">    4538 </span>            :   // DQ (4/14/2019): Alternatively, it might be better to make a recursive call in the evaluateInheritedAttribute() traversal.</a>
<a name="4539"><span class="lineNum">    4539 </span>            : </a>
<a name="4540"><span class="lineNum">    4540 </span>            :   // DQ (4/14/2019): I think we might support decltype() via this function.</a>
<a name="4541"><span class="lineNum">    4541 </span>            :      SgDeclType* declType = isSgDeclType(type);</a>
<a name="4542"><span class="lineNum">    4542 </span>            :      if (declType != NULL)</a>
<a name="4543"><span class="lineNum">    4543 </span>            :         {</a>
<a name="4544"><span class="lineNum">    4544 </span>            :        // Not clear if we need to worry about when the base type of the SgPointerMemberType is a SgDeclType.</a>
<a name="4545"><span class="lineNum">    4545 </span>            : </a>
<a name="4546"><span class="lineNum">    4546 </span>            :        // We need to handle any possible name qualification of a type or SgVarRefExp used as decltype argument.</a>
<a name="4547"><span class="lineNum">    4547 </span>            :           SgExpression* baseExpression = declType-&gt;get_base_expression();</a>
<a name="4548"><span class="lineNum">    4548 </span>            :           SgType*       baseType       = declType-&gt;get_base_type();</a>
<a name="4549"><span class="lineNum">    4549 </span>            :           if (baseExpression != NULL)</a>
<a name="4550"><span class="lineNum">    4550 </span>            :              {</a>
<a name="4551"><span class="lineNum">    4551 </span>            :             // Need name qualification for expression used in decltype().</a>
<a name="4552"><span class="lineNum">    4552 </span>            :                declaration = baseExpression-&gt;getAssociatedDeclaration();</a>
<a name="4553"><span class="lineNum">    4553 </span>            :              }</a>
<a name="4554"><span class="lineNum">    4554 </span>            :             else</a>
<a name="4555"><span class="lineNum">    4555 </span>            :              {</a>
<a name="4556"><span class="lineNum">    4556 </span>            :             // Need name qualification for type used in decltype().</a>
<a name="4557"><span class="lineNum">    4557 </span>            :                ASSERT_not_null(baseType);</a>
<a name="4558"><span class="lineNum">    4558 </span>            : </a>
<a name="4559"><span class="lineNum">    4559 </span>            :                declaration = baseType-&gt;getAssociatedDeclaration();</a>
<a name="4560"><span class="lineNum">    4560 </span>            :              }</a>
<a name="4561"><span class="lineNum">    4561 </span>            :         }</a>
<a name="4562"><span class="lineNum">    4562 </span>            : #endif</a>
<a name="4563"><span class="lineNum">    4563 </span>            : </a>
<a name="4564"><span class="lineNum">    4564 </span>            : </a>
<a name="4565"><span class="lineNum">    4565 </span>            :   // Primative types will not have an asociated declaration...</a>
<a name="4566"><span class="lineNum">    4566 </span>            :   // ASSERT_not_null(declaration);</a>
<a name="4567"><span class="lineNum">    4567 </span><span class="lineCov">    4894270 :      if (declaration == NULL)</span></a>
<a name="4568"><span class="lineNum">    4568 </span>            :         {</a>
<a name="4569"><span class="lineNum">    4569 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="4570"><span class="lineNum">    4570 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;In getDeclarationAssociatedWithType(): declaration == NULL type = %s \n&quot;,type-&gt;class_name().c_str());</a>
<a name="4571"><span class="lineNum">    4571 </span>            : #endif</a>
<a name="4572"><span class="lineNum">    4572 </span>            : </a>
<a name="4573"><span class="lineNum">    4573 </span>            : #if 0</a>
<a name="4574"><span class="lineNum">    4574 </span>            :        // DQ (3/29/2019): Adding support for pointer to member type.</a>
<a name="4575"><span class="lineNum">    4575 </span>            :           SgPointerMemberType* pointerToMember = isSgPointerMemberType(type);</a>
<a name="4576"><span class="lineNum">    4576 </span>            :           if (pointerToMember != NULL)</a>
<a name="4577"><span class="lineNum">    4577 </span>            :              {</a>
<a name="4578"><span class="lineNum">    4578 </span>            :             // DQ (4/9/2019): If this is a SgPointerMemberType then it has two parts, and possible name qualification</a>
<a name="4579"><span class="lineNum">    4579 </span>            :             // for the SgInitializedName or SgFunctionDeclaration, and another one for the base type of the SgPointerMemberType.</a>
<a name="4580"><span class="lineNum">    4580 </span>            :             // So this function has to requrn the base type of the SgPointerMemberType.  So we have to return the declaration</a>
<a name="4581"><span class="lineNum">    4581 </span>            :             // associated with the base type.</a>
<a name="4582"><span class="lineNum">    4582 </span>            : </a>
<a name="4583"><span class="lineNum">    4583 </span>            :                ASSERT_not_null(pointerToMember-&gt;get_base_type());</a>
<a name="4584"><span class="lineNum">    4584 </span>            :                declaration = pointerToMember-&gt;get_base_type()-&gt;getAssociatedDeclaration();</a>
<a name="4585"><span class="lineNum">    4585 </span>            : </a>
<a name="4586"><span class="lineNum">    4586 </span>            : #if 1</a>
<a name="4587"><span class="lineNum">    4587 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Detected SgPointerMemberType: pointerToMember = %p: declaration = %p = %s \n&quot;,pointerToMember,declaration,declaration != NULL ? declaration-&gt;class_name().c_str() : &quot;null&quot;);</a>
<a name="4588"><span class="lineNum">    4588 </span>            : #endif</a>
<a name="4589"><span class="lineNum">    4589 </span>            : #if 0</a>
<a name="4590"><span class="lineNum">    4590 </span>            :             // SgClassType* classType = pointerToMember-&gt;class_type();</a>
<a name="4591"><span class="lineNum">    4591 </span>            :             // ASSERT_not_null(classType);</a>
<a name="4592"><span class="lineNum">    4592 </span>            :             // declaration = getDeclarationAssociatedWithType(classType);</a>
<a name="4593"><span class="lineNum">    4593 </span>            :             // SgClassDefinition* classDefinition = pointerToMember-&gt;get_class_of();</a>
<a name="4594"><span class="lineNum">    4594 </span>            :             // ASSERT_not_null(classDefinition);</a>
<a name="4595"><span class="lineNum">    4595 </span>            :             // declaration = classDefinition-&gt;get_declaration();</a>
<a name="4596"><span class="lineNum">    4596 </span>            :             // ASSERT_not_null(declaration);</a>
<a name="4597"><span class="lineNum">    4597 </span>            : #endif</a>
<a name="4598"><span class="lineNum">    4598 </span>            : #if 0</a>
<a name="4599"><span class="lineNum">    4599 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="4600"><span class="lineNum">    4600 </span>            :                ROSE_ABORT();</a>
<a name="4601"><span class="lineNum">    4601 </span>            : #endif</a>
<a name="4602"><span class="lineNum">    4602 </span>            :              }</a>
<a name="4603"><span class="lineNum">    4603 </span>            : #endif</a>
<a name="4604"><span class="lineNum">    4604 </span>            : </a>
<a name="4605"><span class="lineNum">    4605 </span>            : #if 0</a>
<a name="4606"><span class="lineNum">    4606 </span>            :           SgArrayType* arrayType = isSgArrayType(type);</a>
<a name="4607"><span class="lineNum">    4607 </span>            :           if (arrayType != NULL)</a>
<a name="4608"><span class="lineNum">    4608 </span>            :              {</a>
<a name="4609"><span class="lineNum">    4609 </span>            : #if 0</a>
<a name="4610"><span class="lineNum">    4610 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Detected SgArrayType: checking for variable reference in index (might be redundant): arrayType = %p \n&quot;,arrayType);</a>
<a name="4611"><span class="lineNum">    4611 </span>            : #endif</a>
<a name="4612"><span class="lineNum">    4612 </span>            : #if 0</a>
<a name="4613"><span class="lineNum">    4613 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="4614"><span class="lineNum">    4614 </span>            :                ROSE_ABORT();</a>
<a name="4615"><span class="lineNum">    4615 </span>            : #endif</a>
<a name="4616"><span class="lineNum">    4616 </span>            :              }</a>
<a name="4617"><span class="lineNum">    4617 </span>            : #endif</a>
<a name="4618"><span class="lineNum">    4618 </span>            :         }</a>
<a name="4619"><span class="lineNum">    4619 </span>            :        else</a>
<a name="4620"><span class="lineNum">    4620 </span>            :         {</a>
<a name="4621"><span class="lineNum">    4621 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="4622"><span class="lineNum">    4622 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;In getDeclarationAssociatedWithType(): declaration                                    = %p = %s \n&quot;,declaration,SageInterface::get_name(declaration).c_str());</a>
<a name="4623"><span class="lineNum">    4623 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;In getDeclarationAssociatedWithType(): declaration-&gt;get_firstNondefiningDeclaration() = %p \n&quot;,declaration-&gt;get_firstNondefiningDeclaration());</a>
<a name="4624"><span class="lineNum">    4624 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;In getDeclarationAssociatedWithType(): declaration-&gt;get_definingDeclaration()         = %p \n&quot;,declaration-&gt;get_definingDeclaration());</a>
<a name="4625"><span class="lineNum">    4625 </span>            : #endif</a>
<a name="4626"><span class="lineNum">    4626 </span>            : </a>
<a name="4627"><span class="lineNum">    4627 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="4628"><span class="lineNum">    4628 </span>            :           if (declaration != declaration-&gt;get_firstNondefiningDeclaration())</a>
<a name="4629"><span class="lineNum">    4629 </span>            :              {</a>
<a name="4630"><span class="lineNum">    4630 </span>            :             // Output some debug information to learn more about this error</a>
<a name="4631"><span class="lineNum">    4631 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;In getDeclarationAssociatedWithType(): declaration = %p = %s \n&quot;,declaration,declaration-&gt;class_name().c_str());</a>
<a name="4632"><span class="lineNum">    4632 </span>            :                ASSERT_not_null(declaration-&gt;get_file_info());</a>
<a name="4633"><span class="lineNum">    4633 </span>            :                declaration-&gt;get_file_info()-&gt;display(&quot;declaration&quot;);</a>
<a name="4634"><span class="lineNum">    4634 </span>            : </a>
<a name="4635"><span class="lineNum">    4635 </span>            :                ASSERT_not_null(declaration-&gt;get_firstNondefiningDeclaration());</a>
<a name="4636"><span class="lineNum">    4636 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;In getDeclarationAssociatedWithType(): declaration-&gt;get_firstNondefiningDeclaration() = %p = %s \n&quot;,declaration-&gt;get_firstNondefiningDeclaration(),declaration-&gt;get_firstNondefiningDeclaration()-&gt;class_name().c_str());</a>
<a name="4637"><span class="lineNum">    4637 </span>            :                ASSERT_not_null(declaration-&gt;get_firstNondefiningDeclaration()-&gt;get_file_info());</a>
<a name="4638"><span class="lineNum">    4638 </span>            :                declaration-&gt;get_firstNondefiningDeclaration()-&gt;get_file_info()-&gt;display(&quot;declaration-&gt;get_firstNondefiningDeclaration()&quot;);</a>
<a name="4639"><span class="lineNum">    4639 </span>            :              }</a>
<a name="4640"><span class="lineNum">    4640 </span>            : #endif</a>
<a name="4641"><span class="lineNum">    4641 </span>            : </a>
<a name="4642"><span class="lineNum">    4642 </span>            :        // DQ (11/6/2011): I think it is OK for where this is a SgEnumDeclaration.</a>
<a name="4643"><span class="lineNum">    4643 </span>            :        // ROSE_ASSERT(declaration == declaration-&gt;get_firstNondefiningDeclaration());</a>
<a name="4644"><span class="lineNum">    4644 </span><span class="lineCov">    4054910 :           ROSE_ASSERT(declaration == declaration-&gt;get_firstNondefiningDeclaration() || isSgEnumDeclaration(declaration) != NULL);</span></a>
<a name="4645"><span class="lineNum">    4645 </span>            :         }</a>
<a name="4646"><span class="lineNum">    4646 </span>            : </a>
<a name="4647"><span class="lineNum">    4647 </span><span class="lineCov">    4894270 :      return declaration;</span></a>
<a name="4648"><span class="lineNum">    4648 </span>            :    }</a>
<a name="4649"><span class="lineNum">    4649 </span>            : </a>
<a name="4650"><span class="lineNum">    4650 </span>            : </a>
<a name="4651"><span class="lineNum">    4651 </span>            : #define DEBUG_NAME_QUALIFICATION_LEVEL_FOR_TEMPLATE_ARGUMENTS 0</a>
<a name="4652"><span class="lineNum">    4652 </span>            : </a>
<a name="4653"><span class="lineNum">    4653 </span>            : // void evaluateNameQualificationForTemplateArgumentList (SgTemplateArgumentPtrList &amp; templateArgumentList, SgScopeStatement* currentScope, SgStatement* positionStatement);</a>
<a name="4654"><span class="lineNum">    4654 </span>            : void</a>
<a name="4655"><span class="lineNum">    4655 </span><span class="lineCov">     326781 : NameQualificationTraversal::evaluateNameQualificationForTemplateArgumentList (SgTemplateArgumentPtrList &amp; templateArgumentList, SgScopeStatement* currentScope, SgStatement* positionStatement)</span></a>
<a name="4656"><span class="lineNum">    4656 </span>            :    {</a>
<a name="4657"><span class="lineNum">    4657 </span>            :   // DQ (6/4/2011): Note that test2005_73.C demonstrate where the Template arguments are shared between template instantiations.</a>
<a name="4658"><span class="lineNum">    4658 </span>            : </a>
<a name="4659"><span class="lineNum">    4659 </span>            :   // DQ (9/24/2012): Track the recursive depth in computing name qualification for template arguments of template instantiations used as template arguments.</a>
<a name="4660"><span class="lineNum">    4660 </span><span class="lineCov">     326781 :      static int recursiveDepth = 0;</span></a>
<a name="4661"><span class="lineNum">    4661 </span>            : </a>
<a name="4662"><span class="lineNum">    4662 </span>            :   // Used for debugging...</a>
<a name="4663"><span class="lineNum">    4663 </span><span class="lineCov">     326781 :      int counter = 0;</span></a>
<a name="4664"><span class="lineNum">    4664 </span>            : </a>
<a name="4665"><span class="lineNum">    4665 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="4666"><span class="lineNum">    4666 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;\n\n*********************************************************************************************************************\n&quot;);</a>
<a name="4667"><span class="lineNum">    4667 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::evaluateNameQualificationForTemplateArgumentList(): templateArgumentList.size() = %&quot; PRIuPTR &quot; recursiveDepth = %d \n&quot;,templateArgumentList.size(),recursiveDepth);</a>
<a name="4668"><span class="lineNum">    4668 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;*********************************************************************************************************************\n&quot;);</a>
<a name="4669"><span class="lineNum">    4669 </span>            : </a>
<a name="4670"><span class="lineNum">    4670 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::evaluateNameQualificationForTemplateArgumentList(): currentScope = %p = %s positionStatement = %p = %s \n&quot;,</a>
<a name="4671"><span class="lineNum">    4671 </span>            :           currentScope,currentScope-&gt;class_name().c_str(),positionStatement,positionStatement-&gt;class_name().c_str());</a>
<a name="4672"><span class="lineNum">    4672 </span>            : </a>
<a name="4673"><span class="lineNum">    4673 </span>            :      ASSERT_not_null(positionStatement);</a>
<a name="4674"><span class="lineNum">    4674 </span>            :      positionStatement-&gt;get_file_info()-&gt;display(&quot;In NameQualificationTraversal::evaluateNameQualificationForTemplateArgumentList()&quot;);</a>
<a name="4675"><span class="lineNum">    4675 </span>            : #endif</a>
<a name="4676"><span class="lineNum">    4676 </span>            : </a>
<a name="4677"><span class="lineNum">    4677 </span><span class="lineCov">     326781 :      SgTemplateArgumentPtrList::iterator i = templateArgumentList.begin();</span></a>
<a name="4678"><span class="lineNum">    4678 </span><span class="lineCov">     640883 :      while (i != templateArgumentList.end())</span></a>
<a name="4679"><span class="lineNum">    4679 </span>            :         {</a>
<a name="4680"><span class="lineNum">    4680 </span><span class="lineCov">     314102 :           SgTemplateArgument* templateArgument = *i;</span></a>
<a name="4681"><span class="lineNum">    4681 </span><span class="lineCov">     314102 :           ASSERT_not_null(templateArgument);</span></a>
<a name="4682"><span class="lineNum">    4682 </span>            : </a>
<a name="4683"><span class="lineNum">    4683 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || DEBUG_NAME_QUALIFICATION_LEVEL_FOR_TEMPLATE_ARGUMENTS</a>
<a name="4684"><span class="lineNum">    4684 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;*** Processing template argument #%d templateArgument = %p \n&quot;,counter,templateArgument);</a>
<a name="4685"><span class="lineNum">    4685 </span>            :        // SgName testNameInMap = templateArgument-&gt;get_qualified_name_prefix();</a>
<a name="4686"><span class="lineNum">    4686 </span>            : #endif</a>
<a name="4687"><span class="lineNum">    4687 </span>            : #if 0</a>
<a name="4688"><span class="lineNum">    4688 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;===== Before being finished with evaluation of templateArgument name qualification: testNameInMap = %s \n&quot;,templateArgument-&gt;unparseToString().c_str());</a>
<a name="4689"><span class="lineNum">    4689 </span>            : #endif</a>
<a name="4690"><span class="lineNum">    4690 </span>            : </a>
<a name="4691"><span class="lineNum">    4691 </span>            :        // DQ (5/29/2019): Newer version of code (still refactoring this section).</a>
<a name="4692"><span class="lineNum">    4692 </span><span class="lineCov">     314102 :           switch (templateArgument-&gt;get_argumentType())</span></a>
<a name="4693"><span class="lineNum">    4693 </span>            :              {</a>
<a name="4694"><span class="lineNum">    4694 </span><span class="lineCov">     300304 :                case SgTemplateArgument::type_argument:</span></a>
<a name="4695"><span class="lineNum">    4695 </span><span class="lineCov">     300304 :                   {</span></a>
<a name="4696"><span class="lineNum">    4696 </span><span class="lineCov">     300304 :                     ASSERT_not_null(templateArgument-&gt;get_type());</span></a>
<a name="4697"><span class="lineNum">    4697 </span><span class="lineCov">     300304 :                     SgType* type = templateArgument-&gt;get_type();</span></a>
<a name="4698"><span class="lineNum">    4698 </span>            : </a>
<a name="4699"><span class="lineNum">    4699 </span><span class="lineCov">     300304 :                     ASSERT_not_null(type);</span></a>
<a name="4700"><span class="lineNum">    4700 </span>            : </a>
<a name="4701"><span class="lineNum">    4701 </span><span class="lineCov">     300304 :                     break;</span></a>
<a name="4702"><span class="lineNum">    4702 </span>            :                   }</a>
<a name="4703"><span class="lineNum">    4703 </span>            : </a>
<a name="4704"><span class="lineNum">    4704 </span><span class="lineCov">      10045 :                case SgTemplateArgument::nontype_argument:</span></a>
<a name="4705"><span class="lineNum">    4705 </span><span class="lineCov">      10045 :                   {</span></a>
<a name="4706"><span class="lineNum">    4706 </span>            :                  // DQ (8/12/2013): This can be either an SgExpression or SgInitializedName.</a>
<a name="4707"><span class="lineNum">    4707 </span>            :                  // ASSERT_not_null(templateArgument-&gt;get_expression());</a>
<a name="4708"><span class="lineNum">    4708 </span><span class="lineCov">      10045 :                     ROSE_ASSERT (templateArgument-&gt;get_expression() != NULL || templateArgument-&gt;get_initializedName() != NULL);</span></a>
<a name="4709"><span class="lineNum">    4709 </span><span class="lineCov">      10045 :                     ROSE_ASSERT (templateArgument-&gt;get_expression() == NULL || templateArgument-&gt;get_initializedName() == NULL);</span></a>
<a name="4710"><span class="lineNum">    4710 </span><span class="lineCov">      10045 :                     if (templateArgument-&gt;get_expression() != NULL)</span></a>
<a name="4711"><span class="lineNum">    4711 </span>            :                        {</a>
<a name="4712"><span class="lineNum">    4712 </span><span class="lineCov">      10045 :                          SgExpression* expression = templateArgument-&gt;get_expression();</span></a>
<a name="4713"><span class="lineNum">    4713 </span>            : </a>
<a name="4714"><span class="lineNum">    4714 </span><span class="lineCov">      10045 :                          ASSERT_not_null(expression);</span></a>
<a name="4715"><span class="lineNum">    4715 </span>            :                        }</a>
<a name="4716"><span class="lineNum">    4716 </span>            :                       else</a>
<a name="4717"><span class="lineNum">    4717 </span>            :                        {</a>
<a name="4718"><span class="lineNum">    4718 </span><span class="lineNoCov">          0 :                          SgType* type = templateArgument-&gt;get_initializedName()-&gt;get_type();</span></a>
<a name="4719"><span class="lineNum">    4719 </span><span class="lineNoCov">          0 :                          ASSERT_not_null(type);</span></a>
<a name="4720"><span class="lineNum">    4720 </span><span class="lineNoCov">          0 :                          SgInitializedName * iname = templateArgument-&gt;get_initializedName();</span></a>
<a name="4721"><span class="lineNum">    4721 </span>            : </a>
<a name="4722"><span class="lineNum">    4722 </span><span class="lineNoCov">          0 :                          ASSERT_not_null(iname);</span></a>
<a name="4723"><span class="lineNum">    4723 </span>            :                        }</a>
<a name="4724"><span class="lineNum">    4724 </span>            : </a>
<a name="4725"><span class="lineNum">    4725 </span>            :                     break;</a>
<a name="4726"><span class="lineNum">    4726 </span>            :                   }</a>
<a name="4727"><span class="lineNum">    4727 </span>            : </a>
<a name="4728"><span class="lineNum">    4728 </span><span class="lineCov">        176 :                case SgTemplateArgument::template_template_argument:</span></a>
<a name="4729"><span class="lineNum">    4729 </span><span class="lineCov">        176 :                   {</span></a>
<a name="4730"><span class="lineNum">    4730 </span>            :                  // SgDeclarationStatement * tpldecl = templateArgument-&gt;get_templateDeclaration();</a>
<a name="4731"><span class="lineNum">    4731 </span><span class="lineCov">        176 :                     SgDeclarationStatement * decl = templateArgument-&gt;get_templateDeclaration();</span></a>
<a name="4732"><span class="lineNum">    4732 </span><span class="lineCov">        176 :                     ASSERT_not_null(decl);</span></a>
<a name="4733"><span class="lineNum">    4733 </span>            : </a>
<a name="4734"><span class="lineNum">    4734 </span><span class="lineCov">        176 :                     SgTemplateDeclaration * tpl_decl = isSgTemplateDeclaration(decl);</span></a>
<a name="4735"><span class="lineNum">    4735 </span><span class="lineCov">        176 :                     ROSE_ASSERT(tpl_decl == NULL);</span></a>
<a name="4736"><span class="lineNum">    4736 </span>            : </a>
<a name="4737"><span class="lineNum">    4737 </span><span class="lineCov">        176 :                     break;</span></a>
<a name="4738"><span class="lineNum">    4738 </span>            :                   }</a>
<a name="4739"><span class="lineNum">    4739 </span>            : </a>
<a name="4740"><span class="lineNum">    4740 </span>            :                 case SgTemplateArgument::start_of_pack_expansion_argument:</a>
<a name="4741"><span class="lineNum">    4741 </span>            :                   {</a>
<a name="4742"><span class="lineNum">    4742 </span>            : #if 0</a>
<a name="4743"><span class="lineNum">    4743 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;WARNING: start_of_pack_expansion_argument in evaluateNameQualificationForTemplateArgumentList (can happen from some debug output)\n&quot;);</a>
<a name="4744"><span class="lineNum">    4744 </span>            : #endif</a>
<a name="4745"><span class="lineNum">    4745 </span>            :                     break;</a>
<a name="4746"><span class="lineNum">    4746 </span>            :                   }</a>
<a name="4747"><span class="lineNum">    4747 </span>            : </a>
<a name="4748"><span class="lineNum">    4748 </span><span class="lineNoCov">          0 :                case SgTemplateArgument::argument_undefined:</span></a>
<a name="4749"><span class="lineNum">    4749 </span><span class="lineNoCov">          0 :                   {</span></a>
<a name="4750"><span class="lineNum">    4750 </span><span class="lineNoCov">          0 :                     mfprintf(mlog [ WARN ] ) (&quot;Error argument_undefined in evaluateNameQualificationForTemplateArgumentList \n&quot;);</span></a>
<a name="4751"><span class="lineNum">    4751 </span><span class="lineNoCov">          0 :                     ROSE_ABORT();</span></a>
<a name="4752"><span class="lineNum">    4752 </span>            :                     break;</a>
<a name="4753"><span class="lineNum">    4753 </span>            :                   }</a>
<a name="4754"><span class="lineNum">    4754 </span>            : </a>
<a name="4755"><span class="lineNum">    4755 </span><span class="lineNoCov">          0 :                default:</span></a>
<a name="4756"><span class="lineNum">    4756 </span><span class="lineNoCov">          0 :                   {</span></a>
<a name="4757"><span class="lineNum">    4757 </span><span class="lineNoCov">          0 :                     mfprintf(mlog [ WARN ] ) (&quot;Error default reached in evaluateNameQualificationForTemplateArgumentList \n&quot;);</span></a>
<a name="4758"><span class="lineNum">    4758 </span><span class="lineNoCov">          0 :                     ROSE_ABORT();</span></a>
<a name="4759"><span class="lineNum">    4759 </span>            :                   }</a>
<a name="4760"><span class="lineNum">    4760 </span>            :              }</a>
<a name="4761"><span class="lineNum">    4761 </span>            : </a>
<a name="4762"><span class="lineNum">    4762 </span>            :        // DQ (5/29/2019): Older version of code.</a>
<a name="4763"><span class="lineNum">    4763 </span><span class="lineCov">     314102 :           SgType* type                     = templateArgument-&gt;get_type();</span></a>
<a name="4764"><span class="lineNum">    4764 </span><span class="lineCov">     314102 :           SgExpression* expression         = templateArgument-&gt;get_expression();</span></a>
<a name="4765"><span class="lineNum">    4765 </span><span class="lineCov">     314102 :           SgDeclarationStatement * tpldecl = templateArgument-&gt;get_templateDeclaration();</span></a>
<a name="4766"><span class="lineNum">    4766 </span><span class="lineCov">     314102 :           SgInitializedName * iname        = templateArgument-&gt;get_initializedName();</span></a>
<a name="4767"><span class="lineNum">    4767 </span><span class="lineCov">     314102 :           if (type != NULL)</span></a>
<a name="4768"><span class="lineNum">    4768 </span>            :              {</a>
<a name="4769"><span class="lineNum">    4769 </span>            :             // Reduce the type to the base type stripping off wrappers that would hide the fundamental type inside.</a>
<a name="4770"><span class="lineNum">    4770 </span><span class="lineCov">     300304 :                SgType* strippedType = type-&gt;stripType(SgType::STRIP_MODIFIER_TYPE|SgType::STRIP_REFERENCE_TYPE|SgType::STRIP_RVALUE_REFERENCE_TYPE|SgType::STRIP_POINTER_TYPE|SgType::STRIP_ARRAY_TYPE);</span></a>
<a name="4771"><span class="lineNum">    4771 </span><span class="lineCov">     300304 :                ASSERT_not_null(strippedType);</span></a>
<a name="4772"><span class="lineNum">    4772 </span>            : </a>
<a name="4773"><span class="lineNum">    4773 </span>            :             // SgNamedType* namedType = isSgNamedType(type);</a>
<a name="4774"><span class="lineNum">    4774 </span><span class="lineCov">     300304 :                SgNamedType* namedType = isSgNamedType(strippedType);</span></a>
<a name="4775"><span class="lineNum">    4775 </span><span class="lineCov">     300304 :                if (namedType != NULL)</span></a>
<a name="4776"><span class="lineNum">    4776 </span>            :                   {</a>
<a name="4777"><span class="lineNum">    4777 </span>            :                  // This could be a type that requires name qualification (reference to a declaration).</a>
<a name="4778"><span class="lineNum">    4778 </span>            : </a>
<a name="4779"><span class="lineNum">    4779 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || DEBUG_NAME_QUALIFICATION_LEVEL_FOR_TEMPLATE_ARGUMENTS</a>
<a name="4780"><span class="lineNum">    4780 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;templateArgument = %p contains type which is namedType = %p = %s \n&quot;,templateArgument,namedType,namedType-&gt;class_name().c_str());</a>
<a name="4781"><span class="lineNum">    4781 </span>            : #endif</a>
<a name="4782"><span class="lineNum">    4782 </span><span class="lineCov">     117166 :                     SgDeclarationStatement* templateArgumentTypeDeclaration = getDeclarationAssociatedWithType(type);</span></a>
<a name="4783"><span class="lineNum">    4783 </span><span class="lineCov">     117166 :                     if (templateArgumentTypeDeclaration != NULL)</span></a>
<a name="4784"><span class="lineNum">    4784 </span>            :                        {</a>
<a name="4785"><span class="lineNum">    4785 </span>            :                       // Check the visability and unambiguity of this declaration.</a>
<a name="4786"><span class="lineNum">    4786 </span>            :                       // Note that since the recursion happens before we set the names, all qualified name are set first</a>
<a name="4787"><span class="lineNum">    4787 </span>            :                       // at the nested types and then used in the setting of qualified names at the higher level types</a>
<a name="4788"><span class="lineNum">    4788 </span>            :                       // (less nested types).</a>
<a name="4789"><span class="lineNum">    4789 </span>            : </a>
<a name="4790"><span class="lineNum">    4790 </span>            :                       // DQ (5/15/2011): Added recursive handling of template arguments which can require name qualification.</a>
<a name="4791"><span class="lineNum">    4791 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || DEBUG_NAME_QUALIFICATION_LEVEL_FOR_TEMPLATE_ARGUMENTS</a>
<a name="4792"><span class="lineNum">    4792 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;xxxxxx --- Making a RECURSIVE call to nameQualificationDepth() on the template argument recursiveDepth = %d \n&quot;,recursiveDepth);</a>
<a name="4793"><span class="lineNum">    4793 </span>            :                       // DQ (9/24/2012): I think this is the way to make the recursive call to handle name qualification of template arguments in nexted template instantiations.</a>
<a name="4794"><span class="lineNum">    4794 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;Need to call evaluateNameQualificationForTemplateArgumentList() on any possible template argument list for type in templateArgument = %p (namely namedType = %p = %s) \n&quot;,</a>
<a name="4795"><span class="lineNum">    4795 </span>            :                               templateArgument,namedType,namedType-&gt;class_name().c_str());</a>
<a name="4796"><span class="lineNum">    4796 </span>            : #endif</a>
<a name="4797"><span class="lineNum">    4797 </span>            : </a>
<a name="4798"><span class="lineNum">    4798 </span><span class="lineCov">     117166 :                          SgClassType* classType = isSgClassType(namedType);</span></a>
<a name="4799"><span class="lineNum">    4799 </span><span class="lineCov">     117166 :                          SgNonrealType* nrType = isSgNonrealType(namedType);</span></a>
<a name="4800"><span class="lineNum">    4800 </span><span class="lineCov">     117166 :                          if (classType != NULL)</span></a>
<a name="4801"><span class="lineNum">    4801 </span>            :                             {</a>
<a name="4802"><span class="lineNum">    4802 </span>            :                            // If this is a class then it should be relative to it's declaration.</a>
<a name="4803"><span class="lineNum">    4803 </span><span class="lineCov">      68472 :                               SgClassDeclaration* classDeclaration = isSgClassDeclaration(classType-&gt;get_declaration());</span></a>
<a name="4804"><span class="lineNum">    4804 </span><span class="lineCov">      68472 :                               ASSERT_not_null(classDeclaration);</span></a>
<a name="4805"><span class="lineNum">    4805 </span>            : </a>
<a name="4806"><span class="lineNum">    4806 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || DEBUG_NAME_QUALIFICATION_LEVEL_FOR_TEMPLATE_ARGUMENTS</a>
<a name="4807"><span class="lineNum">    4807 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;namedType is a SgClassType: classDeclaration = %p = %s \n&quot;,classDeclaration,classDeclaration-&gt;class_name().c_str());</a>
<a name="4808"><span class="lineNum">    4808 </span>            : #endif</a>
<a name="4809"><span class="lineNum">    4809 </span><span class="lineCov">      68472 :                               SgTemplateInstantiationDecl* templateClassInstantiationDeclaration = isSgTemplateInstantiationDecl(classDeclaration);</span></a>
<a name="4810"><span class="lineNum">    4810 </span><span class="lineCov">      68472 :                               if (templateClassInstantiationDeclaration != NULL)</span></a>
<a name="4811"><span class="lineNum">    4811 </span>            :                                  {</a>
<a name="4812"><span class="lineNum">    4812 </span><span class="lineCov">      64571 :                                    recursiveDepth++;</span></a>
<a name="4813"><span class="lineNum">    4813 </span><span class="lineCov">      64571 :                                    evaluateNameQualificationForTemplateArgumentList(templateClassInstantiationDeclaration-&gt;get_templateArguments(),currentScope,positionStatement);</span></a>
<a name="4814"><span class="lineNum">    4814 </span><span class="lineCov">      64571 :                                    recursiveDepth--;</span></a>
<a name="4815"><span class="lineNum">    4815 </span>            :                                  }</a>
<a name="4816"><span class="lineNum">    4816 </span>            :                             }</a>
<a name="4817"><span class="lineNum">    4817 </span>            :                            else if (nrType == NULL)</a>
<a name="4818"><span class="lineNum">    4818 </span>            :                             {</a>
<a name="4819"><span class="lineNum">    4819 </span>            :                            // If not a class then (e.g. typedef) then it is relative to the typedef declaration, but we don't have to recursively evaluate the type.</a>
<a name="4820"><span class="lineNum">    4820 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || DEBUG_NAME_QUALIFICATION_LEVEL_FOR_TEMPLATE_ARGUMENTS</a>
<a name="4821"><span class="lineNum">    4821 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;This is not a SgClassType nor a SgNonrealType, so we don't have to recursively evaluate for template arguments. \n&quot;);</a>
<a name="4822"><span class="lineNum">    4822 </span>            : #endif</a>
<a name="4823"><span class="lineNum">    4823 </span>            :                             }</a>
<a name="4824"><span class="lineNum">    4824 </span>            : </a>
<a name="4825"><span class="lineNum">    4825 </span><span class="lineCov">     117166 :                          if (nrType != NULL) {</span></a>
<a name="4826"><span class="lineNum">    4826 </span><span class="lineCov">      28823 :                            SgNonrealDecl * nrdecl = isSgNonrealDecl(nrType-&gt;get_declaration());</span></a>
<a name="4827"><span class="lineNum">    4827 </span><span class="lineCov">      28823 :                            ASSERT_not_null(nrdecl);</span></a>
<a name="4828"><span class="lineNum">    4828 </span>            : </a>
<a name="4829"><span class="lineNum">    4829 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || DEBUG_NAME_QUALIFICATION_LEVEL_FOR_TEMPLATE_ARGUMENTS</a>
<a name="4830"><span class="lineNum">    4830 </span>            :                            mfprintf(mlog [ WARN ] ) (&quot;namedType is a SgNonrealType: nrdecl = %p = %s \n&quot;,nrdecl,nrdecl-&gt;class_name().c_str());</a>
<a name="4831"><span class="lineNum">    4831 </span>            : #endif</a>
<a name="4832"><span class="lineNum">    4832 </span><span class="lineCov">      29396 :                            do {</span></a>
<a name="4833"><span class="lineNum">    4833 </span><span class="lineCov">      29396 :                              recursiveDepth++;</span></a>
<a name="4834"><span class="lineNum">    4834 </span><span class="lineCov">      29396 :                              evaluateNameQualificationForTemplateArgumentList(nrdecl-&gt;get_tpl_args(), currentScope, positionStatement);</span></a>
<a name="4835"><span class="lineNum">    4835 </span><span class="lineCov">      29396 :                              recursiveDepth--;</span></a>
<a name="4836"><span class="lineNum">    4836 </span>            : </a>
<a name="4837"><span class="lineNum">    4837 </span><span class="lineCov">      29396 :                              if (nrdecl-&gt;get_templateDeclaration() != NULL) {</span></a>
<a name="4838"><span class="lineNum">    4838 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || DEBUG_NAME_QUALIFICATION_LEVEL_FOR_TEMPLATE_ARGUMENTS</a>
<a name="4839"><span class="lineNum">    4839 </span>            :                                mfprintf(mlog [ WARN ] ) (&quot; - nrdecl-&gt;get_templateDeclaration() = %p = %s \n&quot;, nrdecl-&gt;get_templateDeclaration(), nrdecl-&gt;get_templateDeclaration() ? nrdecl-&gt;get_templateDeclaration()-&gt;class_name().c_str() : &quot;&quot;);</a>
<a name="4840"><span class="lineNum">    4840 </span>            : #endif</a>
<a name="4841"><span class="lineNum">    4841 </span><span class="lineCov">       3225 :                                int amountOfNameQualificationRequired = nameQualificationDepth(nrdecl-&gt;get_templateDeclaration(),currentScope,positionStatement);</span></a>
<a name="4842"><span class="lineNum">    4842 </span><span class="lineCov">       3225 :                                setNameQualification(templateArgument,nrdecl-&gt;get_templateDeclaration(),amountOfNameQualificationRequired);</span></a>
<a name="4843"><span class="lineNum">    4843 </span>            :                              }</a>
<a name="4844"><span class="lineNum">    4844 </span>            : </a>
<a name="4845"><span class="lineNum">    4845 </span><span class="lineCov">      29396 :                              SgNode * nrdecl_parent = nrdecl-&gt;get_parent();</span></a>
<a name="4846"><span class="lineNum">    4846 </span><span class="lineCov">      29396 :                              ASSERT_not_null(nrdecl_parent);</span></a>
<a name="4847"><span class="lineNum">    4847 </span><span class="lineCov">      29396 :                              nrdecl_parent = nrdecl_parent-&gt;get_parent();</span></a>
<a name="4848"><span class="lineNum">    4848 </span><span class="lineCov">      29396 :                              ASSERT_not_null(nrdecl_parent);</span></a>
<a name="4849"><span class="lineNum">    4849 </span>            : </a>
<a name="4850"><span class="lineNum">    4850 </span><span class="lineCov">      29396 :                              ROSE_ASSERT(nrdecl_parent != nrdecl); // That would be a loop...</span></a>
<a name="4851"><span class="lineNum">    4851 </span>            : </a>
<a name="4852"><span class="lineNum">    4852 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || DEBUG_NAME_QUALIFICATION_LEVEL_FOR_TEMPLATE_ARGUMENTS</a>
<a name="4853"><span class="lineNum">    4853 </span>            :                              mfprintf(mlog [ WARN ] ) (&quot; - nrdecl_parent = %p = %s \n&quot;, nrdecl_parent, nrdecl_parent-&gt;class_name().c_str());</a>
<a name="4854"><span class="lineNum">    4854 </span>            : #endif</a>
<a name="4855"><span class="lineNum">    4855 </span>            : </a>
<a name="4856"><span class="lineNum">    4856 </span><span class="lineCov">      29396 :                              nrdecl = isSgNonrealDecl(nrdecl_parent);</span></a>
<a name="4857"><span class="lineNum">    4857 </span><span class="lineCov">      29396 :                            } while (nrdecl != NULL);</span></a>
<a name="4858"><span class="lineNum">    4858 </span>            : </a>
<a name="4859"><span class="lineNum">    4859 </span>            :                          } else {</a>
<a name="4860"><span class="lineNum">    4860 </span><span class="lineCov">      88343 :                            int amountOfNameQualificationRequiredForTemplateArgument = nameQualificationDepth(namedType,currentScope,positionStatement);</span></a>
<a name="4861"><span class="lineNum">    4861 </span>            : </a>
<a name="4862"><span class="lineNum">    4862 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || DEBUG_NAME_QUALIFICATION_LEVEL_FOR_TEMPLATE_ARGUMENTS</a>
<a name="4863"><span class="lineNum">    4863 </span>            :                            mfprintf(mlog [ WARN ] ) (&quot;xxxxxx --- amountOfNameQualificationRequiredForTemplateArgument = %d (for type = %p (%s) = %s) (counter = %d recursiveDepth = %d) \n&quot;,</a>
<a name="4864"><span class="lineNum">    4864 </span>            :                                 amountOfNameQualificationRequiredForTemplateArgument,namedType,namedType-&gt;class_name().c_str(), namedType-&gt;get_name().str(),counter,recursiveDepth);</a>
<a name="4865"><span class="lineNum">    4865 </span>            :                            mfprintf(mlog [ WARN ] ) (&quot;xxxxxx --- Must call a function to set the name qualification data in the SgTemplateArgument = %p \n&quot;,templateArgument);</a>
<a name="4866"><span class="lineNum">    4866 </span>            : #endif</a>
<a name="4867"><span class="lineNum">    4867 </span>            : </a>
<a name="4868"><span class="lineNum">    4868 </span>            :                         // TV (10/09/2018): FIXME ROSE-1511</a>
<a name="4869"><span class="lineNum">    4869 </span><span class="lineCov">      88343 :                            SgNamespaceDefinitionStatement * nsp_defn = isSgNamespaceDefinitionStatement(currentScope);</span></a>
<a name="4870"><span class="lineNum">    4870 </span><span class="lineCov">      88343 :                            if (nsp_defn != NULL) {</span></a>
<a name="4871"><span class="lineNum">    4871 </span><span class="lineCov">      29596 :                              SgNamespaceDeclarationStatement * nsp_decl = nsp_defn-&gt;get_namespaceDeclaration();</span></a>
<a name="4872"><span class="lineNum">    4872 </span><span class="lineCov">      29596 :                              ASSERT_not_null(nsp_decl);</span></a>
<a name="4873"><span class="lineNum">    4873 </span><span class="lineCov">      59192 :                              if (nsp_decl-&gt;get_name() == &quot;std&quot; &amp;&amp; (</span></a>
<a name="4874"><span class="lineNum">    4874 </span><span class="lineCov">      58504 :                                     namedType-&gt;get_name().getString().find(&quot;allocator&quot;) == 0 ||</span></a>
<a name="4875"><span class="lineNum">    4875 </span><span class="lineCov">      29596 :                                     namedType-&gt;get_name().getString().find(&quot;less&quot;) == 0</span></a>
<a name="4876"><span class="lineNum">    4876 </span>            :                                   )) {</a>
<a name="4877"><span class="lineNum">    4877 </span><span class="lineCov">       1893 :                                amountOfNameQualificationRequiredForTemplateArgument = 1;</span></a>
<a name="4878"><span class="lineNum">    4878 </span>            :                              }</a>
<a name="4879"><span class="lineNum">    4879 </span>            :                            }</a>
<a name="4880"><span class="lineNum">    4880 </span>            : </a>
<a name="4881"><span class="lineNum">    4881 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || DEBUG_NAME_QUALIFICATION_LEVEL_FOR_TEMPLATE_ARGUMENTS</a>
<a name="4882"><span class="lineNum">    4882 </span>            :                            mfprintf(mlog [ WARN ] ) (&quot;templateArgumentTypeDeclaration = %p = %s \n&quot;,templateArgumentTypeDeclaration,templateArgumentTypeDeclaration-&gt;class_name().c_str());</a>
<a name="4883"><span class="lineNum">    4883 </span>            : #endif</a>
<a name="4884"><span class="lineNum">    4884 </span><span class="lineCov">      88343 :                            setNameQualification(templateArgument,templateArgumentTypeDeclaration,amountOfNameQualificationRequiredForTemplateArgument);</span></a>
<a name="4885"><span class="lineNum">    4885 </span>            :                          }</a>
<a name="4886"><span class="lineNum">    4886 </span>            :                        }</a>
<a name="4887"><span class="lineNum">    4887 </span>            :                   }</a>
<a name="4888"><span class="lineNum">    4888 </span>            : </a>
<a name="4889"><span class="lineNum">    4889 </span>            :             // If this was not a SgNamedType (and even if it is, see test2011_117.C), it still might be a type</a>
<a name="4890"><span class="lineNum">    4890 </span>            :             // where name qualification is required (might be a SgArrayType with an index requiring qualification).</a>
<a name="4891"><span class="lineNum">    4891 </span><span class="lineCov">     300304 :                processNameQualificationForPossibleArrayType(type,currentScope);</span></a>
<a name="4892"><span class="lineNum">    4892 </span>            : </a>
<a name="4893"><span class="lineNum">    4893 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || DEBUG_NAME_QUALIFICATION_LEVEL_FOR_TEMPLATE_ARGUMENTS</a>
<a name="4894"><span class="lineNum">    4894 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::evaluateNameQualificationForTemplateArgumentList(): DONE: processing type = %p = %s \n&quot;,type,type-&gt;class_name().c_str());</a>
<a name="4895"><span class="lineNum">    4895 </span>            : #endif</a>
<a name="4896"><span class="lineNum">    4896 </span>            :              }</a>
<a name="4897"><span class="lineNum">    4897 </span><span class="lineCov">      13798 :             else if (expression != NULL)</span></a>
<a name="4898"><span class="lineNum">    4898 </span>            :              {</a>
<a name="4899"><span class="lineNum">    4899 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || DEBUG_NAME_QUALIFICATION_LEVEL_FOR_TEMPLATE_ARGUMENTS</a>
<a name="4900"><span class="lineNum">    4900 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Template argument was an expression = %p \n&quot;,expression);</a>
<a name="4901"><span class="lineNum">    4901 </span>            : #endif</a>
<a name="4902"><span class="lineNum">    4902 </span>            :             // Check if this is a variable in which case it might require name qualification.  If we we have to traverse this expression recursively.</a>
<a name="4903"><span class="lineNum">    4903 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || DEBUG_NAME_QUALIFICATION_LEVEL_FOR_TEMPLATE_ARGUMENTS</a>
<a name="4904"><span class="lineNum">    4904 </span>            :             // We need to traverse this expression and evaluate if any name qualification is required on its pieces (e.g. referenced variables)</a>
<a name="4905"><span class="lineNum">    4905 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Call to generateNestedTraversalWithExplicitScope() with expression = %p = %s \n&quot;,expression,expression-&gt;class_name().c_str());</a>
<a name="4906"><span class="lineNum">    4906 </span>            : #endif</a>
<a name="4907"><span class="lineNum">    4907 </span>            : </a>
<a name="4908"><span class="lineNum">    4908 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || DEBUG_NAME_QUALIFICATION_LEVEL_FOR_TEMPLATE_ARGUMENTS</a>
<a name="4909"><span class="lineNum">    4909 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::evaluateNameQualificationForTemplateArgumentList(): Calling generateNestedTraversalWithExplicitScope(): with expression = %p = %s and currentScope = %p = %s \n&quot;,</a>
<a name="4910"><span class="lineNum">    4910 </span>            :                     expression,expression-&gt;class_name().c_str(),currentScope,currentScope-&gt;class_name().c_str());</a>
<a name="4911"><span class="lineNum">    4911 </span>            : #endif</a>
<a name="4912"><span class="lineNum">    4912 </span>            :             // DQ (3/15/2019): Added Comment: This is required because the expression can be a subtree that would have to be seperately traversed.</a>
<a name="4913"><span class="lineNum">    4913 </span><span class="lineCov">      10045 :                generateNestedTraversalWithExplicitScope(expression,currentScope);</span></a>
<a name="4914"><span class="lineNum">    4914 </span>            : </a>
<a name="4915"><span class="lineNum">    4915 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || DEBUG_NAME_QUALIFICATION_LEVEL_FOR_TEMPLATE_ARGUMENTS</a>
<a name="4916"><span class="lineNum">    4916 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::evaluateNameQualificationForTemplateArgumentList(): DONE: Call to generateNestedTraversalWithExplicitScope() with expression = %p = %s \n&quot;,expression,expression-&gt;class_name().c_str());</a>
<a name="4917"><span class="lineNum">    4917 </span>            : #endif</a>
<a name="4918"><span class="lineNum">    4918 </span>            : </a>
<a name="4919"><span class="lineNum">    4919 </span>            : #if 0</a>
<a name="4920"><span class="lineNum">    4920 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="4921"><span class="lineNum">    4921 </span>            :                ROSE_ABORT();</a>
<a name="4922"><span class="lineNum">    4922 </span>            : #endif</a>
<a name="4923"><span class="lineNum">    4923 </span>            :              }</a>
<a name="4924"><span class="lineNum">    4924 </span><span class="lineCov">       3753 :             else if (iname != NULL)</span></a>
<a name="4925"><span class="lineNum">    4925 </span>            :              {</a>
<a name="4926"><span class="lineNum">    4926 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || DEBUG_NAME_QUALIFICATION_LEVEL_FOR_TEMPLATE_ARGUMENTS</a>
<a name="4927"><span class="lineNum">    4927 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::evaluateNameQualificationForTemplateArgumentList(): Empty case: template argument is an initialized name = %p \n&quot;,iname);</a>
<a name="4928"><span class="lineNum">    4928 </span>            : #endif</a>
<a name="4929"><span class="lineNum">    4929 </span>            :              }</a>
<a name="4930"><span class="lineNum">    4930 </span><span class="lineCov">       3753 :             else if (tpldecl != NULL)</span></a>
<a name="4931"><span class="lineNum">    4931 </span>            :              {</a>
<a name="4932"><span class="lineNum">    4932 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || DEBUG_NAME_QUALIFICATION_LEVEL_FOR_TEMPLATE_ARGUMENTS</a>
<a name="4933"><span class="lineNum">    4933 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::evaluateNameQualificationForTemplateArgumentList(): template argument is a template = %p (%s)\n&quot;, tpldecl, tpldecl-&gt;class_name().c_str());</a>
<a name="4934"><span class="lineNum">    4934 </span>            : #endif</a>
<a name="4935"><span class="lineNum">    4935 </span><span class="lineCov">        176 :               int amountOfNameQualificationRequiredForTemplateArgument = nameQualificationDepth( tpldecl, currentScope, positionStatement );</span></a>
<a name="4936"><span class="lineNum">    4936 </span><span class="lineCov">        176 :               setNameQualification(templateArgument,tpldecl,amountOfNameQualificationRequiredForTemplateArgument);</span></a>
<a name="4937"><span class="lineNum">    4937 </span>            : </a>
<a name="4938"><span class="lineNum">    4938 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || DEBUG_NAME_QUALIFICATION_LEVEL_FOR_TEMPLATE_ARGUMENTS</a>
<a name="4939"><span class="lineNum">    4939 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::evaluateNameQualificationForTemplateArgumentList(): DONE: template argument is a template = %p (%s)\n&quot;, tpldecl, tpldecl-&gt;class_name().c_str());</a>
<a name="4940"><span class="lineNum">    4940 </span>            : #endif</a>
<a name="4941"><span class="lineNum">    4941 </span>            :              }</a>
<a name="4942"><span class="lineNum">    4942 </span>            : </a>
<a name="4943"><span class="lineNum">    4943 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || DEBUG_NAME_QUALIFICATION_LEVEL_FOR_TEMPLATE_ARGUMENTS</a>
<a name="4944"><span class="lineNum">    4944 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;===== After finishing with evaluation of templateArgument name qualification: templateArgument = %p testNameInMap = %s \n&quot;,templateArgument,templateArgument-&gt;unparseToString().c_str());</a>
<a name="4945"><span class="lineNum">    4945 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;===== templateArgument-&gt;unparseToString() = %s \n&quot;,templateArgument-&gt;unparseToString().c_str());</a>
<a name="4946"><span class="lineNum">    4946 </span>            : #endif</a>
<a name="4947"><span class="lineNum">    4947 </span>            : </a>
<a name="4948"><span class="lineNum">    4948 </span>            : //        ROSE_ASSERT(templateArgument-&gt;unparseToString() != &quot;allocator&lt; int &gt;&quot;);</a>
<a name="4949"><span class="lineNum">    4949 </span>            : </a>
<a name="4950"><span class="lineNum">    4950 </span><span class="lineCov">     314102 :           i++;</span></a>
<a name="4951"><span class="lineNum">    4951 </span>            : </a>
<a name="4952"><span class="lineNum">    4952 </span>            :        // Used for debugging...</a>
<a name="4953"><span class="lineNum">    4953 </span><span class="lineCov">     314102 :           counter++;</span></a>
<a name="4954"><span class="lineNum">    4954 </span>            :         }</a>
<a name="4955"><span class="lineNum">    4955 </span>            : </a>
<a name="4956"><span class="lineNum">    4956 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || DEBUG_NAME_QUALIFICATION_LEVEL_FOR_TEMPLATE_ARGUMENTS</a>
<a name="4957"><span class="lineNum">    4957 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;*****************************************************************************************************************************\n&quot;);</a>
<a name="4958"><span class="lineNum">    4958 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;Leaving NameQualificationTraversal::evaluateNameQualificationForTemplateArgumentList(): templateArgumentList.size() = %&quot; PRIuPTR &quot; recursiveDepth = %d \n&quot;,templateArgumentList.size(),recursiveDepth);</a>
<a name="4959"><span class="lineNum">    4959 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;*****************************************************************************************************************************\n\n&quot;);</a>
<a name="4960"><span class="lineNum">    4960 </span>            : #endif</a>
<a name="4961"><span class="lineNum">    4961 </span>            : </a>
<a name="4962"><span class="lineNum">    4962 </span>            : #if 0</a>
<a name="4963"><span class="lineNum">    4963 </span>            :   // DQ (7/22/2017): Added for testing only.</a>
<a name="4964"><span class="lineNum">    4964 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="4965"><span class="lineNum">    4965 </span>            :      ROSE_ABORT();</a>
<a name="4966"><span class="lineNum">    4966 </span>            : #endif</a>
<a name="4967"><span class="lineNum">    4967 </span>            : </a>
<a name="4968"><span class="lineNum">    4968 </span><span class="lineCov">     326781 :    }</span></a>
<a name="4969"><span class="lineNum">    4969 </span>            : </a>
<a name="4970"><span class="lineNum">    4970 </span>            : #define DEBUG_NAME_QUALIFICATION_LEVEL_FOR_NAME_QUALIFICATION_DEPTH 0</a>
<a name="4971"><span class="lineNum">    4971 </span>            : </a>
<a name="4972"><span class="lineNum">    4972 </span>            : int</a>
<a name="4973"><span class="lineNum">    4973 </span><span class="lineCov">    1563250 : NameQualificationTraversal::nameQualificationDepth ( SgType* type, SgScopeStatement* currentScope, SgStatement* positionStatement )</span></a>
<a name="4974"><span class="lineNum">    4974 </span>            :    {</a>
<a name="4975"><span class="lineNum">    4975 </span><span class="lineCov">    1563250 :      int amountOfNameQualificationRequired = 0;</span></a>
<a name="4976"><span class="lineNum">    4976 </span>            : </a>
<a name="4977"><span class="lineNum">    4977 </span><span class="lineCov">    1563250 :      ASSERT_not_null(type);</span></a>
<a name="4978"><span class="lineNum">    4978 </span>            : </a>
<a name="4979"><span class="lineNum">    4979 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || DEBUG_NAME_QUALIFICATION_LEVEL_FOR_NAME_QUALIFICATION_DEPTH || 0</a>
<a name="4980"><span class="lineNum">    4980 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In nameQualificationDepth(SgType*): type = %p = %s \n&quot;,type,type-&gt;class_name().c_str());</a>
<a name="4981"><span class="lineNum">    4981 </span>            : #endif</a>
<a name="4982"><span class="lineNum">    4982 </span>            : </a>
<a name="4983"><span class="lineNum">    4983 </span>            :   // DQ (7/23/2011): Test if we see array types here (looking for way to process all array types).</a>
<a name="4984"><span class="lineNum">    4984 </span>            :   // ROSE_ASSERT(isSgArrayType(type) == NULL);</a>
<a name="4985"><span class="lineNum">    4985 </span>            : </a>
<a name="4986"><span class="lineNum">    4986 </span>            :   // DQ (7/23/2011): If this is an array type, then we need special processing for any name qualification of its index expressions.</a>
<a name="4987"><span class="lineNum">    4987 </span><span class="lineCov">    1563250 :      processNameQualificationForPossibleArrayType(type,currentScope);</span></a>
<a name="4988"><span class="lineNum">    4988 </span>            : </a>
<a name="4989"><span class="lineNum">    4989 </span><span class="lineCov">    1563250 :      SgDeclarationStatement* declaration = getDeclarationAssociatedWithType(type);</span></a>
<a name="4990"><span class="lineNum">    4990 </span><span class="lineCov">    1563250 :      if (declaration != NULL)</span></a>
<a name="4991"><span class="lineNum">    4991 </span>            :         {</a>
<a name="4992"><span class="lineNum">    4992 </span>            : </a>
<a name="4993"><span class="lineNum">    4993 </span>            :        // Check the visability and unambiguity of this declaration.</a>
<a name="4994"><span class="lineNum">    4994 </span><span class="lineCov">    1311330 :           amountOfNameQualificationRequired = nameQualificationDepth(declaration,currentScope,positionStatement);</span></a>
<a name="4995"><span class="lineNum">    4995 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || DEBUG_NAME_QUALIFICATION_LEVEL_FOR_NAME_QUALIFICATION_DEPTH</a>
<a name="4996"><span class="lineNum">    4996 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;amountOfNameQualificationRequired = %d \n&quot;,amountOfNameQualificationRequired);</a>
<a name="4997"><span class="lineNum">    4997 </span>            : #endif</a>
<a name="4998"><span class="lineNum">    4998 </span>            :         }</a>
<a name="4999"><span class="lineNum">    4999 </span>            :        else</a>
<a name="5000"><span class="lineNum">    5000 </span>            :         {</a>
<a name="5001"><span class="lineNum">    5001 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || DEBUG_NAME_QUALIFICATION_LEVEL_FOR_NAME_QUALIFICATION_DEPTH</a>
<a name="5002"><span class="lineNum">    5002 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;ERROR: In nameQualificationDepth(SgType*): declaration NOT found for type = %p = %s\n&quot;,type,type-&gt;class_name().c_str());</a>
<a name="5003"><span class="lineNum">    5003 </span>            : #endif</a>
<a name="5004"><span class="lineNum">    5004 </span>            :         }</a>
<a name="5005"><span class="lineNum">    5005 </span>            : </a>
<a name="5006"><span class="lineNum">    5006 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || DEBUG_NAME_QUALIFICATION_LEVEL_FOR_NAME_QUALIFICATION_DEPTH</a>
<a name="5007"><span class="lineNum">    5007 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;Leaving nameQualificationDepth(SgType*): type = %p = %s amountOfNameQualificationRequired = %d \n&quot;,type,type-&gt;class_name().c_str(),amountOfNameQualificationRequired);</a>
<a name="5008"><span class="lineNum">    5008 </span>            : #endif</a>
<a name="5009"><span class="lineNum">    5009 </span>            : </a>
<a name="5010"><span class="lineNum">    5010 </span><span class="lineCov">    1563250 :      return amountOfNameQualificationRequired;</span></a>
<a name="5011"><span class="lineNum">    5011 </span>            :    }</a>
<a name="5012"><span class="lineNum">    5012 </span>            : </a>
<a name="5013"><span class="lineNum">    5013 </span>            : </a>
<a name="5014"><span class="lineNum">    5014 </span>            : // int NameQualificationTraversal::nameQualificationDepthForType ( SgInitializedName* initializedName, SgStatement* positionStatement )</a>
<a name="5015"><span class="lineNum">    5015 </span>            : int</a>
<a name="5016"><span class="lineNum">    5016 </span><span class="lineCov">    1461880 : NameQualificationTraversal::nameQualificationDepthForType ( SgInitializedName* initializedName, SgScopeStatement* currentScope, SgStatement* positionStatement )</span></a>
<a name="5017"><span class="lineNum">    5017 </span>            :    {</a>
<a name="5018"><span class="lineNum">    5018 </span><span class="lineCov">    1461880 :      ASSERT_not_null(initializedName);</span></a>
<a name="5019"><span class="lineNum">    5019 </span><span class="lineCov">    1461880 :      ASSERT_not_null(positionStatement);</span></a>
<a name="5020"><span class="lineNum">    5020 </span>            : </a>
<a name="5021"><span class="lineNum">    5021 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="5022"><span class="lineNum">    5022 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In nameQualificationDepthForType(): initializedName = %s type = %p = %s currentScope = %p = %s \n&quot;,initializedName-&gt;get_name().str(),initializedName-&gt;get_type(),initializedName-&gt;get_type()-&gt;class_name().c_str(),currentScope,currentScope-&gt;class_name().c_str());</a>
<a name="5023"><span class="lineNum">    5023 </span>            : #endif</a>
<a name="5024"><span class="lineNum">    5024 </span>            : </a>
<a name="5025"><span class="lineNum">    5025 </span><span class="lineCov">    1461880 :      SgType* initializedNameType = initializedName-&gt;get_type();</span></a>
<a name="5026"><span class="lineNum">    5026 </span>            : </a>
<a name="5027"><span class="lineNum">    5027 </span>            :   // DQ (4/9/2019): Adding support for SgPointerMemberType.</a>
<a name="5028"><span class="lineNum">    5028 </span><span class="lineCov">    1461880 :      SgPointerMemberType* pointerMemberType = isSgPointerMemberType(initializedNameType);</span></a>
<a name="5029"><span class="lineNum">    5029 </span><span class="lineCov">    1461880 :      if (pointerMemberType != NULL)</span></a>
<a name="5030"><span class="lineNum">    5030 </span>            :         {</a>
<a name="5031"><span class="lineNum">    5031 </span><span class="lineNoCov">          0 :           SgType* baseType = pointerMemberType-&gt;get_base_type();</span></a>
<a name="5032"><span class="lineNum">    5032 </span><span class="lineNoCov">          0 :           ASSERT_not_null(baseType);</span></a>
<a name="5033"><span class="lineNum">    5033 </span>            : </a>
<a name="5034"><span class="lineNum">    5034 </span>            :        // Handle member functions as a special case.</a>
<a name="5035"><span class="lineNum">    5035 </span><span class="lineNoCov">          0 :           SgMemberFunctionType* memberFunctionType = isSgMemberFunctionType(baseType);</span></a>
<a name="5036"><span class="lineNum">    5036 </span><span class="lineNoCov">          0 :           if (memberFunctionType != NULL)</span></a>
<a name="5037"><span class="lineNum">    5037 </span>            :              {</a>
<a name="5038"><span class="lineNum">    5038 </span><span class="lineNoCov">          0 :                SgType* returnType = memberFunctionType-&gt;get_return_type();</span></a>
<a name="5039"><span class="lineNum">    5039 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="5040"><span class="lineNum">    5040 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;nameQualificationDepthForType(): case SgPointerMemberType: Reset associated initializedNameType: returnType = %p = %s \n&quot;,returnType,returnType-&gt;class_name().c_str());</a>
<a name="5041"><span class="lineNum">    5041 </span>            : #endif</a>
<a name="5042"><span class="lineNum">    5042 </span><span class="lineNoCov">          0 :                initializedNameType = returnType;</span></a>
<a name="5043"><span class="lineNum">    5043 </span>            :              }</a>
<a name="5044"><span class="lineNum">    5044 </span>            :             else</a>
<a name="5045"><span class="lineNum">    5045 </span>            :              {</a>
<a name="5046"><span class="lineNum">    5046 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="5047"><span class="lineNum">    5047 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;nameQualificationDepthForType(): case SgPointerMemberType: Reset associated initializedNameType: baseType = %p = %s \n&quot;,baseType,baseType-&gt;class_name().c_str());</a>
<a name="5048"><span class="lineNum">    5048 </span>            : #endif</a>
<a name="5049"><span class="lineNum">    5049 </span>            :                initializedNameType = baseType;</a>
<a name="5050"><span class="lineNum">    5050 </span>            :              }</a>
<a name="5051"><span class="lineNum">    5051 </span>            :         }</a>
<a name="5052"><span class="lineNum">    5052 </span>            : </a>
<a name="5053"><span class="lineNum">    5053 </span>            :   // return nameQualificationDepth(initializedName-&gt;get_type(),initializedName-&gt;get_scope(),positionStatement);</a>
<a name="5054"><span class="lineNum">    5054 </span>            :   // return nameQualificationDepth(initializedName-&gt;get_type(),currentScope,positionStatement);</a>
<a name="5055"><span class="lineNum">    5055 </span><span class="lineCov">    1461880 :      return nameQualificationDepth(initializedNameType,currentScope,positionStatement);</span></a>
<a name="5056"><span class="lineNum">    5056 </span>            :    }</a>
<a name="5057"><span class="lineNum">    5057 </span>            : </a>
<a name="5058"><span class="lineNum">    5058 </span>            : </a>
<a name="5059"><span class="lineNum">    5059 </span>            : int</a>
<a name="5060"><span class="lineNum">    5060 </span><span class="lineCov">        435 : NameQualificationTraversal::nameQualificationDepth ( SgInitializedName* initializedName, SgScopeStatement* currentScope, SgStatement* positionStatement )</span></a>
<a name="5061"><span class="lineNum">    5061 </span>            :    {</a>
<a name="5062"><span class="lineNum">    5062 </span><span class="lineCov">        435 :      int amountOfNameQualificationRequired = 0;</span></a>
<a name="5063"><span class="lineNum">    5063 </span>            : </a>
<a name="5064"><span class="lineNum">    5064 </span><span class="lineCov">        435 :      ASSERT_not_null(initializedName);</span></a>
<a name="5065"><span class="lineNum">    5065 </span>            :   // SgScopeStatement* currentScope = initializedName-&gt;get_scope();</a>
<a name="5066"><span class="lineNum">    5066 </span><span class="lineCov">        435 :      ASSERT_not_null(currentScope);</span></a>
<a name="5067"><span class="lineNum">    5067 </span>            : #if 0</a>
<a name="5068"><span class="lineNum">    5068 </span>            :   // If this is global scope then don't try to take it's scope.</a>
<a name="5069"><span class="lineNum">    5069 </span>            :      if (isSgGlobal(currentScope) == NULL)</a>
<a name="5070"><span class="lineNum">    5070 </span>            :           currentScope = currentScope-&gt;get_scope();</a>
<a name="5071"><span class="lineNum">    5071 </span>            :      ASSERT_not_null(currentScope);</a>
<a name="5072"><span class="lineNum">    5072 </span>            : #endif</a>
<a name="5073"><span class="lineNum">    5073 </span>            : </a>
<a name="5074"><span class="lineNum">    5074 </span><span class="lineCov">        870 :      SgName name = initializedName-&gt;get_name();</span></a>
<a name="5075"><span class="lineNum">    5075 </span>            : </a>
<a name="5076"><span class="lineNum">    5076 </span>            :   // DQ (6/5/2011): Test if this has a valid name (if not then it need not be qualified).</a>
<a name="5077"><span class="lineNum">    5077 </span>            :   // Examples of tests codes: test2005_114.C and test2011_73.C.</a>
<a name="5078"><span class="lineNum">    5078 </span><span class="lineCov">        435 :      if (name.is_null() == true)</span></a>
<a name="5079"><span class="lineNum">    5079 </span>            :         {</a>
<a name="5080"><span class="lineNum">    5080 </span>            :        // An empty name implies that no name qualification would make sense.</a>
<a name="5081"><span class="lineNum">    5081 </span>            :           return 0;</a>
<a name="5082"><span class="lineNum">    5082 </span>            :         }</a>
<a name="5083"><span class="lineNum">    5083 </span>            : </a>
<a name="5084"><span class="lineNum">    5084 </span>            :   // DQ (12/28/2011): Added test...</a>
<a name="5085"><span class="lineNum">    5085 </span><span class="lineCov">        345 :      ASSERT_not_null(initializedName-&gt;get_scope());</span></a>
<a name="5086"><span class="lineNum">    5086 </span>            : </a>
<a name="5087"><span class="lineNum">    5087 </span>            :   // mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::nameQualificationDepth(): initializedName-&gt;get_scope() = %p = %s \n&quot;,initializedName-&gt;get_scope(),initializedName-&gt;get_scope()-&gt;class_name().c_str());</a>
<a name="5088"><span class="lineNum">    5088 </span>            : </a>
<a name="5089"><span class="lineNum">    5089 </span><span class="lineCov">        345 :      SgDeclarationStatement* declaration = associatedDeclaration(initializedName-&gt;get_scope());</span></a>
<a name="5090"><span class="lineNum">    5090 </span>            :   // ASSERT_not_null(declaration);</a>
<a name="5091"><span class="lineNum">    5091 </span>            : </a>
<a name="5092"><span class="lineNum">    5092 </span>            :   // mfprintf(mlog [ WARN ] ) (&quot;************** In nameQualificationDepth(): declaration = %p \n&quot;,declaration);</a>
<a name="5093"><span class="lineNum">    5093 </span>            : </a>
<a name="5094"><span class="lineNum">    5094 </span><span class="lineCov">        345 :      SgVariableSymbol* variableSymbol = NULL;</span></a>
<a name="5095"><span class="lineNum">    5095 </span>            : </a>
<a name="5096"><span class="lineNum">    5096 </span>            :   // DQ (8/16/2013): Modified to support new API.</a>
<a name="5097"><span class="lineNum">    5097 </span>            :   // SgSymbol* symbol = SageInterface::lookupSymbolInParentScopes(name,currentScope);</a>
<a name="5098"><span class="lineNum">    5098 </span><span class="lineCov">        345 :      SgSymbol* symbol = SageInterface::lookupSymbolInParentScopes(name,currentScope,NULL,NULL);</span></a>
<a name="5099"><span class="lineNum">    5099 </span>            : </a>
<a name="5100"><span class="lineNum">    5100 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="5101"><span class="lineNum">    5101 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::nameQualificationDepth(SgInitializedName* = %p): symbol = %p \n&quot;,initializedName,symbol);</a>
<a name="5102"><span class="lineNum">    5102 </span>            : #endif</a>
<a name="5103"><span class="lineNum">    5103 </span>            : </a>
<a name="5104"><span class="lineNum">    5104 </span><span class="lineCov">        345 :      if (symbol != NULL)</span></a>
<a name="5105"><span class="lineNum">    5105 </span>            :         {</a>
<a name="5106"><span class="lineNum">    5106 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="5107"><span class="lineNum">    5107 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Lookup symbol based on name only (via parents starting at currentScope = %p = %s: name = %s symbol = %p = %s) \n&quot;,currentScope,currentScope-&gt;class_name().c_str(),name.str(),symbol,symbol-&gt;class_name().c_str());</a>
<a name="5108"><span class="lineNum">    5108 </span>            : #endif</a>
<a name="5109"><span class="lineNum">    5109 </span>            : </a>
<a name="5110"><span class="lineNum">    5110 </span>            : #if 0</a>
<a name="5111"><span class="lineNum">    5111 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;This should be a while loop to resolve the full possible chain of alias symbols! \n&quot;);</a>
<a name="5112"><span class="lineNum">    5112 </span>            :           SgAliasSymbol* aliasSymbol = isSgAliasSymbol(symbol);</a>
<a name="5113"><span class="lineNum">    5113 </span>            :           if (aliasSymbol != NULL)</a>
<a name="5114"><span class="lineNum">    5114 </span>            :              {</a>
<a name="5115"><span class="lineNum">    5115 </span>            :                symbol = aliasSymbol-&gt;get_alias();</a>
<a name="5116"><span class="lineNum">    5116 </span>            : </a>
<a name="5117"><span class="lineNum">    5117 </span>            :                ROSE_ASSERT(isSgAliasSymbol(symbol) == NULL);</a>
<a name="5118"><span class="lineNum">    5118 </span>            :              }</a>
<a name="5119"><span class="lineNum">    5119 </span>            : #else</a>
<a name="5120"><span class="lineNum">    5120 </span>            :        // Loop over possible chain of alias symbols to find the original sysmbol.</a>
<a name="5121"><span class="lineNum">    5121 </span><span class="lineCov">         57 :           SgAliasSymbol* aliasSymbol = isSgAliasSymbol(symbol);</span></a>
<a name="5122"><span class="lineNum">    5122 </span>            : </a>
<a name="5123"><span class="lineNum">    5123 </span>            :        // DQ (7/12/2014): The newer design of the symbol table handling means that we will never see a SgAliasSymbol at this level.</a>
<a name="5124"><span class="lineNum">    5124 </span><span class="lineCov">         57 :           ROSE_ASSERT(aliasSymbol == NULL);</span></a>
<a name="5125"><span class="lineNum">    5125 </span>            : </a>
<a name="5126"><span class="lineNum">    5126 </span><span class="lineCov">         57 :           while (aliasSymbol != NULL)</span></a>
<a name="5127"><span class="lineNum">    5127 </span>            :              {</a>
<a name="5128"><span class="lineNum">    5128 </span>            :             // DQ (7/12/2014): The newer design of the symbol table handling means that we will never see a SgAliasSymbol at this level.</a>
<a name="5129"><span class="lineNum">    5129 </span>            :                ROSE_ABORT();</a>
<a name="5130"><span class="lineNum">    5130 </span>            : #if 1</a>
<a name="5131"><span class="lineNum">    5131 </span>            :             // DQ (7/12/2014): debugging use of SgAliasSymbol.</a>
<a name="5132"><span class="lineNum">    5132 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::nameQualificationDepth(): resolving alias symbol in loop: alias = %p baseSymbol = %p = %s \n&quot;,aliasSymbol,aliasSymbol-&gt;get_alias(),aliasSymbol-&gt;get_alias()-&gt;class_name().c_str());</a>
<a name="5133"><span class="lineNum">    5133 </span>            : #endif</a>
<a name="5134"><span class="lineNum">    5134 </span>            :                symbol = aliasSymbol-&gt;get_alias();</a>
<a name="5135"><span class="lineNum">    5135 </span>            :                aliasSymbol = isSgAliasSymbol(symbol);</a>
<a name="5136"><span class="lineNum">    5136 </span>            :              }</a>
<a name="5137"><span class="lineNum">    5137 </span><span class="lineCov">         57 :           ROSE_ASSERT(isSgAliasSymbol(symbol) == NULL);</span></a>
<a name="5138"><span class="lineNum">    5138 </span>            : #endif</a>
<a name="5139"><span class="lineNum">    5139 </span><span class="lineCov">         57 :           variableSymbol = isSgVariableSymbol(symbol);</span></a>
<a name="5140"><span class="lineNum">    5140 </span>            : </a>
<a name="5141"><span class="lineNum">    5141 </span>            : </a>
<a name="5142"><span class="lineNum">    5142 </span>            : </a>
<a name="5143"><span class="lineNum">    5143 </span><span class="lineCov">         57 :           if (variableSymbol == NULL)</span></a>
<a name="5144"><span class="lineNum">    5144 </span>            :              {</a>
<a name="5145"><span class="lineNum">    5145 </span><span class="lineCov">         50 :                variableSymbol = SageInterface::lookupVariableSymbolInParentScopes(name,currentScope);</span></a>
<a name="5146"><span class="lineNum">    5146 </span>            : </a>
<a name="5147"><span class="lineNum">    5147 </span>            :             // ASSERT_not_null(variableSymbol);</a>
<a name="5148"><span class="lineNum">    5148 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="5149"><span class="lineNum">    5149 </span>            :                if (variableSymbol != NULL)</a>
<a name="5150"><span class="lineNum">    5150 </span>            :                   {</a>
<a name="5151"><span class="lineNum">    5151 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Lookup symbol based symbol type: variableSymbol = %p = %s \n&quot;,variableSymbol,variableSymbol-&gt;class_name().c_str());</a>
<a name="5152"><span class="lineNum">    5152 </span>            :                   }</a>
<a name="5153"><span class="lineNum">    5153 </span>            :                  else</a>
<a name="5154"><span class="lineNum">    5154 </span>            :                   {</a>
<a name="5155"><span class="lineNum">    5155 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::nameQualificationDepth(SgInitializedName*,SgScopeStatement*,SgStatement*): variableSymbol == NULL \n&quot;);</a>
<a name="5156"><span class="lineNum">    5156 </span>            :                   }</a>
<a name="5157"><span class="lineNum">    5157 </span>            : #endif</a>
<a name="5158"><span class="lineNum">    5158 </span>            : </a>
<a name="5159"><span class="lineNum">    5159 </span>            :             // amountOfNameQualificationRequired = nameQualificationDepth(associatedDeclaration(initializedName-&gt;get_scope()),currentScope,positionStatement) + 1;</a>
<a name="5160"><span class="lineNum">    5160 </span>            :             // SgDeclarationStatement* declaration = associatedDeclaration(initializedName-&gt;get_scope());</a>
<a name="5161"><span class="lineNum">    5161 </span>            : </a>
<a name="5162"><span class="lineNum">    5162 </span>            :             // DQ (6/21/2011): This assertion fails for test2007_55.C.</a>
<a name="5163"><span class="lineNum">    5163 </span>            :             // DQ (6/5/2011): This assertion fails for test2005_114.C.</a>
<a name="5164"><span class="lineNum">    5164 </span>            :             // ASSERT_not_null(declaration);</a>
<a name="5165"><span class="lineNum">    5165 </span>            :             // amountOfNameQualificationRequired = nameQualificationDepth(declaration,currentScope,positionStatement) + 1;</a>
<a name="5166"><span class="lineNum">    5166 </span><span class="lineCov">         50 :                if (declaration != NULL)</span></a>
<a name="5167"><span class="lineNum">    5167 </span>            :                   {</a>
<a name="5168"><span class="lineNum">    5168 </span><span class="lineCov">         50 :                     amountOfNameQualificationRequired = nameQualificationDepth(declaration,currentScope,positionStatement) + 1;</span></a>
<a name="5169"><span class="lineNum">    5169 </span>            :                   }</a>
<a name="5170"><span class="lineNum">    5170 </span>            :                  else</a>
<a name="5171"><span class="lineNum">    5171 </span>            :                   {</a>
<a name="5172"><span class="lineNum">    5172 </span>            :                  // DQ (6/21/2011): This is the case for test2007_55.C.</a>
<a name="5173"><span class="lineNum">    5173 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="5174"><span class="lineNum">    5174 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;WARNING: there is no associated declaration! \n&quot;);</a>
<a name="5175"><span class="lineNum">    5175 </span>            : #endif</a>
<a name="5176"><span class="lineNum">    5176 </span>            :                   }</a>
<a name="5177"><span class="lineNum">    5177 </span>            :              }</a>
<a name="5178"><span class="lineNum">    5178 </span>            :             else</a>
<a name="5179"><span class="lineNum">    5179 </span>            :              {</a>
<a name="5180"><span class="lineNum">    5180 </span>            : </a>
<a name="5181"><span class="lineNum">    5181 </span>            : #define DEBUG_SKIP_VARIABLE_SYMBOL 0</a>
<a name="5182"><span class="lineNum">    5182 </span>            : </a>
<a name="5183"><span class="lineNum">    5183 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || DEBUG_SKIP_VARIABLE_SYMBOL</a>
<a name="5184"><span class="lineNum">    5184 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;initializedName-&gt;get_prev_decl_item() = %p \n&quot;,initializedName-&gt;get_prev_decl_item());</a>
<a name="5185"><span class="lineNum">    5185 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;initializedName-&gt;get_parent() = %p = %s \n&quot;,initializedName-&gt;get_parent(),initializedName-&gt;get_parent()-&gt;class_name().c_str());</a>
<a name="5186"><span class="lineNum">    5186 </span>            : #endif</a>
<a name="5187"><span class="lineNum">    5187 </span>            :             // DQ (6/1/2019): If this is associated with an extern declaration then don't use this symbol (see test2019_470.C).</a>
<a name="5188"><span class="lineNum">    5188 </span>            :             // This should not apply to enum values which we would want to detect the correct symbol for to support the name qualification.</a>
<a name="5189"><span class="lineNum">    5189 </span>            :             // bool skipThisSymbol = (initializedName-&gt;get_prev_decl_item() != NULL);</a>
<a name="5190"><span class="lineNum">    5190 </span>            :             // bool skipThisSymbol = (initializedName-&gt;get_prev_decl_item() != NULL &amp;&amp; isSgEnumDeclaration(initializedName-&gt;get_parent()) == NULL);</a>
<a name="5191"><span class="lineNum">    5191 </span>            :             // bool skipThisSymbol = (initializedName-&gt;get_prev_decl_item() != NULL || isSgEnumDeclaration(initializedName-&gt;get_parent()) != NULL);</a>
<a name="5192"><span class="lineNum">    5192 </span>            :             // bool skipThisSymbol = (initializedName-&gt;get_prev_decl_item() != NULL || isSgEnumDeclaration(initializedName-&gt;get_parent()) == NULL);</a>
<a name="5193"><span class="lineNum">    5193 </span>            :             // bool skipThisSymbol = (initializedName-&gt;get_prev_decl_item() != NULL || isSgEnumDeclaration(initializedName-&gt;get_parent()) == NULL);</a>
<a name="5194"><span class="lineNum">    5194 </span>            :             // bool skipThisSymbol = false;</a>
<a name="5195"><span class="lineNum">    5195 </span><span class="lineCov">          7 :                bool skipThisSymbol = true;</span></a>
<a name="5196"><span class="lineNum">    5196 </span>            : </a>
<a name="5197"><span class="lineNum">    5197 </span>            :             // Check if the initializedName is appearing in different scopes, which would trigger name qualification.</a>
<a name="5198"><span class="lineNum">    5198 </span>            :             // SgVariableDeclaration* variableDeclaration = isSgVariableDeclaration(initializedName-&gt;get_parent());</a>
<a name="5199"><span class="lineNum">    5199 </span>            :             // if (initializedName-&gt;get_prev_decl_item() != NULL &amp;&amp; variableDeclaration != NULL)</a>
<a name="5200"><span class="lineNum">    5200 </span><span class="lineCov">          7 :                if (initializedName-&gt;get_prev_decl_item() != NULL)</span></a>
<a name="5201"><span class="lineNum">    5201 </span>            :                   {</a>
<a name="5202"><span class="lineNum">    5202 </span><span class="lineCov">          7 :                     SgVariableDeclaration* variableDeclaration = isSgVariableDeclaration(initializedName-&gt;get_prev_decl_item()-&gt;get_parent());</span></a>
<a name="5203"><span class="lineNum">    5203 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || DEBUG_SKIP_VARIABLE_SYMBOL</a>
<a name="5204"><span class="lineNum">    5204 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;variableDeclaration = %p \n&quot;,variableDeclaration);</a>
<a name="5205"><span class="lineNum">    5205 </span>            : #endif</a>
<a name="5206"><span class="lineNum">    5206 </span>            :                  // if (variableDeclaration != NULL &amp;&amp; variableDeclaration-&gt;get_declarationModifier().get_storageModifier().isExtern() &amp;&amp; variableDeclaration-&gt;get_linkage().empty() == true)</a>
<a name="5207"><span class="lineNum">    5207 </span><span class="lineCov">          7 :                     if (variableDeclaration != NULL)</span></a>
<a name="5208"><span class="lineNum">    5208 </span>            :                        {</a>
<a name="5209"><span class="lineNum">    5209 </span><span class="lineCov">          7 :                          SgVariableDeclaration* possible_extern_variableDeclaration = isSgVariableDeclaration(initializedName-&gt;get_prev_decl_item()-&gt;get_parent());</span></a>
<a name="5210"><span class="lineNum">    5210 </span><span class="lineCov">          7 :                          SgVariableDeclaration* original_variableDeclaration        = isSgVariableDeclaration(initializedName-&gt;get_parent());</span></a>
<a name="5211"><span class="lineNum">    5211 </span>            : </a>
<a name="5212"><span class="lineNum">    5212 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || DEBUG_SKIP_VARIABLE_SYMBOL</a>
<a name="5213"><span class="lineNum">    5213 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;possible_extern_variableDeclaration = %p \n&quot;,possible_extern_variableDeclaration);</a>
<a name="5214"><span class="lineNum">    5214 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;original_variableDeclaration        = %p \n&quot;,original_variableDeclaration);</a>
<a name="5215"><span class="lineNum">    5215 </span>            : #endif</a>
<a name="5216"><span class="lineNum">    5216 </span><span class="lineCov">          7 :                          if (possible_extern_variableDeclaration != NULL &amp;&amp; original_variableDeclaration != NULL)</span></a>
<a name="5217"><span class="lineNum">    5217 </span>            :                             {</a>
<a name="5218"><span class="lineNum">    5218 </span>            :                            // Need to check if either of these declarations was marked as extern.</a>
<a name="5219"><span class="lineNum">    5219 </span><span class="lineCov">          8 :                               bool possible_extern_foundExternModifier = (possible_extern_variableDeclaration-&gt;get_declarationModifier().get_storageModifier().isExtern() &amp;&amp;</span></a>
<a name="5220"><span class="lineNum">    5220 </span><span class="lineCov">          7 :                                                                           possible_extern_variableDeclaration-&gt;get_linkage().empty() == true);</span></a>
<a name="5221"><span class="lineNum">    5221 </span><span class="lineCov">          7 :                               bool original_foundExternModifier        = (original_variableDeclaration-&gt;get_declarationModifier().get_storageModifier().isExtern() &amp;&amp;</span></a>
<a name="5222"><span class="lineNum">    5222 </span><span class="lineCov">          7 :                                                                           original_variableDeclaration-&gt;get_linkage().empty() == true);</span></a>
<a name="5223"><span class="lineNum">    5223 </span><span class="lineCov">          7 :                               bool foundExternModifier = (possible_extern_foundExternModifier || original_foundExternModifier);</span></a>
<a name="5224"><span class="lineNum">    5224 </span>            : </a>
<a name="5225"><span class="lineNum">    5225 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || DEBUG_SKIP_VARIABLE_SYMBOL</a>
<a name="5226"><span class="lineNum">    5226 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;foundExternModifier = %s \n&quot;,foundExternModifier ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="5227"><span class="lineNum">    5227 </span>            : #endif</a>
<a name="5228"><span class="lineNum">    5228 </span><span class="lineCov">          7 :                               if (foundExternModifier == true)</span></a>
<a name="5229"><span class="lineNum">    5229 </span>            :                                  {</a>
<a name="5230"><span class="lineNum">    5230 </span><span class="lineCov">          1 :                                    SgScopeStatement* possible_extern_variable_scope = possible_extern_variableDeclaration-&gt;get_scope();</span></a>
<a name="5231"><span class="lineNum">    5231 </span><span class="lineCov">          1 :                                    SgScopeStatement* original_variable_scope        = original_variableDeclaration-&gt;get_scope();</span></a>
<a name="5232"><span class="lineNum">    5232 </span>            : </a>
<a name="5233"><span class="lineNum">    5233 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || DEBUG_SKIP_VARIABLE_SYMBOL</a>
<a name="5234"><span class="lineNum">    5234 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;possible_extern_variable_scope = %p = %s \n&quot;,possible_extern_variable_scope,possible_extern_variable_scope-&gt;class_name().c_str());</a>
<a name="5235"><span class="lineNum">    5235 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;original_variable_scope        = %p = %s \n&quot;,original_variable_scope,original_variable_scope-&gt;class_name().c_str());</a>
<a name="5236"><span class="lineNum">    5236 </span>            : #endif</a>
<a name="5237"><span class="lineNum">    5237 </span><span class="lineCov">          1 :                                    SgNamespaceDefinitionStatement* possible_extern_variable_namespace_definition = isSgNamespaceDefinitionStatement(possible_extern_variable_scope);</span></a>
<a name="5238"><span class="lineNum">    5238 </span><span class="lineCov">          1 :                                    SgNamespaceDefinitionStatement* original_variable_namespace_definition        = isSgNamespaceDefinitionStatement(original_variable_scope);</span></a>
<a name="5239"><span class="lineNum">    5239 </span><span class="lineCov">          1 :                                    if (possible_extern_variable_namespace_definition != NULL &amp;&amp; original_variable_namespace_definition != NULL)</span></a>
<a name="5240"><span class="lineNum">    5240 </span>            :                                       {</a>
<a name="5241"><span class="lineNum">    5241 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || DEBUG_SKIP_VARIABLE_SYMBOL</a>
<a name="5242"><span class="lineNum">    5242 </span>            :                                         mfprintf(mlog [ WARN ] ) (&quot;possible_extern_variable_namespace_definition = %p \n&quot;,possible_extern_variable_namespace_definition);</a>
<a name="5243"><span class="lineNum">    5243 </span>            :                                         mfprintf(mlog [ WARN ] ) (&quot;original_variable_namespace_definition        = %p \n&quot;,original_variable_namespace_definition);</a>
<a name="5244"><span class="lineNum">    5244 </span>            :                                         mfprintf(mlog [ WARN ] ) (&quot;possible_extern_variable_namespace_definition-&gt;get_global_definition() = %p \n&quot;,possible_extern_variable_namespace_definition-&gt;get_global_definition());</a>
<a name="5245"><span class="lineNum">    5245 </span>            :                                         mfprintf(mlog [ WARN ] ) (&quot;original_variable_namespace_definition-&gt;get_global_definition()        = %p \n&quot;,original_variable_namespace_definition-&gt;get_global_definition());</a>
<a name="5246"><span class="lineNum">    5246 </span>            : #endif</a>
<a name="5247"><span class="lineNum">    5247 </span><span class="lineNoCov">          0 :                                         if (possible_extern_variable_namespace_definition-&gt;get_global_definition() == original_variable_namespace_definition-&gt;get_global_definition())</span></a>
<a name="5248"><span class="lineNum">    5248 </span>            :                                            {</a>
<a name="5249"><span class="lineNum">    5249 </span>            :                                           // skipThisSymbol = true;</a>
<a name="5250"><span class="lineNum">    5250 </span><span class="lineNoCov">          0 :                                              skipThisSymbol = false;</span></a>
<a name="5251"><span class="lineNum">    5251 </span>            :                                            }</a>
<a name="5252"><span class="lineNum">    5252 </span>            :                                       }</a>
<a name="5253"><span class="lineNum">    5253 </span>            :                                      else</a>
<a name="5254"><span class="lineNum">    5254 </span>            :                                       {</a>
<a name="5255"><span class="lineNum">    5255 </span><span class="lineCov">          1 :                                         ROSE_ASSERT(possible_extern_variable_scope != NULL &amp;&amp; original_variable_scope != NULL);</span></a>
<a name="5256"><span class="lineNum">    5256 </span><span class="lineCov">          1 :                                         if (possible_extern_variable_scope == original_variable_scope)</span></a>
<a name="5257"><span class="lineNum">    5257 </span>            :                                            {</a>
<a name="5258"><span class="lineNum">    5258 </span>            :                                           // skipThisSymbol = true;</a>
<a name="5259"><span class="lineNum">    5259 </span><span class="lineCov">          1 :                                              skipThisSymbol = false;</span></a>
<a name="5260"><span class="lineNum">    5260 </span>            :                                            }</a>
<a name="5261"><span class="lineNum">    5261 </span>            :                                       }</a>
<a name="5262"><span class="lineNum">    5262 </span>            :                                  }</a>
<a name="5263"><span class="lineNum">    5263 </span>            :                                 else</a>
<a name="5264"><span class="lineNum">    5264 </span>            :                                  {</a>
<a name="5265"><span class="lineNum">    5265 </span>            :                                 // If neither is marked extern, then they should not be name qualified.</a>
<a name="5266"><span class="lineNum">    5266 </span>            :                                    skipThisSymbol = false;</a>
<a name="5267"><span class="lineNum">    5267 </span>            :                                  }</a>
<a name="5268"><span class="lineNum">    5268 </span>            :                             }</a>
<a name="5269"><span class="lineNum">    5269 </span>            :                        }</a>
<a name="5270"><span class="lineNum">    5270 </span>            :                   }</a>
<a name="5271"><span class="lineNum">    5271 </span>            : </a>
<a name="5272"><span class="lineNum">    5272 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || DEBUG_SKIP_VARIABLE_SYMBOL</a>
<a name="5273"><span class="lineNum">    5273 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;skipThisSymbol = %s \n&quot;,skipThisSymbol ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="5274"><span class="lineNum">    5274 </span>            : #endif</a>
<a name="5275"><span class="lineNum">    5275 </span>            : </a>
<a name="5276"><span class="lineNum">    5276 </span>            : #if 0</a>
<a name="5277"><span class="lineNum">    5277 </span>            :             // DQ (6/1/2019): Better to seatch if the scopes are the same then is the previous variable declaration was marked as extern.</a>
<a name="5278"><span class="lineNum">    5278 </span>            :                   {</a>
<a name="5279"><span class="lineNum">    5279 </span>            :                     if (variableDeclaration != NULL &amp;&amp; variableDeclaration-&gt;get_declarationModifier().get_storageModifier().isExtern() &amp;&amp; variableDeclaration-&gt;get_linkage().empty() == true)</a>
<a name="5280"><span class="lineNum">    5280 </span>            :                        {</a>
<a name="5281"><span class="lineNum">    5281 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || 0</a>
<a name="5282"><span class="lineNum">    5282 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;FOUND extern modifier \n&quot;);</a>
<a name="5283"><span class="lineNum">    5283 </span>            : #endif</a>
<a name="5284"><span class="lineNum">    5284 </span>            :                          if ( (variableDeclaration-&gt;get_declarationModifier().isFriend() == false) &amp;&amp; (isSgTemplateVariableDeclaration(variableDeclaration) == NULL) )</a>
<a name="5285"><span class="lineNum">    5285 </span>            :                             {</a>
<a name="5286"><span class="lineNum">    5286 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || 0</a>
<a name="5287"><span class="lineNum">    5287 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;SETTING skipThisSymbol = true \n&quot;);</a>
<a name="5288"><span class="lineNum">    5288 </span>            : #endif</a>
<a name="5289"><span class="lineNum">    5289 </span>            :                               skipThisSymbol = true;</a>
<a name="5290"><span class="lineNum">    5290 </span>            :                             }</a>
<a name="5291"><span class="lineNum">    5291 </span>            :                            else</a>
<a name="5292"><span class="lineNum">    5292 </span>            :                             {</a>
<a name="5293"><span class="lineNum">    5293 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || 0</a>
<a name="5294"><span class="lineNum">    5294 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;NOT setting skipThisSymbol = true \n&quot;);</a>
<a name="5295"><span class="lineNum">    5295 </span>            : #endif</a>
<a name="5296"><span class="lineNum">    5296 </span>            :                             }</a>
<a name="5297"><span class="lineNum">    5297 </span>            :                        }</a>
<a name="5298"><span class="lineNum">    5298 </span>            :                       else</a>
<a name="5299"><span class="lineNum">    5299 </span>            :                        {</a>
<a name="5300"><span class="lineNum">    5300 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || 0</a>
<a name="5301"><span class="lineNum">    5301 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;NOT found extern modifier \n&quot;);</a>
<a name="5302"><span class="lineNum">    5302 </span>            : #endif</a>
<a name="5303"><span class="lineNum">    5303 </span>            :                        }</a>
<a name="5304"><span class="lineNum">    5304 </span>            :                   }</a>
<a name="5305"><span class="lineNum">    5305 </span>            : #endif</a>
<a name="5306"><span class="lineNum">    5306 </span>            : </a>
<a name="5307"><span class="lineNum">    5307 </span>            :             // DQ (6/4/2011): Get the associated symbol so that we can avoid matching on name only; and not the actual SgVariableSymbol symbols.</a>
<a name="5308"><span class="lineNum">    5308 </span><span class="lineCov">          7 :                SgVariableSymbol* targetInitializedNameSymbol = isSgVariableSymbol(initializedName-&gt;search_for_symbol_from_symbol_table());</span></a>
<a name="5309"><span class="lineNum">    5309 </span><span class="lineCov">          7 :                ASSERT_not_null(targetInitializedNameSymbol);</span></a>
<a name="5310"><span class="lineNum">    5310 </span>            : </a>
<a name="5311"><span class="lineNum">    5311 </span>            :             // DQ (6/1/2019): If this is associated with an extern declaration then don't use this symbol (see test2019_470.C).</a>
<a name="5312"><span class="lineNum">    5312 </span>            :             // DQ (6/4/2011): Make sure we have the correct symbol, else we have detected a collision which will require name qualification to resolve.</a>
<a name="5313"><span class="lineNum">    5313 </span>            :             // if (variableSymbol == targetInitializedNameSymbol)</a>
<a name="5314"><span class="lineNum">    5314 </span>            :             // if (variableSymbol == targetInitializedNameSymbol &amp;&amp; skipThisSymbol == false)</a>
<a name="5315"><span class="lineNum">    5315 </span><span class="lineCov">          7 :                if (variableSymbol == targetInitializedNameSymbol &amp;&amp; skipThisSymbol == false)</span></a>
<a name="5316"><span class="lineNum">    5316 </span>            :                   {</a>
<a name="5317"><span class="lineNum">    5317 </span>            :                  // Found the correct symbol.</a>
<a name="5318"><span class="lineNum">    5318 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="5319"><span class="lineNum">    5319 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Found the correct SgVariableSymbol \n&quot;);</a>
<a name="5320"><span class="lineNum">    5320 </span>            : #endif</a>
<a name="5321"><span class="lineNum">    5321 </span>            :                   }</a>
<a name="5322"><span class="lineNum">    5322 </span>            :                  else</a>
<a name="5323"><span class="lineNum">    5323 </span>            :                   {</a>
<a name="5324"><span class="lineNum">    5324 </span>            :                  // This is not the correct symbol, even though the unqualified names match.</a>
<a name="5325"><span class="lineNum">    5325 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="5326"><span class="lineNum">    5326 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;These symbols only match based on name and is not the targetInitializedNameSymbol. \n&quot;);</a>
<a name="5327"><span class="lineNum">    5327 </span>            : #endif</a>
<a name="5328"><span class="lineNum">    5328 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="5329"><span class="lineNum">    5329 </span>            :                  // DQ (12/15/2014): Liao's move tool will cause this message to be output, but it is not a problem (I think).</a>
<a name="5330"><span class="lineNum">    5330 </span>            :                     if (declaration == NULL)</a>
<a name="5331"><span class="lineNum">    5331 </span>            :                        {</a>
<a name="5332"><span class="lineNum">    5332 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;variableSymbol = %p \n&quot;,variableSymbol);</a>
<a name="5333"><span class="lineNum">    5333 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;targetInitializedNameSymbol = %p = %s \n&quot;,targetInitializedNameSymbol,targetInitializedNameSymbol-&gt;get_name().str());</a>
<a name="5334"><span class="lineNum">    5334 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;initializedName = %p = %s \n&quot;,initializedName,initializedName-&gt;get_name().str());</a>
<a name="5335"><span class="lineNum">    5335 </span>            :                          initializedName-&gt;get_file_info()-&gt;display(&quot;NameQualificationTraversal::nameQualificationDepth(): initializedName&quot;);</a>
<a name="5336"><span class="lineNum">    5336 </span>            :                        }</a>
<a name="5337"><span class="lineNum">    5337 </span>            : #endif</a>
<a name="5338"><span class="lineNum">    5338 </span>            : </a>
<a name="5339"><span class="lineNum">    5339 </span>            :                  // DQ (12/28/2011): I think it may be OK to have this be NULL, in which case there is not name qualification (scope has no associated declaration, so it is NULL as is should be).</a>
<a name="5340"><span class="lineNum">    5340 </span>            :                  // ASSERT_not_null(declaration);</a>
<a name="5341"><span class="lineNum">    5341 </span><span class="lineNoCov">          0 :                     if (declaration != NULL)</span></a>
<a name="5342"><span class="lineNum">    5342 </span>            :                        {</a>
<a name="5343"><span class="lineNum">    5343 </span><span class="lineNoCov">          0 :                          amountOfNameQualificationRequired = nameQualificationDepth(declaration,currentScope,positionStatement) + 1;</span></a>
<a name="5344"><span class="lineNum">    5344 </span>            :                        }</a>
<a name="5345"><span class="lineNum">    5345 </span>            :                       else</a>
<a name="5346"><span class="lineNum">    5346 </span>            :                        {</a>
<a name="5347"><span class="lineNum">    5347 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="5348"><span class="lineNum">    5348 </span>            :                       // DQ (12/15/2014): Liao's move tool will cause this message to be output, but it is not a problem (I think).</a>
<a name="5349"><span class="lineNum">    5349 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;Warning: In NameQualificationTraversal::nameQualificationDepth() --- It might be that this is an incorrect fix for where declaration == NULL in test2004_97.C \n&quot;);</a>
<a name="5350"><span class="lineNum">    5350 </span>            : #endif</a>
<a name="5351"><span class="lineNum">    5351 </span>            :                        }</a>
<a name="5352"><span class="lineNum">    5352 </span>            :                   }</a>
<a name="5353"><span class="lineNum">    5353 </span>            :              }</a>
<a name="5354"><span class="lineNum">    5354 </span>            :         }</a>
<a name="5355"><span class="lineNum">    5355 </span>            :        else</a>
<a name="5356"><span class="lineNum">    5356 </span>            :         {</a>
<a name="5357"><span class="lineNum">    5357 </span>            :        // Symbol for the SgInitializedName is not in the current scope or those of parent scopes.  So some name qualification is required.</a>
<a name="5358"><span class="lineNum">    5358 </span>            :        // amountOfNameQualificationRequired = nameQualificationDepth(associatedDeclaration(initializedName-&gt;get_scope()),currentScope,positionStatement) + 1;</a>
<a name="5359"><span class="lineNum">    5359 </span>            :        // SgDeclarationStatement* declaration = associatedDeclaration(initializedName-&gt;get_scope());</a>
<a name="5360"><span class="lineNum">    5360 </span>            :        // amountOfNameQualificationRequired = nameQualificationDepth(declaration,currentScope,positionStatement) + 1;</a>
<a name="5361"><span class="lineNum">    5361 </span>            :        // ASSERT_not_null(declaration);</a>
<a name="5362"><span class="lineNum">    5362 </span>            : </a>
<a name="5363"><span class="lineNum">    5363 </span>            :        // See test2004_34.C for an example of where declaration == NULL</a>
<a name="5364"><span class="lineNum">    5364 </span><span class="lineCov">        288 :           if (declaration != NULL)</span></a>
<a name="5365"><span class="lineNum">    5365 </span>            :              {</a>
<a name="5366"><span class="lineNum">    5366 </span><span class="lineCov">        176 :                amountOfNameQualificationRequired = nameQualificationDepth(declaration,currentScope,positionStatement) + 1;</span></a>
<a name="5367"><span class="lineNum">    5367 </span>            :              }</a>
<a name="5368"><span class="lineNum">    5368 </span>            :             else</a>
<a name="5369"><span class="lineNum">    5369 </span>            :              {</a>
<a name="5370"><span class="lineNum">    5370 </span>            :             // This can be the case of ??? &quot;catch (Overflow)&quot; (see test2004_43.C) instead of &quot;catch (Overflow xxx)&quot; (see test2011_71.C).</a>
<a name="5371"><span class="lineNum">    5371 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="5372"><span class="lineNum">    5372 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::nameQualificationDepth(SgInitializedName*): declaration == NULL, why is this? initializedName-&gt;get_scope() = %p = %s \n&quot;,initializedName-&gt;get_scope(),initializedName-&gt;get_scope()-&gt;class_name().c_str());</a>
<a name="5373"><span class="lineNum">    5373 </span>            : #endif</a>
<a name="5374"><span class="lineNum">    5374 </span>            :             // ROSE_ASSERT(false);</a>
<a name="5375"><span class="lineNum">    5375 </span>            :              }</a>
<a name="5376"><span class="lineNum">    5376 </span>            :         }</a>
<a name="5377"><span class="lineNum">    5377 </span>            : </a>
<a name="5378"><span class="lineNum">    5378 </span>            :   // amountOfNameQualificationRequired = nameQualificationDepth(declaration,currentScope,positionStatement);</a>
<a name="5379"><span class="lineNum">    5379 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="5380"><span class="lineNum">    5380 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;amountOfNameQualificationRequired = %d \n&quot;,amountOfNameQualificationRequired);</a>
<a name="5381"><span class="lineNum">    5381 </span>            : #endif</a>
<a name="5382"><span class="lineNum">    5382 </span>            : </a>
<a name="5383"><span class="lineNum">    5383 </span>            :      return amountOfNameQualificationRequired;</a>
<a name="5384"><span class="lineNum">    5384 </span>            :    }</a>
<a name="5385"><span class="lineNum">    5385 </span>            : </a>
<a name="5386"><span class="lineNum">    5386 </span>            : </a>
<a name="5387"><span class="lineNum">    5387 </span>            : // DQ (3/14/2019): Adding debugging support to output the map of names.</a>
<a name="5388"><span class="lineNum">    5388 </span>            : void</a>
<a name="5389"><span class="lineNum">    5389 </span><span class="lineNoCov">          0 : NameQualificationTraversal::outputNameQualificationMap( const std::map&lt;SgNode*,std::string&gt; &amp; qualifiedNameMap )</span></a>
<a name="5390"><span class="lineNum">    5390 </span>            :    {</a>
<a name="5391"><span class="lineNum">    5391 </span><span class="lineNoCov">          0 :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::outputNameQualificationMap(): qualifiedNameMap.size() = %zu \n&quot;,qualifiedNameMap.size());</span></a>
<a name="5392"><span class="lineNum">    5392 </span>            : </a>
<a name="5393"><span class="lineNum">    5393 </span><span class="lineNoCov">          0 :      int counter = 0;</span></a>
<a name="5394"><span class="lineNum">    5394 </span><span class="lineNoCov">          0 :      std::map&lt;SgNode*,std::string&gt;::const_iterator i = qualifiedNameMap.begin();</span></a>
<a name="5395"><span class="lineNum">    5395 </span><span class="lineNoCov">          0 :      while (i != qualifiedNameMap.end())</span></a>
<a name="5396"><span class="lineNum">    5396 </span>            :        {</a>
<a name="5397"><span class="lineNum">    5397 </span><span class="lineNoCov">          0 :          ASSERT_not_null(i-&gt;first);</span></a>
<a name="5398"><span class="lineNum">    5398 </span>            : </a>
<a name="5399"><span class="lineNum">    5399 </span><span class="lineNoCov">          0 :          mfprintf(mlog [ WARN ] ) (&quot; --- counter = %d *i = i-&gt;first = %p = %s i-&gt;second = %s \n&quot;,counter,i-&gt;first,i-&gt;first-&gt;class_name().c_str(),i-&gt;second.c_str());</span></a>
<a name="5400"><span class="lineNum">    5400 </span>            : </a>
<a name="5401"><span class="lineNum">    5401 </span><span class="lineNoCov">          0 :          counter++;</span></a>
<a name="5402"><span class="lineNum">    5402 </span><span class="lineNoCov">          0 :          i++;</span></a>
<a name="5403"><span class="lineNum">    5403 </span>            :        }</a>
<a name="5404"><span class="lineNum">    5404 </span><span class="lineNoCov">          0 :    }</span></a>
<a name="5405"><span class="lineNum">    5405 </span>            : </a>
<a name="5406"><span class="lineNum">    5406 </span>            : </a>
<a name="5407"><span class="lineNum">    5407 </span>            : </a>
<a name="5408"><span class="lineNum">    5408 </span>            : void</a>
<a name="5409"><span class="lineNum">    5409 </span><span class="lineCov">    1448560 : NameQualificationTraversal::addToNameMap ( SgNode* nodeReference, string typeNameString )</span></a>
<a name="5410"><span class="lineNum">    5410 </span>            :    {</a>
<a name="5411"><span class="lineNum">    5411 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || 0</a>
<a name="5412"><span class="lineNum">    5412 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In addToNameMap(): nodeReference = %p = %s typeNameString = %s \n&quot;,nodeReference,nodeReference-&gt;class_name().c_str(),typeNameString.c_str());</a>
<a name="5413"><span class="lineNum">    5413 </span>            : #endif</a>
<a name="5414"><span class="lineNum">    5414 </span>            : </a>
<a name="5415"><span class="lineNum">    5415 </span>            :   // DQ (6/21/2011): This is refactored code used in traverseType() and traverseTemplatedFunction().</a>
<a name="5416"><span class="lineNum">    5416 </span>            :   // bool isTemplateName = (typeNameString.find('&lt;') != string::npos) &amp;&amp; (typeNameString.find(&quot;::&quot;) != string::npos);</a>
<a name="5417"><span class="lineNum">    5417 </span><span class="lineCov">    1448560 :      bool isTemplateName = (typeNameString.find('&lt;') != string::npos); // &amp;&amp; (typeNameString.find(&quot;::&quot;) != string::npos);</span></a>
<a name="5418"><span class="lineNum">    5418 </span>            : </a>
<a name="5419"><span class="lineNum">    5419 </span><span class="lineCov">    1448560 :      bool isPointerMemberType = (isSgPointerMemberType(nodeReference) != NULL);</span></a>
<a name="5420"><span class="lineNum">    5420 </span>            : </a>
<a name="5421"><span class="lineNum">    5421 </span>            :   // DQ (4/21/2019): Unclear if we should store the intermediately generated strings for each part of a type.</a>
<a name="5422"><span class="lineNum">    5422 </span>            :   // I think that test2019_385.C makes it clear that we need to allow the SgPointerMemberType intermediate</a>
<a name="5423"><span class="lineNum">    5423 </span>            :   // strings to be reset.</a>
<a name="5424"><span class="lineNum">    5424 </span>            :   // isPointerMemberType = false;</a>
<a name="5425"><span class="lineNum">    5425 </span>            : </a>
<a name="5426"><span class="lineNum">    5426 </span><span class="lineCov">    1448560 :      bool isInitializedName    = (isSgInitializedName(nodeReference) != NULL);</span></a>
<a name="5427"><span class="lineNum">    5427 </span>            : </a>
<a name="5428"><span class="lineNum">    5428 </span>            :   // DQ (4/28/2019): Adding support for the base type if a SgTypedefDeclaration.</a>
<a name="5429"><span class="lineNum">    5429 </span><span class="lineCov">    1448560 :      bool isTypedefDeclaration = (isSgTypedefDeclaration(nodeReference) != NULL);</span></a>
<a name="5430"><span class="lineNum">    5430 </span>            : </a>
<a name="5431"><span class="lineNum">    5431 </span>            :   // DQ (4/28/2019): We only want to save the type as a string if it has a SgPointerMemberType (or a template instantiation).</a>
<a name="5432"><span class="lineNum">    5432 </span>            :   // I think the same thing is also true for the type associated with a SgInitializedName as well.</a>
<a name="5433"><span class="lineNum">    5433 </span><span class="lineCov">    1448560 :      SgTypedefDeclaration* typedefDeclaration = isSgTypedefDeclaration(nodeReference);</span></a>
<a name="5434"><span class="lineNum">    5434 </span><span class="lineCov">    1448560 :      if (typedefDeclaration != NULL)</span></a>
<a name="5435"><span class="lineNum">    5435 </span>            :         {</a>
<a name="5436"><span class="lineNum">    5436 </span><span class="lineCov">      12926 :           SgType* baseType = typedefDeclaration-&gt;get_base_type();</span></a>
<a name="5437"><span class="lineNum">    5437 </span>            : </a>
<a name="5438"><span class="lineNum">    5438 </span>            :        // We realy need to strip off any modifiers before we check if it is a SgPointerMembertype.</a>
<a name="5439"><span class="lineNum">    5439 </span><span class="lineCov">      12926 :           unsigned char bit_array = SgType::STRIP_MODIFIER_TYPE | SgType::STRIP_REFERENCE_TYPE | SgType::STRIP_RVALUE_REFERENCE_TYPE |</span></a>
<a name="5440"><span class="lineNum">    5440 </span>            :                                     SgType::STRIP_POINTER_TYPE  | SgType::STRIP_ARRAY_TYPE;</a>
<a name="5441"><span class="lineNum">    5441 </span><span class="lineCov">      12926 :           baseType = baseType-&gt;stripType(bit_array);</span></a>
<a name="5442"><span class="lineNum">    5442 </span><span class="lineCov">      12926 :           ASSERT_not_null(baseType);</span></a>
<a name="5443"><span class="lineNum">    5443 </span>            : </a>
<a name="5444"><span class="lineNum">    5444 </span>            :        // Check if this is something that could be name qualified.</a>
<a name="5445"><span class="lineNum">    5445 </span><span class="lineCov">      12926 :           SgPointerMemberType* pointerMemberType = isSgPointerMemberType(baseType);</span></a>
<a name="5446"><span class="lineNum">    5446 </span><span class="lineCov">      12926 :           SgNamedType*         namedType         = isSgNamedType(baseType);</span></a>
<a name="5447"><span class="lineNum">    5447 </span>            :        // if (pointerMemberType == NULL)</a>
<a name="5448"><span class="lineNum">    5448 </span><span class="lineCov">      12926 :           if (pointerMemberType == NULL &amp;&amp; namedType == NULL)</span></a>
<a name="5449"><span class="lineNum">    5449 </span>            :              {</a>
<a name="5450"><span class="lineNum">    5450 </span><span class="lineCov">       1070 :                isTypedefDeclaration = false;</span></a>
<a name="5451"><span class="lineNum">    5451 </span>            :              }</a>
<a name="5452"><span class="lineNum">    5452 </span>            : </a>
<a name="5453"><span class="lineNum">    5453 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || 0</a>
<a name="5454"><span class="lineNum">    5454 </span>            :        // Find out what type this is, we need to detect template instantiations as well, so that they CAN be used to generate strings.</a>
<a name="5455"><span class="lineNum">    5455 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;In addToNameMap(): case SgTypedefDeclaration: baseType = %p = %s \n&quot;,baseType,baseType-&gt;class_name().c_str());</a>
<a name="5456"><span class="lineNum">    5456 </span>            : #endif</a>
<a name="5457"><span class="lineNum">    5457 </span>            :         }</a>
<a name="5458"><span class="lineNum">    5458 </span>            : </a>
<a name="5459"><span class="lineNum">    5459 </span>            :   // DQ (4/28/2019): Handle the SgInitialzedName the same as the typedef.</a>
<a name="5460"><span class="lineNum">    5460 </span><span class="lineCov">    1448560 :      SgInitializedName* initializedName = isSgInitializedName(nodeReference);</span></a>
<a name="5461"><span class="lineNum">    5461 </span><span class="lineCov">    1448560 :      if (initializedName != NULL)</span></a>
<a name="5462"><span class="lineNum">    5462 </span>            :         {</a>
<a name="5463"><span class="lineNum">    5463 </span><span class="lineCov">    1206640 :           SgType* type = initializedName-&gt;get_type();</span></a>
<a name="5464"><span class="lineNum">    5464 </span>            : </a>
<a name="5465"><span class="lineNum">    5465 </span>            :        // We realy need to strip off any modifiers before we check if it is a SgPointerMembertype.</a>
<a name="5466"><span class="lineNum">    5466 </span><span class="lineCov">    1206640 :           unsigned char bit_array = SgType::STRIP_MODIFIER_TYPE | SgType::STRIP_REFERENCE_TYPE | SgType::STRIP_RVALUE_REFERENCE_TYPE |</span></a>
<a name="5467"><span class="lineNum">    5467 </span>            :                                     SgType::STRIP_POINTER_TYPE  | SgType::STRIP_ARRAY_TYPE;</a>
<a name="5468"><span class="lineNum">    5468 </span><span class="lineCov">    1206640 :           type = type-&gt;stripType(bit_array);</span></a>
<a name="5469"><span class="lineNum">    5469 </span><span class="lineCov">    1206640 :           ASSERT_not_null(type);</span></a>
<a name="5470"><span class="lineNum">    5470 </span>            : </a>
<a name="5471"><span class="lineNum">    5471 </span>            :        // Check if this is something that could be name qualified.</a>
<a name="5472"><span class="lineNum">    5472 </span><span class="lineCov">    1206640 :           SgPointerMemberType* pointerMemberType = isSgPointerMemberType(type);</span></a>
<a name="5473"><span class="lineNum">    5473 </span><span class="lineCov">    1206640 :           SgNamedType*         namedType         = isSgNamedType(type);</span></a>
<a name="5474"><span class="lineNum">    5474 </span>            :        // if (pointerMemberType == NULL)</a>
<a name="5475"><span class="lineNum">    5475 </span><span class="lineCov">    1206640 :           if (pointerMemberType == NULL &amp;&amp; namedType == NULL)</span></a>
<a name="5476"><span class="lineNum">    5476 </span>            :              {</a>
<a name="5477"><span class="lineNum">    5477 </span><span class="lineCov">        431 :                isInitializedName = false;</span></a>
<a name="5478"><span class="lineNum">    5478 </span>            :              }</a>
<a name="5479"><span class="lineNum">    5479 </span>            : </a>
<a name="5480"><span class="lineNum">    5480 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || 0</a>
<a name="5481"><span class="lineNum">    5481 </span>            :        // Find out what type this is, we need to detect template instantiations as well, so that they CAN be used to generate strings.</a>
<a name="5482"><span class="lineNum">    5482 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;In addToNameMap(): case SgInitializedName: type = %p = %s \n&quot;,type,type-&gt;class_name().c_str());</a>
<a name="5483"><span class="lineNum">    5483 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;In addToNameMap(): case SgInitializedName: isInitializedName = %s \n&quot;,isInitializedName ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="5484"><span class="lineNum">    5484 </span>            : #endif</a>
<a name="5485"><span class="lineNum">    5485 </span>            :         }</a>
<a name="5486"><span class="lineNum">    5486 </span>            : </a>
<a name="5487"><span class="lineNum">    5487 </span>            : </a>
<a name="5488"><span class="lineNum">    5488 </span>            : #if 0</a>
<a name="5489"><span class="lineNum">    5489 </span>            :   // DQ (4/22/2019): Debugging test2019_397.C.</a>
<a name="5490"><span class="lineNum">    5490 </span>            :      if (isInitializedName == true)</a>
<a name="5491"><span class="lineNum">    5491 </span>            :        {</a>
<a name="5492"><span class="lineNum">    5492 </span>            :          mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="5493"><span class="lineNum">    5493 </span>            :          ROSE_ABORT();</a>
<a name="5494"><span class="lineNum">    5494 </span>            :        }</a>
<a name="5495"><span class="lineNum">    5495 </span>            :   // DQ (4/22/2019): Test setting this to false for test2019_397.C.</a>
<a name="5496"><span class="lineNum">    5496 </span>            :   // isInitializedName = false;</a>
<a name="5497"><span class="lineNum">    5497 </span>            : #endif</a>
<a name="5498"><span class="lineNum">    5498 </span>            : </a>
<a name="5499"><span class="lineNum">    5499 </span>            :   // DQ (4/21/2019): The list of nodes which we will have to allow to store types as generated strings will</a>
<a name="5500"><span class="lineNum">    5500 </span>            :   // have to include expressions (SgNewExp, SgSizeOf, SgCastExp, SgTypeIdOp)</a>
<a name="5501"><span class="lineNum">    5501 </span>            :   // and functions (SgFunctionDeclaration)</a>
<a name="5502"><span class="lineNum">    5502 </span>            :   // and maybe that is about it.</a>
<a name="5503"><span class="lineNum">    5503 </span>            : </a>
<a name="5504"><span class="lineNum">    5504 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || 0</a>
<a name="5505"><span class="lineNum">    5505 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In addToNameMap(): isTemplateName = %s isPointerMemberType = %s nodeReference = %p = %s typeNameString = %s \n&quot;,</a>
<a name="5506"><span class="lineNum">    5506 </span>            :           isTemplateName ? &quot;true&quot; : &quot;false&quot;,isPointerMemberType ? &quot;true&quot; : &quot;false&quot;,nodeReference,nodeReference-&gt;class_name().c_str(),typeNameString.c_str());</a>
<a name="5507"><span class="lineNum">    5507 </span>            : #endif</a>
<a name="5508"><span class="lineNum">    5508 </span>            : </a>
<a name="5509"><span class="lineNum">    5509 </span>            :   // DQ (4/21/2019): Adding case to support SgInitializedName.</a>
<a name="5510"><span class="lineNum">    5510 </span>            :   // DQ (4/18/2019): We need to support SgPointerMemberType as well.</a>
<a name="5511"><span class="lineNum">    5511 </span>            :   // if (isTemplateName == true)</a>
<a name="5512"><span class="lineNum">    5512 </span>            :   // if (isTemplateName == true || isPointerMemberType == true)</a>
<a name="5513"><span class="lineNum">    5513 </span>            :   // if (isTemplateName == true || isPointerMemberType == true || isInitializedName == true)</a>
<a name="5514"><span class="lineNum">    5514 </span><span class="lineCov">    1448560 :      if (isTemplateName == true || isPointerMemberType == true || isInitializedName == true || isTypedefDeclaration == true)</span></a>
<a name="5515"><span class="lineNum">    5515 </span>            :         {</a>
<a name="5516"><span class="lineNum">    5516 </span><span class="lineCov">    2469540 :           if (typeNameMap.find(nodeReference) == typeNameMap.end())</span></a>
<a name="5517"><span class="lineNum">    5517 </span>            :              {</a>
<a name="5518"><span class="lineNum">    5518 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || 0</a>
<a name="5519"><span class="lineNum">    5519 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;============== Inserting qualifier for name = %s into typeNameMap list at IR node = %p = %s \n&quot;,</a>
<a name="5520"><span class="lineNum">    5520 </span>            :                     typeNameString.c_str(),nodeReference,nodeReference-&gt;class_name().c_str());</a>
<a name="5521"><span class="lineNum">    5521 </span>            : #endif</a>
<a name="5522"><span class="lineNum">    5522 </span><span class="lineCov">    1227640 :                typeNameMap.insert(std::pair&lt;SgNode*,std::string&gt;(nodeReference,typeNameString));</span></a>
<a name="5523"><span class="lineNum">    5523 </span>            :              }</a>
<a name="5524"><span class="lineNum">    5524 </span>            :             else</a>
<a name="5525"><span class="lineNum">    5525 </span>            :              {</a>
<a name="5526"><span class="lineNum">    5526 </span>            :             // If it already exists, then overwrite the existing information.</a>
<a name="5527"><span class="lineNum">    5527 </span><span class="lineCov">     139695 :                std::map&lt;SgNode*,std::string&gt;::iterator i = typeNameMap.find(nodeReference);</span></a>
<a name="5528"><span class="lineNum">    5528 </span><span class="lineCov">       7133 :                ROSE_ASSERT (i != typeNameMap.end());</span></a>
<a name="5529"><span class="lineNum">    5529 </span>            : </a>
<a name="5530"><span class="lineNum">    5530 </span><span class="lineCov">      14266 :                string previousTypeName = i-&gt;second.c_str();</span></a>
<a name="5531"><span class="lineNum">    5531 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || 0</a>
<a name="5532"><span class="lineNum">    5532 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;WARNING: replacing previousTypeName = %s with new typeNameString = %s for nodeReference = %p = %s \n&quot;,</a>
<a name="5533"><span class="lineNum">    5533 </span>            :                     previousTypeName.c_str(),typeNameString.c_str(),nodeReference,nodeReference-&gt;class_name().c_str());</a>
<a name="5534"><span class="lineNum">    5534 </span>            : #endif</a>
<a name="5535"><span class="lineNum">    5535 </span><span class="lineCov">       7133 :                if (i-&gt;second != typeNameString)</span></a>
<a name="5536"><span class="lineNum">    5536 </span>            :                   {</a>
<a name="5537"><span class="lineNum">    5537 </span><span class="lineNoCov">          0 :                     i-&gt;second = typeNameString;</span></a>
<a name="5538"><span class="lineNum">    5538 </span>            : #if 0</a>
<a name="5539"><span class="lineNum">    5539 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Error: name in qualifiedNameMapForNames already exists and is different... nodeReference = %p = %s \n&quot;,nodeReference,nodeReference-&gt;class_name().c_str());</a>
<a name="5540"><span class="lineNum">    5540 </span>            :                     ROSE_ABORT();</a>
<a name="5541"><span class="lineNum">    5541 </span>            : #else</a>
<a name="5542"><span class="lineNum">    5542 </span><span class="lineNoCov">          0 :                     mfprintf(mlog [ WARN ] ) (&quot;In addToNameMap(): Allow this for replacement now! \n&quot;);</span></a>
<a name="5543"><span class="lineNum">    5543 </span>            : #endif</a>
<a name="5544"><span class="lineNum">    5544 </span>            :                  }</a>
<a name="5545"><span class="lineNum">    5545 </span>            :              }</a>
<a name="5546"><span class="lineNum">    5546 </span>            :         }</a>
<a name="5547"><span class="lineNum">    5547 </span>            :        else</a>
<a name="5548"><span class="lineNum">    5548 </span>            :         {</a>
<a name="5549"><span class="lineNum">    5549 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || 0</a>
<a name="5550"><span class="lineNum">    5550 </span>            :        // DQ (8/19/2013): comment added for debugging.</a>
<a name="5551"><span class="lineNum">    5551 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::addToNameMap(): isTemplateName == false, typeNameString = %s NOT added to typeNameMap for key = %p = %s \n&quot;,typeNameString.c_str(),nodeReference,nodeReference-&gt;class_name().c_str());</a>
<a name="5552"><span class="lineNum">    5552 </span>            : #endif</a>
<a name="5553"><span class="lineNum">    5553 </span>            :         }</a>
<a name="5554"><span class="lineNum">    5554 </span>            : </a>
<a name="5555"><span class="lineNum">    5555 </span>            : #if 0</a>
<a name="5556"><span class="lineNum">    5556 </span>            :   // DQ (4/21/2019): This is too much output when we are debugging the typeid operator</a>
<a name="5557"><span class="lineNum">    5557 </span>            :   // examples (since the header files have to be included). It does seem that this table</a>
<a name="5558"><span class="lineNum">    5558 </span>            :   // can get quit large for reasons that my have nothing to do with name qualification,</a>
<a name="5559"><span class="lineNum">    5559 </span>            :   // so we might want to look into the size of this table at some point.</a>
<a name="5560"><span class="lineNum">    5560 </span>            :   // DQ (3/14/2019): Adding debugging support.</a>
<a name="5561"><span class="lineNum">    5561 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || 0</a>
<a name="5562"><span class="lineNum">    5562 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;Leaving addToNameMap(): calling outputNameQualificationMap(): using typeNameMap \n&quot;);</a>
<a name="5563"><span class="lineNum">    5563 </span>            :      outputNameQualificationMap(typeNameMap);</a>
<a name="5564"><span class="lineNum">    5564 </span>            : #endif</a>
<a name="5565"><span class="lineNum">    5565 </span>            : #endif</a>
<a name="5566"><span class="lineNum">    5566 </span><span class="lineCov">    1448560 :    }</span></a>
<a name="5567"><span class="lineNum">    5567 </span>            : </a>
<a name="5568"><span class="lineNum">    5568 </span>            : </a>
<a name="5569"><span class="lineNum">    5569 </span>            : void</a>
<a name="5570"><span class="lineNum">    5570 </span><span class="lineCov">    1532540 : NameQualificationTraversal::traverseType ( SgType* type, SgNode* nodeReferenceToType, SgScopeStatement* currentScope, SgStatement* positionStatement )</span></a>
<a name="5571"><span class="lineNum">    5571 </span>            :    {</a>
<a name="5572"><span class="lineNum">    5572 </span>            :   // The type can contain subtypes (e.g. template arguments) and when the subtypes need to be name qualified the name of the encompassing type</a>
<a name="5573"><span class="lineNum">    5573 </span>            :   // has a name that depends upon its location in the source code (and could vary depending on the positon in a single basic block, I think).</a>
<a name="5574"><span class="lineNum">    5574 </span>            : </a>
<a name="5575"><span class="lineNum">    5575 </span>            : #define DEBUG_TRAVERSE_TYPE 0</a>
<a name="5576"><span class="lineNum">    5576 </span>            : </a>
<a name="5577"><span class="lineNum">    5577 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || DEBUG_TRAVERSE_TYPE</a>
<a name="5578"><span class="lineNum">    5578 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;&lt;&lt;&lt;&lt;&lt; Starting traversal of type: type = %p = %s \n&quot;,type,type-&gt;class_name().c_str());</a>
<a name="5579"><span class="lineNum">    5579 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In traverseType(): nodeReferenceToType = %p = %s \n&quot;,nodeReferenceToType,nodeReferenceToType-&gt;class_name().c_str());</a>
<a name="5580"><span class="lineNum">    5580 </span>            : #endif</a>
<a name="5581"><span class="lineNum">    5581 </span>            : </a>
<a name="5582"><span class="lineNum">    5582 </span>            :   // DQ (4/27/2019): If this is an un-named type then it can't be name qualified, so we can exit directly.</a>
<a name="5583"><span class="lineNum">    5583 </span>            :   // We don't want to generate strings to represent the types from unNamed declarations that could not be name qualified anyway.</a>
<a name="5584"><span class="lineNum">    5584 </span><span class="lineCov">    1532540 :      bool isUnNamed = false;</span></a>
<a name="5585"><span class="lineNum">    5585 </span>            :   // SgNamedType* namedType = isSgNamedType(type);</a>
<a name="5586"><span class="lineNum">    5586 </span><span class="lineCov">    1532540 :      unsigned char bit_array = SgType::STRIP_MODIFIER_TYPE | SgType::STRIP_REFERENCE_TYPE | SgType::STRIP_RVALUE_REFERENCE_TYPE |</span></a>
<a name="5587"><span class="lineNum">    5587 </span>            :                                SgType::STRIP_POINTER_TYPE  | SgType::STRIP_ARRAY_TYPE;</a>
<a name="5588"><span class="lineNum">    5588 </span><span class="lineCov">    1532540 :      SgType* strippedType = type-&gt;stripType(bit_array);</span></a>
<a name="5589"><span class="lineNum">    5589 </span>            : </a>
<a name="5590"><span class="lineNum">    5590 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || DEBUG_TRAVERSE_TYPE</a>
<a name="5591"><span class="lineNum">    5591 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In traverseType(): strippedType = %p = %s \n&quot;,strippedType,strippedType-&gt;class_name().c_str());</a>
<a name="5592"><span class="lineNum">    5592 </span>            : #endif</a>
<a name="5593"><span class="lineNum">    5593 </span>            : </a>
<a name="5594"><span class="lineNum">    5594 </span><span class="lineCov">    1532540 :      SgNamedType* namedType = isSgNamedType(strippedType);</span></a>
<a name="5595"><span class="lineNum">    5595 </span><span class="lineCov">    1532540 :      if (namedType != NULL)</span></a>
<a name="5596"><span class="lineNum">    5596 </span>            :         {</a>
<a name="5597"><span class="lineNum">    5597 </span><span class="lineCov">    1440870 :           SgEnumType*  enumType  = isSgEnumType(namedType);</span></a>
<a name="5598"><span class="lineNum">    5598 </span><span class="lineCov">    1440870 :           SgClassType* classType = isSgClassType(namedType);</span></a>
<a name="5599"><span class="lineNum">    5599 </span>            : </a>
<a name="5600"><span class="lineNum">    5600 </span><span class="lineCov">    1440870 :           if (enumType != NULL)</span></a>
<a name="5601"><span class="lineNum">    5601 </span>            :              {</a>
<a name="5602"><span class="lineNum">    5602 </span><span class="lineCov">       3360 :                SgEnumDeclaration* enumDeclaration = isSgEnumDeclaration(enumType-&gt;get_declaration());</span></a>
<a name="5603"><span class="lineNum">    5603 </span><span class="lineCov">       3360 :                ASSERT_not_null(enumDeclaration);</span></a>
<a name="5604"><span class="lineNum">    5604 </span>            : #if DEBUG_TRAVERSE_TYPE</a>
<a name="5605"><span class="lineNum">    5605 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;enumDeclaration-&gt;get_isUnNamed()        = %s \n&quot;,enumDeclaration-&gt;get_isUnNamed() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="5606"><span class="lineNum">    5606 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;namedType-&gt;get_autonomous_declaration() = %s \n&quot;,namedType-&gt;get_autonomous_declaration() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="5607"><span class="lineNum">    5607 </span>            : #endif</a>
<a name="5608"><span class="lineNum">    5608 </span><span class="lineCov">       3360 :                isUnNamed = enumDeclaration-&gt;get_isUnNamed();</span></a>
<a name="5609"><span class="lineNum">    5609 </span>            :              }</a>
<a name="5610"><span class="lineNum">    5610 </span>            :             else</a>
<a name="5611"><span class="lineNum">    5611 </span>            :              {</a>
<a name="5612"><span class="lineNum">    5612 </span><span class="lineCov">    1437510 :                if (classType != NULL)</span></a>
<a name="5613"><span class="lineNum">    5613 </span>            :                   {</a>
<a name="5614"><span class="lineNum">    5614 </span><span class="lineCov">      32922 :                     SgClassDeclaration* classDeclaration = isSgClassDeclaration(classType-&gt;get_declaration());</span></a>
<a name="5615"><span class="lineNum">    5615 </span><span class="lineCov">      32922 :                     ASSERT_not_null(classDeclaration);</span></a>
<a name="5616"><span class="lineNum">    5616 </span>            : #if DEBUG_TRAVERSE_TYPE</a>
<a name="5617"><span class="lineNum">    5617 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;classDeclaration-&gt;get_isUnNamed()       = %s \n&quot;,classDeclaration-&gt;get_isUnNamed() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="5618"><span class="lineNum">    5618 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;namedType-&gt;get_autonomous_declaration() = %s \n&quot;,namedType-&gt;get_autonomous_declaration() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="5619"><span class="lineNum">    5619 </span>            : #endif</a>
<a name="5620"><span class="lineNum">    5620 </span><span class="lineCov">      32922 :                     isUnNamed = classDeclaration-&gt;get_isUnNamed();</span></a>
<a name="5621"><span class="lineNum">    5621 </span>            :                   }</a>
<a name="5622"><span class="lineNum">    5622 </span>            :                  else</a>
<a name="5623"><span class="lineNum">    5623 </span>            :                   {</a>
<a name="5624"><span class="lineNum">    5624 </span>            :                  // This is most commonly a SgTypedefType, but they can't be un-named.</a>
<a name="5625"><span class="lineNum">    5625 </span>            : #if DEBUG_TRAVERSE_TYPE</a>
<a name="5626"><span class="lineNum">    5626 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;In traverseType(): Alternative SgNamedType: namedType = %p = %s \n&quot;,namedType,namedType-&gt;class_name().c_str());</a>
<a name="5627"><span class="lineNum">    5627 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;namedType-&gt;get_autonomous_declaration()               = %s \n&quot;,namedType-&gt;get_autonomous_declaration() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="5628"><span class="lineNum">    5628 </span>            : #endif</a>
<a name="5629"><span class="lineNum">    5629 </span>            :                   }</a>
<a name="5630"><span class="lineNum">    5630 </span>            :              }</a>
<a name="5631"><span class="lineNum">    5631 </span>            : </a>
<a name="5632"><span class="lineNum">    5632 </span>            : #if 0</a>
<a name="5633"><span class="lineNum">    5633 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="5634"><span class="lineNum">    5634 </span>            :           ROSE_ABORT();</a>
<a name="5635"><span class="lineNum">    5635 </span>            : #endif</a>
<a name="5636"><span class="lineNum">    5636 </span>            : </a>
<a name="5637"><span class="lineNum">    5637 </span>            :        // Return from function if this is associated wqith an unNamed declaration (since it could not be name qualified).</a>
<a name="5638"><span class="lineNum">    5638 </span><span class="lineCov">      36282 :           if (isUnNamed == true)</span></a>
<a name="5639"><span class="lineNum">    5639 </span>            :              {</a>
<a name="5640"><span class="lineNum">    5640 </span>            : #if DEBUG_TRAVERSE_TYPE</a>
<a name="5641"><span class="lineNum">    5641 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;In traverseType(): isUnNamed == true: returning \n&quot;);</a>
<a name="5642"><span class="lineNum">    5642 </span>            : #endif</a>
<a name="5643"><span class="lineNum">    5643 </span>            :                return;</a>
<a name="5644"><span class="lineNum">    5644 </span>            :              }</a>
<a name="5645"><span class="lineNum">    5645 </span>            :         }</a>
<a name="5646"><span class="lineNum">    5646 </span>            : </a>
<a name="5647"><span class="lineNum">    5647 </span>            :   // DQ (4/22/2019): Need to detect when this is part of a type from a paremter in a function parameter list.</a>
<a name="5648"><span class="lineNum">    5648 </span><span class="lineCov">    1531140 :      SgInitializedName* initializedName = isSgInitializedName(nodeReferenceToType);</span></a>
<a name="5649"><span class="lineNum">    5649 </span><span class="lineCov">    1531140 :      bool inArgList = false;</span></a>
<a name="5650"><span class="lineNum">    5650 </span><span class="lineCov">    1531140 :      if (initializedName != NULL)</span></a>
<a name="5651"><span class="lineNum">    5651 </span>            :         {</a>
<a name="5652"><span class="lineNum">    5652 </span>            : #if DEBUG_TRAVERSE_TYPE</a>
<a name="5653"><span class="lineNum">    5653 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Found a SgInitializedName: initializedName = %p name = %s \n&quot;,initializedName,initializedName-&gt;get_name().str());</a>
<a name="5654"><span class="lineNum">    5654 </span>            : #endif</a>
<a name="5655"><span class="lineNum">    5655 </span>            :        // If this is a part of a function parameter list, then we need to set info.inArgList() in the Unparse_Info object that we pass to the unparse the type.</a>
<a name="5656"><span class="lineNum">    5656 </span><span class="lineCov">    1208730 :           SgFunctionParameterList* functionParameterList = isSgFunctionParameterList(initializedName-&gt;get_parent());</span></a>
<a name="5657"><span class="lineNum">    5657 </span><span class="lineCov">    1208730 :           inArgList = (functionParameterList != NULL);</span></a>
<a name="5658"><span class="lineNum">    5658 </span>            :         }</a>
<a name="5659"><span class="lineNum">    5659 </span>            : </a>
<a name="5660"><span class="lineNum">    5660 </span>            :   // DQ (4/28/2019): Need to detect when this is part of a base type from a typedef declaration.</a>
<a name="5661"><span class="lineNum">    5661 </span><span class="lineCov">    1531140 :      SgTypedefDeclaration* typedefDeclaration = isSgTypedefDeclaration(nodeReferenceToType);</span></a>
<a name="5662"><span class="lineNum">    5662 </span><span class="lineCov">    1531140 :      bool inTypedefDecl = false;</span></a>
<a name="5663"><span class="lineNum">    5663 </span><span class="lineCov">    1531140 :      if (typedefDeclaration != NULL)</span></a>
<a name="5664"><span class="lineNum">    5664 </span>            :         {</a>
<a name="5665"><span class="lineNum">    5665 </span>            : #if DEBUG_TRAVERSE_TYPE</a>
<a name="5666"><span class="lineNum">    5666 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Found a SgTypedefDeclaration: typedefDeclaration = %p name = %s \n&quot;,typedefDeclaration,typedefDeclaration-&gt;get_name().str());</a>
<a name="5667"><span class="lineNum">    5667 </span>            : #endif</a>
<a name="5668"><span class="lineNum">    5668 </span><span class="lineCov">      20086 :           inTypedefDecl = true;</span></a>
<a name="5669"><span class="lineNum">    5669 </span>            :         }</a>
<a name="5670"><span class="lineNum">    5670 </span>            : </a>
<a name="5671"><span class="lineNum">    5671 </span>            : </a>
<a name="5672"><span class="lineNum">    5672 </span>            :   // DQ (4/27/2019): Could this be how we trigger name qualification for constructor preinitialization lists?</a>
<a name="5673"><span class="lineNum">    5673 </span><span class="lineCov">    1531140 :      SgConstructorInitializer* constructorInitializer = isSgConstructorInitializer(nodeReferenceToType);</span></a>
<a name="5674"><span class="lineNum">    5674 </span><span class="lineCov">    1531140 :      if (constructorInitializer != NULL)</span></a>
<a name="5675"><span class="lineNum">    5675 </span>            :         {</a>
<a name="5676"><span class="lineNum">    5676 </span>            : #if DEBUG_TRAVERSE_TYPE</a>
<a name="5677"><span class="lineNum">    5677 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Found a SgConstructorInitializer: %p \n&quot;,constructorInitializer);</a>
<a name="5678"><span class="lineNum">    5678 </span>            : #endif</a>
<a name="5679"><span class="lineNum">    5679 </span>            :         }</a>
<a name="5680"><span class="lineNum">    5680 </span>            : </a>
<a name="5681"><span class="lineNum">    5681 </span><span class="lineCov">    1531140 :      ASSERT_not_null(nodeReferenceToType);</span></a>
<a name="5682"><span class="lineNum">    5682 </span>            : </a>
<a name="5683"><span class="lineNum">    5683 </span>            :   // DQ (3/29/2019): I think we are ready to address this now.</a>
<a name="5684"><span class="lineNum">    5684 </span>            :   // Some type IR nodes are difficult to save as a string and reuse. So for now we will skip supporting</a>
<a name="5685"><span class="lineNum">    5685 </span>            :   // some type IR nodes with generated name qualification specific to where they are used.</a>
<a name="5686"><span class="lineNum">    5686 </span><span class="lineCov">    1531140 :      bool skipThisType = false;</span></a>
<a name="5687"><span class="lineNum">    5687 </span><span class="lineCov">    1531140 :      if (isSgPointerMemberType(type) != NULL)</span></a>
<a name="5688"><span class="lineNum">    5688 </span>            :         {</a>
<a name="5689"><span class="lineNum">    5689 </span>            :        // DQ (3/29/2019): We would like to no longer skip this type.</a>
<a name="5690"><span class="lineNum">    5690 </span>            :        // skipThisType = true;</a>
<a name="5691"><span class="lineNum">    5691 </span>            :         }</a>
<a name="5692"><span class="lineNum">    5692 </span>            : </a>
<a name="5693"><span class="lineNum">    5693 </span>            :   // DQ (4/20/2019): We should have a SgType member function for this (which would be more complete).</a>
<a name="5694"><span class="lineNum">    5694 </span>            :   // bool isPrimativeType = (isSgTypeInt(type) != NULL) || (isSgTypeLong(type) != NULL) || (isSgTypeVoid(type) != NULL);</a>
<a name="5695"><span class="lineNum">    5695 </span><span class="lineCov">    1531140 :      bool isPrimativeType = type-&gt;isPrimativeType();</span></a>
<a name="5696"><span class="lineNum">    5696 </span><span class="lineCov">    1531140 :      bool isFunctionType = (isSgFunctionType(type) != NULL);</span></a>
<a name="5697"><span class="lineNum">    5697 </span>            : </a>
<a name="5698"><span class="lineNum">    5698 </span>            : #if 0</a>
<a name="5699"><span class="lineNum">    5699 </span>            :   // DQ (4/27/2019): Trying to trigger name qualificaiton (see test2019_102.C).</a>
<a name="5700"><span class="lineNum">    5700 </span>            :      if (constructorInitializer != NULL)</a>
<a name="5701"><span class="lineNum">    5701 </span>            :         {</a>
<a name="5702"><span class="lineNum">    5702 </span>            :           isFunctionType = false;</a>
<a name="5703"><span class="lineNum">    5703 </span>            :         }</a>
<a name="5704"><span class="lineNum">    5704 </span>            : #endif</a>
<a name="5705"><span class="lineNum">    5705 </span>            : </a>
<a name="5706"><span class="lineNum">    5706 </span>            :   // DQ (4/27/2019): Added support for member functions to handle test2019_102.C test code.</a>
<a name="5707"><span class="lineNum">    5707 </span>            :   // bool isMemberFunctionType = (isSgMemberFunctionType(type) != NULL);</a>
<a name="5708"><span class="lineNum">    5708 </span>            : </a>
<a name="5709"><span class="lineNum">    5709 </span>            :   // bool isEnumType = (isSgEnumType(type) != NULL);</a>
<a name="5710"><span class="lineNum">    5710 </span>            :   // bool isEnumType = false;</a>
<a name="5711"><span class="lineNum">    5711 </span>            : </a>
<a name="5712"><span class="lineNum">    5712 </span>            :   // if (isPrimativeType == true)</a>
<a name="5713"><span class="lineNum">    5713 </span>            :   // if (isPrimativeType == true || isFunctionType == true)</a>
<a name="5714"><span class="lineNum">    5714 </span>            :   // if (isPrimativeType == true || isFunctionType == true || isEnumType == true)</a>
<a name="5715"><span class="lineNum">    5715 </span>            :   // if (isPrimativeType == true || isFunctionType == true || isMemberFunctionType == true)</a>
<a name="5716"><span class="lineNum">    5716 </span><span class="lineCov">    1531140 :      if (isPrimativeType == true || isFunctionType == true)</span></a>
<a name="5717"><span class="lineNum">    5717 </span>            :         {</a>
<a name="5718"><span class="lineNum">    5718 </span>            :        // DQ (3/29/2019): We should skip this type because they are never name qualified.</a>
<a name="5719"><span class="lineNum">    5719 </span><span class="lineCov">      84823 :           skipThisType = true;</span></a>
<a name="5720"><span class="lineNum">    5720 </span>            :         }</a>
<a name="5721"><span class="lineNum">    5721 </span>            : </a>
<a name="5722"><span class="lineNum">    5722 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="5723"><span class="lineNum">    5723 </span>            :      mfprintf(mlog [ WARN ] )(&quot;In NameQualificationTraversal::traverseType:\n&quot;);</a>
<a name="5724"><span class="lineNum">    5724 </span>            :      mfprintf(mlog [ WARN ] )(&quot; -- type = %p (%s) : %s\n&quot;, type, type-&gt;class_name().c_str(), type-&gt;unparseToString().c_str());</a>
<a name="5725"><span class="lineNum">    5725 </span>            : #endif</a>
<a name="5726"><span class="lineNum">    5726 </span>            : </a>
<a name="5727"><span class="lineNum">    5727 </span>            :   // DQ (5/17/2019): Adding support to only handle class types that are from template instantiations (since they can contains types that require name qualificaiton).</a>
<a name="5728"><span class="lineNum">    5728 </span>            :   // bool isTemplateInstantiationType = false;</a>
<a name="5729"><span class="lineNum">    5729 </span><span class="lineCov">    1531140 :      SgClassType* classType = isSgClassType(type);</span></a>
<a name="5730"><span class="lineNum">    5730 </span><span class="lineCov">    1531140 :      if (classType != NULL)</span></a>
<a name="5731"><span class="lineNum">    5731 </span>            :         {</a>
<a name="5732"><span class="lineNum">    5732 </span><span class="lineCov">       8785 :           SgDeclarationStatement* classDeclaration = classType-&gt;get_declaration();</span></a>
<a name="5733"><span class="lineNum">    5733 </span>            : </a>
<a name="5734"><span class="lineNum">    5734 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="5735"><span class="lineNum">    5735 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::traverseType: classDeclaration = %p = %s \n&quot;,classDeclaration,classDeclaration-&gt;class_name().c_str());</a>
<a name="5736"><span class="lineNum">    5736 </span>            : #endif</a>
<a name="5737"><span class="lineNum">    5737 </span><span class="lineCov">       8785 :           SgTemplateInstantiationDecl* templateInstantiationDecl = isSgTemplateInstantiationDecl(classDeclaration);</span></a>
<a name="5738"><span class="lineNum">    5738 </span><span class="lineCov">       8785 :           if (templateInstantiationDecl == NULL)</span></a>
<a name="5739"><span class="lineNum">    5739 </span>            :              {</a>
<a name="5740"><span class="lineNum">    5740 </span>            :             // isTemplateInstantiationType = true;</a>
<a name="5741"><span class="lineNum">    5741 </span>            :                skipThisType = true;</a>
<a name="5742"><span class="lineNum">    5742 </span>            :              }</a>
<a name="5743"><span class="lineNum">    5743 </span>            : #if 0</a>
<a name="5744"><span class="lineNum">    5744 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="5745"><span class="lineNum">    5745 </span>            :           ROSE_ABORT();</a>
<a name="5746"><span class="lineNum">    5746 </span>            : #endif</a>
<a name="5747"><span class="lineNum">    5747 </span>            :         }</a>
<a name="5748"><span class="lineNum">    5748 </span>            : </a>
<a name="5749"><span class="lineNum">    5749 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="5750"><span class="lineNum">    5750 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::traverseType: skipThisType = %s \n&quot;,skipThisType ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="5751"><span class="lineNum">    5751 </span>            : #endif</a>
<a name="5752"><span class="lineNum">    5752 </span>            : </a>
<a name="5753"><span class="lineNum">    5753 </span><span class="lineCov">    1526010 :      if (skipThisType == false)</span></a>
<a name="5754"><span class="lineNum">    5754 </span>            :         {</a>
<a name="5755"><span class="lineNum">    5755 </span><span class="lineCov">    1441190 :           SgDeclarationStatement* declaration = associatedDeclaration(type);</span></a>
<a name="5756"><span class="lineNum">    5756 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="5757"><span class="lineNum">    5757 </span>            :           mfprintf(mlog [ WARN ] )(&quot; -- declaration = %p (%s)\n&quot;, declaration, declaration ? declaration-&gt;class_name().c_str() : &quot;&quot;);</a>
<a name="5758"><span class="lineNum">    5758 </span>            : #endif</a>
<a name="5759"><span class="lineNum">    5759 </span><span class="lineCov">    1441190 :           if (declaration != NULL)</span></a>
<a name="5760"><span class="lineNum">    5760 </span>            :              {</a>
<a name="5761"><span class="lineNum">    5761 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="5762"><span class="lineNum">    5762 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::traverseType(): Calling evaluateTemplateInstantiationDeclaration(): declaration = %p = %s currentScope = %p = %s positionStatement = %p = %s \n&quot;,</a>
<a name="5763"><span class="lineNum">    5763 </span>            :                     declaration,declaration-&gt;class_name().c_str(),currentScope,currentScope-&gt;class_name().c_str(),positionStatement,positionStatement-&gt;class_name().c_str());</a>
<a name="5764"><span class="lineNum">    5764 </span>            : #endif</a>
<a name="5765"><span class="lineNum">    5765 </span><span class="lineCov">    1434720 :                evaluateTemplateInstantiationDeclaration(declaration,currentScope,positionStatement);</span></a>
<a name="5766"><span class="lineNum">    5766 </span>            :              }</a>
<a name="5767"><span class="lineNum">    5767 </span>            : </a>
<a name="5768"><span class="lineNum">    5768 </span><span class="lineCov">    1441190 :           SgUnparse_Info* unparseInfoPointer = new SgUnparse_Info();</span></a>
<a name="5769"><span class="lineNum">    5769 </span><span class="lineCov">    1441190 :           ASSERT_not_null(unparseInfoPointer);</span></a>
<a name="5770"><span class="lineNum">    5770 </span><span class="lineCov">    1441190 :           unparseInfoPointer-&gt;set_outputCompilerGeneratedStatements();</span></a>
<a name="5771"><span class="lineNum">    5771 </span>            : </a>
<a name="5772"><span class="lineNum">    5772 </span>            :        // Avoid unpasing the class definition when unparseing the type.</a>
<a name="5773"><span class="lineNum">    5773 </span><span class="lineCov">    1441190 :           unparseInfoPointer-&gt;set_SkipClassDefinition();</span></a>
<a name="5774"><span class="lineNum">    5774 </span>            : </a>
<a name="5775"><span class="lineNum">    5775 </span>            :        // DQ (5/8/2013): Added specification to skip enum definitions also (see test2012_202.C).</a>
<a name="5776"><span class="lineNum">    5776 </span><span class="lineCov">    1441190 :           unparseInfoPointer-&gt;set_SkipEnumDefinition();</span></a>
<a name="5777"><span class="lineNum">    5777 </span>            : </a>
<a name="5778"><span class="lineNum">    5778 </span>            :        // Associate the unparsing of this type with the statement or scope where it occures.</a>
<a name="5779"><span class="lineNum">    5779 </span>            :        // This is the key to use in the lookup of the qualified name. But this is the correct key....</a>
<a name="5780"><span class="lineNum">    5780 </span>            :        // unparseInfoPointer-&gt;set_reference_node_for_qualification(positionStatement);</a>
<a name="5781"><span class="lineNum">    5781 </span>            :        // unparseInfoPointer-&gt;set_reference_node_for_qualification(currentScope);</a>
<a name="5782"><span class="lineNum">    5782 </span><span class="lineCov">    1441190 :           unparseInfoPointer-&gt;set_reference_node_for_qualification(nodeReferenceToType);</span></a>
<a name="5783"><span class="lineNum">    5783 </span>            : </a>
<a name="5784"><span class="lineNum">    5784 </span>            :        // DQ (5/7/2013): A problem with this is that it combines the first and second parts of the</a>
<a name="5785"><span class="lineNum">    5785 </span>            :        // type into a single string (e.g. the array type will include two parts &quot;base_type&quot; &lt;array name&gt; &quot;[index]&quot;.</a>
<a name="5786"><span class="lineNum">    5786 </span>            :        // When this is combined for types that have two parts (most types don't) the result is an error</a>
<a name="5787"><span class="lineNum">    5787 </span>            :        // when the type is unparsed.  It is not clear, but a solution might be for this to be built here</a>
<a name="5788"><span class="lineNum">    5788 </span>            :        // as just the 1st part, and let the second part be generated when the array type is unparsed.</a>
<a name="5789"><span class="lineNum">    5789 </span>            :        // BTW, the reason why it is computed here is that there may be many nested types that require</a>
<a name="5790"><span class="lineNum">    5790 </span>            :        // name qualifications and so it is required that we save the whole string.  However, name</a>
<a name="5791"><span class="lineNum">    5791 </span>            :        // qualification might only apply to the first part of types.  So we need to investigate this.</a>
<a name="5792"><span class="lineNum">    5792 </span>            :        // This is a problem demonstrated in test2013_156.C and test2013_158.C.</a>
<a name="5793"><span class="lineNum">    5793 </span>            : </a>
<a name="5794"><span class="lineNum">    5794 </span>            :        // DQ (5/8/2013): Set the SgUnparse_Info so that only the first part will be unparsed.</a>
<a name="5795"><span class="lineNum">    5795 </span><span class="lineCov">    1441190 :           unparseInfoPointer-&gt;set_isTypeFirstPart();</span></a>
<a name="5796"><span class="lineNum">    5796 </span>            : #if 0</a>
<a name="5797"><span class="lineNum">    5797 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::traverseType(): Comment out out the setting of SkipClassSpecifier \n&quot;);</a>
<a name="5798"><span class="lineNum">    5798 </span>            : #endif</a>
<a name="5799"><span class="lineNum">    5799 </span>            :        // DQ (4/27/2019): Comment out out the setting of SkipClassSpecifier.  If this is commented out then</a>
<a name="5800"><span class="lineNum">    5800 </span>            :        // we pass a lot more (about 19 more) of the test codes in the Cxx_test directory, else we only fail</a>
<a name="5801"><span class="lineNum">    5801 </span>            :        // 7 test codes.  However, we fail a number of the tests in the Cxx11_tests directory.</a>
<a name="5802"><span class="lineNum">    5802 </span>            :        // Not clear how to proceed here.</a>
<a name="5803"><span class="lineNum">    5803 </span>            : </a>
<a name="5804"><span class="lineNum">    5804 </span>            : #if 0</a>
<a name="5805"><span class="lineNum">    5805 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="5806"><span class="lineNum">    5806 </span>            :           ROSE_ABORT();</a>
<a name="5807"><span class="lineNum">    5807 </span>            : #endif</a>
<a name="5808"><span class="lineNum">    5808 </span>            : </a>
<a name="5809"><span class="lineNum">    5809 </span>            :        // DQ (5/14/2019): We can sometimes need this class specifier to be output (e.g. test2019_430.C) (testing).</a>
<a name="5810"><span class="lineNum">    5810 </span>            :        // DQ (8/19/2013): Added specification to skip class specifier (fixes problem with test2013_306.C).</a>
<a name="5811"><span class="lineNum">    5811 </span>            :        // unparseInfoPointer-&gt;set_SkipClassSpecifier();</a>
<a name="5812"><span class="lineNum">    5812 </span>            : #if 0</a>
<a name="5813"><span class="lineNum">    5813 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::traverseType(): Comment out the setting of SkipClassSpecifier() \n&quot;);</a>
<a name="5814"><span class="lineNum">    5814 </span>            : #endif</a>
<a name="5815"><span class="lineNum">    5815 </span>            :        // DQ (4/22/2019): Make this as being from a parameter list (types are unparse with extra parenthesis).</a>
<a name="5816"><span class="lineNum">    5816 </span><span class="lineCov">    1441190 :           if (inArgList == true)</span></a>
<a name="5817"><span class="lineNum">    5817 </span>            :              {</a>
<a name="5818"><span class="lineNum">    5818 </span><span class="lineCov">    1196020 :                unparseInfoPointer-&gt;set_inArgList();</span></a>
<a name="5819"><span class="lineNum">    5819 </span>            : </a>
<a name="5820"><span class="lineNum">    5820 </span>            :             // DQ (5/19/2019): when in the function argument list, don't output the class specifier.</a>
<a name="5821"><span class="lineNum">    5821 </span>            :             // unparseInfoPointer-&gt;set_SkipClassSpecifier();</a>
<a name="5822"><span class="lineNum">    5822 </span>            :              }</a>
<a name="5823"><span class="lineNum">    5823 </span>            : </a>
<a name="5824"><span class="lineNum">    5824 </span>            :        // DQ (4/28/2019): Need to detect when this is part of a base type from a typedef declaration.</a>
<a name="5825"><span class="lineNum">    5825 </span><span class="lineCov">    1441190 :           if (inTypedefDecl == true)</span></a>
<a name="5826"><span class="lineNum">    5826 </span>            :              {</a>
<a name="5827"><span class="lineNum">    5827 </span><span class="lineCov">      12926 :                unparseInfoPointer-&gt;set_inTypedefDecl();</span></a>
<a name="5828"><span class="lineNum">    5828 </span>            :              }</a>
<a name="5829"><span class="lineNum">    5829 </span>            : </a>
<a name="5830"><span class="lineNum">    5830 </span>            :        // DQ (5/18/2019): Makr this as being in a SgAggregateInitializer.</a>
<a name="5831"><span class="lineNum">    5831 </span><span class="lineCov">    1441190 :           bool exit_in_processing_aggregateInitializer = false;</span></a>
<a name="5832"><span class="lineNum">    5832 </span><span class="lineCov">    1441190 :           SgAggregateInitializer* aggregateInitializer = isSgAggregateInitializer(nodeReferenceToType);</span></a>
<a name="5833"><span class="lineNum">    5833 </span><span class="lineCov">    1441190 :           if (aggregateInitializer != NULL)</span></a>
<a name="5834"><span class="lineNum">    5834 </span>            :              {</a>
<a name="5835"><span class="lineNum">    5835 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || DEBUG_TRAVERSE_TYPE</a>
<a name="5836"><span class="lineNum">    5836 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;++++++++++++++++ explicitly setting unparseInfoPointer-&gt;set_inAggregateInitializer() \n&quot;);</a>
<a name="5837"><span class="lineNum">    5837 </span>            : #endif</a>
<a name="5838"><span class="lineNum">    5838 </span><span class="lineNoCov">          0 :                exit_in_processing_aggregateInitializer = true;</span></a>
<a name="5839"><span class="lineNum">    5839 </span><span class="lineNoCov">          0 :                unparseInfoPointer-&gt;set_inAggregateInitializer();</span></a>
<a name="5840"><span class="lineNum">    5840 </span>            : </a>
<a name="5841"><span class="lineNum">    5841 </span>            :             // DQ (5/18/2019): when in the SgAggregateInitializer, don't output the class specifier.</a>
<a name="5842"><span class="lineNum">    5842 </span><span class="lineNoCov">          0 :                unparseInfoPointer-&gt;set_SkipClassSpecifier();</span></a>
<a name="5843"><span class="lineNum">    5843 </span>            :              }</a>
<a name="5844"><span class="lineNum">    5844 </span>            : </a>
<a name="5845"><span class="lineNum">    5845 </span><span class="lineCov">    1441190 :           SgConstructorInitializer* constructorInitializer = isSgConstructorInitializer(nodeReferenceToType);</span></a>
<a name="5846"><span class="lineNum">    5846 </span><span class="lineCov">    1441190 :           if (constructorInitializer != NULL)</span></a>
<a name="5847"><span class="lineNum">    5847 </span>            :              {</a>
<a name="5848"><span class="lineNum">    5848 </span>            :             // DQ (5/19/2019): when in the function argument list, don't output the class specifier.</a>
<a name="5849"><span class="lineNum">    5849 </span><span class="lineCov">       3020 :                unparseInfoPointer-&gt;set_SkipClassSpecifier();</span></a>
<a name="5850"><span class="lineNum">    5850 </span>            : #if 0</a>
<a name="5851"><span class="lineNum">    5851 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="5852"><span class="lineNum">    5852 </span>            :                ROSE_ABORT();</a>
<a name="5853"><span class="lineNum">    5853 </span>            : #endif</a>
<a name="5854"><span class="lineNum">    5854 </span>            :              }</a>
<a name="5855"><span class="lineNum">    5855 </span>            : </a>
<a name="5856"><span class="lineNum">    5856 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || DEBUG_TRAVERSE_TYPE</a>
<a name="5857"><span class="lineNum">    5857 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;++++++++++++++++ Calling globalUnparseToString(): type = %p = %s \n&quot;,type,type-&gt;class_name().c_str());</a>
<a name="5858"><span class="lineNum">    5858 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;++++++++++++++++ unparseInfoPointer-&gt;inAggregateInitializer() = %s \n&quot;,unparseInfoPointer-&gt;inAggregateInitializer() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="5859"><span class="lineNum">    5859 </span>            : #endif</a>
<a name="5860"><span class="lineNum">    5860 </span>            : </a>
<a name="5861"><span class="lineNum">    5861 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || DEBUG_TRAVERSE_TYPE</a>
<a name="5862"><span class="lineNum">    5862 </span>            :        // DQ (5/18/2019): Adding debugging info.</a>
<a name="5863"><span class="lineNum">    5863 </span>            :        // unparseInfoPointer-&gt;display(&quot;In NameQualificationTraversal::traverseType(): unparseInfoPointer \n&quot;);</a>
<a name="5864"><span class="lineNum">    5864 </span>            : #endif</a>
<a name="5865"><span class="lineNum">    5865 </span>            : </a>
<a name="5866"><span class="lineNum">    5866 </span><span class="lineCov">    2882380 :           string typeNameString = globalUnparseToString(type,unparseInfoPointer);</span></a>
<a name="5867"><span class="lineNum">    5867 </span>            : </a>
<a name="5868"><span class="lineNum">    5868 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || DEBUG_TRAVERSE_TYPE || 0</a>
<a name="5869"><span class="lineNum">    5869 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;++++++++++++++++ typeNameString (globalUnparseToString()) = %s \n&quot;,typeNameString.c_str());</a>
<a name="5870"><span class="lineNum">    5870 </span>            : #endif</a>
<a name="5871"><span class="lineNum">    5871 </span>            : </a>
<a name="5872"><span class="lineNum">    5872 </span>            :        // DQ (5/18/2019): Testing...</a>
<a name="5873"><span class="lineNum">    5873 </span>            :        // ROSE_ASSERT(exit_in_processing_aggregateInitializer == false);</a>
<a name="5874"><span class="lineNum">    5874 </span><span class="lineCov">    1441190 :           if (exit_in_processing_aggregateInitializer != false)</span></a>
<a name="5875"><span class="lineNum">    5875 </span>            :              {</a>
<a name="5876"><span class="lineNum">    5876 </span>            : #if 0</a>
<a name="5877"><span class="lineNum">    5877 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;############################################### \n&quot;);</a>
<a name="5878"><span class="lineNum">    5878 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;exit_in_processing_aggregateInitializer == true \n&quot;);</a>
<a name="5879"><span class="lineNum">    5879 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;############################################### \n&quot;);</a>
<a name="5880"><span class="lineNum">    5880 </span>            : #endif</a>
<a name="5881"><span class="lineNum">    5881 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || DEBUG_TRAVERSE_TYPE</a>
<a name="5882"><span class="lineNum">    5882 </span>            :             // DQ (5/18/2019): Adding debugging info.</a>
<a name="5883"><span class="lineNum">    5883 </span>            :                unparseInfoPointer-&gt;display(&quot;In NameQualificationTraversal::traverseType(): exit_in_processing_aggregateInitializer == true: unparseInfoPointer \n&quot;);</a>
<a name="5884"><span class="lineNum">    5884 </span>            : #endif</a>
<a name="5885"><span class="lineNum">    5885 </span>            :              }</a>
<a name="5886"><span class="lineNum">    5886 </span>            : </a>
<a name="5887"><span class="lineNum">    5887 </span>            :        // DQ (7/13/2011): OSX can have types that are about 2487 characters long (see test2004_35.C).</a>
<a name="5888"><span class="lineNum">    5888 </span>            :        // This is symptematic of an error which causes the whole class to be included with the class</a>
<a name="5889"><span class="lineNum">    5889 </span>            :        // definition.  This was fixed by calling unparseInfoPointer-&gt;set_SkipClassDefinition() above.</a>
<a name="5890"><span class="lineNum">    5890 </span>            :        // if (typeNameString.length() &gt; 6000)</a>
<a name="5891"><span class="lineNum">    5891 </span>            :        // if (typeNameString.length() &gt; 600)</a>
<a name="5892"><span class="lineNum">    5892 </span><span class="lineCov">    1441190 :           if (typeNameString.length() &gt; 6000)</span></a>
<a name="5893"><span class="lineNum">    5893 </span>            :              {</a>
<a name="5894"><span class="lineNum">    5894 </span><span class="lineNoCov">          0 :                if (SgProject::get_verbose() &gt; 0)</span></a>
<a name="5895"><span class="lineNum">    5895 </span>            :                   {</a>
<a name="5896"><span class="lineNum">    5896 </span><span class="lineNoCov">          0 :                     mfprintf(mlog [ WARN ] ) (&quot;Warning: type names should not be this long...(unless this is boost) typeNameString.length() = %&quot; PRIuPTR &quot; \n&quot;,typeNameString.length());</span></a>
<a name="5897"><span class="lineNum">    5897 </span>            :                   }</a>
<a name="5898"><span class="lineNum">    5898 </span>            : #if 0</a>
<a name="5899"><span class="lineNum">    5899 </span>            :             // DQ (6/30/2013): Allow the output of an example so that we can verify that this make</a>
<a name="5900"><span class="lineNum">    5900 </span>            :             // sense (and that it is not a result of some comment output from the unparsing of types).</a>
<a name="5901"><span class="lineNum">    5901 </span>            :                static bool outputOneExample = true;</a>
<a name="5902"><span class="lineNum">    5902 </span>            :                if (outputOneExample == true)</a>
<a name="5903"><span class="lineNum">    5903 </span>            :                   {</a>
<a name="5904"><span class="lineNum">    5904 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;   --- example typeNameString = %s \n&quot;,typeNameString.c_str());</a>
<a name="5905"><span class="lineNum">    5905 </span>            :                     outputOneExample = false;</a>
<a name="5906"><span class="lineNum">    5906 </span>            : #if 0</a>
<a name="5907"><span class="lineNum">    5907 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="5908"><span class="lineNum">    5908 </span>            :                     ROSE_ABORT();</a>
<a name="5909"><span class="lineNum">    5909 </span>            : #endif</a>
<a name="5910"><span class="lineNum">    5910 </span>            :                   }</a>
<a name="5911"><span class="lineNum">    5911 </span>            : #endif</a>
<a name="5912"><span class="lineNum">    5912 </span>            : </a>
<a name="5913"><span class="lineNum">    5913 </span>            :             // DQ (10/11/2015): Increased max size of typename handled in ROSE (a 42K charater long</a>
<a name="5914"><span class="lineNum">    5914 </span>            :             // typename was generated by test2015_87.C), so we will allow this.</a>
<a name="5915"><span class="lineNum">    5915 </span>            :             // DQ (1/30/2013): Increased already too long limit for string lengths for typenames.  This</a>
<a name="5916"><span class="lineNum">    5916 </span>            :             // test fails for ROSE compiling ROSE with a type name that is 17807 characters long.  I have</a>
<a name="5917"><span class="lineNum">    5917 </span>            :             // increased the max allowable typename lengtt to over twice that for good measure.</a>
<a name="5918"><span class="lineNum">    5918 </span>            :             // DQ (7/22/2011): The a992-thrifty-mips-compiler Hudson test fails because it generates a</a>
<a name="5919"><span class="lineNum">    5919 </span>            :             // typename that is even longer 5149, so we need an even larger upper bound.  This should be</a>
<a name="5920"><span class="lineNum">    5920 </span>            :             // looked into later to see why some of these different platforms are generating such large</a>
<a name="5921"><span class="lineNum">    5921 </span>            :             // typenames. See testcode: tests/nonsmoke/functional/CompileTests/PythonExample_tests/test2004_92.C (on thrifty).</a>
<a name="5922"><span class="lineNum">    5922 </span>            :             // if (typeNameString.length() &gt; 10000)</a>
<a name="5923"><span class="lineNum">    5923 </span>            :             // if (typeNameString.length() &gt; 40000)</a>
<a name="5924"><span class="lineNum">    5924 </span>            :             // if (typeNameString.length() &gt; 400000)</a>
<a name="5925"><span class="lineNum">    5925 </span>            :             // if (typeNameString.length() &gt; 400)</a>
<a name="5926"><span class="lineNum">    5926 </span><span class="lineNoCov">          0 :                if (typeNameString.length() &gt; 400000)</span></a>
<a name="5927"><span class="lineNum">    5927 </span>            :                   {</a>
<a name="5928"><span class="lineNum">    5928 </span>            :                  // If your ever curious, you can output the type name.</a>
<a name="5929"><span class="lineNum">    5929 </span>            :                  // mfprintf(mlog [ WARN ] ) (&quot;Error: typeNameString = %s \n&quot;,typeNameString.c_str());</a>
<a name="5930"><span class="lineNum">    5930 </span>            : #if 1</a>
<a name="5931"><span class="lineNum">    5931 </span>            :                  // DQ (2/7/2017): Output offending type name string to a file for inspection.</a>
<a name="5932"><span class="lineNum">    5932 </span><span class="lineNoCov">          0 :                     ASSERT_not_null(positionStatement);</span></a>
<a name="5933"><span class="lineNum">    5933 </span><span class="lineNoCov">          0 :                     positionStatement-&gt;get_file_info()-&gt;display(&quot;Output offending type name string to a file for inspection: debug&quot;);</span></a>
<a name="5934"><span class="lineNum">    5934 </span>            : </a>
<a name="5935"><span class="lineNum">    5935 </span><span class="lineNoCov">          0 :                     SgFile* problemFile = TransformationSupport::getFile(positionStatement);</span></a>
<a name="5936"><span class="lineNum">    5936 </span><span class="lineNoCov">          0 :                     string filename = problemFile-&gt;getFileName();</span></a>
<a name="5937"><span class="lineNum">    5937 </span><span class="lineNoCov">          0 :                     filename += &quot;.typename&quot;;</span></a>
<a name="5938"><span class="lineNum">    5938 </span>            : </a>
<a name="5939"><span class="lineNum">    5939 </span><span class="lineNoCov">          0 :                     mfprintf(mlog [ WARN ] ) (&quot;Generating a file (%s) to hold the typename \n&quot;,filename.c_str());</span></a>
<a name="5940"><span class="lineNum">    5940 </span>            : </a>
<a name="5941"><span class="lineNum">    5941 </span><span class="lineNoCov">          0 :                     std::ofstream output_file(filename.c_str());</span></a>
<a name="5942"><span class="lineNum">    5942 </span>            :                  // std::ofstream output_file(filename);</a>
<a name="5943"><span class="lineNum">    5943 </span><span class="lineNoCov">          0 :                     output_file &lt;&lt; typeNameString;</span></a>
<a name="5944"><span class="lineNum">    5944 </span><span class="lineNoCov">          0 :                     output_file.close();</span></a>
<a name="5945"><span class="lineNum">    5945 </span>            : #endif</a>
<a name="5946"><span class="lineNum">    5946 </span><span class="lineNoCov">          0 :                     mfprintf(mlog [ WARN ] ) (&quot;Error: type names should not be this long... (even in boost, I think) typeNameString.length() = %&quot; PRIuPTR &quot; \n&quot;,typeNameString.length());</span></a>
<a name="5947"><span class="lineNum">    5947 </span><span class="lineNoCov">          0 :                     mfprintf(mlog [ WARN ] ) (&quot;nodeReferenceToType = %p = %s \n&quot;,nodeReferenceToType,nodeReferenceToType-&gt;class_name().c_str());</span></a>
<a name="5948"><span class="lineNum">    5948 </span><span class="lineNoCov">          0 :                     if (nodeReferenceToType-&gt;get_file_info())</span></a>
<a name="5949"><span class="lineNum">    5949 </span>            :                        {</a>
<a name="5950"><span class="lineNum">    5950 </span><span class="lineNoCov">          0 :                          nodeReferenceToType-&gt;get_file_info()-&gt;display(&quot;Error: type names should not be this long...: debug&quot;);</span></a>
<a name="5951"><span class="lineNum">    5951 </span>            :                        }</a>
<a name="5952"><span class="lineNum">    5952 </span><span class="lineNoCov">          0 :                     ROSE_ABORT();</span></a>
<a name="5953"><span class="lineNum">    5953 </span>            :                   }</a>
<a name="5954"><span class="lineNum">    5954 </span>            : #if 0</a>
<a name="5955"><span class="lineNum">    5955 </span>            :             // DQ (2/18/2013): I think that the output if such long strings in a problem for the Jenkins tests,</a>
<a name="5956"><span class="lineNum">    5956 </span>            :             // outside of Jenkins this branch executes fine.  This branch is executed only for ROSE compiling</a>
<a name="5957"><span class="lineNum">    5957 </span>            :             // ROSE (so far) and is executed for the typename generated from the enum in Cxx_Grammar.h which</a>
<a name="5958"><span class="lineNum">    5958 </span>            :             // is converted to a unique typename (and the string function for this contatinates all of the names</a>
<a name="5959"><span class="lineNum">    5959 </span>            :             // of the 700+ enum fields to generate the typename, hence a long name exceeding 10K characters).</a>
<a name="5960"><span class="lineNum">    5960 </span>            :             // ROSE compiling the ROSE Cxx_Grammar.h file is not a problem outside of Jenkins so I suspect that</a>
<a name="5961"><span class="lineNum">    5961 </span>            :             // Jenkins is having problems with the processing of long strings generated as part of the tests.</a>
<a name="5962"><span class="lineNum">    5962 </span>            : </a>
<a name="5963"><span class="lineNum">    5963 </span>            :             // DQ (1/30/2013): Print out the long name that previously violated our initial limits.</a>
<a name="5964"><span class="lineNum">    5964 </span>            :                if (typeNameString.length() &gt; 10000)</a>
<a name="5965"><span class="lineNum">    5965 </span>            :                   {</a>
<a name="5966"><span class="lineNum">    5966 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;WARNING: extremely long type name found: typeNameString.length() = %&quot; PRIuPTR &quot; \n&quot;,typeNameString.length());</a>
<a name="5967"><span class="lineNum">    5967 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;typeNameString = %s \n&quot;,typeNameString.c_str());</a>
<a name="5968"><span class="lineNum">    5968 </span>            :                   }</a>
<a name="5969"><span class="lineNum">    5969 </span>            : #endif</a>
<a name="5970"><span class="lineNum">    5970 </span>            :              }</a>
<a name="5971"><span class="lineNum">    5971 </span>            : </a>
<a name="5972"><span class="lineNum">    5972 </span>            : #if 0</a>
<a name="5973"><span class="lineNum">    5973 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::traverseType(): addToNameMap(): nodeReferenceToType = %p = %s typeNameString = %s \n&quot;,</a>
<a name="5974"><span class="lineNum">    5974 </span>            :                nodeReferenceToType,nodeReferenceToType-&gt;class_name().c_str(),typeNameString.c_str());</a>
<a name="5975"><span class="lineNum">    5975 </span>            : #endif</a>
<a name="5976"><span class="lineNum">    5976 </span>            : </a>
<a name="5977"><span class="lineNum">    5977 </span>            :        // DQ (6/21/2011): Refactored this code for use in traverseTemplatedFunction()</a>
<a name="5978"><span class="lineNum">    5978 </span><span class="lineCov">    2882380 :           addToNameMap(nodeReferenceToType,typeNameString);</span></a>
<a name="5979"><span class="lineNum">    5979 </span>            : </a>
<a name="5980"><span class="lineNum">    5980 </span>            :        // DQ (2/18/2013): Fixing generation of too many SgUnparse_Info object.</a>
<a name="5981"><span class="lineNum">    5981 </span><span class="lineCov">    1441190 :           delete unparseInfoPointer;</span></a>
<a name="5982"><span class="lineNum">    5982 </span>            : </a>
<a name="5983"><span class="lineNum">    5983 </span>            : #if 0</a>
<a name="5984"><span class="lineNum">    5984 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="5985"><span class="lineNum">    5985 </span>            :           ROSE_ABORT();</a>
<a name="5986"><span class="lineNum">    5986 </span>            : #endif</a>
<a name="5987"><span class="lineNum">    5987 </span>            :         }</a>
<a name="5988"><span class="lineNum">    5988 </span>            :        else</a>
<a name="5989"><span class="lineNum">    5989 </span>            :         {</a>
<a name="5990"><span class="lineNum">    5990 </span>            :        // Output a message when we cheat on this IR node (even if this is a clue for George).</a>
<a name="5991"><span class="lineNum">    5991 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 0) || 0</a>
<a name="5992"><span class="lineNum">    5992 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Skipping precompuation of string for name qualified type = %p = %s \n&quot;,type,type-&gt;class_name().c_str());</a>
<a name="5993"><span class="lineNum">    5993 </span>            : #endif</a>
<a name="5994"><span class="lineNum">    5994 </span>            : #if 0</a>
<a name="5995"><span class="lineNum">    5995 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="5996"><span class="lineNum">    5996 </span>            :           ROSE_ABORT();</a>
<a name="5997"><span class="lineNum">    5997 </span>            : #endif</a>
<a name="5998"><span class="lineNum">    5998 </span>            :         }</a>
<a name="5999"><span class="lineNum">    5999 </span>            : </a>
<a name="6000"><span class="lineNum">    6000 </span>            : </a>
<a name="6001"><span class="lineNum">    6001 </span>            : #if 0</a>
<a name="6002"><span class="lineNum">    6002 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;################################################################################################# \n&quot;);</a>
<a name="6003"><span class="lineNum">    6003 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::traverseType(): Calling generateNestedTraversalWithExplicitScope() \n&quot;);</a>
<a name="6004"><span class="lineNum">    6004 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;################################################################################################# \n&quot;);</a>
<a name="6005"><span class="lineNum">    6005 </span>            : #endif</a>
<a name="6006"><span class="lineNum">    6006 </span>            : </a>
<a name="6007"><span class="lineNum">    6007 </span>            : #if 0</a>
<a name="6008"><span class="lineNum">    6008 </span>            :   // DQ (4/18/2019): I think we need to traverse the type doing a proper type travesal, since it can consist of</a>
<a name="6009"><span class="lineNum">    6009 </span>            :   // long chains of types that each must be name qualified. The example of a chain of SgPointerToMemberTypes is</a>
<a name="6010"><span class="lineNum">    6010 </span>            :   // the best example of this.</a>
<a name="6011"><span class="lineNum">    6011 </span>            :      ASSERT_not_null(currentScope);</a>
<a name="6012"><span class="lineNum">    6012 </span>            :      generateNestedTraversalWithExplicitScope(type,currentScope);</a>
<a name="6013"><span class="lineNum">    6013 </span>            : #endif</a>
<a name="6014"><span class="lineNum">    6014 </span>            : </a>
<a name="6015"><span class="lineNum">    6015 </span>            : #if 0</a>
<a name="6016"><span class="lineNum">    6016 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;Exitng as a test! \n&quot;);</a>
<a name="6017"><span class="lineNum">    6017 </span>            :      ROSE_ABORT();</a>
<a name="6018"><span class="lineNum">    6018 </span>            : #endif</a>
<a name="6019"><span class="lineNum">    6019 </span>            : </a>
<a name="6020"><span class="lineNum">    6020 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || 0</a>
<a name="6021"><span class="lineNum">    6021 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;&lt;&lt;&lt;&lt;&lt; Ending traversal of type: type = %p = %s \n&quot;,type,type-&gt;class_name().c_str());</a>
<a name="6022"><span class="lineNum">    6022 </span>            : #endif</a>
<a name="6023"><span class="lineNum">    6023 </span>            :    }</a>
<a name="6024"><span class="lineNum">    6024 </span>            : </a>
<a name="6025"><span class="lineNum">    6025 </span>            : </a>
<a name="6026"><span class="lineNum">    6026 </span>            : void</a>
<a name="6027"><span class="lineNum">    6027 </span><span class="lineCov">        973 : NameQualificationTraversal::traverseTemplatedFunction(SgFunctionRefExp* functionRefExp, SgNode* nodeReference, SgScopeStatement* currentScope, SgStatement* positionStatement )</span></a>
<a name="6028"><span class="lineNum">    6028 </span>            :    {</a>
<a name="6029"><span class="lineNum">    6029 </span>            :   // Called using traverseTemplatedFunction(functionRefExp,templateInstantiationFunctionDeclaration,currentScope,currentStatement)</a>
<a name="6030"><span class="lineNum">    6030 </span>            : </a>
<a name="6031"><span class="lineNum">    6031 </span><span class="lineCov">        973 :      ASSERT_not_null(functionRefExp);</span></a>
<a name="6032"><span class="lineNum">    6032 </span><span class="lineCov">        973 :      ASSERT_not_null(nodeReference);</span></a>
<a name="6033"><span class="lineNum">    6033 </span><span class="lineCov">        973 :      ASSERT_not_null(currentScope);</span></a>
<a name="6034"><span class="lineNum">    6034 </span><span class="lineCov">        973 :      ASSERT_not_null(positionStatement);</span></a>
<a name="6035"><span class="lineNum">    6035 </span>            : </a>
<a name="6036"><span class="lineNum">    6036 </span>            :   // mfprintf(mlog [ WARN ] ) (&quot;Inside of traverseTemplatedFunction functionRefExp = %p currentScope = %p = %s \n&quot;,functionRefExp,currentScope,currentScope-&gt;class_name().c_str());</a>
<a name="6037"><span class="lineNum">    6037 </span>            : </a>
<a name="6038"><span class="lineNum">    6038 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || 0</a>
<a name="6039"><span class="lineNum">    6039 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;&lt;&lt;&lt;&lt;&lt; Starting traversal of traverseTemplatedFunction functionRefExp = %p currentScope = %p = %s \n&quot;,functionRefExp,currentScope,currentScope-&gt;class_name().c_str());</a>
<a name="6040"><span class="lineNum">    6040 </span>            : #endif</a>
<a name="6041"><span class="lineNum">    6041 </span>            : </a>
<a name="6042"><span class="lineNum">    6042 </span><span class="lineCov">        973 :      bool skipThisFunction = false;</span></a>
<a name="6043"><span class="lineNum">    6043 </span><span class="lineCov">        973 :      if (skipThisFunction == false)</span></a>
<a name="6044"><span class="lineNum">    6044 </span>            :         {</a>
<a name="6045"><span class="lineNum">    6045 </span><span class="lineCov">        973 :           SgTemplateInstantiationFunctionDecl* templateInstantiationFunctionDeclaration = isSgTemplateInstantiationFunctionDecl(functionRefExp-&gt;getAssociatedFunctionDeclaration());</span></a>
<a name="6046"><span class="lineNum">    6046 </span><span class="lineCov">        973 :           if (templateInstantiationFunctionDeclaration != NULL)</span></a>
<a name="6047"><span class="lineNum">    6047 </span>            :              {</a>
<a name="6048"><span class="lineNum">    6048 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="6049"><span class="lineNum">    6049 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Found a SgTemplateInstantiationFunctionDecl that will have template arguments that might require qualification. name = %s \n&quot;,templateInstantiationFunctionDeclaration-&gt;get_name().str());</a>
<a name="6050"><span class="lineNum">    6050 </span>            : #endif</a>
<a name="6051"><span class="lineNum">    6051 </span><span class="lineCov">        973 :                evaluateTemplateInstantiationDeclaration(templateInstantiationFunctionDeclaration,currentScope,positionStatement);</span></a>
<a name="6052"><span class="lineNum">    6052 </span>            :              }</a>
<a name="6053"><span class="lineNum">    6053 </span>            : </a>
<a name="6054"><span class="lineNum">    6054 </span><span class="lineCov">        973 :           SgUnparse_Info* unparseInfoPointer = new SgUnparse_Info();</span></a>
<a name="6055"><span class="lineNum">    6055 </span><span class="lineCov">        973 :           ASSERT_not_null(unparseInfoPointer);</span></a>
<a name="6056"><span class="lineNum">    6056 </span><span class="lineCov">        973 :           unparseInfoPointer-&gt;set_outputCompilerGeneratedStatements();</span></a>
<a name="6057"><span class="lineNum">    6057 </span>            : </a>
<a name="6058"><span class="lineNum">    6058 </span>            :        // Avoid unpasing the class definition when unparseing the type.</a>
<a name="6059"><span class="lineNum">    6059 </span><span class="lineCov">        973 :           unparseInfoPointer-&gt;set_SkipClassDefinition();</span></a>
<a name="6060"><span class="lineNum">    6060 </span>            : </a>
<a name="6061"><span class="lineNum">    6061 </span>            :        // DQ (1/13/2014): Set the output of the enum defintion to match that of the class definition (consistancy is now inforced).</a>
<a name="6062"><span class="lineNum">    6062 </span><span class="lineCov">        973 :           unparseInfoPointer-&gt;set_SkipEnumDefinition();</span></a>
<a name="6063"><span class="lineNum">    6063 </span>            : </a>
<a name="6064"><span class="lineNum">    6064 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="6065"><span class="lineNum">    6065 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;nodeReference = %p = %s \n&quot;,nodeReference,nodeReference-&gt;class_name().c_str());</a>
<a name="6066"><span class="lineNum">    6066 </span>            : #endif</a>
<a name="6067"><span class="lineNum">    6067 </span>            :        // Associate the unparsing of this type with the statement or scope where it occures.</a>
<a name="6068"><span class="lineNum">    6068 </span>            :        // This is the key to use in the lookup of the qualified name. But this is the correct key....</a>
<a name="6069"><span class="lineNum">    6069 </span>            :        // unparseInfoPointer-&gt;set_reference_node_for_qualification(positionStatement);</a>
<a name="6070"><span class="lineNum">    6070 </span>            :        // unparseInfoPointer-&gt;set_reference_node_for_qualification(currentScope);</a>
<a name="6071"><span class="lineNum">    6071 </span><span class="lineCov">        973 :           unparseInfoPointer-&gt;set_reference_node_for_qualification(nodeReference);</span></a>
<a name="6072"><span class="lineNum">    6072 </span>            : </a>
<a name="6073"><span class="lineNum">    6073 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="6074"><span class="lineNum">    6074 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Calling globalUnparseToString() \n&quot;);</a>
<a name="6075"><span class="lineNum">    6075 </span>            : #endif</a>
<a name="6076"><span class="lineNum">    6076 </span><span class="lineCov">        973 :           string functionNameString = globalUnparseToString(functionRefExp,unparseInfoPointer);</span></a>
<a name="6077"><span class="lineNum">    6077 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="6078"><span class="lineNum">    6078 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;++++++++++++++++ functionNameString (globalUnparseToString()) = %s \n&quot;,functionNameString.c_str());</a>
<a name="6079"><span class="lineNum">    6079 </span>            : #endif</a>
<a name="6080"><span class="lineNum">    6080 </span>            : #if 0</a>
<a name="6081"><span class="lineNum">    6081 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;++++++++++++++++ functionNameString (globalUnparseToString()) = %s \n&quot;,functionNameString.c_str());</a>
<a name="6082"><span class="lineNum">    6082 </span>            : #endif</a>
<a name="6083"><span class="lineNum">    6083 </span>            : </a>
<a name="6084"><span class="lineNum">    6084 </span>            :        // DQ (10/31/2015): Increased the maximum allowable size of function names (because test2015_98.C</a>
<a name="6085"><span class="lineNum">    6085 </span>            :        // demonstrates a longer name (length == 5062)).</a>
<a name="6086"><span class="lineNum">    6086 </span>            :        // DQ (6/24/2013): Increased upper bound to support ROSE compiling ROSE.</a>
<a name="6087"><span class="lineNum">    6087 </span>            :        // This is symptematic of an error which causes the whole class to be included with the class</a>
<a name="6088"><span class="lineNum">    6088 </span>            :        // definition.  This was fixed by calling unparseInfoPointer-&gt;set_SkipClassDefinition() above.</a>
<a name="6089"><span class="lineNum">    6089 </span>            :        // if (functionNameString.length() &gt; 2000)</a>
<a name="6090"><span class="lineNum">    6090 </span>            :        // if (functionNameString.length() &gt; 5000)</a>
<a name="6091"><span class="lineNum">    6091 </span><span class="lineCov">        973 :           if (functionNameString.length() &gt; 10000)</span></a>
<a name="6092"><span class="lineNum">    6092 </span>            :              {</a>
<a name="6093"><span class="lineNum">    6093 </span><span class="lineNoCov">          0 :                mfprintf(mlog [ WARN ] ) (&quot;Error: function names should not be this long... functionNameString.length() = %&quot; PRIuPTR &quot; \n&quot;,functionNameString.length());</span></a>
<a name="6094"><span class="lineNum">    6094 </span>            : #if 1</a>
<a name="6095"><span class="lineNum">    6095 </span><span class="lineNoCov">          0 :                mfprintf(mlog [ WARN ] ) (&quot;Error: function names should not be this long... functionNameString          = \n%s \n&quot;,functionNameString.c_str());</span></a>
<a name="6096"><span class="lineNum">    6096 </span>            : #endif</a>
<a name="6097"><span class="lineNum">    6097 </span>            : #if 0</a>
<a name="6098"><span class="lineNum">    6098 </span>            :             // DQ (2/9/2017): Debugging if this should be failing on GNU 4.9.3 with EDG 4.12 on tests/CompileTests/RoseExample_tests/testRoseHeaders_01.C</a>
<a name="6099"><span class="lineNum">    6099 </span>            :             // This also might be caused by the new support for template arguments which prevents private/protected types from being used where a public alias is available.</a>
<a name="6100"><span class="lineNum">    6100 </span>            :                ROSE_ABORT();</a>
<a name="6101"><span class="lineNum">    6101 </span>            : #endif</a>
<a name="6102"><span class="lineNum">    6102 </span>            :              }</a>
<a name="6103"><span class="lineNum">    6103 </span>            : </a>
<a name="6104"><span class="lineNum">    6104 </span>            :        // DQ (6/21/2011): Refactored this code for use in traverseTemplatedFunction()</a>
<a name="6105"><span class="lineNum">    6105 </span><span class="lineCov">       1946 :           addToNameMap(nodeReference,functionNameString);</span></a>
<a name="6106"><span class="lineNum">    6106 </span>            : </a>
<a name="6107"><span class="lineNum">    6107 </span>            :        // DQ (2/18/2013): Fixing generation of too many SgUnparse_Info object.</a>
<a name="6108"><span class="lineNum">    6108 </span><span class="lineCov">        973 :           delete unparseInfoPointer;</span></a>
<a name="6109"><span class="lineNum">    6109 </span>            :         }</a>
<a name="6110"><span class="lineNum">    6110 </span>            : </a>
<a name="6111"><span class="lineNum">    6111 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || 0</a>
<a name="6112"><span class="lineNum">    6112 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;&lt;&lt;&lt;&lt;&lt; Ending traversal of traverseTemplatedFunction functionRefExp = %p currentScope = %p = %s \n&quot;,functionRefExp,currentScope,currentScope-&gt;class_name().c_str());</a>
<a name="6113"><span class="lineNum">    6113 </span>            : #endif</a>
<a name="6114"><span class="lineNum">    6114 </span><span class="lineCov">        973 :    }</span></a>
<a name="6115"><span class="lineNum">    6115 </span>            : </a>
<a name="6116"><span class="lineNum">    6116 </span>            : </a>
<a name="6117"><span class="lineNum">    6117 </span>            : void</a>
<a name="6118"><span class="lineNum">    6118 </span><span class="lineCov">       2803 : NameQualificationTraversal::traverseTemplatedMemberFunction(SgMemberFunctionRefExp* memberFunctionRefExp, SgNode* nodeReference, SgScopeStatement* currentScope, SgStatement* positionStatement )</span></a>
<a name="6119"><span class="lineNum">    6119 </span>            :    {</a>
<a name="6120"><span class="lineNum">    6120 </span>            :   // Called using traverseTemplatedFunction(functionRefExp,templateInstantiationFunctionDeclaration,currentScope,currentStatement)</a>
<a name="6121"><span class="lineNum">    6121 </span>            : </a>
<a name="6122"><span class="lineNum">    6122 </span><span class="lineCov">       2803 :      ASSERT_not_null(memberFunctionRefExp);</span></a>
<a name="6123"><span class="lineNum">    6123 </span><span class="lineCov">       2803 :      ASSERT_not_null(nodeReference);</span></a>
<a name="6124"><span class="lineNum">    6124 </span><span class="lineCov">       2803 :      ASSERT_not_null(currentScope);</span></a>
<a name="6125"><span class="lineNum">    6125 </span><span class="lineCov">       2803 :      ASSERT_not_null(positionStatement);</span></a>
<a name="6126"><span class="lineNum">    6126 </span>            : </a>
<a name="6127"><span class="lineNum">    6127 </span>            :   // mfprintf(mlog [ WARN ] ) (&quot;Inside of traverseTemplatedFunction functionRefExp = %p currentScope = %p = %s \n&quot;,functionRefExp,currentScope,currentScope-&gt;class_name().c_str());</a>
<a name="6128"><span class="lineNum">    6128 </span>            : </a>
<a name="6129"><span class="lineNum">    6129 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || 0</a>
<a name="6130"><span class="lineNum">    6130 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;&lt;&lt;&lt;&lt;&lt; Starting traversal of traverseTemplatedFunction memberFunctionRefExp = %p currentScope = %p = %s \n&quot;,memberFunctionRefExp,currentScope,currentScope-&gt;class_name().c_str());</a>
<a name="6131"><span class="lineNum">    6131 </span>            : #endif</a>
<a name="6132"><span class="lineNum">    6132 </span>            : </a>
<a name="6133"><span class="lineNum">    6133 </span><span class="lineCov">       2803 :      bool skipThisFunction = false;</span></a>
<a name="6134"><span class="lineNum">    6134 </span><span class="lineCov">       2803 :      if (skipThisFunction == false)</span></a>
<a name="6135"><span class="lineNum">    6135 </span>            :         {</a>
<a name="6136"><span class="lineNum">    6136 </span><span class="lineCov">       2803 :           SgTemplateInstantiationMemberFunctionDecl* templateInstantiationMemberFunctionDeclaration = isSgTemplateInstantiationMemberFunctionDecl(memberFunctionRefExp-&gt;getAssociatedMemberFunctionDeclaration());</span></a>
<a name="6137"><span class="lineNum">    6137 </span><span class="lineCov">       2803 :           if (templateInstantiationMemberFunctionDeclaration != NULL)</span></a>
<a name="6138"><span class="lineNum">    6138 </span>            :              {</a>
<a name="6139"><span class="lineNum">    6139 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="6140"><span class="lineNum">    6140 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Found a SgTemplateInstantiationMemberFunctionDecl that will have template arguments that might require qualification. name = %s \n&quot;,templateInstantiationMemberFunctionDeclaration-&gt;get_name().str());</a>
<a name="6141"><span class="lineNum">    6141 </span>            : #endif</a>
<a name="6142"><span class="lineNum">    6142 </span><span class="lineCov">       2803 :                evaluateTemplateInstantiationDeclaration(templateInstantiationMemberFunctionDeclaration,currentScope,positionStatement);</span></a>
<a name="6143"><span class="lineNum">    6143 </span>            :              }</a>
<a name="6144"><span class="lineNum">    6144 </span>            : </a>
<a name="6145"><span class="lineNum">    6145 </span><span class="lineCov">       2803 :           SgUnparse_Info* unparseInfoPointer = new SgUnparse_Info();</span></a>
<a name="6146"><span class="lineNum">    6146 </span><span class="lineCov">       2803 :           ASSERT_not_null(unparseInfoPointer);</span></a>
<a name="6147"><span class="lineNum">    6147 </span><span class="lineCov">       2803 :           unparseInfoPointer-&gt;set_outputCompilerGeneratedStatements();</span></a>
<a name="6148"><span class="lineNum">    6148 </span>            : </a>
<a name="6149"><span class="lineNum">    6149 </span>            :        // Avoid unpasing the class definition when unparsing the type.</a>
<a name="6150"><span class="lineNum">    6150 </span><span class="lineCov">       2803 :           unparseInfoPointer-&gt;set_SkipClassDefinition();</span></a>
<a name="6151"><span class="lineNum">    6151 </span>            : </a>
<a name="6152"><span class="lineNum">    6152 </span>            :        // DQ (1/13/2014): Set the output of the enum defintion to match that of the class definition (consistancy is now inforced).</a>
<a name="6153"><span class="lineNum">    6153 </span><span class="lineCov">       2803 :           unparseInfoPointer-&gt;set_SkipEnumDefinition();</span></a>
<a name="6154"><span class="lineNum">    6154 </span>            : </a>
<a name="6155"><span class="lineNum">    6155 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="6156"><span class="lineNum">    6156 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;nodeReference = %p = %s \n&quot;,nodeReference,nodeReference-&gt;class_name().c_str());</a>
<a name="6157"><span class="lineNum">    6157 </span>            : #endif</a>
<a name="6158"><span class="lineNum">    6158 </span>            :        // Associate the unparsing of this type with the statement or scope where it occures.</a>
<a name="6159"><span class="lineNum">    6159 </span>            :        // This is the key to use in the lookup of the qualified name. But this is the correct key....</a>
<a name="6160"><span class="lineNum">    6160 </span>            :        // unparseInfoPointer-&gt;set_reference_node_for_qualification(positionStatement);</a>
<a name="6161"><span class="lineNum">    6161 </span>            :        // unparseInfoPointer-&gt;set_reference_node_for_qualification(currentScope);</a>
<a name="6162"><span class="lineNum">    6162 </span><span class="lineCov">       2803 :           unparseInfoPointer-&gt;set_reference_node_for_qualification(nodeReference);</span></a>
<a name="6163"><span class="lineNum">    6163 </span>            : </a>
<a name="6164"><span class="lineNum">    6164 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="6165"><span class="lineNum">    6165 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Calling globalUnparseToString() \n&quot;);</a>
<a name="6166"><span class="lineNum">    6166 </span>            : #endif</a>
<a name="6167"><span class="lineNum">    6167 </span><span class="lineCov">       2803 :           string memberFunctionNameString = globalUnparseToString(memberFunctionRefExp,unparseInfoPointer);</span></a>
<a name="6168"><span class="lineNum">    6168 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="6169"><span class="lineNum">    6169 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;++++++++++++++++ memberFunctionNameString (globalUnparseToString()) = %s \n&quot;,memberFunctionNameString.c_str());</a>
<a name="6170"><span class="lineNum">    6170 </span>            : #endif</a>
<a name="6171"><span class="lineNum">    6171 </span>            : #if 0</a>
<a name="6172"><span class="lineNum">    6172 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;++++++++++++++++ memberFunctionNameString (globalUnparseToString()) = %s \n&quot;,memberFunctionNameString.c_str());</a>
<a name="6173"><span class="lineNum">    6173 </span>            : #endif</a>
<a name="6174"><span class="lineNum">    6174 </span>            :        // DQ (3/30/2018): Incremented this for ROSE compiling ROSE using Boost (after bugfix for private types to be replaced with non-private unparsable types).</a>
<a name="6175"><span class="lineNum">    6175 </span>            :        // DQ (12/3/2014): Incremented this for ARES application files.</a>
<a name="6176"><span class="lineNum">    6176 </span>            :        // DQ (6/9/2013): I have incremented this value to support mangled names in the protobuf-2.5.0 application.</a>
<a name="6177"><span class="lineNum">    6177 </span>            :        // This is symptematic of an error which causes the whole class to be included with the class</a>
<a name="6178"><span class="lineNum">    6178 </span>            :        // definition.  This was fixed by calling unparseInfoPointer-&gt;set_SkipClassDefinition() above.</a>
<a name="6179"><span class="lineNum">    6179 </span>            :        // [Robb Matzke 2018-06-19]: Incremented from 8000 to 9000 because &lt;rose.h&gt; has a name that's 8960 characters, namely &quot;__gnu_cxx::new_allocator&lt; _Rb_tree_node&lt; map&lt; ... &gt;</a>
<a name="6180"><span class="lineNum">    6180 </span>            :        //    ::value_type &gt; &gt; ::deallocate&quot;.</a>
<a name="6181"><span class="lineNum">    6181 </span>            :        // if (memberFunctionNameString.length() &gt; 4000)</a>
<a name="6182"><span class="lineNum">    6182 </span>            :        // if (memberFunctionNameString.length() &gt; 8000)</a>
<a name="6183"><span class="lineNum">    6183 </span>            :        // if (memberFunctionNameString.length() &gt; 8000)</a>
<a name="6184"><span class="lineNum">    6184 </span><span class="lineCov">       2803 :           if (memberFunctionNameString.length() &gt; 9000)</span></a>
<a name="6185"><span class="lineNum">    6185 </span>            :              {</a>
<a name="6186"><span class="lineNum">    6186 </span><span class="lineNoCov">          0 :                mfprintf(mlog [ WARN ] ) (&quot;Error: function names should not be this long... memberFunctionNameString.length() = %&quot; PRIuPTR &quot; \n&quot;,memberFunctionNameString.length());</span></a>
<a name="6187"><span class="lineNum">    6187 </span>            : #if 1</a>
<a name="6188"><span class="lineNum">    6188 </span><span class="lineNoCov">          0 :                mfprintf(mlog [ WARN ] ) (&quot;Error: function names should not be this long... memberFunctionNameString = \n%s \n&quot;,memberFunctionNameString.c_str());</span></a>
<a name="6189"><span class="lineNum">    6189 </span>            : #endif</a>
<a name="6190"><span class="lineNum">    6190 </span><span class="lineNoCov">          0 :                ROSE_ABORT();</span></a>
<a name="6191"><span class="lineNum">    6191 </span>            :              }</a>
<a name="6192"><span class="lineNum">    6192 </span>            : </a>
<a name="6193"><span class="lineNum">    6193 </span>            :        // DQ (6/21/2011): Refactored this code for use in traverseTemplatedFunction()</a>
<a name="6194"><span class="lineNum">    6194 </span><span class="lineCov">       5606 :           addToNameMap(nodeReference,memberFunctionNameString);</span></a>
<a name="6195"><span class="lineNum">    6195 </span>            : </a>
<a name="6196"><span class="lineNum">    6196 </span>            :        // DQ (2/18/2013): Fixing generation of too many SgUnparse_Info object.</a>
<a name="6197"><span class="lineNum">    6197 </span><span class="lineCov">       2803 :           delete unparseInfoPointer;</span></a>
<a name="6198"><span class="lineNum">    6198 </span>            :         }</a>
<a name="6199"><span class="lineNum">    6199 </span>            : </a>
<a name="6200"><span class="lineNum">    6200 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || 0</a>
<a name="6201"><span class="lineNum">    6201 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;&lt;&lt;&lt;&lt;&lt; Ending traversal of traverseTemplatedMemberFunction memberFunctionRefExp = %p currentScope = %p = %s \n&quot;,memberFunctionRefExp,currentScope,currentScope-&gt;class_name().c_str());</a>
<a name="6202"><span class="lineNum">    6202 </span>            : #endif</a>
<a name="6203"><span class="lineNum">    6203 </span><span class="lineCov">       2803 :    }</span></a>
<a name="6204"><span class="lineNum">    6204 </span>            : </a>
<a name="6205"><span class="lineNum">    6205 </span>            : </a>
<a name="6206"><span class="lineNum">    6206 </span>            : void</a>
<a name="6207"><span class="lineNum">    6207 </span><span class="lineCov">       3592 : NameQualificationTraversal::traverseTemplatedClass(SgBaseClass* baseClass, SgNode* nodeReference, SgScopeStatement* currentScope, SgStatement* positionStatement )</span></a>
<a name="6208"><span class="lineNum">    6208 </span>            :    {</a>
<a name="6209"><span class="lineNum">    6209 </span>            :   // DQ (4/12/2019): Notes on Cxx11_tests/test342.C:</a>
<a name="6210"><span class="lineNum">    6210 </span>            :   // It may be that we need a function like &quot;traverseTemplatedFunction&quot; for classes to support the reference to a template class instantiation in a SgBaseClass.</a>
<a name="6211"><span class="lineNum">    6211 </span>            :   // The issue is that the template arguments can have arbitrary complexity of name qualification requirements such that we need to save the associtate string</a>
<a name="6212"><span class="lineNum">    6212 </span>            :   // generated once after all of the required name qualification (of the template arguments) has been figured out.</a>
<a name="6213"><span class="lineNum">    6213 </span>            : </a>
<a name="6214"><span class="lineNum">    6214 </span>            :   // The point is to save the generated name of the class declaration, correctly name qualified (with all template parameters name qualified) so that it can</a>
<a name="6215"><span class="lineNum">    6215 </span>            :   // be used directly (as a string) in the unparsing. The call to &quot;addToNameMap()&quot; is the key part that saves the name of the template instantiation.</a>
<a name="6216"><span class="lineNum">    6216 </span>            : </a>
<a name="6217"><span class="lineNum">    6217 </span>            :   // Currently the base class references the shared template class instantiation (so this might be the root of the problem as well).</a>
<a name="6218"><span class="lineNum">    6218 </span>            :   // If sharing is the issue, then generateding a strring to hold the name of the class with ccntext depenent template argument name</a>
<a name="6219"><span class="lineNum">    6219 </span>            :   // qualification would be the solution (just as it is for shared types).</a>
<a name="6220"><span class="lineNum">    6220 </span>            : </a>
<a name="6221"><span class="lineNum">    6221 </span>            : </a>
<a name="6222"><span class="lineNum">    6222 </span>            :   // Called similar to traverseTemplatedFunction(functionRefExp,templateInstantiationFunctionDeclaration,currentScope,currentStatement)</a>
<a name="6223"><span class="lineNum">    6223 </span>            : </a>
<a name="6224"><span class="lineNum">    6224 </span><span class="lineCov">       3592 :      ASSERT_not_null(baseClass);</span></a>
<a name="6225"><span class="lineNum">    6225 </span><span class="lineCov">       3592 :      ASSERT_not_null(nodeReference);</span></a>
<a name="6226"><span class="lineNum">    6226 </span><span class="lineCov">       3592 :      ASSERT_not_null(currentScope);</span></a>
<a name="6227"><span class="lineNum">    6227 </span><span class="lineCov">       3592 :      ASSERT_not_null(positionStatement);</span></a>
<a name="6228"><span class="lineNum">    6228 </span>            : </a>
<a name="6229"><span class="lineNum">    6229 </span>            : #if 0</a>
<a name="6230"><span class="lineNum">    6230 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;Inside of traverseTemplatedClass baseClass = %p currentScope = %p = %s \n&quot;,baseClass,currentScope,currentScope-&gt;class_name().c_str());</a>
<a name="6231"><span class="lineNum">    6231 </span>            : #endif</a>
<a name="6232"><span class="lineNum">    6232 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || 0</a>
<a name="6233"><span class="lineNum">    6233 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;&lt;&lt;&lt;&lt;&lt; Starting traversal of traverseTemplatedFunction baseClass = %p currentScope = %p = %s \n&quot;,baseClass,currentScope,currentScope-&gt;class_name().c_str());</a>
<a name="6234"><span class="lineNum">    6234 </span>            : #endif</a>
<a name="6235"><span class="lineNum">    6235 </span>            : </a>
<a name="6236"><span class="lineNum">    6236 </span><span class="lineCov">       3592 :      bool skipThisClass = false;</span></a>
<a name="6237"><span class="lineNum">    6237 </span><span class="lineCov">       3592 :      if (skipThisClass == false)</span></a>
<a name="6238"><span class="lineNum">    6238 </span>            :         {</a>
<a name="6239"><span class="lineNum">    6239 </span><span class="lineCov">       3592 :           SgTemplateInstantiationDecl* templateInstantiationClassDeclaration = isSgTemplateInstantiationDecl(baseClass-&gt;get_base_class());</span></a>
<a name="6240"><span class="lineNum">    6240 </span><span class="lineCov">       3592 :           if (templateInstantiationClassDeclaration != NULL)</span></a>
<a name="6241"><span class="lineNum">    6241 </span>            :              {</a>
<a name="6242"><span class="lineNum">    6242 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || 0</a>
<a name="6243"><span class="lineNum">    6243 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Found a SgTemplateInstantiationDecl that will have template arguments that might require qualification. name = %s \n&quot;,templateInstantiationClassDeclaration-&gt;get_name().str());</a>
<a name="6244"><span class="lineNum">    6244 </span>            : #endif</a>
<a name="6245"><span class="lineNum">    6245 </span><span class="lineCov">       3592 :                evaluateTemplateInstantiationDeclaration(templateInstantiationClassDeclaration,currentScope,positionStatement);</span></a>
<a name="6246"><span class="lineNum">    6246 </span>            :              }</a>
<a name="6247"><span class="lineNum">    6247 </span>            : </a>
<a name="6248"><span class="lineNum">    6248 </span><span class="lineCov">       3592 :           SgUnparse_Info* unparseInfoPointer = new SgUnparse_Info();</span></a>
<a name="6249"><span class="lineNum">    6249 </span><span class="lineCov">       3592 :           ASSERT_not_null(unparseInfoPointer);</span></a>
<a name="6250"><span class="lineNum">    6250 </span><span class="lineCov">       3592 :           unparseInfoPointer-&gt;set_outputCompilerGeneratedStatements();</span></a>
<a name="6251"><span class="lineNum">    6251 </span>            : </a>
<a name="6252"><span class="lineNum">    6252 </span>            :        // Avoid unpasing the class definition when unparseing the type.</a>
<a name="6253"><span class="lineNum">    6253 </span><span class="lineCov">       3592 :           unparseInfoPointer-&gt;set_SkipClassDefinition();</span></a>
<a name="6254"><span class="lineNum">    6254 </span>            : </a>
<a name="6255"><span class="lineNum">    6255 </span>            :        // DQ (1/13/2014): Set the output of the enum defintion to match that of the class definition (consistancy is now inforced).</a>
<a name="6256"><span class="lineNum">    6256 </span><span class="lineCov">       3592 :           unparseInfoPointer-&gt;set_SkipEnumDefinition();</span></a>
<a name="6257"><span class="lineNum">    6257 </span>            : </a>
<a name="6258"><span class="lineNum">    6258 </span>            :        // DQ (4/12/2019): This is how we skip the generation of the name with the &quot;template&lt;&gt; struct&quot; specifiers and trailing &quot;;&quot;.</a>
<a name="6259"><span class="lineNum">    6259 </span><span class="lineCov">       3592 :           unparseInfoPointer-&gt;set_inEmbeddedDecl();</span></a>
<a name="6260"><span class="lineNum">    6260 </span><span class="lineCov">       3592 :           unparseInfoPointer-&gt;set_SkipSemiColon();</span></a>
<a name="6261"><span class="lineNum">    6261 </span><span class="lineCov">       3592 :           unparseInfoPointer-&gt;set_SkipClassSpecifier();</span></a>
<a name="6262"><span class="lineNum">    6262 </span>            : </a>
<a name="6263"><span class="lineNum">    6263 </span>            : #if 0</a>
<a name="6264"><span class="lineNum">    6264 </span>            :        // DQ (4/12/2019): Test2019_342.C and test2019_350.C demonstrate that this needs to be more carefully supported.</a>
<a name="6265"><span class="lineNum">    6265 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;############################################################################################################################# \n&quot;);</a>
<a name="6266"><span class="lineNum">    6266 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;In traverseTemplatedClass(): Need to supress name qualification in the generated string to avoid redundant name qualification \n&quot;);</a>
<a name="6267"><span class="lineNum">    6267 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;############################################################################################################################# \n&quot;);</a>
<a name="6268"><span class="lineNum">    6268 </span>            : #endif</a>
<a name="6269"><span class="lineNum">    6269 </span><span class="lineCov">       3592 :           unparseInfoPointer-&gt;set_SkipNameQualification();</span></a>
<a name="6270"><span class="lineNum">    6270 </span>            : </a>
<a name="6271"><span class="lineNum">    6271 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || 0</a>
<a name="6272"><span class="lineNum">    6272 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;In traverseTemplatedClass(): nodeReference = %p = %s \n&quot;,nodeReference,nodeReference-&gt;class_name().c_str());</a>
<a name="6273"><span class="lineNum">    6273 </span>            : #endif</a>
<a name="6274"><span class="lineNum">    6274 </span>            : </a>
<a name="6275"><span class="lineNum">    6275 </span>            :        // DQ (3/13/2019): Not setting the reference_node_for_qualification, may be the best way to make sure</a>
<a name="6276"><span class="lineNum">    6276 </span>            :        // we don't get a name qualification prefix.</a>
<a name="6277"><span class="lineNum">    6277 </span>            :        // Associate the unparsing of this type with the statement or scope where it occures.</a>
<a name="6278"><span class="lineNum">    6278 </span>            :        // This is the key to use in the lookup of the qualified name. But this is the correct key....</a>
<a name="6279"><span class="lineNum">    6279 </span>            :        // unparseInfoPointer-&gt;set_reference_node_for_qualification(positionStatement);</a>
<a name="6280"><span class="lineNum">    6280 </span>            :        // unparseInfoPointer-&gt;set_reference_node_for_qualification(currentScope);</a>
<a name="6281"><span class="lineNum">    6281 </span><span class="lineCov">       3592 :           unparseInfoPointer-&gt;set_reference_node_for_qualification(nodeReference);</span></a>
<a name="6282"><span class="lineNum">    6282 </span>            : </a>
<a name="6283"><span class="lineNum">    6283 </span>            :        // DQ (3/16/2021): Need to set the assocated file, else it is caught in unparseStatement().</a>
<a name="6284"><span class="lineNum">    6284 </span>            :        // After review, I think we may not need this.</a>
<a name="6285"><span class="lineNum">    6285 </span>            :        // SgSourceFile* sourceFile = xxx;</a>
<a name="6286"><span class="lineNum">    6286 </span>            :        // unparseInfoPointer-&gt;set_current_source_file(xxx);</a>
<a name="6287"><span class="lineNum">    6287 </span>            : </a>
<a name="6288"><span class="lineNum">    6288 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || 0</a>
<a name="6289"><span class="lineNum">    6289 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Calling globalUnparseToString() \n&quot;);</a>
<a name="6290"><span class="lineNum">    6290 </span>            : #endif</a>
<a name="6291"><span class="lineNum">    6291 </span><span class="lineCov">       3592 :           string classNameString = globalUnparseToString(templateInstantiationClassDeclaration,unparseInfoPointer);</span></a>
<a name="6292"><span class="lineNum">    6292 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || 0</a>
<a name="6293"><span class="lineNum">    6293 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;++++++++++++++++ classNameString (globalUnparseToString()) = %s \n&quot;,classNameString.c_str());</a>
<a name="6294"><span class="lineNum">    6294 </span>            : #endif</a>
<a name="6295"><span class="lineNum">    6295 </span>            : #if 0</a>
<a name="6296"><span class="lineNum">    6296 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;++++++++++++++++ classNameString (globalUnparseToString()) = %s \n&quot;,classNameString.c_str());</a>
<a name="6297"><span class="lineNum">    6297 </span>            : #endif</a>
<a name="6298"><span class="lineNum">    6298 </span>            : </a>
<a name="6299"><span class="lineNum">    6299 </span>            :        // DQ (10/31/2015): Increased the maximum allowable size of function names (because test2015_98.C</a>
<a name="6300"><span class="lineNum">    6300 </span>            :        // demonstrates a longer name (length == 5062)).</a>
<a name="6301"><span class="lineNum">    6301 </span>            :        // DQ (6/24/2013): Increased upper bound to support ROSE compiling ROSE.</a>
<a name="6302"><span class="lineNum">    6302 </span>            :        // This is symptematic of an error which causes the whole class to be included with the class</a>
<a name="6303"><span class="lineNum">    6303 </span>            :        // definition.  This was fixed by calling unparseInfoPointer-&gt;set_SkipClassDefinition() above.</a>
<a name="6304"><span class="lineNum">    6304 </span>            :        // if (functionNameString.length() &gt; 2000)</a>
<a name="6305"><span class="lineNum">    6305 </span>            :        // if (functionNameString.length() &gt; 5000)</a>
<a name="6306"><span class="lineNum">    6306 </span><span class="lineCov">       3592 :           if (classNameString.length() &gt; 10000)</span></a>
<a name="6307"><span class="lineNum">    6307 </span>            :              {</a>
<a name="6308"><span class="lineNum">    6308 </span><span class="lineNoCov">          0 :                mfprintf(mlog [ WARN ] ) (&quot;Error: class names should not be this long... classNameString.length() = %&quot; PRIuPTR &quot; \n&quot;,classNameString.length());</span></a>
<a name="6309"><span class="lineNum">    6309 </span>            : #if 0</a>
<a name="6310"><span class="lineNum">    6310 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Error: class names should not be this long... classNameString          = \n%s \n&quot;,classNameString.c_str());</a>
<a name="6311"><span class="lineNum">    6311 </span>            : #endif</a>
<a name="6312"><span class="lineNum">    6312 </span>            : #if 0</a>
<a name="6313"><span class="lineNum">    6313 </span>            :             // DQ (2/9/2017): Debugging if this should be failing on GNU 4.9.3 with EDG 4.12 on tests/CompileTests/RoseExample_tests/testRoseHeaders_01.C</a>
<a name="6314"><span class="lineNum">    6314 </span>            :             // This also might be caused by the new support for template arguments which prevents private/protected types from being used where a public alias is available.</a>
<a name="6315"><span class="lineNum">    6315 </span>            :                ROSE_ABORT();</a>
<a name="6316"><span class="lineNum">    6316 </span>            : #endif</a>
<a name="6317"><span class="lineNum">    6317 </span>            :              }</a>
<a name="6318"><span class="lineNum">    6318 </span>            : </a>
<a name="6319"><span class="lineNum">    6319 </span>            :        // DQ (6/21/2011): Refactored this code for use in traverseTemplatedFunction()</a>
<a name="6320"><span class="lineNum">    6320 </span><span class="lineCov">       7184 :           addToNameMap(nodeReference,classNameString);</span></a>
<a name="6321"><span class="lineNum">    6321 </span>            : </a>
<a name="6322"><span class="lineNum">    6322 </span>            :        // DQ (2/18/2013): Fixing generation of too many SgUnparse_Info object.</a>
<a name="6323"><span class="lineNum">    6323 </span><span class="lineCov">       3592 :           delete unparseInfoPointer;</span></a>
<a name="6324"><span class="lineNum">    6324 </span>            :         }</a>
<a name="6325"><span class="lineNum">    6325 </span>            : </a>
<a name="6326"><span class="lineNum">    6326 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || 0</a>
<a name="6327"><span class="lineNum">    6327 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;&lt;&lt;&lt;&lt;&lt; Ending traversal of traverseTemplatedClass baseClass = %p currentScope = %p = %s \n&quot;,baseClass,currentScope,currentScope-&gt;class_name().c_str());</a>
<a name="6328"><span class="lineNum">    6328 </span>            : #endif</a>
<a name="6329"><span class="lineNum">    6329 </span><span class="lineCov">       3592 :    }</span></a>
<a name="6330"><span class="lineNum">    6330 </span>            : </a>
<a name="6331"><span class="lineNum">    6331 </span>            : </a>
<a name="6332"><span class="lineNum">    6332 </span>            : </a>
<a name="6333"><span class="lineNum">    6333 </span>            : </a>
<a name="6334"><span class="lineNum">    6334 </span>            : </a>
<a name="6335"><span class="lineNum">    6335 </span>            : </a>
<a name="6336"><span class="lineNum">    6336 </span>            : bool</a>
<a name="6337"><span class="lineNum">    6337 </span><span class="lineCov">    1216980 : NameQualificationTraversal::skipNameQualificationIfNotProperlyDeclaredWhereDeclarationIsDefinable(SgDeclarationStatement* declaration)</span></a>
<a name="6338"><span class="lineNum">    6338 </span>            :    {</a>
<a name="6339"><span class="lineNum">    6339 </span>            :   // DQ (6/9/2011): Support for test2011_78.C (we only qualify function call references where the function has been declared in</a>
<a name="6340"><span class="lineNum">    6340 </span>            :   // a scope where it could be expected to be defined (e.g. not using a forward declaration in a SgBasicBlock, since the function</a>
<a name="6341"><span class="lineNum">    6341 </span>            :   // definition could not live in the SgBasicBlock.</a>
<a name="6342"><span class="lineNum">    6342 </span>            : </a>
<a name="6343"><span class="lineNum">    6343 </span>            :   // DQ (4/27/2019): Added assertion.</a>
<a name="6344"><span class="lineNum">    6344 </span><span class="lineCov">    1216980 :      ASSERT_not_null(declaration);</span></a>
<a name="6345"><span class="lineNum">    6345 </span>            : </a>
<a name="6346"><span class="lineNum">    6346 </span><span class="lineCov">    1216980 :      bool skipNameQualification = false;</span></a>
<a name="6347"><span class="lineNum">    6347 </span><span class="lineCov">    1216980 :      SgDeclarationStatement* declarationToSearchForInReferencedNameSet = declaration-&gt;get_firstNondefiningDeclaration() != NULL ? declaration-&gt;get_firstNondefiningDeclaration() : declaration;</span></a>
<a name="6348"><span class="lineNum">    6348 </span><span class="lineCov">    1216980 :      ASSERT_not_null(declarationToSearchForInReferencedNameSet);</span></a>
<a name="6349"><span class="lineNum">    6349 </span>            : </a>
<a name="6350"><span class="lineNum">    6350 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="6351"><span class="lineNum">    6351 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In skipNameQualificationIfNotProperlyDeclaredWhereDeclarationIsDefinable(): declaration-&gt;get_firstNondefiningDeclaration() = %p \n&quot;,</a>
<a name="6352"><span class="lineNum">    6352 </span>            :           declaration-&gt;get_firstNondefiningDeclaration());</a>
<a name="6353"><span class="lineNum">    6353 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;   --- declarationToSearchForInReferencedNameSet-&gt;get_parent() = %p = %s \n&quot;,</a>
<a name="6354"><span class="lineNum">    6354 </span>            :           declarationToSearchForInReferencedNameSet-&gt;get_parent(),declarationToSearchForInReferencedNameSet-&gt;get_parent()-&gt;class_name().c_str());</a>
<a name="6355"><span class="lineNum">    6355 </span>            : </a>
<a name="6356"><span class="lineNum">    6356 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;   --- declaration                                             = %p = %s \n&quot;,declaration,declaration-&gt;class_name().c_str());</a>
<a name="6357"><span class="lineNum">    6357 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;   --- declaration-&gt;get_parent()                               = %p = %s \n&quot;,declaration-&gt;get_parent(),declaration-&gt;get_parent()-&gt;class_name().c_str());</a>
<a name="6358"><span class="lineNum">    6358 </span>            :      if (declaration-&gt;get_firstNondefiningDeclaration() != NULL)</a>
<a name="6359"><span class="lineNum">    6359 </span>            :         {</a>
<a name="6360"><span class="lineNum">    6360 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;   --- declaration -&gt;get_firstNondefiningDeclaration()              = %p = %s \n&quot;,</a>
<a name="6361"><span class="lineNum">    6361 </span>            :                declaration-&gt;get_firstNondefiningDeclaration(),declaration-&gt;get_firstNondefiningDeclaration()-&gt;class_name().c_str());</a>
<a name="6362"><span class="lineNum">    6362 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;   --- declaration-&gt;get_firstNondefiningDeclaration()-&gt;get_parent() = %p = %s \n&quot;,</a>
<a name="6363"><span class="lineNum">    6363 </span>            :                declaration-&gt;get_firstNondefiningDeclaration()-&gt;get_parent(),declaration-&gt;get_firstNondefiningDeclaration()-&gt;get_parent()-&gt;class_name().c_str());</a>
<a name="6364"><span class="lineNum">    6364 </span>            :         }</a>
<a name="6365"><span class="lineNum">    6365 </span>            :      if (declaration-&gt;get_definingDeclaration() != NULL)</a>
<a name="6366"><span class="lineNum">    6366 </span>            :         {</a>
<a name="6367"><span class="lineNum">    6367 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;   --- declaration -&gt;get_definingDeclaration()                      = %p = %s \n&quot;,</a>
<a name="6368"><span class="lineNum">    6368 </span>            :                declaration-&gt;get_definingDeclaration(),declaration-&gt;get_definingDeclaration()-&gt;class_name().c_str());</a>
<a name="6369"><span class="lineNum">    6369 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;   --- declaration-&gt;get_definingDeclaration()-&gt;get_parent()         = %p = %s \n&quot;,</a>
<a name="6370"><span class="lineNum">    6370 </span>            :                declaration-&gt;get_definingDeclaration()-&gt;get_parent(),declaration-&gt;get_definingDeclaration()-&gt;get_parent()-&gt;class_name().c_str());</a>
<a name="6371"><span class="lineNum">    6371 </span>            :         }</a>
<a name="6372"><span class="lineNum">    6372 </span>            : #endif</a>
<a name="6373"><span class="lineNum">    6373 </span>            : </a>
<a name="6374"><span class="lineNum">    6374 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) &amp;&amp; 0</a>
<a name="6375"><span class="lineNum">    6375 </span>            :      SgFunctionDeclaration* inputFunctionDeclaration = isSgFunctionDeclaration(declaration);</a>
<a name="6376"><span class="lineNum">    6376 </span>            :      if (inputFunctionDeclaration != NULL)</a>
<a name="6377"><span class="lineNum">    6377 </span>            :         {</a>
<a name="6378"><span class="lineNum">    6378 </span>            :           printf (&quot;inputFunctionDeclaration name = %s \n&quot;,inputFunctionDeclaration-&gt;get_name().str());</a>
<a name="6379"><span class="lineNum">    6379 </span>            :           SgScopeStatement* scope = inputFunctionDeclaration-&gt;get_scope();</a>
<a name="6380"><span class="lineNum">    6380 </span>            :           printf (&quot;scope = %p = %s \n&quot;,scope,scope-&gt;class_name().c_str());</a>
<a name="6381"><span class="lineNum">    6381 </span>            : </a>
<a name="6382"><span class="lineNum">    6382 </span>            :           SgName mangledName = inputFunctionDeclaration-&gt;get_mangled_name();</a>
<a name="6383"><span class="lineNum">    6383 </span>            :           printf (&quot;mangledName = %s \n&quot;,mangledName.str());</a>
<a name="6384"><span class="lineNum">    6384 </span>            : </a>
<a name="6385"><span class="lineNum">    6385 </span>            :           SgSourceFile* sourceFile = SageInterface::getEnclosingNode&lt;SgSourceFile&gt;(inputFunctionDeclaration);</a>
<a name="6386"><span class="lineNum">    6386 </span>            :           ROSE_ASSERT(sourceFile != NULL);</a>
<a name="6387"><span class="lineNum">    6387 </span>            :           printf (&quot;sourceFile = %p name = %s \n&quot;,sourceFile,sourceFile-&gt;getFileName().c_str());</a>
<a name="6388"><span class="lineNum">    6388 </span>            :           inputFunctionDeclaration-&gt;get_file_info()-&gt;display(&quot;inputFunctionDeclaration: debug&quot;);</a>
<a name="6389"><span class="lineNum">    6389 </span>            :         }</a>
<a name="6390"><span class="lineNum">    6390 </span>            : </a>
<a name="6391"><span class="lineNum">    6391 </span>            :      SgFunctionDeclaration* inputFunctionDeclarationToSearchForInReferencedNameSet = isSgFunctionDeclaration(declarationToSearchForInReferencedNameSet);</a>
<a name="6392"><span class="lineNum">    6392 </span>            :      if (inputFunctionDeclarationToSearchForInReferencedNameSet != NULL)</a>
<a name="6393"><span class="lineNum">    6393 </span>            :         {</a>
<a name="6394"><span class="lineNum">    6394 </span>            :           printf (&quot;inputFunctionDeclarationToSearchForInReferencedNameSet name = %s \n&quot;,inputFunctionDeclarationToSearchForInReferencedNameSet-&gt;get_name().str());</a>
<a name="6395"><span class="lineNum">    6395 </span>            :           SgScopeStatement* scope = inputFunctionDeclarationToSearchForInReferencedNameSet-&gt;get_scope();</a>
<a name="6396"><span class="lineNum">    6396 </span>            :           printf (&quot;scope = %p = %s \n&quot;,scope,scope-&gt;class_name().c_str());</a>
<a name="6397"><span class="lineNum">    6397 </span>            : </a>
<a name="6398"><span class="lineNum">    6398 </span>            :           SgName mangledName = inputFunctionDeclarationToSearchForInReferencedNameSet-&gt;get_mangled_name();</a>
<a name="6399"><span class="lineNum">    6399 </span>            :           printf (&quot;mangledName = %s \n&quot;,mangledName.str());</a>
<a name="6400"><span class="lineNum">    6400 </span>            : </a>
<a name="6401"><span class="lineNum">    6401 </span>            :           SgSourceFile* sourceFile = SageInterface::getEnclosingNode&lt;SgSourceFile&gt;(inputFunctionDeclarationToSearchForInReferencedNameSet);</a>
<a name="6402"><span class="lineNum">    6402 </span>            :           ROSE_ASSERT(sourceFile != NULL);</a>
<a name="6403"><span class="lineNum">    6403 </span>            :           printf (&quot;sourceFile = %p name = %s \n&quot;,sourceFile,sourceFile-&gt;getFileName().c_str());</a>
<a name="6404"><span class="lineNum">    6404 </span>            : </a>
<a name="6405"><span class="lineNum">    6405 </span>            :           inputFunctionDeclarationToSearchForInReferencedNameSet-&gt;get_file_info()-&gt;display(&quot;inputFunctionDeclarationToSearchForInReferencedNameSet: debug&quot;);</a>
<a name="6406"><span class="lineNum">    6406 </span>            :         }</a>
<a name="6407"><span class="lineNum">    6407 </span>            : </a>
<a name="6408"><span class="lineNum">    6408 </span>            :      printf (&quot;Output referencedNameSet: \n&quot;);</a>
<a name="6409"><span class="lineNum">    6409 </span>            :      for (std::set&lt;SgNode*&gt;::iterator i = referencedNameSet.begin(); i != referencedNameSet.end(); i++)</a>
<a name="6410"><span class="lineNum">    6410 </span>            :         {</a>
<a name="6411"><span class="lineNum">    6411 </span>            :        // printf (&quot; --- referencedNameSet: element: \n&quot;);</a>
<a name="6412"><span class="lineNum">    6412 </span>            : </a>
<a name="6413"><span class="lineNum">    6413 </span>            :        // DQ (10/17/2020): There is a NULL entry in the referencedNameSet, this should not exist.</a>
<a name="6414"><span class="lineNum">    6414 </span>            :        // ROSE_ASSERT(*i != NULL);</a>
<a name="6415"><span class="lineNum">    6415 </span>            : </a>
<a name="6416"><span class="lineNum">    6416 </span>            :           if (*i != NULL)</a>
<a name="6417"><span class="lineNum">    6417 </span>            :              {</a>
<a name="6418"><span class="lineNum">    6418 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;   --- *** referencedNameSet member *i = %p = %s \n&quot;,*i,(*i)-&gt;class_name().c_str());</a>
<a name="6419"><span class="lineNum">    6419 </span>            :                SgFunctionDeclaration* functionDeclaration = isSgFunctionDeclaration(*i);</a>
<a name="6420"><span class="lineNum">    6420 </span>            :                if (functionDeclaration != NULL)</a>
<a name="6421"><span class="lineNum">    6421 </span>            :                   {</a>
<a name="6422"><span class="lineNum">    6422 </span>            :                  // DQ (10/17/2020): This is a declaration from likely a different file, but with the same name as what we are searching for.</a>
<a name="6423"><span class="lineNum">    6423 </span>            :                  // So although I would not want to compare function names, that could be one solution.</a>
<a name="6424"><span class="lineNum">    6424 </span>            :                  // Either that or identify if these are from a different file.</a>
<a name="6425"><span class="lineNum">    6425 </span>            :                     printf (&quot;   --- *** functionDeclaration name = %s \n&quot;,functionDeclaration-&gt;get_name().str());</a>
<a name="6426"><span class="lineNum">    6426 </span>            :                     SgScopeStatement* scope = functionDeclaration-&gt;get_scope();</a>
<a name="6427"><span class="lineNum">    6427 </span>            :                     printf (&quot;   --- *** scope = %p = %s \n&quot;,scope,scope-&gt;class_name().c_str());</a>
<a name="6428"><span class="lineNum">    6428 </span>            : </a>
<a name="6429"><span class="lineNum">    6429 </span>            :                     SgName mangledName = functionDeclaration-&gt;get_mangled_name();</a>
<a name="6430"><span class="lineNum">    6430 </span>            :                     printf (&quot;   --- *** mangledName = %s \n&quot;,mangledName.str());</a>
<a name="6431"><span class="lineNum">    6431 </span>            : </a>
<a name="6432"><span class="lineNum">    6432 </span>            :                     SgSourceFile* sourceFile = SageInterface::getEnclosingNode&lt;SgSourceFile&gt;(functionDeclaration);</a>
<a name="6433"><span class="lineNum">    6433 </span>            :                     ROSE_ASSERT(sourceFile != NULL);</a>
<a name="6434"><span class="lineNum">    6434 </span>            :                     printf (&quot;   --- *** sourceFile = %p name = %s \n&quot;,sourceFile,sourceFile-&gt;getFileName().c_str());</a>
<a name="6435"><span class="lineNum">    6435 </span>            : </a>
<a name="6436"><span class="lineNum">    6436 </span>            :                     functionDeclaration-&gt;get_file_info()-&gt;display(&quot;functionDeclaration: debug&quot;);</a>
<a name="6437"><span class="lineNum">    6437 </span>            :                   }</a>
<a name="6438"><span class="lineNum">    6438 </span>            :              }</a>
<a name="6439"><span class="lineNum">    6439 </span>            :             else</a>
<a name="6440"><span class="lineNum">    6440 </span>            :              {</a>
<a name="6441"><span class="lineNum">    6441 </span>            :             // printf (&quot; --- element = %p \n&quot;,*i);</a>
<a name="6442"><span class="lineNum">    6442 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;   --- *** referencedNameSet member *i = %p \n&quot;,*i);</a>
<a name="6443"><span class="lineNum">    6443 </span>            :              }</a>
<a name="6444"><span class="lineNum">    6444 </span>            :         }</a>
<a name="6445"><span class="lineNum">    6445 </span>            : #endif</a>
<a name="6446"><span class="lineNum">    6446 </span>            : </a>
<a name="6447"><span class="lineNum">    6447 </span>            :   // DQ (8/18/2012): If this is a template instantiation, then we need to look at where the template declaration is and if IT is defined.</a>
<a name="6448"><span class="lineNum">    6448 </span>            :   // See test2009_30.C for an example of this.</a>
<a name="6449"><span class="lineNum">    6449 </span><span class="lineCov">    1216980 :      SgTemplateInstantiationFunctionDecl* templateInstantiationFunctionDecl = isSgTemplateInstantiationFunctionDecl(declaration);</span></a>
<a name="6450"><span class="lineNum">    6450 </span><span class="lineCov">    1216980 :      if (templateInstantiationFunctionDecl != NULL)</span></a>
<a name="6451"><span class="lineNum">    6451 </span>            :         {</a>
<a name="6452"><span class="lineNum">    6452 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="6453"><span class="lineNum">    6453 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;In skipNameQualificationIfNotProperlyDeclaredWhereDeclarationIsDefinable(): templateInstantiationFunctionDecl-&gt;get_name() = %p = %s \n&quot;,</a>
<a name="6454"><span class="lineNum">    6454 </span>            :                templateInstantiationFunctionDecl,templateInstantiationFunctionDecl-&gt;get_name().str());</a>
<a name="6455"><span class="lineNum">    6455 </span>            : #endif</a>
<a name="6456"><span class="lineNum">    6456 </span>            : </a>
<a name="6457"><span class="lineNum">    6457 </span>            :        // DQ (8/18/2012): Note that test2012_57.C and test2012_59.C have template specalizations that don't appear</a>
<a name="6458"><span class="lineNum">    6458 </span>            :        // to have there associated template declaration set properly, issue a warning for now.</a>
<a name="6459"><span class="lineNum">    6459 </span>            :        // declarationToSearchForInReferencedNameSet = templateInstantiationFunctionDecl-&gt;get_templateDeclaration();</a>
<a name="6460"><span class="lineNum">    6460 </span><span class="lineCov">       1899 :           if (templateInstantiationFunctionDecl-&gt;get_templateDeclaration() == NULL)</span></a>
<a name="6461"><span class="lineNum">    6461 </span>            :              {</a>
<a name="6462"><span class="lineNum">    6462 </span><span class="lineNoCov">          0 :                mfprintf(mlog [ WARN ] ) (&quot;WARNING: templateInstantiationFunctionDecl-&gt;get_templateDeclaration() == NULL for templateInstantiationFunctionDecl = %p = %s \n&quot;,</span></a>
<a name="6463"><span class="lineNum">    6463 </span><span class="lineNoCov">          0 :                     templateInstantiationFunctionDecl,templateInstantiationFunctionDecl-&gt;get_name().str());</span></a>
<a name="6464"><span class="lineNum">    6464 </span>            :              }</a>
<a name="6465"><span class="lineNum">    6465 </span>            :             else</a>
<a name="6466"><span class="lineNum">    6466 </span>            :              {</a>
<a name="6467"><span class="lineNum">    6467 </span><span class="lineCov">       1899 :                declarationToSearchForInReferencedNameSet = templateInstantiationFunctionDecl-&gt;get_templateDeclaration();</span></a>
<a name="6468"><span class="lineNum">    6468 </span>            :              }</a>
<a name="6469"><span class="lineNum">    6469 </span><span class="lineCov">       1899 :           ASSERT_not_null(declarationToSearchForInReferencedNameSet);</span></a>
<a name="6470"><span class="lineNum">    6470 </span>            :         }</a>
<a name="6471"><span class="lineNum">    6471 </span>            :        else</a>
<a name="6472"><span class="lineNum">    6472 </span>            :         {</a>
<a name="6473"><span class="lineNum">    6473 </span>            :        // Also test for member function.</a>
<a name="6474"><span class="lineNum">    6474 </span><span class="lineCov">    1215080 :           SgTemplateInstantiationMemberFunctionDecl* templateInstantiationMemberFunctionDecl = isSgTemplateInstantiationMemberFunctionDecl(declaration);</span></a>
<a name="6475"><span class="lineNum">    6475 </span><span class="lineCov">    1215080 :           if (templateInstantiationMemberFunctionDecl != NULL)</span></a>
<a name="6476"><span class="lineNum">    6476 </span>            :              {</a>
<a name="6477"><span class="lineNum">    6477 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="6478"><span class="lineNum">    6478 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;In skipNameQualificationIfNotProperlyDeclaredWhereDeclarationIsDefinable(): templateInstantiationMemberFunctionDecl-&gt;get_name() = %p = %s \n&quot;,</a>
<a name="6479"><span class="lineNum">    6479 </span>            :                     templateInstantiationMemberFunctionDecl,templateInstantiationMemberFunctionDecl-&gt;get_name().str());</a>
<a name="6480"><span class="lineNum">    6480 </span>            : #endif</a>
<a name="6481"><span class="lineNum">    6481 </span><span class="lineNoCov">          0 :                declarationToSearchForInReferencedNameSet = templateInstantiationMemberFunctionDecl-&gt;get_templateDeclaration();</span></a>
<a name="6482"><span class="lineNum">    6482 </span><span class="lineNoCov">          0 :                ASSERT_not_null(declarationToSearchForInReferencedNameSet);</span></a>
<a name="6483"><span class="lineNum">    6483 </span>            :              }</a>
<a name="6484"><span class="lineNum">    6484 </span>            :             else</a>
<a name="6485"><span class="lineNum">    6485 </span>            :              {</a>
<a name="6486"><span class="lineNum">    6486 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="6487"><span class="lineNum">    6487 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;In skipNameQualificationIfNotProperlyDeclaredWhereDeclarationIsDefinable(): This is not a template function instantation (member nor non-member function) \n&quot;);</a>
<a name="6488"><span class="lineNum">    6488 </span>            : #endif</a>
<a name="6489"><span class="lineNum">    6489 </span>            :              }</a>
<a name="6490"><span class="lineNum">    6490 </span>            :         }</a>
<a name="6491"><span class="lineNum">    6491 </span>            : </a>
<a name="6492"><span class="lineNum">    6492 </span>            :   // DQ (6/22/2011): This fixes test2011_97.C which only has a defining declaration so that the declaration-&gt;get_firstNondefiningDeclaration() was NULL.</a>
<a name="6493"><span class="lineNum">    6493 </span>            :   // if (referencedNameSet.find(declaration-&gt;get_firstNondefiningDeclaration()) == referencedNameSet.end())</a>
<a name="6494"><span class="lineNum">    6494 </span><span class="lineCov">    2433960 :      if (referencedNameSet.find(declarationToSearchForInReferencedNameSet) == referencedNameSet.end())</span></a>
<a name="6495"><span class="lineNum">    6495 </span>            :         {</a>
<a name="6496"><span class="lineNum">    6496 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="6497"><span class="lineNum">    6497 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;   --- $$$$$$$$$$ NOT Found: declaration %p = %s in referencedNameSet referencedNameSet.size() = %&quot; PRIuPTR &quot; \n&quot;,</a>
<a name="6498"><span class="lineNum">    6498 </span>            :                declaration,declaration-&gt;class_name().c_str(),referencedNameSet.size());</a>
<a name="6499"><span class="lineNum">    6499 </span>            : #endif</a>
<a name="6500"><span class="lineNum">    6500 </span><span class="lineCov">      10899 :           skipNameQualification = true;</span></a>
<a name="6501"><span class="lineNum">    6501 </span>            :         }</a>
<a name="6502"><span class="lineNum">    6502 </span>            :        else</a>
<a name="6503"><span class="lineNum">    6503 </span>            :         {</a>
<a name="6504"><span class="lineNum">    6504 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="6505"><span class="lineNum">    6505 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;   --- $$$$$$$$$$ FOUND: declaration %p = %s in referencedNameSet \n&quot;,declaration,declaration-&gt;class_name().c_str());</a>
<a name="6506"><span class="lineNum">    6506 </span>            : #endif</a>
<a name="6507"><span class="lineNum">    6507 </span>            :         }</a>
<a name="6508"><span class="lineNum">    6508 </span>            : </a>
<a name="6509"><span class="lineNum">    6509 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="6510"><span class="lineNum">    6510 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;Leaving skipNameQualificationIfNotProperlyDeclaredWhereDeclarationIsDefinable(): skipNameQualification = %s \n&quot;,skipNameQualification ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="6511"><span class="lineNum">    6511 </span>            : #endif</a>
<a name="6512"><span class="lineNum">    6512 </span>            : </a>
<a name="6513"><span class="lineNum">    6513 </span><span class="lineCov">    1216980 :      return skipNameQualification;</span></a>
<a name="6514"><span class="lineNum">    6514 </span>            :    }</a>
<a name="6515"><span class="lineNum">    6515 </span>            : </a>
<a name="6516"><span class="lineNum">    6516 </span>            : </a>
<a name="6517"><span class="lineNum">    6517 </span>            : // void NameQualificationTraversal::nameQualificationTypeSupport  ( SgType* type, SgScopeStatement* currentScope, SgInitializedName* initializedName, SgStatement* currentStatement, SgStatement* positionStatement )</a>
<a name="6518"><span class="lineNum">    6518 </span>            : void</a>
<a name="6519"><span class="lineNum">    6519 </span><span class="lineCov">    1462240 : NameQualificationTraversal::nameQualificationTypeSupport  ( SgType* type, SgScopeStatement* currentScope, SgInitializedName* initializedName )</span></a>
<a name="6520"><span class="lineNum">    6520 </span>            :    {</a>
<a name="6521"><span class="lineNum">    6521 </span>            :   // DQ (8/8/2020): this is code refactored from the evaluateInheritedAttribute() function within the SgInitializeName handling.</a>
<a name="6522"><span class="lineNum">    6522 </span>            :   // This code support the name qualification of the type associated with a SgInitializedName (it might be useful else where as well).</a>
<a name="6523"><span class="lineNum">    6523 </span>            : </a>
<a name="6524"><span class="lineNum">    6524 </span>            :        // else for type handling.</a>
<a name="6525"><span class="lineNum">    6525 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="6526"><span class="lineNum">    6526 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Case SgInitializedName: initializedName-&gt;get_type(): before stripType(): type = %p = %s \n&quot;,type,type-&gt;class_name().c_str());</a>
<a name="6527"><span class="lineNum">    6527 </span>            : #endif</a>
<a name="6528"><span class="lineNum">    6528 </span>            :        // DQ (4/15/2019): Reset the type so that we don't miss the SgPointerMemberType.</a>
<a name="6529"><span class="lineNum">    6529 </span>            :        // unsigned char bit_array = SgType::STRIP_MODIFIER_TYPE | SgType::STRIP_REFERENCE_TYPE | SgType::STRIP_RVALUE_REFERENCE_TYPE |</a>
<a name="6530"><span class="lineNum">    6530 </span>            :        //                           SgType::STRIP_POINTER_TYPE  | SgType::STRIP_POINTER_TYPE   | SgType::STRIP_ARRAY_TYPE;</a>
<a name="6531"><span class="lineNum">    6531 </span><span class="lineCov">    1462240 :           unsigned char bit_array = SgType::STRIP_MODIFIER_TYPE | SgType::STRIP_REFERENCE_TYPE | SgType::STRIP_RVALUE_REFERENCE_TYPE |</span></a>
<a name="6532"><span class="lineNum">    6532 </span>            :                                     SgType::STRIP_POINTER_TYPE  | SgType::STRIP_ARRAY_TYPE;</a>
<a name="6533"><span class="lineNum">    6533 </span><span class="lineCov">    1462240 :           type = type-&gt;stripType(bit_array);</span></a>
<a name="6534"><span class="lineNum">    6534 </span>            : </a>
<a name="6535"><span class="lineNum">    6535 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || DEBUG_INITIALIZED_NAME</a>
<a name="6536"><span class="lineNum">    6536 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Case SgInitializedName: initializedName-&gt;get_type(): after stripType(): type = %p = %s \n&quot;,type,type-&gt;class_name().c_str());</a>
<a name="6537"><span class="lineNum">    6537 </span>            : #endif</a>
<a name="6538"><span class="lineNum">    6538 </span>            : </a>
<a name="6539"><span class="lineNum">    6539 </span>            : </a>
<a name="6540"><span class="lineNum">    6540 </span>            : #if 0</a>
<a name="6541"><span class="lineNum">    6541 </span>            :        // DQ (4/17/2019): Need more general type support, required for more complex nesting of SgPointerMemberType types.</a>
<a name="6542"><span class="lineNum">    6542 </span>            : </a>
<a name="6543"><span class="lineNum">    6543 </span>            : #if 0</a>
<a name="6544"><span class="lineNum">    6544 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;######################################################## \n&quot;);</a>
<a name="6545"><span class="lineNum">    6545 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Case SgInitializedName: Checking for SgPointerMemberType \n&quot;);</a>
<a name="6546"><span class="lineNum">    6546 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;######################################################## \n&quot;);</a>
<a name="6547"><span class="lineNum">    6547 </span>            : #endif</a>
<a name="6548"><span class="lineNum">    6548 </span>            : </a>
<a name="6549"><span class="lineNum">    6549 </span>            :           SgPointerMemberType* pointerMemberType = isSgPointerMemberType(type);</a>
<a name="6550"><span class="lineNum">    6550 </span>            :           if (pointerMemberType != NULL)</a>
<a name="6551"><span class="lineNum">    6551 </span>            :              {</a>
<a name="6552"><span class="lineNum">    6552 </span>            :             // DQ (4/9/2019): If this is a pointer to member type then we will need name qualification for the SgInitializedName and its type.</a>
<a name="6553"><span class="lineNum">    6553 </span>            :             // The name qualification for the base type will be attached a the name qualification for the type, and the name qualification</a>
<a name="6554"><span class="lineNum">    6554 </span>            :             // for the pointer to member class will be attached to the SgInitializedName.</a>
<a name="6555"><span class="lineNum">    6555 </span>            : #if 0</a>
<a name="6556"><span class="lineNum">    6556 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;############################################################################## \n&quot;);</a>
<a name="6557"><span class="lineNum">    6557 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Case SgInitializedName: Processing the SgInitializedName IR node name directly \n&quot;);</a>
<a name="6558"><span class="lineNum">    6558 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;############################################################################## \n&quot;);</a>
<a name="6559"><span class="lineNum">    6559 </span>            : #endif</a>
<a name="6560"><span class="lineNum">    6560 </span>            : </a>
<a name="6561"><span class="lineNum">    6561 </span>            :             // DQ (4/11/2019): This is the old function API, but did not handle the case where the SgClassDefinition was not available.</a>
<a name="6562"><span class="lineNum">    6562 </span>            :             // SgClassDefinition* classDefinition = pointerMemberType-&gt;get_class_of();</a>
<a name="6563"><span class="lineNum">    6563 </span>            :                SgClassDeclaration* classDeclaration = isSgClassDeclaration(pointerMemberType-&gt;get_class_declaration_of());</a>
<a name="6564"><span class="lineNum">    6564 </span>            : </a>
<a name="6565"><span class="lineNum">    6565 </span>            :             // DQ (4/10/2019): The definition might not be available, but this means more that we should change the API to for</a>
<a name="6566"><span class="lineNum">    6566 </span>            :             // get_class_of() to return the SgClassDeclaration (and the firstNondefiing one if the defining declaration is not available).</a>
<a name="6567"><span class="lineNum">    6567 </span>            :             // ASSERT_not_null(classDefinition);</a>
<a name="6568"><span class="lineNum">    6568 </span>            :             // if (classDefinition != NULL)</a>
<a name="6569"><span class="lineNum">    6569 </span>            :                if (classDeclaration != NULL)</a>
<a name="6570"><span class="lineNum">    6570 </span>            :                   {</a>
<a name="6571"><span class="lineNum">    6571 </span>            :                  // SgClassDeclaration* classDeclaration = classDefinition-&gt;get_declaration();</a>
<a name="6572"><span class="lineNum">    6572 </span>            :                     ASSERT_not_null(classDeclaration);</a>
<a name="6573"><span class="lineNum">    6573 </span>            : </a>
<a name="6574"><span class="lineNum">    6574 </span>            :                     SgDeclarationStatement* declarationForInitializedName = classDeclaration;</a>
<a name="6575"><span class="lineNum">    6575 </span>            :                     ASSERT_not_null(declarationForInitializedName);</a>
<a name="6576"><span class="lineNum">    6576 </span>            : </a>
<a name="6577"><span class="lineNum">    6577 </span>            :                     SgDeclarationStatement* positionStatement = isSgDeclarationStatement(initializedName-&gt;get_parent());</a>
<a name="6578"><span class="lineNum">    6578 </span>            :                     ASSERT_not_null(positionStatement);</a>
<a name="6579"><span class="lineNum">    6579 </span>            : </a>
<a name="6580"><span class="lineNum">    6580 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="6581"><span class="lineNum">    6581 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Correcting associated declaration: declarationForInitializedName = %p = %s \n&quot;,declarationForInitializedName,declarationForInitializedName-&gt;class_name().c_str());</a>
<a name="6582"><span class="lineNum">    6582 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Correcting associated declaration: positionStatement = %p = %s \n&quot;,positionStatement,positionStatement-&gt;class_name().c_str());</a>
<a name="6583"><span class="lineNum">    6583 </span>            : #endif</a>
<a name="6584"><span class="lineNum">    6584 </span>            :                  // int amountOfNameQualificationRequiredForName = nameQualificationDepth(initializedName,currentScope,variableDeclaration);</a>
<a name="6585"><span class="lineNum">    6585 </span>            :                  // int amountOfNameQualificationRequiredForName = nameQualificationDepth(initializedName,currentScope,declarationForInitializedName);</a>
<a name="6586"><span class="lineNum">    6586 </span>            :                     int amountOfNameQualificationRequiredForName = nameQualificationDepth(declarationForInitializedName,currentScope,positionStatement);</a>
<a name="6587"><span class="lineNum">    6587 </span>            : </a>
<a name="6588"><span class="lineNum">    6588 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="6589"><span class="lineNum">    6589 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;SgInitializedName: SgPointerMemberType: name: amountOfNameQualificationRequiredForName = %d \n&quot;,amountOfNameQualificationRequiredForName);</a>
<a name="6590"><span class="lineNum">    6590 </span>            : #endif</a>
<a name="6591"><span class="lineNum">    6591 </span>            :                  // bool skipGlobalNameQualification = true;</a>
<a name="6592"><span class="lineNum">    6592 </span>            :                     bool skipGlobalNameQualification = false;</a>
<a name="6593"><span class="lineNum">    6593 </span>            :                  // setNameQualificationOnName(initializedName,declaration,amountOfNameQualificationRequiredForName,skipGlobalNameQualification);</a>
<a name="6594"><span class="lineNum">    6594 </span>            :                  // setNameQualificationOnName(initializedName,positionStatement,amountOfNameQualificationRequiredForName,skipGlobalNameQualification);</a>
<a name="6595"><span class="lineNum">    6595 </span>            :                     setNameQualificationOnName(initializedName,declarationForInitializedName,amountOfNameQualificationRequiredForName,skipGlobalNameQualification);</a>
<a name="6596"><span class="lineNum">    6596 </span>            :                   }</a>
<a name="6597"><span class="lineNum">    6597 </span>            :                  else</a>
<a name="6598"><span class="lineNum">    6598 </span>            :                   {</a>
<a name="6599"><span class="lineNum">    6599 </span>            :                  // DQ (4/11/2019): If this is not a SgClassDeclaration thenit can be a nonreal declaration which is not handled yet.</a>
<a name="6600"><span class="lineNum">    6600 </span>            :                   }</a>
<a name="6601"><span class="lineNum">    6601 </span>            :              }</a>
<a name="6602"><span class="lineNum">    6602 </span>            : #else</a>
<a name="6603"><span class="lineNum">    6603 </span>            : </a>
<a name="6604"><span class="lineNum">    6604 </span>            : #if 0</a>
<a name="6605"><span class="lineNum">    6605 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Commented out SgPointerMemberType code to compute the name qualification on the name (calling setNameQualificationOnName()) \n&quot;);</a>
<a name="6606"><span class="lineNum">    6606 </span>            : #endif</a>
<a name="6607"><span class="lineNum">    6607 </span>            : </a>
<a name="6608"><span class="lineNum">    6608 </span>            : #endif</a>
<a name="6609"><span class="lineNum">    6609 </span>            : </a>
<a name="6610"><span class="lineNum">    6610 </span>            : #if 0</a>
<a name="6611"><span class="lineNum">    6611 </span>            :        // DQ (3/31/2019): debugging support.</a>
<a name="6612"><span class="lineNum">    6612 </span>            :           if (debugging == true)</a>
<a name="6613"><span class="lineNum">    6613 </span>            :              {</a>
<a name="6614"><span class="lineNum">    6614 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="6615"><span class="lineNum">    6615 </span>            :                ROSE_ABORT();</a>
<a name="6616"><span class="lineNum">    6616 </span>            :              }</a>
<a name="6617"><span class="lineNum">    6617 </span>            : #endif</a>
<a name="6618"><span class="lineNum">    6618 </span><span class="lineCov">    1462240 :           SgStatement* currentStatement = TransformationSupport::getStatement(initializedName);</span></a>
<a name="6619"><span class="lineNum">    6619 </span><span class="lineCov">    1462240 :           ASSERT_not_null(currentStatement);</span></a>
<a name="6620"><span class="lineNum">    6620 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || 0</a>
<a name="6621"><span class="lineNum">    6621 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;case of SgInitializedName: currentStatement = %p = %s \n&quot;,currentStatement,currentStatement-&gt;class_name().c_str());</a>
<a name="6622"><span class="lineNum">    6622 </span>            : #endif</a>
<a name="6623"><span class="lineNum">    6623 </span>            : </a>
<a name="6624"><span class="lineNum">    6624 </span>            : #if DEBUG_INITIALIZED_NAME</a>
<a name="6625"><span class="lineNum">    6625 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;################################################################## \n&quot;);</a>
<a name="6626"><span class="lineNum">    6626 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Case SgInitializedName: Processing the SgInitializedName IR's type \n&quot;);</a>
<a name="6627"><span class="lineNum">    6627 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;################################################################## \n&quot;);</a>
<a name="6628"><span class="lineNum">    6628 </span>            : #endif</a>
<a name="6629"><span class="lineNum">    6629 </span>            : </a>
<a name="6630"><span class="lineNum">    6630 </span>            :        // DQ (4/19/2019): It might be that we should call this after the traveral over each type instead of before we traverse the type.</a>
<a name="6631"><span class="lineNum">    6631 </span>            :        // traverseType(initializedName-&gt;get_type(),initializedName,currentScope,currentStatement);</a>
<a name="6632"><span class="lineNum">    6632 </span>            : </a>
<a name="6633"><span class="lineNum">    6633 </span>            :        // DQ (4/19/2019): Added current statement to paremter list for recursive call.</a>
<a name="6634"><span class="lineNum">    6634 </span>            :        // DQ (4/18/2019): I think we need to traverse the type doing a proper type travesal, since it can consist of</a>
<a name="6635"><span class="lineNum">    6635 </span>            :        // long chains of types that each must be name qualified. The example of a chain of SgPointerToMemberTypes is</a>
<a name="6636"><span class="lineNum">    6636 </span>            :        // the best example of this.</a>
<a name="6637"><span class="lineNum">    6637 </span><span class="lineCov">    1462240 :           ASSERT_not_null(currentScope);</span></a>
<a name="6638"><span class="lineNum">    6638 </span>            : </a>
<a name="6639"><span class="lineNum">    6639 </span>            :        // DQ (4/27/2019): Refactored this code to be outside of the flase block below, so it can be used both there</a>
<a name="6640"><span class="lineNum">    6640 </span>            :        // and outside the false branch afterward.</a>
<a name="6641"><span class="lineNum">    6641 </span><span class="lineCov">    1462240 :           SgDeclarationStatement* declaration = getDeclarationAssociatedWithType(initializedName-&gt;get_type());</span></a>
<a name="6642"><span class="lineNum">    6642 </span>            : </a>
<a name="6643"><span class="lineNum">    6643 </span>            :        // DQ (4/22/2019): If we have resolved the type (after stripType() function) to a SgPointerMemberType, then</a>
<a name="6644"><span class="lineNum">    6644 </span>            :        // we need to traverse the type using a type traversal.  Else we can handle it normally.</a>
<a name="6645"><span class="lineNum">    6645 </span>            :        // generateNestedTraversalWithExplicitScope(type,currentScope,currentStatement,initializedName);</a>
<a name="6646"><span class="lineNum">    6646 </span>            :        // traverseType(initializedName-&gt;get_type(),initializedName,currentScope,currentStatement);</a>
<a name="6647"><span class="lineNum">    6647 </span><span class="lineCov">    1462240 :           SgPointerMemberType* pointerMemberType = isSgPointerMemberType(type);</span></a>
<a name="6648"><span class="lineNum">    6648 </span><span class="lineCov">    1462240 :           if (pointerMemberType != NULL)</span></a>
<a name="6649"><span class="lineNum">    6649 </span>            :              {</a>
<a name="6650"><span class="lineNum">    6650 </span>            : #if DEBUG_INITIALIZED_NAME</a>
<a name="6651"><span class="lineNum">    6651 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;########################################################################## \n&quot;);</a>
<a name="6652"><span class="lineNum">    6652 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Case SgInitializedName: Calling generateNestedTraversalWithExplicitScope() \n&quot;);</a>
<a name="6653"><span class="lineNum">    6653 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;########################################################################## \n&quot;);</a>
<a name="6654"><span class="lineNum">    6654 </span>            : #endif</a>
<a name="6655"><span class="lineNum">    6655 </span><span class="lineCov">        360 :                generateNestedTraversalWithExplicitScope(type,currentScope,currentStatement,initializedName);</span></a>
<a name="6656"><span class="lineNum">    6656 </span>            : </a>
<a name="6657"><span class="lineNum">    6657 </span>            :             // DQ (4/19/2019): It might be that we should call this after the traveral over each type instead of before we traverse the type.</a>
<a name="6658"><span class="lineNum">    6658 </span>            :             // This way we save the correctly computed string for each type after the different parts of name qualificaiton are in place.</a>
<a name="6659"><span class="lineNum">    6659 </span><span class="lineCov">        360 :                traverseType(initializedName-&gt;get_type(),initializedName,currentScope,currentStatement);</span></a>
<a name="6660"><span class="lineNum">    6660 </span>            : </a>
<a name="6661"><span class="lineNum">    6661 </span>            : #if DEBUG_INITIALIZED_NAME</a>
<a name="6662"><span class="lineNum">    6662 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;#################################################################################################### \n&quot;);</a>
<a name="6663"><span class="lineNum">    6663 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Case SgInitializedName: DONE: Processing the recursive evaluation of the SgInitializedName IR's type \n&quot;);</a>
<a name="6664"><span class="lineNum">    6664 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;#################################################################################################### \n&quot;);</a>
<a name="6665"><span class="lineNum">    6665 </span>            : #endif</a>
<a name="6666"><span class="lineNum">    6666 </span>            :              }</a>
<a name="6667"><span class="lineNum">    6667 </span>            :             else</a>
<a name="6668"><span class="lineNum">    6668 </span>            :              {</a>
<a name="6669"><span class="lineNum">    6669 </span>            : #if DEBUG_INITIALIZED_NAME</a>
<a name="6670"><span class="lineNum">    6670 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Normal processing of type (no recursive call to evaluate the type) \n&quot;);</a>
<a name="6671"><span class="lineNum">    6671 </span>            : #endif</a>
<a name="6672"><span class="lineNum">    6672 </span>            :             // The code for the normal processing of the type is below.</a>
<a name="6673"><span class="lineNum">    6673 </span>            : </a>
<a name="6674"><span class="lineNum">    6674 </span>            : #if DEBUG_INITIALIZED_NAME</a>
<a name="6675"><span class="lineNum">    6675 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;######################################################################### \n&quot;);</a>
<a name="6676"><span class="lineNum">    6676 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Case SgInitializedName: Normal Processing the SgInitializedName IR's type \n&quot;);</a>
<a name="6677"><span class="lineNum">    6677 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;######################################################################### \n&quot;);</a>
<a name="6678"><span class="lineNum">    6678 </span>            : #endif</a>
<a name="6679"><span class="lineNum">    6679 </span>            : </a>
<a name="6680"><span class="lineNum">    6680 </span>            : #if 0</a>
<a name="6681"><span class="lineNum">    6681 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="6682"><span class="lineNum">    6682 </span>            :                ROSE_ABORT();</a>
<a name="6683"><span class="lineNum">    6683 </span>            : #endif</a>
<a name="6684"><span class="lineNum">    6684 </span>            : </a>
<a name="6685"><span class="lineNum">    6685 </span>            : #if 0</a>
<a name="6686"><span class="lineNum">    6686 </span>            :             // DQ (4/27/2019): I really want to put this &quot;}&quot; at the end of where the initializedName's type is processed.</a>
<a name="6687"><span class="lineNum">    6687 </span>            :             // }</a>
<a name="6688"><span class="lineNum">    6688 </span>            : #endif</a>
<a name="6689"><span class="lineNum">    6689 </span>            : </a>
<a name="6690"><span class="lineNum">    6690 </span>            : #if 0</a>
<a name="6691"><span class="lineNum">    6691 </span>            :             // DQ (3/31/2019): debugging support.</a>
<a name="6692"><span class="lineNum">    6692 </span>            :                if (debugging == true)</a>
<a name="6693"><span class="lineNum">    6693 </span>            :                   {</a>
<a name="6694"><span class="lineNum">    6694 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="6695"><span class="lineNum">    6695 </span>            :                     ROSE_ABORT();</a>
<a name="6696"><span class="lineNum">    6696 </span>            :                   }</a>
<a name="6697"><span class="lineNum">    6697 </span>            : #endif</a>
<a name="6698"><span class="lineNum">    6698 </span>            : </a>
<a name="6699"><span class="lineNum">    6699 </span>            :             // DQ (4/27/2019): refactoring: As a result of the block processing of the type being extended, and this variable</a>
<a name="6700"><span class="lineNum">    6700 </span>            :             // being used outside of that block, we need to move this variable declaration to be outside of this block at the</a>
<a name="6701"><span class="lineNum">    6701 </span>            :             // top of this block.</a>
<a name="6702"><span class="lineNum">    6702 </span>            :             // We want to handle types from every where a SgInitializedName might be used.</a>
<a name="6703"><span class="lineNum">    6703 </span>            :             // SgDeclarationStatement* declaration = getDeclarationAssociatedWithType(initializedName-&gt;get_type());</a>
<a name="6704"><span class="lineNum">    6704 </span>            : </a>
<a name="6705"><span class="lineNum">    6705 </span>            :             // DQ (4/22/2019): If there is a SgPointerMemberType, then don't processs as a normal type.</a>
<a name="6706"><span class="lineNum">    6706 </span><span class="lineCov">    1461880 :                if (pointerMemberType != NULL)</span></a>
<a name="6707"><span class="lineNum">    6707 </span>            :                   {</a>
<a name="6708"><span class="lineNum">    6708 </span>            :                     if (declaration != NULL)</a>
<a name="6709"><span class="lineNum">    6709 </span>            :                        {</a>
<a name="6710"><span class="lineNum">    6710 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;None null declaration where detected valid SgPointerMemberType: declaration = %p = %s \n&quot;,declaration,declaration-&gt;class_name().c_str());</a>
<a name="6711"><span class="lineNum">    6711 </span>            :                        }</a>
<a name="6712"><span class="lineNum">    6712 </span>            :                     ROSE_ASSERT(declaration == NULL);</a>
<a name="6713"><span class="lineNum">    6713 </span>            :                   }</a>
<a name="6714"><span class="lineNum">    6714 </span>            : </a>
<a name="6715"><span class="lineNum">    6715 </span>            : </a>
<a name="6716"><span class="lineNum">    6716 </span>            : #if 0</a>
<a name="6717"><span class="lineNum">    6717 </span>            :             // SgPointerMemberType* pointerMemberType = isSgPointerMemberType(initializedName-&gt;get_type());</a>
<a name="6718"><span class="lineNum">    6718 </span>            :                if (pointerMemberType != NULL)</a>
<a name="6719"><span class="lineNum">    6719 </span>            :                   {</a>
<a name="6720"><span class="lineNum">    6720 </span>            :                     SgType* baseType = pointerMemberType-&gt;get_base_type();</a>
<a name="6721"><span class="lineNum">    6721 </span>            :                     ASSERT_not_null(baseType);</a>
<a name="6722"><span class="lineNum">    6722 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="6723"><span class="lineNum">    6723 </span>            :                     SgMemberFunctionType* memberFunctionType = isSgMemberFunctionType(baseType);</a>
<a name="6724"><span class="lineNum">    6724 </span>            :                     if (memberFunctionType != NULL)</a>
<a name="6725"><span class="lineNum">    6725 </span>            :                        {</a>
<a name="6726"><span class="lineNum">    6726 </span>            :                          SgType* returnType = memberFunctionType-&gt;get_return_type();</a>
<a name="6727"><span class="lineNum">    6727 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="6728"><span class="lineNum">    6728 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;Case of SgPointerMemberType: Reset associated declaration: returnType = %p = %s \n&quot;,returnType,returnType-&gt;class_name().c_str());</a>
<a name="6729"><span class="lineNum">    6729 </span>            : #endif</a>
<a name="6730"><span class="lineNum">    6730 </span>            :                          ASSERT_not_null(returnType);</a>
<a name="6731"><span class="lineNum">    6731 </span>            :                       // declaration = getDeclarationAssociatedWithType(memberFunctionType-&gt;get_return_type());</a>
<a name="6732"><span class="lineNum">    6732 </span>            :                          declaration = getDeclarationAssociatedWithType(returnType);</a>
<a name="6733"><span class="lineNum">    6733 </span>            :                        }</a>
<a name="6734"><span class="lineNum">    6734 </span>            :                       else</a>
<a name="6735"><span class="lineNum">    6735 </span>            :                        {</a>
<a name="6736"><span class="lineNum">    6736 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="6737"><span class="lineNum">    6737 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;Case of SgPointerMemberType: Reset associated declaration: baseType = %p = %s \n&quot;,baseType,baseType-&gt;class_name().c_str());</a>
<a name="6738"><span class="lineNum">    6738 </span>            : #endif</a>
<a name="6739"><span class="lineNum">    6739 </span>            :                          declaration = getDeclarationAssociatedWithType(baseType);</a>
<a name="6740"><span class="lineNum">    6740 </span>            :                        }</a>
<a name="6741"><span class="lineNum">    6741 </span>            :                   }</a>
<a name="6742"><span class="lineNum">    6742 </span>            : #else</a>
<a name="6743"><span class="lineNum">    6743 </span>            : </a>
<a name="6744"><span class="lineNum">    6744 </span>            : #if 0</a>
<a name="6745"><span class="lineNum">    6745 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Commented out SgPointerMemberType code to compute the associated declaration \n&quot;);</a>
<a name="6746"><span class="lineNum">    6746 </span>            : #endif</a>
<a name="6747"><span class="lineNum">    6747 </span>            : </a>
<a name="6748"><span class="lineNum">    6748 </span>            : #endif</a>
<a name="6749"><span class="lineNum">    6749 </span>            : </a>
<a name="6750"><span class="lineNum">    6750 </span>            : #if 1</a>
<a name="6751"><span class="lineNum">    6751 </span>            :             // DQ (4/14/2019): Add support for declType.</a>
<a name="6752"><span class="lineNum">    6752 </span>            : </a>
<a name="6753"><span class="lineNum">    6753 </span>            :             // DQ (4/14/2019): An alternative might be to support this in the getDeclarationAssociatedWithType() function.</a>
<a name="6754"><span class="lineNum">    6754 </span>            : </a>
<a name="6755"><span class="lineNum">    6755 </span><span class="lineCov">    1461880 :                SgDeclType* declType = isSgDeclType(type);</span></a>
<a name="6756"><span class="lineNum">    6756 </span><span class="lineCov">    1461880 :                if (declType != NULL)</span></a>
<a name="6757"><span class="lineNum">    6757 </span>            :                   {</a>
<a name="6758"><span class="lineNum">    6758 </span>            :                  // Not clear if we need to worry about when the base type of the SgPointerMemberType is a SgDeclType.</a>
<a name="6759"><span class="lineNum">    6759 </span>            : #if 0</a>
<a name="6760"><span class="lineNum">    6760 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;################################################################################## \n&quot;);</a>
<a name="6761"><span class="lineNum">    6761 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Case SgInitializedName: Processing the SgInitializedName decltype IR node directly \n&quot;);</a>
<a name="6762"><span class="lineNum">    6762 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;################################################################################## \n&quot;);</a>
<a name="6763"><span class="lineNum">    6763 </span>            : #endif</a>
<a name="6764"><span class="lineNum">    6764 </span>            : </a>
<a name="6765"><span class="lineNum">    6765 </span>            :                  // We need to handle any possible name qualification of a type or SgVarRefExp used as decltype argument.</a>
<a name="6766"><span class="lineNum">    6766 </span><span class="lineCov">        143 :                     SgExpression* baseExpression = declType-&gt;get_base_expression();</span></a>
<a name="6767"><span class="lineNum">    6767 </span><span class="lineCov">        143 :                     SgType*       baseType       = declType-&gt;get_base_type();</span></a>
<a name="6768"><span class="lineNum">    6768 </span><span class="lineCov">        143 :                     if (baseExpression != NULL)</span></a>
<a name="6769"><span class="lineNum">    6769 </span>            :                        {</a>
<a name="6770"><span class="lineNum">    6770 </span>            :                       // Need name qualification for expression used in decltype().</a>
<a name="6771"><span class="lineNum">    6771 </span>            : #if 0</a>
<a name="6772"><span class="lineNum">    6772 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;Make a recursive call from this context (processing decltype taking SgExpression) \n&quot;);</a>
<a name="6773"><span class="lineNum">    6773 </span>            : #endif</a>
<a name="6774"><span class="lineNum">    6774 </span>            :                       // DQ (8/8/2020): Removed reference to &quot;n&quot;.</a>
<a name="6775"><span class="lineNum">    6775 </span>            :                       // DQ (6/30/2013): Added to support using generateNestedTraversalWithExplicitScope() instead of generateNameQualificationSupport().</a>
<a name="6776"><span class="lineNum">    6776 </span>            :                       // SgStatement* currentStatement = TransformationSupport::getStatement(n);</a>
<a name="6777"><span class="lineNum">    6777 </span><span class="lineCov">        143 :                          SgStatement* currentStatement = TransformationSupport::getStatement(initializedName);</span></a>
<a name="6778"><span class="lineNum">    6778 </span>            : #if 0</a>
<a name="6779"><span class="lineNum">    6779 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;SgInitializedName: decltype: currentStatement = %p = %s \n&quot;,currentStatement,currentStatement != NULL ? currentStatement-&gt;class_name().c_str() : &quot;null&quot;);</a>
<a name="6780"><span class="lineNum">    6780 </span>            : #endif</a>
<a name="6781"><span class="lineNum">    6781 </span>            : #if 0</a>
<a name="6782"><span class="lineNum">    6782 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! (before recursive call) \n&quot;);</a>
<a name="6783"><span class="lineNum">    6783 </span>            :                          ROSE_ABORT();</a>
<a name="6784"><span class="lineNum">    6784 </span>            : #endif</a>
<a name="6785"><span class="lineNum">    6785 </span>            :                       // DQ (9/14/2015): Added debugging code.</a>
<a name="6786"><span class="lineNum">    6786 </span>            :                       // DQ (9/14/2015): This can be an expression in a type, in which case we don't have an associated scope.</a>
<a name="6787"><span class="lineNum">    6787 </span><span class="lineCov">        143 :                          if (currentStatement == NULL)</span></a>
<a name="6788"><span class="lineNum">    6788 </span>            :                             {</a>
<a name="6789"><span class="lineNum">    6789 </span>            :                            // This can be an expression in a type, in which case we don't have an associated scope.</a>
<a name="6790"><span class="lineNum">    6790 </span><span class="lineNoCov">          0 :                               mfprintf(mlog [ WARN ] ) (&quot;Note: This can be an expression in a type, in which case we don't have an associated scope: baseExpression = %p = %s \n&quot;,</span></a>
<a name="6791"><span class="lineNum">    6791 </span><span class="lineNoCov">          0 :                                       baseExpression,baseExpression-&gt;class_name().c_str());</span></a>
<a name="6792"><span class="lineNum">    6792 </span>            :                             }</a>
<a name="6793"><span class="lineNum">    6793 </span>            :                            else</a>
<a name="6794"><span class="lineNum">    6794 </span>            :                             {</a>
<a name="6795"><span class="lineNum">    6795 </span><span class="lineCov">        143 :                               ASSERT_not_null(currentStatement);</span></a>
<a name="6796"><span class="lineNum">    6796 </span><span class="lineCov">        143 :                               SgScopeStatement* currentScope = currentStatement-&gt;get_scope();</span></a>
<a name="6797"><span class="lineNum">    6797 </span><span class="lineCov">        143 :                               ASSERT_not_null(currentScope);</span></a>
<a name="6798"><span class="lineNum">    6798 </span>            : #if 0</a>
<a name="6799"><span class="lineNum">    6799 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;SgInitializedName: currentScope = %p = %s \n&quot;,currentScope,currentScope-&gt;class_name().c_str());</a>
<a name="6800"><span class="lineNum">    6800 </span>            : #endif</a>
<a name="6801"><span class="lineNum">    6801 </span>            :                            // DQ (6/30/2013): For the recursive call use generateNestedTraversalWithExplicitScope() instead of generateNameQualificationSupport().</a>
<a name="6802"><span class="lineNum">    6802 </span>            :                            // generateNameQualificationSupport(originalExpressionTree,referencedNameSet);</a>
<a name="6803"><span class="lineNum">    6803 </span><span class="lineCov">        143 :                               generateNestedTraversalWithExplicitScope(baseExpression,currentScope);</span></a>
<a name="6804"><span class="lineNum">    6804 </span>            :                             }</a>
<a name="6805"><span class="lineNum">    6805 </span>            : #if 0</a>
<a name="6806"><span class="lineNum">    6806 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! (after recursive call) \n&quot;);</a>
<a name="6807"><span class="lineNum">    6807 </span>            :                          ROSE_ABORT();</a>
<a name="6808"><span class="lineNum">    6808 </span>            : #endif</a>
<a name="6809"><span class="lineNum">    6809 </span>            :                        }</a>
<a name="6810"><span class="lineNum">    6810 </span>            :                       else</a>
<a name="6811"><span class="lineNum">    6811 </span>            :                        {</a>
<a name="6812"><span class="lineNum">    6812 </span>            :                       // Need name qualification for type used in decltype().  Not clear what I good example is of this!</a>
<a name="6813"><span class="lineNum">    6813 </span><span class="lineNoCov">          0 :                          ASSERT_not_null(baseType);</span></a>
<a name="6814"><span class="lineNum">    6814 </span>            : #if 0</a>
<a name="6815"><span class="lineNum">    6815 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;REPORT ME: Unknow case: SgInitializedName: decltype: calling getDeclarationAssociatedWithType(): baseType = %p = %s \n&quot;,baseType,baseType-&gt;class_name().c_str());</a>
<a name="6816"><span class="lineNum">    6816 </span>            : #endif</a>
<a name="6817"><span class="lineNum">    6817 </span><span class="lineNoCov">          0 :                          declaration = getDeclarationAssociatedWithType(baseType);</span></a>
<a name="6818"><span class="lineNum">    6818 </span>            : #if 0</a>
<a name="6819"><span class="lineNum">    6819 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="6820"><span class="lineNum">    6820 </span>            :                          ROSE_ABORT();</a>
<a name="6821"><span class="lineNum">    6821 </span>            : #endif</a>
<a name="6822"><span class="lineNum">    6822 </span>            :                        }</a>
<a name="6823"><span class="lineNum">    6823 </span>            :                   }</a>
<a name="6824"><span class="lineNum">    6824 </span>            : #else</a>
<a name="6825"><span class="lineNum">    6825 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Commented out code specific to support of SgDeclType \n&quot;);</a>
<a name="6826"><span class="lineNum">    6826 </span>            : #endif</a>
<a name="6827"><span class="lineNum">    6827 </span>            : </a>
<a name="6828"><span class="lineNum">    6828 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="6829"><span class="lineNum">    6829 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Case of SgInitializedName: getDeclarationAssociatedWithType(): type = %p = %s declaration = %p \n&quot;,initializedName-&gt;get_type(),initializedName-&gt;get_type()-&gt;class_name().c_str(),declaration);</a>
<a name="6830"><span class="lineNum">    6830 </span>            : #endif</a>
<a name="6831"><span class="lineNum">    6831 </span>            : </a>
<a name="6832"><span class="lineNum">    6832 </span>            :             // DQ (4/22/2019): The detect of a SgPointerMemberType will force a type traversal, which means</a>
<a name="6833"><span class="lineNum">    6833 </span>            :             // we don't process the type as a normal type.  Even if it has a valid declaration.</a>
<a name="6834"><span class="lineNum">    6834 </span>            :             // Note: &quot;Normal Type&quot; in the name below means not having pointer to member types and being</a>
<a name="6835"><span class="lineNum">    6835 </span>            :             // a type derived from a declaration.</a>
<a name="6836"><span class="lineNum">    6836 </span><span class="lineCov">    1461880 :                bool processAsNormalTypeThatMightRequireNameQualification = ((pointerMemberType == NULL) &amp;&amp; (declaration != NULL));</span></a>
<a name="6837"><span class="lineNum">    6837 </span>            : </a>
<a name="6838"><span class="lineNum">    6838 </span>            : #if 0</a>
<a name="6839"><span class="lineNum">    6839 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Need to dig deeper past modifiers, etc. to find possible array types \n&quot;);</a>
<a name="6840"><span class="lineNum">    6840 </span>            : </a>
<a name="6841"><span class="lineNum">    6841 </span>            :             // DQ (4/27/2019): I don't think we want to force this through the true branch below.</a>
<a name="6842"><span class="lineNum">    6842 </span>            :                SgArrayType* arrayType = isSgArrayType(initializedName-&gt;get_type());</a>
<a name="6843"><span class="lineNum">    6843 </span>            :                if (arrayType != NULL)</a>
<a name="6844"><span class="lineNum">    6844 </span>            :                   {</a>
<a name="6845"><span class="lineNum">    6845 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Process the SgArrayType to find name qualification (for the index more than for the type) \n&quot;);</a>
<a name="6846"><span class="lineNum">    6846 </span>            : </a>
<a name="6847"><span class="lineNum">    6847 </span>            :                     processAsNormalTypeThatMightRequireNameQualification = true;</a>
<a name="6848"><span class="lineNum">    6848 </span>            :                   }</a>
<a name="6849"><span class="lineNum">    6849 </span>            : #endif</a>
<a name="6850"><span class="lineNum">    6850 </span>            : </a>
<a name="6851"><span class="lineNum">    6851 </span>            : #if DEBUG_INITIALIZED_NAME || 0</a>
<a name="6852"><span class="lineNum">    6852 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;processAsNormalTypeThatMightRequireNameQualification = %s \n&quot;,processAsNormalTypeThatMightRequireNameQualification ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="6853"><span class="lineNum">    6853 </span>            : #endif</a>
<a name="6854"><span class="lineNum">    6854 </span>            :             // if (declaration != NULL)</a>
<a name="6855"><span class="lineNum">    6855 </span><span class="lineCov">    1461880 :                if (processAsNormalTypeThatMightRequireNameQualification == true)</span></a>
<a name="6856"><span class="lineNum">    6856 </span>            :                   {</a>
<a name="6857"><span class="lineNum">    6857 </span><span class="lineCov">    1209960 :                     SgStatement* currentStatement = TransformationSupport::getStatement(initializedName);</span></a>
<a name="6858"><span class="lineNum">    6858 </span><span class="lineCov">    1209960 :                     ASSERT_not_null(currentStatement);</span></a>
<a name="6859"><span class="lineNum">    6859 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || DEBUG_INITIALIZED_NAME</a>
<a name="6860"><span class="lineNum">    6860 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;case of SgInitializedName: currentStatement = %p = %s \n&quot;,currentStatement,currentStatement-&gt;class_name().c_str());</a>
<a name="6861"><span class="lineNum">    6861 </span>            : #endif</a>
<a name="6862"><span class="lineNum">    6862 </span><span class="lineCov">    1209960 :                     SgScopeStatement* currentScope = currentStatement-&gt;get_scope();</span></a>
<a name="6863"><span class="lineNum">    6863 </span><span class="lineCov">    1209960 :                     ASSERT_not_null(currentScope);</span></a>
<a name="6864"><span class="lineNum">    6864 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || DEBUG_INITIALIZED_NAME</a>
<a name="6865"><span class="lineNum">    6865 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;case of SgInitializedName: currentScope = %p = %s \n&quot;,currentScope,currentScope-&gt;class_name().c_str());</a>
<a name="6866"><span class="lineNum">    6866 </span>            : #endif</a>
<a name="6867"><span class="lineNum">    6867 </span>            :                  // DQ (2/21/2019): The constructor initializers need to start their name qualification from the class declaration.</a>
<a name="6868"><span class="lineNum">    6868 </span>            :                  // bool debugging = false;</a>
<a name="6869"><span class="lineNum">    6869 </span><span class="lineCov">    1209960 :                     SgCtorInitializerList* ctorInitializerList = isSgCtorInitializerList(initializedName-&gt;get_parent());</span></a>
<a name="6870"><span class="lineNum">    6870 </span><span class="lineCov">    1209960 :                     if (ctorInitializerList != NULL)</span></a>
<a name="6871"><span class="lineNum">    6871 </span>            :                        {</a>
<a name="6872"><span class="lineNum">    6872 </span><span class="lineCov">       2228 :                          SgClassDefinition* classDefinition = isSgClassDefinition(initializedName-&gt;get_scope());</span></a>
<a name="6873"><span class="lineNum">    6873 </span>            : #if 0</a>
<a name="6874"><span class="lineNum">    6874 </span>            :                       // DQ (2/21/2019): This is either a SgDeclarationScope or a SgClassDefinition.</a>
<a name="6875"><span class="lineNum">    6875 </span>            :                          if (classDefinition == NULL)</a>
<a name="6876"><span class="lineNum">    6876 </span>            :                             {</a>
<a name="6877"><span class="lineNum">    6877 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;case SgInitializedName: initializedName-&gt;get_scope(): classDefinition == NULL: initializedName-&gt;get_scope() = %p = %s \n&quot;,</a>
<a name="6878"><span class="lineNum">    6878 </span>            :                                    initializedName-&gt;get_scope(),initializedName-&gt;get_scope()-&gt;class_name().c_str());</a>
<a name="6879"><span class="lineNum">    6879 </span>            :                             }</a>
<a name="6880"><span class="lineNum">    6880 </span>            :                       // ASSERT_not_null(classDefinition);</a>
<a name="6881"><span class="lineNum">    6881 </span>            : #endif</a>
<a name="6882"><span class="lineNum">    6882 </span><span class="lineCov">       2228 :                          if (classDefinition != NULL)</span></a>
<a name="6883"><span class="lineNum">    6883 </span>            :                             {</a>
<a name="6884"><span class="lineNum">    6884 </span><span class="lineCov">       2228 :                               SgClassDeclaration* classDeclaration = classDefinition-&gt;get_declaration();</span></a>
<a name="6885"><span class="lineNum">    6885 </span><span class="lineCov">       2228 :                               ASSERT_not_null(classDeclaration);</span></a>
<a name="6886"><span class="lineNum">    6886 </span>            : </a>
<a name="6887"><span class="lineNum">    6887 </span><span class="lineCov">       2228 :                               currentScope = classDeclaration-&gt;get_scope();</span></a>
<a name="6888"><span class="lineNum">    6888 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="6889"><span class="lineNum">    6889 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;Found case of SgInitializedName in constructor preinitialization list: currentScope = %p = %s \n&quot;,</a>
<a name="6890"><span class="lineNum">    6890 </span>            :                                    currentScope,currentScope-&gt;class_name().c_str());</a>
<a name="6891"><span class="lineNum">    6891 </span>            : #endif</a>
<a name="6892"><span class="lineNum">    6892 </span>            :                             }</a>
<a name="6893"><span class="lineNum">    6893 </span>            :                       // debugging = true;</a>
<a name="6894"><span class="lineNum">    6894 </span>            :                        }</a>
<a name="6895"><span class="lineNum">    6895 </span>            : </a>
<a name="6896"><span class="lineNum">    6896 </span>            :                  // int amountOfNameQualificationRequiredForType = nameQualificationDepthForType(initializedName,currentScope,currentStatement);</a>
<a name="6897"><span class="lineNum">    6897 </span>            :                  // int amountOfNameQualificationRequiredForType = nameQualificationDepthForType(initializedName,currentStatement);</a>
<a name="6898"><span class="lineNum">    6898 </span><span class="lineCov">    1209960 :                     int amountOfNameQualificationRequiredForType = nameQualificationDepthForType(initializedName,currentScope,currentStatement);</span></a>
<a name="6899"><span class="lineNum">    6899 </span>            : </a>
<a name="6900"><span class="lineNum">    6900 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || DEBUG_INITIALIZED_NAME</a>
<a name="6901"><span class="lineNum">    6901 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;SgInitializedName's (%s) type: amountOfNameQualificationRequiredForType = %d \n&quot;,</a>
<a name="6902"><span class="lineNum">    6902 </span>            :                          initializedName-&gt;get_name().str(),amountOfNameQualificationRequiredForType);</a>
<a name="6903"><span class="lineNum">    6903 </span>            : #endif</a>
<a name="6904"><span class="lineNum">    6904 </span>            : #if 0</a>
<a name="6905"><span class="lineNum">    6905 </span>            :                  // DQ (1/3/2020): Debugging code for Cxx11_tests/test2020_07.C.</a>
<a name="6906"><span class="lineNum">    6906 </span>            :                     if (initializedName-&gt;get_name() == &quot;var_2&quot;)</a>
<a name="6907"><span class="lineNum">    6907 </span>            :                        {</a>
<a name="6908"><span class="lineNum">    6908 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="6909"><span class="lineNum">    6909 </span>            :                          ROSE_ABORT();</a>
<a name="6910"><span class="lineNum">    6910 </span>            :                        }</a>
<a name="6911"><span class="lineNum">    6911 </span>            : #endif</a>
<a name="6912"><span class="lineNum">    6912 </span>            : #if 1</a>
<a name="6913"><span class="lineNum">    6913 </span>            :                  // DQ (8/4/2012): This is redundant code with where the SgInitializedName appears in the SgVariableDeclaration.</a>
<a name="6914"><span class="lineNum">    6914 </span>            :                  // **************************************************</a>
<a name="6915"><span class="lineNum">    6915 </span>            :                  // DQ (8/4/2012): The type being used might not have to be qualified if it is associated with a SgClassDeclaration</a>
<a name="6916"><span class="lineNum">    6916 </span>            :                  // that has not been defined yet.  This fixes test2012_165.C.</a>
<a name="6917"><span class="lineNum">    6917 </span>            :                  // **************************************************</a>
<a name="6918"><span class="lineNum">    6918 </span><span class="lineCov">    1209960 :                     bool skipGlobalNameQualification = skipNameQualificationIfNotProperlyDeclaredWhereDeclarationIsDefinable(declaration);</span></a>
<a name="6919"><span class="lineNum">    6919 </span>            : </a>
<a name="6920"><span class="lineNum">    6920 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="6921"><span class="lineNum">    6921 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;case of SgInitializedName: currentScope = %p = %s \n&quot;,currentScope,currentScope-&gt;class_name().c_str());</a>
<a name="6922"><span class="lineNum">    6922 </span>            : #endif</a>
<a name="6923"><span class="lineNum">    6923 </span>            : #if 0</a>
<a name="6924"><span class="lineNum">    6924 </span>            :                  // DQ (2/21/2019): debugging support.</a>
<a name="6925"><span class="lineNum">    6925 </span>            :                     if (debugging == true)</a>
<a name="6926"><span class="lineNum">    6926 </span>            :                        {</a>
<a name="6927"><span class="lineNum">    6927 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="6928"><span class="lineNum">    6928 </span>            :                          ROSE_ABORT();</a>
<a name="6929"><span class="lineNum">    6929 </span>            :                        }</a>
<a name="6930"><span class="lineNum">    6930 </span>            : #endif</a>
<a name="6931"><span class="lineNum">    6931 </span>            :                  // DQ (8/4/2012): However, this quasi-pathological case does not apply to template instantiations</a>
<a name="6932"><span class="lineNum">    6932 </span>            :                  // (only non-template classes or maybe named types more generally?).  Handle template declarations similarly.</a>
<a name="6933"><span class="lineNum">    6933 </span>            :                  // OR enum declarations (since they can have a forward declaration (except that this is a common languae extension...).</a>
<a name="6934"><span class="lineNum">    6934 </span><span class="lineCov">    1209960 :                     if (isSgTemplateInstantiationDecl(declaration) != NULL || isSgEnumDeclaration(declaration) != NULL || isSgNonrealDecl(declaration) != NULL)</span></a>
<a name="6935"><span class="lineNum">    6935 </span>            :                        {</a>
<a name="6936"><span class="lineNum">    6936 </span>            :                       // Do the regularly schedule name qualification for these cases.</a>
<a name="6937"><span class="lineNum">    6937 </span>            :                          skipGlobalNameQualification = false;</a>
<a name="6938"><span class="lineNum">    6938 </span>            :                        }</a>
<a name="6939"><span class="lineNum">    6939 </span>            :                       else</a>
<a name="6940"><span class="lineNum">    6940 </span>            :                        {</a>
<a name="6941"><span class="lineNum">    6941 </span>            :                       // Look back through the scopes and see if we are in a template instantiation or template scope,</a>
<a name="6942"><span class="lineNum">    6942 </span>            :                       // if so then do the regularly scheduled name qualification.</a>
<a name="6943"><span class="lineNum">    6943 </span>            : </a>
<a name="6944"><span class="lineNum">    6944 </span><span class="lineCov">    1179240 :                          SgScopeStatement* scope = declaration-&gt;get_scope();</span></a>
<a name="6945"><span class="lineNum">    6945 </span>            :                       // mfprintf(mlog [ WARN ] ) (&quot;case of SgInitializedName: scope = %p = %s \n&quot;,scope,scope-&gt;class_name().c_str());</a>
<a name="6946"><span class="lineNum">    6946 </span><span class="lineCov">    1179240 :                          int distanceBackThroughScopes = amountOfNameQualificationRequiredForType;</span></a>
<a name="6947"><span class="lineNum">    6947 </span>            :                       // mfprintf(mlog [ WARN ] ) (&quot;case of SgInitializedName: distanceBackThroughScopes = %d \n&quot;,distanceBackThroughScopes);</a>
<a name="6948"><span class="lineNum">    6948 </span><span class="lineCov">    1255710 :                          while (distanceBackThroughScopes &gt; 0 &amp;&amp; scope != NULL)</span></a>
<a name="6949"><span class="lineNum">    6949 </span>            :                             {</a>
<a name="6950"><span class="lineNum">    6950 </span>            :                            // Traverse backwards through the scopes checking for a SgTemplateClassDefinition scope</a>
<a name="6951"><span class="lineNum">    6951 </span>            :                            // If we traverse off the end of SgGlobal then the amountOfNameQualificationRequiredForType</a>
<a name="6952"><span class="lineNum">    6952 </span>            :                            // value was trying to trigger global qualification, so this is not a problem.</a>
<a name="6953"><span class="lineNum">    6953 </span>            :                            // We at least need isSgTemplateInstantiationDefn, not clear about isSgTemplateClassDefinition.</a>
<a name="6954"><span class="lineNum">    6954 </span>            : </a>
<a name="6955"><span class="lineNum">    6955 </span><span class="lineCov">      76478 :                               if (isSgTemplateInstantiationDefn(scope) != NULL || isSgTemplateClassDefinition(scope) != NULL)</span></a>
<a name="6956"><span class="lineNum">    6956 </span>            :                                  {</a>
<a name="6957"><span class="lineNum">    6957 </span>            :                                    skipGlobalNameQualification = false;</a>
<a name="6958"><span class="lineNum">    6958 </span>            :                                  }</a>
<a name="6959"><span class="lineNum">    6959 </span>            : </a>
<a name="6960"><span class="lineNum">    6960 </span><span class="lineCov">      76478 :                               ASSERT_not_null(scope);</span></a>
<a name="6961"><span class="lineNum">    6961 </span><span class="lineCov">      76478 :                               scope = scope-&gt;get_scope();</span></a>
<a name="6962"><span class="lineNum">    6962 </span>            : </a>
<a name="6963"><span class="lineNum">    6963 </span><span class="lineCov">      76478 :                               distanceBackThroughScopes--;</span></a>
<a name="6964"><span class="lineNum">    6964 </span>            :                             }</a>
<a name="6965"><span class="lineNum">    6965 </span>            :                        }</a>
<a name="6966"><span class="lineNum">    6966 </span>            : </a>
<a name="6967"><span class="lineNum">    6967 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || DEBUG_INITIALIZED_NAME</a>
<a name="6968"><span class="lineNum">    6968 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Test of Type used in SgInitializedName: declaration = %p = %s skipGlobalNameQualification = %s \n&quot;,declaration,declaration-&gt;class_name().c_str(),skipGlobalNameQualification ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="6969"><span class="lineNum">    6969 </span>            : #endif</a>
<a name="6970"><span class="lineNum">    6970 </span>            :                  // DQ (4/26/2019): Need to call setNameQualificationForType so that we can save the name qualification string using the SgInitializedName as the key.</a>
<a name="6971"><span class="lineNum">    6971 </span>            :                  // DQ (8/4/2012): Added support to permit global qualification be be skipped explicitly (see test2012_164.C and test2012_165.C for examples where this is important).</a>
<a name="6972"><span class="lineNum">    6972 </span>            :                  // setNameQualification(initializedName,declaration,amountOfNameQualificationRequiredForType,skipGlobalNameQualification);</a>
<a name="6973"><span class="lineNum">    6973 </span><span class="lineCov">    1209960 :                     setNameQualificationOnType(initializedName,declaration,amountOfNameQualificationRequiredForType,skipGlobalNameQualification);</span></a>
<a name="6974"><span class="lineNum">    6974 </span>            : </a>
<a name="6975"><span class="lineNum">    6975 </span>            : #if DEBUG_INITIALIZED_NAME</a>
<a name="6976"><span class="lineNum">    6976 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;@@@@@@@@@ Calling traverseType() to save type as string if it is contained types that would be shared AND name qualified \n&quot;);</a>
<a name="6977"><span class="lineNum">    6977 </span>            : #endif</a>
<a name="6978"><span class="lineNum">    6978 </span>            :                  // DQ (4/27/2019): I think we need to call this function to handle the name qualification on template</a>
<a name="6979"><span class="lineNum">    6979 </span>            :                  // arguments where the type is a template instantiation.</a>
<a name="6980"><span class="lineNum">    6980 </span><span class="lineCov">    1209960 :                     SgStatement* associatedStatement = currentScope;</span></a>
<a name="6981"><span class="lineNum">    6981 </span>            : </a>
<a name="6982"><span class="lineNum">    6982 </span><span class="lineCov">    1209960 :                     SgNode* initializedNameParent = initializedName-&gt;get_parent();</span></a>
<a name="6983"><span class="lineNum">    6983 </span><span class="lineCov">    1209960 :                     ASSERT_not_null(initializedNameParent);</span></a>
<a name="6984"><span class="lineNum">    6984 </span>            : </a>
<a name="6985"><span class="lineNum">    6985 </span>            : #if DEBUG_INITIALIZED_NAME || 0</a>
<a name="6986"><span class="lineNum">    6986 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;initializedNameParent = %p = %s \n&quot;,initializedNameParent,initializedNameParent-&gt;class_name().c_str());</a>
<a name="6987"><span class="lineNum">    6987 </span>            : #endif</a>
<a name="6988"><span class="lineNum">    6988 </span><span class="lineCov">    1209960 :                     bool skipTraverseType = false;</span></a>
<a name="6989"><span class="lineNum">    6989 </span><span class="lineCov">    1209960 :                     SgVariableDeclaration* variableDeclaration = isSgVariableDeclaration(initializedNameParent);</span></a>
<a name="6990"><span class="lineNum">    6990 </span><span class="lineCov">    1209960 :                     if (variableDeclaration != NULL)</span></a>
<a name="6991"><span class="lineNum">    6991 </span>            :                        {</a>
<a name="6992"><span class="lineNum">    6992 </span>            : #if DEBUG_INITIALIZED_NAME</a>
<a name="6993"><span class="lineNum">    6993 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;variableDeclaration-&gt;get_variableDeclarationContainsBaseTypeDefiningDeclaration() = %s \n&quot;,</a>
<a name="6994"><span class="lineNum">    6994 </span>            :                               variableDeclaration-&gt;get_variableDeclarationContainsBaseTypeDefiningDeclaration() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="6995"><span class="lineNum">    6995 </span>            : #endif</a>
<a name="6996"><span class="lineNum">    6996 </span>            :                          // DQ (5/26/2019): I think this should be the reversed.</a>
<a name="6997"><span class="lineNum">    6997 </span>            :                       // skipTraverseType = variableDeclaration-&gt;get_variableDeclarationContainsBaseTypeDefiningDeclaration();</a>
<a name="6998"><span class="lineNum">    6998 </span><span class="lineCov">       8463 :                          if (variableDeclaration-&gt;get_variableDeclarationContainsBaseTypeDefiningDeclaration() == true)</span></a>
<a name="6999"><span class="lineNum">    6999 </span>            :                             {</a>
<a name="7000"><span class="lineNum">    7000 </span>            :                               skipTraverseType = true;</a>
<a name="7001"><span class="lineNum">    7001 </span>            :                             }</a>
<a name="7002"><span class="lineNum">    7002 </span>            :                            else</a>
<a name="7003"><span class="lineNum">    7003 </span>            :                             {</a>
<a name="7004"><span class="lineNum">    7004 </span>            :                            // The name of the type will have to be output!</a>
<a name="7005"><span class="lineNum">    7005 </span>            :                             }</a>
<a name="7006"><span class="lineNum">    7006 </span>            :                        }</a>
<a name="7007"><span class="lineNum">    7007 </span>            :                       else</a>
<a name="7008"><span class="lineNum">    7008 </span>            :                        {</a>
<a name="7009"><span class="lineNum">    7009 </span>            : #if DEBUG_INITIALIZED_NAME</a>
<a name="7010"><span class="lineNum">    7010 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;initializedNameParent = %p = %s \n&quot;,initializedNameParent,initializedNameParent-&gt;class_name().c_str());</a>
<a name="7011"><span class="lineNum">    7011 </span>            : #endif</a>
<a name="7012"><span class="lineNum">    7012 </span>            :                        }</a>
<a name="7013"><span class="lineNum">    7013 </span>            : </a>
<a name="7014"><span class="lineNum">    7014 </span>            : #if 0</a>
<a name="7015"><span class="lineNum">    7015 </span>            :                     SgTypedefType* typedefType = isSgTypedefType(initializedName-&gt;get_type());</a>
<a name="7016"><span class="lineNum">    7016 </span>            :                     if (typedefType != NULL)</a>
<a name="7017"><span class="lineNum">    7017 </span>            :                        {</a>
<a name="7018"><span class="lineNum">    7018 </span>            :                          SgTypedefDeclaration* typedefDeclaration = isSgTypedefDeclaration(typedefType-&gt;get_declaration());</a>
<a name="7019"><span class="lineNum">    7019 </span>            :                          ASSERT_not_null(typedefDeclaration);</a>
<a name="7020"><span class="lineNum">    7020 </span>            : </a>
<a name="7021"><span class="lineNum">    7021 </span>            : #if DEBUG_INITIALIZED_NAME || 0</a>
<a name="7022"><span class="lineNum">    7022 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;typedefDeclaration-&gt;get_typedefBaseTypeContainsDefiningDeclaration() = %s \n&quot;,</a>
<a name="7023"><span class="lineNum">    7023 </span>            :                               typedefDeclaration-&gt;get_typedefBaseTypeContainsDefiningDeclaration() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="7024"><span class="lineNum">    7024 </span>            : #endif</a>
<a name="7025"><span class="lineNum">    7025 </span>            :                          skipTraverseType = typedefDeclaration-&gt;get_typedefBaseTypeContainsDefiningDeclaration();</a>
<a name="7026"><span class="lineNum">    7026 </span>            :                        }</a>
<a name="7027"><span class="lineNum">    7027 </span>            : #endif</a>
<a name="7028"><span class="lineNum">    7028 </span>            : #if 0</a>
<a name="7029"><span class="lineNum">    7029 </span>            :                  // DQ (5/25/2019): If we don't skip the type traversal because  amountOfNameQualificationRequiredForType == 0,</a>
<a name="7030"><span class="lineNum">    7030 </span>            :                  // then we don't need this code here!</a>
<a name="7031"><span class="lineNum">    7031 </span>            :                  // DQ (5/25/2019): If this is associated with a template instantiaton, then we need to save the</a>
<a name="7032"><span class="lineNum">    7032 </span>            :                  // typename as a string to preservce context of any nested template argument name qualification.</a>
<a name="7033"><span class="lineNum">    7033 </span>            :                     SgClassType* classType = isSgClassType(initializedName-&gt;get_type());</a>
<a name="7034"><span class="lineNum">    7034 </span>            :                     if (classType != NULL)</a>
<a name="7035"><span class="lineNum">    7035 </span>            :                        {</a>
<a name="7036"><span class="lineNum">    7036 </span>            :                          ASSERT_not_null(classType-&gt;get_declaration());</a>
<a name="7037"><span class="lineNum">    7037 </span>            : #if DEBUG_INITIALIZED_NAME</a>
<a name="7038"><span class="lineNum">    7038 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;classType-&gt;get_declaration() = %s \n&quot;,classType-&gt;get_declaration()-&gt;class_name().c_str());</a>
<a name="7039"><span class="lineNum">    7039 </span>            : #endif</a>
<a name="7040"><span class="lineNum">    7040 </span>            :                          SgTemplateInstantiationDecl* templateInstantiationDecl = isSgTemplateInstantiationDecl(classType-&gt;get_declaration());</a>
<a name="7041"><span class="lineNum">    7041 </span>            :                          if (templateInstantiationDecl != NULL)</a>
<a name="7042"><span class="lineNum">    7042 </span>            :                             {</a>
<a name="7043"><span class="lineNum">    7043 </span>            :                               skipTraverseType = false;</a>
<a name="7044"><span class="lineNum">    7044 </span>            :                             }</a>
<a name="7045"><span class="lineNum">    7045 </span>            :                        }</a>
<a name="7046"><span class="lineNum">    7046 </span>            : #endif</a>
<a name="7047"><span class="lineNum">    7047 </span>            : #if 0</a>
<a name="7048"><span class="lineNum">    7048 </span>            :                  // DQ (5/25/2019): This will be a problem when template instantiations require name qualificaiton</a>
<a name="7049"><span class="lineNum">    7049 </span>            :                  // or are output in different contexts requiring different name qualifications.</a>
<a name="7050"><span class="lineNum">    7050 </span>            : #if DEBUG_INITIALIZED_NAME</a>
<a name="7051"><span class="lineNum">    7051 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;amountOfNameQualificationRequiredForType == 0, so skipTraverseType = true initializedName-&gt;get_type() = %p = %s \n&quot;,</a>
<a name="7052"><span class="lineNum">    7052 </span>            :                          initializedName-&gt;get_type(),initializedName-&gt;get_type()-&gt;class_name().c_str());</a>
<a name="7053"><span class="lineNum">    7053 </span>            : #endif</a>
<a name="7054"><span class="lineNum">    7054 </span>            :                  // DQ (4/28/2019): We still need to generate the string for the type, because it could be a template</a>
<a name="7055"><span class="lineNum">    7055 </span>            :                  // instantiation which has template parameter that are name qualified (see test2019_423.C).</a>
<a name="7056"><span class="lineNum">    7056 </span>            :                  // FIXME: LOOK AT THIS IN THE MORNING!!!!!</a>
<a name="7057"><span class="lineNum">    7057 </span>            :                  // DQ (4/27/2019): Adding logic to skip calling traverseType() so much when it is not needed.</a>
<a name="7058"><span class="lineNum">    7058 </span>            :                  // However, we can't skip the string generation of the type if this is a template instantiation.</a>
<a name="7059"><span class="lineNum">    7059 </span>            :                     if (amountOfNameQualificationRequiredForType == 0)</a>
<a name="7060"><span class="lineNum">    7060 </span>            :                        {</a>
<a name="7061"><span class="lineNum">    7061 </span>            : #if DEBUG_INITIALIZED_NAME</a>
<a name="7062"><span class="lineNum">    7062 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;set skipTraverseType = true: amountOfNameQualificationRequiredForType == 0, so skipTraverseType = true initializedName-&gt;get_type() = %p = %s \n&quot;,</a>
<a name="7063"><span class="lineNum">    7063 </span>            :                               initializedName-&gt;get_type(),initializedName-&gt;get_type()-&gt;class_name().c_str());</a>
<a name="7064"><span class="lineNum">    7064 </span>            : #endif</a>
<a name="7065"><span class="lineNum">    7065 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;Just because there is not name qualification, does not mean that types from template instatiations with template arguments should not be saved as strings \n&quot;);</a>
<a name="7066"><span class="lineNum">    7066 </span>            :                       // skipTraverseType = true;</a>
<a name="7067"><span class="lineNum">    7067 </span>            :                        }</a>
<a name="7068"><span class="lineNum">    7068 </span>            : #endif</a>
<a name="7069"><span class="lineNum">    7069 </span>            : #if 0</a>
<a name="7070"><span class="lineNum">    7070 </span>            :                     if (skipTraverseType == true)</a>
<a name="7071"><span class="lineNum">    7071 </span>            :                        {</a>
<a name="7072"><span class="lineNum">    7072 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="7073"><span class="lineNum">    7073 </span>            :                          ROSE_ABORT();</a>
<a name="7074"><span class="lineNum">    7074 </span>            :                        }</a>
<a name="7075"><span class="lineNum">    7075 </span>            : #endif</a>
<a name="7076"><span class="lineNum">    7076 </span>            : </a>
<a name="7077"><span class="lineNum">    7077 </span>            : #if DEBUG_INITIALIZED_NAME || 0</a>
<a name="7078"><span class="lineNum">    7078 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;skipTraverseType = %s \n&quot;,skipTraverseType ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="7079"><span class="lineNum">    7079 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;initializedName-&gt;get_type() = %p = %s \n&quot;,initializedName-&gt;get_type(),initializedName-&gt;get_type()-&gt;class_name().c_str());</a>
<a name="7080"><span class="lineNum">    7080 </span>            : #endif</a>
<a name="7081"><span class="lineNum">    7081 </span>            :                  // mfprintf(mlog [ WARN ] ) (&quot;Calling traverseType ALWAYS! \n&quot;);</a>
<a name="7082"><span class="lineNum">    7082 </span>            :                     if (skipTraverseType == false)</a>
<a name="7083"><span class="lineNum">    7083 </span>            :                        {</a>
<a name="7084"><span class="lineNum">    7084 </span><span class="lineCov">    1209760 :                          traverseType(initializedName-&gt;get_type(),initializedName,currentScope,associatedStatement);</span></a>
<a name="7085"><span class="lineNum">    7085 </span>            :                        }</a>
<a name="7086"><span class="lineNum">    7086 </span>            : #if 0</a>
<a name="7087"><span class="lineNum">    7087 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;processAsNormalTypeThatMightRequireNameQualification == true: Looking for specific variable name: initializedName-&gt;get_name() = |%s| \n&quot;,initializedName-&gt;get_name().str());</a>
<a name="7088"><span class="lineNum">    7088 </span>            :                  // if (initializedName-&gt;get_name().str() == &quot;N&quot;)</a>
<a name="7089"><span class="lineNum">    7089 </span>            :                     if (initializedName-&gt;get_name() == &quot;N&quot;)</a>
<a name="7090"><span class="lineNum">    7090 </span>            :                        {</a>
<a name="7091"><span class="lineNum">    7091 </span>            : #if 0</a>
<a name="7092"><span class="lineNum">    7092 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;Detected initializedName-&gt;get_name().str() == \&quot;N\&quot;: Exiting as a test! \n&quot;);</a>
<a name="7093"><span class="lineNum">    7093 </span>            :                          ROSE_ABORT();</a>
<a name="7094"><span class="lineNum">    7094 </span>            : #endif</a>
<a name="7095"><span class="lineNum">    7095 </span>            :                        }</a>
<a name="7096"><span class="lineNum">    7096 </span>            : #endif</a>
<a name="7097"><span class="lineNum">    7097 </span>            : #if 0</a>
<a name="7098"><span class="lineNum">    7098 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="7099"><span class="lineNum">    7099 </span>            :                     ROSE_ABORT();</a>
<a name="7100"><span class="lineNum">    7100 </span>            : #endif</a>
<a name="7101"><span class="lineNum">    7101 </span>            :                   }</a>
<a name="7102"><span class="lineNum">    7102 </span>            :                  else</a>
<a name="7103"><span class="lineNum">    7103 </span>            :                   {</a>
<a name="7104"><span class="lineNum">    7104 </span>            :                  // DQ (8/23/2014): This case is demonstrated by test2014_145.C. where a SgInitializedName is used in a SgArrayType.</a>
<a name="7105"><span class="lineNum">    7105 </span>            :                  // However, it would provide greater symetry to handle the SgInitializedName objects in the processing of the</a>
<a name="7106"><span class="lineNum">    7106 </span>            :                  // SgFunctionParameterList similar to how they are handling in the SgVariableDeclaration.</a>
<a name="7107"><span class="lineNum">    7107 </span>            : </a>
<a name="7108"><span class="lineNum">    7108 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="7109"><span class="lineNum">    7109 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Case of SgInitializedName: getDeclarationAssociatedWithType() == NULL (this not associated with a type)  \n&quot;);</a>
<a name="7110"><span class="lineNum">    7110 </span>            : #endif</a>
<a name="7111"><span class="lineNum">    7111 </span>            : </a>
<a name="7112"><span class="lineNum">    7112 </span>            : #if 0</a>
<a name="7113"><span class="lineNum">    7113 </span>            :                  // DQ (2/7/2019): Set the pointer to member type in the inherited attribute so that we can know when to</a>
<a name="7114"><span class="lineNum">    7114 </span>            :                  // add name qualification to variables or function arguments being assigned to this initializedName.</a>
<a name="7115"><span class="lineNum">    7115 </span>            :                     SgPointerMemberType* pointerMemberType = isSgPointerMemberType(initializedName-&gt;get_type());</a>
<a name="7116"><span class="lineNum">    7116 </span>            :                     if (pointerMemberType != NULL)</a>
<a name="7117"><span class="lineNum">    7117 </span>            :                        {</a>
<a name="7118"><span class="lineNum">    7118 </span>            :                          inheritedAttribute.set_usingPointerToMemberType(pointerMemberType);</a>
<a name="7119"><span class="lineNum">    7119 </span>            :                          ASSERT_not_null(inheritedAttribute.get_usingPointerToMemberType());</a>
<a name="7120"><span class="lineNum">    7120 </span>            : #if 0</a>
<a name="7121"><span class="lineNum">    7121 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="7122"><span class="lineNum">    7122 </span>            :                          ROSE_ABORT();</a>
<a name="7123"><span class="lineNum">    7123 </span>            : #endif</a>
<a name="7124"><span class="lineNum">    7124 </span>            :                        }</a>
<a name="7125"><span class="lineNum">    7125 </span>            : #endif</a>
<a name="7126"><span class="lineNum">    7126 </span>            : </a>
<a name="7127"><span class="lineNum">    7127 </span>            : #if 1</a>
<a name="7128"><span class="lineNum">    7128 </span>            :                  // DQ (4/10/2019): I think we need to call this function to handle the name qualification on template</a>
<a name="7129"><span class="lineNum">    7129 </span>            :                  // arguments where the type is a template instantiation.</a>
<a name="7130"><span class="lineNum">    7130 </span>            :                  // DQ (8/23/2014): Adding this to support SgInitializedName in SgArrayType in function parameter lists.</a>
<a name="7131"><span class="lineNum">    7131 </span>            :                  // SgDeclarationStatement* associatedDeclaration = NULL;</a>
<a name="7132"><span class="lineNum">    7132 </span>            : </a>
<a name="7133"><span class="lineNum">    7133 </span>            :                  // DQ (8/8/2020): This is passed in as a function parameter.</a>
<a name="7134"><span class="lineNum">    7134 </span>            :                  // SgScopeStatement* currentScope = inheritedAttribute.get_currentScope();</a>
<a name="7135"><span class="lineNum">    7135 </span><span class="lineCov">     251917 :                     ASSERT_not_null(currentScope);</span></a>
<a name="7136"><span class="lineNum">    7136 </span>            : </a>
<a name="7137"><span class="lineNum">    7137 </span><span class="lineCov">     251917 :                     SgStatement* associatedStatement = currentScope;</span></a>
<a name="7138"><span class="lineNum">    7138 </span>            : </a>
<a name="7139"><span class="lineNum">    7139 </span>            :                  // int amountOfNameQualificationRequiredForType = nameQualificationDepthForType(initializedName,currentScope,associatedDeclaration);</a>
<a name="7140"><span class="lineNum">    7140 </span><span class="lineCov">     251917 :                     int amountOfNameQualificationRequiredForType = nameQualificationDepthForType(initializedName,currentScope,associatedStatement);</span></a>
<a name="7141"><span class="lineNum">    7141 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="7142"><span class="lineNum">    7142 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;SgInitializedName's type: amountOfNameQualificationRequiredForType = %d \n&quot;,amountOfNameQualificationRequiredForType);</a>
<a name="7143"><span class="lineNum">    7143 </span>            : #endif</a>
<a name="7144"><span class="lineNum">    7144 </span>            :                  // bool skipGlobalNameQualification = false;</a>
<a name="7145"><span class="lineNum">    7145 </span>            :                  // setNameQualificationOnType(initializedName,declaration,amountOfNameQualificationRequiredForType,skipGlobalNameQualification);</a>
<a name="7146"><span class="lineNum">    7146 </span>            :                  // setNameQualificationOnType(initializedName,associatedStatement,amountOfNameQualificationRequiredForType,skipGlobalNameQualification);</a>
<a name="7147"><span class="lineNum">    7147 </span>            : #if 0</a>
<a name="7148"><span class="lineNum">    7148 </span>            :                  // DQ (4/27/2019): Debugging test2019_414.C.</a>
<a name="7149"><span class="lineNum">    7149 </span>            :                     SgArrayType* tmp_arrayType = isSgArrayType(initializedName-&gt;get_type());</a>
<a name="7150"><span class="lineNum">    7150 </span>            :                     if (tmp_arrayType != NULL)</a>
<a name="7151"><span class="lineNum">    7151 </span>            :                        {</a>
<a name="7152"><span class="lineNum">    7152 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="7153"><span class="lineNum">    7153 </span>            :                          ROSE_ABORT();</a>
<a name="7154"><span class="lineNum">    7154 </span>            :                        }</a>
<a name="7155"><span class="lineNum">    7155 </span>            : #endif</a>
<a name="7156"><span class="lineNum">    7156 </span>            : #if 0</a>
<a name="7157"><span class="lineNum">    7157 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;amountOfNameQualificationRequiredForType = %d Calling traverseType() \n&quot;,amountOfNameQualificationRequiredForType);</a>
<a name="7158"><span class="lineNum">    7158 </span>            : #endif</a>
<a name="7159"><span class="lineNum">    7159 </span>            :                  // DQ (4/27/2019): This will avoid over use of the generated string mechanism to represent types, but</a>
<a name="7160"><span class="lineNum">    7160 </span>            :                  // we need to allow template instantiations to be processed.</a>
<a name="7161"><span class="lineNum">    7161 </span>            :                  // DQ (4/10/2019): I think we need to call this function to handle the name qualification on template</a>
<a name="7162"><span class="lineNum">    7162 </span>            :                  // arguments where the type is a template instantiation.</a>
<a name="7163"><span class="lineNum">    7163 </span>            :                  // traverseType(initializedName-&gt;get_type(),initializedName,currentScope,associatedStatement);</a>
<a name="7164"><span class="lineNum">    7164 </span><span class="lineCov">     251917 :                     if (amountOfNameQualificationRequiredForType &gt; 0)</span></a>
<a name="7165"><span class="lineNum">    7165 </span>            :                        {</a>
<a name="7166"><span class="lineNum">    7166 </span>            : #if 1</a>
<a name="7167"><span class="lineNum">    7167 </span><span class="lineNoCov">          0 :                          mfprintf(mlog [ WARN ] ) (&quot;Calling traverseType() on initializedName-&gt;get_type(): amountOfNameQualificationRequiredForType &gt; 0: amountOfNameQualificationRequiredForType = %d Calling traverseType() \n&quot;,</span></a>
<a name="7168"><span class="lineNum">    7168 </span>            :                               amountOfNameQualificationRequiredForType);</a>
<a name="7169"><span class="lineNum">    7169 </span>            : #endif</a>
<a name="7170"><span class="lineNum">    7170 </span><span class="lineNoCov">          0 :                          traverseType(initializedName-&gt;get_type(),initializedName,currentScope,associatedStatement);</span></a>
<a name="7171"><span class="lineNum">    7171 </span>            :                        }</a>
<a name="7172"><span class="lineNum">    7172 </span>            : #endif</a>
<a name="7173"><span class="lineNum">    7173 </span>            : #if 0</a>
<a name="7174"><span class="lineNum">    7174 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Looking for specific variable name: initializedName-&gt;get_name() = %s \n&quot;,initializedName-&gt;get_name().str());</a>
<a name="7175"><span class="lineNum">    7175 </span>            : #endif</a>
<a name="7176"><span class="lineNum">    7176 </span>            : #if 0</a>
<a name="7177"><span class="lineNum">    7177 </span>            :                  // if (initializedName-&gt;get_name().str() == &quot;N&quot;)</a>
<a name="7178"><span class="lineNum">    7178 </span>            :                     if (initializedName-&gt;get_name() == &quot;N&quot;)</a>
<a name="7179"><span class="lineNum">    7179 </span>            :                        {</a>
<a name="7180"><span class="lineNum">    7180 </span>            : #if 1</a>
<a name="7181"><span class="lineNum">    7181 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;Detected initializedName-&gt;get_name().str() == \&quot;N\&quot;: Exiting as a test! \n&quot;);</a>
<a name="7182"><span class="lineNum">    7182 </span>            :                          ROSE_ABORT();</a>
<a name="7183"><span class="lineNum">    7183 </span>            : #endif</a>
<a name="7184"><span class="lineNum">    7184 </span>            :                        }</a>
<a name="7185"><span class="lineNum">    7185 </span>            : #endif</a>
<a name="7186"><span class="lineNum">    7186 </span>            : #if 0</a>
<a name="7187"><span class="lineNum">    7187 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="7188"><span class="lineNum">    7188 </span>            :                     ROSE_ABORT();</a>
<a name="7189"><span class="lineNum">    7189 </span>            : #endif</a>
<a name="7190"><span class="lineNum">    7190 </span>            :                   }</a>
<a name="7191"><span class="lineNum">    7191 </span>            : #endif</a>
<a name="7192"><span class="lineNum">    7192 </span>            : </a>
<a name="7193"><span class="lineNum">    7193 </span>            : #if DEBUG_INITIALIZED_NAME</a>
<a name="7194"><span class="lineNum">    7194 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;######################################################################## \n&quot;);</a>
<a name="7195"><span class="lineNum">    7195 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Case SgInitializedName: DONE: Processing the SgInitializedName IR's type \n&quot;);</a>
<a name="7196"><span class="lineNum">    7196 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;######################################################################## \n&quot;);</a>
<a name="7197"><span class="lineNum">    7197 </span>            : #endif</a>
<a name="7198"><span class="lineNum">    7198 </span>            : </a>
<a name="7199"><span class="lineNum">    7199 </span>            : #if 0</a>
<a name="7200"><span class="lineNum">    7200 </span>            :             // DQ (4/27/2019): Debugging test2019_414.C.</a>
<a name="7201"><span class="lineNum">    7201 </span>            :                SgArrayType* tmp_arrayType = isSgArrayType(initializedName-&gt;get_type());</a>
<a name="7202"><span class="lineNum">    7202 </span>            :                if (tmp_arrayType != NULL)</a>
<a name="7203"><span class="lineNum">    7203 </span>            :                   {</a>
<a name="7204"><span class="lineNum">    7204 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="7205"><span class="lineNum">    7205 </span>            :                     ROSE_ABORT();</a>
<a name="7206"><span class="lineNum">    7206 </span>            :                   }</a>
<a name="7207"><span class="lineNum">    7207 </span>            : #endif</a>
<a name="7208"><span class="lineNum">    7208 </span>            : </a>
<a name="7209"><span class="lineNum">    7209 </span>            :             // DQ (4/27/2019): This is the new location of the end of the block to process the SgInitializedName's type.</a>
<a name="7210"><span class="lineNum">    7210 </span>            :              }</a>
<a name="7211"><span class="lineNum">    7211 </span>            : </a>
<a name="7212"><span class="lineNum">    7212 </span>            :        // endif for type handling.</a>
<a name="7213"><span class="lineNum">    7213 </span>            : </a>
<a name="7214"><span class="lineNum">    7214 </span><span class="lineCov">    1462240 :    }</span></a>
<a name="7215"><span class="lineNum">    7215 </span>            : </a>
<a name="7216"><span class="lineNum">    7216 </span>            : </a>
<a name="7217"><span class="lineNum">    7217 </span>            : </a>
<a name="7218"><span class="lineNum">    7218 </span>            : </a>
<a name="7219"><span class="lineNum">    7219 </span>            : NameQualificationInheritedAttribute</a>
<a name="7220"><span class="lineNum">    7220 </span><span class="lineCov">    2810440 : NameQualificationTraversal::evaluateInheritedAttribute(SgNode* n, NameQualificationInheritedAttribute inheritedAttribute)</span></a>
<a name="7221"><span class="lineNum">    7221 </span>            :    {</a>
<a name="7222"><span class="lineNum">    7222 </span><span class="lineCov">    2810440 :      ASSERT_not_null(n);</span></a>
<a name="7223"><span class="lineNum">    7223 </span>            : </a>
<a name="7224"><span class="lineNum">    7224 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || 0</a>
<a name="7225"><span class="lineNum">    7225 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;\n\n****************************************************** \n&quot;);</a>
<a name="7226"><span class="lineNum">    7226 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;****************************************************** \n&quot;);</a>
<a name="7227"><span class="lineNum">    7227 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;Inside of NameQualificationTraversal::evaluateInheritedAttribute(): node = %p = %s = %s \n&quot;,n,n-&gt;class_name().c_str(),SageInterface::get_name(n).c_str());</a>
<a name="7228"><span class="lineNum">    7228 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;****************************************************** \n&quot;);</a>
<a name="7229"><span class="lineNum">    7229 </span>            : #endif</a>
<a name="7230"><span class="lineNum">    7230 </span>            : </a>
<a name="7231"><span class="lineNum">    7231 </span>            : #if 0</a>
<a name="7232"><span class="lineNum">    7232 </span>            :   // DQ (8/1/2020): Setup a reference to the namespace alias map (so that the map is available in member functions of NameQualificationTraversal).</a>
<a name="7233"><span class="lineNum">    7233 </span>            :   // Specifically the function setNameQualificationSupport() requires this information so that any reference to a namespace declaration that</a>
<a name="7234"><span class="lineNum">    7234 </span>            :   // is in the map will use the alias as a priority.</a>
<a name="7235"><span class="lineNum">    7235 </span>            :      namespaceAliasDeclarationMapFromInheritedAttribute = &amp;(inheritedAttribute.get_namespaceAliasDeclarationMap());</a>
<a name="7236"><span class="lineNum">    7236 </span>            : #endif</a>
<a name="7237"><span class="lineNum">    7237 </span>            : </a>
<a name="7238"><span class="lineNum">    7238 </span>            : #if 0</a>
<a name="7239"><span class="lineNum">    7239 </span>            :   // DQ (2/13/2017): This will report progress through the global scope.</a>
<a name="7240"><span class="lineNum">    7240 </span>            :      if (SgProject::get_verbose() &gt;= 0)</a>
<a name="7241"><span class="lineNum">    7241 </span>            :        {</a>
<a name="7242"><span class="lineNum">    7242 </span>            :          SgDeclarationStatement* declarationStatement = isSgDeclarationStatement(n);</a>
<a name="7243"><span class="lineNum">    7243 </span>            :          SgDeclarationStatement* definingDeclarationStatement = NULL;</a>
<a name="7244"><span class="lineNum">    7244 </span>            :          if (declarationStatement != NULL)</a>
<a name="7245"><span class="lineNum">    7245 </span>            :             {</a>
<a name="7246"><span class="lineNum">    7246 </span>            : #if 0</a>
<a name="7247"><span class="lineNum">    7247 </span>            :               mfprintf(mlog [ WARN ] ) (&quot;Name qualification progress: test: declarationStatement = %p = %s \n&quot;,declarationStatement,declarationStatement-&gt;class_name().c_str());</a>
<a name="7248"><span class="lineNum">    7248 </span>            : #endif</a>
<a name="7249"><span class="lineNum">    7249 </span>            :               definingDeclarationStatement = declarationStatement-&gt;get_definingDeclaration();</a>
<a name="7250"><span class="lineNum">    7250 </span>            :             }</a>
<a name="7251"><span class="lineNum">    7251 </span>            :          if (declarationStatement != NULL &amp;&amp; declarationStatement == definingDeclarationStatement)</a>
<a name="7252"><span class="lineNum">    7252 </span>            :             {</a>
<a name="7253"><span class="lineNum">    7253 </span>            :            // This is the defining declaration</a>
<a name="7254"><span class="lineNum">    7254 </span>            :               mfprintf(mlog [ WARN ] ) (&quot;Name qualification progress (inheritedAttribute): declarationStatement = %p = %s \n&quot;,declarationStatement,declarationStatement-&gt;class_name().c_str());</a>
<a name="7255"><span class="lineNum">    7255 </span>            :               string filename = declarationStatement-&gt;get_file_info()-&gt;get_filename();</a>
<a name="7256"><span class="lineNum">    7256 </span>            :               int linenumber  = declarationStatement-&gt;get_file_info()-&gt;get_line();</a>
<a name="7257"><span class="lineNum">    7257 </span>            :               mfprintf(mlog [ WARN ] ) (&quot;--- filename = %s line = %d \n&quot;,filename.c_str(),linenumber);</a>
<a name="7258"><span class="lineNum">    7258 </span>            :             }</a>
<a name="7259"><span class="lineNum">    7259 </span>            :          SgTypedefDeclaration* typedefDeclaration = isSgTypedefDeclaration(n);</a>
<a name="7260"><span class="lineNum">    7260 </span>            :          if (typedefDeclaration != NULL)</a>
<a name="7261"><span class="lineNum">    7261 </span>            :             {</a>
<a name="7262"><span class="lineNum">    7262 </span>            :               mfprintf(mlog [ WARN ] ) (&quot;Name qualification progress: typedefDeclaration = %p = %s name = %s \n&quot;,typedefDeclaration,typedefDeclaration-&gt;class_name().c_str(),typedefDeclaration-&gt;get_name().str());</a>
<a name="7263"><span class="lineNum">    7263 </span>            :             }</a>
<a name="7264"><span class="lineNum">    7264 </span>            :        }</a>
<a name="7265"><span class="lineNum">    7265 </span>            : #endif</a>
<a name="7266"><span class="lineNum">    7266 </span>            : </a>
<a name="7267"><span class="lineNum">    7267 </span>            : #if 0</a>
<a name="7268"><span class="lineNum">    7268 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In evaluateInheritedAttribute(): inheritedAttribute.get_currentScope() = %p \n&quot;,inheritedAttribute.get_currentScope());</a>
<a name="7269"><span class="lineNum">    7269 </span>            :      if (inheritedAttribute.get_currentScope() != NULL)</a>
<a name="7270"><span class="lineNum">    7270 </span>            :         {</a>
<a name="7271"><span class="lineNum">    7271 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;In evaluateInheritedAttribute(): inheritedAttribute.get_currentScope() = %p = %s \n&quot;,inheritedAttribute.get_currentScope(),inheritedAttribute.get_currentScope()-&gt;class_name().c_str());</a>
<a name="7272"><span class="lineNum">    7272 </span>            :         }</a>
<a name="7273"><span class="lineNum">    7273 </span>            :        else</a>
<a name="7274"><span class="lineNum">    7274 </span>            :         {</a>
<a name="7275"><span class="lineNum">    7275 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;inheritedAttribute.get_currentScope() NOT set \n&quot;);</a>
<a name="7276"><span class="lineNum">    7276 </span>            :         }</a>
<a name="7277"><span class="lineNum">    7277 </span>            : #endif</a>
<a name="7278"><span class="lineNum">    7278 </span>            : </a>
<a name="7279"><span class="lineNum">    7279 </span><span class="lineCov">    2810440 :      SgSourceFile* sourceFile = isSgSourceFile(n);</span></a>
<a name="7280"><span class="lineNum">    7280 </span><span class="lineCov">    2810440 :      if (sourceFile != NULL)</span></a>
<a name="7281"><span class="lineNum">    7281 </span>            :         {</a>
<a name="7282"><span class="lineNum">    7282 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="7283"><span class="lineNum">    7283 </span>            :           printf (&quot;In evaluateInheritedAttribute(): sourceFile = %p = %s \n&quot;,sourceFile,sourceFile-&gt;getFileName().c_str());</a>
<a name="7284"><span class="lineNum">    7284 </span>            : #endif</a>
<a name="7285"><span class="lineNum">    7285 </span>            :         }</a>
<a name="7286"><span class="lineNum">    7286 </span>            : </a>
<a name="7287"><span class="lineNum">    7287 </span>            :   // DQ (5/24/2013): Allow the current scope to be tracked from the traversal of the AST</a>
<a name="7288"><span class="lineNum">    7288 </span>            :   // instead of being computed at each IR node which is a problem for template arguments.</a>
<a name="7289"><span class="lineNum">    7289 </span>            :   // See test2013_187.C for an example of this.</a>
<a name="7290"><span class="lineNum">    7290 </span><span class="lineCov">    2810440 :      SgScopeStatement* evaluateInheritedAttribute_currentScope = isSgScopeStatement(n);</span></a>
<a name="7291"><span class="lineNum">    7291 </span><span class="lineCov">    2810440 :      if (evaluateInheritedAttribute_currentScope != NULL)</span></a>
<a name="7292"><span class="lineNum">    7292 </span>            :         {</a>
<a name="7293"><span class="lineNum">    7293 </span>            : #if 0</a>
<a name="7294"><span class="lineNum">    7294 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;In evaluateInheritedAttribute(): resetting inheritedAttribute.get_currentScope() = %p = %s \n&quot;,n,n-&gt;class_name().c_str());</a>
<a name="7295"><span class="lineNum">    7295 </span>            : #endif</a>
<a name="7296"><span class="lineNum">    7296 </span><span class="lineCov">      65740 :           inheritedAttribute.set_currentScope(evaluateInheritedAttribute_currentScope);</span></a>
<a name="7297"><span class="lineNum">    7297 </span>            :         }</a>
<a name="7298"><span class="lineNum">    7298 </span>            : </a>
<a name="7299"><span class="lineNum">    7299 </span>            :   // DQ (5/24/2013): We can't set the current scope until we at first get past the SgProject and SgSourceFile IR nodes in the AST traversal.</a>
<a name="7300"><span class="lineNum">    7300 </span><span class="lineCov">    2810440 :      if (isSgSourceFile(n) == NULL &amp;&amp; isSgProject(n) == NULL)</span></a>
<a name="7301"><span class="lineNum">    7301 </span>            :         {</a>
<a name="7302"><span class="lineNum">    7302 </span>            :        // DQ (5/25/2013): This only appears to fail for test2013_63.C.</a>
<a name="7303"><span class="lineNum">    7303 </span><span class="lineCov">    2810370 :           if (inheritedAttribute.get_currentScope() == NULL)</span></a>
<a name="7304"><span class="lineNum">    7304 </span>            :              {</a>
<a name="7305"><span class="lineNum">    7305 </span><span class="lineNoCov">          0 :                mfprintf(mlog [ WARN ] ) (&quot;WARNING: In NameQualificationTraversal::evaluateInheritedAttribute(): inheritedAttribute.get_currentScope() == NULL: node = %p = %s = %s \n&quot;,n,n-&gt;class_name().c_str(),SageInterface::get_name(n).c_str());</span></a>
<a name="7306"><span class="lineNum">    7306 </span>            :              }</a>
<a name="7307"><span class="lineNum">    7307 </span>            :        // ASSERT_not_null(inheritedAttribute.get_currentScope());</a>
<a name="7308"><span class="lineNum">    7308 </span>            :         }</a>
<a name="7309"><span class="lineNum">    7309 </span>            : </a>
<a name="7310"><span class="lineNum">    7310 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="7311"><span class="lineNum">    7311 </span>            :   // Extra information about the location of the current node.</a>
<a name="7312"><span class="lineNum">    7312 </span>            :      Sg_File_Info* fileInfo = n-&gt;get_file_info();</a>
<a name="7313"><span class="lineNum">    7313 </span>            :      if (fileInfo != NULL)</a>
<a name="7314"><span class="lineNum">    7314 </span>            :         {</a>
<a name="7315"><span class="lineNum">    7315 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;NameQualificationTraversal: --- n = %p = %s line %d col = %d file = %s \n&quot;,n,n-&gt;class_name().c_str(),fileInfo-&gt;get_line(),fileInfo-&gt;get_col(),fileInfo-&gt;get_filenameString().c_str());</a>
<a name="7316"><span class="lineNum">    7316 </span>            :         }</a>
<a name="7317"><span class="lineNum">    7317 </span>            : #endif</a>
<a name="7318"><span class="lineNum">    7318 </span>            : </a>
<a name="7319"><span class="lineNum">    7319 </span>            :   // Locations where name qualified references can exist:</a>
<a name="7320"><span class="lineNum">    7320 </span>            :   //   1) Base class names</a>
<a name="7321"><span class="lineNum">    7321 </span>            :   //   2) Variable names in declarations (see test2011_30.C)</a>
<a name="7322"><span class="lineNum">    7322 </span>            :   //   3) Types referenced by variables</a>
<a name="7323"><span class="lineNum">    7323 </span>            :   //   4) Types referenced in function parameter lists</a>
<a name="7324"><span class="lineNum">    7324 </span>            :   //   5) Return types referenced by functions (including covariant types for member functions)</a>
<a name="7325"><span class="lineNum">    7325 </span>            :   //   6) References to functions thrown by functions</a>
<a name="7326"><span class="lineNum">    7326 </span>            :   //   7) Namespaces referenced by SgUsingDirectiveStatement IR nodes</a>
<a name="7327"><span class="lineNum">    7327 </span>            :   //   8) Variables and declarations reference from SgUsingDeclarationStatement IR nodes</a>
<a name="7328"><span class="lineNum">    7328 </span>            :   //   9) Functions reference by SgFunctionRefExp IR nodes</a>
<a name="7329"><span class="lineNum">    7329 </span>            :   //  10) Functions reference by SgMemberFunctionRefExp IR nodes</a>
<a name="7330"><span class="lineNum">    7330 </span>            :   //  11) Variable reference by SgVarRefExp IR nodes</a>
<a name="7331"><span class="lineNum">    7331 </span>            :   //  12) Template arguments (and default template parameter specifications)</a>
<a name="7332"><span class="lineNum">    7332 </span>            :   //  13) Template parameters?</a>
<a name="7333"><span class="lineNum">    7333 </span>            :   //  14) Function declarations</a>
<a name="7334"><span class="lineNum">    7334 </span>            :   //  15) Member function declarations</a>
<a name="7335"><span class="lineNum">    7335 </span>            :   //  16) Typedef declarations</a>
<a name="7336"><span class="lineNum">    7336 </span>            :   //  17) Throw exception lists</a>
<a name="7337"><span class="lineNum">    7337 </span>            :   //  18) A number of expressions (listed below)</a>
<a name="7338"><span class="lineNum">    7338 </span>            :   //         SgVarRefExp</a>
<a name="7339"><span class="lineNum">    7339 </span>            :   //         SgFunctionRefExp</a>
<a name="7340"><span class="lineNum">    7340 </span>            :   //         SgMemberFunctionRefExp</a>
<a name="7341"><span class="lineNum">    7341 </span>            :   //         SgConstructorInitializer</a>
<a name="7342"><span class="lineNum">    7342 </span>            :   //         SgNewExp</a>
<a name="7343"><span class="lineNum">    7343 </span>            :   //         SgCastExp</a>
<a name="7344"><span class="lineNum">    7344 </span>            :   //         SgSizeOfOp</a>
<a name="7345"><span class="lineNum">    7345 </span>            :   //         SgTypeIdOp</a>
<a name="7346"><span class="lineNum">    7346 </span>            :   //  19) SgVarRefExp's hidden in array types (SgArrayType) (requires explicitly specified current scope).</a>
<a name="7347"><span class="lineNum">    7347 </span>            :   //  20)</a>
<a name="7348"><span class="lineNum">    7348 </span>            : </a>
<a name="7349"><span class="lineNum">    7349 </span>            :   // The use of name qualification in types is a complicated because types are shared and the same type can</a>
<a name="7350"><span class="lineNum">    7350 </span>            :   // have it's template arguments qualified differently depending on where it is referenced.  This is an</a>
<a name="7351"><span class="lineNum">    7351 </span>            :   // issue for all references to types containing template arguments and not just where SgInitializedName</a>
<a name="7352"><span class="lineNum">    7352 </span>            :   // are used. Since name qualification of the same type can only vary at most from statement to statement</a>
<a name="7353"><span class="lineNum">    7353 </span>            :   // in some cases likely only from scope to scope) we need only associate names to statements (see note 1).</a>
<a name="7354"><span class="lineNum">    7354 </span>            :   // I would like to for now use scopes as the finest level of resolution.</a>
<a name="7355"><span class="lineNum">    7355 </span>            :   // The solution:</a>
<a name="7356"><span class="lineNum">    7356 </span>            :   //    1) Support a test for which types are effected.  a member function of SgType will evaluate if</a>
<a name="7357"><span class="lineNum">    7357 </span>            :   //       a type uses template arguments or subtypes using template arguments and if these could require</a>
<a name="7358"><span class="lineNum">    7358 </span>            :   //       name qualification.</a>
<a name="7359"><span class="lineNum">    7359 </span>            :   //    2) A map will be created in each scope (or maybe statement) for types used in that scope (or statement)</a>
<a name="7360"><span class="lineNum">    7360 </span>            :   //       which will store the computed name of the type (evaluated as part of the name qualification support;</a>
<a name="7361"><span class="lineNum">    7361 </span>            :   //       called immediately at the start of the unparsing of each SgFile).  The SgType pointer will be used</a>
<a name="7362"><span class="lineNum">    7362 </span>            :   //       as the key into the map of SgType to names (stored as strings).</a>
<a name="7363"><span class="lineNum">    7363 </span>            :   //    3) The unparser will check for entries in the associated map and use the stringified type names if they</a>
<a name="7364"><span class="lineNum">    7364 </span>            :   //       are available.  This can be done at the top level of the unparseType() function.</a>
<a name="7365"><span class="lineNum">    7365 </span>            : </a>
<a name="7366"><span class="lineNum">    7366 </span>            :   // Note 1: A forward declaraion of a function (and maybe a class) can happen in a scope that does not allow a defining</a>
<a name="7367"><span class="lineNum">    7367 </span>            :   // declaration and when this happens the name qualification of that function is undefined.  However after a</a>
<a name="7368"><span class="lineNum">    7368 </span>            :   // forward declaration in a scope permitting a defining declaration, the function name must be qualified as per</a>
<a name="7369"><span class="lineNum">    7369 </span>            :   // usual name qualification rules.</a>
<a name="7370"><span class="lineNum">    7370 </span>            : </a>
<a name="7371"><span class="lineNum">    7371 </span>            :   // DQ (8/4/2012): It is too complex to add this declaration support here (use the previous code and just</a>
<a name="7372"><span class="lineNum">    7372 </span>            :   // handle the specific cases where we need to add a declaration to the reference set separately.</a>
<a name="7373"><span class="lineNum">    7373 </span>            :   // DQ (8/4/2012): Let any procesing define a declaration to be used for the reference set.</a>
<a name="7374"><span class="lineNum">    7374 </span>            :   // Ititially it is NULL, but specific cases can set this so that the associated declaration</a>
<a name="7375"><span class="lineNum">    7375 </span>            :   // we be recorded as referenced.  This is important for test2012_164.C, where a variable declaration</a>
<a name="7376"><span class="lineNum">    7376 </span>            :   // generates a reference to a type that at first must not use a qualified name (since there is no</a>
<a name="7377"><span class="lineNum">    7377 </span>            :   // explicit forward declaration for the type (a class/struct).  This is a facinating case since</a>
<a name="7378"><span class="lineNum">    7378 </span>            :   // the scope of the declaration is the outer namespace from where it is first implicitly referenced</a>
<a name="7379"><span class="lineNum">    7379 </span>            :   // via a variable declaration.  This is part of debugging test2005_133.C (of which test2012_16[3-5].C</a>
<a name="7380"><span class="lineNum">    7380 </span>            :   // are simpler cases.</a>
<a name="7381"><span class="lineNum">    7381 </span>            :   // SgDeclarationStatement* declarationForReferencedNameSet = NULL;</a>
<a name="7382"><span class="lineNum">    7382 </span>            : </a>
<a name="7383"><span class="lineNum">    7383 </span>            :   // DQ (6/11/2011): This is a new IR nodes, but the use of it causes a few problems (test2004_109.C)</a>
<a name="7384"><span class="lineNum">    7384 </span>            :   // because the source position is not computed correctly (I think).</a>
<a name="7385"><span class="lineNum">    7385 </span><span class="lineCov">    2810440 :      SgTemplateClassDefinition* templateClassDefinition = isSgTemplateClassDefinition(n);</span></a>
<a name="7386"><span class="lineNum">    7386 </span><span class="lineCov">    2810440 :      if (templateClassDefinition != NULL)</span></a>
<a name="7387"><span class="lineNum">    7387 </span>            :         {</a>
<a name="7388"><span class="lineNum">    7388 </span>            : #if 0</a>
<a name="7389"><span class="lineNum">    7389 </span>            :        // DQ (3/5/2012): I think this is OK, since the SgTemplateClassDefinition is derived from the SgClassDefinition,</a>
<a name="7390"><span class="lineNum">    7390 </span>            :        // that case below will work well. This example is demonstrated in test2012_10.C.</a>
<a name="7391"><span class="lineNum">    7391 </span>            :        // DQ (11/20/2011): Debugging new use of SgTemplateClassDefinition (only used in new version of EDG 4.x support).</a>
<a name="7392"><span class="lineNum">    7392 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Name qualification of SgTemplateClassDefinition = %p not implemented, OK (no special handling is required, we be processed as a SgClassDefinition) (need and example to debug this case) \n&quot;,templateClassDefinition);</a>
<a name="7393"><span class="lineNum">    7393 </span>            : #endif</a>
<a name="7394"><span class="lineNum">    7394 </span>            : </a>
<a name="7395"><span class="lineNum">    7395 </span>            :        // DQ (11/20/2011): Commented out this assertion.</a>
<a name="7396"><span class="lineNum">    7396 </span>            :        // ROSE_ASSERT(false);</a>
<a name="7397"><span class="lineNum">    7397 </span>            :         }</a>
<a name="7398"><span class="lineNum">    7398 </span>            : </a>
<a name="7399"><span class="lineNum">    7399 </span><span class="lineCov">    2810440 :      SgClassDefinition* classDefinition = isSgClassDefinition(n);</span></a>
<a name="7400"><span class="lineNum">    7400 </span>            :   // if (classDefinition != NULL &amp;&amp; templateClassDefinition == NULL)</a>
<a name="7401"><span class="lineNum">    7401 </span><span class="lineCov">    2810440 :      if (classDefinition != NULL)</span></a>
<a name="7402"><span class="lineNum">    7402 </span>            :         {</a>
<a name="7403"><span class="lineNum">    7403 </span>            :        // Add all of the named types from this class into the set that have already been seen.</a>
<a name="7404"><span class="lineNum">    7404 </span>            :        // Note that this should not include nested classes (I think).</a>
<a name="7405"><span class="lineNum">    7405 </span>            : </a>
<a name="7406"><span class="lineNum">    7406 </span><span class="lineCov">      13053 :           SgBaseClassPtrList &amp; baseClassList = classDefinition-&gt;get_inheritances();</span></a>
<a name="7407"><span class="lineNum">    7407 </span>            : </a>
<a name="7408"><span class="lineNum">    7408 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || 0</a>
<a name="7409"><span class="lineNum">    7409 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;!!!!! Evaluate the derived classes: are they visible --- baseClassList.size() = %&quot; PRIuPTR &quot; \n&quot;,baseClassList.size());</a>
<a name="7410"><span class="lineNum">    7410 </span>            : #endif</a>
<a name="7411"><span class="lineNum">    7411 </span>            : #if 0</a>
<a name="7412"><span class="lineNum">    7412 </span>            :           string declaration_name = classDefinition-&gt;get_declaration()-&gt;unparseToString();</a>
<a name="7413"><span class="lineNum">    7413 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;test: declaration_name (unparseToString()) = %s \n&quot;,declaration_name.c_str());</a>
<a name="7414"><span class="lineNum">    7414 </span>            : #endif</a>
<a name="7415"><span class="lineNum">    7415 </span>            : </a>
<a name="7416"><span class="lineNum">    7416 </span><span class="lineCov">      13053 :           SgBaseClassPtrList::iterator i = baseClassList.begin();</span></a>
<a name="7417"><span class="lineNum">    7417 </span><span class="lineCov">      19398 :           while (i != baseClassList.end())</span></a>
<a name="7418"><span class="lineNum">    7418 </span>            :              {</a>
<a name="7419"><span class="lineNum">    7419 </span>            : </a>
<a name="7420"><span class="lineNum">    7420 </span>            : #define DEBUG_BASE_CLASS_SUPPORT 0</a>
<a name="7421"><span class="lineNum">    7421 </span>            : </a>
<a name="7422"><span class="lineNum">    7422 </span>            :             // Check each base class.</a>
<a name="7423"><span class="lineNum">    7423 </span><span class="lineCov">       6345 :                SgBaseClass* baseClass = *i;</span></a>
<a name="7424"><span class="lineNum">    7424 </span><span class="lineCov">       6345 :                ASSERT_not_null(baseClass);</span></a>
<a name="7425"><span class="lineNum">    7425 </span>            : </a>
<a name="7426"><span class="lineNum">    7426 </span><span class="lineCov">       6345 :                if (isSgNonrealBaseClass(baseClass)) {</span></a>
<a name="7427"><span class="lineNum">    7427 </span>            :                  // FIXME nothing to do?</a>
<a name="7428"><span class="lineNum">    7428 </span><span class="lineCov">       4237 :                } else if (isSgExpBaseClass(baseClass)) {</span></a>
<a name="7429"><span class="lineNum">    7429 </span><span class="lineNoCov">          0 :                   ROSE_ABORT(); // TODO traverse the expression ???</span></a>
<a name="7430"><span class="lineNum">    7430 </span>            :                   }</a>
<a name="7431"><span class="lineNum">    7431 </span>            :                  else</a>
<a name="7432"><span class="lineNum">    7432 </span>            :                   {</a>
<a name="7433"><span class="lineNum">    7433 </span><span class="lineCov">       4237 :                     SgClassDeclaration * classDeclaration = baseClass-&gt;get_base_class();</span></a>
<a name="7434"><span class="lineNum">    7434 </span><span class="lineCov">       4237 :                     ASSERT_not_null(classDeclaration);</span></a>
<a name="7435"><span class="lineNum">    7435 </span><span class="lineCov">       4237 :                     SgScopeStatement * currentScope = classDefinition-&gt;get_scope();</span></a>
<a name="7436"><span class="lineNum">    7436 </span><span class="lineCov">       4237 :                     ASSERT_not_null(currentScope);</span></a>
<a name="7437"><span class="lineNum">    7437 </span>            : </a>
<a name="7438"><span class="lineNum">    7438 </span>            :                  // Name these better to be more clear.</a>
<a name="7439"><span class="lineNum">    7439 </span><span class="lineCov">       4237 :                     SgClassDeclaration* derivedClassDeclaration = classDefinition-&gt;get_declaration();</span></a>
<a name="7440"><span class="lineNum">    7440 </span><span class="lineCov">       4237 :                     if (derivedClassDeclaration != derivedClassDeclaration-&gt;get_firstNondefiningDeclaration())</span></a>
<a name="7441"><span class="lineNum">    7441 </span>            :                        {</a>
<a name="7442"><span class="lineNum">    7442 </span><span class="lineCov">       4237 :                          derivedClassDeclaration = isSgClassDeclaration(derivedClassDeclaration-&gt;get_firstNondefiningDeclaration());</span></a>
<a name="7443"><span class="lineNum">    7443 </span>            : #if DEBUG_BASE_CLASS_SUPPORT</a>
<a name="7444"><span class="lineNum">    7444 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;RESET derivedClassDeclaration to firstNondefiningDeclaration: %p \n&quot;,derivedClassDeclaration);</a>
<a name="7445"><span class="lineNum">    7445 </span>            : #endif</a>
<a name="7446"><span class="lineNum">    7446 </span>            :                        }</a>
<a name="7447"><span class="lineNum">    7447 </span>            :                  // SgClassDeclaration* baseClassDeclaration    = classDeclaration;</a>
<a name="7448"><span class="lineNum">    7448 </span><span class="lineCov">       4237 :                     SgClassDeclaration* baseClassDeclaration    = baseClass-&gt;get_base_class();</span></a>
<a name="7449"><span class="lineNum">    7449 </span><span class="lineCov">       4237 :                     if (baseClassDeclaration != baseClassDeclaration-&gt;get_firstNondefiningDeclaration())</span></a>
<a name="7450"><span class="lineNum">    7450 </span>            :                        {</a>
<a name="7451"><span class="lineNum">    7451 </span><span class="lineNoCov">          0 :                          baseClassDeclaration = isSgClassDeclaration(baseClassDeclaration-&gt;get_firstNondefiningDeclaration());</span></a>
<a name="7452"><span class="lineNum">    7452 </span>            : #if DEBUG_BASE_CLASS_SUPPORT</a>
<a name="7453"><span class="lineNum">    7453 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;RESET baseClassDeclaration to firstNondefiningDeclaration: %p \n&quot;,baseClassDeclaration);</a>
<a name="7454"><span class="lineNum">    7454 </span>            : #endif</a>
<a name="7455"><span class="lineNum">    7455 </span>            :                        }</a>
<a name="7456"><span class="lineNum">    7456 </span>            : </a>
<a name="7457"><span class="lineNum">    7457 </span><span class="lineCov">       4237 :                     ASSERT_not_null(derivedClassDeclaration);</span></a>
<a name="7458"><span class="lineNum">    7458 </span><span class="lineCov">       4237 :                     ASSERT_not_null(baseClassDeclaration);</span></a>
<a name="7459"><span class="lineNum">    7459 </span>            : </a>
<a name="7460"><span class="lineNum">    7460 </span>            :                  // DQ (1/24/2019): Build a list of private base classes and accumulate them from any base classes.</a>
<a name="7461"><span class="lineNum">    7461 </span>            :                  // This is important to support additional name qualification required when derived classes</a>
<a name="7462"><span class="lineNum">    7462 </span>            :                  // reference a nested base class that may be private.</a>
<a name="7463"><span class="lineNum">    7463 </span><span class="lineCov">       4237 :                     SgBaseClassModifier* baseClassDeclarationBaseClassModifier = baseClass-&gt;get_baseClassModifier();</span></a>
<a name="7464"><span class="lineNum">    7464 </span><span class="lineCov">       4237 :                     ASSERT_not_null(baseClassDeclarationBaseClassModifier);</span></a>
<a name="7465"><span class="lineNum">    7465 </span><span class="lineCov">       4237 :                     SgAccessModifier &amp; baseClassDeclarationAccessModifier = baseClassDeclarationBaseClassModifier-&gt;get_accessModifier();</span></a>
<a name="7466"><span class="lineNum">    7466 </span>            : #if DEBUG_BASE_CLASS_SUPPORT</a>
<a name="7467"><span class="lineNum">    7467 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;  --- derivedClassDeclaration = %p name = %s \n&quot;,derivedClassDeclaration,SageInterface::get_name(derivedClassDeclaration).c_str());</a>
<a name="7468"><span class="lineNum">    7468 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;  --- baseClassDeclaration    = %p name = %s \n&quot;,baseClassDeclaration,SageInterface::get_name(baseClassDeclaration).c_str());</a>
<a name="7469"><span class="lineNum">    7469 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;  --- classDeclarationAccessModifier = %s \n&quot;,baseClassDeclarationAccessModifier.displayString().c_str());</a>
<a name="7470"><span class="lineNum">    7470 </span>            : </a>
<a name="7471"><span class="lineNum">    7471 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;  --- privateBaseClassSets.size()  = %zu \n&quot;,privateBaseClassSets.size());</a>
<a name="7472"><span class="lineNum">    7472 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;  --- inaccessibleClassSets.size() = %zu \n&quot;,inaccessibleClassSets.size());</a>
<a name="7473"><span class="lineNum">    7473 </span>            : #endif</a>
<a name="7474"><span class="lineNum">    7474 </span><span class="lineCov">       4237 :                     if (baseClassDeclarationAccessModifier.isPrivate() == true)</span></a>
<a name="7475"><span class="lineNum">    7475 </span>            :                        {</a>
<a name="7476"><span class="lineNum">    7476 </span>            : #if DEBUG_BASE_CLASS_SUPPORT</a>
<a name="7477"><span class="lineNum">    7477 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;Found private derivation of baseClassDeclaration = %s from derivedClassDeclaration = %s \n&quot;,baseClassDeclaration-&gt;get_name().str(),derivedClassDeclaration-&gt;get_name().str());</a>
<a name="7478"><span class="lineNum">    7478 </span>            : #endif</a>
<a name="7479"><span class="lineNum">    7479 </span><span class="lineCov">        242 :                          if (privateBaseClassSets.find(derivedClassDeclaration) != privateBaseClassSets.end())</span></a>
<a name="7480"><span class="lineNum">    7480 </span>            :                             {</a>
<a name="7481"><span class="lineNum">    7481 </span>            : #if DEBUG_BASE_CLASS_SUPPORT</a>
<a name="7482"><span class="lineNum">    7482 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;privateBaseClassSets has an entry for this class: derivedClassDeclaration = %p = %s name = %s \n&quot;,</a>
<a name="7483"><span class="lineNum">    7483 </span>            :                                    derivedClassDeclaration,derivedClassDeclaration-&gt;class_name().c_str(),derivedClassDeclaration-&gt;get_name().str());</a>
<a name="7484"><span class="lineNum">    7484 </span>            : #endif</a>
<a name="7485"><span class="lineNum">    7485 </span>            : #if 0</a>
<a name="7486"><span class="lineNum">    7486 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="7487"><span class="lineNum">    7487 </span>            :                               ROSE_ABORT();</a>
<a name="7488"><span class="lineNum">    7488 </span>            : #endif</a>
<a name="7489"><span class="lineNum">    7489 </span>            :                             }</a>
<a name="7490"><span class="lineNum">    7490 </span>            :                            else</a>
<a name="7491"><span class="lineNum">    7491 </span>            :                             {</a>
<a name="7492"><span class="lineNum">    7492 </span><span class="lineCov">        242 :                               std::set&lt;SgClassDeclaration*&gt; privateClasses;</span></a>
<a name="7493"><span class="lineNum">    7493 </span><span class="lineCov">        121 :                               privateClasses.insert(baseClassDeclaration);</span></a>
<a name="7494"><span class="lineNum">    7494 </span><span class="lineCov">        242 :                               privateBaseClassSets.insert(std::pair&lt;SgClassDeclaration*,std::set&lt;SgClassDeclaration*&gt; &gt;(derivedClassDeclaration,privateClasses));</span></a>
<a name="7495"><span class="lineNum">    7495 </span>            : #if 0</a>
<a name="7496"><span class="lineNum">    7496 </span>            :                            // Output the evolving maps.</a>
<a name="7497"><span class="lineNum">    7497 </span>            :                               displayBaseClassMap(&quot;private class set accumulation&quot;,privateBaseClassSets);</a>
<a name="7498"><span class="lineNum">    7498 </span>            : #endif</a>
<a name="7499"><span class="lineNum">    7499 </span>            :                             }</a>
<a name="7500"><span class="lineNum">    7500 </span>            : </a>
<a name="7501"><span class="lineNum">    7501 </span>            :                        }</a>
<a name="7502"><span class="lineNum">    7502 </span>            : </a>
<a name="7503"><span class="lineNum">    7503 </span>            :                  // Build up the inaccessibleClassSets map.</a>
<a name="7504"><span class="lineNum">    7504 </span><span class="lineCov">       8474 :                     if (privateBaseClassSets.find(baseClassDeclaration) != privateBaseClassSets.end())</span></a>
<a name="7505"><span class="lineNum">    7505 </span>            :                        {</a>
<a name="7506"><span class="lineNum">    7506 </span><span class="lineNoCov">          0 :                          std::set&lt;SgClassDeclaration*&gt; &amp; privateBaseClasses = privateBaseClassSets[baseClassDeclaration];</span></a>
<a name="7507"><span class="lineNum">    7507 </span>            : #if DEBUG_BASE_CLASS_SUPPORT</a>
<a name="7508"><span class="lineNum">    7508 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;In base class: find the set of private base classes: privateBaseClasses.size() = %zu \n&quot;,privateBaseClasses.size());</a>
<a name="7509"><span class="lineNum">    7509 </span>            : #endif</a>
<a name="7510"><span class="lineNum">    7510 </span><span class="lineNoCov">          0 :                          std::set&lt;SgClassDeclaration*&gt;::iterator j = privateBaseClasses.begin();</span></a>
<a name="7511"><span class="lineNum">    7511 </span><span class="lineNoCov">          0 :                          while (j != privateBaseClasses.end())</span></a>
<a name="7512"><span class="lineNum">    7512 </span>            :                             {</a>
<a name="7513"><span class="lineNum">    7513 </span><span class="lineNoCov">          0 :                               SgClassDeclaration* privateBaseClassDeclaration = *j;</span></a>
<a name="7514"><span class="lineNum">    7514 </span><span class="lineNoCov">          0 :                               ASSERT_not_null(privateBaseClassDeclaration);</span></a>
<a name="7515"><span class="lineNum">    7515 </span>            : #if DEBUG_BASE_CLASS_SUPPORT</a>
<a name="7516"><span class="lineNum">    7516 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;  --- privateBaseClassDeclaration = %p = %s name = %s \n&quot;,privateBaseClassDeclaration,privateBaseClassDeclaration-&gt;class_name().c_str(),privateBaseClassDeclaration-&gt;get_name().str());</a>
<a name="7517"><span class="lineNum">    7517 </span>            : #endif</a>
<a name="7518"><span class="lineNum">    7518 </span><span class="lineNoCov">          0 :                               std::set&lt;SgClassDeclaration*&gt; privateClasses;</span></a>
<a name="7519"><span class="lineNum">    7519 </span><span class="lineNoCov">          0 :                               privateClasses.insert(privateBaseClassDeclaration);</span></a>
<a name="7520"><span class="lineNum">    7520 </span><span class="lineNoCov">          0 :                               inaccessibleClassSets.insert(std::pair&lt;SgClassDeclaration*,std::set&lt;SgClassDeclaration*&gt; &gt;(derivedClassDeclaration,privateClasses));</span></a>
<a name="7521"><span class="lineNum">    7521 </span>            : </a>
<a name="7522"><span class="lineNum">    7522 </span><span class="lineNoCov">          0 :                               j++;</span></a>
<a name="7523"><span class="lineNum">    7523 </span>            :                             }</a>
<a name="7524"><span class="lineNum">    7524 </span>            :                        }</a>
<a name="7525"><span class="lineNum">    7525 </span>            :                       else</a>
<a name="7526"><span class="lineNum">    7526 </span>            :                        {</a>
<a name="7527"><span class="lineNum">    7527 </span>            : #if DEBUG_BASE_CLASS_SUPPORT</a>
<a name="7528"><span class="lineNum">    7528 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;baseClassDeclaration = %p = %s name = %s : has no recorded private base classes \n&quot;,baseClassDeclaration,baseClassDeclaration-&gt;class_name().c_str(),baseClassDeclaration-&gt;get_name().str());</a>
<a name="7529"><span class="lineNum">    7529 </span>            : #endif</a>
<a name="7530"><span class="lineNum">    7530 </span>            :                        }</a>
<a name="7531"><span class="lineNum">    7531 </span>            : #if 0</a>
<a name="7532"><span class="lineNum">    7532 </span>            :                  // Output the evolving maps.</a>
<a name="7533"><span class="lineNum">    7533 </span>            :                     displayBaseClassMap(&quot;inaccessible class set accumulation&quot;,inaccessibleClassSets);</a>
<a name="7534"><span class="lineNum">    7534 </span>            : #endif</a>
<a name="7535"><span class="lineNum">    7535 </span>            : </a>
<a name="7536"><span class="lineNum">    7536 </span>            : #if 0</a>
<a name="7537"><span class="lineNum">    7537 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="7538"><span class="lineNum">    7538 </span>            :                     ROSE_ABORT();</a>
<a name="7539"><span class="lineNum">    7539 </span>            : #endif</a>
<a name="7540"><span class="lineNum">    7540 </span>            : </a>
<a name="7541"><span class="lineNum">    7541 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="7542"><span class="lineNum">    7542 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Calling nameQualificationDepth() for base class baseClassDeclaration name = %s \n&quot;,baseClassDeclaration-&gt;get_name().str());</a>
<a name="7543"><span class="lineNum">    7543 </span>            : #endif</a>
<a name="7544"><span class="lineNum">    7544 </span><span class="lineCov">       4237 :                     int amountOfNameQualificationRequired = nameQualificationDepth(baseClassDeclaration,currentScope,classDefinition);</span></a>
<a name="7545"><span class="lineNum">    7545 </span>            : </a>
<a name="7546"><span class="lineNum">    7546 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="7547"><span class="lineNum">    7547 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;amountOfNameQualificationRequired (base class) = %d \n&quot;,amountOfNameQualificationRequired);</a>
<a name="7548"><span class="lineNum">    7548 </span>            : #endif</a>
<a name="7549"><span class="lineNum">    7549 </span>            : </a>
<a name="7550"><span class="lineNum">    7550 </span>            : #if 1</a>
<a name="7551"><span class="lineNum">    7551 </span>            :                  // DQ (4/12/2019): We need this name qualification, but we need to avoid redundant name qualification.</a>
<a name="7552"><span class="lineNum">    7552 </span><span class="lineCov">       4237 :                     setNameQualification(baseClass,baseClassDeclaration,amountOfNameQualificationRequired);</span></a>
<a name="7553"><span class="lineNum">    7553 </span>            : #else</a>
<a name="7554"><span class="lineNum">    7554 </span>            :                // DQ (4/12/2019): If this is a templated class then we don't want redundant name qualification.</a>
<a name="7555"><span class="lineNum">    7555 </span>            :                // See test2019_350.C for an example.</a>
<a name="7556"><span class="lineNum">    7556 </span>            :                   ASSERT_not_null(baseClass);</a>
<a name="7557"><span class="lineNum">    7557 </span>            :                   SgTemplateInstantiationDecl* templateInstantiationClassDeclaration = isSgTemplateInstantiationDecl(baseClass-&gt;get_base_class());</a>
<a name="7558"><span class="lineNum">    7558 </span>            :                   if (templateInstantiationClassDeclaration == NULL)</a>
<a name="7559"><span class="lineNum">    7559 </span>            :                      {</a>
<a name="7560"><span class="lineNum">    7560 </span>            :                        setNameQualification(baseClass,baseClassDeclaration,amountOfNameQualificationRequired);</a>
<a name="7561"><span class="lineNum">    7561 </span>            :                      }</a>
<a name="7562"><span class="lineNum">    7562 </span>            : #endif</a>
<a name="7563"><span class="lineNum">    7563 </span>            : </a>
<a name="7564"><span class="lineNum">    7564 </span>            : #if 0</a>
<a name="7565"><span class="lineNum">    7565 </span>            :                  // DQ (4/12/2019): There is no support currently in unparseToString() for the SgBaseClass IR node.</a>
<a name="7566"><span class="lineNum">    7566 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;8888888888888888888888888 Case of processing name qualification for classDeclaration = %p = %s \n&quot;,classDeclaration,classDeclaration-&gt;unparseToString().c_str());</a>
<a name="7567"><span class="lineNum">    7567 </span>            : #endif</a>
<a name="7568"><span class="lineNum">    7568 </span>            :                   }</a>
<a name="7569"><span class="lineNum">    7569 </span>            : </a>
<a name="7570"><span class="lineNum">    7570 </span>            :             // DQ (12/23/2015): Also need to add this to the aliasSymbolCausalNodeSet.</a>
<a name="7571"><span class="lineNum">    7571 </span><span class="lineCov">       6345 :                SgSymbolTable::get_aliasSymbolCausalNodeSet().insert(baseClass);</span></a>
<a name="7572"><span class="lineNum">    7572 </span>            : </a>
<a name="7573"><span class="lineNum">    7573 </span>            : #if 1</a>
<a name="7574"><span class="lineNum">    7574 </span>            :             // DQ (4/12/2019): New code to uniformally support template instantiations that are referenced (shared), where they are shared.</a>
<a name="7575"><span class="lineNum">    7575 </span>            : </a>
<a name="7576"><span class="lineNum">    7576 </span>            :             // DQ (4/12/2019): If this is a templated class then we have to save the name because its templated name might have template arguments that require name qualification.</a>
<a name="7577"><span class="lineNum">    7577 </span><span class="lineCov">       6345 :                ASSERT_not_null(baseClass);</span></a>
<a name="7578"><span class="lineNum">    7578 </span>            :             // SgTemplateInstantiationDecl* templateInstantiationClassDeclaration = isSgTemplateInstantiationDecl(*i);</a>
<a name="7579"><span class="lineNum">    7579 </span><span class="lineCov">       6345 :                SgTemplateInstantiationDecl* templateInstantiationClassDeclaration = isSgTemplateInstantiationDecl(baseClass-&gt;get_base_class());</span></a>
<a name="7580"><span class="lineNum">    7580 </span><span class="lineCov">       6345 :                if (templateInstantiationClassDeclaration != NULL)</span></a>
<a name="7581"><span class="lineNum">    7581 </span>            :                   {</a>
<a name="7582"><span class="lineNum">    7582 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || 0</a>
<a name="7583"><span class="lineNum">    7583 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Found a SgTemplateInstantiationDecl that will have template arguments that might require qualification. name = %s \n&quot;,templateInstantiationClassDeclaration-&gt;get_name().str());</a>
<a name="7584"><span class="lineNum">    7584 </span>            : #endif</a>
<a name="7585"><span class="lineNum">    7585 </span>            :                  // DQ (4/12/2019): When this is a function call in an array type index expression we can't identify an associated statement.</a>
<a name="7586"><span class="lineNum">    7586 </span><span class="lineCov">       3592 :                     SgStatement* currentStatement = TransformationSupport::getStatement(baseClass);</span></a>
<a name="7587"><span class="lineNum">    7587 </span>            :                  // ASSERT_not_null(currentStatement);</a>
<a name="7588"><span class="lineNum">    7588 </span><span class="lineCov">       3592 :                     if (currentStatement != NULL)</span></a>
<a name="7589"><span class="lineNum">    7589 </span>            :                        {</a>
<a name="7590"><span class="lineNum">    7590 </span><span class="lineCov">       3592 :                          SgScopeStatement* currentScope = currentStatement-&gt;get_scope();</span></a>
<a name="7591"><span class="lineNum">    7591 </span><span class="lineCov">       3592 :                          ASSERT_not_null(currentScope);</span></a>
<a name="7592"><span class="lineNum">    7592 </span>            : </a>
<a name="7593"><span class="lineNum">    7593 </span>            :                       // traverseTemplatedFunction(functionRefExp,templateInstantiationFunctionDeclaration,currentScope,currentStatement);</a>
<a name="7594"><span class="lineNum">    7594 </span>            :                       // traverseTemplatedFunction(functionRefExp,functionRefExp,currentScope,currentStatement);</a>
<a name="7595"><span class="lineNum">    7595 </span><span class="lineCov">       3592 :                          traverseTemplatedClass(baseClass,baseClass,currentScope,currentStatement);</span></a>
<a name="7596"><span class="lineNum">    7596 </span>            :                        }</a>
<a name="7597"><span class="lineNum">    7597 </span>            :                       else</a>
<a name="7598"><span class="lineNum">    7598 </span>            :                        {</a>
<a name="7599"><span class="lineNum">    7599 </span><span class="lineNoCov">          0 :                          mfprintf(mlog [ WARN ] ) (&quot;Note: Name qualification: parent statement could not be identified for baseClass = %p = %s \n&quot;,baseClass,baseClass-&gt;class_name().c_str());</span></a>
<a name="7600"><span class="lineNum">    7600 </span>            :                        }</a>
<a name="7601"><span class="lineNum">    7601 </span>            :                   }</a>
<a name="7602"><span class="lineNum">    7602 </span>            : #endif</a>
<a name="7603"><span class="lineNum">    7603 </span>            : #if 0</a>
<a name="7604"><span class="lineNum">    7604 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Exiting after evaluation of derived each base class: are they visible: \n&quot;);</a>
<a name="7605"><span class="lineNum">    7605 </span>            :                ROSE_ABORT();</a>
<a name="7606"><span class="lineNum">    7606 </span>            : #endif</a>
<a name="7607"><span class="lineNum">    7607 </span>            : </a>
<a name="7608"><span class="lineNum">    7608 </span><span class="lineCov">       6345 :                i++;</span></a>
<a name="7609"><span class="lineNum">    7609 </span>            :              }</a>
<a name="7610"><span class="lineNum">    7610 </span>            : </a>
<a name="7611"><span class="lineNum">    7611 </span>            : #if 0</a>
<a name="7612"><span class="lineNum">    7612 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Exiting after evaluation of derived classes: are they visible: \n&quot;);</a>
<a name="7613"><span class="lineNum">    7613 </span>            :           ROSE_ABORT();</a>
<a name="7614"><span class="lineNum">    7614 </span>            : #endif</a>
<a name="7615"><span class="lineNum">    7615 </span>            :         }</a>
<a name="7616"><span class="lineNum">    7616 </span>            : </a>
<a name="7617"><span class="lineNum">    7617 </span>            :   // DQ (6/16/2017): It might be that this case should exclue the case of a SgTemplateInstantiationDecl so that it can be processed below.</a>
<a name="7618"><span class="lineNum">    7618 </span>            :   // Handle references to SgMemberFunctionDeclaration...</a>
<a name="7619"><span class="lineNum">    7619 </span><span class="lineCov">    2810440 :      SgClassDeclaration* classDeclaration = isSgClassDeclaration(n);</span></a>
<a name="7620"><span class="lineNum">    7620 </span><span class="lineCov">    2810440 :      if (classDeclaration != NULL)</span></a>
<a name="7621"><span class="lineNum">    7621 </span>            :         {</a>
<a name="7622"><span class="lineNum">    7622 </span>            :        // Could it be that we only want to do this for the defining declaration? No, since prototypes must also use name qualification!</a>
<a name="7623"><span class="lineNum">    7623 </span>            : </a>
<a name="7624"><span class="lineNum">    7624 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="7625"><span class="lineNum">    7625 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;In name qualification:\n&quot;);</a>
<a name="7626"><span class="lineNum">    7626 </span>            :           mfprintf(mlog [ WARN ] ) (&quot; - classDeclaration   = %p = %s \n&quot;,classDeclaration, classDeclaration-&gt;class_name().c_str());</a>
<a name="7627"><span class="lineNum">    7627 </span>            :           mfprintf(mlog [ WARN ] ) (&quot; -     -&gt;get_parent() = %p = %s \n&quot;,classDeclaration-&gt;get_parent(), classDeclaration-&gt;get_parent() ? classDeclaration-&gt;get_parent()-&gt;class_name().c_str() : &quot;&quot;);</a>
<a name="7628"><span class="lineNum">    7628 </span>            : #endif</a>
<a name="7629"><span class="lineNum">    7629 </span>            : </a>
<a name="7630"><span class="lineNum">    7630 </span>            :        // We need the structural location in scope (not the semantic one).</a>
<a name="7631"><span class="lineNum">    7631 </span><span class="lineCov">      17802 :           SgScopeStatement* currentScope = isSgScopeStatement(classDeclaration-&gt;get_parent());</span></a>
<a name="7632"><span class="lineNum">    7632 </span>            : </a>
<a name="7633"><span class="lineNum">    7633 </span>            :        // DQ (6/16/2017): Handle the case of a template instantiation directive containing a template instantiation (which is also a SgClassDeclaration).</a>
<a name="7634"><span class="lineNum">    7634 </span><span class="lineCov">      17802 :           if (currentScope == NULL)</span></a>
<a name="7635"><span class="lineNum">    7635 </span>            :              {</a>
<a name="7636"><span class="lineNum">    7636 </span>            :             // Check if this is a template class instantiation that is part of a template instantiation directive</a>
<a name="7637"><span class="lineNum">    7637 </span><span class="lineCov">        718 :                SgTemplateInstantiationDirectiveStatement* templateInstantiationDirectiveStatement = isSgTemplateInstantiationDirectiveStatement(classDeclaration-&gt;get_parent());</span></a>
<a name="7638"><span class="lineNum">    7638 </span><span class="lineCov">        718 :                if (templateInstantiationDirectiveStatement != NULL)</span></a>
<a name="7639"><span class="lineNum">    7639 </span>            :                   {</a>
<a name="7640"><span class="lineNum">    7640 </span>            :                  // currentScope is that of the parent of the templateInstantiationDirectiveStatement</a>
<a name="7641"><span class="lineNum">    7641 </span><span class="lineCov">        212 :                     currentScope = isSgScopeStatement(templateInstantiationDirectiveStatement-&gt;get_parent());</span></a>
<a name="7642"><span class="lineNum">    7642 </span>            : #if 0</a>
<a name="7643"><span class="lineNum">    7643 </span>            :                  // DQ (4/20/2018): Added debugging support.</a>
<a name="7644"><span class="lineNum">    7644 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;In name qualification: processing SgClassDeclaration: found SgTemplateInstantiationDirectiveStatement \n&quot;);</a>
<a name="7645"><span class="lineNum">    7645 </span>            : #endif</a>
<a name="7646"><span class="lineNum">    7646 </span>            :                  // I think this has to be true.</a>
<a name="7647"><span class="lineNum">    7647 </span><span class="lineCov">        212 :                     ASSERT_not_null(currentScope);</span></a>
<a name="7648"><span class="lineNum">    7648 </span>            : #if 0</a>
<a name="7649"><span class="lineNum">    7649 </span>            :                  // DQ (7/22/2017): Uncomment as a test!</a>
<a name="7650"><span class="lineNum">    7650 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="7651"><span class="lineNum">    7651 </span>            :                     ROSE_ABORT();</a>
<a name="7652"><span class="lineNum">    7652 </span>            : #endif</a>
<a name="7653"><span class="lineNum">    7653 </span>            :                   }</a>
<a name="7654"><span class="lineNum">    7654 </span>            :                  else</a>
<a name="7655"><span class="lineNum">    7655 </span>            :                   {</a>
<a name="7656"><span class="lineNum">    7656 </span>            :                  // DQ (2/18/2019): Adding support for when the SgClassDeclaration is defined in another declaration (e.g. SgTypedefDeclaration).</a>
<a name="7657"><span class="lineNum">    7657 </span><span class="lineCov">        506 :                     SgNode* parent = classDeclaration-&gt;get_parent();</span></a>
<a name="7658"><span class="lineNum">    7658 </span><span class="lineCov">        506 :                     SgTypedefDeclaration* typedefDeclaration = isSgTypedefDeclaration(parent);</span></a>
<a name="7659"><span class="lineNum">    7659 </span>            :                  // currentScope = isSgScopeStatement(typedefDeclaration-&gt;get_parent());</a>
<a name="7660"><span class="lineNum">    7660 </span><span class="lineCov">        506 :                     if (typedefDeclaration != NULL)</span></a>
<a name="7661"><span class="lineNum">    7661 </span>            :                        {</a>
<a name="7662"><span class="lineNum">    7662 </span><span class="lineCov">        310 :                          currentScope = isSgScopeStatement(typedefDeclaration-&gt;get_parent());</span></a>
<a name="7663"><span class="lineNum">    7663 </span>            : </a>
<a name="7664"><span class="lineNum">    7664 </span>            :                       // DQ (2/18/2019): We should have a valid currentScope at this point.</a>
<a name="7665"><span class="lineNum">    7665 </span><span class="lineCov">        310 :                          if (currentScope == NULL)</span></a>
<a name="7666"><span class="lineNum">    7666 </span>            :                             {</a>
<a name="7667"><span class="lineNum">    7667 </span><span class="lineNoCov">          0 :                               mfprintf(mlog [ WARN ] ) (&quot;NOTE: Could not identify scope for class declaration: parent = %p = %s \n&quot;,parent,parent-&gt;class_name().c_str());</span></a>
<a name="7668"><span class="lineNum">    7668 </span>            : #if 1</a>
<a name="7669"><span class="lineNum">    7669 </span><span class="lineNoCov">          0 :                               mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</span></a>
<a name="7670"><span class="lineNum">    7670 </span><span class="lineNoCov">          0 :                               ROSE_ABORT();</span></a>
<a name="7671"><span class="lineNum">    7671 </span>            : #endif</a>
<a name="7672"><span class="lineNum">    7672 </span>            :                             }</a>
<a name="7673"><span class="lineNum">    7673 </span>            :                            else</a>
<a name="7674"><span class="lineNum">    7674 </span>            :                             {</a>
<a name="7675"><span class="lineNum">    7675 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="7676"><span class="lineNum">    7676 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;Found SgClassDeclaration in SgTypedefDeclaration: currentScope = %p = %s \n&quot;,currentScope,currentScope-&gt;class_name().c_str());</a>
<a name="7677"><span class="lineNum">    7677 </span>            : #endif</a>
<a name="7678"><span class="lineNum">    7678 </span>            :                             }</a>
<a name="7679"><span class="lineNum">    7679 </span>            :                        }</a>
<a name="7680"><span class="lineNum">    7680 </span>            :                       else</a>
<a name="7681"><span class="lineNum">    7681 </span>            :                        {</a>
<a name="7682"><span class="lineNum">    7682 </span>            :                       // DQ (2/19/2019): This is frequently a SgLambdaExp or a SgVariableDeclaration</a>
<a name="7683"><span class="lineNum">    7683 </span>            :                       // Computing the current scope does not always seem possible.</a>
<a name="7684"><span class="lineNum">    7684 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="7685"><span class="lineNum">    7685 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;In name qualification: Cannot compute a valid scope for the classDeclaration = %p = %s \n&quot;,classDeclaration,classDeclaration-&gt;class_name().c_str());</a>
<a name="7686"><span class="lineNum">    7686 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot; --- parent = %p = %s \n&quot;,parent,parent-&gt;class_name().c_str());</a>
<a name="7687"><span class="lineNum">    7687 </span>            : #endif</a>
<a name="7688"><span class="lineNum">    7688 </span>            :                        }</a>
<a name="7689"><span class="lineNum">    7689 </span>            :                   }</a>
<a name="7690"><span class="lineNum">    7690 </span>            :              }</a>
<a name="7691"><span class="lineNum">    7691 </span>            : </a>
<a name="7692"><span class="lineNum">    7692 </span>            :        // ASSERT_not_null(currentScope);</a>
<a name="7693"><span class="lineNum">    7693 </span><span class="lineCov">      17802 :           if (currentScope != NULL)</span></a>
<a name="7694"><span class="lineNum">    7694 </span>            :              {</a>
<a name="7695"><span class="lineNum">    7695 </span>            :             // Only use name qualification where the scopes of the declaration's use (currentScope) is not the same</a>
<a name="7696"><span class="lineNum">    7696 </span>            :             // as the scope of the class declaration.  However, the analysis should work and determin that the</a>
<a name="7697"><span class="lineNum">    7697 </span>            :             // required name qualification length is zero.</a>
<a name="7698"><span class="lineNum">    7698 </span>            : </a>
<a name="7699"><span class="lineNum">    7699 </span>            :             // DQ (7/22/2017): Refactored this code.</a>
<a name="7700"><span class="lineNum">    7700 </span><span class="lineCov">      17606 :                SgScopeStatement* class_scope = classDeclaration-&gt;get_scope();</span></a>
<a name="7701"><span class="lineNum">    7701 </span>            : </a>
<a name="7702"><span class="lineNum">    7702 </span>            :             // DQ (7/22/2017): I think we can assert this.</a>
<a name="7703"><span class="lineNum">    7703 </span><span class="lineCov">      17606 :                ASSERT_not_null(class_scope);</span></a>
<a name="7704"><span class="lineNum">    7704 </span>            : </a>
<a name="7705"><span class="lineNum">    7705 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="7706"><span class="lineNum">    7706 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;currentScope                  = %p = %s \n&quot;,currentScope,currentScope-&gt;class_name().c_str());</a>
<a name="7707"><span class="lineNum">    7707 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;classDeclaration-&gt;get_scope() = %p = %s \n&quot;,class_scope,class_scope-&gt;class_name().c_str());</a>
<a name="7708"><span class="lineNum">    7708 </span>            : #endif</a>
<a name="7709"><span class="lineNum">    7709 </span><span class="lineCov">      17606 :                if (currentScope != class_scope &amp;&amp; !SgScopeStatement::isEquivalentScope(currentScope, class_scope))</span></a>
<a name="7710"><span class="lineNum">    7710 </span>            :                   {</a>
<a name="7711"><span class="lineNum">    7711 </span>            :                       // DQ (6/11/2013): Added test to make sure that name qualification is ignored for friend function where the class has not yet been seen.</a>
<a name="7712"><span class="lineNum">    7712 </span>            :                       // if (classDeclaration-&gt;get_declarationModifier().isFriend() == false)</a>
<a name="7713"><span class="lineNum">    7713 </span><span class="lineCov">       2958 :                          SgDeclarationStatement* declarationForReferencedNameSet = classDeclaration-&gt;get_firstNondefiningDeclaration();</span></a>
<a name="7714"><span class="lineNum">    7714 </span><span class="lineCov">       2958 :                          ASSERT_not_null(declarationForReferencedNameSet);</span></a>
<a name="7715"><span class="lineNum">    7715 </span><span class="lineCov">       5916 :                          if (referencedNameSet.find(declarationForReferencedNameSet) != referencedNameSet.end())</span></a>
<a name="7716"><span class="lineNum">    7716 </span>            :                             {</a>
<a name="7717"><span class="lineNum">    7717 </span><span class="lineCov">        951 :                               int amountOfNameQualificationRequired = nameQualificationDepth(classDeclaration,currentScope,classDeclaration);</span></a>
<a name="7718"><span class="lineNum">    7718 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="7719"><span class="lineNum">    7719 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;SgClassDeclaration: amountOfNameQualificationRequired = %d \n&quot;,amountOfNameQualificationRequired);</a>
<a name="7720"><span class="lineNum">    7720 </span>            : #endif</a>
<a name="7721"><span class="lineNum">    7721 </span><span class="lineCov">        951 :                               setNameQualification(classDeclaration,amountOfNameQualificationRequired);</span></a>
<a name="7722"><span class="lineNum">    7722 </span>            :                             }</a>
<a name="7723"><span class="lineNum">    7723 </span>            :                            else</a>
<a name="7724"><span class="lineNum">    7724 </span>            :                             {</a>
<a name="7725"><span class="lineNum">    7725 </span>            :                            // DQ (2/12/2019): This branch is taken within Cxx11_tests/test2019_107.C where the associated</a>
<a name="7726"><span class="lineNum">    7726 </span>            :                            // SgTemplateInstantiationDecl is a specialization and does require name qualification.</a>
<a name="7727"><span class="lineNum">    7727 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="7728"><span class="lineNum">    7728 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;This classDeclaration has not been seen before so skip the name qualification \n&quot;);</a>
<a name="7729"><span class="lineNum">    7729 </span>            : #endif</a>
<a name="7730"><span class="lineNum">    7730 </span>            :                            // DQ (2/12/2019): If this is a SgTemplateInstantiationDecl, it might require name qualification.</a>
<a name="7731"><span class="lineNum">    7731 </span><span class="lineCov">       2007 :                               SgTemplateInstantiationDecl* templateInstantiationDecl = isSgTemplateInstantiationDecl(classDeclaration);</span></a>
<a name="7732"><span class="lineNum">    7732 </span><span class="lineCov">       2007 :                               if (templateInstantiationDecl != NULL)</span></a>
<a name="7733"><span class="lineNum">    7733 </span>            :                                  {</a>
<a name="7734"><span class="lineNum">    7734 </span><span class="lineCov">       1998 :                                    int amountOfNameQualificationRequired = nameQualificationDepth(classDeclaration,currentScope,classDeclaration);</span></a>
<a name="7735"><span class="lineNum">    7735 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="7736"><span class="lineNum">    7736 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;SgClassDeclaration: amountOfNameQualificationRequired = %d \n&quot;,amountOfNameQualificationRequired);</a>
<a name="7737"><span class="lineNum">    7737 </span>            : #endif</a>
<a name="7738"><span class="lineNum">    7738 </span><span class="lineCov">       1998 :                                    setNameQualification(classDeclaration,amountOfNameQualificationRequired);</span></a>
<a name="7739"><span class="lineNum">    7739 </span>            :                                  }</a>
<a name="7740"><span class="lineNum">    7740 </span>            :                             }</a>
<a name="7741"><span class="lineNum">    7741 </span>            :                   }</a>
<a name="7742"><span class="lineNum">    7742 </span>            :                  else</a>
<a name="7743"><span class="lineNum">    7743 </span>            :                   {</a>
<a name="7744"><span class="lineNum">    7744 </span>            :                  // DQ (7/22/2017): I think the template arguments name qualification can be required. This fixes test2017_56.C.</a>
<a name="7745"><span class="lineNum">    7745 </span><span class="lineCov">      14648 :                     int amountOfNameQualificationRequired = nameQualificationDepth(classDeclaration,currentScope,classDeclaration);</span></a>
<a name="7746"><span class="lineNum">    7746 </span>            : </a>
<a name="7747"><span class="lineNum">    7747 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="7748"><span class="lineNum">    7748 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot; - amountOfNameQualificationRequired = %d \n&quot;,amountOfNameQualificationRequired);</a>
<a name="7749"><span class="lineNum">    7749 </span>            : #endif</a>
<a name="7750"><span class="lineNum">    7750 </span><span class="lineCov">      14648 :                     setNameQualification(classDeclaration,amountOfNameQualificationRequired);</span></a>
<a name="7751"><span class="lineNum">    7751 </span>            :                   }</a>
<a name="7752"><span class="lineNum">    7752 </span>            :              }</a>
<a name="7753"><span class="lineNum">    7753 </span>            :             else</a>
<a name="7754"><span class="lineNum">    7754 </span>            :              {</a>
<a name="7755"><span class="lineNum">    7755 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="7756"><span class="lineNum">    7756 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;WARNING: SgClassDeclaration -- currentScope is not available, not clear why! \n&quot;);</a>
<a name="7757"><span class="lineNum">    7757 </span>            : #endif</a>
<a name="7758"><span class="lineNum">    7758 </span>            :             // ROSE_ASSERT(false);</a>
<a name="7759"><span class="lineNum">    7759 </span>            :              }</a>
<a name="7760"><span class="lineNum">    7760 </span>            : </a>
<a name="7761"><span class="lineNum">    7761 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="7762"><span class="lineNum">    7762 </span>            :        // DQ (9/23/2012): We need to handle the template arguments associate with this template instantiation.</a>
<a name="7763"><span class="lineNum">    7763 </span>            :           SgTemplateInstantiationDecl* templateClassInstantiationDeclaration = isSgTemplateInstantiationDecl(classDeclaration);</a>
<a name="7764"><span class="lineNum">    7764 </span>            :           if (templateClassInstantiationDeclaration != NULL)</a>
<a name="7765"><span class="lineNum">    7765 </span>            :              {</a>
<a name="7766"><span class="lineNum">    7766 </span>            :             // There are template parameters that may require name qualification.</a>
<a name="7767"><span class="lineNum">    7767 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;WARNING: There are template parameters that may require name qualification. templateClassInstantiationDeclaration = %p \n&quot;,templateClassInstantiationDeclaration);</a>
<a name="7768"><span class="lineNum">    7768 </span>            : </a>
<a name="7769"><span class="lineNum">    7769 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;  --- templateClassInstantiationDeclaration-&gt;get_firstNondefiningDeclaration() = %p \n&quot;,templateClassInstantiationDeclaration-&gt;get_firstNondefiningDeclaration());</a>
<a name="7770"><span class="lineNum">    7770 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;  --- templateClassInstantiationDeclaration-&gt;get_definingDeclaration()         = %p \n&quot;,templateClassInstantiationDeclaration-&gt;get_definingDeclaration());</a>
<a name="7771"><span class="lineNum">    7771 </span>            : </a>
<a name="7772"><span class="lineNum">    7772 </span>            :                SgTemplateArgumentPtrList &amp; l = templateClassInstantiationDeclaration-&gt;get_templateArguments();</a>
<a name="7773"><span class="lineNum">    7773 </span>            :                for (SgTemplateArgumentPtrList::iterator i = l.begin(); i != l.end(); i++)</a>
<a name="7774"><span class="lineNum">    7774 </span>            :                   {</a>
<a name="7775"><span class="lineNum">    7775 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;  --- template argument = %p = %s \n&quot;,*i,(*i)-&gt;class_name().c_str());</a>
<a name="7776"><span class="lineNum">    7776 </span>            :                   }</a>
<a name="7777"><span class="lineNum">    7777 </span>            : #if 0</a>
<a name="7778"><span class="lineNum">    7778 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="7779"><span class="lineNum">    7779 </span>            :                ROSE_ABORT();</a>
<a name="7780"><span class="lineNum">    7780 </span>            : #endif</a>
<a name="7781"><span class="lineNum">    7781 </span>            :              }</a>
<a name="7782"><span class="lineNum">    7782 </span>            : #endif</a>
<a name="7783"><span class="lineNum">    7783 </span>            :         }</a>
<a name="7784"><span class="lineNum">    7784 </span>            : </a>
<a name="7785"><span class="lineNum">    7785 </span>            : </a>
<a name="7786"><span class="lineNum">    7786 </span>            :   // DQ (4/26/2019): Adding support to detect SgTemplateVariableDeclaration (see test2019_399.C).</a>
<a name="7787"><span class="lineNum">    7787 </span><span class="lineCov">    2810440 :      SgTemplateVariableDeclaration* templateVariableDeclaration = isSgTemplateVariableDeclaration(n);</span></a>
<a name="7788"><span class="lineNum">    7788 </span><span class="lineCov">    2810440 :      if (templateVariableDeclaration != NULL)</span></a>
<a name="7789"><span class="lineNum">    7789 </span>            :         {</a>
<a name="7790"><span class="lineNum">    7790 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="7791"><span class="lineNum">    7791 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Case SgTemplateVariableDeclaration: name qualificaiton will be processed by the SgInitializedName support \n&quot;);</a>
<a name="7792"><span class="lineNum">    7792 </span>            : #endif</a>
<a name="7793"><span class="lineNum">    7793 </span>            :         }</a>
<a name="7794"><span class="lineNum">    7794 </span>            : </a>
<a name="7795"><span class="lineNum">    7795 </span>            : </a>
<a name="7796"><span class="lineNum">    7796 </span>            :   // Handle the types used in variable declarations...</a>
<a name="7797"><span class="lineNum">    7797 </span>            :   // A problem with this implementation is that it relies on there being one SgInitializedName per SgVariableDeclaration.</a>
<a name="7798"><span class="lineNum">    7798 </span>            :   // This is currently the case for C++, but we would like to fix this.  It is not clear if the SgInitializedName should carry its</a>
<a name="7799"><span class="lineNum">    7799 </span>            :   // own qualification or not (this violates the idea that the IR node that has the reference stored the name qualification data).</a>
<a name="7800"><span class="lineNum">    7800 </span><span class="lineCov">    2810440 :      SgVariableDeclaration* variableDeclaration = isSgVariableDeclaration(n);</span></a>
<a name="7801"><span class="lineNum">    7801 </span><span class="lineCov">    2810440 :      if (variableDeclaration != NULL)</span></a>
<a name="7802"><span class="lineNum">    7802 </span>            :         {</a>
<a name="7803"><span class="lineNum">    7803 </span>            : #if 1</a>
<a name="7804"><span class="lineNum">    7804 </span>            :        // DQ (4/10/2019): I would like to have all processing happen through the support for SgInitializedName, but maybe that is a problem.</a>
<a name="7805"><span class="lineNum">    7805 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="7806"><span class="lineNum">    7806 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Skipping the previous handling of the SgVariableDeclaration (need to check bit field name qualification) \n&quot;);</a>
<a name="7807"><span class="lineNum">    7807 </span>            : #endif</a>
<a name="7808"><span class="lineNum">    7808 </span>            : </a>
<a name="7809"><span class="lineNum">    7809 </span>            : #else</a>
<a name="7810"><span class="lineNum">    7810 </span>            : </a>
<a name="7811"><span class="lineNum">    7811 </span>            :        // DQ (4/19/2019): Comment this out for now (SgInitializedName IR nodes are processed directly</a>
<a name="7812"><span class="lineNum">    7812 </span>            :        // instead of indirectly through each SgVariableDeclaration).</a>
<a name="7813"><span class="lineNum">    7813 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="7814"><span class="lineNum">    7814 </span>            : </a>
<a name="7815"><span class="lineNum">    7815 </span>            : #ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION</a>
<a name="7816"><span class="lineNum">    7816 </span>            :        // DQ (8/24/2012): Allow this to be output a little less often.</a>
<a name="7817"><span class="lineNum">    7817 </span>            :        // DQ (8/4/2012): Why is this case procesed if the SgInitializedNames are processed sperately (this appears to be redundant with that).</a>
<a name="7818"><span class="lineNum">    7818 </span>            :           static int counter = 0;</a>
<a name="7819"><span class="lineNum">    7819 </span>            :           if (counter++ % 100 == 0)</a>
<a name="7820"><span class="lineNum">    7820 </span>            :              {</a>
<a name="7821"><span class="lineNum">    7821 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;QUESTION: Why is this case of name qualification SgVariableDeclaration procesed if the SgInitializedNames are processed sperately (this appears to be redundant with that). \n&quot;);</a>
<a name="7822"><span class="lineNum">    7822 </span>            :              }</a>
<a name="7823"><span class="lineNum">    7823 </span>            : #endif</a>
<a name="7824"><span class="lineNum">    7824 </span>            :           SgInitializedName* initializedName = SageInterface::getFirstInitializedName(variableDeclaration);</a>
<a name="7825"><span class="lineNum">    7825 </span>            :           ASSERT_not_null(initializedName);</a>
<a name="7826"><span class="lineNum">    7826 </span>            : </a>
<a name="7827"><span class="lineNum">    7827 </span>            :        // This is not always the correct current scope (see test2011_70.C for an example).</a>
<a name="7828"><span class="lineNum">    7828 </span>            :           SgScopeStatement* currentScope = SageInterface::getScope(variableDeclaration);</a>
<a name="7829"><span class="lineNum">    7829 </span>            :        // SgScopeStatement* currentScope = isSgScopeStatement(variableDeclaration-&gt;get_parent());</a>
<a name="7830"><span class="lineNum">    7830 </span>            :           ASSERT_not_null(currentScope);</a>
<a name="7831"><span class="lineNum">    7831 </span>            : </a>
<a name="7832"><span class="lineNum">    7832 </span>            :        // DQ (5/24/2013): This should be the same scope as what is in the inherited attribute, I think.</a>
<a name="7833"><span class="lineNum">    7833 </span>            :        // This fails for test2013_186.C, I expect it is because one of these is NULL (allowed for some nested traversals).</a>
<a name="7834"><span class="lineNum">    7834 </span>            :           if (currentScope != inheritedAttribute.get_currentScope())</a>
<a name="7835"><span class="lineNum">    7835 </span>            :              {</a>
<a name="7836"><span class="lineNum">    7836 </span>            :                if (currentScope != NULL &amp;&amp; inheritedAttribute.get_currentScope() != NULL)</a>
<a name="7837"><span class="lineNum">    7837 </span>            :                   {</a>
<a name="7838"><span class="lineNum">    7838 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 1)</a>
<a name="7839"><span class="lineNum">    7839 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;WARNING: currentScope != inheritedAttribute.get_currentScope(): currentScope = %p = %s inheritedAttribute.get_currentScope() = %p = %s \n&quot;,</a>
<a name="7840"><span class="lineNum">    7840 </span>            :                          currentScope,currentScope-&gt;class_name().c_str(),inheritedAttribute.get_currentScope(),inheritedAttribute.get_currentScope()-&gt;class_name().c_str());</a>
<a name="7841"><span class="lineNum">    7841 </span>            : #endif</a>
<a name="7842"><span class="lineNum">    7842 </span>            :                   }</a>
<a name="7843"><span class="lineNum">    7843 </span>            :              }</a>
<a name="7844"><span class="lineNum">    7844 </span>            :        // ROSE_ASSERT(currentScope == inheritedAttribute.get_currentScope());</a>
<a name="7845"><span class="lineNum">    7845 </span>            : </a>
<a name="7846"><span class="lineNum">    7846 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="7847"><span class="lineNum">    7847 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;================ Calling nameQualificationDepthForType to evaluate the type \n&quot;);</a>
<a name="7848"><span class="lineNum">    7848 </span>            : #endif</a>
<a name="7849"><span class="lineNum">    7849 </span>            :        // Compute the depth of name qualification from the current statement:  variableDeclaration.</a>
<a name="7850"><span class="lineNum">    7850 </span>            :        // int amountOfNameQualificationRequiredForType = nameQualificationDepthForType(initializedName,variableDeclaration);</a>
<a name="7851"><span class="lineNum">    7851 </span>            :           int amountOfNameQualificationRequiredForType = nameQualificationDepthForType(initializedName,currentScope,variableDeclaration);</a>
<a name="7852"><span class="lineNum">    7852 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="7853"><span class="lineNum">    7853 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;SgVariableDeclaration's type: amountOfNameQualificationRequiredForType = %d \n&quot;,amountOfNameQualificationRequiredForType);</a>
<a name="7854"><span class="lineNum">    7854 </span>            : #endif</a>
<a name="7855"><span class="lineNum">    7855 </span>            :        // Not all types have an associated declaration, but some do: examples include classes, typedefs, and enums.</a>
<a name="7856"><span class="lineNum">    7856 </span>            :           SgDeclarationStatement* declaration = getDeclarationAssociatedWithType(initializedName-&gt;get_type());</a>
<a name="7857"><span class="lineNum">    7857 </span>            :           if (declaration != NULL)</a>
<a name="7858"><span class="lineNum">    7858 </span>            :              {</a>
<a name="7859"><span class="lineNum">    7859 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="7860"><span class="lineNum">    7860 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Putting the name qualification for the type into the SgInitializedName = %p = %s \n&quot;,initializedName,initializedName-&gt;get_name().str());</a>
<a name="7861"><span class="lineNum">    7861 </span>            : #endif</a>
<a name="7862"><span class="lineNum">    7862 </span>            : </a>
<a name="7863"><span class="lineNum">    7863 </span>            : </a>
<a name="7864"><span class="lineNum">    7864 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="7865"><span class="lineNum">    7865 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;declaration = %p = %s \n&quot;,declaration,declaration-&gt;class_name().c_str());</a>
<a name="7866"><span class="lineNum">    7866 </span>            : #endif</a>
<a name="7867"><span class="lineNum">    7867 </span>            : </a>
<a name="7868"><span class="lineNum">    7868 </span>            : #if 1</a>
<a name="7869"><span class="lineNum">    7869 </span>            :             // **************************************************</a>
<a name="7870"><span class="lineNum">    7870 </span>            :             // DQ (8/4/2012): The type being used might not have to be qualified if it is associated with a SgClassDeclaration that has not been defined yet.</a>
<a name="7871"><span class="lineNum">    7871 </span>            :             // **************************************************</a>
<a name="7872"><span class="lineNum">    7872 </span>            :                bool skipGlobalNameQualification = skipNameQualificationIfNotProperlyDeclaredWhereDeclarationIsDefinable(declaration);</a>
<a name="7873"><span class="lineNum">    7873 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="7874"><span class="lineNum">    7874 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Test of Type used in SgVariableDeclaration: skipGlobalNameQualification = %s \n&quot;,skipGlobalNameQualification ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="7875"><span class="lineNum">    7875 </span>            : #endif</a>
<a name="7876"><span class="lineNum">    7876 </span>            : #if 1</a>
<a name="7877"><span class="lineNum">    7877 </span>            :             // setNameQualification(initializedName,declaration,amountOfNameQualificationRequiredForType,skipGlobalNameQualification);</a>
<a name="7878"><span class="lineNum">    7878 </span>            :                setNameQualificationOnType(initializedName,declaration,amountOfNameQualificationRequiredForType,skipGlobalNameQualification);</a>
<a name="7879"><span class="lineNum">    7879 </span>            : #else</a>
<a name="7880"><span class="lineNum">    7880 </span>            : </a>
<a name="7881"><span class="lineNum">    7881 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="7882"><span class="lineNum">    7882 </span>            : </a>
<a name="7883"><span class="lineNum">    7883 </span>            :                if (skipGlobalNameQualification == false)</a>
<a name="7884"><span class="lineNum">    7884 </span>            :                   {</a>
<a name="7885"><span class="lineNum">    7885 </span>            :                     setNameQualification(initializedName,declaration,amountOfNameQualificationRequiredForType);</a>
<a name="7886"><span class="lineNum">    7886 </span>            :                   }</a>
<a name="7887"><span class="lineNum">    7887 </span>            : #endif</a>
<a name="7888"><span class="lineNum">    7888 </span>            :             // **************************************************</a>
<a name="7889"><span class="lineNum">    7889 </span>            : #else</a>
<a name="7890"><span class="lineNum">    7890 </span>            : </a>
<a name="7891"><span class="lineNum">    7891 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="7892"><span class="lineNum">    7892 </span>            : </a>
<a name="7893"><span class="lineNum">    7893 </span>            :                setNameQualification(initializedName,declaration,amountOfNameQualificationRequiredForType);</a>
<a name="7894"><span class="lineNum">    7894 </span>            : #endif</a>
<a name="7895"><span class="lineNum">    7895 </span>            :              }</a>
<a name="7896"><span class="lineNum">    7896 </span>            :             else</a>
<a name="7897"><span class="lineNum">    7897 </span>            :              {</a>
<a name="7898"><span class="lineNum">    7898 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="7899"><span class="lineNum">    7899 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;declaration == NULL: could not put name qualification for the type into the SgInitializedName = %p = %s \n&quot;,initializedName,initializedName-&gt;get_name().str());</a>
<a name="7900"><span class="lineNum">    7900 </span>            : #endif</a>
<a name="7901"><span class="lineNum">    7901 </span>            :              }</a>
<a name="7902"><span class="lineNum">    7902 </span>            : </a>
<a name="7903"><span class="lineNum">    7903 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="7904"><span class="lineNum">    7904 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;\n++++++++++++++++ Calling nameQualificationDepth to evaluate the name currentScope = %p = %s \n&quot;,currentScope,currentScope-&gt;class_name().c_str());</a>
<a name="7905"><span class="lineNum">    7905 </span>            : #endif</a>
<a name="7906"><span class="lineNum">    7906 </span>            :           int amountOfNameQualificationRequiredForName = nameQualificationDepth(initializedName,currentScope,variableDeclaration);</a>
<a name="7907"><span class="lineNum">    7907 </span>            : </a>
<a name="7908"><span class="lineNum">    7908 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="7909"><span class="lineNum">    7909 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;SgVariableDeclaration's variable name: amountOfNameQualificationRequiredForName = %d \n&quot;,amountOfNameQualificationRequiredForName);</a>
<a name="7910"><span class="lineNum">    7910 </span>            : #endif</a>
<a name="7911"><span class="lineNum">    7911 </span>            : </a>
<a name="7912"><span class="lineNum">    7912 </span>            :        // DQ (6/5/2011): Debugging test2011_75.C ...</a>
<a name="7913"><span class="lineNum">    7913 </span>            : </a>
<a name="7914"><span class="lineNum">    7914 </span>            :        // If there is a previous declaration then that is the original declaration (see test2011_30.C for an example of this case).</a>
<a name="7915"><span class="lineNum">    7915 </span>            :           SgInitializedName* originalInitializedName = initializedName-&gt;get_prev_decl_item();</a>
<a name="7916"><span class="lineNum">    7916 </span>            :        // SgInitializedName* originalInitializedName = initializedName;</a>
<a name="7917"><span class="lineNum">    7917 </span>            : #if 0</a>
<a name="7918"><span class="lineNum">    7918 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Case of SgInitializedName: originalInitializedName = %p \n&quot;,originalInitializedName);</a>
<a name="7919"><span class="lineNum">    7919 </span>            : #endif</a>
<a name="7920"><span class="lineNum">    7920 </span>            :           if (originalInitializedName != NULL)</a>
<a name="7921"><span class="lineNum">    7921 </span>            :              {</a>
<a name="7922"><span class="lineNum">    7922 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="7923"><span class="lineNum">    7923 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;originalInitializedName = %p = %s \n&quot;,originalInitializedName,originalInitializedName-&gt;get_name().str());</a>
<a name="7924"><span class="lineNum">    7924 </span>            : #endif</a>
<a name="7925"><span class="lineNum">    7925 </span>            :             // DQ (6/5/2011): Handle case where originalInitializedName-&gt;get_parent() == NULL</a>
<a name="7926"><span class="lineNum">    7926 </span>            :             // ASSERT_not_null(originalInitializedName-&gt;get_parent());</a>
<a name="7927"><span class="lineNum">    7927 </span>            :                if (originalInitializedName-&gt;get_parent() != NULL)</a>
<a name="7928"><span class="lineNum">    7928 </span>            :                   {</a>
<a name="7929"><span class="lineNum">    7929 </span>            :                     SgVariableDeclaration* originalVariableDeclaration = isSgVariableDeclaration(originalInitializedName-&gt;get_parent());</a>
<a name="7930"><span class="lineNum">    7930 </span>            : </a>
<a name="7931"><span class="lineNum">    7931 </span>            :                  // DQ (6/4/2011): test2005_68.C is an example that fails this test.</a>
<a name="7932"><span class="lineNum">    7932 </span>            :                  // ASSERT_not_null(originalVariableDeclaration);</a>
<a name="7933"><span class="lineNum">    7933 </span>            :                  // setNameQualification(variableDeclaration,originalVariableDeclaration,amountOfNameQualificationRequiredForName);</a>
<a name="7934"><span class="lineNum">    7934 </span>            :                     if (originalVariableDeclaration != NULL)</a>
<a name="7935"><span class="lineNum">    7935 </span>            :                        {</a>
<a name="7936"><span class="lineNum">    7936 </span>            :                       // Accumulate names of scopes starting at the originalVariableDeclaration (amountOfNameQualificationRequiredForName times).</a>
<a name="7937"><span class="lineNum">    7937 </span>            :                          setNameQualification(variableDeclaration,originalVariableDeclaration,amountOfNameQualificationRequiredForName);</a>
<a name="7938"><span class="lineNum">    7938 </span>            :                        }</a>
<a name="7939"><span class="lineNum">    7939 </span>            :                       else</a>
<a name="7940"><span class="lineNum">    7940 </span>            :                        {</a>
<a name="7941"><span class="lineNum">    7941 </span>            :                       // DQ (6/4/2011): test2005_68.C is an example that fails this test (also test2011_70.C).  If the SgInitializedName</a>
<a name="7942"><span class="lineNum">    7942 </span>            :                       // is referenced before it is declared then it can appear associated via the symbol table through a non variable</a>
<a name="7943"><span class="lineNum">    7943 </span>            :                       // declaration (SgVariableDeclaration) IR node.</a>
<a name="7944"><span class="lineNum">    7944 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="7945"><span class="lineNum">    7945 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;WARNING: variableDeclaration case of name qualification originalVariableDeclaration == NULL (building alternativeDecaration) \n&quot;);</a>
<a name="7946"><span class="lineNum">    7946 </span>            : #endif</a>
<a name="7947"><span class="lineNum">    7947 </span>            :                          SgFunctionDeclaration* alternativeDecaration = TransformationSupport::getFunctionDeclaration(originalInitializedName-&gt;get_parent());</a>
<a name="7948"><span class="lineNum">    7948 </span>            : </a>
<a name="7949"><span class="lineNum">    7949 </span>            :                       // DQ (7/19/2012): Allow this to be NULL (see test2005_103.C), at least for testing.</a>
<a name="7950"><span class="lineNum">    7950 </span>            :                       // ASSERT_not_null(alternativeDecaration);</a>
<a name="7951"><span class="lineNum">    7951 </span>            :                       // setNameQualification(variableDeclaration,alternativeDecaration,amountOfNameQualificationRequiredForName);</a>
<a name="7952"><span class="lineNum">    7952 </span>            :                          if (alternativeDecaration != NULL)</a>
<a name="7953"><span class="lineNum">    7953 </span>            :                             {</a>
<a name="7954"><span class="lineNum">    7954 </span>            :                               setNameQualification(variableDeclaration,alternativeDecaration,amountOfNameQualificationRequiredForName);</a>
<a name="7955"><span class="lineNum">    7955 </span>            :                             }</a>
<a name="7956"><span class="lineNum">    7956 </span>            :                            else</a>
<a name="7957"><span class="lineNum">    7957 </span>            :                             {</a>
<a name="7958"><span class="lineNum">    7958 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;Warning: In name qualification support: alternativeDecaration == NULL (see test2005_103.C) \n&quot;);</a>
<a name="7959"><span class="lineNum">    7959 </span>            :                             }</a>
<a name="7960"><span class="lineNum">    7960 </span>            :                        }</a>
<a name="7961"><span class="lineNum">    7961 </span>            :                   }</a>
<a name="7962"><span class="lineNum">    7962 </span>            :                  else</a>
<a name="7963"><span class="lineNum">    7963 </span>            :                   {</a>
<a name="7964"><span class="lineNum">    7964 </span>            :                  // This is demonstrated by test2011_72.C (and maybe test2005_103.C).  I can't really fix this in the AST</a>
<a name="7965"><span class="lineNum">    7965 </span>            :                  // until I can get all of the test codes back to passing with the new name qualification support, so this</a>
<a name="7966"><span class="lineNum">    7966 </span>            :                  // will have to wait.  We output an error message for now.</a>
<a name="7967"><span class="lineNum">    7967 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="7968"><span class="lineNum">    7968 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Error: originalInitializedName-&gt;get_parent() == NULL (skipping any required name qualification, I think this is a bug in the AST) \n&quot;);</a>
<a name="7969"><span class="lineNum">    7969 </span>            : #endif</a>
<a name="7970"><span class="lineNum">    7970 </span>            :                   }</a>
<a name="7971"><span class="lineNum">    7971 </span>            :              }</a>
<a name="7972"><span class="lineNum">    7972 </span>            : </a>
<a name="7973"><span class="lineNum">    7973 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="7974"><span class="lineNum">    7974 </span>            : </a>
<a name="7975"><span class="lineNum">    7975 </span>            : #endif</a>
<a name="7976"><span class="lineNum">    7976 </span>            : </a>
<a name="7977"><span class="lineNum">    7977 </span><span class="lineCov">      14577 :           SgInitializedName* initializedName = SageInterface::getFirstInitializedName(variableDeclaration);</span></a>
<a name="7978"><span class="lineNum">    7978 </span><span class="lineCov">      14577 :           ASSERT_not_null(initializedName);</span></a>
<a name="7979"><span class="lineNum">    7979 </span>            : </a>
<a name="7980"><span class="lineNum">    7980 </span>            :        // DQ (7/24/2011): if there is a bit-field width specifier then it could contain variable references that require name qualification.</a>
<a name="7981"><span class="lineNum">    7981 </span><span class="lineCov">      14577 :           SgVariableDefinition* variableDefinition = isSgVariableDefinition(initializedName-&gt;get_declptr());</span></a>
<a name="7982"><span class="lineNum">    7982 </span><span class="lineCov">      14577 :           if (variableDefinition != NULL)</span></a>
<a name="7983"><span class="lineNum">    7983 </span>            :              {</a>
<a name="7984"><span class="lineNum">    7984 </span>            :             // This is not always the correct current scope (see test2011_70.C for an example).</a>
<a name="7985"><span class="lineNum">    7985 </span><span class="lineCov">      14561 :                SgScopeStatement* currentScope = SageInterface::getScope(variableDeclaration);</span></a>
<a name="7986"><span class="lineNum">    7986 </span><span class="lineCov">      14561 :                ASSERT_not_null(currentScope);</span></a>
<a name="7987"><span class="lineNum">    7987 </span>            : </a>
<a name="7988"><span class="lineNum">    7988 </span><span class="lineCov">      14561 :                SgExpression* bitFieldWidthSpecifier = variableDefinition-&gt;get_bitfield();</span></a>
<a name="7989"><span class="lineNum">    7989 </span><span class="lineCov">      14561 :                if (bitFieldWidthSpecifier != NULL)</span></a>
<a name="7990"><span class="lineNum">    7990 </span>            :                   {</a>
<a name="7991"><span class="lineNum">    7991 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="7992"><span class="lineNum">    7992 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Traverse the bitFieldWidthSpecifier and add any required name qualification.\n&quot;);</a>
<a name="7993"><span class="lineNum">    7993 </span>            : #endif</a>
<a name="7994"><span class="lineNum">    7994 </span>            :                  // DQ (4/28/2019): We might need to add additional arguments to this function, such as in:</a>
<a name="7995"><span class="lineNum">    7995 </span>            :                  // generateNestedTraversalWithExplicitScope(type,currentScope,currentStatement,initializedName);</a>
<a name="7996"><span class="lineNum">    7996 </span><span class="lineCov">         99 :                     generateNestedTraversalWithExplicitScope(bitFieldWidthSpecifier,currentScope);</span></a>
<a name="7997"><span class="lineNum">    7997 </span>            :                   }</a>
<a name="7998"><span class="lineNum">    7998 </span>            :              }</a>
<a name="7999"><span class="lineNum">    7999 </span>            : </a>
<a name="8000"><span class="lineNum">    8000 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="8001"><span class="lineNum">    8001 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;++++++++++++++++ DONE: Calling nameQualificationDepth to evaluate the name \n\n&quot;);</a>
<a name="8002"><span class="lineNum">    8002 </span>            : #endif</a>
<a name="8003"><span class="lineNum">    8003 </span>            :         }</a>
<a name="8004"><span class="lineNum">    8004 </span>            : </a>
<a name="8005"><span class="lineNum">    8005 </span>            : </a>
<a name="8006"><span class="lineNum">    8006 </span>            :   // DQ (8/23/2014): Adding more uniform support for SgInitializedName objects by supporting the SgFunctionParameterList (similar to the SgVariableDeclaration).</a>
<a name="8007"><span class="lineNum">    8007 </span><span class="lineCov">    2810440 :      SgFunctionParameterList* functionParameterList = isSgFunctionParameterList(n);</span></a>
<a name="8008"><span class="lineNum">    8008 </span><span class="lineCov">    2810440 :      if (functionParameterList != NULL)</span></a>
<a name="8009"><span class="lineNum">    8009 </span>            :         {</a>
<a name="8010"><span class="lineNum">    8010 </span>            : #if 0</a>
<a name="8011"><span class="lineNum">    8011 </span>            :        // mfprintf(mlog [ WARN ] ) (&quot;Case of SgFunctionParameterList: functionParameterList = %p \n&quot;,functionParameterList);</a>
<a name="8012"><span class="lineNum">    8012 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Case of SgFunctionParameterList: functionParameterList = %p: SgInitializedName nodes handled directly in pre-order traversal \n&quot;,functionParameterList);</a>
<a name="8013"><span class="lineNum">    8013 </span>            : #endif</a>
<a name="8014"><span class="lineNum">    8014 </span>            : </a>
<a name="8015"><span class="lineNum">    8015 </span>            : #if 0</a>
<a name="8016"><span class="lineNum">    8016 </span>            :        // DQ (4/9/2019): Commented out since we handle the function parameters directly in the pre-order traversal.</a>
<a name="8017"><span class="lineNum">    8017 </span>            :           SgScopeStatement* currentScope = SageInterface::getScope(functionParameterList);</a>
<a name="8018"><span class="lineNum">    8018 </span>            : </a>
<a name="8019"><span class="lineNum">    8019 </span>            :        // DQ (8/29/2014): This is a result of a transformation in the tutorial (codeCoverage.C) that does not appear to be implemeting a transformation correctly.</a>
<a name="8020"><span class="lineNum">    8020 </span>            :           if (currentScope == NULL)</a>
<a name="8021"><span class="lineNum">    8021 </span>            :              {</a>
<a name="8022"><span class="lineNum">    8022 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Error: currentScope == NULL: functionParameterList = %p \n&quot;,functionParameterList);</a>
<a name="8023"><span class="lineNum">    8023 </span>            :                SgFunctionDeclaration* functionDeclaration = isSgFunctionDeclaration(functionParameterList-&gt;get_parent());</a>
<a name="8024"><span class="lineNum">    8024 </span>            :                ASSERT_not_null(functionDeclaration);</a>
<a name="8025"><span class="lineNum">    8025 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Error: currentScope == NULL: functionDeclaration = %p = %s name = %s \n&quot;,functionDeclaration,functionDeclaration-&gt;class_name().c_str(),functionDeclaration-&gt;get_name().str());</a>
<a name="8026"><span class="lineNum">    8026 </span>            :                ASSERT_not_null(functionDeclaration-&gt;get_file_info());</a>
<a name="8027"><span class="lineNum">    8027 </span>            :                functionDeclaration-&gt;get_file_info()-&gt;display(&quot;Error: currentScope == NULL: functionParameterList-&gt;get_parent(): debug&quot;);</a>
<a name="8028"><span class="lineNum">    8028 </span>            :                SgScopeStatement* temp_scope = SageInterface::getScope(functionDeclaration);</a>
<a name="8029"><span class="lineNum">    8029 </span>            :                ASSERT_not_null(temp_scope);</a>
<a name="8030"><span class="lineNum">    8030 </span>            : </a>
<a name="8031"><span class="lineNum">    8031 </span>            :             // DQ (8/29/2014): It appears that we can't ask the SgFunctionParameterList for it's scope, but we can find the SgFunctionDeclaration from the parent and ask it; so this should be fixed.</a>
<a name="8032"><span class="lineNum">    8032 </span>            :                currentScope = temp_scope;</a>
<a name="8033"><span class="lineNum">    8033 </span>            : </a>
<a name="8034"><span class="lineNum">    8034 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;It appears that in the case of a transforamtion, we can't always ask the SgFunctionParameterList for it's scope, but we can find the SgFunctionDeclaration from the parent and ask it; so this should be fixed. \n&quot;);</a>
<a name="8035"><span class="lineNum">    8035 </span>            :              }</a>
<a name="8036"><span class="lineNum">    8036 </span>            :           ASSERT_not_null(currentScope);</a>
<a name="8037"><span class="lineNum">    8037 </span>            : </a>
<a name="8038"><span class="lineNum">    8038 </span>            :        // DQ (8/24/2014): This should be the same scope as what is in the inherited attribute, I think.</a>
<a name="8039"><span class="lineNum">    8039 </span>            :        // This fails for test2013_186.C, I expect it is because one of these is NULL (allowed for some nested traversals).</a>
<a name="8040"><span class="lineNum">    8040 </span>            :           if (currentScope != inheritedAttribute.get_currentScope())</a>
<a name="8041"><span class="lineNum">    8041 </span>            :              {</a>
<a name="8042"><span class="lineNum">    8042 </span>            :                if (currentScope != NULL &amp;&amp; inheritedAttribute.get_currentScope() != NULL)</a>
<a name="8043"><span class="lineNum">    8043 </span>            :                   {</a>
<a name="8044"><span class="lineNum">    8044 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 1)</a>
<a name="8045"><span class="lineNum">    8045 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;WARNING: currentScope != inheritedAttribute.get_currentScope(): currentScope = %p = %s inheritedAttribute.get_currentScope() = %p = %s \n&quot;,</a>
<a name="8046"><span class="lineNum">    8046 </span>            :                          currentScope,currentScope-&gt;class_name().c_str(),inheritedAttribute.get_currentScope(),inheritedAttribute.get_currentScope()-&gt;class_name().c_str());</a>
<a name="8047"><span class="lineNum">    8047 </span>            : #endif</a>
<a name="8048"><span class="lineNum">    8048 </span>            :                   }</a>
<a name="8049"><span class="lineNum">    8049 </span>            :              }</a>
<a name="8050"><span class="lineNum">    8050 </span>            :        // ROSE_ASSERT(currentScope == inheritedAttribute.get_currentScope());</a>
<a name="8051"><span class="lineNum">    8051 </span>            : </a>
<a name="8052"><span class="lineNum">    8052 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="8053"><span class="lineNum">    8053 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;================ Calling nameQualificationDepthForType to evaluate the type \n&quot;);</a>
<a name="8054"><span class="lineNum">    8054 </span>            : #endif</a>
<a name="8055"><span class="lineNum">    8055 </span>            : </a>
<a name="8056"><span class="lineNum">    8056 </span>            :           SgFunctionDeclaration* functionDeclaration = isSgFunctionDeclaration(functionParameterList-&gt;get_parent());</a>
<a name="8057"><span class="lineNum">    8057 </span>            :           ASSERT_not_null(functionDeclaration);</a>
<a name="8058"><span class="lineNum">    8058 </span>            : </a>
<a name="8059"><span class="lineNum">    8059 </span>            :           SgInitializedNamePtrList::iterator i = functionParameterList-&gt;get_args().begin();</a>
<a name="8060"><span class="lineNum">    8060 </span>            :           while (i != functionParameterList-&gt;get_args().end())</a>
<a name="8061"><span class="lineNum">    8061 </span>            :              {</a>
<a name="8062"><span class="lineNum">    8062 </span>            :                SgInitializedName* initializedName = *i;</a>
<a name="8063"><span class="lineNum">    8063 </span>            :                ASSERT_not_null(initializedName);</a>
<a name="8064"><span class="lineNum">    8064 </span>            : </a>
<a name="8065"><span class="lineNum">    8065 </span>            : #if 0</a>
<a name="8066"><span class="lineNum">    8066 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="8067"><span class="lineNum">    8067 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;================ Calling nameQualificationDepthForType to evaluate the type for initializedName = %p = %s \n&quot;,initializedName,initializedName-&gt;get_name().str());</a>
<a name="8068"><span class="lineNum">    8068 </span>            : #endif</a>
<a name="8069"><span class="lineNum">    8069 </span>            :             // Compute the depth of name qualification from the current statement:  variableDeclaration.</a>
<a name="8070"><span class="lineNum">    8070 </span>            :                int amountOfNameQualificationRequiredForType = nameQualificationDepthForType(initializedName,currentScope,functionDeclaration);</a>
<a name="8071"><span class="lineNum">    8071 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="8072"><span class="lineNum">    8072 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;SgFunctionParameterList's type: amountOfNameQualificationRequiredForType = %d \n&quot;,amountOfNameQualificationRequiredForType);</a>
<a name="8073"><span class="lineNum">    8073 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;   --- initializedName-&gt;get_type() = %p = %s \n&quot;,initializedName-&gt;get_type(),initializedName-&gt;get_type()-&gt;class_name().c_str());</a>
<a name="8074"><span class="lineNum">    8074 </span>            : #endif</a>
<a name="8075"><span class="lineNum">    8075 </span>            :             // Not all types have an associated declaration, but some do: examples include classes, typedefs, and enums.</a>
<a name="8076"><span class="lineNum">    8076 </span>            :                SgDeclarationStatement* declaration = getDeclarationAssociatedWithType(initializedName-&gt;get_type());</a>
<a name="8077"><span class="lineNum">    8077 </span>            :                if (declaration != NULL)</a>
<a name="8078"><span class="lineNum">    8078 </span>            :                   {</a>
<a name="8079"><span class="lineNum">    8079 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="8080"><span class="lineNum">    8080 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Putting the name qualification for the type into the SgInitializedName = %p = %s \n&quot;,initializedName,initializedName-&gt;get_name().str());</a>
<a name="8081"><span class="lineNum">    8081 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;   --- getDeclarationAssociatedWithType(): declaration                 = %p = %s \n&quot;,declaration,declaration-&gt;class_name().c_str());</a>
<a name="8082"><span class="lineNum">    8082 </span>            : #endif</a>
<a name="8083"><span class="lineNum">    8083 </span>            : </a>
<a name="8084"><span class="lineNum">    8084 </span>            :                  // **************************************************</a>
<a name="8085"><span class="lineNum">    8085 </span>            :                  // DQ (8/4/2012): The type being used might not have to be qualified if it is associated with a SgClassDeclaration that has not been defined yet.</a>
<a name="8086"><span class="lineNum">    8086 </span>            :                  // **************************************************</a>
<a name="8087"><span class="lineNum">    8087 </span>            :                     bool skipGlobalNameQualification = false; // skipNameQualificationIfNotProperlyDeclaredWhereDeclarationIsDefinable(declaration);</a>
<a name="8088"><span class="lineNum">    8088 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="8089"><span class="lineNum">    8089 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Test of Type used in SgVariableDeclaration: skipGlobalNameQualification = %s \n&quot;,skipGlobalNameQualification ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="8090"><span class="lineNum">    8090 </span>            : #endif</a>
<a name="8091"><span class="lineNum">    8091 </span>            :                  // setNameQualification(initializedName,declaration,amountOfNameQualificationRequiredForType,skipGlobalNameQualification);</a>
<a name="8092"><span class="lineNum">    8092 </span>            :                     setNameQualificationOnType(initializedName,declaration,amountOfNameQualificationRequiredForType,skipGlobalNameQualification);</a>
<a name="8093"><span class="lineNum">    8093 </span>            :                   }</a>
<a name="8094"><span class="lineNum">    8094 </span>            : #else</a>
<a name="8095"><span class="lineNum">    8095 </span>            :             // DQ (3/31/2019): We want to handle the SgInitializedName IR node consistant now that we have identified the need</a>
<a name="8096"><span class="lineNum">    8096 </span>            :             // to support name qualification of it in the case of SgInitializedName nodes using the SgPointerMemberType type.</a>
<a name="8097"><span class="lineNum">    8097 </span>            : #if 1</a>
<a name="8098"><span class="lineNum">    8098 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;@@@@@@@@@@@@@@@@@@ \n&quot;);</a>
<a name="8099"><span class="lineNum">    8099 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;@@@@@@@@@@@@@@@@@@ Processing of SgInitializedName in the SgFunctionParameterList is dererreed to the traversal of the SgInitializedName \n&quot;);</a>
<a name="8100"><span class="lineNum">    8100 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;@@@@@@@@@@@@@@@@@@ \n&quot;);</a>
<a name="8101"><span class="lineNum">    8101 </span>            : #endif</a>
<a name="8102"><span class="lineNum">    8102 </span>            : #endif</a>
<a name="8103"><span class="lineNum">    8103 </span>            :                i++;</a>
<a name="8104"><span class="lineNum">    8104 </span>            :              }</a>
<a name="8105"><span class="lineNum">    8105 </span>            : </a>
<a name="8106"><span class="lineNum">    8106 </span>            :        // DQ (4/9/2019): Commented out since we handle the function parameters directly in the pre-order traversal.</a>
<a name="8107"><span class="lineNum">    8107 </span>            : #endif</a>
<a name="8108"><span class="lineNum">    8108 </span>            : </a>
<a name="8109"><span class="lineNum">    8109 </span>            : #if 0</a>
<a name="8110"><span class="lineNum">    8110 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="8111"><span class="lineNum">    8111 </span>            :           ROSE_ABORT();</a>
<a name="8112"><span class="lineNum">    8112 </span>            : #endif</a>
<a name="8113"><span class="lineNum">    8113 </span>            :         }</a>
<a name="8114"><span class="lineNum">    8114 </span>            : </a>
<a name="8115"><span class="lineNum">    8115 </span>            :   // DQ (4/18/2019): Added support for traversals over the type, so that we can support SgPointerMemberType which can exist within nested type.</a>
<a name="8116"><span class="lineNum">    8116 </span>            :   // Because this can happen in nexted types we need the type traversal to discover these.  I am hoping this will not be a performance issue</a>
<a name="8117"><span class="lineNum">    8117 </span>            :   // for long types stemming from template instatiations, if so we might want to detect these seperately and avoid name qualification for them.</a>
<a name="8118"><span class="lineNum">    8118 </span><span class="lineCov">    2810440 :      SgPointerMemberType* pointerMemberType = isSgPointerMemberType(n);</span></a>
<a name="8119"><span class="lineNum">    8119 </span><span class="lineCov">    2810440 :      if (pointerMemberType != NULL)</span></a>
<a name="8120"><span class="lineNum">    8120 </span>            :         {</a>
<a name="8121"><span class="lineNum">    8121 </span><span class="lineCov">        382 :           SgScopeStatement* currentScope = inheritedAttribute.get_currentScope();</span></a>
<a name="8122"><span class="lineNum">    8122 </span><span class="lineCov">        382 :           ASSERT_not_null(currentScope);</span></a>
<a name="8123"><span class="lineNum">    8123 </span>            : </a>
<a name="8124"><span class="lineNum">    8124 </span>            :        // DQ (4/19/2019): This is not a good idea, I have modified the recursive step to allow us to pass the currentStatement as well (optionally).</a>
<a name="8125"><span class="lineNum">    8125 </span>            :        // DQ (4/18/2019): See if we can make the currentStatement just the currentScope.</a>
<a name="8126"><span class="lineNum">    8126 </span>            :        // SgStatement* currentStatement = currentScope;</a>
<a name="8127"><span class="lineNum">    8127 </span><span class="lineCov">        382 :           SgStatement* currentStatement = inheritedAttribute.get_currentStatement();</span></a>
<a name="8128"><span class="lineNum">    8128 </span><span class="lineCov">        382 :           ASSERT_not_null(currentStatement);</span></a>
<a name="8129"><span class="lineNum">    8129 </span>            : </a>
<a name="8130"><span class="lineNum">    8130 </span>            :        // We need to have saved the referenceNode to use since this is associated with a shared type.</a>
<a name="8131"><span class="lineNum">    8131 </span><span class="lineCov">        382 :           SgNode* referenceNode = inheritedAttribute.get_referenceNode();</span></a>
<a name="8132"><span class="lineNum">    8132 </span><span class="lineCov">        382 :           ASSERT_not_null(referenceNode);</span></a>
<a name="8133"><span class="lineNum">    8133 </span>            : </a>
<a name="8134"><span class="lineNum">    8134 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="8135"><span class="lineNum">    8135 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Case SgPointerMemberType: referenceNode = %p = %s \n&quot;,referenceNode,referenceNode-&gt;class_name().c_str());</a>
<a name="8136"><span class="lineNum">    8136 </span>            : #endif</a>
<a name="8137"><span class="lineNum">    8137 </span>            : </a>
<a name="8138"><span class="lineNum">    8138 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="8139"><span class="lineNum">    8139 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;###################################################### \n&quot;);</a>
<a name="8140"><span class="lineNum">    8140 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Case SgPointerMemberType: Compute name qualification() \n&quot;);</a>
<a name="8141"><span class="lineNum">    8141 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;###################################################### \n&quot;);</a>
<a name="8142"><span class="lineNum">    8142 </span>            : #endif</a>
<a name="8143"><span class="lineNum">    8143 </span>            : </a>
<a name="8144"><span class="lineNum">    8144 </span><span class="lineCov">        382 :           SgDeclarationStatement* classDeclaration = pointerMemberType-&gt;get_class_declaration_of();</span></a>
<a name="8145"><span class="lineNum">    8145 </span><span class="lineCov">        382 :           ASSERT_not_null(classDeclaration);</span></a>
<a name="8146"><span class="lineNum">    8146 </span>            : </a>
<a name="8147"><span class="lineNum">    8147 </span>            :        // SgDeclarationStatement* declarationForInitializedName = classDeclaration;</a>
<a name="8148"><span class="lineNum">    8148 </span>            :        // ASSERT_not_null(declarationForInitializedName);</a>
<a name="8149"><span class="lineNum">    8149 </span>            :        // SgDeclarationStatement* positionStatement = isSgDeclarationStatement(initializedName-&gt;get_parent());</a>
<a name="8150"><span class="lineNum">    8150 </span>            : </a>
<a name="8151"><span class="lineNum">    8151 </span>            :        // DQ (4/21/2019): This a SgExprStatement when we are processing a SgSizeOfOp IR node (see test2019_379.C).</a>
<a name="8152"><span class="lineNum">    8152 </span>            :        // SgDeclarationStatement* positionStatement = isSgDeclarationStatement(currentStatement);</a>
<a name="8153"><span class="lineNum">    8153 </span><span class="lineCov">        382 :           SgStatement* positionStatement = isSgStatement(currentStatement);</span></a>
<a name="8154"><span class="lineNum">    8154 </span><span class="lineCov">        382 :           if (positionStatement == NULL)</span></a>
<a name="8155"><span class="lineNum">    8155 </span>            :              {</a>
<a name="8156"><span class="lineNum">    8156 </span><span class="lineNoCov">          0 :                ASSERT_not_null(currentStatement);</span></a>
<a name="8157"><span class="lineNum">    8157 </span><span class="lineNoCov">          0 :                mfprintf(mlog [ WARN ] ) (&quot;Error: currentStatement = %p = %s \n&quot;,currentStatement,currentStatement-&gt;class_name().c_str());</span></a>
<a name="8158"><span class="lineNum">    8158 </span>            :              }</a>
<a name="8159"><span class="lineNum">    8159 </span><span class="lineCov">        382 :           ASSERT_not_null(positionStatement);</span></a>
<a name="8160"><span class="lineNum">    8160 </span>            : </a>
<a name="8161"><span class="lineNum">    8161 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="8162"><span class="lineNum">    8162 </span>            :        // mfprintf(mlog [ WARN ] ) (&quot;Correcting associated declaration: declarationForInitializedName = %p = %s \n&quot;,declarationForInitializedName,declarationForInitializedName-&gt;class_name().c_str());</a>
<a name="8163"><span class="lineNum">    8163 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Correcting associated declaration: classDeclaration  = %p = %s \n&quot;,classDeclaration,classDeclaration-&gt;class_name().c_str());</a>
<a name="8164"><span class="lineNum">    8164 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Correcting associated declaration: positionStatement = %p = %s \n&quot;,positionStatement,positionStatement-&gt;class_name().c_str());</a>
<a name="8165"><span class="lineNum">    8165 </span>            : #endif</a>
<a name="8166"><span class="lineNum">    8166 </span>            :        // int amountOfNameQualificationRequiredForName = nameQualificationDepth(initializedName,currentScope,variableDeclaration);</a>
<a name="8167"><span class="lineNum">    8167 </span>            :        // int amountOfNameQualificationRequiredForName = nameQualificationDepth(initializedName,currentScope,declarationForInitializedName);</a>
<a name="8168"><span class="lineNum">    8168 </span>            :        // int amountOfNameQualificationRequiredForName = nameQualificationDepth(declarationForInitializedName,currentScope,positionStatement);</a>
<a name="8169"><span class="lineNum">    8169 </span><span class="lineCov">        382 :           int amountOfNameQualificationRequired = nameQualificationDepth(classDeclaration,currentScope,positionStatement);</span></a>
<a name="8170"><span class="lineNum">    8170 </span>            : </a>
<a name="8171"><span class="lineNum">    8171 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="8172"><span class="lineNum">    8172 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;SgPointerMemberType: amountOfNameQualificationRequired = %d \n&quot;,amountOfNameQualificationRequired);</a>
<a name="8173"><span class="lineNum">    8173 </span>            : #endif</a>
<a name="8174"><span class="lineNum">    8174 </span>            : </a>
<a name="8175"><span class="lineNum">    8175 </span>            : #if 0</a>
<a name="8176"><span class="lineNum">    8176 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;######################################################## \n&quot;);</a>
<a name="8177"><span class="lineNum">    8177 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Case SgPointerMemberType: Calling setNameQualification() \n&quot;);</a>
<a name="8178"><span class="lineNum">    8178 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;######################################################## \n&quot;);</a>
<a name="8179"><span class="lineNum">    8179 </span>            : #endif</a>
<a name="8180"><span class="lineNum">    8180 </span>            : </a>
<a name="8181"><span class="lineNum">    8181 </span>            :        // DQ (4/20/2019): Need to pass the reference node which is the node for which this is a type (intial testing this should be a SgInitializedName).</a>
<a name="8182"><span class="lineNum">    8182 </span>            :        // bool skipGlobalNameQualification = true;</a>
<a name="8183"><span class="lineNum">    8183 </span>            :        // bool skipGlobalNameQualification = false;</a>
<a name="8184"><span class="lineNum">    8184 </span>            :        // setNameQualificationOnName(initializedName,declaration,amountOfNameQualificationRequiredForName,skipGlobalNameQualification);</a>
<a name="8185"><span class="lineNum">    8185 </span>            :        // setNameQualificationOnName(initializedName,positionStatement,amountOfNameQualificationRequiredForName,skipGlobalNameQualification);</a>
<a name="8186"><span class="lineNum">    8186 </span>            :        // setNameQualificationOnName(initializedName,declarationForInitializedName,amountOfNameQualificationRequiredForName,skipGlobalNameQualification);</a>
<a name="8187"><span class="lineNum">    8187 </span>            :        // setNameQualification(pointerMemberType,classDeclaration,amountOfNameQualificationRequired,skipGlobalNameQualification);</a>
<a name="8188"><span class="lineNum">    8188 </span>            :        // setNameQualification(pointerMemberType,classDeclaration,amountOfNameQualificationRequired);</a>
<a name="8189"><span class="lineNum">    8189 </span>            :        // setNameQualification(pointerMemberType,referenceNode,amountOfNameQualificationRequired);</a>
<a name="8190"><span class="lineNum">    8190 </span>            :        // setNameQualification(referenceNode,classDeclaration,amountOfNameQualificationRequired);</a>
<a name="8191"><span class="lineNum">    8191 </span>            :        // setNameQualification(pointerMemberType,classDeclaration,amountOfNameQualificationRequired);</a>
<a name="8192"><span class="lineNum">    8192 </span><span class="lineCov">        382 :           setNameQualificationOnClassOf(pointerMemberType,classDeclaration,amountOfNameQualificationRequired);</span></a>
<a name="8193"><span class="lineNum">    8193 </span>            : </a>
<a name="8194"><span class="lineNum">    8194 </span>            : #if 0</a>
<a name="8195"><span class="lineNum">    8195 </span>            :        // DQ (4/21/2019): I think this must be called on in the evaluateSythesisedAttribute traversal,</a>
<a name="8196"><span class="lineNum">    8196 </span>            :        // since it requires that the string results already be computed for nested types.</a>
<a name="8197"><span class="lineNum">    8197 </span>            : #if 0</a>
<a name="8198"><span class="lineNum">    8198 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;################################################ \n&quot;);</a>
<a name="8199"><span class="lineNum">    8199 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Case SgPointerMemberType: Calling traverseType() \n&quot;);</a>
<a name="8200"><span class="lineNum">    8200 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;################################################ \n&quot;);</a>
<a name="8201"><span class="lineNum">    8201 </span>            : #endif</a>
<a name="8202"><span class="lineNum">    8202 </span>            : </a>
<a name="8203"><span class="lineNum">    8203 </span>            :        // traverseType(pointerMemberType,pointerMemberType,currentScope,currentStatement);</a>
<a name="8204"><span class="lineNum">    8204 </span>            :           traverseType(pointerMemberType,referenceNode,currentScope,currentStatement);</a>
<a name="8205"><span class="lineNum">    8205 </span>            : #endif</a>
<a name="8206"><span class="lineNum">    8206 </span>            : </a>
<a name="8207"><span class="lineNum">    8207 </span>            : #if 0</a>
<a name="8208"><span class="lineNum">    8208 </span>            :        // DQ (4/21/2019): We don't have to reset anything because we are not calling the generateNestedTraversalWithExplicitScope() function.</a>
<a name="8209"><span class="lineNum">    8209 </span>            : #if 0</a>
<a name="8210"><span class="lineNum">    8210 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Reset inheritedAttribute with new referenceNode = %p = %s \n&quot;,pointerMemberType,pointerMemberType-&gt;class_name().c_str());</a>
<a name="8211"><span class="lineNum">    8211 </span>            : #endif</a>
<a name="8212"><span class="lineNum">    8212 </span>            :        // DQ (4/19/2019): Reset the referenceNode in in the inherited attribute to be the current pointerMemberType node.</a>
<a name="8213"><span class="lineNum">    8213 </span>            :           inheritedAttribute.set_referenceNode(pointerMemberType);</a>
<a name="8214"><span class="lineNum">    8214 </span>            :           ASSERT_not_null(inheritedAttribute.get_referenceNode());</a>
<a name="8215"><span class="lineNum">    8215 </span>            : </a>
<a name="8216"><span class="lineNum">    8216 </span>            :        // DQ (4/18/2019): I think we need to traverse the type doing a proper type travesal, since it can consist of</a>
<a name="8217"><span class="lineNum">    8217 </span>            :        // long chains of types that each must be name qualified. The example of a chain of SgPointerToMemberTypes is</a>
<a name="8218"><span class="lineNum">    8218 </span>            :        // the best example of this.</a>
<a name="8219"><span class="lineNum">    8219 </span>            :        // ASSERT_not_null(currentScope);</a>
<a name="8220"><span class="lineNum">    8220 </span>            :        // generateNestedTraversalWithExplicitScope(pointerMemberType,currentScope);</a>
<a name="8221"><span class="lineNum">    8221 </span>            : #endif</a>
<a name="8222"><span class="lineNum">    8222 </span>            : </a>
<a name="8223"><span class="lineNum">    8223 </span>            : #if 0</a>
<a name="8224"><span class="lineNum">    8224 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="8225"><span class="lineNum">    8225 </span>            :           ROSE_ABORT();</a>
<a name="8226"><span class="lineNum">    8226 </span>            : #endif</a>
<a name="8227"><span class="lineNum">    8227 </span>            : </a>
<a name="8228"><span class="lineNum">    8228 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="8229"><span class="lineNum">    8229 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;################################################ \n&quot;);</a>
<a name="8230"><span class="lineNum">    8230 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Case SgPointerMemberType: Evaluate the base type \n&quot;);</a>
<a name="8231"><span class="lineNum">    8231 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;################################################ \n&quot;);</a>
<a name="8232"><span class="lineNum">    8232 </span>            : #endif</a>
<a name="8233"><span class="lineNum">    8233 </span>            : </a>
<a name="8234"><span class="lineNum">    8234 </span>            :        // DQ (4/20/2019): Now look at the base type, if it is not a SgPointerMemberType, then compute the associated name qualification.</a>
<a name="8235"><span class="lineNum">    8235 </span>            :        // We will of course traverse this type, but at the time of the traversal, we would not compute the name qualification since it</a>
<a name="8236"><span class="lineNum">    8236 </span>            :        // would be done from the context of the IR node that references the type.</a>
<a name="8237"><span class="lineNum">    8237 </span><span class="lineCov">        382 :           SgType* baseType = pointerMemberType-&gt;get_base_type();</span></a>
<a name="8238"><span class="lineNum">    8238 </span><span class="lineCov">        382 :           ASSERT_not_null(baseType);</span></a>
<a name="8239"><span class="lineNum">    8239 </span>            : </a>
<a name="8240"><span class="lineNum">    8240 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="8241"><span class="lineNum">    8241 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Case SgPointerMemberType: baseType = %p = %s \n&quot;,baseType,baseType-&gt;class_name().c_str());</a>
<a name="8242"><span class="lineNum">    8242 </span>            : #endif</a>
<a name="8243"><span class="lineNum">    8243 </span>            : </a>
<a name="8244"><span class="lineNum">    8244 </span>            :        // DQ (4/21/2019): Reset the type so that we don't miss the SgPointerMemberType, but ignore other modifiers.</a>
<a name="8245"><span class="lineNum">    8245 </span><span class="lineCov">        382 :           unsigned char bit_array = SgType::STRIP_MODIFIER_TYPE | SgType::STRIP_REFERENCE_TYPE | SgType::STRIP_RVALUE_REFERENCE_TYPE |</span></a>
<a name="8246"><span class="lineNum">    8246 </span>            :                                     SgType::STRIP_POINTER_TYPE  | SgType::STRIP_ARRAY_TYPE;</a>
<a name="8247"><span class="lineNum">    8247 </span><span class="lineCov">        382 :           baseType = baseType-&gt;stripType(bit_array);</span></a>
<a name="8248"><span class="lineNum">    8248 </span><span class="lineCov">        382 :           ASSERT_not_null(baseType);</span></a>
<a name="8249"><span class="lineNum">    8249 </span>            : </a>
<a name="8250"><span class="lineNum">    8250 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="8251"><span class="lineNum">    8251 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Case SgPointerMemberType: after stripType(): baseType = %p = %s \n&quot;,baseType,baseType-&gt;class_name().c_str());</a>
<a name="8252"><span class="lineNum">    8252 </span>            : #endif</a>
<a name="8253"><span class="lineNum">    8253 </span>            : </a>
<a name="8254"><span class="lineNum">    8254 </span><span class="lineCov">        382 :           SgPointerMemberType* pointerMemberBaseType = isSgPointerMemberType(baseType);</span></a>
<a name="8255"><span class="lineNum">    8255 </span><span class="lineCov">        382 :           if (pointerMemberBaseType == NULL)</span></a>
<a name="8256"><span class="lineNum">    8256 </span>            :              {</a>
<a name="8257"><span class="lineNum">    8257 </span>            :             // Need to handle name qualification of this type (if there is an associated declaration).</a>
<a name="8258"><span class="lineNum">    8258 </span>            : </a>
<a name="8259"><span class="lineNum">    8259 </span><span class="lineCov">        382 :                SgDeclarationStatement* declaration = getDeclarationAssociatedWithType(baseType);</span></a>
<a name="8260"><span class="lineNum">    8260 </span>            : </a>
<a name="8261"><span class="lineNum">    8261 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="8262"><span class="lineNum">    8262 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Case SgPointerMemberType: declaration = %p = %s \n&quot;,declaration,(declaration != NULL) ? baseType-&gt;class_name().c_str() : &quot;null&quot;);</a>
<a name="8263"><span class="lineNum">    8263 </span>            : #endif</a>
<a name="8264"><span class="lineNum">    8264 </span><span class="lineCov">        382 :                if (declaration != NULL)</span></a>
<a name="8265"><span class="lineNum">    8265 </span>            :                   {</a>
<a name="8266"><span class="lineNum">    8266 </span>            :                  // DQ (4/21/2019): Handle the base type of the SgPointerMemberType, if it is not another nested SgPointerMemberType IR node.</a>
<a name="8267"><span class="lineNum">    8267 </span><span class="lineCov">        382 :                     ASSERT_not_null(currentScope);</span></a>
<a name="8268"><span class="lineNum">    8268 </span><span class="lineCov">        382 :                     ASSERT_not_null(positionStatement);</span></a>
<a name="8269"><span class="lineNum">    8269 </span>            :                  // int amountOfNameQualificationRequiredForName = nameQualificationDepth(declarationForInitializedName,currentScope,positionStatement);</a>
<a name="8270"><span class="lineNum">    8270 </span><span class="lineCov">        382 :                     int amountOfNameQualificationRequiredForType = nameQualificationDepth(declaration,currentScope,positionStatement);</span></a>
<a name="8271"><span class="lineNum">    8271 </span>            : </a>
<a name="8272"><span class="lineNum">    8272 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="8273"><span class="lineNum">    8273 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;SgPointerMemberType: base type: amountOfNameQualificationRequiredForType = %d \n&quot;,amountOfNameQualificationRequiredForType);</a>
<a name="8274"><span class="lineNum">    8274 </span>            : #endif</a>
<a name="8275"><span class="lineNum">    8275 </span>            :                  // bool skipGlobalNameQualification = true;</a>
<a name="8276"><span class="lineNum">    8276 </span>            :                  // bool skipGlobalNameQualification = false;</a>
<a name="8277"><span class="lineNum">    8277 </span>            :                  // setNameQualificationOnName(initializedName,declaration,amountOfNameQualificationRequiredForName,skipGlobalNameQualification);</a>
<a name="8278"><span class="lineNum">    8278 </span>            :                  // setNameQualificationOnName(initializedName,positionStatement,amountOfNameQualificationRequiredForName,skipGlobalNameQualification);</a>
<a name="8279"><span class="lineNum">    8279 </span>            :                  // setNameQualificationOnName(initializedName,declarationForInitializedName,amountOfNameQualificationRequiredForName,skipGlobalNameQualification);</a>
<a name="8280"><span class="lineNum">    8280 </span>            :                  // setNameQualificationOnType(pointerMemberType,declaration,amountOfNameQualificationRequiredForType,skipGlobalNameQualification);</a>
<a name="8281"><span class="lineNum">    8281 </span><span class="lineCov">        382 :                     setNameQualificationOnBaseType(pointerMemberType,declaration,amountOfNameQualificationRequiredForType);</span></a>
<a name="8282"><span class="lineNum">    8282 </span>            : #if 0</a>
<a name="8283"><span class="lineNum">    8283 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="8284"><span class="lineNum">    8284 </span>            :                     ROSE_ABORT();</a>
<a name="8285"><span class="lineNum">    8285 </span>            : #endif</a>
<a name="8286"><span class="lineNum">    8286 </span>            :                   }</a>
<a name="8287"><span class="lineNum">    8287 </span>            :                  else</a>
<a name="8288"><span class="lineNum">    8288 </span>            :                   {</a>
<a name="8289"><span class="lineNum">    8289 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="8290"><span class="lineNum">    8290 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;The base type of the SgPointerMemberType has no associated declaration (so cannot be name qualified) \n&quot;);</a>
<a name="8291"><span class="lineNum">    8291 </span>            : #endif</a>
<a name="8292"><span class="lineNum">    8292 </span>            :                   }</a>
<a name="8293"><span class="lineNum">    8293 </span>            : #if 0</a>
<a name="8294"><span class="lineNum">    8294 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="8295"><span class="lineNum">    8295 </span>            :                ROSE_ABORT();</a>
<a name="8296"><span class="lineNum">    8296 </span>            : #endif</a>
<a name="8297"><span class="lineNum">    8297 </span>            :              }</a>
<a name="8298"><span class="lineNum">    8298 </span>            :             else</a>
<a name="8299"><span class="lineNum">    8299 </span>            :              {</a>
<a name="8300"><span class="lineNum">    8300 </span>            :             // This is a nested SgPointerMemberType in a SgPointerMemberType, it will be processed as part of the type traversal.</a>
<a name="8301"><span class="lineNum">    8301 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="8302"><span class="lineNum">    8302 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Detected a nested SgPointerMemberType, it will be processed as part of the recursion of the type traversal \n&quot;);</a>
<a name="8303"><span class="lineNum">    8303 </span>            : #endif</a>
<a name="8304"><span class="lineNum">    8304 </span>            : #if 0</a>
<a name="8305"><span class="lineNum">    8305 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="8306"><span class="lineNum">    8306 </span>            :                ROSE_ABORT();</a>
<a name="8307"><span class="lineNum">    8307 </span>            : #endif</a>
<a name="8308"><span class="lineNum">    8308 </span>            :              }</a>
<a name="8309"><span class="lineNum">    8309 </span>            :         }</a>
<a name="8310"><span class="lineNum">    8310 </span>            : </a>
<a name="8311"><span class="lineNum">    8311 </span>            : </a>
<a name="8312"><span class="lineNum">    8312 </span>            :   // Handle SgType name qualification where SgInitializedName's appear outside of SgVariableDeclaration's (e.g. in function parameter declarations).</a>
<a name="8313"><span class="lineNum">    8313 </span><span class="lineCov">    2810440 :      SgInitializedName* initializedName = isSgInitializedName(n);</span></a>
<a name="8314"><span class="lineNum">    8314 </span><span class="lineCov">    2810440 :      if (initializedName != NULL)</span></a>
<a name="8315"><span class="lineNum">    8315 </span>            :         {</a>
<a name="8316"><span class="lineNum">    8316 </span>            : </a>
<a name="8317"><span class="lineNum">    8317 </span>            :        // bool debugging = false;</a>
<a name="8318"><span class="lineNum">    8318 </span>            : #if DEBUG_INITIALIZED_NAME || 0</a>
<a name="8319"><span class="lineNum">    8319 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Case SgInitializedName: initializedName = %p = %s name = %s \n&quot;,initializedName,initializedName-&gt;class_name().c_str(),initializedName-&gt;get_name().str());</a>
<a name="8320"><span class="lineNum">    8320 </span>            :           mfprintf(mlog [ WARN ] ) (&quot; --- initializedName-&gt;get_parent() = %p = %s \n&quot;,initializedName-&gt;get_parent(),initializedName-&gt;get_parent()-&gt;class_name().c_str());</a>
<a name="8321"><span class="lineNum">    8321 </span>            : #endif</a>
<a name="8322"><span class="lineNum">    8322 </span>            : </a>
<a name="8323"><span class="lineNum">    8323 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || DEBUG_INITIALIZED_NAME</a>
<a name="8324"><span class="lineNum">    8324 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Case of SgInitializedName: type = %p = %s name = %s \n&quot;,initializedName-&gt;get_type(),initializedName-&gt;get_type()-&gt;class_name().c_str(),initializedName-&gt;get_name().str());</a>
<a name="8325"><span class="lineNum">    8325 </span>            : #endif</a>
<a name="8326"><span class="lineNum">    8326 </span>            :        // DQ (3/31/2019): Adding debugging support to debug pointer-to-membr name qualification.</a>
<a name="8327"><span class="lineNum">    8327 </span>            :        // bool debugging = (initializedName-&gt;get_name() == &quot;callback_func_ptr&quot;);</a>
<a name="8328"><span class="lineNum">    8328 </span>            :        // bool debugging = (initializedName-&gt;get_name() == &quot;pointer_to_data&quot;);</a>
<a name="8329"><span class="lineNum">    8329 </span>            :        // bool debugging = (initializedName-&gt;get_name() == &quot;p2&quot;);</a>
<a name="8330"><span class="lineNum">    8330 </span>            :        // bool debugging = (initializedName-&gt;get_name() == &quot;xyz&quot;);</a>
<a name="8331"><span class="lineNum">    8331 </span>            : </a>
<a name="8332"><span class="lineNum">    8332 </span>            :        // DQ (3/31/2019): Adding name qualification for the SgInitialized name directly (then we need to remove</a>
<a name="8333"><span class="lineNum">    8333 </span>            :        // it from there it is introduced in the SgVariableDeclaration and the SgFunctionParameterList). The point</a>
<a name="8334"><span class="lineNum">    8334 </span>            :        // of adding it here is the it is required for pointer-to-member declarations that are not associated with</a>
<a name="8335"><span class="lineNum">    8335 </span>            :        // the base type of the pointer-to-member type and must be name qualified differently from the base type</a>
<a name="8336"><span class="lineNum">    8336 </span>            :        // (as demonstrated in C++11_tests/test2019_333.C).</a>
<a name="8337"><span class="lineNum">    8337 </span>            : </a>
<a name="8338"><span class="lineNum">    8338 </span>            : </a>
<a name="8339"><span class="lineNum">    8339 </span>            :        // DQ (4/26/2019): We need the currentScope where we are evaluating the name qualification, not the scope of the initialized name.</a>
<a name="8340"><span class="lineNum">    8340 </span>            :        // SgScopeStatement* currentScope = SageInterface::getScope(variableDeclaration);</a>
<a name="8341"><span class="lineNum">    8341 </span>            :        // SgScopeStatement* currentScope = isSgScopeStatement(variableDeclaration-&gt;get_parent());</a>
<a name="8342"><span class="lineNum">    8342 </span>            :        // SgScopeStatement* currentScope = initializedName-&gt;get_scope();</a>
<a name="8343"><span class="lineNum">    8343 </span><span class="lineCov">    1462240 :           SgNode* initializedNameParent = initializedName-&gt;get_parent();</span></a>
<a name="8344"><span class="lineNum">    8344 </span><span class="lineCov">    1462240 :           SgDeclarationStatement* declarationStatement = isSgDeclarationStatement(initializedNameParent);</span></a>
<a name="8345"><span class="lineNum">    8345 </span><span class="lineCov">    1462240 :           if (declarationStatement == NULL)</span></a>
<a name="8346"><span class="lineNum">    8346 </span>            :              {</a>
<a name="8347"><span class="lineNum">    8347 </span><span class="lineNoCov">          0 :                mfprintf(mlog [ WARN ] ) (&quot;What is this: initializedNameParent = %p = %s \n&quot;,initializedNameParent,initializedNameParent-&gt;class_name().c_str());</span></a>
<a name="8348"><span class="lineNum">    8348 </span><span class="lineNoCov">          0 :                ROSE_ABORT();</span></a>
<a name="8349"><span class="lineNum">    8349 </span>            :              }</a>
<a name="8350"><span class="lineNum">    8350 </span><span class="lineCov">    1462240 :           ASSERT_not_null(declarationStatement);</span></a>
<a name="8351"><span class="lineNum">    8351 </span><span class="lineCov">    1462240 :           SgScopeStatement* currentScope = declarationStatement-&gt;get_scope();</span></a>
<a name="8352"><span class="lineNum">    8352 </span>            : </a>
<a name="8353"><span class="lineNum">    8353 </span>            : #if 1</a>
<a name="8354"><span class="lineNum">    8354 </span>            :        // DQ (9/2/2020): Name qualification for the SgCtorInitializerList should use the scope of the associated class declaration.</a>
<a name="8355"><span class="lineNum">    8355 </span><span class="lineCov">    1462240 :           SgCtorInitializerList* ctorInitializerList = isSgCtorInitializerList(initializedNameParent);</span></a>
<a name="8356"><span class="lineNum">    8356 </span><span class="lineCov">    1462240 :           if (ctorInitializerList != NULL)</span></a>
<a name="8357"><span class="lineNum">    8357 </span>            :              {</a>
<a name="8358"><span class="lineNum">    8358 </span><span class="lineCov">       2670 :                SgMemberFunctionDeclaration* memberFunctionDeclaration = isSgMemberFunctionDeclaration(ctorInitializerList-&gt;get_parent());</span></a>
<a name="8359"><span class="lineNum">    8359 </span><span class="lineCov">       2670 :                ROSE_ASSERT(memberFunctionDeclaration != NULL);</span></a>
<a name="8360"><span class="lineNum">    8360 </span>            :             // currentStatement = memberFunctionDeclaration-&gt;get_firstNondefiningDeclaration();</a>
<a name="8361"><span class="lineNum">    8361 </span><span class="lineCov">       2670 :                currentScope = memberFunctionDeclaration-&gt;get_scope();</span></a>
<a name="8362"><span class="lineNum">    8362 </span>            : #if DEBUG_INITIALIZED_NAME</a>
<a name="8363"><span class="lineNum">    8363 </span>            :                printf (&quot;Case of SgInitializedName: from SgCtorInitializerList: currentScope = %p = %s name = %s \n&quot;,currentScope,</a>
<a name="8364"><span class="lineNum">    8364 </span>            :                     currentScope-&gt;class_name().c_str(),SageInterface::get_name(currentScope).c_str());</a>
<a name="8365"><span class="lineNum">    8365 </span>            : #endif</a>
<a name="8366"><span class="lineNum">    8366 </span>            : #if 0</a>
<a name="8367"><span class="lineNum">    8367 </span>            :                printf (&quot;Case of SgInitializedName: case of SgCtorInitializerList before if(currentStatement == NULL): currentStatement = %p = %s name = %s \n&quot;,currentStatement,</a>
<a name="8368"><span class="lineNum">    8368 </span>            :                     currentStatement-&gt;class_name().c_str(),SageInterface::get_name(currentStatement).c_str());</a>
<a name="8369"><span class="lineNum">    8369 </span>            : #endif</a>
<a name="8370"><span class="lineNum">    8370 </span>            :              }</a>
<a name="8371"><span class="lineNum">    8371 </span>            : #endif</a>
<a name="8372"><span class="lineNum">    8372 </span>            : </a>
<a name="8373"><span class="lineNum">    8373 </span>            : </a>
<a name="8374"><span class="lineNum">    8374 </span>            : #if DEBUG_INITIALIZED_NAME</a>
<a name="8375"><span class="lineNum">    8375 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Case SgInitializedName: currentScope = %p = %s \n&quot;,currentScope,currentScope-&gt;class_name().c_str());</a>
<a name="8376"><span class="lineNum">    8376 </span>            : #endif</a>
<a name="8377"><span class="lineNum">    8377 </span>            : </a>
<a name="8378"><span class="lineNum">    8378 </span>            : #if 1</a>
<a name="8379"><span class="lineNum">    8379 </span>            :        // DQ (4/12/2019): Now that we have unified the SgInitializedName support, we need to handle this case here instead of in the SgfunctionParameterList support.</a>
<a name="8380"><span class="lineNum">    8380 </span>            :        // DQ (8/29/2014): This is a result of a transformation in the tutorial (codeCoverage.C) that does not appear to be implemeting a transformation correctly.</a>
<a name="8381"><span class="lineNum">    8381 </span><span class="lineCov">    1462240 :           if (currentScope == NULL)</span></a>
<a name="8382"><span class="lineNum">    8382 </span>            :              {</a>
<a name="8383"><span class="lineNum">    8383 </span>            :             // DQ (4/12/2019): Need to setup a local copy of the functionParameterList (since this code has been moved).</a>
<a name="8384"><span class="lineNum">    8384 </span><span class="lineNoCov">          0 :                SgFunctionParameterList* functionParameterList = isSgFunctionParameterList(initializedName-&gt;get_parent());</span></a>
<a name="8385"><span class="lineNum">    8385 </span><span class="lineNoCov">          0 :                ASSERT_not_null(functionParameterList);</span></a>
<a name="8386"><span class="lineNum">    8386 </span>            : </a>
<a name="8387"><span class="lineNum">    8387 </span><span class="lineNoCov">          0 :                mfprintf(mlog [ WARN ] ) (&quot;Error: currentScope == NULL: functionParameterList = %p \n&quot;,functionParameterList);</span></a>
<a name="8388"><span class="lineNum">    8388 </span><span class="lineNoCov">          0 :                SgFunctionDeclaration* functionDeclaration = isSgFunctionDeclaration(functionParameterList-&gt;get_parent());</span></a>
<a name="8389"><span class="lineNum">    8389 </span><span class="lineNoCov">          0 :                ASSERT_not_null(functionDeclaration);</span></a>
<a name="8390"><span class="lineNum">    8390 </span><span class="lineNoCov">          0 :                mfprintf(mlog [ WARN ] ) (&quot;Error: currentScope == NULL: functionDeclaration = %p = %s name = %s \n&quot;,functionDeclaration,functionDeclaration-&gt;class_name().c_str(),functionDeclaration-&gt;get_name().str());</span></a>
<a name="8391"><span class="lineNum">    8391 </span><span class="lineNoCov">          0 :                ASSERT_not_null(functionDeclaration-&gt;get_file_info());</span></a>
<a name="8392"><span class="lineNum">    8392 </span><span class="lineNoCov">          0 :                functionDeclaration-&gt;get_file_info()-&gt;display(&quot;Error: currentScope == NULL: functionParameterList-&gt;get_parent(): debug&quot;);</span></a>
<a name="8393"><span class="lineNum">    8393 </span><span class="lineNoCov">          0 :                SgScopeStatement* temp_scope = SageInterface::getScope(functionDeclaration);</span></a>
<a name="8394"><span class="lineNum">    8394 </span><span class="lineNoCov">          0 :                ASSERT_not_null(temp_scope);</span></a>
<a name="8395"><span class="lineNum">    8395 </span>            : </a>
<a name="8396"><span class="lineNum">    8396 </span>            :             // DQ (8/29/2014): It appears that we can't ask the SgFunctionParameterList for it's scope, but we can find the SgFunctionDeclaration from the parent and ask it; so this should be fixed.</a>
<a name="8397"><span class="lineNum">    8397 </span><span class="lineNoCov">          0 :                currentScope = temp_scope;</span></a>
<a name="8398"><span class="lineNum">    8398 </span>            : </a>
<a name="8399"><span class="lineNum">    8399 </span><span class="lineNoCov">          0 :                mfprintf(mlog [ WARN ] ) (&quot;It appears that in the case of a transforamtion, we can't always ask the SgFunctionParameterList for it's scope, but we can find the SgFunctionDeclaration from the parent and ask it; so this should be fixed. \n&quot;);</span></a>
<a name="8400"><span class="lineNum">    8400 </span>            :              }</a>
<a name="8401"><span class="lineNum">    8401 </span>            : #endif</a>
<a name="8402"><span class="lineNum">    8402 </span>            : </a>
<a name="8403"><span class="lineNum">    8403 </span><span class="lineCov">    1462240 :           ASSERT_not_null(currentScope);</span></a>
<a name="8404"><span class="lineNum">    8404 </span>            : </a>
<a name="8405"><span class="lineNum">    8405 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || DEBUG_INITIALIZED_NAME</a>
<a name="8406"><span class="lineNum">    8406 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;currentScope = %p = %s \n&quot;,currentScope,currentScope-&gt;class_name().c_str());</a>
<a name="8407"><span class="lineNum">    8407 </span>            : #endif</a>
<a name="8408"><span class="lineNum">    8408 </span>            : #if 0</a>
<a name="8409"><span class="lineNum">    8409 </span>            :           SgDeclarationStatement* declarationForInitializedName = isSgDeclarationStatement(initializedName-&gt;get_parent());</a>
<a name="8410"><span class="lineNum">    8410 </span>            :           ASSERT_not_null(declarationForInitializedName);</a>
<a name="8411"><span class="lineNum">    8411 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="8412"><span class="lineNum">    8412 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;declarationForInitializedName = %p = %s \n&quot;,declarationForInitializedName,declarationForInitializedName-&gt;class_name().c_str());</a>
<a name="8413"><span class="lineNum">    8413 </span>            : #endif</a>
<a name="8414"><span class="lineNum">    8414 </span>            : #endif</a>
<a name="8415"><span class="lineNum">    8415 </span>            : </a>
<a name="8416"><span class="lineNum">    8416 </span>            :        // DQ (8/8/2020): Moved from the refactored code below.</a>
<a name="8417"><span class="lineNum">    8417 </span><span class="lineCov">    1462240 :           SgStatement* currentStatement = TransformationSupport::getStatement(initializedName);</span></a>
<a name="8418"><span class="lineNum">    8418 </span><span class="lineCov">    1462240 :           ASSERT_not_null(currentStatement);</span></a>
<a name="8419"><span class="lineNum">    8419 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || 0</a>
<a name="8420"><span class="lineNum">    8420 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;case of SgInitializedName: currentStatement = %p = %s \n&quot;,currentStatement,currentStatement-&gt;class_name().c_str());</a>
<a name="8421"><span class="lineNum">    8421 </span>            : #endif</a>
<a name="8422"><span class="lineNum">    8422 </span>            : </a>
<a name="8423"><span class="lineNum">    8423 </span>            :        // DQ (8/8/2020): Moved from the refactored code below.</a>
<a name="8424"><span class="lineNum">    8424 </span>            :        // DQ (4/27/2019): Refactored this code to be outside of the flase block below, so it can be used both there</a>
<a name="8425"><span class="lineNum">    8425 </span>            :        // and outside the false branch afterward.</a>
<a name="8426"><span class="lineNum">    8426 </span>            : </a>
<a name="8427"><span class="lineNum">    8427 </span>            :        // DQ (10/18/2020): Commented out to see where this is first used.</a>
<a name="8428"><span class="lineNum">    8428 </span>            :        // SgDeclarationStatement* declaration = getDeclarationAssociatedWithType(initializedName-&gt;get_type());</a>
<a name="8429"><span class="lineNum">    8429 </span>            : </a>
<a name="8430"><span class="lineNum">    8430 </span><span class="lineCov">    1462240 :           SgType* type = initializedName-&gt;get_type();</span></a>
<a name="8431"><span class="lineNum">    8431 </span><span class="lineCov">    1462240 :           ASSERT_not_null(type);</span></a>
<a name="8432"><span class="lineNum">    8432 </span>            : </a>
<a name="8433"><span class="lineNum">    8433 </span>            : #if 1</a>
<a name="8434"><span class="lineNum">    8434 </span>            :        // if for type handling.</a>
<a name="8435"><span class="lineNum">    8435 </span>            :        // Refactored this code.</a>
<a name="8436"><span class="lineNum">    8436 </span><span class="lineCov">    1462240 :           nameQualificationTypeSupport (type,currentScope,initializedName);</span></a>
<a name="8437"><span class="lineNum">    8437 </span>            : #else</a>
<a name="8438"><span class="lineNum">    8438 </span>            : </a>
<a name="8439"><span class="lineNum">    8439 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="8440"><span class="lineNum">    8440 </span>            : </a>
<a name="8441"><span class="lineNum">    8441 </span>            :        // else for type handling.</a>
<a name="8442"><span class="lineNum">    8442 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="8443"><span class="lineNum">    8443 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Case SgInitializedName: initializedName-&gt;get_type(): before stripType(): type = %p = %s \n&quot;,type,type-&gt;class_name().c_str());</a>
<a name="8444"><span class="lineNum">    8444 </span>            : #endif</a>
<a name="8445"><span class="lineNum">    8445 </span>            :        // DQ (4/15/2019): Reset the type so that we don't miss the SgPointerMemberType.</a>
<a name="8446"><span class="lineNum">    8446 </span>            :        // unsigned char bit_array = SgType::STRIP_MODIFIER_TYPE | SgType::STRIP_REFERENCE_TYPE | SgType::STRIP_RVALUE_REFERENCE_TYPE |</a>
<a name="8447"><span class="lineNum">    8447 </span>            :        //                           SgType::STRIP_POINTER_TYPE  | SgType::STRIP_POINTER_TYPE   | SgType::STRIP_ARRAY_TYPE;</a>
<a name="8448"><span class="lineNum">    8448 </span>            :           unsigned char bit_array = SgType::STRIP_MODIFIER_TYPE | SgType::STRIP_REFERENCE_TYPE | SgType::STRIP_RVALUE_REFERENCE_TYPE |</a>
<a name="8449"><span class="lineNum">    8449 </span>            :                                     SgType::STRIP_POINTER_TYPE  | SgType::STRIP_ARRAY_TYPE;</a>
<a name="8450"><span class="lineNum">    8450 </span>            :           type = type-&gt;stripType(bit_array);</a>
<a name="8451"><span class="lineNum">    8451 </span>            : </a>
<a name="8452"><span class="lineNum">    8452 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || DEBUG_INITIALIZED_NAME</a>
<a name="8453"><span class="lineNum">    8453 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Case SgInitializedName: initializedName-&gt;get_type(): after stripType(): type = %p = %s \n&quot;,type,type-&gt;class_name().c_str());</a>
<a name="8454"><span class="lineNum">    8454 </span>            : #endif</a>
<a name="8455"><span class="lineNum">    8455 </span>            : </a>
<a name="8456"><span class="lineNum">    8456 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="8457"><span class="lineNum">    8457 </span>            : </a>
<a name="8458"><span class="lineNum">    8458 </span>            : #if 0</a>
<a name="8459"><span class="lineNum">    8459 </span>            :        // DQ (4/17/2019): Need more general type support, required for more complex nesting of SgPointerMemberType types.</a>
<a name="8460"><span class="lineNum">    8460 </span>            : </a>
<a name="8461"><span class="lineNum">    8461 </span>            : #if 0</a>
<a name="8462"><span class="lineNum">    8462 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;######################################################## \n&quot;);</a>
<a name="8463"><span class="lineNum">    8463 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Case SgInitializedName: Checking for SgPointerMemberType \n&quot;);</a>
<a name="8464"><span class="lineNum">    8464 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;######################################################## \n&quot;);</a>
<a name="8465"><span class="lineNum">    8465 </span>            : #endif</a>
<a name="8466"><span class="lineNum">    8466 </span>            : </a>
<a name="8467"><span class="lineNum">    8467 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="8468"><span class="lineNum">    8468 </span>            : </a>
<a name="8469"><span class="lineNum">    8469 </span>            :           SgPointerMemberType* pointerMemberType = isSgPointerMemberType(type);</a>
<a name="8470"><span class="lineNum">    8470 </span>            :           if (pointerMemberType != NULL)</a>
<a name="8471"><span class="lineNum">    8471 </span>            :              {</a>
<a name="8472"><span class="lineNum">    8472 </span>            :             // DQ (4/9/2019): If this is a pointer to member type then we will need name qualification for the SgInitializedName and its type.</a>
<a name="8473"><span class="lineNum">    8473 </span>            :             // The name qualification for the base type will be attached a the name qualification for the type, and the name qualification</a>
<a name="8474"><span class="lineNum">    8474 </span>            :             // for the pointer to member class will be attached to the SgInitializedName.</a>
<a name="8475"><span class="lineNum">    8475 </span>            : #if 0</a>
<a name="8476"><span class="lineNum">    8476 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;############################################################################## \n&quot;);</a>
<a name="8477"><span class="lineNum">    8477 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Case SgInitializedName: Processing the SgInitializedName IR node name directly \n&quot;);</a>
<a name="8478"><span class="lineNum">    8478 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;############################################################################## \n&quot;);</a>
<a name="8479"><span class="lineNum">    8479 </span>            : #endif</a>
<a name="8480"><span class="lineNum">    8480 </span>            : </a>
<a name="8481"><span class="lineNum">    8481 </span>            :             // DQ (4/11/2019): This is the old function API, but did not handle the case where the SgClassDefinition was not available.</a>
<a name="8482"><span class="lineNum">    8482 </span>            :             // SgClassDefinition* classDefinition = pointerMemberType-&gt;get_class_of();</a>
<a name="8483"><span class="lineNum">    8483 </span>            :                SgClassDeclaration* classDeclaration = isSgClassDeclaration(pointerMemberType-&gt;get_class_declaration_of());</a>
<a name="8484"><span class="lineNum">    8484 </span>            : </a>
<a name="8485"><span class="lineNum">    8485 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="8486"><span class="lineNum">    8486 </span>            : </a>
<a name="8487"><span class="lineNum">    8487 </span>            :             // DQ (4/10/2019): The definition might not be available, but this means more that we should change the API to for</a>
<a name="8488"><span class="lineNum">    8488 </span>            :             // get_class_of() to return the SgClassDeclaration (and the firstNondefiing one if the defining declaration is not available).</a>
<a name="8489"><span class="lineNum">    8489 </span>            :             // ASSERT_not_null(classDefinition);</a>
<a name="8490"><span class="lineNum">    8490 </span>            :             // if (classDefinition != NULL)</a>
<a name="8491"><span class="lineNum">    8491 </span>            :                if (classDeclaration != NULL)</a>
<a name="8492"><span class="lineNum">    8492 </span>            :                   {</a>
<a name="8493"><span class="lineNum">    8493 </span>            :                  // SgClassDeclaration* classDeclaration = classDefinition-&gt;get_declaration();</a>
<a name="8494"><span class="lineNum">    8494 </span>            :                     ASSERT_not_null(classDeclaration);</a>
<a name="8495"><span class="lineNum">    8495 </span>            : </a>
<a name="8496"><span class="lineNum">    8496 </span>            :                     SgDeclarationStatement* declarationForInitializedName = classDeclaration;</a>
<a name="8497"><span class="lineNum">    8497 </span>            :                     ASSERT_not_null(declarationForInitializedName);</a>
<a name="8498"><span class="lineNum">    8498 </span>            : </a>
<a name="8499"><span class="lineNum">    8499 </span>            :                     SgDeclarationStatement* positionStatement = isSgDeclarationStatement(initializedName-&gt;get_parent());</a>
<a name="8500"><span class="lineNum">    8500 </span>            :                     ASSERT_not_null(positionStatement);</a>
<a name="8501"><span class="lineNum">    8501 </span>            : </a>
<a name="8502"><span class="lineNum">    8502 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="8503"><span class="lineNum">    8503 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Correcting associated declaration: declarationForInitializedName = %p = %s \n&quot;,declarationForInitializedName,declarationForInitializedName-&gt;class_name().c_str());</a>
<a name="8504"><span class="lineNum">    8504 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Correcting associated declaration: positionStatement = %p = %s \n&quot;,positionStatement,positionStatement-&gt;class_name().c_str());</a>
<a name="8505"><span class="lineNum">    8505 </span>            : #endif</a>
<a name="8506"><span class="lineNum">    8506 </span>            :                  // int amountOfNameQualificationRequiredForName = nameQualificationDepth(initializedName,currentScope,variableDeclaration);</a>
<a name="8507"><span class="lineNum">    8507 </span>            :                  // int amountOfNameQualificationRequiredForName = nameQualificationDepth(initializedName,currentScope,declarationForInitializedName);</a>
<a name="8508"><span class="lineNum">    8508 </span>            :                     int amountOfNameQualificationRequiredForName = nameQualificationDepth(declarationForInitializedName,currentScope,positionStatement);</a>
<a name="8509"><span class="lineNum">    8509 </span>            : </a>
<a name="8510"><span class="lineNum">    8510 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="8511"><span class="lineNum">    8511 </span>            : </a>
<a name="8512"><span class="lineNum">    8512 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="8513"><span class="lineNum">    8513 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;SgInitializedName: SgPointerMemberType: name: amountOfNameQualificationRequiredForName = %d \n&quot;,amountOfNameQualificationRequiredForName);</a>
<a name="8514"><span class="lineNum">    8514 </span>            : #endif</a>
<a name="8515"><span class="lineNum">    8515 </span>            :                  // bool skipGlobalNameQualification = true;</a>
<a name="8516"><span class="lineNum">    8516 </span>            :                     bool skipGlobalNameQualification = false;</a>
<a name="8517"><span class="lineNum">    8517 </span>            :                  // setNameQualificationOnName(initializedName,declaration,amountOfNameQualificationRequiredForName,skipGlobalNameQualification);</a>
<a name="8518"><span class="lineNum">    8518 </span>            :                  // setNameQualificationOnName(initializedName,positionStatement,amountOfNameQualificationRequiredForName,skipGlobalNameQualification);</a>
<a name="8519"><span class="lineNum">    8519 </span>            :                     setNameQualificationOnName(initializedName,declarationForInitializedName,amountOfNameQualificationRequiredForName,skipGlobalNameQualification);</a>
<a name="8520"><span class="lineNum">    8520 </span>            :                   }</a>
<a name="8521"><span class="lineNum">    8521 </span>            :                  else</a>
<a name="8522"><span class="lineNum">    8522 </span>            :                   {</a>
<a name="8523"><span class="lineNum">    8523 </span>            :                  // DQ (4/11/2019): If this is not a SgClassDeclaration thenit can be a nonreal declaration which is not handled yet.</a>
<a name="8524"><span class="lineNum">    8524 </span>            :                   }</a>
<a name="8525"><span class="lineNum">    8525 </span>            :              }</a>
<a name="8526"><span class="lineNum">    8526 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="8527"><span class="lineNum">    8527 </span>            : </a>
<a name="8528"><span class="lineNum">    8528 </span>            : #else</a>
<a name="8529"><span class="lineNum">    8529 </span>            : </a>
<a name="8530"><span class="lineNum">    8530 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="8531"><span class="lineNum">    8531 </span>            : </a>
<a name="8532"><span class="lineNum">    8532 </span>            : #if 0</a>
<a name="8533"><span class="lineNum">    8533 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Commented out SgPointerMemberType code to compute the name qualification on the name (calling setNameQualificationOnName()) \n&quot;);</a>
<a name="8534"><span class="lineNum">    8534 </span>            : #endif</a>
<a name="8535"><span class="lineNum">    8535 </span>            : </a>
<a name="8536"><span class="lineNum">    8536 </span>            : #endif</a>
<a name="8537"><span class="lineNum">    8537 </span>            : </a>
<a name="8538"><span class="lineNum">    8538 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="8539"><span class="lineNum">    8539 </span>            : </a>
<a name="8540"><span class="lineNum">    8540 </span>            : #if 0</a>
<a name="8541"><span class="lineNum">    8541 </span>            :        // DQ (3/31/2019): debugging support.</a>
<a name="8542"><span class="lineNum">    8542 </span>            :           if (debugging == true)</a>
<a name="8543"><span class="lineNum">    8543 </span>            :              {</a>
<a name="8544"><span class="lineNum">    8544 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="8545"><span class="lineNum">    8545 </span>            :                ROSE_ABORT();</a>
<a name="8546"><span class="lineNum">    8546 </span>            :              }</a>
<a name="8547"><span class="lineNum">    8547 </span>            : #endif</a>
<a name="8548"><span class="lineNum">    8548 </span>            :        // DQ (8/8/2020): This was moved to before the refactored code.</a>
<a name="8549"><span class="lineNum">    8549 </span>            :        // SgStatement* currentStatement = TransformationSupport::getStatement(initializedName);</a>
<a name="8550"><span class="lineNum">    8550 </span>            :           ASSERT_not_null(currentStatement);</a>
<a name="8551"><span class="lineNum">    8551 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || 0</a>
<a name="8552"><span class="lineNum">    8552 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;case of SgInitializedName: currentStatement = %p = %s \n&quot;,currentStatement,currentStatement-&gt;class_name().c_str());</a>
<a name="8553"><span class="lineNum">    8553 </span>            : #endif</a>
<a name="8554"><span class="lineNum">    8554 </span>            : </a>
<a name="8555"><span class="lineNum">    8555 </span>            : #if DEBUG_INITIALIZED_NAME</a>
<a name="8556"><span class="lineNum">    8556 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;################################################################## \n&quot;);</a>
<a name="8557"><span class="lineNum">    8557 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Case SgInitializedName: Processing the SgInitializedName IR's type \n&quot;);</a>
<a name="8558"><span class="lineNum">    8558 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;################################################################## \n&quot;);</a>
<a name="8559"><span class="lineNum">    8559 </span>            : #endif</a>
<a name="8560"><span class="lineNum">    8560 </span>            : </a>
<a name="8561"><span class="lineNum">    8561 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="8562"><span class="lineNum">    8562 </span>            : </a>
<a name="8563"><span class="lineNum">    8563 </span>            :        // DQ (4/19/2019): It might be that we should call this after the traveral over each type instead of before we traverse the type.</a>
<a name="8564"><span class="lineNum">    8564 </span>            :        // traverseType(initializedName-&gt;get_type(),initializedName,currentScope,currentStatement);</a>
<a name="8565"><span class="lineNum">    8565 </span>            : </a>
<a name="8566"><span class="lineNum">    8566 </span>            :        // DQ (4/19/2019): Added current statement to paremter list for recursive call.</a>
<a name="8567"><span class="lineNum">    8567 </span>            :        // DQ (4/18/2019): I think we need to traverse the type doing a proper type travesal, since it can consist of</a>
<a name="8568"><span class="lineNum">    8568 </span>            :        // long chains of types that each must be name qualified. The example of a chain of SgPointerToMemberTypes is</a>
<a name="8569"><span class="lineNum">    8569 </span>            :        // the best example of this.</a>
<a name="8570"><span class="lineNum">    8570 </span>            :           ASSERT_not_null(currentScope);</a>
<a name="8571"><span class="lineNum">    8571 </span>            : </a>
<a name="8572"><span class="lineNum">    8572 </span>            :        // DQ (8/8/2020): This was moved to before the refactored code.</a>
<a name="8573"><span class="lineNum">    8573 </span>            :        // DQ (4/27/2019): Refactored this code to be outside of the flase block below, so it can be used both there</a>
<a name="8574"><span class="lineNum">    8574 </span>            :        // and outside the false branch afterward.</a>
<a name="8575"><span class="lineNum">    8575 </span>            :        // SgDeclarationStatement* declaration = getDeclarationAssociatedWithType(initializedName-&gt;get_type());</a>
<a name="8576"><span class="lineNum">    8576 </span>            : </a>
<a name="8577"><span class="lineNum">    8577 </span>            :        // DQ (4/22/2019): If we have resolved the type (after stripType() function) to a SgPointerMemberType, then</a>
<a name="8578"><span class="lineNum">    8578 </span>            :        // we need to traverse the type using a type traversal.  Else we can handle it normally.</a>
<a name="8579"><span class="lineNum">    8579 </span>            :        // generateNestedTraversalWithExplicitScope(type,currentScope,currentStatement,initializedName);</a>
<a name="8580"><span class="lineNum">    8580 </span>            :        // traverseType(initializedName-&gt;get_type(),initializedName,currentScope,currentStatement);</a>
<a name="8581"><span class="lineNum">    8581 </span>            :           SgPointerMemberType* pointerMemberType = isSgPointerMemberType(type);</a>
<a name="8582"><span class="lineNum">    8582 </span>            :           if (pointerMemberType != NULL)</a>
<a name="8583"><span class="lineNum">    8583 </span>            :              {</a>
<a name="8584"><span class="lineNum">    8584 </span>            : #if DEBUG_INITIALIZED_NAME</a>
<a name="8585"><span class="lineNum">    8585 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;########################################################################## \n&quot;);</a>
<a name="8586"><span class="lineNum">    8586 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Case SgInitializedName: Calling generateNestedTraversalWithExplicitScope() \n&quot;);</a>
<a name="8587"><span class="lineNum">    8587 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;########################################################################## \n&quot;);</a>
<a name="8588"><span class="lineNum">    8588 </span>            : #endif</a>
<a name="8589"><span class="lineNum">    8589 </span>            :                generateNestedTraversalWithExplicitScope(type,currentScope,currentStatement,initializedName);</a>
<a name="8590"><span class="lineNum">    8590 </span>            : </a>
<a name="8591"><span class="lineNum">    8591 </span>            :             // DQ (4/19/2019): It might be that we should call this after the traveral over each type instead of before we traverse the type.</a>
<a name="8592"><span class="lineNum">    8592 </span>            :             // This way we save the correctly computed string for each type after the different parts of name qualificaiton are in place.</a>
<a name="8593"><span class="lineNum">    8593 </span>            :                traverseType(initializedName-&gt;get_type(),initializedName,currentScope,currentStatement);</a>
<a name="8594"><span class="lineNum">    8594 </span>            : </a>
<a name="8595"><span class="lineNum">    8595 </span>            : #if DEBUG_INITIALIZED_NAME</a>
<a name="8596"><span class="lineNum">    8596 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;#################################################################################################### \n&quot;);</a>
<a name="8597"><span class="lineNum">    8597 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Case SgInitializedName: DONE: Processing the recursive evaluation of the SgInitializedName IR's type \n&quot;);</a>
<a name="8598"><span class="lineNum">    8598 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;#################################################################################################### \n&quot;);</a>
<a name="8599"><span class="lineNum">    8599 </span>            : #endif</a>
<a name="8600"><span class="lineNum">    8600 </span>            :              }</a>
<a name="8601"><span class="lineNum">    8601 </span>            :             else</a>
<a name="8602"><span class="lineNum">    8602 </span>            :              {</a>
<a name="8603"><span class="lineNum">    8603 </span>            : #if DEBUG_INITIALIZED_NAME</a>
<a name="8604"><span class="lineNum">    8604 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Normal processing of type (no recursive call to evaluate the type) \n&quot;);</a>
<a name="8605"><span class="lineNum">    8605 </span>            : #endif</a>
<a name="8606"><span class="lineNum">    8606 </span>            :             // The code for the normal processing of the type is below.</a>
<a name="8607"><span class="lineNum">    8607 </span>            : </a>
<a name="8608"><span class="lineNum">    8608 </span>            : #if DEBUG_INITIALIZED_NAME</a>
<a name="8609"><span class="lineNum">    8609 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;######################################################################### \n&quot;);</a>
<a name="8610"><span class="lineNum">    8610 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Case SgInitializedName: Normal Processing the SgInitializedName IR's type \n&quot;);</a>
<a name="8611"><span class="lineNum">    8611 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;######################################################################### \n&quot;);</a>
<a name="8612"><span class="lineNum">    8612 </span>            : #endif</a>
<a name="8613"><span class="lineNum">    8613 </span>            : </a>
<a name="8614"><span class="lineNum">    8614 </span>            : #if 0</a>
<a name="8615"><span class="lineNum">    8615 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="8616"><span class="lineNum">    8616 </span>            :                ROSE_ABORT();</a>
<a name="8617"><span class="lineNum">    8617 </span>            : #endif</a>
<a name="8618"><span class="lineNum">    8618 </span>            : </a>
<a name="8619"><span class="lineNum">    8619 </span>            : #if 0</a>
<a name="8620"><span class="lineNum">    8620 </span>            :             // DQ (4/27/2019): I really want to put this &quot;}&quot; at the end of where the initializedName's type is processed.</a>
<a name="8621"><span class="lineNum">    8621 </span>            :             // }</a>
<a name="8622"><span class="lineNum">    8622 </span>            : #endif</a>
<a name="8623"><span class="lineNum">    8623 </span>            : </a>
<a name="8624"><span class="lineNum">    8624 </span>            : #if 0</a>
<a name="8625"><span class="lineNum">    8625 </span>            :             // DQ (3/31/2019): debugging support.</a>
<a name="8626"><span class="lineNum">    8626 </span>            :                if (debugging == true)</a>
<a name="8627"><span class="lineNum">    8627 </span>            :                   {</a>
<a name="8628"><span class="lineNum">    8628 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="8629"><span class="lineNum">    8629 </span>            :                     ROSE_ABORT();</a>
<a name="8630"><span class="lineNum">    8630 </span>            :                   }</a>
<a name="8631"><span class="lineNum">    8631 </span>            : #endif</a>
<a name="8632"><span class="lineNum">    8632 </span>            : </a>
<a name="8633"><span class="lineNum">    8633 </span>            :             // DQ (4/27/2019): refactoring: As a result of the block processing of the type being extended, and this variable</a>
<a name="8634"><span class="lineNum">    8634 </span>            :             // being used outside of that block, we need to move this variable declaration to be outside of this block at the</a>
<a name="8635"><span class="lineNum">    8635 </span>            :             // top of this block.</a>
<a name="8636"><span class="lineNum">    8636 </span>            :             // We want to handle types from every where a SgInitializedName might be used.</a>
<a name="8637"><span class="lineNum">    8637 </span>            :             // SgDeclarationStatement* declaration = getDeclarationAssociatedWithType(initializedName-&gt;get_type());</a>
<a name="8638"><span class="lineNum">    8638 </span>            : </a>
<a name="8639"><span class="lineNum">    8639 </span>            :             // DQ (4/22/2019): If there is a SgPointerMemberType, then don't processs as a normal type.</a>
<a name="8640"><span class="lineNum">    8640 </span>            :                if (pointerMemberType != NULL)</a>
<a name="8641"><span class="lineNum">    8641 </span>            :                   {</a>
<a name="8642"><span class="lineNum">    8642 </span>            :                     if (declaration != NULL)</a>
<a name="8643"><span class="lineNum">    8643 </span>            :                        {</a>
<a name="8644"><span class="lineNum">    8644 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;None null declaration where detected valid SgPointerMemberType: declaration = %p = %s \n&quot;,declaration,declaration-&gt;class_name().c_str());</a>
<a name="8645"><span class="lineNum">    8645 </span>            :                        }</a>
<a name="8646"><span class="lineNum">    8646 </span>            :                     ROSE_ASSERT(declaration == NULL);</a>
<a name="8647"><span class="lineNum">    8647 </span>            :                   }</a>
<a name="8648"><span class="lineNum">    8648 </span>            : </a>
<a name="8649"><span class="lineNum">    8649 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="8650"><span class="lineNum">    8650 </span>            : </a>
<a name="8651"><span class="lineNum">    8651 </span>            : #if 0</a>
<a name="8652"><span class="lineNum">    8652 </span>            :             // SgPointerMemberType* pointerMemberType = isSgPointerMemberType(initializedName-&gt;get_type());</a>
<a name="8653"><span class="lineNum">    8653 </span>            :                if (pointerMemberType != NULL)</a>
<a name="8654"><span class="lineNum">    8654 </span>            :                   {</a>
<a name="8655"><span class="lineNum">    8655 </span>            :                     SgType* baseType = pointerMemberType-&gt;get_base_type();</a>
<a name="8656"><span class="lineNum">    8656 </span>            :                     ASSERT_not_null(baseType);</a>
<a name="8657"><span class="lineNum">    8657 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="8658"><span class="lineNum">    8658 </span>            :                     SgMemberFunctionType* memberFunctionType = isSgMemberFunctionType(baseType);</a>
<a name="8659"><span class="lineNum">    8659 </span>            :                     if (memberFunctionType != NULL)</a>
<a name="8660"><span class="lineNum">    8660 </span>            :                        {</a>
<a name="8661"><span class="lineNum">    8661 </span>            :                          SgType* returnType = memberFunctionType-&gt;get_return_type();</a>
<a name="8662"><span class="lineNum">    8662 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="8663"><span class="lineNum">    8663 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;Case of SgPointerMemberType: Reset associated declaration: returnType = %p = %s \n&quot;,returnType,returnType-&gt;class_name().c_str());</a>
<a name="8664"><span class="lineNum">    8664 </span>            : #endif</a>
<a name="8665"><span class="lineNum">    8665 </span>            :                          ASSERT_not_null(returnType);</a>
<a name="8666"><span class="lineNum">    8666 </span>            :                       // declaration = getDeclarationAssociatedWithType(memberFunctionType-&gt;get_return_type());</a>
<a name="8667"><span class="lineNum">    8667 </span>            :                          declaration = getDeclarationAssociatedWithType(returnType);</a>
<a name="8668"><span class="lineNum">    8668 </span>            :                        }</a>
<a name="8669"><span class="lineNum">    8669 </span>            :                       else</a>
<a name="8670"><span class="lineNum">    8670 </span>            :                        {</a>
<a name="8671"><span class="lineNum">    8671 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="8672"><span class="lineNum">    8672 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;Case of SgPointerMemberType: Reset associated declaration: baseType = %p = %s \n&quot;,baseType,baseType-&gt;class_name().c_str());</a>
<a name="8673"><span class="lineNum">    8673 </span>            : #endif</a>
<a name="8674"><span class="lineNum">    8674 </span>            :                          declaration = getDeclarationAssociatedWithType(baseType);</a>
<a name="8675"><span class="lineNum">    8675 </span>            :                        }</a>
<a name="8676"><span class="lineNum">    8676 </span>            :                   }</a>
<a name="8677"><span class="lineNum">    8677 </span>            : #else</a>
<a name="8678"><span class="lineNum">    8678 </span>            : </a>
<a name="8679"><span class="lineNum">    8679 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="8680"><span class="lineNum">    8680 </span>            : </a>
<a name="8681"><span class="lineNum">    8681 </span>            : #if 0</a>
<a name="8682"><span class="lineNum">    8682 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Commented out SgPointerMemberType code to compute the associated declaration \n&quot;);</a>
<a name="8683"><span class="lineNum">    8683 </span>            : #endif</a>
<a name="8684"><span class="lineNum">    8684 </span>            : </a>
<a name="8685"><span class="lineNum">    8685 </span>            : #endif</a>
<a name="8686"><span class="lineNum">    8686 </span>            : </a>
<a name="8687"><span class="lineNum">    8687 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="8688"><span class="lineNum">    8688 </span>            : </a>
<a name="8689"><span class="lineNum">    8689 </span>            : #if 1</a>
<a name="8690"><span class="lineNum">    8690 </span>            :             // DQ (4/14/2019): Add support for declType.</a>
<a name="8691"><span class="lineNum">    8691 </span>            : </a>
<a name="8692"><span class="lineNum">    8692 </span>            :             // DQ (4/14/2019): An alternative might be to support this in the getDeclarationAssociatedWithType() function.</a>
<a name="8693"><span class="lineNum">    8693 </span>            : </a>
<a name="8694"><span class="lineNum">    8694 </span>            :                SgDeclType* declType = isSgDeclType(type);</a>
<a name="8695"><span class="lineNum">    8695 </span>            :                if (declType != NULL)</a>
<a name="8696"><span class="lineNum">    8696 </span>            :                   {</a>
<a name="8697"><span class="lineNum">    8697 </span>            :                  // Not clear if we need to worry about when the base type of the SgPointerMemberType is a SgDeclType.</a>
<a name="8698"><span class="lineNum">    8698 </span>            : #if 0</a>
<a name="8699"><span class="lineNum">    8699 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;################################################################################## \n&quot;);</a>
<a name="8700"><span class="lineNum">    8700 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Case SgInitializedName: Processing the SgInitializedName decltype IR node directly \n&quot;);</a>
<a name="8701"><span class="lineNum">    8701 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;################################################################################## \n&quot;);</a>
<a name="8702"><span class="lineNum">    8702 </span>            : #endif</a>
<a name="8703"><span class="lineNum">    8703 </span>            : </a>
<a name="8704"><span class="lineNum">    8704 </span>            :                  // We need to handle any possible name qualification of a type or SgVarRefExp used as decltype argument.</a>
<a name="8705"><span class="lineNum">    8705 </span>            :                     SgExpression* baseExpression = declType-&gt;get_base_expression();</a>
<a name="8706"><span class="lineNum">    8706 </span>            :                     SgType*       baseType       = declType-&gt;get_base_type();</a>
<a name="8707"><span class="lineNum">    8707 </span>            :                     if (baseExpression != NULL)</a>
<a name="8708"><span class="lineNum">    8708 </span>            :                        {</a>
<a name="8709"><span class="lineNum">    8709 </span>            :                       // Need name qualification for expression used in decltype().</a>
<a name="8710"><span class="lineNum">    8710 </span>            : #if 0</a>
<a name="8711"><span class="lineNum">    8711 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;Make a recursive call from this context (processing decltype taking SgExpression) \n&quot;);</a>
<a name="8712"><span class="lineNum">    8712 </span>            : #endif</a>
<a name="8713"><span class="lineNum">    8713 </span>            :                          SgStatement* currentStatement = TransformationSupport::getStatement(n);</a>
<a name="8714"><span class="lineNum">    8714 </span>            : #if 0</a>
<a name="8715"><span class="lineNum">    8715 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;SgInitializedName: decltype: currentStatement = %p = %s \n&quot;,currentStatement,currentStatement != NULL ? currentStatement-&gt;class_name().c_str() : &quot;null&quot;);</a>
<a name="8716"><span class="lineNum">    8716 </span>            : #endif</a>
<a name="8717"><span class="lineNum">    8717 </span>            : #if 0</a>
<a name="8718"><span class="lineNum">    8718 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! (before recursive call) \n&quot;);</a>
<a name="8719"><span class="lineNum">    8719 </span>            :                          ROSE_ABORT();</a>
<a name="8720"><span class="lineNum">    8720 </span>            : #endif</a>
<a name="8721"><span class="lineNum">    8721 </span>            :                       // DQ (9/14/2015): Added debugging code.</a>
<a name="8722"><span class="lineNum">    8722 </span>            :                       // DQ (9/14/2015): This can be an expression in a type, in which case we don't have an associated scope.</a>
<a name="8723"><span class="lineNum">    8723 </span>            :                          if (currentStatement == NULL)</a>
<a name="8724"><span class="lineNum">    8724 </span>            :                             {</a>
<a name="8725"><span class="lineNum">    8725 </span>            :                            // This can be an expression in a type, in which case we don't have an associated scope.</a>
<a name="8726"><span class="lineNum">    8726 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;Note: This can be an expression in a type, in which case we don't have an associated scope: baseExpression = %p = %s \n&quot;,</a>
<a name="8727"><span class="lineNum">    8727 </span>            :                                       baseExpression,baseExpression-&gt;class_name().c_str());</a>
<a name="8728"><span class="lineNum">    8728 </span>            :                             }</a>
<a name="8729"><span class="lineNum">    8729 </span>            :                            else</a>
<a name="8730"><span class="lineNum">    8730 </span>            :                             {</a>
<a name="8731"><span class="lineNum">    8731 </span>            :                               ASSERT_not_null(currentStatement);</a>
<a name="8732"><span class="lineNum">    8732 </span>            :                               SgScopeStatement* currentScope = currentStatement-&gt;get_scope();</a>
<a name="8733"><span class="lineNum">    8733 </span>            :                               ASSERT_not_null(currentScope);</a>
<a name="8734"><span class="lineNum">    8734 </span>            : #if 0</a>
<a name="8735"><span class="lineNum">    8735 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;SgInitializedName: currentScope = %p = %s \n&quot;,currentScope,currentScope-&gt;class_name().c_str());</a>
<a name="8736"><span class="lineNum">    8736 </span>            : #endif</a>
<a name="8737"><span class="lineNum">    8737 </span>            :                               generateNestedTraversalWithExplicitScope(baseExpression,currentScope);</a>
<a name="8738"><span class="lineNum">    8738 </span>            :                             }</a>
<a name="8739"><span class="lineNum">    8739 </span>            : #if 0</a>
<a name="8740"><span class="lineNum">    8740 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! (after recursive call) \n&quot;);</a>
<a name="8741"><span class="lineNum">    8741 </span>            :                          ROSE_ABORT();</a>
<a name="8742"><span class="lineNum">    8742 </span>            : #endif</a>
<a name="8743"><span class="lineNum">    8743 </span>            :                        }</a>
<a name="8744"><span class="lineNum">    8744 </span>            :                       else</a>
<a name="8745"><span class="lineNum">    8745 </span>            :                        {</a>
<a name="8746"><span class="lineNum">    8746 </span>            :                       // Need name qualification for type used in decltype().  Not clear what I good example is of this!</a>
<a name="8747"><span class="lineNum">    8747 </span>            :                          ASSERT_not_null(baseType);</a>
<a name="8748"><span class="lineNum">    8748 </span>            : #if 0</a>
<a name="8749"><span class="lineNum">    8749 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;REPORT ME: Unknow case: SgInitializedName: decltype: calling getDeclarationAssociatedWithType(): baseType = %p = %s \n&quot;,baseType,baseType-&gt;class_name().c_str());</a>
<a name="8750"><span class="lineNum">    8750 </span>            : #endif</a>
<a name="8751"><span class="lineNum">    8751 </span>            :                          declaration = getDeclarationAssociatedWithType(baseType);</a>
<a name="8752"><span class="lineNum">    8752 </span>            : #if 0</a>
<a name="8753"><span class="lineNum">    8753 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="8754"><span class="lineNum">    8754 </span>            :                          ROSE_ABORT();</a>
<a name="8755"><span class="lineNum">    8755 </span>            : #endif</a>
<a name="8756"><span class="lineNum">    8756 </span>            :                        }</a>
<a name="8757"><span class="lineNum">    8757 </span>            :                   }</a>
<a name="8758"><span class="lineNum">    8758 </span>            : #else</a>
<a name="8759"><span class="lineNum">    8759 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Commented out code specific to support of SgDeclType \n&quot;);</a>
<a name="8760"><span class="lineNum">    8760 </span>            : #endif</a>
<a name="8761"><span class="lineNum">    8761 </span>            : </a>
<a name="8762"><span class="lineNum">    8762 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="8763"><span class="lineNum">    8763 </span>            : </a>
<a name="8764"><span class="lineNum">    8764 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="8765"><span class="lineNum">    8765 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Case of SgInitializedName: getDeclarationAssociatedWithType(): type = %p = %s declaration = %p \n&quot;,initializedName-&gt;get_type(),initializedName-&gt;get_type()-&gt;class_name().c_str(),declaration);</a>
<a name="8766"><span class="lineNum">    8766 </span>            : #endif</a>
<a name="8767"><span class="lineNum">    8767 </span>            : </a>
<a name="8768"><span class="lineNum">    8768 </span>            :             // DQ (4/22/2019): The detect of a SgPointerMemberType will force a type traversal, which means</a>
<a name="8769"><span class="lineNum">    8769 </span>            :             // we don't process the type as a normal type.  Even if it has a valid declaration.</a>
<a name="8770"><span class="lineNum">    8770 </span>            :             // Note: &quot;Normal Type&quot; in the name below means not having pointer to member types and being</a>
<a name="8771"><span class="lineNum">    8771 </span>            :             // a type derived from a declaration.</a>
<a name="8772"><span class="lineNum">    8772 </span>            :                bool processAsNormalTypeThatMightRequireNameQualification = ((pointerMemberType == NULL) &amp;&amp; (declaration != NULL));</a>
<a name="8773"><span class="lineNum">    8773 </span>            : </a>
<a name="8774"><span class="lineNum">    8774 </span>            : #if 0</a>
<a name="8775"><span class="lineNum">    8775 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Need to dig deeper past modifiers, etc. to find possible array types \n&quot;);</a>
<a name="8776"><span class="lineNum">    8776 </span>            : </a>
<a name="8777"><span class="lineNum">    8777 </span>            :             // DQ (4/27/2019): I don't think we want to force this through the true branch below.</a>
<a name="8778"><span class="lineNum">    8778 </span>            :                SgArrayType* arrayType = isSgArrayType(initializedName-&gt;get_type());</a>
<a name="8779"><span class="lineNum">    8779 </span>            :                if (arrayType != NULL)</a>
<a name="8780"><span class="lineNum">    8780 </span>            :                   {</a>
<a name="8781"><span class="lineNum">    8781 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Process the SgArrayType to find name qualification (for the index more than for the type) \n&quot;);</a>
<a name="8782"><span class="lineNum">    8782 </span>            : </a>
<a name="8783"><span class="lineNum">    8783 </span>            :                     processAsNormalTypeThatMightRequireNameQualification = true;</a>
<a name="8784"><span class="lineNum">    8784 </span>            :                   }</a>
<a name="8785"><span class="lineNum">    8785 </span>            : #endif</a>
<a name="8786"><span class="lineNum">    8786 </span>            : </a>
<a name="8787"><span class="lineNum">    8787 </span>            : #if DEBUG_INITIALIZED_NAME || 0</a>
<a name="8788"><span class="lineNum">    8788 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;processAsNormalTypeThatMightRequireNameQualification = %s \n&quot;,processAsNormalTypeThatMightRequireNameQualification ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="8789"><span class="lineNum">    8789 </span>            : #endif</a>
<a name="8790"><span class="lineNum">    8790 </span>            :             // if (declaration != NULL)</a>
<a name="8791"><span class="lineNum">    8791 </span>            :                if (processAsNormalTypeThatMightRequireNameQualification == true)</a>
<a name="8792"><span class="lineNum">    8792 </span>            :                   {</a>
<a name="8793"><span class="lineNum">    8793 </span>            :                     SgStatement* currentStatement = TransformationSupport::getStatement(initializedName);</a>
<a name="8794"><span class="lineNum">    8794 </span>            :                     ASSERT_not_null(currentStatement);</a>
<a name="8795"><span class="lineNum">    8795 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || DEBUG_INITIALIZED_NAME</a>
<a name="8796"><span class="lineNum">    8796 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;case of SgInitializedName: currentStatement = %p = %s \n&quot;,currentStatement,currentStatement-&gt;class_name().c_str());</a>
<a name="8797"><span class="lineNum">    8797 </span>            : #endif</a>
<a name="8798"><span class="lineNum">    8798 </span>            :                     SgScopeStatement* currentScope = currentStatement-&gt;get_scope();</a>
<a name="8799"><span class="lineNum">    8799 </span>            :                     ASSERT_not_null(currentScope);</a>
<a name="8800"><span class="lineNum">    8800 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || DEBUG_INITIALIZED_NAME</a>
<a name="8801"><span class="lineNum">    8801 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;case of SgInitializedName: currentScope = %p = %s \n&quot;,currentScope,currentScope-&gt;class_name().c_str());</a>
<a name="8802"><span class="lineNum">    8802 </span>            : #endif</a>
<a name="8803"><span class="lineNum">    8803 </span>            :                  // DQ (2/21/2019): The constructor initializers need to start their name qualification from the class declaration.</a>
<a name="8804"><span class="lineNum">    8804 </span>            :                  // bool debugging = false;</a>
<a name="8805"><span class="lineNum">    8805 </span>            :                     SgCtorInitializerList* ctorInitializerList = isSgCtorInitializerList(initializedName-&gt;get_parent());</a>
<a name="8806"><span class="lineNum">    8806 </span>            :                     if (ctorInitializerList != NULL)</a>
<a name="8807"><span class="lineNum">    8807 </span>            :                        {</a>
<a name="8808"><span class="lineNum">    8808 </span>            :                          SgClassDefinition* classDefinition = isSgClassDefinition(initializedName-&gt;get_scope());</a>
<a name="8809"><span class="lineNum">    8809 </span>            : #if 0</a>
<a name="8810"><span class="lineNum">    8810 </span>            :                       // DQ (2/21/2019): This is either a SgDeclarationScope or a SgClassDefinition.</a>
<a name="8811"><span class="lineNum">    8811 </span>            :                          if (classDefinition == NULL)</a>
<a name="8812"><span class="lineNum">    8812 </span>            :                             {</a>
<a name="8813"><span class="lineNum">    8813 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;case SgInitializedName: initializedName-&gt;get_scope(): classDefinition == NULL: initializedName-&gt;get_scope() = %p = %s \n&quot;,</a>
<a name="8814"><span class="lineNum">    8814 </span>            :                                    initializedName-&gt;get_scope(),initializedName-&gt;get_scope()-&gt;class_name().c_str());</a>
<a name="8815"><span class="lineNum">    8815 </span>            :                             }</a>
<a name="8816"><span class="lineNum">    8816 </span>            :                       // ASSERT_not_null(classDefinition);</a>
<a name="8817"><span class="lineNum">    8817 </span>            : #endif</a>
<a name="8818"><span class="lineNum">    8818 </span>            :                          if (classDefinition != NULL)</a>
<a name="8819"><span class="lineNum">    8819 </span>            :                             {</a>
<a name="8820"><span class="lineNum">    8820 </span>            :                               SgClassDeclaration* classDeclaration = classDefinition-&gt;get_declaration();</a>
<a name="8821"><span class="lineNum">    8821 </span>            :                               ASSERT_not_null(classDeclaration);</a>
<a name="8822"><span class="lineNum">    8822 </span>            : </a>
<a name="8823"><span class="lineNum">    8823 </span>            :                               currentScope = classDeclaration-&gt;get_scope();</a>
<a name="8824"><span class="lineNum">    8824 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="8825"><span class="lineNum">    8825 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;Found case of SgInitializedName in constructor preinitialization list: currentScope = %p = %s \n&quot;,</a>
<a name="8826"><span class="lineNum">    8826 </span>            :                                    currentScope,currentScope-&gt;class_name().c_str());</a>
<a name="8827"><span class="lineNum">    8827 </span>            : #endif</a>
<a name="8828"><span class="lineNum">    8828 </span>            :                             }</a>
<a name="8829"><span class="lineNum">    8829 </span>            :                       // debugging = true;</a>
<a name="8830"><span class="lineNum">    8830 </span>            :                        }</a>
<a name="8831"><span class="lineNum">    8831 </span>            : </a>
<a name="8832"><span class="lineNum">    8832 </span>            :                  // int amountOfNameQualificationRequiredForType = nameQualificationDepthForType(initializedName,currentScope,currentStatement);</a>
<a name="8833"><span class="lineNum">    8833 </span>            :                  // int amountOfNameQualificationRequiredForType = nameQualificationDepthForType(initializedName,currentStatement);</a>
<a name="8834"><span class="lineNum">    8834 </span>            :                     int amountOfNameQualificationRequiredForType = nameQualificationDepthForType(initializedName,currentScope,currentStatement);</a>
<a name="8835"><span class="lineNum">    8835 </span>            : </a>
<a name="8836"><span class="lineNum">    8836 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || DEBUG_INITIALIZED_NAME</a>
<a name="8837"><span class="lineNum">    8837 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;SgInitializedName's (%s) type: amountOfNameQualificationRequiredForType = %d \n&quot;,</a>
<a name="8838"><span class="lineNum">    8838 </span>            :                          initializedName-&gt;get_name().str(),amountOfNameQualificationRequiredForType);</a>
<a name="8839"><span class="lineNum">    8839 </span>            : #endif</a>
<a name="8840"><span class="lineNum">    8840 </span>            : #if 0</a>
<a name="8841"><span class="lineNum">    8841 </span>            :                  // DQ (1/3/2020): Debugging code for Cxx11_tests/test2020_07.C.</a>
<a name="8842"><span class="lineNum">    8842 </span>            :                     if (initializedName-&gt;get_name() == &quot;var_2&quot;)</a>
<a name="8843"><span class="lineNum">    8843 </span>            :                        {</a>
<a name="8844"><span class="lineNum">    8844 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="8845"><span class="lineNum">    8845 </span>            :                          ROSE_ABORT();</a>
<a name="8846"><span class="lineNum">    8846 </span>            :                        }</a>
<a name="8847"><span class="lineNum">    8847 </span>            : #endif</a>
<a name="8848"><span class="lineNum">    8848 </span>            : #if 1</a>
<a name="8849"><span class="lineNum">    8849 </span>            :                  // DQ (8/4/2012): This is redundant code with where the SgInitializedName appears in the SgVariableDeclaration.</a>
<a name="8850"><span class="lineNum">    8850 </span>            :                  // **************************************************</a>
<a name="8851"><span class="lineNum">    8851 </span>            :                  // DQ (8/4/2012): The type being used might not have to be qualified if it is associated with a SgClassDeclaration</a>
<a name="8852"><span class="lineNum">    8852 </span>            :                  // that has not been defined yet.  This fixes test2012_165.C.</a>
<a name="8853"><span class="lineNum">    8853 </span>            :                  // **************************************************</a>
<a name="8854"><span class="lineNum">    8854 </span>            :                     bool skipGlobalNameQualification = skipNameQualificationIfNotProperlyDeclaredWhereDeclarationIsDefinable(declaration);</a>
<a name="8855"><span class="lineNum">    8855 </span>            : </a>
<a name="8856"><span class="lineNum">    8856 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="8857"><span class="lineNum">    8857 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;case of SgInitializedName: currentScope = %p = %s \n&quot;,currentScope,currentScope-&gt;class_name().c_str());</a>
<a name="8858"><span class="lineNum">    8858 </span>            : #endif</a>
<a name="8859"><span class="lineNum">    8859 </span>            : #if 0</a>
<a name="8860"><span class="lineNum">    8860 </span>            :                  // DQ (2/21/2019): debugging support.</a>
<a name="8861"><span class="lineNum">    8861 </span>            :                     if (debugging == true)</a>
<a name="8862"><span class="lineNum">    8862 </span>            :                        {</a>
<a name="8863"><span class="lineNum">    8863 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="8864"><span class="lineNum">    8864 </span>            :                          ROSE_ABORT();</a>
<a name="8865"><span class="lineNum">    8865 </span>            :                        }</a>
<a name="8866"><span class="lineNum">    8866 </span>            : #endif</a>
<a name="8867"><span class="lineNum">    8867 </span>            : </a>
<a name="8868"><span class="lineNum">    8868 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="8869"><span class="lineNum">    8869 </span>            : </a>
<a name="8870"><span class="lineNum">    8870 </span>            :                  // DQ (8/4/2012): However, this quasi-pathological case does not apply to template instantiations</a>
<a name="8871"><span class="lineNum">    8871 </span>            :                  // (only non-template classes or maybe named types more generally?).  Handle template declarations similarly.</a>
<a name="8872"><span class="lineNum">    8872 </span>            :                  // OR enum declarations (since they can have a forward declaration (except that this is a common languae extension...).</a>
<a name="8873"><span class="lineNum">    8873 </span>            :                     if (isSgTemplateInstantiationDecl(declaration) != NULL || isSgEnumDeclaration(declaration) != NULL || isSgNonrealDecl(declaration) != NULL)</a>
<a name="8874"><span class="lineNum">    8874 </span>            :                        {</a>
<a name="8875"><span class="lineNum">    8875 </span>            :                       // Do the regularly schedule name qualification for these cases.</a>
<a name="8876"><span class="lineNum">    8876 </span>            :                          skipGlobalNameQualification = false;</a>
<a name="8877"><span class="lineNum">    8877 </span>            :                        }</a>
<a name="8878"><span class="lineNum">    8878 </span>            :                       else</a>
<a name="8879"><span class="lineNum">    8879 </span>            :                        {</a>
<a name="8880"><span class="lineNum">    8880 </span>            :                       // Look back through the scopes and see if we are in a template instantiation or template scope,</a>
<a name="8881"><span class="lineNum">    8881 </span>            :                       // if so then do the regularly scheduled name qualification.</a>
<a name="8882"><span class="lineNum">    8882 </span>            : </a>
<a name="8883"><span class="lineNum">    8883 </span>            :                          SgScopeStatement* scope = declaration-&gt;get_scope();</a>
<a name="8884"><span class="lineNum">    8884 </span>            :                       // mfprintf(mlog [ WARN ] ) (&quot;case of SgInitializedName: scope = %p = %s \n&quot;,scope,scope-&gt;class_name().c_str());</a>
<a name="8885"><span class="lineNum">    8885 </span>            :                          int distanceBackThroughScopes = amountOfNameQualificationRequiredForType;</a>
<a name="8886"><span class="lineNum">    8886 </span>            :                       // mfprintf(mlog [ WARN ] ) (&quot;case of SgInitializedName: distanceBackThroughScopes = %d \n&quot;,distanceBackThroughScopes);</a>
<a name="8887"><span class="lineNum">    8887 </span>            :                          while (distanceBackThroughScopes &gt; 0 &amp;&amp; scope != NULL)</a>
<a name="8888"><span class="lineNum">    8888 </span>            :                             {</a>
<a name="8889"><span class="lineNum">    8889 </span>            :                            // Traverse backwards through the scopes checking for a SgTemplateClassDefinition scope</a>
<a name="8890"><span class="lineNum">    8890 </span>            :                            // If we traverse off the end of SgGlobal then the amountOfNameQualificationRequiredForType</a>
<a name="8891"><span class="lineNum">    8891 </span>            :                            // value was trying to trigger global qualification, so this is not a problem.</a>
<a name="8892"><span class="lineNum">    8892 </span>            :                            // We at least need isSgTemplateInstantiationDefn, not clear about isSgTemplateClassDefinition.</a>
<a name="8893"><span class="lineNum">    8893 </span>            : </a>
<a name="8894"><span class="lineNum">    8894 </span>            :                               if (isSgTemplateInstantiationDefn(scope) != NULL || isSgTemplateClassDefinition(scope) != NULL)</a>
<a name="8895"><span class="lineNum">    8895 </span>            :                                  {</a>
<a name="8896"><span class="lineNum">    8896 </span>            :                                    skipGlobalNameQualification = false;</a>
<a name="8897"><span class="lineNum">    8897 </span>            :                                  }</a>
<a name="8898"><span class="lineNum">    8898 </span>            : </a>
<a name="8899"><span class="lineNum">    8899 </span>            :                               ASSERT_not_null(scope);</a>
<a name="8900"><span class="lineNum">    8900 </span>            :                               scope = scope-&gt;get_scope();</a>
<a name="8901"><span class="lineNum">    8901 </span>            : </a>
<a name="8902"><span class="lineNum">    8902 </span>            :                               distanceBackThroughScopes--;</a>
<a name="8903"><span class="lineNum">    8903 </span>            :                             }</a>
<a name="8904"><span class="lineNum">    8904 </span>            :                        }</a>
<a name="8905"><span class="lineNum">    8905 </span>            : </a>
<a name="8906"><span class="lineNum">    8906 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || DEBUG_INITIALIZED_NAME</a>
<a name="8907"><span class="lineNum">    8907 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Test of Type used in SgInitializedName: declaration = %p = %s skipGlobalNameQualification = %s \n&quot;,declaration,declaration-&gt;class_name().c_str(),skipGlobalNameQualification ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="8908"><span class="lineNum">    8908 </span>            : #endif</a>
<a name="8909"><span class="lineNum">    8909 </span>            :                  // DQ (4/26/2019): Need to call setNameQualificationForType so that we can save the name qualification string using the SgInitializedName as the key.</a>
<a name="8910"><span class="lineNum">    8910 </span>            :                  // DQ (8/4/2012): Added support to permit global qualification be be skipped explicitly (see test2012_164.C and test2012_165.C for examples where this is important).</a>
<a name="8911"><span class="lineNum">    8911 </span>            :                  // setNameQualification(initializedName,declaration,amountOfNameQualificationRequiredForType,skipGlobalNameQualification);</a>
<a name="8912"><span class="lineNum">    8912 </span>            :                     setNameQualificationOnType(initializedName,declaration,amountOfNameQualificationRequiredForType,skipGlobalNameQualification);</a>
<a name="8913"><span class="lineNum">    8913 </span>            : </a>
<a name="8914"><span class="lineNum">    8914 </span>            : #if DEBUG_INITIALIZED_NAME</a>
<a name="8915"><span class="lineNum">    8915 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;@@@@@@@@@ Calling traverseType() to save type as string if it is contained types that would be shared AND name qualified \n&quot;);</a>
<a name="8916"><span class="lineNum">    8916 </span>            : #endif</a>
<a name="8917"><span class="lineNum">    8917 </span>            :                  // DQ (4/27/2019): I think we need to call this function to handle the name qualification on template</a>
<a name="8918"><span class="lineNum">    8918 </span>            :                  // arguments where the type is a template instantiation.</a>
<a name="8919"><span class="lineNum">    8919 </span>            :                     SgStatement* associatedStatement = currentScope;</a>
<a name="8920"><span class="lineNum">    8920 </span>            : </a>
<a name="8921"><span class="lineNum">    8921 </span>            :                     SgNode* initializedNameParent = initializedName-&gt;get_parent();</a>
<a name="8922"><span class="lineNum">    8922 </span>            :                     ASSERT_not_null(initializedNameParent);</a>
<a name="8923"><span class="lineNum">    8923 </span>            : </a>
<a name="8924"><span class="lineNum">    8924 </span>            : #if DEBUG_INITIALIZED_NAME || 0</a>
<a name="8925"><span class="lineNum">    8925 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;initializedNameParent = %p = %s \n&quot;,initializedNameParent,initializedNameParent-&gt;class_name().c_str());</a>
<a name="8926"><span class="lineNum">    8926 </span>            : #endif</a>
<a name="8927"><span class="lineNum">    8927 </span>            :                     bool skipTraverseType = false;</a>
<a name="8928"><span class="lineNum">    8928 </span>            :                     SgVariableDeclaration* variableDeclaration = isSgVariableDeclaration(initializedNameParent);</a>
<a name="8929"><span class="lineNum">    8929 </span>            :                     if (variableDeclaration != NULL)</a>
<a name="8930"><span class="lineNum">    8930 </span>            :                        {</a>
<a name="8931"><span class="lineNum">    8931 </span>            : #if DEBUG_INITIALIZED_NAME</a>
<a name="8932"><span class="lineNum">    8932 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;variableDeclaration-&gt;get_variableDeclarationContainsBaseTypeDefiningDeclaration() = %s \n&quot;,</a>
<a name="8933"><span class="lineNum">    8933 </span>            :                               variableDeclaration-&gt;get_variableDeclarationContainsBaseTypeDefiningDeclaration() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="8934"><span class="lineNum">    8934 </span>            : #endif</a>
<a name="8935"><span class="lineNum">    8935 </span>            :                          // DQ (5/26/2019): I think this should be the reversed.</a>
<a name="8936"><span class="lineNum">    8936 </span>            :                       // skipTraverseType = variableDeclaration-&gt;get_variableDeclarationContainsBaseTypeDefiningDeclaration();</a>
<a name="8937"><span class="lineNum">    8937 </span>            :                          if (variableDeclaration-&gt;get_variableDeclarationContainsBaseTypeDefiningDeclaration() == true)</a>
<a name="8938"><span class="lineNum">    8938 </span>            :                             {</a>
<a name="8939"><span class="lineNum">    8939 </span>            :                               skipTraverseType = true;</a>
<a name="8940"><span class="lineNum">    8940 </span>            :                             }</a>
<a name="8941"><span class="lineNum">    8941 </span>            :                            else</a>
<a name="8942"><span class="lineNum">    8942 </span>            :                             {</a>
<a name="8943"><span class="lineNum">    8943 </span>            :                            // The name of the type will have to be output!</a>
<a name="8944"><span class="lineNum">    8944 </span>            :                             }</a>
<a name="8945"><span class="lineNum">    8945 </span>            :                        }</a>
<a name="8946"><span class="lineNum">    8946 </span>            :                       else</a>
<a name="8947"><span class="lineNum">    8947 </span>            :                        {</a>
<a name="8948"><span class="lineNum">    8948 </span>            : #if DEBUG_INITIALIZED_NAME</a>
<a name="8949"><span class="lineNum">    8949 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;initializedNameParent = %p = %s \n&quot;,initializedNameParent,initializedNameParent-&gt;class_name().c_str());</a>
<a name="8950"><span class="lineNum">    8950 </span>            : #endif</a>
<a name="8951"><span class="lineNum">    8951 </span>            :                        }</a>
<a name="8952"><span class="lineNum">    8952 </span>            : </a>
<a name="8953"><span class="lineNum">    8953 </span>            : #if 0</a>
<a name="8954"><span class="lineNum">    8954 </span>            :                     SgTypedefType* typedefType = isSgTypedefType(initializedName-&gt;get_type());</a>
<a name="8955"><span class="lineNum">    8955 </span>            :                     if (typedefType != NULL)</a>
<a name="8956"><span class="lineNum">    8956 </span>            :                        {</a>
<a name="8957"><span class="lineNum">    8957 </span>            :                          SgTypedefDeclaration* typedefDeclaration = isSgTypedefDeclaration(typedefType-&gt;get_declaration());</a>
<a name="8958"><span class="lineNum">    8958 </span>            :                          ASSERT_not_null(typedefDeclaration);</a>
<a name="8959"><span class="lineNum">    8959 </span>            : </a>
<a name="8960"><span class="lineNum">    8960 </span>            : #if DEBUG_INITIALIZED_NAME || 0</a>
<a name="8961"><span class="lineNum">    8961 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;typedefDeclaration-&gt;get_typedefBaseTypeContainsDefiningDeclaration() = %s \n&quot;,</a>
<a name="8962"><span class="lineNum">    8962 </span>            :                               typedefDeclaration-&gt;get_typedefBaseTypeContainsDefiningDeclaration() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="8963"><span class="lineNum">    8963 </span>            : #endif</a>
<a name="8964"><span class="lineNum">    8964 </span>            :                          skipTraverseType = typedefDeclaration-&gt;get_typedefBaseTypeContainsDefiningDeclaration();</a>
<a name="8965"><span class="lineNum">    8965 </span>            :                        }</a>
<a name="8966"><span class="lineNum">    8966 </span>            : #endif</a>
<a name="8967"><span class="lineNum">    8967 </span>            : #if 0</a>
<a name="8968"><span class="lineNum">    8968 </span>            :                  // DQ (5/25/2019): If we don't skip the type traversal because  amountOfNameQualificationRequiredForType == 0,</a>
<a name="8969"><span class="lineNum">    8969 </span>            :                  // then we don't need this code here!</a>
<a name="8970"><span class="lineNum">    8970 </span>            :                  // DQ (5/25/2019): If this is associated with a template instantiaton, then we need to save the</a>
<a name="8971"><span class="lineNum">    8971 </span>            :                  // typename as a string to preservce context of any nested template argument name qualification.</a>
<a name="8972"><span class="lineNum">    8972 </span>            :                     SgClassType* classType = isSgClassType(initializedName-&gt;get_type());</a>
<a name="8973"><span class="lineNum">    8973 </span>            :                     if (classType != NULL)</a>
<a name="8974"><span class="lineNum">    8974 </span>            :                        {</a>
<a name="8975"><span class="lineNum">    8975 </span>            :                          ASSERT_not_null(classType-&gt;get_declaration());</a>
<a name="8976"><span class="lineNum">    8976 </span>            : #if DEBUG_INITIALIZED_NAME</a>
<a name="8977"><span class="lineNum">    8977 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;classType-&gt;get_declaration() = %s \n&quot;,classType-&gt;get_declaration()-&gt;class_name().c_str());</a>
<a name="8978"><span class="lineNum">    8978 </span>            : #endif</a>
<a name="8979"><span class="lineNum">    8979 </span>            :                          SgTemplateInstantiationDecl* templateInstantiationDecl = isSgTemplateInstantiationDecl(classType-&gt;get_declaration());</a>
<a name="8980"><span class="lineNum">    8980 </span>            :                          if (templateInstantiationDecl != NULL)</a>
<a name="8981"><span class="lineNum">    8981 </span>            :                             {</a>
<a name="8982"><span class="lineNum">    8982 </span>            :                               skipTraverseType = false;</a>
<a name="8983"><span class="lineNum">    8983 </span>            :                             }</a>
<a name="8984"><span class="lineNum">    8984 </span>            :                        }</a>
<a name="8985"><span class="lineNum">    8985 </span>            : #endif</a>
<a name="8986"><span class="lineNum">    8986 </span>            : #if 0</a>
<a name="8987"><span class="lineNum">    8987 </span>            :                  // DQ (5/25/2019): This will be a problem when template instantiations require name qualificaiton</a>
<a name="8988"><span class="lineNum">    8988 </span>            :                  // or are output in different contexts requiring different name qualifications.</a>
<a name="8989"><span class="lineNum">    8989 </span>            : #if DEBUG_INITIALIZED_NAME</a>
<a name="8990"><span class="lineNum">    8990 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;amountOfNameQualificationRequiredForType == 0, so skipTraverseType = true initializedName-&gt;get_type() = %p = %s \n&quot;,</a>
<a name="8991"><span class="lineNum">    8991 </span>            :                          initializedName-&gt;get_type(),initializedName-&gt;get_type()-&gt;class_name().c_str());</a>
<a name="8992"><span class="lineNum">    8992 </span>            : #endif</a>
<a name="8993"><span class="lineNum">    8993 </span>            :                  // DQ (4/28/2019): We still need to generate the string for the type, because it could be a template</a>
<a name="8994"><span class="lineNum">    8994 </span>            :                  // instantiation which has template parameter that are name qualified (see test2019_423.C).</a>
<a name="8995"><span class="lineNum">    8995 </span>            :                  // FIXME: LOOK AT THIS IN THE MORNING!!!!!</a>
<a name="8996"><span class="lineNum">    8996 </span>            :                  // DQ (4/27/2019): Adding logic to skip calling traverseType() so much when it is not needed.</a>
<a name="8997"><span class="lineNum">    8997 </span>            :                  // However, we can't skip the string generation of the type if this is a template instantiation.</a>
<a name="8998"><span class="lineNum">    8998 </span>            :                     if (amountOfNameQualificationRequiredForType == 0)</a>
<a name="8999"><span class="lineNum">    8999 </span>            :                        {</a>
<a name="9000"><span class="lineNum">    9000 </span>            : #if DEBUG_INITIALIZED_NAME</a>
<a name="9001"><span class="lineNum">    9001 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;set skipTraverseType = true: amountOfNameQualificationRequiredForType == 0, so skipTraverseType = true initializedName-&gt;get_type() = %p = %s \n&quot;,</a>
<a name="9002"><span class="lineNum">    9002 </span>            :                               initializedName-&gt;get_type(),initializedName-&gt;get_type()-&gt;class_name().c_str());</a>
<a name="9003"><span class="lineNum">    9003 </span>            : #endif</a>
<a name="9004"><span class="lineNum">    9004 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;Just because there is not name qualification, does not mean that types from template instatiations with template arguments should not be saved as strings \n&quot;);</a>
<a name="9005"><span class="lineNum">    9005 </span>            :                       // skipTraverseType = true;</a>
<a name="9006"><span class="lineNum">    9006 </span>            :                        }</a>
<a name="9007"><span class="lineNum">    9007 </span>            : #endif</a>
<a name="9008"><span class="lineNum">    9008 </span>            : #if 0</a>
<a name="9009"><span class="lineNum">    9009 </span>            :                     if (skipTraverseType == true)</a>
<a name="9010"><span class="lineNum">    9010 </span>            :                        {</a>
<a name="9011"><span class="lineNum">    9011 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="9012"><span class="lineNum">    9012 </span>            :                          ROSE_ABORT();</a>
<a name="9013"><span class="lineNum">    9013 </span>            :                        }</a>
<a name="9014"><span class="lineNum">    9014 </span>            : #endif</a>
<a name="9015"><span class="lineNum">    9015 </span>            : </a>
<a name="9016"><span class="lineNum">    9016 </span>            : #if DEBUG_INITIALIZED_NAME || 0</a>
<a name="9017"><span class="lineNum">    9017 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;skipTraverseType = %s \n&quot;,skipTraverseType ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="9018"><span class="lineNum">    9018 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;initializedName-&gt;get_type() = %p = %s \n&quot;,initializedName-&gt;get_type(),initializedName-&gt;get_type()-&gt;class_name().c_str());</a>
<a name="9019"><span class="lineNum">    9019 </span>            : #endif</a>
<a name="9020"><span class="lineNum">    9020 </span>            :                  // mfprintf(mlog [ WARN ] ) (&quot;Calling traverseType ALWAYS! \n&quot;);</a>
<a name="9021"><span class="lineNum">    9021 </span>            :                     if (skipTraverseType == false)</a>
<a name="9022"><span class="lineNum">    9022 </span>            :                        {</a>
<a name="9023"><span class="lineNum">    9023 </span>            :                          traverseType(initializedName-&gt;get_type(),initializedName,currentScope,associatedStatement);</a>
<a name="9024"><span class="lineNum">    9024 </span>            :                        }</a>
<a name="9025"><span class="lineNum">    9025 </span>            : #if 0</a>
<a name="9026"><span class="lineNum">    9026 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;processAsNormalTypeThatMightRequireNameQualification == true: Looking for specific variable name: initializedName-&gt;get_name() = |%s| \n&quot;,initializedName-&gt;get_name().str());</a>
<a name="9027"><span class="lineNum">    9027 </span>            :                  // if (initializedName-&gt;get_name().str() == &quot;N&quot;)</a>
<a name="9028"><span class="lineNum">    9028 </span>            :                     if (initializedName-&gt;get_name() == &quot;N&quot;)</a>
<a name="9029"><span class="lineNum">    9029 </span>            :                        {</a>
<a name="9030"><span class="lineNum">    9030 </span>            : #if 0</a>
<a name="9031"><span class="lineNum">    9031 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;Detected initializedName-&gt;get_name().str() == \&quot;N\&quot;: Exiting as a test! \n&quot;);</a>
<a name="9032"><span class="lineNum">    9032 </span>            :                          ROSE_ABORT();</a>
<a name="9033"><span class="lineNum">    9033 </span>            : #endif</a>
<a name="9034"><span class="lineNum">    9034 </span>            :                        }</a>
<a name="9035"><span class="lineNum">    9035 </span>            : #endif</a>
<a name="9036"><span class="lineNum">    9036 </span>            : #if 0</a>
<a name="9037"><span class="lineNum">    9037 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="9038"><span class="lineNum">    9038 </span>            :                     ROSE_ABORT();</a>
<a name="9039"><span class="lineNum">    9039 </span>            : #endif</a>
<a name="9040"><span class="lineNum">    9040 </span>            :                   }</a>
<a name="9041"><span class="lineNum">    9041 </span>            :                  else</a>
<a name="9042"><span class="lineNum">    9042 </span>            :                   {</a>
<a name="9043"><span class="lineNum">    9043 </span>            :                  // DQ (8/23/2014): This case is demonstrated by test2014_145.C. where a SgInitializedName is used in a SgArrayType.</a>
<a name="9044"><span class="lineNum">    9044 </span>            :                  // However, it would provide greater symetry to handle the SgInitializedName objects in the processing of the</a>
<a name="9045"><span class="lineNum">    9045 </span>            :                  // SgFunctionParameterList similar to how they are handling in the SgVariableDeclaration.</a>
<a name="9046"><span class="lineNum">    9046 </span>            : </a>
<a name="9047"><span class="lineNum">    9047 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="9048"><span class="lineNum">    9048 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Case of SgInitializedName: getDeclarationAssociatedWithType() == NULL (this not associated with a type)  \n&quot;);</a>
<a name="9049"><span class="lineNum">    9049 </span>            : #endif</a>
<a name="9050"><span class="lineNum">    9050 </span>            : </a>
<a name="9051"><span class="lineNum">    9051 </span>            : #if 0</a>
<a name="9052"><span class="lineNum">    9052 </span>            :                  // DQ (2/7/2019): Set the pointer to member type in the inherited attribute so that we can know when to</a>
<a name="9053"><span class="lineNum">    9053 </span>            :                  // add name qualification to variables or function arguments being assigned to this initializedName.</a>
<a name="9054"><span class="lineNum">    9054 </span>            :                     SgPointerMemberType* pointerMemberType = isSgPointerMemberType(initializedName-&gt;get_type());</a>
<a name="9055"><span class="lineNum">    9055 </span>            :                     if (pointerMemberType != NULL)</a>
<a name="9056"><span class="lineNum">    9056 </span>            :                        {</a>
<a name="9057"><span class="lineNum">    9057 </span>            :                          inheritedAttribute.set_usingPointerToMemberType(pointerMemberType);</a>
<a name="9058"><span class="lineNum">    9058 </span>            :                          ASSERT_not_null(inheritedAttribute.get_usingPointerToMemberType());</a>
<a name="9059"><span class="lineNum">    9059 </span>            : #if 0</a>
<a name="9060"><span class="lineNum">    9060 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="9061"><span class="lineNum">    9061 </span>            :                          ROSE_ABORT();</a>
<a name="9062"><span class="lineNum">    9062 </span>            : #endif</a>
<a name="9063"><span class="lineNum">    9063 </span>            :                        }</a>
<a name="9064"><span class="lineNum">    9064 </span>            : #endif</a>
<a name="9065"><span class="lineNum">    9065 </span>            : </a>
<a name="9066"><span class="lineNum">    9066 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="9067"><span class="lineNum">    9067 </span>            : </a>
<a name="9068"><span class="lineNum">    9068 </span>            : #if 1</a>
<a name="9069"><span class="lineNum">    9069 </span>            :                  // DQ (4/10/2019): I think we need to call this function to handle the name qualification on template</a>
<a name="9070"><span class="lineNum">    9070 </span>            :                  // arguments where the type is a template instantiation.</a>
<a name="9071"><span class="lineNum">    9071 </span>            :                  // DQ (8/23/2014): Adding this to support SgInitializedName in SgArrayType in function parameter lists.</a>
<a name="9072"><span class="lineNum">    9072 </span>            :                  // SgDeclarationStatement* associatedDeclaration = NULL;</a>
<a name="9073"><span class="lineNum">    9073 </span>            : </a>
<a name="9074"><span class="lineNum">    9074 </span>            :                     SgScopeStatement* currentScope = inheritedAttribute.get_currentScope();</a>
<a name="9075"><span class="lineNum">    9075 </span>            :                     ASSERT_not_null(currentScope);</a>
<a name="9076"><span class="lineNum">    9076 </span>            : </a>
<a name="9077"><span class="lineNum">    9077 </span>            :                     SgStatement* associatedStatement = currentScope;</a>
<a name="9078"><span class="lineNum">    9078 </span>            : </a>
<a name="9079"><span class="lineNum">    9079 </span>            :                  // int amountOfNameQualificationRequiredForType = nameQualificationDepthForType(initializedName,currentScope,associatedDeclaration);</a>
<a name="9080"><span class="lineNum">    9080 </span>            :                     int amountOfNameQualificationRequiredForType = nameQualificationDepthForType(initializedName,currentScope,associatedStatement);</a>
<a name="9081"><span class="lineNum">    9081 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="9082"><span class="lineNum">    9082 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;SgInitializedName's type: amountOfNameQualificationRequiredForType = %d \n&quot;,amountOfNameQualificationRequiredForType);</a>
<a name="9083"><span class="lineNum">    9083 </span>            : #endif</a>
<a name="9084"><span class="lineNum">    9084 </span>            :                  // bool skipGlobalNameQualification = false;</a>
<a name="9085"><span class="lineNum">    9085 </span>            :                  // setNameQualificationOnType(initializedName,declaration,amountOfNameQualificationRequiredForType,skipGlobalNameQualification);</a>
<a name="9086"><span class="lineNum">    9086 </span>            :                  // setNameQualificationOnType(initializedName,associatedStatement,amountOfNameQualificationRequiredForType,skipGlobalNameQualification);</a>
<a name="9087"><span class="lineNum">    9087 </span>            : #if 0</a>
<a name="9088"><span class="lineNum">    9088 </span>            :                  // DQ (4/27/2019): Debugging test2019_414.C.</a>
<a name="9089"><span class="lineNum">    9089 </span>            :                     SgArrayType* tmp_arrayType = isSgArrayType(initializedName-&gt;get_type());</a>
<a name="9090"><span class="lineNum">    9090 </span>            :                     if (tmp_arrayType != NULL)</a>
<a name="9091"><span class="lineNum">    9091 </span>            :                        {</a>
<a name="9092"><span class="lineNum">    9092 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="9093"><span class="lineNum">    9093 </span>            :                          ROSE_ABORT();</a>
<a name="9094"><span class="lineNum">    9094 </span>            :                        }</a>
<a name="9095"><span class="lineNum">    9095 </span>            : #endif</a>
<a name="9096"><span class="lineNum">    9096 </span>            : #if 0</a>
<a name="9097"><span class="lineNum">    9097 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;amountOfNameQualificationRequiredForType = %d Calling traverseType() \n&quot;,amountOfNameQualificationRequiredForType);</a>
<a name="9098"><span class="lineNum">    9098 </span>            : #endif</a>
<a name="9099"><span class="lineNum">    9099 </span>            :                  // DQ (4/27/2019): This will avoid over use of the generated string mechanism to represent types, but</a>
<a name="9100"><span class="lineNum">    9100 </span>            :                  // we need to allow template instantiations to be processed.</a>
<a name="9101"><span class="lineNum">    9101 </span>            :                  // DQ (4/10/2019): I think we need to call this function to handle the name qualification on template</a>
<a name="9102"><span class="lineNum">    9102 </span>            :                  // arguments where the type is a template instantiation.</a>
<a name="9103"><span class="lineNum">    9103 </span>            :                  // traverseType(initializedName-&gt;get_type(),initializedName,currentScope,associatedStatement);</a>
<a name="9104"><span class="lineNum">    9104 </span>            :                     if (amountOfNameQualificationRequiredForType &gt; 0)</a>
<a name="9105"><span class="lineNum">    9105 </span>            :                        {</a>
<a name="9106"><span class="lineNum">    9106 </span>            : #if 1</a>
<a name="9107"><span class="lineNum">    9107 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;Calling traverseType() on initializedName-&gt;get_type(): amountOfNameQualificationRequiredForType &gt; 0: amountOfNameQualificationRequiredForType = %d Calling traverseType() \n&quot;,</a>
<a name="9108"><span class="lineNum">    9108 </span>            :                               amountOfNameQualificationRequiredForType);</a>
<a name="9109"><span class="lineNum">    9109 </span>            : #endif</a>
<a name="9110"><span class="lineNum">    9110 </span>            :                          traverseType(initializedName-&gt;get_type(),initializedName,currentScope,associatedStatement);</a>
<a name="9111"><span class="lineNum">    9111 </span>            :                        }</a>
<a name="9112"><span class="lineNum">    9112 </span>            : #endif</a>
<a name="9113"><span class="lineNum">    9113 </span>            : #if 0</a>
<a name="9114"><span class="lineNum">    9114 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Looking for specific variable name: initializedName-&gt;get_name() = %s \n&quot;,initializedName-&gt;get_name().str());</a>
<a name="9115"><span class="lineNum">    9115 </span>            : #endif</a>
<a name="9116"><span class="lineNum">    9116 </span>            : #if 0</a>
<a name="9117"><span class="lineNum">    9117 </span>            :                  // if (initializedName-&gt;get_name().str() == &quot;N&quot;)</a>
<a name="9118"><span class="lineNum">    9118 </span>            :                     if (initializedName-&gt;get_name() == &quot;N&quot;)</a>
<a name="9119"><span class="lineNum">    9119 </span>            :                        {</a>
<a name="9120"><span class="lineNum">    9120 </span>            : #if 1</a>
<a name="9121"><span class="lineNum">    9121 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;Detected initializedName-&gt;get_name().str() == \&quot;N\&quot;: Exiting as a test! \n&quot;);</a>
<a name="9122"><span class="lineNum">    9122 </span>            :                          ROSE_ABORT();</a>
<a name="9123"><span class="lineNum">    9123 </span>            : #endif</a>
<a name="9124"><span class="lineNum">    9124 </span>            :                        }</a>
<a name="9125"><span class="lineNum">    9125 </span>            : #endif</a>
<a name="9126"><span class="lineNum">    9126 </span>            : #if 0</a>
<a name="9127"><span class="lineNum">    9127 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="9128"><span class="lineNum">    9128 </span>            :                     ROSE_ABORT();</a>
<a name="9129"><span class="lineNum">    9129 </span>            : #endif</a>
<a name="9130"><span class="lineNum">    9130 </span>            :                   }</a>
<a name="9131"><span class="lineNum">    9131 </span>            : </a>
<a name="9132"><span class="lineNum">    9132 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="9133"><span class="lineNum">    9133 </span>            : </a>
<a name="9134"><span class="lineNum">    9134 </span>            : #endif</a>
<a name="9135"><span class="lineNum">    9135 </span>            : </a>
<a name="9136"><span class="lineNum">    9136 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="9137"><span class="lineNum">    9137 </span>            : </a>
<a name="9138"><span class="lineNum">    9138 </span>            : #if DEBUG_INITIALIZED_NAME</a>
<a name="9139"><span class="lineNum">    9139 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;######################################################################## \n&quot;);</a>
<a name="9140"><span class="lineNum">    9140 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Case SgInitializedName: DONE: Processing the SgInitializedName IR's type \n&quot;);</a>
<a name="9141"><span class="lineNum">    9141 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;######################################################################## \n&quot;);</a>
<a name="9142"><span class="lineNum">    9142 </span>            : #endif</a>
<a name="9143"><span class="lineNum">    9143 </span>            : </a>
<a name="9144"><span class="lineNum">    9144 </span>            : #if 0</a>
<a name="9145"><span class="lineNum">    9145 </span>            :             // DQ (4/27/2019): Debugging test2019_414.C.</a>
<a name="9146"><span class="lineNum">    9146 </span>            :                SgArrayType* tmp_arrayType = isSgArrayType(initializedName-&gt;get_type());</a>
<a name="9147"><span class="lineNum">    9147 </span>            :                if (tmp_arrayType != NULL)</a>
<a name="9148"><span class="lineNum">    9148 </span>            :                   {</a>
<a name="9149"><span class="lineNum">    9149 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="9150"><span class="lineNum">    9150 </span>            :                     ROSE_ABORT();</a>
<a name="9151"><span class="lineNum">    9151 </span>            :                   }</a>
<a name="9152"><span class="lineNum">    9152 </span>            : #endif</a>
<a name="9153"><span class="lineNum">    9153 </span>            : </a>
<a name="9154"><span class="lineNum">    9154 </span>            :             // DQ (4/27/2019): This is the new location of the end of the block to process the SgInitializedName's type.</a>
<a name="9155"><span class="lineNum">    9155 </span>            :              }</a>
<a name="9156"><span class="lineNum">    9156 </span>            : </a>
<a name="9157"><span class="lineNum">    9157 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="9158"><span class="lineNum">    9158 </span>            : </a>
<a name="9159"><span class="lineNum">    9159 </span>            :        // endif for type handling.</a>
<a name="9160"><span class="lineNum">    9160 </span>            : #endif</a>
<a name="9161"><span class="lineNum">    9161 </span>            : </a>
<a name="9162"><span class="lineNum">    9162 </span>            :        // DQ (9/2/2020): This is the start of the non-commented out code!</a>
<a name="9163"><span class="lineNum">    9163 </span>            : #if DEBUG_INITIALIZED_NAME &amp;&amp; 0</a>
<a name="9164"><span class="lineNum">    9164 </span>            :           printf(&quot;222222222222222222222222222222222222222222222222222222222222222222222222222 \n&quot;);</a>
<a name="9165"><span class="lineNum">    9165 </span>            :           printf(&quot;222222222222222222222222222222222222222222222222222222222222222222222222222 \n&quot;);</a>
<a name="9166"><span class="lineNum">    9166 </span>            :           printf(&quot;222222222222222222222222222222222222222222222222222222222222222222222222222 \n&quot;);</a>
<a name="9167"><span class="lineNum">    9167 </span>            :           printf(&quot;222222222222222222222222222222222222222222222222222222222222222222222222222 \n&quot;);</a>
<a name="9168"><span class="lineNum">    9168 </span>            :           printf(&quot;222222222222222222222222222222222222222222222222222222222222222222222222222 \n&quot;);</a>
<a name="9169"><span class="lineNum">    9169 </span>            :           printf(&quot;222222222222222222222222222222222222222222222222222222222222222222222222222 \n&quot;);</a>
<a name="9170"><span class="lineNum">    9170 </span>            : #endif</a>
<a name="9171"><span class="lineNum">    9171 </span>            : </a>
<a name="9172"><span class="lineNum">    9172 </span>            : #if DEBUG_INITIALIZED_NAME</a>
<a name="9173"><span class="lineNum">    9173 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;########################################################################### \n&quot;);</a>
<a name="9174"><span class="lineNum">    9174 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Case SgInitializedName: Processing the SgInitializedName IR's name = %s \n&quot;,initializedName-&gt;get_name().str());</a>
<a name="9175"><span class="lineNum">    9175 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;########################################################################### \n&quot;);</a>
<a name="9176"><span class="lineNum">    9176 </span>            : #endif</a>
<a name="9177"><span class="lineNum">    9177 </span>            :        // XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</a>
<a name="9178"><span class="lineNum">    9178 </span>            : </a>
<a name="9179"><span class="lineNum">    9179 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || DEBUG_INITIALIZED_NAME</a>
<a name="9180"><span class="lineNum">    9180 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;initializedName-&gt;get_prev_decl_item() = %p \n&quot;,initializedName-&gt;get_prev_decl_item());</a>
<a name="9181"><span class="lineNum">    9181 </span>            : #endif</a>
<a name="9182"><span class="lineNum">    9182 </span>            : </a>
<a name="9183"><span class="lineNum">    9183 </span><span class="lineCov">    1462240 :           bool initializedNameCouldRequireNameQualification = (initializedName-&gt;get_prev_decl_item() != NULL);</span></a>
<a name="9184"><span class="lineNum">    9184 </span>            : #if DEBUG_INITIALIZED_NAME</a>
<a name="9185"><span class="lineNum">    9185 </span>            :           printf (&quot;Case SgInitializedName: initializedNameCouldRequireNameQualification = %s \n&quot;,initializedNameCouldRequireNameQualification ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="9186"><span class="lineNum">    9186 </span>            : #endif</a>
<a name="9187"><span class="lineNum">    9187 </span><span class="lineCov">    1462240 :           if (initializedNameCouldRequireNameQualification == true)</span></a>
<a name="9188"><span class="lineNum">    9188 </span>            :              {</a>
<a name="9189"><span class="lineNum">    9189 </span><span class="lineCov">        275 :                SgInitializedName* originallyDeclaredInitializedName = initializedName-&gt;get_prev_decl_item();</span></a>
<a name="9190"><span class="lineNum">    9190 </span>            : </a>
<a name="9191"><span class="lineNum">    9191 </span>            : #if DEBUG_INITIALIZED_NAME</a>
<a name="9192"><span class="lineNum">    9192 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;originallyDeclaredInitializedName = %p = %s name = %s \n&quot;,</a>
<a name="9193"><span class="lineNum">    9193 </span>            :                     originallyDeclaredInitializedName,originallyDeclaredInitializedName-&gt;class_name().c_str(),originallyDeclaredInitializedName-&gt;get_name().str());</a>
<a name="9194"><span class="lineNum">    9194 </span>            : #endif</a>
<a name="9195"><span class="lineNum">    9195 </span>            :             // SgInitializedName* initializedName = SageInterface::getFirstInitializedName(variableDeclaration);</a>
<a name="9196"><span class="lineNum">    9196 </span><span class="lineCov">        275 :                ASSERT_not_null(initializedName);</span></a>
<a name="9197"><span class="lineNum">    9197 </span><span class="lineCov">        275 :                ASSERT_not_null(initializedName-&gt;get_parent());</span></a>
<a name="9198"><span class="lineNum">    9198 </span>            : </a>
<a name="9199"><span class="lineNum">    9199 </span><span class="lineCov">        275 :                ASSERT_not_null(originallyDeclaredInitializedName-&gt;get_parent());</span></a>
<a name="9200"><span class="lineNum">    9200 </span>            : </a>
<a name="9201"><span class="lineNum">    9201 </span>            :             // SgDeclarationStatement* associatedDeclaration = isSgDeclarationStatement(initializedName-&gt;get_parent());</a>
<a name="9202"><span class="lineNum">    9202 </span>            :             // SgDeclarationStatement* associatedDeclaration = isSgDeclarationStatement(initializedName-&gt;get_parent());</a>
<a name="9203"><span class="lineNum">    9203 </span><span class="lineCov">        275 :                SgDeclarationStatement* associatedDeclaration = isSgDeclarationStatement(originallyDeclaredInitializedName-&gt;get_parent());</span></a>
<a name="9204"><span class="lineNum">    9204 </span><span class="lineCov">        275 :                if (associatedDeclaration == NULL)</span></a>
<a name="9205"><span class="lineNum">    9205 </span>            :                   {</a>
<a name="9206"><span class="lineNum">    9206 </span>            : #if DEBUG_INITIALIZED_NAME</a>
<a name="9207"><span class="lineNum">    9207 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Note: unexpected IR node: originallyDeclaredInitializedName-&gt;get_parent() = %p = %s \n&quot;,</a>
<a name="9208"><span class="lineNum">    9208 </span>            :                          originallyDeclaredInitializedName-&gt;get_parent(),originallyDeclaredInitializedName-&gt;get_parent()-&gt;class_name().c_str());</a>
<a name="9209"><span class="lineNum">    9209 </span>            : #endif</a>
<a name="9210"><span class="lineNum">    9210 </span>            :                  // DQ (4/27/2019): Address at least this specific case of a SgClassDefinition (should include case of SgTemplateClassDefinition).</a>
<a name="9211"><span class="lineNum">    9211 </span>            :                  // SgTemplateClassDefinition</a>
<a name="9212"><span class="lineNum">    9212 </span><span class="lineNoCov">          0 :                     SgClassDefinition * classDefinition = isSgClassDefinition(originallyDeclaredInitializedName-&gt;get_parent());</span></a>
<a name="9213"><span class="lineNum">    9213 </span><span class="lineNoCov">          0 :                     if (classDefinition != NULL)</span></a>
<a name="9214"><span class="lineNum">    9214 </span>            :                        {</a>
<a name="9215"><span class="lineNum">    9215 </span><span class="lineNoCov">          0 :                          associatedDeclaration = classDefinition-&gt;get_declaration();</span></a>
<a name="9216"><span class="lineNum">    9216 </span><span class="lineNoCov">          0 :                          ASSERT_not_null(associatedDeclaration);</span></a>
<a name="9217"><span class="lineNum">    9217 </span>            :                        }</a>
<a name="9218"><span class="lineNum">    9218 </span>            :                   }</a>
<a name="9219"><span class="lineNum">    9219 </span>            : </a>
<a name="9220"><span class="lineNum">    9220 </span>            :             // DQ (6/27/2019): Added more debugging support.</a>
<a name="9221"><span class="lineNum">    9221 </span><span class="lineCov">        275 :                if (associatedDeclaration == NULL)</span></a>
<a name="9222"><span class="lineNum">    9222 </span>            :                   {</a>
<a name="9223"><span class="lineNum">    9223 </span><span class="lineNoCov">          0 :                     mfprintf(mlog [ WARN ] ) (&quot;Note: unexpected IR node: originallyDeclaredInitializedName-&gt;get_parent() = %p = %s \n&quot;,</span></a>
<a name="9224"><span class="lineNum">    9224 </span><span class="lineNoCov">          0 :                          originallyDeclaredInitializedName-&gt;get_parent(),originallyDeclaredInitializedName-&gt;get_parent()-&gt;class_name().c_str());</span></a>
<a name="9225"><span class="lineNum">    9225 </span><span class="lineNoCov">          0 :                     mfprintf(mlog [ WARN ] ) (&quot; --- originallyDeclaredInitializedName-&gt;get_name() = %s \n&quot;,originallyDeclaredInitializedName-&gt;get_name().str());</span></a>
<a name="9226"><span class="lineNum">    9226 </span><span class="lineNoCov">          0 :                     originallyDeclaredInitializedName-&gt;get_file_info()-&gt;display(&quot;unexpected IR node&quot;);</span></a>
<a name="9227"><span class="lineNum">    9227 </span>            :                   }</a>
<a name="9228"><span class="lineNum">    9228 </span><span class="lineCov">        275 :                ASSERT_not_null(associatedDeclaration);</span></a>
<a name="9229"><span class="lineNum">    9229 </span>            : </a>
<a name="9230"><span class="lineNum">    9230 </span>            :             // Reuse the previously computed currentScope.</a>
<a name="9231"><span class="lineNum">    9231 </span>            :             // This is not always the correct current scope (see test2011_70.C for an example).</a>
<a name="9232"><span class="lineNum">    9232 </span>            :             // SgScopeStatement* currentScope = SageInterface::getScope(variableDeclaration);</a>
<a name="9233"><span class="lineNum">    9233 </span>            :             // SgScopeStatement* currentScope = isSgScopeStatement(variableDeclaration-&gt;get_parent());</a>
<a name="9234"><span class="lineNum">    9234 </span>            :             // SgScopeStatement* currentScope = SageInterface::getScope(associatedDeclaration);</a>
<a name="9235"><span class="lineNum">    9235 </span><span class="lineCov">        275 :                ASSERT_not_null(currentScope);</span></a>
<a name="9236"><span class="lineNum">    9236 </span>            : #if DEBUG_INITIALIZED_NAME</a>
<a name="9237"><span class="lineNum">    9237 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;SgInitializedName: name: currentScope = %p = %s \n&quot;,currentScope,currentScope-&gt;class_name().c_str());</a>
<a name="9238"><span class="lineNum">    9238 </span>            : #endif</a>
<a name="9239"><span class="lineNum">    9239 </span>            : #if 0</a>
<a name="9240"><span class="lineNum">    9240 </span>            :             // DQ (5/24/2013): This should be the same scope as what is in the inherited attribute, I think.</a>
<a name="9241"><span class="lineNum">    9241 </span>            :             // This fails for test2013_186.C, I expect it is because one of these is NULL (allowed for some nested traversals).</a>
<a name="9242"><span class="lineNum">    9242 </span>            :                if (currentScope != inheritedAttribute.get_currentScope())</a>
<a name="9243"><span class="lineNum">    9243 </span>            :                   {</a>
<a name="9244"><span class="lineNum">    9244 </span>            :                     if (currentScope != NULL &amp;&amp; inheritedAttribute.get_currentScope() != NULL)</a>
<a name="9245"><span class="lineNum">    9245 </span>            :                        {</a>
<a name="9246"><span class="lineNum">    9246 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 1) || DEBUG_INITIALIZED_NAME</a>
<a name="9247"><span class="lineNum">    9247 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;WARNING: currentScope != inheritedAttribute.get_currentScope(): currentScope = %p = %s inheritedAttribute.get_currentScope() = %p = %s \n&quot;,</a>
<a name="9248"><span class="lineNum">    9248 </span>            :                               currentScope,currentScope-&gt;class_name().c_str(),inheritedAttribute.get_currentScope(),inheritedAttribute.get_currentScope()-&gt;class_name().c_str());</a>
<a name="9249"><span class="lineNum">    9249 </span>            : #endif</a>
<a name="9250"><span class="lineNum">    9250 </span>            :                        }</a>
<a name="9251"><span class="lineNum">    9251 </span>            :                   }</a>
<a name="9252"><span class="lineNum">    9252 </span>            :             // ROSE_ASSERT(currentScope == inheritedAttribute.get_currentScope());</a>
<a name="9253"><span class="lineNum">    9253 </span>            : #endif</a>
<a name="9254"><span class="lineNum">    9254 </span>            : </a>
<a name="9255"><span class="lineNum">    9255 </span>            : #if 0</a>
<a name="9256"><span class="lineNum">    9256 </span>            :           printf (&quot;Case of SgConstructorInitializer: initializedName = %p = %s name = %s \n&quot;,</a>
<a name="9257"><span class="lineNum">    9257 </span>            :                initializedName,initializedName-&gt;class_name().c_str(),SageInterface::get_name(initializedName).c_str());</a>
<a name="9258"><span class="lineNum">    9258 </span>            :           printf (&quot;Case of SgConstructorInitializer: currentScope = %p = %s name = %s \n&quot;,currentScope,</a>
<a name="9259"><span class="lineNum">    9259 </span>            :                currentScope-&gt;class_name().c_str(),SageInterface::get_name(currentScope).c_str());</a>
<a name="9260"><span class="lineNum">    9260 </span>            :           printf (&quot;Case of SgConstructorInitializer: associatedDeclaration = %p = %s name = %s \n&quot;,associatedDeclaration,</a>
<a name="9261"><span class="lineNum">    9261 </span>            :                associatedDeclaration-&gt;class_name().c_str(),SageInterface::get_name(associatedDeclaration).c_str());</a>
<a name="9262"><span class="lineNum">    9262 </span>            : #endif</a>
<a name="9263"><span class="lineNum">    9263 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || DEBUG_INITIALIZED_NAME</a>
<a name="9264"><span class="lineNum">    9264 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;================ Calling nameQualificationDepthForType to evaluate the type \n&quot;);</a>
<a name="9265"><span class="lineNum">    9265 </span>            : #endif</a>
<a name="9266"><span class="lineNum">    9266 </span>            :             // Compute the depth of name qualification from the current statement:  variableDeclaration.</a>
<a name="9267"><span class="lineNum">    9267 </span>            :             // int amountOfNameQualificationRequiredForType = nameQualificationDepthForType(initializedName,variableDeclaration);</a>
<a name="9268"><span class="lineNum">    9268 </span>            :             // int amountOfNameQualificationRequiredForType = nameQualificationDepthForType(initializedName,currentScope,variableDeclaration);</a>
<a name="9269"><span class="lineNum">    9269 </span><span class="lineCov">        275 :                int amountOfNameQualificationRequiredForName = nameQualificationDepth(initializedName,currentScope,associatedDeclaration);</span></a>
<a name="9270"><span class="lineNum">    9270 </span>            : </a>
<a name="9271"><span class="lineNum">    9271 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || DEBUG_INITIALIZED_NAME</a>
<a name="9272"><span class="lineNum">    9272 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;SgInitializedName: name: amountOfNameQualificationRequiredForName = %d \n&quot;,amountOfNameQualificationRequiredForName);</a>
<a name="9273"><span class="lineNum">    9273 </span>            : #endif</a>
<a name="9274"><span class="lineNum">    9274 </span>            : </a>
<a name="9275"><span class="lineNum">    9275 </span>            : #if 1</a>
<a name="9276"><span class="lineNum">    9276 </span>            :             // DQ (4/26/2019): Call this directly for the name qualificaiton of the SgInitializedName.</a>
<a name="9277"><span class="lineNum">    9277 </span>            :             // bool skipGlobalNameQualification = skipNameQualificationIfNotProperlyDeclaredWhereDeclarationIsDefinable(declaration);</a>
<a name="9278"><span class="lineNum">    9278 </span>            :             // bool skipGlobalNameQualification = true;</a>
<a name="9279"><span class="lineNum">    9279 </span><span class="lineCov">        275 :                bool skipGlobalNameQualification = false;</span></a>
<a name="9280"><span class="lineNum">    9280 </span>            :             // setNameQualificationOnName(initializedName,declaration,amountOfNameQualificationRequiredForName,skipGlobalNameQualification);</a>
<a name="9281"><span class="lineNum">    9281 </span><span class="lineCov">        275 :                setNameQualificationOnName(initializedName,associatedDeclaration,amountOfNameQualificationRequiredForName,skipGlobalNameQualification);</span></a>
<a name="9282"><span class="lineNum">    9282 </span>            : #else</a>
<a name="9283"><span class="lineNum">    9283 </span>            :             // Not all types have an associated declaration, but some do: examples include classes, typedefs, and enums.</a>
<a name="9284"><span class="lineNum">    9284 </span>            :                SgDeclarationStatement* declaration = getDeclarationAssociatedWithType(initializedName-&gt;get_type());</a>
<a name="9285"><span class="lineNum">    9285 </span>            :                if (declaration != NULL)</a>
<a name="9286"><span class="lineNum">    9286 </span>            :                   {</a>
<a name="9287"><span class="lineNum">    9287 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="9288"><span class="lineNum">    9288 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Putting the name qualification for the type into the SgInitializedName = %p = %s \n&quot;,initializedName,initializedName-&gt;get_name().str());</a>
<a name="9289"><span class="lineNum">    9289 </span>            : #endif</a>
<a name="9290"><span class="lineNum">    9290 </span>            : </a>
<a name="9291"><span class="lineNum">    9291 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="9292"><span class="lineNum">    9292 </span>            : </a>
<a name="9293"><span class="lineNum">    9293 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="9294"><span class="lineNum">    9294 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;declaration = %p = %s \n&quot;,declaration,declaration-&gt;class_name().c_str());</a>
<a name="9295"><span class="lineNum">    9295 </span>            : #endif</a>
<a name="9296"><span class="lineNum">    9296 </span>            : </a>
<a name="9297"><span class="lineNum">    9297 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="9298"><span class="lineNum">    9298 </span>            : </a>
<a name="9299"><span class="lineNum">    9299 </span>            :                  // **************************************************</a>
<a name="9300"><span class="lineNum">    9300 </span>            :                  // DQ (8/4/2012): The type being used might not have to be qualified if it is associated with a SgClassDeclaration that has not been defined yet.</a>
<a name="9301"><span class="lineNum">    9301 </span>            :                  // **************************************************</a>
<a name="9302"><span class="lineNum">    9302 </span>            :                     bool skipGlobalNameQualification = skipNameQualificationIfNotProperlyDeclaredWhereDeclarationIsDefinable(declaration);</a>
<a name="9303"><span class="lineNum">    9303 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="9304"><span class="lineNum">    9304 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Test of Type used in SgVariableDeclaration: skipGlobalNameQualification = %s \n&quot;,skipGlobalNameQualification ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="9305"><span class="lineNum">    9305 </span>            : #endif</a>
<a name="9306"><span class="lineNum">    9306 </span>            :                  // setNameQualification(initializedName,declaration,amountOfNameQualificationRequiredForType,skipGlobalNameQualification);</a>
<a name="9307"><span class="lineNum">    9307 </span>            :                  // setNameQualificationOnType(initializedName,declaration,amountOfNameQualificationRequiredForType,skipGlobalNameQualification);</a>
<a name="9308"><span class="lineNum">    9308 </span>            :                     setNameQualificationOnName(initializedName,declaration,amountOfNameQualificationRequiredForName,skipGlobalNameQualification);</a>
<a name="9309"><span class="lineNum">    9309 </span>            :                   }</a>
<a name="9310"><span class="lineNum">    9310 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="9311"><span class="lineNum">    9311 </span>            : </a>
<a name="9312"><span class="lineNum">    9312 </span>            : #endif</a>
<a name="9313"><span class="lineNum">    9313 </span>            : </a>
<a name="9314"><span class="lineNum">    9314 </span>            : #if 0</a>
<a name="9315"><span class="lineNum">    9315 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="9316"><span class="lineNum">    9316 </span>            :                ROSE_ABORT();</a>
<a name="9317"><span class="lineNum">    9317 </span>            : #endif</a>
<a name="9318"><span class="lineNum">    9318 </span>            :              }</a>
<a name="9319"><span class="lineNum">    9319 </span>            : </a>
<a name="9320"><span class="lineNum">    9320 </span>            : #if DEBUG_INITIALIZED_NAME</a>
<a name="9321"><span class="lineNum">    9321 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;######################################################################## \n&quot;);</a>
<a name="9322"><span class="lineNum">    9322 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Case SgInitializedName: DONE: Processing the SgInitializedName IR's name \n&quot;);</a>
<a name="9323"><span class="lineNum">    9323 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;######################################################################## \n&quot;);</a>
<a name="9324"><span class="lineNum">    9324 </span>            : #endif</a>
<a name="9325"><span class="lineNum">    9325 </span>            :             // XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</a>
<a name="9326"><span class="lineNum">    9326 </span>            : </a>
<a name="9327"><span class="lineNum">    9327 </span>            : #if DEBUG_INITIALIZED_NAME &amp;&amp; 0</a>
<a name="9328"><span class="lineNum">    9328 </span>            :           printf(&quot;333333333333333333333333333333333333333333333333333333333333333333333333333 \n&quot;);</a>
<a name="9329"><span class="lineNum">    9329 </span>            :           printf(&quot;333333333333333333333333333333333333333333333333333333333333333333333333333 \n&quot;);</a>
<a name="9330"><span class="lineNum">    9330 </span>            :           printf(&quot;333333333333333333333333333333333333333333333333333333333333333333333333333 \n&quot;);</a>
<a name="9331"><span class="lineNum">    9331 </span>            :           printf(&quot;333333333333333333333333333333333333333333333333333333333333333333333333333 \n&quot;);</a>
<a name="9332"><span class="lineNum">    9332 </span>            :           printf(&quot;333333333333333333333333333333333333333333333333333333333333333333333333333 \n&quot;);</a>
<a name="9333"><span class="lineNum">    9333 </span>            : #endif</a>
<a name="9334"><span class="lineNum">    9334 </span>            : </a>
<a name="9335"><span class="lineNum">    9335 </span>            : #if 0</a>
<a name="9336"><span class="lineNum">    9336 </span>            :        // DQ (4/26/2019): debugging support.</a>
<a name="9337"><span class="lineNum">    9337 </span>            :           if (debugging == true)</a>
<a name="9338"><span class="lineNum">    9338 </span>            :              {</a>
<a name="9339"><span class="lineNum">    9339 </span>            :             // Looking for the SgTemplateInstantiationDirective.</a>
<a name="9340"><span class="lineNum">    9340 </span>            :                SgTemplateInstantiationDirectiveStatement* templateInstantiationDirectiveStatement = isSgTemplateInstantiationDirectiveStatement(initializedName-&gt;get_parent()-&gt;get_parent());</a>
<a name="9341"><span class="lineNum">    9341 </span>            :                if (templateInstantiationDirectiveStatement != NULL)</a>
<a name="9342"><span class="lineNum">    9342 </span>            :                   {</a>
<a name="9343"><span class="lineNum">    9343 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="9344"><span class="lineNum">    9344 </span>            :                     ROSE_ABORT();</a>
<a name="9345"><span class="lineNum">    9345 </span>            :                   }</a>
<a name="9346"><span class="lineNum">    9346 </span>            :               }</a>
<a name="9347"><span class="lineNum">    9347 </span>            : #endif</a>
<a name="9348"><span class="lineNum">    9348 </span>            : </a>
<a name="9349"><span class="lineNum">    9349 </span>            : </a>
<a name="9350"><span class="lineNum">    9350 </span>            : #if 1</a>
<a name="9351"><span class="lineNum">    9351 </span>            :        // DQ (4/28/2019): Trying to support the initializer here, so that we can support constructor</a>
<a name="9352"><span class="lineNum">    9352 </span>            :        // preinitialization lists, rather than through the SgConstructor initializer.</a>
<a name="9353"><span class="lineNum">    9353 </span>            : </a>
<a name="9354"><span class="lineNum">    9354 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || 0</a>
<a name="9355"><span class="lineNum">    9355 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;initializedName-&gt;get_preinitialization() = %d \n&quot;,initializedName-&gt;get_preinitialization());</a>
<a name="9356"><span class="lineNum">    9356 </span>            : #endif</a>
<a name="9357"><span class="lineNum">    9357 </span>            :        // DQ (12/8/2019): If this is a simple data member then we don't need anme qualification on its type (which does not appear in the source code).</a>
<a name="9358"><span class="lineNum">    9358 </span><span class="lineCov">    1462240 :           bool is_simple_data_member = false;</span></a>
<a name="9359"><span class="lineNum">    9359 </span><span class="lineCov">    1462240 :           if (initializedName-&gt;get_preinitialization() == SgInitializedName::e_data_member)</span></a>
<a name="9360"><span class="lineNum">    9360 </span>            :              {</a>
<a name="9361"><span class="lineNum">    9361 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || 0</a>
<a name="9362"><span class="lineNum">    9362 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Found a data member used in pre-initialization list \n&quot;);</a>
<a name="9363"><span class="lineNum">    9363 </span>            : #endif</a>
<a name="9364"><span class="lineNum">    9364 </span><span class="lineCov">       2114 :                is_simple_data_member = true;</span></a>
<a name="9365"><span class="lineNum">    9365 </span>            :              }</a>
<a name="9366"><span class="lineNum">    9366 </span>            : </a>
<a name="9367"><span class="lineNum">    9367 </span>            :        // DQ (4/26/2019): The initializer should be processed as an expression to be name qualified seperately.</a>
<a name="9368"><span class="lineNum">    9368 </span>            : #if DEBUG_INITIALIZED_NAME</a>
<a name="9369"><span class="lineNum">    9369 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;############################################# \n&quot;);</a>
<a name="9370"><span class="lineNum">    9370 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Case SgInitializedName: Check for initializer \n&quot;);</a>
<a name="9371"><span class="lineNum">    9371 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;############################################# \n&quot;);</a>
<a name="9372"><span class="lineNum">    9372 </span>            : #endif</a>
<a name="9373"><span class="lineNum">    9373 </span>            :             // DQ (12/17/2013): Added support for name qualification of preinitialization list elements (see test codes: test2013_285-288.C).</a>
<a name="9374"><span class="lineNum">    9374 </span>            :             // if (initializedName-&gt;get_initptr() != NULL)</a>
<a name="9375"><span class="lineNum">    9375 </span><span class="lineCov">    1462240 :                if (initializedName-&gt;get_initptr() != NULL &amp;&amp; is_simple_data_member == false)</span></a>
<a name="9376"><span class="lineNum">    9376 </span>            :                   {</a>
<a name="9377"><span class="lineNum">    9377 </span>            :                  // DQ (2/7/2019): I think this can't be a SgPointerMemberType, so the code specific to this case does not go here.</a>
<a name="9378"><span class="lineNum">    9378 </span>            :                  // ROSE_ASSERT(isSgPointerMemberType(initializedName-&gt;get_type()) == NULL);</a>
<a name="9379"><span class="lineNum">    9379 </span>            : #if 0</a>
<a name="9380"><span class="lineNum">    9380 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Case of SgInitializedName: Commented out assertion: testing test2019_122.C \n&quot;);</a>
<a name="9381"><span class="lineNum">    9381 </span>            : #endif</a>
<a name="9382"><span class="lineNum">    9382 </span>            : #if DEBUG_INITIALIZED_NAME</a>
<a name="9383"><span class="lineNum">    9383 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;############################################################################## \n&quot;);</a>
<a name="9384"><span class="lineNum">    9384 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Case SgInitializedName: Processing the SgInitializedName IR node's initializer \n&quot;);</a>
<a name="9385"><span class="lineNum">    9385 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;############################################################################## \n&quot;);</a>
<a name="9386"><span class="lineNum">    9386 </span>            : #endif</a>
<a name="9387"><span class="lineNum">    9387 </span>            :                  // DQ (4/28/2019): Added this variable declaration to support compiling this section that was previously commented out.</a>
<a name="9388"><span class="lineNum">    9388 </span><span class="lineCov">      12005 :                     SgStatement* associatedStatement = currentScope;</span></a>
<a name="9389"><span class="lineNum">    9389 </span>            : #if DEBUG_INITIALIZED_NAME</a>
<a name="9390"><span class="lineNum">    9390 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;initializedName = %p name = %s \n&quot;,initializedName,initializedName-&gt;get_name().str());</a>
<a name="9391"><span class="lineNum">    9391 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;currentScope = %p = %s \n&quot;,currentScope,currentScope-&gt;class_name().c_str());</a>
<a name="9392"><span class="lineNum">    9392 </span>            : #endif</a>
<a name="9393"><span class="lineNum">    9393 </span>            : #if 0</a>
<a name="9394"><span class="lineNum">    9394 </span>            :                     int amountOfNameQualificationRequiredForType = nameQualificationDepthForType(initializedName,currentScope,associatedStatement);</a>
<a name="9395"><span class="lineNum">    9395 </span>            : #if 0</a>
<a name="9396"><span class="lineNum">    9396 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;amountOfNameQualificationRequiredForType = %d \n&quot;,amountOfNameQualificationRequiredForType);</a>
<a name="9397"><span class="lineNum">    9397 </span>            : #endif</a>
<a name="9398"><span class="lineNum">    9398 </span>            : #endif</a>
<a name="9399"><span class="lineNum">    9399 </span><span class="lineCov">      12005 :                     SgConstructorInitializer* constructorInitializer = isSgConstructorInitializer(initializedName-&gt;get_initptr());</span></a>
<a name="9400"><span class="lineNum">    9400 </span>            :                  // ASSERT_not_null(constructorInitializer);</a>
<a name="9401"><span class="lineNum">    9401 </span><span class="lineCov">      12005 :                     if (constructorInitializer != NULL)</span></a>
<a name="9402"><span class="lineNum">    9402 </span>            :                        {</a>
<a name="9403"><span class="lineNum">    9403 </span>            : #if DEBUG_INITIALIZED_NAME</a>
<a name="9404"><span class="lineNum">    9404 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;######################################################## \n&quot;);</a>
<a name="9405"><span class="lineNum">    9405 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;Case SgInitializedName: (constructorInitializer != NULL) \n&quot;);</a>
<a name="9406"><span class="lineNum">    9406 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;######################################################## \n&quot;);</a>
<a name="9407"><span class="lineNum">    9407 </span>            : #endif</a>
<a name="9408"><span class="lineNum">    9408 </span>            :                       // DQ (12/8/2019): Note that &quot;type&quot; is a variable declared above and we don't what to hide that variable.</a>
<a name="9409"><span class="lineNum">    9409 </span>            :                       // SgType* type = initializedName-&gt;get_type();</a>
<a name="9410"><span class="lineNum">    9410 </span>            :                       // SgType* type = constructorInitializer-&gt;get_type();</a>
<a name="9411"><span class="lineNum">    9411 </span><span class="lineCov">       1389 :                          SgType* constructorInitializer_type = constructorInitializer-&gt;get_type();</span></a>
<a name="9412"><span class="lineNum">    9412 </span><span class="lineCov">       1389 :                          ASSERT_not_null(constructorInitializer_type);</span></a>
<a name="9413"><span class="lineNum">    9413 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="9414"><span class="lineNum">    9414 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;Test for special case of SgInitializedName used in SgCtorInitializerList: type = %p = %s \n&quot;,type,type-&gt;class_name().c_str());</a>
<a name="9415"><span class="lineNum">    9415 </span>            : #endif</a>
<a name="9416"><span class="lineNum">    9416 </span><span class="lineCov">       1389 :                          SgFunctionType*        constructorInitializer_functionType       = isSgFunctionType(constructorInitializer_type);</span></a>
<a name="9417"><span class="lineNum">    9417 </span><span class="lineCov">       1389 :                          SgMemberFunctionType*  constructorInitializer_memberFunctionType = isSgMemberFunctionType(constructorInitializer_type);</span></a>
<a name="9418"><span class="lineNum">    9418 </span><span class="lineCov">       1389 :                          SgCtorInitializerList* ctor                                      = isSgCtorInitializerList(currentStatement);</span></a>
<a name="9419"><span class="lineNum">    9419 </span>            : </a>
<a name="9420"><span class="lineNum">    9420 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="9421"><span class="lineNum">    9421 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;Test for special case of SgInitializedName used in SgCtorInitializerList: ctor = %p functionType = %p memberFunctionType = %p \n&quot;,ctor,constructorInitializer_functionType,constructorInitializer_memberFunctionType);</a>
<a name="9422"><span class="lineNum">    9422 </span>            : #endif</a>
<a name="9423"><span class="lineNum">    9423 </span>            :                       // if (ctor != NULL)</a>
<a name="9424"><span class="lineNum">    9424 </span><span class="lineCov">       1389 :                          if (ctor != NULL &amp;&amp; (constructorInitializer_functionType != NULL || constructorInitializer_memberFunctionType != NULL))</span></a>
<a name="9425"><span class="lineNum">    9425 </span>            :                             {</a>
<a name="9426"><span class="lineNum">    9426 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="9427"><span class="lineNum">    9427 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;Calling setNameQualificationOnName() (operating DIRECTLY on the SgInitializedName) \n&quot;);</a>
<a name="9428"><span class="lineNum">    9428 </span>            : #endif</a>
<a name="9429"><span class="lineNum">    9429 </span>            : #if DEBUG_INITIALIZED_NAME</a>
<a name="9430"><span class="lineNum">    9430 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;############################################################################################## \n&quot;);</a>
<a name="9431"><span class="lineNum">    9431 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;Case SgInitializedName: (ctor != NULL &amp;&amp; (functionType != NULL || memberFunctionType != NULL)) \n&quot;);</a>
<a name="9432"><span class="lineNum">    9432 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;############################################################################################## \n&quot;);</a>
<a name="9433"><span class="lineNum">    9433 </span>            : #endif</a>
<a name="9434"><span class="lineNum">    9434 </span>            : </a>
<a name="9435"><span class="lineNum">    9435 </span>            :                            // DQ (2/2/2019): NOTE: constructorInitializer-&gt;get_declaration() == NULL when there is not associated</a>
<a name="9436"><span class="lineNum">    9436 </span>            :                            // constructor for the class (e.g. the case where the default constructor (compiler generated) is used).</a>
<a name="9437"><span class="lineNum">    9437 </span>            :                            // DQ (1/13/2014): This only get's qualification when the name being used matches the class name,</a>
<a name="9438"><span class="lineNum">    9438 </span>            :                            // else this is a data member and should not be qualified.  See test2014_01.C.</a>
<a name="9439"><span class="lineNum">    9439 </span>            :                            // SgName functionName = (functionType != NULL) ? functionType-&gt;get_name() : memberFunctionType-&gt;get_name();</a>
<a name="9440"><span class="lineNum">    9440 </span><span class="lineCov">        297 :                               SgFunctionDeclaration* functionDeclaration = isSgFunctionDeclaration(constructorInitializer-&gt;get_declaration());</span></a>
<a name="9441"><span class="lineNum">    9441 </span>            : #if 0</a>
<a name="9442"><span class="lineNum">    9442 </span>            :                            // int amountOfNameQualificationRequiredForType = nameQualificationDepthForType(initializedName,currentScope,associatedStatement);</a>
<a name="9443"><span class="lineNum">    9443 </span>            :                               int amountOfNameQualificationRequiredForType = nameQualificationDepth(functionDeclaration,currentScope,associatedStatement);</a>
<a name="9444"><span class="lineNum">    9444 </span>            : #if 1</a>
<a name="9445"><span class="lineNum">    9445 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;amountOfNameQualificationRequiredForType = %d \n&quot;,amountOfNameQualificationRequiredForType);</a>
<a name="9446"><span class="lineNum">    9446 </span>            : #endif</a>
<a name="9447"><span class="lineNum">    9447 </span>            : #endif</a>
<a name="9448"><span class="lineNum">    9448 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="9449"><span class="lineNum">    9449 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;Test for special case of SgInitializedName used in SgCtorInitializerList: functionDeclaration = %p \n&quot;,functionDeclaration);</a>
<a name="9450"><span class="lineNum">    9450 </span>            : #endif</a>
<a name="9451"><span class="lineNum">    9451 </span>            :                            // DQ (2/2/2019): This is non-null for all but EDG 5.0, so this is debugging support.</a>
<a name="9452"><span class="lineNum">    9452 </span><span class="lineCov">        297 :                               if (functionDeclaration == NULL)</span></a>
<a name="9453"><span class="lineNum">    9453 </span>            :                                  {</a>
<a name="9454"><span class="lineNum">    9454 </span>            : #if DEBUG_INITIALIZED_NAME</a>
<a name="9455"><span class="lineNum">    9455 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;############################################################################################################################### \n&quot;);</a>
<a name="9456"><span class="lineNum">    9456 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;Case SgInitializedName: SKIPPING CALL TO setNameQualificationOnName(): functionDeclaration == NULL \n&quot;);</a>
<a name="9457"><span class="lineNum">    9457 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;############################################################################################################################### \n&quot;);</a>
<a name="9458"><span class="lineNum">    9458 </span>            : #endif</a>
<a name="9459"><span class="lineNum">    9459 </span>            : #if 0</a>
<a name="9460"><span class="lineNum">    9460 </span>            :                                 // DQ (2/2/2019): Adding debugging code to better understand this case demonstrated for EDG 5.0 on Cxx11_tests/test2019_55.C.</a>
<a name="9461"><span class="lineNum">    9461 </span>            :                                    SgExpression* initialzerExpression = initializedName-&gt;get_initptr();</a>
<a name="9462"><span class="lineNum">    9462 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;initialzerExpression               = %p = %s \n&quot;,initialzerExpression,initialzerExpression-&gt;class_name().c_str());</a>
<a name="9463"><span class="lineNum">    9463 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;constructorInitializer             = %p = %s \n&quot;,constructorInitializer,constructorInitializer-&gt;class_name().c_str());</a>
<a name="9464"><span class="lineNum">    9464 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;constructorInitializer-&gt;get_type() = %p = %s \n&quot;,constructorInitializer-&gt;get_type(),constructorInitializer-&gt;get_type()-&gt;class_name().c_str());</a>
<a name="9465"><span class="lineNum">    9465 </span>            : </a>
<a name="9466"><span class="lineNum">    9466 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;constructorInitializer-&gt;get_declaration() = %p \n&quot;,constructorInitializer-&gt;get_declaration());</a>
<a name="9467"><span class="lineNum">    9467 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;constructorInitializer-&gt;get_args()        = %p \n&quot;,constructorInitializer-&gt;get_args());</a>
<a name="9468"><span class="lineNum">    9468 </span>            :                                    SgExprListExp* expressionList = constructorInitializer-&gt;get_args();</a>
<a name="9469"><span class="lineNum">    9469 </span>            :                                    if (expressionList != NULL)</a>
<a name="9470"><span class="lineNum">    9470 </span>            :                                       {</a>
<a name="9471"><span class="lineNum">    9471 </span>            :                                         mfprintf(mlog [ WARN ] ) (&quot;expressionList-&gt;get_expressions().size() = %zu \n&quot;,expressionList-&gt;get_expressions().size());</a>
<a name="9472"><span class="lineNum">    9472 </span>            :                                         SgExpressionPtrList::iterator i = expressionList-&gt;get_expressions().begin();</a>
<a name="9473"><span class="lineNum">    9473 </span>            :                                         while (i != expressionList-&gt;get_expressions().end())</a>
<a name="9474"><span class="lineNum">    9474 </span>            :                                            {</a>
<a name="9475"><span class="lineNum">    9475 </span>            :                                              mfprintf(mlog [ WARN ] ) (&quot;  --- *i = %p = %s \n&quot;,*i,(*i)-&gt;class_name().c_str());</a>
<a name="9476"><span class="lineNum">    9476 </span>            :                                              i++;</a>
<a name="9477"><span class="lineNum">    9477 </span>            :                                            }</a>
<a name="9478"><span class="lineNum">    9478 </span>            :                                       }</a>
<a name="9479"><span class="lineNum">    9479 </span>            : </a>
<a name="9480"><span class="lineNum">    9480 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;constructorInitializer_functionType       = %p \n&quot;,constructorInitializer_functionType);</a>
<a name="9481"><span class="lineNum">    9481 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;constructorInitializer_memberFunctionType = %p \n&quot;,constructorInitializer_memberFunctionType);</a>
<a name="9482"><span class="lineNum">    9482 </span>            : </a>
<a name="9483"><span class="lineNum">    9483 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;initializedName-&gt;get_name() = %s \n&quot;,initializedName-&gt;get_name().str());</a>
<a name="9484"><span class="lineNum">    9484 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;initializedName-&gt;get_name() = %s \n&quot;,initializedName-&gt;get_name().str());</a>
<a name="9485"><span class="lineNum">    9485 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;functionDeclaration == NULL: (EDG 5.0 issue): constructorInitializer-&gt;get_declaration() = %p \n&quot;,constructorInitializer-&gt;get_declaration());</a>
<a name="9486"><span class="lineNum">    9486 </span>            :                                    if (constructorInitializer-&gt;get_declaration() != NULL)</a>
<a name="9487"><span class="lineNum">    9487 </span>            :                                       {</a>
<a name="9488"><span class="lineNum">    9488 </span>            :                                         mfprintf(mlog [ WARN ] ) (&quot;functionDeclaration == NULL: (EDG 5.0 issue): constructorInitializer-&gt;get_declaration() = %p = %s \n&quot;,</a>
<a name="9489"><span class="lineNum">    9489 </span>            :                                              constructorInitializer-&gt;get_declaration(),constructorInitializer-&gt;get_declaration()-&gt;class_name().c_str());</a>
<a name="9490"><span class="lineNum">    9490 </span>            :                                       }</a>
<a name="9491"><span class="lineNum">    9491 </span>            :                                    initializedName-&gt;get_file_info()-&gt;display(&quot;initializedName&quot;);</a>
<a name="9492"><span class="lineNum">    9492 </span>            : #endif</a>
<a name="9493"><span class="lineNum">    9493 </span>            :                                  }</a>
<a name="9494"><span class="lineNum">    9494 </span>            :                                 else</a>
<a name="9495"><span class="lineNum">    9495 </span>            :                                  {</a>
<a name="9496"><span class="lineNum">    9496 </span>            :                                 // DQ (2/2/2019): Original code. Works for all but EDG 5.0.</a>
<a name="9497"><span class="lineNum">    9497 </span><span class="lineCov">        594 :                                    SgName functionName = functionDeclaration-&gt;get_name();</span></a>
<a name="9498"><span class="lineNum">    9498 </span>            : </a>
<a name="9499"><span class="lineNum">    9499 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || DEBUG_INITIALIZED_NAME</a>
<a name="9500"><span class="lineNum">    9500 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;Test for special case of SgInitializedName used in SgCtorInitializerList: functionName = %s \n&quot;,functionName.str());</a>
<a name="9501"><span class="lineNum">    9501 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;Test for special case of SgInitializedName used in SgCtorInitializerList: initializedName-&gt;get_name() = %s \n&quot;,initializedName-&gt;get_name().str());</a>
<a name="9502"><span class="lineNum">    9502 </span>            : #endif</a>
<a name="9503"><span class="lineNum">    9503 </span>            : #if DEBUG_INITIALIZED_NAME</a>
<a name="9504"><span class="lineNum">    9504 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;@@@@@ currentScope = %p = %s \n&quot;,currentScope,currentScope-&gt;class_name().c_str());</a>
<a name="9505"><span class="lineNum">    9505 </span>            : #endif</a>
<a name="9506"><span class="lineNum">    9506 </span>            : </a>
<a name="9507"><span class="lineNum">    9507 </span>            : #if DEBUG_INITIALIZED_NAME</a>
<a name="9508"><span class="lineNum">    9508 </span>            :                                    printf(&quot;444444444444444444444444444444444444444444444444444444444444444444444444444 \n&quot;);</a>
<a name="9509"><span class="lineNum">    9509 </span>            :                                    printf(&quot;444444444444444444444444444444444444444444444444444444444444444444444444444 \n&quot;);</a>
<a name="9510"><span class="lineNum">    9510 </span>            :                                    printf(&quot;444444444444444444444444444444444444444444444444444444444444444444444444444 \n&quot;);</a>
<a name="9511"><span class="lineNum">    9511 </span>            :                                    printf(&quot;444444444444444444444444444444444444444444444444444444444444444444444444444 \n&quot;);</a>
<a name="9512"><span class="lineNum">    9512 </span>            :                                    printf(&quot;444444444444444444444444444444444444444444444444444444444444444444444444444 \n&quot;);</a>
<a name="9513"><span class="lineNum">    9513 </span>            : #endif</a>
<a name="9514"><span class="lineNum">    9514 </span>            : #if DEBUG_INITIALIZED_NAME</a>
<a name="9515"><span class="lineNum">    9515 </span>            :                                    printf (&quot;Case of SgInitializedName: functionDeclaration = %p = %s name = %s \n&quot;,</a>
<a name="9516"><span class="lineNum">    9516 </span>            :                                         functionDeclaration,functionDeclaration-&gt;class_name().c_str(),SageInterface::get_name(functionDeclaration).c_str());</a>
<a name="9517"><span class="lineNum">    9517 </span>            :                                    printf (&quot;Case of SgInitializedName: currentScope = %p = %s name = %s \n&quot;,currentScope,</a>
<a name="9518"><span class="lineNum">    9518 </span>            :                                         currentScope-&gt;class_name().c_str(),SageInterface::get_name(currentScope).c_str());</a>
<a name="9519"><span class="lineNum">    9519 </span>            :                                    printf (&quot;Case of SgInitializedName: associatedStatement = %p = %s name = %s \n&quot;,associatedStatement,</a>
<a name="9520"><span class="lineNum">    9520 </span>            :                                         associatedStatement-&gt;class_name().c_str(),SageInterface::get_name(associatedStatement).c_str());</a>
<a name="9521"><span class="lineNum">    9521 </span>            : #endif</a>
<a name="9522"><span class="lineNum">    9522 </span>            : #if DEBUG_INITIALIZED_NAME</a>
<a name="9523"><span class="lineNum">    9523 </span>            :                                    printf (&quot;6666666666666666666666666666666666666666666666666666666666666666666666666 \n&quot;);</a>
<a name="9524"><span class="lineNum">    9524 </span>            :                                    printf (&quot;6666666666666666666666666666666666666666666666666666666666666666666666666 \n&quot;);</a>
<a name="9525"><span class="lineNum">    9525 </span>            :                                    printf (&quot;Handling specific case of SgInitializedName from SgCtorInitializationList \n&quot;);</a>
<a name="9526"><span class="lineNum">    9526 </span>            :                                    printf (&quot;6666666666666666666666666666666666666666666666666666666666666666666666666 \n&quot;);</a>
<a name="9527"><span class="lineNum">    9527 </span>            :                                    printf (&quot;6666666666666666666666666666666666666666666666666666666666666666666666666 \n&quot;);</a>
<a name="9528"><span class="lineNum">    9528 </span>            : #endif</a>
<a name="9529"><span class="lineNum">    9529 </span>            : #if 1</a>
<a name="9530"><span class="lineNum">    9530 </span>            :                                 // DQ (9/3/2020): This is I think the only meaningful change to address Cxx11_tests/test2020_89.C.</a>
<a name="9531"><span class="lineNum">    9531 </span>            :                                 // DQ (9/2/2020): If this is a SgInitializedName from a SgCtorInitializationList, then we want to search for the</a>
<a name="9532"><span class="lineNum">    9532 </span>            :                                 // class associated with the member function in the parent of the scope of the class definition.</a>
<a name="9533"><span class="lineNum">    9533 </span>            :                                 // However, this code might be too specific to this narrow case (something to look at in the morning).</a>
<a name="9534"><span class="lineNum">    9534 </span><span class="lineCov">        297 :                                    SgClassDefinition* classDefinition = isSgClassDefinition(functionDeclaration-&gt;get_scope());</span></a>
<a name="9535"><span class="lineNum">    9535 </span><span class="lineCov">        297 :                                    ROSE_ASSERT(classDefinition != NULL);</span></a>
<a name="9536"><span class="lineNum">    9536 </span><span class="lineCov">        297 :                                    SgDeclarationStatement* associatedDeclaration = isSgClassDeclaration(classDefinition-&gt;get_declaration());</span></a>
<a name="9537"><span class="lineNum">    9537 </span><span class="lineCov">        297 :                                    ROSE_ASSERT(associatedDeclaration != NULL);</span></a>
<a name="9538"><span class="lineNum">    9538 </span>            : </a>
<a name="9539"><span class="lineNum">    9539 </span>            :                                 // DQ (9/2/2020): use the scope of the current scope.</a>
<a name="9540"><span class="lineNum">    9540 </span><span class="lineCov">        297 :                                    currentScope = currentScope-&gt;get_scope();</span></a>
<a name="9541"><span class="lineNum">    9541 </span>            : #if 0</a>
<a name="9542"><span class="lineNum">    9542 </span>            :                                    printf (&quot;Case of SgInitializedName: 9/3/2020 change: recomputed currentScope = %p = %s name = %s \n&quot;,currentScope,</a>
<a name="9543"><span class="lineNum">    9543 </span>            :                                         currentScope-&gt;class_name().c_str(),SageInterface::get_name(currentScope).c_str());</a>
<a name="9544"><span class="lineNum">    9544 </span>            : #endif</a>
<a name="9545"><span class="lineNum">    9545 </span>            :                                 // DQ (9/2/2020): Use alternative declarations for initialized names from ctor initialization list support.</a>
<a name="9546"><span class="lineNum">    9546 </span>            :                                 // int amountOfNameQualificationRequiredForType = nameQualificationDepthForType(initializedName,currentScope,associatedStatement);</a>
<a name="9547"><span class="lineNum">    9547 </span>            :                                 // int amountOfNameQualificationRequiredForType = nameQualificationDepth(functionDeclaration,currentScope,associatedStatement);</a>
<a name="9548"><span class="lineNum">    9548 </span><span class="lineCov">        297 :                                    int amountOfNameQualificationRequiredForType = nameQualificationDepth(associatedDeclaration,currentScope,associatedStatement);</span></a>
<a name="9549"><span class="lineNum">    9549 </span>            : #else</a>
<a name="9550"><span class="lineNum">    9550 </span>            :                                    int amountOfNameQualificationRequiredForType = nameQualificationDepth(functionDeclaration,currentScope,associatedStatement);</a>
<a name="9551"><span class="lineNum">    9551 </span>            : #endif</a>
<a name="9552"><span class="lineNum">    9552 </span>            : #if DEBUG_INITIALIZED_NAME</a>
<a name="9553"><span class="lineNum">    9553 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;amountOfNameQualificationRequiredForType = %d \n&quot;,amountOfNameQualificationRequiredForType);</a>
<a name="9554"><span class="lineNum">    9554 </span>            : #endif</a>
<a name="9555"><span class="lineNum">    9555 </span><span class="lineCov">        297 :                                    if (initializedName-&gt;get_name() == functionName)</span></a>
<a name="9556"><span class="lineNum">    9556 </span>            :                                       {</a>
<a name="9557"><span class="lineNum">    9557 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || DEBUG_INITIALIZED_NAME</a>
<a name="9558"><span class="lineNum">    9558 </span>            :                                         mfprintf(mlog [ WARN ] ) (&quot;amountOfNameQualificationRequiredForType = %d \n&quot;,amountOfNameQualificationRequiredForType);</a>
<a name="9559"><span class="lineNum">    9559 </span>            : #endif</a>
<a name="9560"><span class="lineNum">    9560 </span>            : #if DEBUG_INITIALIZED_NAME</a>
<a name="9561"><span class="lineNum">    9561 </span>            :                                         mfprintf(mlog [ WARN ] ) (&quot;############################################################################################################################### \n&quot;);</a>
<a name="9562"><span class="lineNum">    9562 </span>            :                                         mfprintf(mlog [ WARN ] ) (&quot;Case SgInitializedName: Processing the SgInitializedName IR node's type ((initializedName-&gt;get_name() == functionName) == true) \n&quot;);</a>
<a name="9563"><span class="lineNum">    9563 </span>            :                                         mfprintf(mlog [ WARN ] ) (&quot;############################################################################################################################### \n&quot;);</a>
<a name="9564"><span class="lineNum">    9564 </span>            : #endif</a>
<a name="9565"><span class="lineNum">    9565 </span>            :                                      // DQ (10/18/2020): Moved declaration to where it is being used.</a>
<a name="9566"><span class="lineNum">    9566 </span><span class="lineCov">        187 :                                         SgDeclarationStatement* declaration = getDeclarationAssociatedWithType(initializedName-&gt;get_type());</span></a>
<a name="9567"><span class="lineNum">    9567 </span><span class="lineCov">        187 :                                         ROSE_ASSERT(declaration != NULL);</span></a>
<a name="9568"><span class="lineNum">    9568 </span>            : </a>
<a name="9569"><span class="lineNum">    9569 </span>            :                                      // DQ (4/28/2019): Added variable to allow this section to be compiled.</a>
<a name="9570"><span class="lineNum">    9570 </span><span class="lineCov">        187 :                                         bool skipGlobalNameQualification = false;</span></a>
<a name="9571"><span class="lineNum">    9571 </span><span class="lineCov">        187 :                                         setNameQualificationOnName(initializedName,declaration,amountOfNameQualificationRequiredForType,skipGlobalNameQualification);</span></a>
<a name="9572"><span class="lineNum">    9572 </span>            : </a>
<a name="9573"><span class="lineNum">    9573 </span>            :                                      // DQ (3/31/2019): Uncomment this to trigger review because I now think we should be calling setNameQualification()</a>
<a name="9574"><span class="lineNum">    9574 </span>            :                                      // instead of setNameQualificationOnName().  Because setNameQualificationOnName() should use the new name qualification</a>
<a name="9575"><span class="lineNum">    9575 </span>            :                                      // fields for the SgInitializedName instead of the fields for the SgInitializedName's type.</a>
<a name="9576"><span class="lineNum">    9576 </span>            : #if 0</a>
<a name="9577"><span class="lineNum">    9577 </span>            :                                         mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="9578"><span class="lineNum">    9578 </span>            :                                         ROSE_ABORT();</a>
<a name="9579"><span class="lineNum">    9579 </span>            : #endif</a>
<a name="9580"><span class="lineNum">    9580 </span>            :                                       }</a>
<a name="9581"><span class="lineNum">    9581 </span>            :                                      else</a>
<a name="9582"><span class="lineNum">    9582 </span>            :                                       {</a>
<a name="9583"><span class="lineNum">    9583 </span>            : #if DEBUG_INITIALIZED_NAME</a>
<a name="9584"><span class="lineNum">    9584 </span>            :                                         mfprintf(mlog [ WARN ] ) (&quot;############################################################################################################################### \n&quot;);</a>
<a name="9585"><span class="lineNum">    9585 </span>            :                                         mfprintf(mlog [ WARN ] ) (&quot;Case SgInitializedName: SKIPPING CALL TO setNameQualificationOnName() \n&quot;);</a>
<a name="9586"><span class="lineNum">    9586 </span>            :                                         mfprintf(mlog [ WARN ] ) (&quot;############################################################################################################################### \n&quot;);</a>
<a name="9587"><span class="lineNum">    9587 </span>            : #endif</a>
<a name="9588"><span class="lineNum">    9588 </span>            :                                       }</a>
<a name="9589"><span class="lineNum">    9589 </span>            : #if DEBUG_INITIALIZED_NAME</a>
<a name="9590"><span class="lineNum">    9590 </span>            :                                    printf(&quot;555555555555555555555555555555555555555555555555555555555555555555555555555 \n&quot;);</a>
<a name="9591"><span class="lineNum">    9591 </span>            :                                    printf(&quot;555555555555555555555555555555555555555555555555555555555555555555555555555 \n&quot;);</a>
<a name="9592"><span class="lineNum">    9592 </span>            :                                    printf(&quot;555555555555555555555555555555555555555555555555555555555555555555555555555 \n&quot;);</a>
<a name="9593"><span class="lineNum">    9593 </span>            :                                    printf(&quot;555555555555555555555555555555555555555555555555555555555555555555555555555 \n&quot;);</a>
<a name="9594"><span class="lineNum">    9594 </span>            :                                    printf(&quot;555555555555555555555555555555555555555555555555555555555555555555555555555 \n&quot;);</a>
<a name="9595"><span class="lineNum">    9595 </span>            : #endif</a>
<a name="9596"><span class="lineNum">    9596 </span>            :                                  }</a>
<a name="9597"><span class="lineNum">    9597 </span>            : #if 0</a>
<a name="9598"><span class="lineNum">    9598 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="9599"><span class="lineNum">    9599 </span>            :                               ROSE_ABORT();</a>
<a name="9600"><span class="lineNum">    9600 </span>            : #endif</a>
<a name="9601"><span class="lineNum">    9601 </span>            :                             }</a>
<a name="9602"><span class="lineNum">    9602 </span>            :                            else</a>
<a name="9603"><span class="lineNum">    9603 </span>            :                             {</a>
<a name="9604"><span class="lineNum">    9604 </span>            : #if 0</a>
<a name="9605"><span class="lineNum">    9605 </span>            :                            // DQ (4/28/2019): Ignore case of implementing the support for name qualification for this case here (it is implemented elsewhere).</a>
<a name="9606"><span class="lineNum">    9606 </span>            :                            // Additionally, this is likely not the correct implementation anyway.</a>
<a name="9607"><span class="lineNum">    9607 </span>            : </a>
<a name="9608"><span class="lineNum">    9608 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="9609"><span class="lineNum">    9609 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;Calling setNameQualification() (operating on the TYPE of the SgInitializedName) \n&quot;);</a>
<a name="9610"><span class="lineNum">    9610 </span>            : #endif</a>
<a name="9611"><span class="lineNum">    9611 </span>            : #if DEBUG_INITIALIZED_NAME || 0</a>
<a name="9612"><span class="lineNum">    9612 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;######################################################################################################################################################### \n&quot;);</a>
<a name="9613"><span class="lineNum">    9613 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;Case SgInitializedName: Processing the SgInitializedName IR node's type ((ctor != NULL &amp;&amp; (functionType != NULL || memberFunctionType != NULL)) == false) \n&quot;);</a>
<a name="9614"><span class="lineNum">    9614 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;######################################################################################################################################################### \n&quot;);</a>
<a name="9615"><span class="lineNum">    9615 </span>            : #endif</a>
<a name="9616"><span class="lineNum">    9616 </span>            : #if 1</a>
<a name="9617"><span class="lineNum">    9617 </span>            :                               int amountOfNameQualificationRequiredForType = nameQualificationDepthForType(initializedName,currentScope,associatedStatement);</a>
<a name="9618"><span class="lineNum">    9618 </span>            : #if DEBUG_INITIALIZED_NAME || 0</a>
<a name="9619"><span class="lineNum">    9619 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;amountOfNameQualificationRequiredForType = %d \n&quot;,amountOfNameQualificationRequiredForType);</a>
<a name="9620"><span class="lineNum">    9620 </span>            : #endif</a>
<a name="9621"><span class="lineNum">    9621 </span>            : #endif</a>
<a name="9622"><span class="lineNum">    9622 </span>            :                            // DQ (4/28/2019): Added variable to allow this section to be compiled.</a>
<a name="9623"><span class="lineNum">    9623 </span>            :                               bool skipGlobalNameQualification = false;</a>
<a name="9624"><span class="lineNum">    9624 </span>            : </a>
<a name="9625"><span class="lineNum">    9625 </span>            :                            // DQ (4/9/2019): This is name qualification that is attached to the name.</a>
<a name="9626"><span class="lineNum">    9626 </span>            :                            // setNameQualification(initializedName,declaration,amountOfNameQualificationRequiredForType,skipGlobalNameQualification);</a>
<a name="9627"><span class="lineNum">    9627 </span>            :                               setNameQualificationOnType(initializedName,declaration,amountOfNameQualificationRequiredForType,skipGlobalNameQualification);</a>
<a name="9628"><span class="lineNum">    9628 </span>            :                            // setNameQualificationOnName(initializedName,declaration,amountOfNameQualificationRequiredForType,skipGlobalNameQualification);</a>
<a name="9629"><span class="lineNum">    9629 </span>            : #endif</a>
<a name="9630"><span class="lineNum">    9630 </span>            :                             }</a>
<a name="9631"><span class="lineNum">    9631 </span>            :                        }</a>
<a name="9632"><span class="lineNum">    9632 </span>            :                       else</a>
<a name="9633"><span class="lineNum">    9633 </span>            :                        {</a>
<a name="9634"><span class="lineNum">    9634 </span>            : #if 0</a>
<a name="9635"><span class="lineNum">    9635 </span>            :                       // DQ (4/28/2019): Ignore case of implementing the support for name qualification for this case here (it is implemented elsewhere).</a>
<a name="9636"><span class="lineNum">    9636 </span>            :                       // Additionally, this is likely not the correct implementation anyway.</a>
<a name="9637"><span class="lineNum">    9637 </span>            : </a>
<a name="9638"><span class="lineNum">    9638 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="9639"><span class="lineNum">    9639 </span>            : </a>
<a name="9640"><span class="lineNum">    9640 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="9641"><span class="lineNum">    9641 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;Calling setNameQualification(): constructorInitializer == NULL: (operating on the TYPE of the SgInitializedName) \n&quot;);</a>
<a name="9642"><span class="lineNum">    9642 </span>            : #endif</a>
<a name="9643"><span class="lineNum">    9643 </span>            : #if DEBUG_INITIALIZED_NAME</a>
<a name="9644"><span class="lineNum">    9644 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;######################################################################################################## \n&quot;);</a>
<a name="9645"><span class="lineNum">    9645 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;Case SgInitializedName: Processing the SgInitializedName IR node's type (constructorInitializer == NULL) \n&quot;);</a>
<a name="9646"><span class="lineNum">    9646 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;######################################################################################################## \n&quot;);</a>
<a name="9647"><span class="lineNum">    9647 </span>            : #endif</a>
<a name="9648"><span class="lineNum">    9648 </span>            : #if 1</a>
<a name="9649"><span class="lineNum">    9649 </span>            :                          int amountOfNameQualificationRequiredForType = nameQualificationDepthForType(initializedName,currentScope,associatedStatement);</a>
<a name="9650"><span class="lineNum">    9650 </span>            : #if DEBUG_INITIALIZED_NAME</a>
<a name="9651"><span class="lineNum">    9651 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;amountOfNameQualificationRequiredForType = %d \n&quot;,amountOfNameQualificationRequiredForType);</a>
<a name="9652"><span class="lineNum">    9652 </span>            : #endif</a>
<a name="9653"><span class="lineNum">    9653 </span>            : #endif</a>
<a name="9654"><span class="lineNum">    9654 </span>            :                       // DQ (4/28/2019): Added variable to allow this section to be compiled.</a>
<a name="9655"><span class="lineNum">    9655 </span>            :                          bool skipGlobalNameQualification = false;</a>
<a name="9656"><span class="lineNum">    9656 </span>            : </a>
<a name="9657"><span class="lineNum">    9657 </span>            :                       // DQ (4/9/2019): This is name qualification that is attached to the name.</a>
<a name="9658"><span class="lineNum">    9658 </span>            :                       // setNameQualification(initializedName,declaration,amountOfNameQualificationRequiredForType,skipGlobalNameQualification);</a>
<a name="9659"><span class="lineNum">    9659 </span>            :                          setNameQualificationOnType(initializedName,declaration,amountOfNameQualificationRequiredForType,skipGlobalNameQualification);</a>
<a name="9660"><span class="lineNum">    9660 </span>            :                       // setNameQualificationOnName(initializedName,declaration,amountOfNameQualificationRequiredForType,skipGlobalNameQualification);</a>
<a name="9661"><span class="lineNum">    9661 </span>            : </a>
<a name="9662"><span class="lineNum">    9662 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="9663"><span class="lineNum">    9663 </span>            : </a>
<a name="9664"><span class="lineNum">    9664 </span>            : #endif</a>
<a name="9665"><span class="lineNum">    9665 </span>            :                        }</a>
<a name="9666"><span class="lineNum">    9666 </span>            :                   }</a>
<a name="9667"><span class="lineNum">    9667 </span>            : </a>
<a name="9668"><span class="lineNum">    9668 </span>            : #if 0</a>
<a name="9669"><span class="lineNum">    9669 </span>            :             // DQ (4/28/2019): This is already addressed by the code above to handle the SgInitializedName's type.</a>
<a name="9670"><span class="lineNum">    9670 </span>            : </a>
<a name="9671"><span class="lineNum">    9671 </span>            :                  else</a>
<a name="9672"><span class="lineNum">    9672 </span>            :                   {</a>
<a name="9673"><span class="lineNum">    9673 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="9674"><span class="lineNum">    9674 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Calling setNameQualification(): initializedName-&gt;get_initptr() == NULL: (operating on the TYPE of the SgInitializedName) \n&quot;);</a>
<a name="9675"><span class="lineNum">    9675 </span>            : #endif</a>
<a name="9676"><span class="lineNum">    9676 </span>            : #if 0</a>
<a name="9677"><span class="lineNum">    9677 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;############################################################################################# \n&quot;);</a>
<a name="9678"><span class="lineNum">    9678 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Case SgInitializedName: Processing the SgInitializedName IR node's type (initializer == NULL) \n&quot;);</a>
<a name="9679"><span class="lineNum">    9679 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;############################################################################################# \n&quot;);</a>
<a name="9680"><span class="lineNum">    9680 </span>            : #endif</a>
<a name="9681"><span class="lineNum">    9681 </span>            :                  // DQ (4/28/2019): Added variable to allow this section to be compiled.</a>
<a name="9682"><span class="lineNum">    9682 </span>            :                     bool skipGlobalNameQualification = false;</a>
<a name="9683"><span class="lineNum">    9683 </span>            : </a>
<a name="9684"><span class="lineNum">    9684 </span>            :                  // DQ (4/9/2019): This is name qualification that is attached to the name.</a>
<a name="9685"><span class="lineNum">    9685 </span>            :                  // setNameQualification(initializedName,declaration,amountOfNameQualificationRequiredForType,skipGlobalNameQualification);</a>
<a name="9686"><span class="lineNum">    9686 </span>            :                     setNameQualificationOnType(initializedName,declaration,amountOfNameQualificationRequiredForType,skipGlobalNameQualification);</a>
<a name="9687"><span class="lineNum">    9687 </span>            :                  // setNameQualificationOnName(initializedName,declaration,amountOfNameQualificationRequiredForType,skipGlobalNameQualification);</a>
<a name="9688"><span class="lineNum">    9688 </span>            :                   }</a>
<a name="9689"><span class="lineNum">    9689 </span>            : #endif</a>
<a name="9690"><span class="lineNum">    9690 </span>            : </a>
<a name="9691"><span class="lineNum">    9691 </span>            :             // DQ (4/26/2019): The initializer should be processed as an expression to be name qualified seperately.</a>
<a name="9692"><span class="lineNum">    9692 </span>            : #endif</a>
<a name="9693"><span class="lineNum">    9693 </span>            : </a>
<a name="9694"><span class="lineNum">    9694 </span>            : #if 0</a>
<a name="9695"><span class="lineNum">    9695 </span>            :             // DQ (2/21/2019): debugging support.</a>
<a name="9696"><span class="lineNum">    9696 </span>            :                if (debugging == true)</a>
<a name="9697"><span class="lineNum">    9697 </span>            :                   {</a>
<a name="9698"><span class="lineNum">    9698 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="9699"><span class="lineNum">    9699 </span>            :                     ROSE_ABORT();</a>
<a name="9700"><span class="lineNum">    9700 </span>            :                   }</a>
<a name="9701"><span class="lineNum">    9701 </span>            : #endif</a>
<a name="9702"><span class="lineNum">    9702 </span>            :             // **************************************************</a>
<a name="9703"><span class="lineNum">    9703 </span>            : // #else</a>
<a name="9704"><span class="lineNum">    9704 </span>            : // #error &quot;DEAD CODE!&quot;</a>
<a name="9705"><span class="lineNum">    9705 </span>            : //             // setNameQualification(initializedName,declaration,amountOfNameQualificationRequiredForType);</a>
<a name="9706"><span class="lineNum">    9706 </span>            : //                setNameQualification(initializedName,declaration,amountOfNameQualificationRequiredForType,false);</a>
<a name="9707"><span class="lineNum">    9707 </span>            : // #endif</a>
<a name="9708"><span class="lineNum">    9708 </span>            : </a>
<a name="9709"><span class="lineNum">    9709 </span>            : #if 0</a>
<a name="9710"><span class="lineNum">    9710 </span>            :             // DQ (2/21/2019): debugging support.</a>
<a name="9711"><span class="lineNum">    9711 </span>            :                if (debugging == true)</a>
<a name="9712"><span class="lineNum">    9712 </span>            :                   {</a>
<a name="9713"><span class="lineNum">    9713 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="9714"><span class="lineNum">    9714 </span>            :                     ROSE_ABORT();</a>
<a name="9715"><span class="lineNum">    9715 </span>            :                   }</a>
<a name="9716"><span class="lineNum">    9716 </span>            : #endif</a>
<a name="9717"><span class="lineNum">    9717 </span>            : </a>
<a name="9718"><span class="lineNum">    9718 </span>            : #if 1</a>
<a name="9719"><span class="lineNum">    9719 </span>            :             // DQ (10/18/2020): Moved declaration to where it is being used.</a>
<a name="9720"><span class="lineNum">    9720 </span><span class="lineCov">    1462240 :                SgDeclarationStatement* declaration = getDeclarationAssociatedWithType(initializedName-&gt;get_type());</span></a>
<a name="9721"><span class="lineNum">    9721 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="9722"><span class="lineNum">    9722 </span>            :                if (declaration == NULL)</a>
<a name="9723"><span class="lineNum">    9723 </span>            :                   {</a>
<a name="9724"><span class="lineNum">    9724 </span>            :                     printf (&quot;initializedName-&gt;get_type() = %p = %s \n&quot;,initializedName-&gt;get_type(),initializedName-&gt;get_type()-&gt;class_name().c_str());</a>
<a name="9725"><span class="lineNum">    9725 </span>            :                     SgType* strippedType = initializedName-&gt;get_type()-&gt;stripType();</a>
<a name="9726"><span class="lineNum">    9726 </span>            :                     printf (&quot;strippedType = %p = %s \n&quot;,strippedType,strippedType-&gt;class_name().c_str());</a>
<a name="9727"><span class="lineNum">    9727 </span>            :                   }</a>
<a name="9728"><span class="lineNum">    9728 </span>            :             // ROSE_ASSERT(declaration != NULL);</a>
<a name="9729"><span class="lineNum">    9729 </span>            : #endif</a>
<a name="9730"><span class="lineNum">    9730 </span>            : </a>
<a name="9731"><span class="lineNum">    9731 </span>            :             // DQ (10/18/2020): Only insert into the referencedNameSet if this is a declaration that we have seen, must be non-null.</a>
<a name="9732"><span class="lineNum">    9732 </span>            :             // DQ (8/4/2012): Isolate that handling of the referencedNameSet from the use of skipGlobalNameQualification so that we can debug (test2012_96.C).</a>
<a name="9733"><span class="lineNum">    9733 </span>            :             // if (skipGlobalNameQualification == true &amp;&amp; referencedNameSet.find(declaration) == referencedNameSet.end())</a>
<a name="9734"><span class="lineNum">    9734 </span>            :             // if (referencedNameSet.find(declaration) == referencedNameSet.end())</a>
<a name="9735"><span class="lineNum">    9735 </span><span class="lineCov">    2672200 :                if ((declaration != NULL) &amp;&amp; (referencedNameSet.find(declaration) == referencedNameSet.end()))</span></a>
<a name="9736"><span class="lineNum">    9736 </span>            :                   {</a>
<a name="9737"><span class="lineNum">    9737 </span>            :                  // No qualification is required but we do want to count this as a reference to the class.</a>
<a name="9738"><span class="lineNum">    9738 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="9739"><span class="lineNum">    9739 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;No qualification should be used for this type (class = %p = %s) AND insert it into the referencedNameSet \n&quot;, declaration, declaration ? declaration-&gt;class_name().c_str() : &quot;&quot;);</a>
<a name="9740"><span class="lineNum">    9740 </span>            : #endif</a>
<a name="9741"><span class="lineNum">    9741 </span>            : </a>
<a name="9742"><span class="lineNum">    9742 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="9743"><span class="lineNum">    9743 </span>            :                     printf (&quot;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ \n&quot;);</a>
<a name="9744"><span class="lineNum">    9744 </span>            :                     printf (&quot;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ \n&quot;);</a>
<a name="9745"><span class="lineNum">    9745 </span>            :                     printf (&quot;INSERTING INTO referencedNameSet: declaration = %p = %s name = %s \n&quot;,declaration,declaration-&gt;class_name().c_str(),SageInterface::get_name(declaration).c_str());</a>
<a name="9746"><span class="lineNum">    9746 </span>            :                     printf (&quot;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ \n&quot;);</a>
<a name="9747"><span class="lineNum">    9747 </span>            :                     printf (&quot;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ \n&quot;);</a>
<a name="9748"><span class="lineNum">    9748 </span>            : #endif</a>
<a name="9749"><span class="lineNum">    9749 </span><span class="lineCov">      11429 :                     referencedNameSet.insert(declaration);</span></a>
<a name="9750"><span class="lineNum">    9750 </span>            :                   }</a>
<a name="9751"><span class="lineNum">    9751 </span>            : #endif</a>
<a name="9752"><span class="lineNum">    9752 </span>            : #if 0</a>
<a name="9753"><span class="lineNum">    9753 </span>            :             // This can be inside of the case where (declaration != NULL)</a>
<a name="9754"><span class="lineNum">    9754 </span>            :             // Traverse the type to set any possible template arguments (or other subtypes?) that require name qualification.</a>
<a name="9755"><span class="lineNum">    9755 </span>            : #if 0</a>
<a name="9756"><span class="lineNum">    9756 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Calling traverseType on SgInitializedName = %p = %s \n&quot;,initializedName,initializedName-&gt;get_name().str());</a>
<a name="9757"><span class="lineNum">    9757 </span>            : #endif</a>
<a name="9758"><span class="lineNum">    9758 </span>            :                traverseType(initializedName-&gt;get_type(),initializedName,currentScope,currentStatement);</a>
<a name="9759"><span class="lineNum">    9759 </span>            : #else</a>
<a name="9760"><span class="lineNum">    9760 </span>            : </a>
<a name="9761"><span class="lineNum">    9761 </span>            : #if 0</a>
<a name="9762"><span class="lineNum">    9762 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Case SgInitializedName: Skipping call to traverseType from processing the SgInitializedName \n&quot;);</a>
<a name="9763"><span class="lineNum">    9763 </span>            : #endif</a>
<a name="9764"><span class="lineNum">    9764 </span>            : </a>
<a name="9765"><span class="lineNum">    9765 </span>            : #endif</a>
<a name="9766"><span class="lineNum">    9766 </span>            : </a>
<a name="9767"><span class="lineNum">    9767 </span>            : #if 0</a>
<a name="9768"><span class="lineNum">    9768 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;############################################################### \n&quot;);</a>
<a name="9769"><span class="lineNum">    9769 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Case SgInitializedName: END OF Processing the SgInitializedName \n&quot;);</a>
<a name="9770"><span class="lineNum">    9770 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;############################################################### \n&quot;);</a>
<a name="9771"><span class="lineNum">    9771 </span>            : #endif</a>
<a name="9772"><span class="lineNum">    9772 </span>            : </a>
<a name="9773"><span class="lineNum">    9773 </span>            : #if 0</a>
<a name="9774"><span class="lineNum">    9774 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="9775"><span class="lineNum">    9775 </span>            :           ROSE_ABORT();</a>
<a name="9776"><span class="lineNum">    9776 </span>            : #endif</a>
<a name="9777"><span class="lineNum">    9777 </span>            : </a>
<a name="9778"><span class="lineNum">    9778 </span>            : #if 0</a>
<a name="9779"><span class="lineNum">    9779 </span>            :        // DQ (2/21/2019): debugging support.</a>
<a name="9780"><span class="lineNum">    9780 </span>            :           if (debugging == true)</a>
<a name="9781"><span class="lineNum">    9781 </span>            :              {</a>
<a name="9782"><span class="lineNum">    9782 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="9783"><span class="lineNum">    9783 </span>            :                ROSE_ABORT();</a>
<a name="9784"><span class="lineNum">    9784 </span>            :              }</a>
<a name="9785"><span class="lineNum">    9785 </span>            : #endif</a>
<a name="9786"><span class="lineNum">    9786 </span>            :         }</a>
<a name="9787"><span class="lineNum">    9787 </span>            : </a>
<a name="9788"><span class="lineNum">    9788 </span>            : </a>
<a name="9789"><span class="lineNum">    9789 </span>            : </a>
<a name="9790"><span class="lineNum">    9790 </span>            :   // Handle references to SgFunctionDeclaration...</a>
<a name="9791"><span class="lineNum">    9791 </span><span class="lineCov">    2810440 :      SgFunctionDeclaration* functionDeclaration = isSgFunctionDeclaration(n);</span></a>
<a name="9792"><span class="lineNum">    9792 </span>            : </a>
<a name="9793"><span class="lineNum">    9793 </span>            :   // DQ (6/4/2011): Avoid processing as both member and non-member function...</a>
<a name="9794"><span class="lineNum">    9794 </span>            :   // if (functionDeclaration != NULL)</a>
<a name="9795"><span class="lineNum">    9795 </span><span class="lineCov">    2810440 :      if (functionDeclaration != NULL &amp;&amp; isSgMemberFunctionDeclaration(n) == NULL)</span></a>
<a name="9796"><span class="lineNum">    9796 </span>            :         {</a>
<a name="9797"><span class="lineNum">    9797 </span>            :        // Could it be that we only want to do this for the defining declaration? No, since prototypes must also use name qualification!</a>
<a name="9798"><span class="lineNum">    9798 </span>            : </a>
<a name="9799"><span class="lineNum">    9799 </span>            :        // We need the structural location in scope (not the semantic one).</a>
<a name="9800"><span class="lineNum">    9800 </span><span class="lineCov">     250901 :           SgScopeStatement* currentScope = isSgScopeStatement(functionDeclaration-&gt;get_parent());</span></a>
<a name="9801"><span class="lineNum">    9801 </span>            :        // SgScopeStatement* currentScope = TransformationSupport::getScope(functionDeclaration);</a>
<a name="9802"><span class="lineNum">    9802 </span>            :        // SgScopeStatement* currentScope = functionDeclaration-&gt;get_scope();</a>
<a name="9803"><span class="lineNum">    9803 </span>            : </a>
<a name="9804"><span class="lineNum">    9804 </span>            :        // SgStatement* currentStatement = TransformationSupport::getStatement(functionDeclaration-&gt;get_parent());</a>
<a name="9805"><span class="lineNum">    9805 </span>            :        // ASSERT_not_null(currentStatement);</a>
<a name="9806"><span class="lineNum">    9806 </span>            : </a>
<a name="9807"><span class="lineNum">    9807 </span>            :        // Make sure these are the same. test2005_57.C presents what might be a relevant test code.</a>
<a name="9808"><span class="lineNum">    9808 </span>            :        // ROSE_ASSERT(currentScope == TransformationSupport::getScope(currentStatement));</a>
<a name="9809"><span class="lineNum">    9809 </span>            :        // ROSE_ASSERT(currentScope == currentStatement-&gt;get_scope());</a>
<a name="9810"><span class="lineNum">    9810 </span>            : #if 0</a>
<a name="9811"><span class="lineNum">    9811 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Case of (functionDeclaration != NULL &amp;&amp; isSgMemberFunctionDeclaration(n) == NULL): currentScope = %p \n&quot;,currentScope);</a>
<a name="9812"><span class="lineNum">    9812 </span>            : #endif</a>
<a name="9813"><span class="lineNum">    9813 </span>            : </a>
<a name="9814"><span class="lineNum">    9814 </span>            :        // DQ (11/18/2017): When the parent is not a scope, it could be a SgTemplateInstantiationDirectiveStatement, in which</a>
<a name="9815"><span class="lineNum">    9815 </span>            :        // case we want the parent of that. See test2017_66.C (and previously test2006_08.C) for an example of this case.</a>
<a name="9816"><span class="lineNum">    9816 </span><span class="lineCov">     250901 :           if (currentScope == NULL)</span></a>
<a name="9817"><span class="lineNum">    9817 </span>            :              {</a>
<a name="9818"><span class="lineNum">    9818 </span><span class="lineCov">        480 :                SgTemplateInstantiationDirectiveStatement* templateInstantiationDirectiveStatement = isSgTemplateInstantiationDirectiveStatement(functionDeclaration-&gt;get_parent());</span></a>
<a name="9819"><span class="lineNum">    9819 </span><span class="lineCov">        480 :                if (templateInstantiationDirectiveStatement != NULL)</span></a>
<a name="9820"><span class="lineNum">    9820 </span>            :                   {</a>
<a name="9821"><span class="lineNum">    9821 </span><span class="lineCov">        480 :                     currentScope = isSgScopeStatement(templateInstantiationDirectiveStatement-&gt;get_parent());</span></a>
<a name="9822"><span class="lineNum">    9822 </span>            : #if 0</a>
<a name="9823"><span class="lineNum">    9823 </span>            :                  // DQ (4/20/2018): Added debugging support.</a>
<a name="9824"><span class="lineNum">    9824 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;In name qualification support: processing SgFunctionDeclaration (non-member): found SgTemplateInstantiationDirectiveStatement \n&quot;);</a>
<a name="9825"><span class="lineNum">    9825 </span>            : #endif</a>
<a name="9826"><span class="lineNum">    9826 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="9827"><span class="lineNum">    9827 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Case of (functionDeclaration != NULL &amp;&amp; isSgMemberFunctionDeclaration(n) == NULL): reset using SgTemplateInstantiationDirectiveStatement: currentScope = %p \n&quot;,currentScope);</a>
<a name="9828"><span class="lineNum">    9828 </span>            : #endif</a>
<a name="9829"><span class="lineNum">    9829 </span>            :                  // Now we should have a valid currentScope.</a>
<a name="9830"><span class="lineNum">    9830 </span><span class="lineCov">        480 :                     ASSERT_not_null(currentScope);</span></a>
<a name="9831"><span class="lineNum">    9831 </span>            :                   }</a>
<a name="9832"><span class="lineNum">    9832 </span>            :              }</a>
<a name="9833"><span class="lineNum">    9833 </span>            : </a>
<a name="9834"><span class="lineNum">    9834 </span>            : #if 0</a>
<a name="9835"><span class="lineNum">    9835 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;currentScope = %p \n&quot;,currentScope);</a>
<a name="9836"><span class="lineNum">    9836 </span>            : #endif</a>
<a name="9837"><span class="lineNum">    9837 </span>            : </a>
<a name="9838"><span class="lineNum">    9838 </span>            :        // ASSERT_not_null(currentScope);</a>
<a name="9839"><span class="lineNum">    9839 </span><span class="lineCov">     250901 :           if (currentScope != NULL)</span></a>
<a name="9840"><span class="lineNum">    9840 </span>            :              {</a>
<a name="9841"><span class="lineNum">    9841 </span>            :             // Handle the function return type...</a>
<a name="9842"><span class="lineNum">    9842 </span><span class="lineCov">     250901 :                ASSERT_not_null(functionDeclaration-&gt;get_orig_return_type());</span></a>
<a name="9843"><span class="lineNum">    9843 </span><span class="lineCov">     250901 :                ASSERT_not_null(functionDeclaration-&gt;get_type());</span></a>
<a name="9844"><span class="lineNum">    9844 </span><span class="lineCov">     250901 :                ASSERT_not_null(functionDeclaration-&gt;get_type()-&gt;get_return_type());</span></a>
<a name="9845"><span class="lineNum">    9845 </span><span class="lineCov">     250901 :                SgType* returnType = functionDeclaration-&gt;get_type()-&gt;get_return_type();</span></a>
<a name="9846"><span class="lineNum">    9846 </span><span class="lineCov">     250901 :                ASSERT_not_null(returnType);</span></a>
<a name="9847"><span class="lineNum">    9847 </span>            : </a>
<a name="9848"><span class="lineNum">    9848 </span><span class="lineCov">     250901 :                SgDeclarationStatement* declaration = getDeclarationAssociatedWithType(returnType);</span></a>
<a name="9849"><span class="lineNum">    9849 </span><span class="lineCov">     250901 :                if (declaration != NULL)</span></a>
<a name="9850"><span class="lineNum">    9850 </span>            :                   {</a>
<a name="9851"><span class="lineNum">    9851 </span><span class="lineCov">     184463 :                     int amountOfNameQualificationRequiredForReturnType = nameQualificationDepth(declaration,currentScope,functionDeclaration);</span></a>
<a name="9852"><span class="lineNum">    9852 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="9853"><span class="lineNum">    9853 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;SgFunctionDeclaration's return type: amountOfNameQualificationRequiredForType = %d \n&quot;,amountOfNameQualificationRequiredForReturnType);</a>
<a name="9854"><span class="lineNum">    9854 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Putting the name qualification for the type into the return type of SgFunctionDeclaration = %p = %s \n&quot;,functionDeclaration,functionDeclaration-&gt;get_name().str());</a>
<a name="9855"><span class="lineNum">    9855 </span>            : #endif</a>
<a name="9856"><span class="lineNum">    9856 </span>            :                  // setNameQualificationReturnType(functionDeclaration,amountOfNameQualificationRequiredForReturnType);</a>
<a name="9857"><span class="lineNum">    9857 </span><span class="lineCov">     184463 :                     setNameQualificationReturnType(functionDeclaration,declaration,amountOfNameQualificationRequiredForReturnType);</span></a>
<a name="9858"><span class="lineNum">    9858 </span>            :                   }</a>
<a name="9859"><span class="lineNum">    9859 </span>            :                  else</a>
<a name="9860"><span class="lineNum">    9860 </span>            :                   {</a>
<a name="9861"><span class="lineNum">    9861 </span>            :                  // This case is common for builtin functions such as: __builtin_powi</a>
<a name="9862"><span class="lineNum">    9862 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="9863"><span class="lineNum">    9863 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;declaration == NULL: could not put name qualification for the type into the return type of SgFunctionDeclaration = %p = %s \n&quot;,functionDeclaration,functionDeclaration-&gt;get_name().str());</a>
<a name="9864"><span class="lineNum">    9864 </span>            : #endif</a>
<a name="9865"><span class="lineNum">    9865 </span>            :                   }</a>
<a name="9866"><span class="lineNum">    9866 </span>            : </a>
<a name="9867"><span class="lineNum">    9867 </span>            : #if 0</a>
<a name="9868"><span class="lineNum">    9868 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Calling traverseType on SgFunctionDeclaration = %p = %s name = %s \n&quot;,functionDeclaration,functionDeclaration-&gt;class_name().c_str(),functionDeclaration-&gt;get_name().str());</a>
<a name="9869"><span class="lineNum">    9869 </span>            : #endif</a>
<a name="9870"><span class="lineNum">    9870 </span>            :             // DQ (6/3/2011): Traverse the type to set any possible template arguments (or other subtypes?) that require name qualification.</a>
<a name="9871"><span class="lineNum">    9871 </span><span class="lineCov">     250901 :                traverseType(returnType,functionDeclaration,currentScope,functionDeclaration);</span></a>
<a name="9872"><span class="lineNum">    9872 </span>            : </a>
<a name="9873"><span class="lineNum">    9873 </span>            : #if 0</a>
<a name="9874"><span class="lineNum">    9874 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ \n&quot;);</a>
<a name="9875"><span class="lineNum">    9875 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;@@@@@@@@@@@@@@@@@@ Process the function name @@@@@@@@@@@@@@@@@@ \n&quot;);</a>
<a name="9876"><span class="lineNum">    9876 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ \n&quot;);</a>
<a name="9877"><span class="lineNum">    9877 </span>            : #endif</a>
<a name="9878"><span class="lineNum">    9878 </span>            : #if 0</a>
<a name="9879"><span class="lineNum">    9879 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;functionDeclaration = %p = %s name = %s \n&quot;,functionDeclaration,functionDeclaration-&gt;class_name().c_str(),functionDeclaration-&gt;get_name().str());</a>
<a name="9880"><span class="lineNum">    9880 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;currentScope = %p \n&quot;,currentScope);</a>
<a name="9881"><span class="lineNum">    9881 </span>            :                if (currentScope != NULL)</a>
<a name="9882"><span class="lineNum">    9882 </span>            :                   {</a>
<a name="9883"><span class="lineNum">    9883 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;currentScope = %p = %s \n&quot;,currentScope,currentScope-&gt;class_name().c_str());</a>
<a name="9884"><span class="lineNum">    9884 </span>            :                   }</a>
<a name="9885"><span class="lineNum">    9885 </span>            : #endif</a>
<a name="9886"><span class="lineNum">    9886 </span>            :             // Handle the function name...</a>
<a name="9887"><span class="lineNum">    9887 </span>            :             // DQ (6/20/2011): Friend function can be qualified...sometimes...</a>
<a name="9888"><span class="lineNum">    9888 </span>            :             // if (functionDeclaration-&gt;get_declarationModifier().isFriend() == true || functionDeclaration-&gt;get_specialFunctionModifier().isOperator() == true)</a>
<a name="9889"><span class="lineNum">    9889 </span><span class="lineCov">     250901 :                if (functionDeclaration-&gt;get_specialFunctionModifier().isOperator() == true)</span></a>
<a name="9890"><span class="lineNum">    9890 </span>            :                   {</a>
<a name="9891"><span class="lineNum">    9891 </span>            :                  // DQ (6/19/2011): We sometimes have to qualify friends if it is to avoid ambiguity (see test2006_159.C) (but we never qualify an operator, I think).</a>
<a name="9892"><span class="lineNum">    9892 </span>            :                  // Maybe a friend declaration should add an SgAliasSymbol to the class definition scope's symbol table.</a>
<a name="9893"><span class="lineNum">    9893 </span>            :                  // Then simpler rules (no special case) would cause the name qualification to be generated properly.</a>
<a name="9894"><span class="lineNum">    9894 </span>            : </a>
<a name="9895"><span class="lineNum">    9895 </span>            :                  // Old comment</a>
<a name="9896"><span class="lineNum">    9896 </span>            :                  // Never use name qualification for friend functions or operators. I am more sure of the case of friend functions than operators.</a>
<a name="9897"><span class="lineNum">    9897 </span>            :                  // Friend functions will have a global scope (though this might change in the future; google &quot;friend global scope injection&quot;).</a>
<a name="9898"><span class="lineNum">    9898 </span>            :                  // mfprintf(mlog [ WARN ] ) (&quot;Detected a friend or operator function, these are not provided with name qualification. \n&quot;);</a>
<a name="9899"><span class="lineNum">    9899 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="9900"><span class="lineNum">    9900 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Detected a operator function, these are not provided with name qualification. \n&quot;);</a>
<a name="9901"><span class="lineNum">    9901 </span>            : #endif</a>
<a name="9902"><span class="lineNum">    9902 </span>            :                   }</a>
<a name="9903"><span class="lineNum">    9903 </span>            :                  else</a>
<a name="9904"><span class="lineNum">    9904 </span>            :                   {</a>
<a name="9905"><span class="lineNum">    9905 </span>            :                  // Only use name qualification where the scopes of the declaration's use (currentScope) is not the same</a>
<a name="9906"><span class="lineNum">    9906 </span>            :                  // as the scope of the function declaration.  However, the analysis should work and determin that the</a>
<a name="9907"><span class="lineNum">    9907 </span>            :                  // required name qualification length is zero.</a>
<a name="9908"><span class="lineNum">    9908 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="9909"><span class="lineNum">    9909 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;I would like to not have to have this SgFunctionDeclaration logic, we should get the name qualification correct more directly. \n&quot;);</a>
<a name="9910"><span class="lineNum">    9910 </span>            : #endif</a>
<a name="9911"><span class="lineNum">    9911 </span>            :                  // DQ (6/20/2011): Friend function can be qualified and a fix to add a SgAliasSymbol to the class definition scope's symbol table</a>
<a name="9912"><span class="lineNum">    9912 </span>            :                  // should allow it to be handled with greater precission.</a>
<a name="9913"><span class="lineNum">    9913 </span>            : #if 0</a>
<a name="9914"><span class="lineNum">    9914 </span>            :                     printf (&quot;functionDeclaration-&gt;get_declarationModifier().isFriend() = %s \n&quot;,functionDeclaration-&gt;get_declarationModifier().isFriend() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="9915"><span class="lineNum">    9915 </span>            : #endif</a>
<a name="9916"><span class="lineNum">    9916 </span>            :                  // DQ (6/25/2011): Friend functions can require global qualification as well (see test2011_106.C).</a>
<a name="9917"><span class="lineNum">    9917 </span>            :                  // Not clear how to handle this case.</a>
<a name="9918"><span class="lineNum">    9918 </span><span class="lineCov">     248565 :                     if (functionDeclaration-&gt;get_declarationModifier().isFriend() == true)</span></a>
<a name="9919"><span class="lineNum">    9919 </span>            :                        {</a>
<a name="9920"><span class="lineNum">    9920 </span>            :                       // This is the case of a friend function declaration which requires more name qualification than expected.</a>
<a name="9921"><span class="lineNum">    9921 </span>            :                       // Note that this might be compiler dependent but at least GNU g++ required more qualification than expected.</a>
<a name="9922"><span class="lineNum">    9922 </span><span class="lineCov">        323 :                          SgScopeStatement* scope = functionDeclaration-&gt;get_scope();</span></a>
<a name="9923"><span class="lineNum">    9923 </span><span class="lineCov">        323 :                          SgGlobal* globalScope = isSgGlobal(scope);</span></a>
<a name="9924"><span class="lineNum">    9924 </span><span class="lineCov">        323 :                          if (globalScope != NULL)</span></a>
<a name="9925"><span class="lineNum">    9925 </span>            :                             {</a>
<a name="9926"><span class="lineNum">    9926 </span>            :                            // We want to specify global qualification when the friend function is in global scope (see test2011_106.C).</a>
<a name="9927"><span class="lineNum">    9927 </span>            : #if 1</a>
<a name="9928"><span class="lineNum">    9928 </span>            :                            // DQ (6/25/2011): This will output the name qualification correctly AND cause the output of the outlined function to be supressed.</a>
<a name="9929"><span class="lineNum">    9929 </span><span class="lineNoCov">          0 :                               int amountOfNameQualificationRequired = 0;</span></a>
<a name="9930"><span class="lineNum">    9930 </span>            : </a>
<a name="9931"><span class="lineNum">    9931 </span>            :                            // Check if this function declaration has been seen already...</a>
<a name="9932"><span class="lineNum">    9932 </span>            :                            // if (functionDeclaration == functionDeclaration-&gt;get_firstNondefiningDeclaration())</a>
<a name="9933"><span class="lineNum">    9933 </span>            : </a>
<a name="9934"><span class="lineNum">    9934 </span>            :                            // This is the same code as below so it could be refactored (special handling for function declarations</a>
<a name="9935"><span class="lineNum">    9935 </span>            :                            // that are defining declaration and don't have an associated nondefining declaration).</a>
<a name="9936"><span class="lineNum">    9936 </span>            : </a>
<a name="9937"><span class="lineNum">    9937 </span>            :                            // DQ (8/4/2012): This is a case using the referencedNameSet that should be refactored out of this location.</a>
<a name="9938"><span class="lineNum">    9938 </span><span class="lineNoCov">          0 :                               SgDeclarationStatement* declarationForReferencedNameSet = functionDeclaration-&gt;get_firstNondefiningDeclaration();</span></a>
<a name="9939"><span class="lineNum">    9939 </span>            : </a>
<a name="9940"><span class="lineNum">    9940 </span><span class="lineNoCov">          0 :                               if (declarationForReferencedNameSet == NULL)</span></a>
<a name="9941"><span class="lineNum">    9941 </span>            :                                  {</a>
<a name="9942"><span class="lineNum">    9942 </span>            :                                 // Note that a function with only a defining declaration will not have a nondefining declaration</a>
<a name="9943"><span class="lineNum">    9943 </span>            :                                 // automatically constructed in the AST (unlike classes and some onther sorts of declarations).</a>
<a name="9944"><span class="lineNum">    9944 </span><span class="lineNoCov">          0 :                                    declarationForReferencedNameSet = functionDeclaration-&gt;get_definingDeclaration();</span></a>
<a name="9945"><span class="lineNum">    9945 </span>            : </a>
<a name="9946"><span class="lineNum">    9946 </span>            :                                 // DQ (6/22/2011): I think this is true.  This assertion fails for test2006_78.C (a template example code).</a>
<a name="9947"><span class="lineNum">    9947 </span>            :                                 // ROSE_ASSERT(declarationForReferencedNameSet == declaration);</a>
<a name="9948"><span class="lineNum">    9948 </span>            : </a>
<a name="9949"><span class="lineNum">    9949 </span>            :                                 // DQ (6/23/2011): This assertion fails for the LoopProcessor on tests/nonsmoke/functional/roseTests/loopProcessingTests/mm.C</a>
<a name="9950"><span class="lineNum">    9950 </span>            :                                 // ASSERT_not_null(declarationForReferencedNameSet);</a>
<a name="9951"><span class="lineNum">    9951 </span><span class="lineNoCov">          0 :                                    if (declarationForReferencedNameSet == NULL)</span></a>
<a name="9952"><span class="lineNum">    9952 </span>            :                                       {</a>
<a name="9953"><span class="lineNum">    9953 </span><span class="lineNoCov">          0 :                                         declarationForReferencedNameSet = functionDeclaration;</span></a>
<a name="9954"><span class="lineNum">    9954 </span><span class="lineNoCov">          0 :                                         ASSERT_not_null(declarationForReferencedNameSet);</span></a>
<a name="9955"><span class="lineNum">    9955 </span>            :                                       }</a>
<a name="9956"><span class="lineNum">    9956 </span><span class="lineNoCov">          0 :                                    ASSERT_not_null(declarationForReferencedNameSet);</span></a>
<a name="9957"><span class="lineNum">    9957 </span>            :                                  }</a>
<a name="9958"><span class="lineNum">    9958 </span><span class="lineNoCov">          0 :                               ASSERT_not_null(declarationForReferencedNameSet);</span></a>
<a name="9959"><span class="lineNum">    9959 </span>            : </a>
<a name="9960"><span class="lineNum">    9960 </span>            :                            // DQ (8/4/2012): We would like to refactor this code (I think).</a>
<a name="9961"><span class="lineNum">    9961 </span>            : #ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION</a>
<a name="9962"><span class="lineNum">    9962 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;Name qualification for SgFunctionDeclaration: I think this should be using the defined function xxx so that we isolate references to the referencedNameSet \n&quot;);</a>
<a name="9963"><span class="lineNum">    9963 </span>            : #endif</a>
<a name="9964"><span class="lineNum">    9964 </span><span class="lineNoCov">          0 :                               if (referencedNameSet.find(declarationForReferencedNameSet) == referencedNameSet.end())</span></a>
<a name="9965"><span class="lineNum">    9965 </span>            :                                  {</a>
<a name="9966"><span class="lineNum">    9966 </span>            :                                 // No global qualification is required.</a>
<a name="9967"><span class="lineNum">    9967 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="9968"><span class="lineNum">    9968 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;No qualification should be used for this friend function. \n&quot;);</a>
<a name="9969"><span class="lineNum">    9969 </span>            : #endif</a>
<a name="9970"><span class="lineNum">    9970 </span>            :                                  }</a>
<a name="9971"><span class="lineNum">    9971 </span>            :                                 else</a>
<a name="9972"><span class="lineNum">    9972 </span>            :                                  {</a>
<a name="9973"><span class="lineNum">    9973 </span><span class="lineNoCov">          0 :                                    amountOfNameQualificationRequired = 1;</span></a>
<a name="9974"><span class="lineNum">    9974 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="9975"><span class="lineNum">    9975 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;Force global qualification for friend function: amountOfNameQualificationRequired = %d \n&quot;,amountOfNameQualificationRequired);</a>
<a name="9976"><span class="lineNum">    9976 </span>            : #endif</a>
<a name="9977"><span class="lineNum">    9977 </span>            :                                  }</a>
<a name="9978"><span class="lineNum">    9978 </span>            : #else</a>
<a name="9979"><span class="lineNum">    9979 </span>            :                            // DQ (6/25/2011): This will not generate the correct name qualification AND will cause the outlined function to be output.</a>
<a name="9980"><span class="lineNum">    9980 </span>            :                               int amountOfNameQualificationRequired = 0;</a>
<a name="9981"><span class="lineNum">    9981 </span>            : #endif</a>
<a name="9982"><span class="lineNum">    9982 </span><span class="lineNoCov">          0 :                               setNameQualification(functionDeclaration,amountOfNameQualificationRequired);</span></a>
<a name="9983"><span class="lineNum">    9983 </span>            :                             }</a>
<a name="9984"><span class="lineNum">    9984 </span>            :                            else</a>
<a name="9985"><span class="lineNum">    9985 </span>            :                             {</a>
<a name="9986"><span class="lineNum">    9986 </span>            :                            // Not clear what to do with this case, I guess we just want standard qualification rules.</a>
<a name="9987"><span class="lineNum">    9987 </span><span class="lineCov">        323 :                               int amountOfNameQualificationRequired = nameQualificationDepth(functionDeclaration,currentScope,functionDeclaration);</span></a>
<a name="9988"><span class="lineNum">    9988 </span><span class="lineCov">        323 :                               setNameQualification(functionDeclaration,amountOfNameQualificationRequired);</span></a>
<a name="9989"><span class="lineNum">    9989 </span>            :                             }</a>
<a name="9990"><span class="lineNum">    9990 </span>            :                        }</a>
<a name="9991"><span class="lineNum">    9991 </span>            :                       else</a>
<a name="9992"><span class="lineNum">    9992 </span>            :                        {</a>
<a name="9993"><span class="lineNum">    9993 </span>            :                       // DQ (3/31/2018): Added assertion.</a>
<a name="9994"><span class="lineNum">    9994 </span><span class="lineCov">     248242 :                          ASSERT_not_null(functionDeclaration-&gt;get_scope());</span></a>
<a name="9995"><span class="lineNum">    9995 </span>            : </a>
<a name="9996"><span class="lineNum">    9996 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="9997"><span class="lineNum">    9997 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;currentScope = %p functionDeclaration-&gt;get_scope() = %p \n&quot;,currentScope,functionDeclaration-&gt;get_scope());</a>
<a name="9998"><span class="lineNum">    9998 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;functionDeclaration-&gt;get_scope() = %s \n&quot;,functionDeclaration-&gt;get_scope()-&gt;class_name().c_str());</a>
<a name="9999"><span class="lineNum">    9999 </span>            : #endif</a>
<a name="10000"><span class="lineNum">   10000 </span>            :                       // Case of non-member functions (more logical name qualification rules).</a>
<a name="10001"><span class="lineNum">   10001 </span><span class="lineCov">     248242 :                          if (currentScope != functionDeclaration-&gt;get_scope())</span></a>
<a name="10002"><span class="lineNum">   10002 </span>            :                             {</a>
<a name="10003"><span class="lineNum">   10003 </span>            :                            // DQ (1/21/2013): Added support for testing the more general equivalence of scopes (where the pointers are not equal, applies only to namespaces, I think).</a>
<a name="10004"><span class="lineNum">   10004 </span><span class="lineCov">       5798 :                               bool isSameNamespace = SgScopeStatement::isEquivalentScope(currentScope,functionDeclaration-&gt;get_scope());</span></a>
<a name="10005"><span class="lineNum">   10005 </span>            : #if 0</a>
<a name="10006"><span class="lineNum">   10006 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;isSameNamespace = %s \n&quot;,isSameNamespace ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="10007"><span class="lineNum">   10007 </span>            : #endif</a>
<a name="10008"><span class="lineNum">   10008 </span><span class="lineCov">       5798 :                               if (isSameNamespace == false)</span></a>
<a name="10009"><span class="lineNum">   10009 </span>            :                                  {</a>
<a name="10010"><span class="lineNum">   10010 </span><span class="lineCov">        926 :                                    int amountOfNameQualificationRequired = nameQualificationDepth(functionDeclaration,currentScope,functionDeclaration);</span></a>
<a name="10011"><span class="lineNum">   10011 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || 0</a>
<a name="10012"><span class="lineNum">   10012 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;isSameNamespace == false: SgFunctionDeclaration: amountOfNameQualificationRequired = %d \n&quot;,amountOfNameQualificationRequired);</a>
<a name="10013"><span class="lineNum">   10013 </span>            : #endif</a>
<a name="10014"><span class="lineNum">   10014 </span>            :                                 // DQ (21/2011): test2011_89.C demonstrates a case where name qualification of a functionRef expression is required.</a>
<a name="10015"><span class="lineNum">   10015 </span>            :                                 // DQ (6/9/2011): Support for test2011_78.C (we only qualify function call references where the function has been declared in</a>
<a name="10016"><span class="lineNum">   10016 </span>            :                                 // a scope where it could be expected to be defined (e.g. not using a forward declaration in a SgBasicBlock, since the function</a>
<a name="10017"><span class="lineNum">   10017 </span>            :                                 // definition could not live in the SgBasicBlock.</a>
<a name="10018"><span class="lineNum">   10018 </span><span class="lineCov">        926 :                                    bool skipNameQualification = skipNameQualificationIfNotProperlyDeclaredWhereDeclarationIsDefinable(functionDeclaration);</span></a>
<a name="10019"><span class="lineNum">   10019 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="10020"><span class="lineNum">   10020 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;isSameNamespace == false: Test of functionDeclaration: skipNameQualification = %s \n&quot;,skipNameQualification ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="10021"><span class="lineNum">   10021 </span>            : #endif</a>
<a name="10022"><span class="lineNum">   10022 </span><span class="lineCov">        926 :                                    if (skipNameQualification == false)</span></a>
<a name="10023"><span class="lineNum">   10023 </span>            :                                       {</a>
<a name="10024"><span class="lineNum">   10024 </span><span class="lineCov">        926 :                                         setNameQualification(functionDeclaration,amountOfNameQualificationRequired);</span></a>
<a name="10025"><span class="lineNum">   10025 </span>            :                                       }</a>
<a name="10026"><span class="lineNum">   10026 </span>            :                                  }</a>
<a name="10027"><span class="lineNum">   10027 </span>            :                                 else</a>
<a name="10028"><span class="lineNum">   10028 </span>            :                                  {</a>
<a name="10029"><span class="lineNum">   10029 </span>            : #if 0</a>
<a name="10030"><span class="lineNum">   10030 </span>            :                                    printf (&quot;isSameNamespace == true: functionDeclaration = %p = %s \n&quot;,functionDeclaration,functionDeclaration-&gt;class_name().c_str());</a>
<a name="10031"><span class="lineNum">   10031 </span>            : #endif</a>
<a name="10032"><span class="lineNum">   10032 </span>            :                                 // DQ (3/31/2018): Note that we still might require name qualification on any template arguments in the template function instantiation.</a>
<a name="10033"><span class="lineNum">   10033 </span>            :                                 // Ignore the case fo a SgTemplateFunctionDeclaration.</a>
<a name="10034"><span class="lineNum">   10034 </span><span class="lineCov">       4872 :                                    if (isSgTemplateInstantiationFunctionDecl(functionDeclaration) != NULL)</span></a>
<a name="10035"><span class="lineNum">   10035 </span>            :                                       {</a>
<a name="10036"><span class="lineNum">   10036 </span>            :                                      // This point of calling this function is to just have the template arguments evaluated for name qualification (see Cxx11_tests/test2018_68.C).</a>
<a name="10037"><span class="lineNum">   10037 </span><span class="lineCov">        818 :                                         int amountOfNameQualificationRequired = nameQualificationDepth(functionDeclaration,currentScope,functionDeclaration);</span></a>
<a name="10038"><span class="lineNum">   10038 </span>            : </a>
<a name="10039"><span class="lineNum">   10039 </span>            :                                      // Add this to make sure that amountOfNameQualificationRequired is referenced to avoid a compiler warning.</a>
<a name="10040"><span class="lineNum">   10040 </span><span class="lineCov">        818 :                                         ROSE_ASSERT(amountOfNameQualificationRequired &gt;= 0);</span></a>
<a name="10041"><span class="lineNum">   10041 </span>            : </a>
<a name="10042"><span class="lineNum">   10042 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="10043"><span class="lineNum">   10043 </span>            :                                         mfprintf(mlog [ WARN ] ) (&quot;SgFunctionDeclaration: amountOfNameQualificationRequired = %d \n&quot;,amountOfNameQualificationRequired);</a>
<a name="10044"><span class="lineNum">   10044 </span>            : #endif</a>
<a name="10045"><span class="lineNum">   10045 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="10046"><span class="lineNum">   10046 </span>            :                                      // DQ (4/2/2018): Report anything that is unusual, i.e. non-zero name qualification length.</a>
<a name="10047"><span class="lineNum">   10047 </span>            :                                         if (amountOfNameQualificationRequired &gt; 0)</a>
<a name="10048"><span class="lineNum">   10048 </span>            :                                            {</a>
<a name="10049"><span class="lineNum">   10049 </span>            :                                              mfprintf(mlog [ WARN ] ) (&quot;Warning: name qualification length should be zero for a function declared in the same scope: amountOfNameQualificationRequired = %d \n&quot;,amountOfNameQualificationRequired);</a>
<a name="10050"><span class="lineNum">   10050 </span>            : </a>
<a name="10051"><span class="lineNum">   10051 </span>            :                                              mfprintf(mlog [ WARN ] ) (&quot;functionDeclaration = %p = %s = %s \n&quot;,functionDeclaration,functionDeclaration-&gt;class_name().c_str(),functionDeclaration-&gt;get_mangled_name().str());</a>
<a name="10052"><span class="lineNum">   10052 </span>            : </a>
<a name="10053"><span class="lineNum">   10053 </span>            :                                              mfprintf(mlog [ WARN ] ) (&quot;currentScope                     = %p = %s \n&quot;,currentScope,currentScope-&gt;class_name().c_str());</a>
<a name="10054"><span class="lineNum">   10054 </span>            :                                              SgNamespaceDefinitionStatement* currentNamespaceDefinition = isSgNamespaceDefinitionStatement(currentScope);</a>
<a name="10055"><span class="lineNum">   10055 </span>            :                                              if (currentNamespaceDefinition != NULL)</a>
<a name="10056"><span class="lineNum">   10056 </span>            :                                                 {</a>
<a name="10057"><span class="lineNum">   10057 </span>            :                                                   SgNamespaceDeclarationStatement* currentNamespaceDeclaration = currentNamespaceDefinition-&gt;get_namespaceDeclaration();</a>
<a name="10058"><span class="lineNum">   10058 </span>            :                                                   mfprintf(mlog [ WARN ] ) (&quot;currentNamespaceDeclaration-&gt;get_name() = %s \n&quot;,currentNamespaceDeclaration-&gt;get_name().str());</a>
<a name="10059"><span class="lineNum">   10059 </span>            :                                                 }</a>
<a name="10060"><span class="lineNum">   10060 </span>            : </a>
<a name="10061"><span class="lineNum">   10061 </span>            :                                              mfprintf(mlog [ WARN ] ) (&quot;functionDeclaration-&gt;get_scope() = %p = %s \n&quot;,functionDeclaration-&gt;get_scope(),functionDeclaration-&gt;get_scope()-&gt;class_name().c_str());</a>
<a name="10062"><span class="lineNum">   10062 </span>            :                                              SgNamespaceDefinitionStatement* functionNamespaceDefinition = isSgNamespaceDefinitionStatement(functionDeclaration-&gt;get_scope());</a>
<a name="10063"><span class="lineNum">   10063 </span>            :                                              if (functionNamespaceDefinition != NULL)</a>
<a name="10064"><span class="lineNum">   10064 </span>            :                                                 {</a>
<a name="10065"><span class="lineNum">   10065 </span>            :                                                   SgNamespaceDeclarationStatement* functionNamespaceDeclaration = functionNamespaceDefinition-&gt;get_namespaceDeclaration();</a>
<a name="10066"><span class="lineNum">   10066 </span>            :                                                   mfprintf(mlog [ WARN ] ) (&quot;functionNamespaceDeclaration-&gt;get_name() = %s \n&quot;,functionNamespaceDeclaration-&gt;get_name().str());</a>
<a name="10067"><span class="lineNum">   10067 </span>            :                                                 }</a>
<a name="10068"><span class="lineNum">   10068 </span>            : #if 0</a>
<a name="10069"><span class="lineNum">   10069 </span>            :                                              SgTemplateInstantiationFunctionDecl* templateInstantiationFunction = isSgTemplateInstantiationFunctionDecl(functionDeclaration);</a>
<a name="10070"><span class="lineNum">   10070 </span>            :                                              mfprintf(mlog [ WARN ] ) (&quot;templateInstantiationFunction-&gt;get_name() = %s \n&quot;,templateInstantiationFunction-&gt;get_name().str());</a>
<a name="10071"><span class="lineNum">   10071 </span>            :                                              functionDeclaration-&gt;get_file_info()-&gt;display(&quot;Warning: name qualification length should be zero: templateInstantiationFunction: debug&quot;);</a>
<a name="10072"><span class="lineNum">   10072 </span>            : </a>
<a name="10073"><span class="lineNum">   10073 </span>            :                                              SgTemplateFunctionDeclaration* templateFunction = templateInstantiationFunction-&gt;get_templateDeclaration();</a>
<a name="10074"><span class="lineNum">   10074 </span>            :                                              ASSERT_not_null(templateFunction);</a>
<a name="10075"><span class="lineNum">   10075 </span>            :                                              templateFunction-&gt;get_file_info()-&gt;display(&quot;Warning: name qualification length should be zero: templateFunction: debug&quot;);</a>
<a name="10076"><span class="lineNum">   10076 </span>            : #endif</a>
<a name="10077"><span class="lineNum">   10077 </span>            : #if 0</a>
<a name="10078"><span class="lineNum">   10078 </span>            :                                              mfprintf(mlog [ WARN ] ) (&quot;ERROR: Why is the name qualification length non-zero: exiting as a test! \n&quot;);</a>
<a name="10079"><span class="lineNum">   10079 </span>            :                                              ROSE_ABORT();</a>
<a name="10080"><span class="lineNum">   10080 </span>            : #endif</a>
<a name="10081"><span class="lineNum">   10081 </span>            :                                            }</a>
<a name="10082"><span class="lineNum">   10082 </span>            : #endif</a>
<a name="10083"><span class="lineNum">   10083 </span>            : #if 0</a>
<a name="10084"><span class="lineNum">   10084 </span>            :                                         mfprintf(mlog [ WARN ] ) (&quot;Need to process the template arguments: exiting as a test! \n&quot;);</a>
<a name="10085"><span class="lineNum">   10085 </span>            :                                         ROSE_ABORT();</a>
<a name="10086"><span class="lineNum">   10086 </span>            : #endif</a>
<a name="10087"><span class="lineNum">   10087 </span>            :                                       }</a>
<a name="10088"><span class="lineNum">   10088 </span>            :                                      else</a>
<a name="10089"><span class="lineNum">   10089 </span>            :                                       {</a>
<a name="10090"><span class="lineNum">   10090 </span>            :                                      // DQ (11/24/2020): This seems like an important case to handle, but perhaps it is handled below.</a>
<a name="10091"><span class="lineNum">   10091 </span>            : #if 0</a>
<a name="10092"><span class="lineNum">   10092 </span>            :                                         printf (&quot;###### In NameQualificationTraversal::evaluateInheritedAttribute(): Why don't we handle the case of a non-template function declaration in a namespace and defined outside of the namespace? \n&quot;);</a>
<a name="10093"><span class="lineNum">   10093 </span>            : #endif</a>
<a name="10094"><span class="lineNum">   10094 </span>            :                                       }</a>
<a name="10095"><span class="lineNum">   10095 </span>            :                                  }</a>
<a name="10096"><span class="lineNum">   10096 </span>            :                             }</a>
<a name="10097"><span class="lineNum">   10097 </span>            : #if 1</a>
<a name="10098"><span class="lineNum">   10098 </span>            :                            else</a>
<a name="10099"><span class="lineNum">   10099 </span>            :                             {</a>
<a name="10100"><span class="lineNum">   10100 </span>            :                            // DQ (10/31/2013): Added to support name qualification on template parameters (see test2013_273.C).</a>
<a name="10101"><span class="lineNum">   10101 </span>            :                            // However, this just leads to over qualification (use of global qualification which is not required).</a>
<a name="10102"><span class="lineNum">   10102 </span>            : </a>
<a name="10103"><span class="lineNum">   10103 </span><span class="lineCov">     242444 :                               SgTemplateInstantiationFunctionDecl* templateFunction = isSgTemplateInstantiationFunctionDecl(functionDeclaration);</span></a>
<a name="10104"><span class="lineNum">   10104 </span>            : </a>
<a name="10105"><span class="lineNum">   10105 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="10106"><span class="lineNum">   10106 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;@@@@@@@@@@@@@ Calling nameQualificationDepth(): functionDeclaration = %p = %s \n&quot;,functionDeclaration,functionDeclaration-&gt;class_name().c_str());</a>
<a name="10107"><span class="lineNum">   10107 </span>            :                               if (templateFunction != NULL)</a>
<a name="10108"><span class="lineNum">   10108 </span>            :                                  {</a>
<a name="10109"><span class="lineNum">   10109 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::evaluateInheritedAttribute(): for case of SgTemplateInstantiationFunctionDecl: templateFunction = %p = %s \n&quot;,</a>
<a name="10110"><span class="lineNum">   10110 </span>            :                                         templateFunction,templateFunction-&gt;class_name().c_str());</a>
<a name="10111"><span class="lineNum">   10111 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;   --- templateFunction-&gt;get_name()         = %s \n&quot;,templateFunction-&gt;get_name().str());</a>
<a name="10112"><span class="lineNum">   10112 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;   --- templateFunction-&gt;get_templateName() = %s \n&quot;,templateFunction-&gt;get_templateName().str());</a>
<a name="10113"><span class="lineNum">   10113 </span>            : #if 0</a>
<a name="10114"><span class="lineNum">   10114 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="10115"><span class="lineNum">   10115 </span>            :                                    ROSE_ABORT();</a>
<a name="10116"><span class="lineNum">   10116 </span>            : #endif</a>
<a name="10117"><span class="lineNum">   10117 </span>            :                                  }</a>
<a name="10118"><span class="lineNum">   10118 </span>            : #endif</a>
<a name="10119"><span class="lineNum">   10119 </span>            : </a>
<a name="10120"><span class="lineNum">   10120 </span>            :                            // DQ (11/16/2013): The point is that we need to handle the name qualification on any associated template arguments not</a>
<a name="10121"><span class="lineNum">   10121 </span>            :                            // on the function itself. So we just want to call nameQualificationDepth(), to get the anem qualification on the template</a>
<a name="10122"><span class="lineNum">   10122 </span>            :                            // arguments, but we can safely ignore the return result since it need not be used to drive name qualification of the</a>
<a name="10123"><span class="lineNum">   10123 </span>            :                            // function.  Either that or we handle the template arguments explicitly.</a>
<a name="10124"><span class="lineNum">   10124 </span>            :                            // int amountOfNameQualificationRequired = nameQualificationDepth(functionDeclaration,currentScope,functionDeclaration);</a>
<a name="10125"><span class="lineNum">   10125 </span>            : #if 0</a>
<a name="10126"><span class="lineNum">   10126 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::evaluateInheritedAttribute(): non-member declaration: functionDeclaration = %p = %s = %s \n&quot;,functionDeclaration,functionDeclaration-&gt;class_name().c_str(),functionDeclaration-&gt;get_name().str());</a>
<a name="10127"><span class="lineNum">   10127 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::evaluateInheritedAttribute(): non-member declaration: currentScope = %p = %s \n&quot;,currentScope,currentScope-&gt;class_name().c_str());</a>
<a name="10128"><span class="lineNum">   10128 </span>            : #endif</a>
<a name="10129"><span class="lineNum">   10129 </span>            :                            // DQ (11/18/2013): Restrict this to template instantiations, else failing some astInterface tests (deepcopy.C).</a>
<a name="10130"><span class="lineNum">   10130 </span>            :                            // nameQualificationDepth(functionDeclaration,currentScope,functionDeclaration);</a>
<a name="10131"><span class="lineNum">   10131 </span><span class="lineCov">     242444 :                               if (templateFunction != NULL)</span></a>
<a name="10132"><span class="lineNum">   10132 </span>            :                                  {</a>
<a name="10133"><span class="lineNum">   10133 </span><span class="lineNoCov">          0 :                                    nameQualificationDepth(functionDeclaration,currentScope,functionDeclaration);</span></a>
<a name="10134"><span class="lineNum">   10134 </span>            :                                  }</a>
<a name="10135"><span class="lineNum">   10135 </span>            : </a>
<a name="10136"><span class="lineNum">   10136 </span>            :                            // setNameQualification(functionDeclaration,amountOfNameQualificationRequired);</a>
<a name="10137"><span class="lineNum">   10137 </span>            :                             }</a>
<a name="10138"><span class="lineNum">   10138 </span>            : #endif</a>
<a name="10139"><span class="lineNum">   10139 </span>            :                        }</a>
<a name="10140"><span class="lineNum">   10140 </span>            :                   }</a>
<a name="10141"><span class="lineNum">   10141 </span>            : </a>
<a name="10142"><span class="lineNum">   10142 </span>            : #if 0</a>
<a name="10143"><span class="lineNum">   10143 </span>            :             // DQ (5/29/2019): Disable this feature as a test for test2019_444.C (it simplifies the name qualification</a>
<a name="10144"><span class="lineNum">   10144 </span>            :             // which will otherwise traverse two sets of function parameters (which can be confusing when debugging)).</a>
<a name="10145"><span class="lineNum">   10145 </span>            :                if (functionDeclaration-&gt;get_type_syntax_is_available() == true)</a>
<a name="10146"><span class="lineNum">   10146 </span>            :                   {</a>
<a name="10147"><span class="lineNum">   10147 </span>            :                  // mfprintf(mlog [ WARN ] ) (&quot;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp; \n&quot;);</a>
<a name="10148"><span class="lineNum">   10148 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Disabling the type_syntax_is_available feature for function parameters \n&quot;);</a>
<a name="10149"><span class="lineNum">   10149 </span>            :                  // mfprintf(mlog [ WARN ] ) (&quot;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp; \n&quot;);</a>
<a name="10150"><span class="lineNum">   10150 </span>            : </a>
<a name="10151"><span class="lineNum">   10151 </span>            :                     ASSERT_not_null(functionDeclaration-&gt;get_type_syntax());</a>
<a name="10152"><span class="lineNum">   10152 </span>            : </a>
<a name="10153"><span class="lineNum">   10153 </span>            :                     functionDeclaration-&gt;set_type_syntax_is_available(false);</a>
<a name="10154"><span class="lineNum">   10154 </span>            :                     functionDeclaration-&gt;set_type_syntax(NULL);</a>
<a name="10155"><span class="lineNum">   10155 </span>            :                   }</a>
<a name="10156"><span class="lineNum">   10156 </span>            :                ROSE_ASSERT(functionDeclaration-&gt;get_type_syntax_is_available() == false);</a>
<a name="10157"><span class="lineNum">   10157 </span>            :                ROSE_ASSERT(functionDeclaration-&gt;get_type_syntax() == NULL);</a>
<a name="10158"><span class="lineNum">   10158 </span>            : #endif</a>
<a name="10159"><span class="lineNum">   10159 </span>            : #if 0</a>
<a name="10160"><span class="lineNum">   10160 </span>            :                printf (&quot;functionDeclaration-&gt;get_type_syntax_is_available() = %s \n&quot;,functionDeclaration-&gt;get_type_syntax_is_available() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="10161"><span class="lineNum">   10161 </span>            : #endif</a>
<a name="10162"><span class="lineNum">   10162 </span>            :             // DQ (4/14/2018): Add the name qualification computation to the parameterList_syntax (since it will be used by preference in the unparser).</a>
<a name="10163"><span class="lineNum">   10163 </span>            :             // generateNestedTraversalWithExplicitScope( SgNode* node, SgScopeStatement* input_currentScope )</a>
<a name="10164"><span class="lineNum">   10164 </span><span class="lineCov">     250901 :                if (functionDeclaration-&gt;get_type_syntax_is_available() == true)</span></a>
<a name="10165"><span class="lineNum">   10165 </span>            :                   {</a>
<a name="10166"><span class="lineNum">   10166 </span>            : #if 0</a>
<a name="10167"><span class="lineNum">   10167 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ \n&quot;);</a>
<a name="10168"><span class="lineNum">   10168 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;@@@@@@@@@@@@@@@@@@ functionDeclaration-&gt;get_type_syntax_is_available() == true @@@@@@@@@@@@@@@@@@ \n&quot;);</a>
<a name="10169"><span class="lineNum">   10169 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;@@@@@@@@@@@@@@@@@@            Process the function parameter syntax            @@@@@@@@@@@@@@@@@@ \n&quot;);</a>
<a name="10170"><span class="lineNum">   10170 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ \n&quot;);</a>
<a name="10171"><span class="lineNum">   10171 </span>            : #endif</a>
<a name="10172"><span class="lineNum">   10172 </span>            : </a>
<a name="10173"><span class="lineNum">   10173 </span>            :                  // DQ (4/20/2018): This is an error reported by Charles, but in a reproducer testcode that does</a>
<a name="10174"><span class="lineNum">   10174 </span>            :                  // not generate the error for me.  I expect that it might be an issue of not recompiling the</a>
<a name="10175"><span class="lineNum">   10175 </span>            :                  // build tree after the header files have been changed between versions that fixed a previous</a>
<a name="10176"><span class="lineNum">   10176 </span>            :                  // bug (unrelated) and was checked in recently. I prefer the assertion, but I will remove it and</a>
<a name="10177"><span class="lineNum">   10177 </span>            :                  // support a conditional check for now (before I leave on vacation).</a>
<a name="10178"><span class="lineNum">   10178 </span>            :                  // ASSERT_not_null(functionDeclaration-&gt;get_parameterList_syntax());</a>
<a name="10179"><span class="lineNum">   10179 </span>            :                  // generateNestedTraversalWithExplicitScope(functionDeclaration-&gt;get_parameterList_syntax(),currentScope);</a>
<a name="10180"><span class="lineNum">   10180 </span><span class="lineCov">     243440 :                     if (functionDeclaration-&gt;get_parameterList_syntax() != NULL)</span></a>
<a name="10181"><span class="lineNum">   10181 </span>            :                        {</a>
<a name="10182"><span class="lineNum">   10182 </span><span class="lineCov">     243440 :                          generateNestedTraversalWithExplicitScope(functionDeclaration-&gt;get_parameterList_syntax(),currentScope);</span></a>
<a name="10183"><span class="lineNum">   10183 </span>            :                        }</a>
<a name="10184"><span class="lineNum">   10184 </span>            :                       else</a>
<a name="10185"><span class="lineNum">   10185 </span>            :                        {</a>
<a name="10186"><span class="lineNum">   10186 </span>            :                       // We might want to output a message here, but I will avoid doing so now.</a>
<a name="10187"><span class="lineNum">   10187 </span>            :                        }</a>
<a name="10188"><span class="lineNum">   10188 </span>            : #if 0</a>
<a name="10189"><span class="lineNum">   10189 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@######@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ \n&quot;);</a>
<a name="10190"><span class="lineNum">   10190 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;@@@@@@@@@@@@@@@@@@ DONE: Process the function parameter syntax @@@@@@@@@@@@@@@@@@ \n&quot;);</a>
<a name="10191"><span class="lineNum">   10191 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;@@@@@@@@@@@@@@@@@@@@@@@@@######@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ \n&quot;);</a>
<a name="10192"><span class="lineNum">   10192 </span>            : #endif</a>
<a name="10193"><span class="lineNum">   10193 </span>            :                   }</a>
<a name="10194"><span class="lineNum">   10194 </span>            : #if 0</a>
<a name="10195"><span class="lineNum">   10195 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ \n&quot;);</a>
<a name="10196"><span class="lineNum">   10196 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;@@@@@@@@@@@@@@@@@@ DONE: Process the function name @@@@@@@@@@@@@@@@@@ \n&quot;);</a>
<a name="10197"><span class="lineNum">   10197 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ \n&quot;);</a>
<a name="10198"><span class="lineNum">   10198 </span>            : #endif</a>
<a name="10199"><span class="lineNum">   10199 </span>            :              }</a>
<a name="10200"><span class="lineNum">   10200 </span>            :             else</a>
<a name="10201"><span class="lineNum">   10201 </span>            :              {</a>
<a name="10202"><span class="lineNum">   10202 </span>            :             // Note that test2005_57.C presents an example that triggers this case and so might be a relevant</a>
<a name="10203"><span class="lineNum">   10203 </span>            :             // test code.  Example: &quot;template&lt;typename T&gt; void foobar (T x){ }&quot;.</a>
<a name="10204"><span class="lineNum">   10204 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="10205"><span class="lineNum">   10205 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;WARNING: SgFunctionDeclaration -- currentScope is not available, not clear why! \n&quot;);</a>
<a name="10206"><span class="lineNum">   10206 </span>            : #endif</a>
<a name="10207"><span class="lineNum">   10207 </span>            :             // ROSE_ASSERT(false);</a>
<a name="10208"><span class="lineNum">   10208 </span>            :              }</a>
<a name="10209"><span class="lineNum">   10209 </span>            : </a>
<a name="10210"><span class="lineNum">   10210 </span>            : #if 0</a>
<a name="10211"><span class="lineNum">   10211 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test at the end of SgFunctionDeclaration name qualification support \n&quot;);</a>
<a name="10212"><span class="lineNum">   10212 </span>            :           ROSE_ABORT();</a>
<a name="10213"><span class="lineNum">   10213 </span>            : #endif</a>
<a name="10214"><span class="lineNum">   10214 </span>            :         }</a>
<a name="10215"><span class="lineNum">   10215 </span>            : </a>
<a name="10216"><span class="lineNum">   10216 </span>            :   // Handle references to SgMemberFunctionDeclaration...</a>
<a name="10217"><span class="lineNum">   10217 </span><span class="lineCov">    2810440 :      SgMemberFunctionDeclaration* memberFunctionDeclaration = isSgMemberFunctionDeclaration(n);</span></a>
<a name="10218"><span class="lineNum">   10218 </span><span class="lineCov">    2810440 :      if (memberFunctionDeclaration != NULL)</span></a>
<a name="10219"><span class="lineNum">   10219 </span>            :         {</a>
<a name="10220"><span class="lineNum">   10220 </span>            :        // Could it be that we only want to do this for the defining declaration? No, since prototypes must also use name qualification!</a>
<a name="10221"><span class="lineNum">   10221 </span>            : </a>
<a name="10222"><span class="lineNum">   10222 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="10223"><span class="lineNum">   10223 </span>            :         // DQ (9/7/2014): Added debugging to verify that this case is supporting name qualification of SgTemplateMemberFunctionDeclaration IR node.</a>
<a name="10224"><span class="lineNum">   10224 </span>            :            if (isSgTemplateMemberFunctionDeclaration(memberFunctionDeclaration) != NULL)</a>
<a name="10225"><span class="lineNum">   10225 </span>            :               {</a>
<a name="10226"><span class="lineNum">   10226 </span>            :                 mfprintf(mlog [ WARN ] ) (&quot;Note: This case supports SgTemplateMemberFunctionDeclaration as well: memberFunctionDeclaration = %p = %s \n&quot;,memberFunctionDeclaration,memberFunctionDeclaration-&gt;get_name().str());</a>
<a name="10227"><span class="lineNum">   10227 </span>            :              // ROSE_ASSERT(false);</a>
<a name="10228"><span class="lineNum">   10228 </span>            :               }</a>
<a name="10229"><span class="lineNum">   10229 </span>            : #endif</a>
<a name="10230"><span class="lineNum">   10230 </span>            : </a>
<a name="10231"><span class="lineNum">   10231 </span>            :        // We need the structural location in scope (not the semantic one).</a>
<a name="10232"><span class="lineNum">   10232 </span><span class="lineCov">      37912 :           SgScopeStatement* currentScope = isSgScopeStatement(memberFunctionDeclaration-&gt;get_parent());</span></a>
<a name="10233"><span class="lineNum">   10233 </span>            : #if 0</a>
<a name="10234"><span class="lineNum">   10234 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;case SgMemberFunctionDeclaration: currentScope = %p \n&quot;,currentScope);</a>
<a name="10235"><span class="lineNum">   10235 </span>            : #endif</a>
<a name="10236"><span class="lineNum">   10236 </span>            : </a>
<a name="10237"><span class="lineNum">   10237 </span>            :        // DQ (4/20/2018): Added new code to support where member functions are used in SgTemplateInstantiationDirectiveStatement.</a>
<a name="10238"><span class="lineNum">   10238 </span>            :        // DQ (4/20/2018): When the parent is not a scope, it could be a SgTemplateInstantiationDirectiveStatement, in which</a>
<a name="10239"><span class="lineNum">   10239 </span>            :        // case we want the parent of that. See test2017_66.C (and previously test2006_08.C) for an example of this case.</a>
<a name="10240"><span class="lineNum">   10240 </span><span class="lineCov">      37912 :           if (currentScope == NULL)</span></a>
<a name="10241"><span class="lineNum">   10241 </span>            :              {</a>
<a name="10242"><span class="lineNum">   10242 </span><span class="lineCov">        304 :                SgTemplateInstantiationDirectiveStatement* templateInstantiationDirectiveStatement = isSgTemplateInstantiationDirectiveStatement(memberFunctionDeclaration-&gt;get_parent());</span></a>
<a name="10243"><span class="lineNum">   10243 </span><span class="lineCov">        304 :                if (templateInstantiationDirectiveStatement != NULL)</span></a>
<a name="10244"><span class="lineNum">   10244 </span>            :                   {</a>
<a name="10245"><span class="lineNum">   10245 </span><span class="lineCov">        304 :                     currentScope = isSgScopeStatement(templateInstantiationDirectiveStatement-&gt;get_parent());</span></a>
<a name="10246"><span class="lineNum">   10246 </span>            : #if 0</a>
<a name="10247"><span class="lineNum">   10247 </span>            :                  // DQ (4/20/2018): Added debugging support.</a>
<a name="10248"><span class="lineNum">   10248 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;In name qualification support: processing SgMemberFunctionDeclaration: found SgTemplateInstantiationDirectiveStatement \n&quot;);</a>
<a name="10249"><span class="lineNum">   10249 </span>            : #endif</a>
<a name="10250"><span class="lineNum">   10250 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="10251"><span class="lineNum">   10251 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Case of (memberFunctionDeclaration != NULL): reset using SgTemplateInstantiationDirectiveStatement: currentScope = %p \n&quot;,currentScope);</a>
<a name="10252"><span class="lineNum">   10252 </span>            : #endif</a>
<a name="10253"><span class="lineNum">   10253 </span>            :                  // Now we should have a valid currentScope.</a>
<a name="10254"><span class="lineNum">   10254 </span><span class="lineCov">        304 :                     ASSERT_not_null(currentScope);</span></a>
<a name="10255"><span class="lineNum">   10255 </span>            :                   }</a>
<a name="10256"><span class="lineNum">   10256 </span>            :              }</a>
<a name="10257"><span class="lineNum">   10257 </span>            : </a>
<a name="10258"><span class="lineNum">   10258 </span>            : #if 0</a>
<a name="10259"><span class="lineNum">   10259 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;currentScope = %p \n&quot;,currentScope);</a>
<a name="10260"><span class="lineNum">   10260 </span>            : #endif</a>
<a name="10261"><span class="lineNum">   10261 </span>            : </a>
<a name="10262"><span class="lineNum">   10262 </span>            :        // ASSERT_not_null(currentScope);</a>
<a name="10263"><span class="lineNum">   10263 </span><span class="lineCov">      37912 :           if (currentScope != NULL)</span></a>
<a name="10264"><span class="lineNum">   10264 </span>            :              {</a>
<a name="10265"><span class="lineNum">   10265 </span>            :             // Handle the function return type...</a>
<a name="10266"><span class="lineNum">   10266 </span><span class="lineCov">      37912 :                ASSERT_not_null(memberFunctionDeclaration-&gt;get_orig_return_type());</span></a>
<a name="10267"><span class="lineNum">   10267 </span><span class="lineCov">      37912 :                ASSERT_not_null(memberFunctionDeclaration-&gt;get_type());</span></a>
<a name="10268"><span class="lineNum">   10268 </span><span class="lineCov">      37912 :                ASSERT_not_null(memberFunctionDeclaration-&gt;get_type()-&gt;get_return_type());</span></a>
<a name="10269"><span class="lineNum">   10269 </span><span class="lineCov">      37912 :                SgType* returnType = memberFunctionDeclaration-&gt;get_type()-&gt;get_return_type();</span></a>
<a name="10270"><span class="lineNum">   10270 </span><span class="lineCov">      37912 :                ASSERT_not_null(returnType);</span></a>
<a name="10271"><span class="lineNum">   10271 </span>            : </a>
<a name="10272"><span class="lineNum">   10272 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || 0</a>
<a name="10273"><span class="lineNum">   10273 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;case SgMemberFunctionDeclaration: returnType = %p = %s = %s \n&quot;,returnType,returnType-&gt;class_name().c_str(),returnType-&gt;unparseToString().c_str());</a>
<a name="10274"><span class="lineNum">   10274 </span>            :                SgType* return_syntax_type = NULL;</a>
<a name="10275"><span class="lineNum">   10275 </span>            :             // DQ (2/25/2019): Use the type syntax when it is available.</a>
<a name="10276"><span class="lineNum">   10276 </span>            :                if (memberFunctionDeclaration-&gt;get_type_syntax_is_available() == true)</a>
<a name="10277"><span class="lineNum">   10277 </span>            :                   {</a>
<a name="10278"><span class="lineNum">   10278 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;case SgMemberFunctionDeclaration: Using the type_syntax since it is available: memberFunctionDeclaration-&gt;get_type_syntax() = %p \n&quot;,</a>
<a name="10279"><span class="lineNum">   10279 </span>            :                          memberFunctionDeclaration-&gt;get_type_syntax());</a>
<a name="10280"><span class="lineNum">   10280 </span>            :                     SgFunctionType* functionType = isSgFunctionType(memberFunctionDeclaration-&gt;get_type_syntax());</a>
<a name="10281"><span class="lineNum">   10281 </span>            :                     ASSERT_not_null(functionType);</a>
<a name="10282"><span class="lineNum">   10282 </span>            :                  // return_syntax_type = memberFunctionDeclaration-&gt;get_type_syntax();</a>
<a name="10283"><span class="lineNum">   10283 </span>            :                     if (functionType-&gt;get_orig_return_type() != NULL)</a>
<a name="10284"><span class="lineNum">   10284 </span>            :                        {</a>
<a name="10285"><span class="lineNum">   10285 </span>            :                          return_syntax_type = functionType-&gt;get_orig_return_type();</a>
<a name="10286"><span class="lineNum">   10286 </span>            :                        }</a>
<a name="10287"><span class="lineNum">   10287 </span>            :                       else</a>
<a name="10288"><span class="lineNum">   10288 </span>            :                        {</a>
<a name="10289"><span class="lineNum">   10289 </span>            :                          return_syntax_type = functionType-&gt;get_return_type();</a>
<a name="10290"><span class="lineNum">   10290 </span>            :                        }</a>
<a name="10291"><span class="lineNum">   10291 </span>            :                     ASSERT_not_null(return_syntax_type);</a>
<a name="10292"><span class="lineNum">   10292 </span>            :                   }</a>
<a name="10293"><span class="lineNum">   10293 </span>            : </a>
<a name="10294"><span class="lineNum">   10294 </span>            :                if (return_syntax_type != NULL)</a>
<a name="10295"><span class="lineNum">   10295 </span>            :                   {</a>
<a name="10296"><span class="lineNum">   10296 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;case SgMemberFunctionDeclaration: return_syntax_type = %p = %s = %s \n&quot;,return_syntax_type,return_syntax_type-&gt;class_name().c_str(),return_syntax_type-&gt;unparseToString().c_str());</a>
<a name="10297"><span class="lineNum">   10297 </span>            :                   }</a>
<a name="10298"><span class="lineNum">   10298 </span>            : #endif</a>
<a name="10299"><span class="lineNum">   10299 </span>            : </a>
<a name="10300"><span class="lineNum">   10300 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="10301"><span class="lineNum">   10301 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;case SgMemberFunctionDeclaration: returnType = %p = %s \n&quot;,returnType,returnType-&gt;class_name().c_str());</a>
<a name="10302"><span class="lineNum">   10302 </span>            :                SgTemplateType* template_returnType = isSgTemplateType(returnType);</a>
<a name="10303"><span class="lineNum">   10303 </span>            :                if (template_returnType != NULL)</a>
<a name="10304"><span class="lineNum">   10304 </span>            :                   {</a>
<a name="10305"><span class="lineNum">   10305 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;template_returnType                                    = %p \n&quot;,template_returnType);</a>
<a name="10306"><span class="lineNum">   10306 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;template_returnType-&gt;get_name()                        = %s \n&quot;,template_returnType-&gt;get_name().str());</a>
<a name="10307"><span class="lineNum">   10307 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;template_returnType-&gt;get_template_parameter_position() = %d \n&quot;,template_returnType-&gt;get_template_parameter_position());</a>
<a name="10308"><span class="lineNum">   10308 </span>            : </a>
<a name="10309"><span class="lineNum">   10309 </span>            :                   }</a>
<a name="10310"><span class="lineNum">   10310 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;   --- memberFunctionDeclaration-&gt;get_firstNondefiningDeclaration() = %p = %s \n&quot;,memberFunctionDeclaration-&gt;get_firstNondefiningDeclaration(),memberFunctionDeclaration-&gt;get_firstNondefiningDeclaration()-&gt;class_name().c_str());</a>
<a name="10311"><span class="lineNum">   10311 </span>            :                if (memberFunctionDeclaration-&gt;get_definingDeclaration() != NULL)</a>
<a name="10312"><span class="lineNum">   10312 </span>            :                   {</a>
<a name="10313"><span class="lineNum">   10313 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;   --- memberFunctionDeclaration-&gt;get_definingDeclaration() = %p = %s \n&quot;,memberFunctionDeclaration-&gt;get_definingDeclaration(),memberFunctionDeclaration-&gt;get_definingDeclaration()-&gt;class_name().c_str());</a>
<a name="10314"><span class="lineNum">   10314 </span>            :                   }</a>
<a name="10315"><span class="lineNum">   10315 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;memberFunctionDeclaration-&gt;get_type() = %p = %s \n&quot;,memberFunctionDeclaration-&gt;get_type(),memberFunctionDeclaration-&gt;get_type()-&gt;class_name().c_str());</a>
<a name="10316"><span class="lineNum">   10316 </span>            : #if 0</a>
<a name="10317"><span class="lineNum">   10317 </span>            :                if (isSgTemplateMemberFunctionDeclaration(memberFunctionDeclaration) != NULL)</a>
<a name="10318"><span class="lineNum">   10318 </span>            :                   {</a>
<a name="10319"><span class="lineNum">   10319 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test: memberFunctionDeclaration = %p = %s \n&quot;,memberFunctionDeclaration,memberFunctionDeclaration-&gt;get_name().str());</a>
<a name="10320"><span class="lineNum">   10320 </span>            :                  // ROSE_ASSERT(false);</a>
<a name="10321"><span class="lineNum">   10321 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ \n&quot;);</a>
<a name="10322"><span class="lineNum">   10322 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ \n&quot;);</a>
<a name="10323"><span class="lineNum">   10323 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ \n&quot;);</a>
<a name="10324"><span class="lineNum">   10324 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ \n&quot;);</a>
<a name="10325"><span class="lineNum">   10325 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ \n&quot;);</a>
<a name="10326"><span class="lineNum">   10326 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ \n&quot;);</a>
<a name="10327"><span class="lineNum">   10327 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ \n&quot;);</a>
<a name="10328"><span class="lineNum">   10328 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ \n&quot;);</a>
<a name="10329"><span class="lineNum">   10329 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ \n&quot;);</a>
<a name="10330"><span class="lineNum">   10330 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ \n&quot;);</a>
<a name="10331"><span class="lineNum">   10331 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ \n&quot;);</a>
<a name="10332"><span class="lineNum">   10332 </span>            :                   }</a>
<a name="10333"><span class="lineNum">   10333 </span>            : #endif</a>
<a name="10334"><span class="lineNum">   10334 </span>            : #endif</a>
<a name="10335"><span class="lineNum">   10335 </span>            : </a>
<a name="10336"><span class="lineNum">   10336 </span><span class="lineCov">      37912 :                SgDeclarationStatement* declaration = getDeclarationAssociatedWithType(returnType);</span></a>
<a name="10337"><span class="lineNum">   10337 </span><span class="lineCov">      37912 :                if (declaration != NULL)</span></a>
<a name="10338"><span class="lineNum">   10338 </span>            :                   {</a>
<a name="10339"><span class="lineNum">   10339 </span>            : </a>
<a name="10340"><span class="lineNum">   10340 </span>            : #if 0</a>
<a name="10341"><span class="lineNum">   10341 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;$$$$$$$$$$ Calling nameQualificationDepth for return type: $$$$$$$$$$$ \n&quot;);</a>
<a name="10342"><span class="lineNum">   10342 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot; --- declaration               = %p = %s \n&quot;,declaration,declaration-&gt;class_name().c_str());</a>
<a name="10343"><span class="lineNum">   10343 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot; --- currentScope              = %p = %s \n&quot;,currentScope,currentScope-&gt;class_name().c_str());</a>
<a name="10344"><span class="lineNum">   10344 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot; --- memberFunctionDeclaration = %p = %s \n&quot;,memberFunctionDeclaration,memberFunctionDeclaration-&gt;class_name().c_str());</a>
<a name="10345"><span class="lineNum">   10345 </span>            : #endif</a>
<a name="10346"><span class="lineNum">   10346 </span><span class="lineCov">      21456 :                     int amountOfNameQualificationRequiredForReturnType = nameQualificationDepth(declaration,currentScope,memberFunctionDeclaration);</span></a>
<a name="10347"><span class="lineNum">   10347 </span>            : </a>
<a name="10348"><span class="lineNum">   10348 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="10349"><span class="lineNum">   10349 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;SgMemberFunctionDeclaration's return type: amountOfNameQualificationRequiredForType = %d \n&quot;,amountOfNameQualificationRequiredForReturnType);</a>
<a name="10350"><span class="lineNum">   10350 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Putting the name qualification for the type into the return type of SgMemberFunctionDeclaration = %p = %s \n&quot;,memberFunctionDeclaration,memberFunctionDeclaration-&gt;get_name().str());</a>
<a name="10351"><span class="lineNum">   10351 </span>            : #endif</a>
<a name="10352"><span class="lineNum">   10352 </span>            : #if 0</a>
<a name="10353"><span class="lineNum">   10353 </span>            :                  // DQ (8/3/2019): Output the aliasSymbolCausalNodeSet.  To support multiple files, or the stame file read twice,</a>
<a name="10354"><span class="lineNum">   10354 </span>            :                  // we need to clear this set before starting the name qualification process.</a>
<a name="10355"><span class="lineNum">   10355 </span>            :                     SgSymbolTable::display_aliasSymbolCausalNodeSet();</a>
<a name="10356"><span class="lineNum">   10356 </span>            : #endif</a>
<a name="10357"><span class="lineNum">   10357 </span>            : #if 0</a>
<a name="10358"><span class="lineNum">   10358 </span>            :                  // DQ (8/3/2019): Trying to understand why we generate two levels of name qualification before the using directive.</a>
<a name="10359"><span class="lineNum">   10359 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="10360"><span class="lineNum">   10360 </span>            :                     ROSE_ABORT();</a>
<a name="10361"><span class="lineNum">   10361 </span>            : #endif</a>
<a name="10362"><span class="lineNum">   10362 </span><span class="lineCov">      21456 :                     setNameQualificationReturnType(memberFunctionDeclaration,declaration,amountOfNameQualificationRequiredForReturnType);</span></a>
<a name="10363"><span class="lineNum">   10363 </span>            :                   }</a>
<a name="10364"><span class="lineNum">   10364 </span>            :                  else</a>
<a name="10365"><span class="lineNum">   10365 </span>            :                   {</a>
<a name="10366"><span class="lineNum">   10366 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="10367"><span class="lineNum">   10367 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;declaration == NULL: could not put name qualification for the type into the return type of SgMemberFunctionDeclaration = %p = %s \n&quot;,memberFunctionDeclaration,memberFunctionDeclaration-&gt;get_name().str());</a>
<a name="10368"><span class="lineNum">   10368 </span>            : #endif</a>
<a name="10369"><span class="lineNum">   10369 </span>            :                   }</a>
<a name="10370"><span class="lineNum">   10370 </span>            : </a>
<a name="10371"><span class="lineNum">   10371 </span>            : #if 0</a>
<a name="10372"><span class="lineNum">   10372 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Calling traverseType on SgMemberFunctionDeclaration = %p = %s name = %s \n&quot;,memberFunctionDeclaration,memberFunctionDeclaration-&gt;class_name().c_str(),memberFunctionDeclaration-&gt;get_name().str());</a>
<a name="10373"><span class="lineNum">   10373 </span>            : #endif</a>
<a name="10374"><span class="lineNum">   10374 </span>            :             // DQ (6/3/2011): Traverse the type to set any possible template arguments (or other subtypes?) that require name qualification.</a>
<a name="10375"><span class="lineNum">   10375 </span><span class="lineCov">      37912 :                traverseType(returnType,memberFunctionDeclaration,currentScope,memberFunctionDeclaration);</span></a>
<a name="10376"><span class="lineNum">   10376 </span>            : </a>
<a name="10377"><span class="lineNum">   10377 </span>            : #if 0</a>
<a name="10378"><span class="lineNum">   10378 </span>            :                if (isSgTemplateInstantiationMemberFunctionDecl(memberFunctionDeclaration) != NULL)</a>
<a name="10379"><span class="lineNum">   10379 </span>            :                   {</a>
<a name="10380"><span class="lineNum">   10380 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ \n&quot;);</a>
<a name="10381"><span class="lineNum">   10381 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;@@@@@@@@@@@@@@@@@@ Process the member function name @@@@@@@@@@@@@@@@@@ \n&quot;);</a>
<a name="10382"><span class="lineNum">   10382 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ \n&quot;);</a>
<a name="10383"><span class="lineNum">   10383 </span>            :                   }</a>
<a name="10384"><span class="lineNum">   10384 </span>            : #endif</a>
<a name="10385"><span class="lineNum">   10385 </span>            : #if 0</a>
<a name="10386"><span class="lineNum">   10386 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Process the member function: SgMemberFunctionDeclaration = %p = %s name = %s \n&quot;,</a>
<a name="10387"><span class="lineNum">   10387 </span>            :                     memberFunctionDeclaration,memberFunctionDeclaration-&gt;class_name().c_str(),memberFunctionDeclaration-&gt;get_name().str());</a>
<a name="10388"><span class="lineNum">   10388 </span>            : #endif</a>
<a name="10389"><span class="lineNum">   10389 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="10390"><span class="lineNum">   10390 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Don't forget possible covariant return types for SgMemberFunctionDeclaration IR nodes \n&quot;);</a>
<a name="10391"><span class="lineNum">   10391 </span>            : </a>
<a name="10392"><span class="lineNum">   10392 </span>            :             // Only use name qualification where the scopes of the declaration's use (currentScope) is not the same</a>
<a name="10393"><span class="lineNum">   10393 </span>            :             // as the scope of the function declaration.  However, the analysis should work and determin that the</a>
<a name="10394"><span class="lineNum">   10394 </span>            :             // required name qualification length is zero.</a>
<a name="10395"><span class="lineNum">   10395 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;I would like to not have to have this SgMemberFunctionDeclaration logic, we should get the name qualification correct more directly. \n&quot;);</a>
<a name="10396"><span class="lineNum">   10396 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;   --- memberFunctionDeclaration-&gt;get_scope() = %p = %s \n&quot;,memberFunctionDeclaration-&gt;get_scope(),memberFunctionDeclaration-&gt;get_scope()-&gt;class_name().c_str());</a>
<a name="10397"><span class="lineNum">   10397 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;   --- currentScope                           = %p = %s \n&quot;,currentScope,currentScope-&gt;class_name().c_str());</a>
<a name="10398"><span class="lineNum">   10398 </span>            : #endif</a>
<a name="10399"><span class="lineNum">   10399 </span><span class="lineCov">      37912 :                if (currentScope != memberFunctionDeclaration-&gt;get_scope())</span></a>
<a name="10400"><span class="lineNum">   10400 </span>            :                   {</a>
<a name="10401"><span class="lineNum">   10401 </span>            :                  // DQ (1/21/2013): Note that the concept of equivalent scope is fine here if it only tests the equivalence of the pointers.</a>
<a name="10402"><span class="lineNum">   10402 </span>            :                  // We can't have member functions in namespaces so we don't require that more general test for scope equivalence.</a>
<a name="10403"><span class="lineNum">   10403 </span>            : </a>
<a name="10404"><span class="lineNum">   10404 </span><span class="lineCov">      10811 :                     int amountOfNameQualificationRequired = nameQualificationDepth(memberFunctionDeclaration,currentScope,memberFunctionDeclaration);</span></a>
<a name="10405"><span class="lineNum">   10405 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="10406"><span class="lineNum">   10406 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;SgMemberFunctionDeclaration: amountOfNameQualificationRequired = %d \n&quot;,amountOfNameQualificationRequired);</a>
<a name="10407"><span class="lineNum">   10407 </span>            : #endif</a>
<a name="10408"><span class="lineNum">   10408 </span><span class="lineCov">      10811 :                     setNameQualification(memberFunctionDeclaration,amountOfNameQualificationRequired);</span></a>
<a name="10409"><span class="lineNum">   10409 </span>            : </a>
<a name="10410"><span class="lineNum">   10410 </span>            : #if 0</a>
<a name="10411"><span class="lineNum">   10411 </span>            :                     if (isSgTemplateInstantiationMemberFunctionDecl(memberFunctionDeclaration) != NULL)</a>
<a name="10412"><span class="lineNum">   10412 </span>            :                       {</a>
<a name="10413"><span class="lineNum">   10413 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! currentScope != memberFunctionDeclaration-&gt;get_scope() \n&quot;);</a>
<a name="10414"><span class="lineNum">   10414 </span>            :                          ROSE_ABORT();</a>
<a name="10415"><span class="lineNum">   10415 </span>            :                        }</a>
<a name="10416"><span class="lineNum">   10416 </span>            : #endif</a>
<a name="10417"><span class="lineNum">   10417 </span>            :                   }</a>
<a name="10418"><span class="lineNum">   10418 </span>            :                  else</a>
<a name="10419"><span class="lineNum">   10419 </span>            :                   {</a>
<a name="10420"><span class="lineNum">   10420 </span>            :                  // DQ (9/7/2014): This branch is taken by the non-defining template member functions defined outside of their</a>
<a name="10421"><span class="lineNum">   10421 </span>            :                  // associated template class declarations. There are also other cases where this branch is taken.</a>
<a name="10422"><span class="lineNum">   10422 </span>            : </a>
<a name="10423"><span class="lineNum">   10423 </span>            :                  // Don't know what test code exercises this case (see test2005_73.C).</a>
<a name="10424"><span class="lineNum">   10424 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || 0</a>
<a name="10425"><span class="lineNum">   10425 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;WARNING: SgMemberFunctionDeclaration -- currentScope is not available through predicate (currentScope != memberFunctionDeclaration-&gt;get_scope()), not clear why! \n&quot;);</a>
<a name="10426"><span class="lineNum">   10426 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;   --- memberFunctionDeclaration-&gt;get_scope() = %p = %s \n&quot;,memberFunctionDeclaration-&gt;get_scope(),memberFunctionDeclaration-&gt;get_scope()-&gt;class_name().c_str());</a>
<a name="10427"><span class="lineNum">   10427 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;   --- currentScope                           = %p = %s \n&quot;,currentScope,currentScope-&gt;class_name().c_str());</a>
<a name="10428"><span class="lineNum">   10428 </span>            : #endif</a>
<a name="10429"><span class="lineNum">   10429 </span>            :                  // ROSE_ASSERT(false);</a>
<a name="10430"><span class="lineNum">   10430 </span>            : #if 0</a>
<a name="10431"><span class="lineNum">   10431 </span>            :                  // DQ (4/2/2018): I now think that we don't need this code, the fix for Cxx11_tests/test2018_69.C was in the unparser, not the name qualification (I think).</a>
<a name="10432"><span class="lineNum">   10432 </span>            :                  // I think it is not allowed bacause the specialization of templates is not allowed in the class where they are declared.</a>
<a name="10433"><span class="lineNum">   10433 </span>            : </a>
<a name="10434"><span class="lineNum">   10434 </span>            :                  // DQ (4/1/2018): We need to have the name qualification computed for any possible template arguments to the member function.</a>
<a name="10435"><span class="lineNum">   10435 </span>            :                  // This fix is similar to that for the case of non-member functions (yesterday, see Cxx11_tests/test2018_68.C). This fix is</a>
<a name="10436"><span class="lineNum">   10436 </span>            :                  // relevant to Cxx11_tests/test2018_69.C.</a>
<a name="10437"><span class="lineNum">   10437 </span>            :                     int amountOfNameQualificationRequired = nameQualificationDepth(memberFunctionDeclaration,currentScope,memberFunctionDeclaration);</a>
<a name="10438"><span class="lineNum">   10438 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="10439"><span class="lineNum">   10439 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;SgMemberFunctionDeclaration: amountOfNameQualificationRequired = %d \n&quot;,amountOfNameQualificationRequired);</a>
<a name="10440"><span class="lineNum">   10440 </span>            : #endif</a>
<a name="10441"><span class="lineNum">   10441 </span>            : </a>
<a name="10442"><span class="lineNum">   10442 </span>            : #if 1</a>
<a name="10443"><span class="lineNum">   10443 </span>            :                     if (isSgTemplateInstantiationMemberFunctionDecl(memberFunctionDeclaration) != NULL)</a>
<a name="10444"><span class="lineNum">   10444 </span>            :                       {</a>
<a name="10445"><span class="lineNum">   10445 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! currentScope == memberFunctionDeclaration-&gt;get_scope() \n&quot;);</a>
<a name="10446"><span class="lineNum">   10446 </span>            :                          ROSE_ABORT();</a>
<a name="10447"><span class="lineNum">   10447 </span>            :                        }</a>
<a name="10448"><span class="lineNum">   10448 </span>            : #endif</a>
<a name="10449"><span class="lineNum">   10449 </span>            : #endif</a>
<a name="10450"><span class="lineNum">   10450 </span>            :                   }</a>
<a name="10451"><span class="lineNum">   10451 </span>            : </a>
<a name="10452"><span class="lineNum">   10452 </span>            :             // DQ (4/14/2018): Add the name qualification computation to the parameterList_syntax (since it will be used by preference in the unparser).</a>
<a name="10453"><span class="lineNum">   10453 </span>            :             // generateNestedTraversalWithExplicitScope( SgNode* node, SgScopeStatement* input_currentScope )</a>
<a name="10454"><span class="lineNum">   10454 </span><span class="lineCov">      37912 :                if (memberFunctionDeclaration-&gt;get_type_syntax_is_available() == true)</span></a>
<a name="10455"><span class="lineNum">   10455 </span>            :                   {</a>
<a name="10456"><span class="lineNum">   10456 </span>            : #if 0</a>
<a name="10457"><span class="lineNum">   10457 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ \n&quot;);</a>
<a name="10458"><span class="lineNum">   10458 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;@@@@@@@@@@@@@@@@@@ Process the member function parameter syntax @@@@@@@@@@@@@@@@@@ \n&quot;);</a>
<a name="10459"><span class="lineNum">   10459 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ \n&quot;);</a>
<a name="10460"><span class="lineNum">   10460 </span>            : #endif</a>
<a name="10461"><span class="lineNum">   10461 </span><span class="lineCov">      16444 :                     ASSERT_not_null(memberFunctionDeclaration-&gt;get_parameterList_syntax());</span></a>
<a name="10462"><span class="lineNum">   10462 </span><span class="lineCov">      16444 :                     generateNestedTraversalWithExplicitScope(memberFunctionDeclaration-&gt;get_parameterList_syntax(),currentScope);</span></a>
<a name="10463"><span class="lineNum">   10463 </span>            : #if 0</a>
<a name="10464"><span class="lineNum">   10464 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@######@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ \n&quot;);</a>
<a name="10465"><span class="lineNum">   10465 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;@@@@@@@@@@@@@@@@@@ DONE: Process the member function parameter syntax @@@@@@@@@@@@@@@@@@ \n&quot;);</a>
<a name="10466"><span class="lineNum">   10466 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;@@@@@@@@@@@@@@@@@@@@@@@@@######@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ \n&quot;);</a>
<a name="10467"><span class="lineNum">   10467 </span>            : #endif</a>
<a name="10468"><span class="lineNum">   10468 </span>            :                   }</a>
<a name="10469"><span class="lineNum">   10469 </span>            :              }</a>
<a name="10470"><span class="lineNum">   10470 </span>            :             else</a>
<a name="10471"><span class="lineNum">   10471 </span>            :              {</a>
<a name="10472"><span class="lineNum">   10472 </span>            :             // Note that test2005_63.C presents an example that triggers this case and so might be a relevant.</a>
<a name="10473"><span class="lineNum">   10473 </span>            :             // This is also the reason why test2005_73.C is failing!!!  Fix it tomorrow!!! (SgTemplateInstantiationDirectiveStatement)</a>
<a name="10474"><span class="lineNum">   10474 </span><span class="lineNoCov">          0 :                SgDeclarationStatement* currentStatement = isSgDeclarationStatement(memberFunctionDeclaration-&gt;get_parent());</span></a>
<a name="10475"><span class="lineNum">   10475 </span>            : </a>
<a name="10476"><span class="lineNum">   10476 </span>            :             // DQ (9/4/2014): Lambda functions (in SgLambdaExp) are an example where this fails.</a>
<a name="10477"><span class="lineNum">   10477 </span>            :             // ASSERT_not_null(currentStatement);</a>
<a name="10478"><span class="lineNum">   10478 </span><span class="lineNoCov">          0 :                if (currentStatement != NULL)</span></a>
<a name="10479"><span class="lineNum">   10479 </span>            :                   {</a>
<a name="10480"><span class="lineNum">   10480 </span><span class="lineNoCov">          0 :                     SgScopeStatement* currentScope = isSgScopeStatement(currentStatement-&gt;get_parent());</span></a>
<a name="10481"><span class="lineNum">   10481 </span><span class="lineNoCov">          0 :                     if (currentScope != NULL)</span></a>
<a name="10482"><span class="lineNum">   10482 </span>            :                        {</a>
<a name="10483"><span class="lineNum">   10483 </span><span class="lineNoCov">          0 :                          int amountOfNameQualificationRequired = nameQualificationDepth(memberFunctionDeclaration,currentScope,memberFunctionDeclaration);</span></a>
<a name="10484"><span class="lineNum">   10484 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="10485"><span class="lineNum">   10485 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;SgMemberFunctionDeclaration: amountOfNameQualificationRequired = %d \n&quot;,amountOfNameQualificationRequired);</a>
<a name="10486"><span class="lineNum">   10486 </span>            : #endif</a>
<a name="10487"><span class="lineNum">   10487 </span><span class="lineNoCov">          0 :                          setNameQualification(memberFunctionDeclaration,amountOfNameQualificationRequired);</span></a>
<a name="10488"><span class="lineNum">   10488 </span>            : </a>
<a name="10489"><span class="lineNum">   10489 </span>            :                       // DQ (4/14/2018): Add the name qualification computation to the parameterList_syntax (since it will be used by preference in the unparser).</a>
<a name="10490"><span class="lineNum">   10490 </span>            :                       // generateNestedTraversalWithExplicitScope( SgNode* node, SgScopeStatement* input_currentScope )</a>
<a name="10491"><span class="lineNum">   10491 </span><span class="lineNoCov">          0 :                          if (memberFunctionDeclaration-&gt;get_type_syntax_is_available() == true)</span></a>
<a name="10492"><span class="lineNum">   10492 </span>            :                             {</a>
<a name="10493"><span class="lineNum">   10493 </span>            :                            // DQ (4/14/2018): I can't detect that we have any test codes that reach here!</a>
<a name="10494"><span class="lineNum">   10494 </span>            :                            // This might be a subject to ingestigate later.</a>
<a name="10495"><span class="lineNum">   10495 </span>            : #if 0</a>
<a name="10496"><span class="lineNum">   10496 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ \n&quot;);</a>
<a name="10497"><span class="lineNum">   10497 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;@@@@@@@@@@@@@@@@@@ Process the member function parameter syntax: scope computed from parent @@@@@@@@@@@@@@@@@@ \n&quot;);</a>
<a name="10498"><span class="lineNum">   10498 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ \n&quot;);</a>
<a name="10499"><span class="lineNum">   10499 </span>            : #endif</a>
<a name="10500"><span class="lineNum">   10500 </span><span class="lineNoCov">          0 :                               ASSERT_not_null(memberFunctionDeclaration-&gt;get_parameterList_syntax());</span></a>
<a name="10501"><span class="lineNum">   10501 </span><span class="lineNoCov">          0 :                               generateNestedTraversalWithExplicitScope(memberFunctionDeclaration-&gt;get_parameterList_syntax(),currentScope);</span></a>
<a name="10502"><span class="lineNum">   10502 </span>            : #if 0</a>
<a name="10503"><span class="lineNum">   10503 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@######@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ \n&quot;);</a>
<a name="10504"><span class="lineNum">   10504 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;@@@@@@@@@@@@@@@@@@ DONE: Process the member function parameter syntax: scope computed from parent @@@@@@@@@@@@@@@@@@ \n&quot;);</a>
<a name="10505"><span class="lineNum">   10505 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;@@@@@@@@@@@@@@@@@@@@@@@@@######@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ \n&quot;);</a>
<a name="10506"><span class="lineNum">   10506 </span>            : #endif</a>
<a name="10507"><span class="lineNum">   10507 </span>            :                             }</a>
<a name="10508"><span class="lineNum">   10508 </span>            :                        }</a>
<a name="10509"><span class="lineNum">   10509 </span>            :                       else</a>
<a name="10510"><span class="lineNum">   10510 </span>            :                        {</a>
<a name="10511"><span class="lineNum">   10511 </span><span class="lineNoCov">          0 :                          mfprintf(mlog [ WARN ] ) (&quot;WARNING: SgMemberFunctionDeclaration -- currentScope is not available through parent SgDeclarationStatement, not clear why! \n&quot;);</span></a>
<a name="10512"><span class="lineNum">   10512 </span><span class="lineNoCov">          0 :                          ROSE_ABORT();</span></a>
<a name="10513"><span class="lineNum">   10513 </span>            :                        }</a>
<a name="10514"><span class="lineNum">   10514 </span>            : </a>
<a name="10515"><span class="lineNum">   10515 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="10516"><span class="lineNum">   10516 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;WARNING: SgMemberFunctionDeclaration -- currentScope is not available, not clear why! \n&quot;);</a>
<a name="10517"><span class="lineNum">   10517 </span>            : #endif</a>
<a name="10518"><span class="lineNum">   10518 </span>            :                  // ROSE_ASSERT(false);</a>
<a name="10519"><span class="lineNum">   10519 </span>            :                   }</a>
<a name="10520"><span class="lineNum">   10520 </span>            :                  else</a>
<a name="10521"><span class="lineNum">   10521 </span>            :                   {</a>
<a name="10522"><span class="lineNum">   10522 </span>            :                  // This should only be a lambda function defined in a SgLambdaExp.</a>
<a name="10523"><span class="lineNum">   10523 </span><span class="lineNoCov">          0 :                     ASSERT_not_null(isSgLambdaExp(memberFunctionDeclaration-&gt;get_parent()));</span></a>
<a name="10524"><span class="lineNum">   10524 </span>            :                   }</a>
<a name="10525"><span class="lineNum">   10525 </span>            :              }</a>
<a name="10526"><span class="lineNum">   10526 </span>            : #if 0</a>
<a name="10527"><span class="lineNum">   10527 </span>            :           if (isSgTemplateInstantiationMemberFunctionDecl(memberFunctionDeclaration) != NULL)</a>
<a name="10528"><span class="lineNum">   10528 </span>            :              {</a>
<a name="10529"><span class="lineNum">   10529 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ \n&quot;);</a>
<a name="10530"><span class="lineNum">   10530 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;@@@@@@@@@@@@@@@@@@ DONE: Process the member function name @@@@@@@@@@@@@@@@@@ \n&quot;);</a>
<a name="10531"><span class="lineNum">   10531 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ \n&quot;);</a>
<a name="10532"><span class="lineNum">   10532 </span>            : </a>
<a name="10533"><span class="lineNum">   10533 </span>            : #if 0</a>
<a name="10534"><span class="lineNum">   10534 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Exitng as a test! \n&quot;);</a>
<a name="10535"><span class="lineNum">   10535 </span>            :                ROSE_ABORT();</a>
<a name="10536"><span class="lineNum">   10536 </span>            : #endif</a>
<a name="10537"><span class="lineNum">   10537 </span>            :              }</a>
<a name="10538"><span class="lineNum">   10538 </span>            : #endif</a>
<a name="10539"><span class="lineNum">   10539 </span>            :         }</a>
<a name="10540"><span class="lineNum">   10540 </span>            : </a>
<a name="10541"><span class="lineNum">   10541 </span>            :   // DQ (6/3/2017): Since the underling template instantiation is not shared, and becasue it is traversed explicitly,</a>
<a name="10542"><span class="lineNum">   10542 </span>            :   // We can (I think) reserve the name qualification of the template instantiation to the instantiated template function</a>
<a name="10543"><span class="lineNum">   10543 </span>            :   // directly and need not support an additional (redundant) evaluation of name qualification here.</a>
<a name="10544"><span class="lineNum">   10544 </span>            : </a>
<a name="10545"><span class="lineNum">   10545 </span>            :   // DQ (4/3/2014): Added new case to address no longer traversing this IR node's member.</a>
<a name="10546"><span class="lineNum">   10546 </span>            :   // See test2005_73.C.</a>
<a name="10547"><span class="lineNum">   10547 </span><span class="lineCov">    2810440 :      SgTemplateInstantiationDirectiveStatement* templateInstantiationDirectiveStatement = isSgTemplateInstantiationDirectiveStatement(n);</span></a>
<a name="10548"><span class="lineNum">   10548 </span><span class="lineCov">    2810440 :      if (templateInstantiationDirectiveStatement != NULL)</span></a>
<a name="10549"><span class="lineNum">   10549 </span>            :         {</a>
<a name="10550"><span class="lineNum">   10550 </span>            :        // DQ (4/3/2014): We no longer traverse the declaration referenced in this IR node so we</a>
<a name="10551"><span class="lineNum">   10551 </span>            :        // have to handle the name qualification requiredments for the associated declaration directly.</a>
<a name="10552"><span class="lineNum">   10552 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || 0</a>
<a name="10553"><span class="lineNum">   10553 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;################ Processing SgTemplateInstantiationDirectiveStatement (name qualification is handled within the nested template instantiation) \n&quot;);</a>
<a name="10554"><span class="lineNum">   10554 </span>            : #endif</a>
<a name="10555"><span class="lineNum">   10555 </span>            : </a>
<a name="10556"><span class="lineNum">   10556 </span>            : #if 0</a>
<a name="10557"><span class="lineNum">   10557 </span>            :        // DQ (6/3/2017): Commenting out this redundant handling because it is addressed in the nested template instantiation declaration directly.</a>
<a name="10558"><span class="lineNum">   10558 </span>            : </a>
<a name="10559"><span class="lineNum">   10559 </span>            :        // Note that test2005_63.C presents an example that triggers this case and so might be a relevant.</a>
<a name="10560"><span class="lineNum">   10560 </span>            :        // This is also the reason why test2005_73.C is failing!!!  Fix it tomorrow!!! (SgTemplateInstantiationDirectiveStatement)</a>
<a name="10561"><span class="lineNum">   10561 </span>            :        // SgDeclarationStatement* currentStatement = isSgDeclarationStatement(memberFunctionDeclaration-&gt;get_parent());</a>
<a name="10562"><span class="lineNum">   10562 </span>            :           SgDeclarationStatement* declarationStatement = isSgDeclarationStatement(templateInstantiationDirectiveStatement-&gt;get_declaration());</a>
<a name="10563"><span class="lineNum">   10563 </span>            :           ASSERT_not_null(declarationStatement);</a>
<a name="10564"><span class="lineNum">   10564 </span>            :           SgDeclarationStatement* currentStatement = isSgDeclarationStatement(declarationStatement-&gt;get_parent());</a>
<a name="10565"><span class="lineNum">   10565 </span>            :           if (currentStatement == NULL)</a>
<a name="10566"><span class="lineNum">   10566 </span>            :              {</a>
<a name="10567"><span class="lineNum">   10567 </span>            : #if 0</a>
<a name="10568"><span class="lineNum">   10568 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;In name qualification: case SgTemplateInstantiationDirectiveStatement: Using backup mechanism to generate current statement (because EDG 4.8 shared template instantiations) \n&quot;);</a>
<a name="10569"><span class="lineNum">   10569 </span>            : #endif</a>
<a name="10570"><span class="lineNum">   10570 </span>            :                currentStatement = templateInstantiationDirectiveStatement;</a>
<a name="10571"><span class="lineNum">   10571 </span>            :              }</a>
<a name="10572"><span class="lineNum">   10572 </span>            :           ASSERT_not_null(currentStatement);</a>
<a name="10573"><span class="lineNum">   10573 </span>            : #if 0</a>
<a name="10574"><span class="lineNum">   10574 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;declarationStatement = %p = %s \n&quot;,declarationStatement,declarationStatement-&gt;class_name().c_str());</a>
<a name="10575"><span class="lineNum">   10575 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;currentStatement     = %p = %s \n&quot;,currentStatement,currentStatement-&gt;class_name().c_str());</a>
<a name="10576"><span class="lineNum">   10576 </span>            : #endif</a>
<a name="10577"><span class="lineNum">   10577 </span>            :           SgScopeStatement* currentScope = isSgScopeStatement(currentStatement-&gt;get_parent());</a>
<a name="10578"><span class="lineNum">   10578 </span>            :           if (currentScope != NULL)</a>
<a name="10579"><span class="lineNum">   10579 </span>            :              {</a>
<a name="10580"><span class="lineNum">   10580 </span>            : #if 0</a>
<a name="10581"><span class="lineNum">   10581 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;currentScope         = %p = %s \n&quot;,currentScope,currentScope-&gt;class_name().c_str());</a>
<a name="10582"><span class="lineNum">   10582 </span>            : #endif</a>
<a name="10583"><span class="lineNum">   10583 </span>            :                int amountOfNameQualificationRequired = nameQualificationDepth(declarationStatement,currentScope,declarationStatement);</a>
<a name="10584"><span class="lineNum">   10584 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="10585"><span class="lineNum">   10585 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;SgTemplateInstantiationDirectiveStatement: amountOfNameQualificationRequired = %d \n&quot;,amountOfNameQualificationRequired);</a>
<a name="10586"><span class="lineNum">   10586 </span>            : #endif</a>
<a name="10587"><span class="lineNum">   10587 </span>            : </a>
<a name="10588"><span class="lineNum">   10588 </span>            :             // Since the reference to the class or function declaration is shared, we might want to</a>
<a name="10589"><span class="lineNum">   10589 </span>            :             // attached the name qualification to the SgTemplateInstantiationDirectiveStatement instead.</a>
<a name="10590"><span class="lineNum">   10590 </span>            :             // setNameQualification(templateInstantiationDirectiveStatement-&gt;get_declaration(),amountOfNameQualificationRequired);</a>
<a name="10591"><span class="lineNum">   10591 </span>            :                SgClassDeclaration* classDeclaration       = isSgClassDeclaration(declarationStatement);</a>
<a name="10592"><span class="lineNum">   10592 </span>            :                SgFunctionDeclaration* functionDeclaration = isSgFunctionDeclaration(declarationStatement);</a>
<a name="10593"><span class="lineNum">   10593 </span>            : </a>
<a name="10594"><span class="lineNum">   10594 </span>            :             // DQ (7/22/2017): We will have to also handle other types of template instantiations as well.</a>
<a name="10595"><span class="lineNum">   10595 </span>            :             // (e.g. for typedefs, and variables).</a>
<a name="10596"><span class="lineNum">   10596 </span>            : </a>
<a name="10597"><span class="lineNum">   10597 </span>            :                if (classDeclaration != NULL)</a>
<a name="10598"><span class="lineNum">   10598 </span>            :                   {</a>
<a name="10599"><span class="lineNum">   10599 </span>            :                     setNameQualification(classDeclaration,amountOfNameQualificationRequired);</a>
<a name="10600"><span class="lineNum">   10600 </span>            :                   }</a>
<a name="10601"><span class="lineNum">   10601 </span>            :                  else</a>
<a name="10602"><span class="lineNum">   10602 </span>            :                   {</a>
<a name="10603"><span class="lineNum">   10603 </span>            :                     ASSERT_not_null(functionDeclaration);</a>
<a name="10604"><span class="lineNum">   10604 </span>            :                     setNameQualification(functionDeclaration,amountOfNameQualificationRequired);</a>
<a name="10605"><span class="lineNum">   10605 </span>            :                   }</a>
<a name="10606"><span class="lineNum">   10606 </span>            :              }</a>
<a name="10607"><span class="lineNum">   10607 </span>            :             else</a>
<a name="10608"><span class="lineNum">   10608 </span>            :              {</a>
<a name="10609"><span class="lineNum">   10609 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;WARNING: SgTemplateInstantiationDirectiveStatement -- currentScope is not available through parent of SgDeclarationStatement, not clear why! \n&quot;);</a>
<a name="10610"><span class="lineNum">   10610 </span>            :                ROSE_ABORT();</a>
<a name="10611"><span class="lineNum">   10611 </span>            :              }</a>
<a name="10612"><span class="lineNum">   10612 </span>            : #endif</a>
<a name="10613"><span class="lineNum">   10613 </span>            : #if 0</a>
<a name="10614"><span class="lineNum">   10614 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;In case of name qualification for SgTemplateInstantiationDirectiveStatement \n&quot;);</a>
<a name="10615"><span class="lineNum">   10615 </span>            :           ROSE_ABORT();</a>
<a name="10616"><span class="lineNum">   10616 </span>            : #endif</a>
<a name="10617"><span class="lineNum">   10617 </span>            :         }</a>
<a name="10618"><span class="lineNum">   10618 </span>            : </a>
<a name="10619"><span class="lineNum">   10619 </span>            :   // DQ (5/14/2011): Added support for the name qualification of the base type used in typedefs.</a>
<a name="10620"><span class="lineNum">   10620 </span>            :   // Handle references to SgTypedefDeclaration...</a>
<a name="10621"><span class="lineNum">   10621 </span><span class="lineCov">    2810440 :      SgTypedefDeclaration* typedefDeclaration = isSgTypedefDeclaration(n);</span></a>
<a name="10622"><span class="lineNum">   10622 </span><span class="lineCov">    2810440 :      if (typedefDeclaration != NULL)</span></a>
<a name="10623"><span class="lineNum">   10623 </span>            :         {</a>
<a name="10624"><span class="lineNum">   10624 </span>            :        // Could it be that we only want to do this for the defining declaration? No, since prototypes must also use name qualification!</a>
<a name="10625"><span class="lineNum">   10625 </span>            : </a>
<a name="10626"><span class="lineNum">   10626 </span>            : #define DEBUG_TYPEDEF (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="10627"><span class="lineNum">   10627 </span>            : </a>
<a name="10628"><span class="lineNum">   10628 </span>            :        // We need the structural location in scope (not the semantic one).</a>
<a name="10629"><span class="lineNum">   10629 </span>            :        // SgScopeStatement* currentScope = isSgScopeStatement(typedefDeclaration-&gt;get_parent());</a>
<a name="10630"><span class="lineNum">   10630 </span><span class="lineCov">      20556 :           SgScopeStatement* currentScope = typedefDeclaration-&gt;get_scope();</span></a>
<a name="10631"><span class="lineNum">   10631 </span><span class="lineCov">      20556 :           ASSERT_not_null(currentScope);</span></a>
<a name="10632"><span class="lineNum">   10632 </span>            : </a>
<a name="10633"><span class="lineNum">   10633 </span><span class="lineCov">      20556 :           SgType* baseType = typedefDeclaration-&gt;get_base_type();</span></a>
<a name="10634"><span class="lineNum">   10634 </span><span class="lineCov">      20556 :           ASSERT_not_null(baseType);</span></a>
<a name="10635"><span class="lineNum">   10635 </span><span class="lineCov">      20556 :           SgDeclarationStatement* baseTypeDeclaration = associatedDeclaration(baseType);</span></a>
<a name="10636"><span class="lineNum">   10636 </span>            : </a>
<a name="10637"><span class="lineNum">   10637 </span>            :        // DQ (4/10/2019): Handle the case when this is a typedef of a SgPointrMemberType.</a>
<a name="10638"><span class="lineNum">   10638 </span><span class="lineCov">      20556 :           SgDeclarationStatement* pointerMemberClassDeclaration = NULL;</span></a>
<a name="10639"><span class="lineNum">   10639 </span>            : </a>
<a name="10640"><span class="lineNum">   10640 </span><span class="lineCov">      20556 :           SgPointerMemberType* pointerMemberType = isSgPointerMemberType(baseType);</span></a>
<a name="10641"><span class="lineNum">   10641 </span><span class="lineCov">      20556 :           if (pointerMemberType != NULL)</span></a>
<a name="10642"><span class="lineNum">   10642 </span>            :              {</a>
<a name="10643"><span class="lineNum">   10643 </span>            : #if DEBUG_TYPEDEF</a>
<a name="10644"><span class="lineNum">   10644 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ \n&quot;);</a>
<a name="10645"><span class="lineNum">   10645 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Found a SgPointerMemberType in the base type of a SgTypedefDeclaration \n&quot;);</a>
<a name="10646"><span class="lineNum">   10646 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ \n&quot;);</a>
<a name="10647"><span class="lineNum">   10647 </span>            : </a>
<a name="10648"><span class="lineNum">   10648 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;We need to make a recursive type traversal for this case! \n&quot;);</a>
<a name="10649"><span class="lineNum">   10649 </span>            : #endif</a>
<a name="10650"><span class="lineNum">   10650 </span>            : </a>
<a name="10651"><span class="lineNum">   10651 </span>            : #if 0</a>
<a name="10652"><span class="lineNum">   10652 </span>            :             // When we have a SgPointerMemberType we have two locations where the name qualification can happen, one on the base type</a>
<a name="10653"><span class="lineNum">   10653 </span>            :             // of the SgPointerMemberType, and the other in the associated class for the pointer to member (data or function).</a>
<a name="10654"><span class="lineNum">   10654 </span>            :                baseType = pointerMemberType-&gt;get_base_type();</a>
<a name="10655"><span class="lineNum">   10655 </span>            :                ASSERT_not_null(baseType);</a>
<a name="10656"><span class="lineNum">   10656 </span>            :                baseTypeDeclaration = associatedDeclaration(baseType);</a>
<a name="10657"><span class="lineNum">   10657 </span>            : #if 1</a>
<a name="10658"><span class="lineNum">   10658 </span>            :             // DQ (4/11/2019): Thisuses the improved API to get the class declaration when the class definition may not exist.</a>
<a name="10659"><span class="lineNum">   10659 </span>            :                pointerMemberClassDeclaration = pointerMemberType-&gt;get_class_declaration_of();</a>
<a name="10660"><span class="lineNum">   10660 </span>            : #else</a>
<a name="10661"><span class="lineNum">   10661 </span>            :             // DQ (4/10/2019): Handle the case when this is a typedef of a SgPointrMemberType.</a>
<a name="10662"><span class="lineNum">   10662 </span>            :             // SgClassDefinition* pointerMemberClassDefinition = pointerMemberType-&gt;get_class_of();</a>
<a name="10663"><span class="lineNum">   10663 </span>            :             // ASSERT_not_null(pointerMemberClassDefinition);</a>
<a name="10664"><span class="lineNum">   10664 </span>            :                if (pointerMemberClassDefinition != NULL)</a>
<a name="10665"><span class="lineNum">   10665 </span>            :                   {</a>
<a name="10666"><span class="lineNum">   10666 </span>            :                     pointerMemberClassDeclaration = pointerMemberClassDefinition-&gt;get_declaration();</a>
<a name="10667"><span class="lineNum">   10667 </span>            :                     ASSERT_not_null(pointerMemberClassDeclaration);</a>
<a name="10668"><span class="lineNum">   10668 </span>            :                   }</a>
<a name="10669"><span class="lineNum">   10669 </span>            : #endif</a>
<a name="10670"><span class="lineNum">   10670 </span>            : #endif</a>
<a name="10671"><span class="lineNum">   10671 </span>            : </a>
<a name="10672"><span class="lineNum">   10672 </span>            : #if DEBUG_TYPEDEF</a>
<a name="10673"><span class="lineNum">   10673 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;############################################################################# \n&quot;);</a>
<a name="10674"><span class="lineNum">   10674 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Case SgTypedefDeclaration: Calling generateNestedTraversalWithExplicitScope() \n&quot;);</a>
<a name="10675"><span class="lineNum">   10675 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;############################################################################# \n&quot;);</a>
<a name="10676"><span class="lineNum">   10676 </span>            : #endif</a>
<a name="10677"><span class="lineNum">   10677 </span><span class="lineCov">         22 :                generateNestedTraversalWithExplicitScope(baseType,currentScope,typedefDeclaration,typedefDeclaration);</span></a>
<a name="10678"><span class="lineNum">   10678 </span>            : </a>
<a name="10679"><span class="lineNum">   10679 </span>            :             // DQ (4/19/2019): It might be that we should call this after the traveral over each type instead of before we traverse the type.</a>
<a name="10680"><span class="lineNum">   10680 </span>            :             // This way we save the correctly computed string for each type after the different parts of name qualificaiton are in place.</a>
<a name="10681"><span class="lineNum">   10681 </span><span class="lineCov">         22 :                traverseType(baseType,typedefDeclaration,currentScope,typedefDeclaration);</span></a>
<a name="10682"><span class="lineNum">   10682 </span>            : </a>
<a name="10683"><span class="lineNum">   10683 </span>            : #if DEBUG_TYPEDEF</a>
<a name="10684"><span class="lineNum">   10684 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;####################################################################################################### \n&quot;);</a>
<a name="10685"><span class="lineNum">   10685 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Case SgTypedefDeclaration: DONE: Processing the recursive evaluation of the SgInitializedName IR's type \n&quot;);</a>
<a name="10686"><span class="lineNum">   10686 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;####################################################################################################### \n&quot;);</a>
<a name="10687"><span class="lineNum">   10687 </span>            : #endif</a>
<a name="10688"><span class="lineNum">   10688 </span>            : </a>
<a name="10689"><span class="lineNum">   10689 </span>            : #if 0</a>
<a name="10690"><span class="lineNum">   10690 </span>            :             // Debugging code.</a>
<a name="10691"><span class="lineNum">   10691 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Case SgTypedefDeclaration: detected a SgPointerMemberType base type \n&quot;);</a>
<a name="10692"><span class="lineNum">   10692 </span>            :                ROSE_ABORT();</a>
<a name="10693"><span class="lineNum">   10693 </span>            : #endif</a>
<a name="10694"><span class="lineNum">   10694 </span>            :              }</a>
<a name="10695"><span class="lineNum">   10695 </span>            :             else</a>
<a name="10696"><span class="lineNum">   10696 </span>            :              {</a>
<a name="10697"><span class="lineNum">   10697 </span>            :             // DQ (4/28/2019): (refactored) Put the rest of the non-SgPointerMemberType support into the false block.</a>
<a name="10698"><span class="lineNum">   10698 </span>            : </a>
<a name="10699"><span class="lineNum">   10699 </span>            :             // If the base type is defined in the typedef directly then it should need no name qualification by definition.</a>
<a name="10700"><span class="lineNum">   10700 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="10701"><span class="lineNum">   10701 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;typedefDeclaration-&gt;get_typedefBaseTypeContainsDefiningDeclaration() = %s \n&quot;,typedefDeclaration-&gt;get_typedefBaseTypeContainsDefiningDeclaration() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="10702"><span class="lineNum">   10702 </span>            : #endif</a>
<a name="10703"><span class="lineNum">   10703 </span>            : </a>
<a name="10704"><span class="lineNum">   10704 </span>            :             // DQ (4/10/2019): Handle the case when this is a typedef of a SgPointrMemberType.</a>
<a name="10705"><span class="lineNum">   10705 </span><span class="lineCov">      20534 :                if (pointerMemberClassDeclaration != NULL)</span></a>
<a name="10706"><span class="lineNum">   10706 </span>            :                   {</a>
<a name="10707"><span class="lineNum">   10707 </span>            :                     int amountOfNameQualificationRequiredOnPointerMemberClass = nameQualificationDepth(pointerMemberClassDeclaration,currentScope,typedefDeclaration);</a>
<a name="10708"><span class="lineNum">   10708 </span>            : </a>
<a name="10709"><span class="lineNum">   10709 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="10710"><span class="lineNum">   10710 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;SgTypedefDeclaration: amountOfNameQualificationRequiredOnPointerMemberClass = %d \n&quot;,amountOfNameQualificationRequiredOnPointerMemberClass);</a>
<a name="10711"><span class="lineNum">   10711 </span>            : #endif</a>
<a name="10712"><span class="lineNum">   10712 </span>            : </a>
<a name="10713"><span class="lineNum">   10713 </span>            :                     ASSERT_not_null(pointerMemberClassDeclaration);</a>
<a name="10714"><span class="lineNum">   10714 </span>            :                     setNameQualificationOnPointerMemberClass(typedefDeclaration,pointerMemberClassDeclaration,amountOfNameQualificationRequiredOnPointerMemberClass);</a>
<a name="10715"><span class="lineNum">   10715 </span>            : </a>
<a name="10716"><span class="lineNum">   10716 </span>            : #if 0</a>
<a name="10717"><span class="lineNum">   10717 </span>            :                  // Debugging code.</a>
<a name="10718"><span class="lineNum">   10718 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Case SgTypedefDeclaration: detected a SgPointerMemberType base type: pointerMemberClassDeclaration != NULL \n&quot;);</a>
<a name="10719"><span class="lineNum">   10719 </span>            :                     ROSE_ABORT();</a>
<a name="10720"><span class="lineNum">   10720 </span>            : #endif</a>
<a name="10721"><span class="lineNum">   10721 </span>            :                   }</a>
<a name="10722"><span class="lineNum">   10722 </span>            : </a>
<a name="10723"><span class="lineNum">   10723 </span>            :             // This is NULL if the base type is not associated with a declaration (e.g. not a SgNamedType).</a>
<a name="10724"><span class="lineNum">   10724 </span>            :             // ASSERT_not_null(baseTypeDeclaration);</a>
<a name="10725"><span class="lineNum">   10725 </span>            :             // if (baseTypeDeclaration != NULL)</a>
<a name="10726"><span class="lineNum">   10726 </span><span class="lineCov">      20534 :                if ( (baseTypeDeclaration != NULL) &amp;&amp; (typedefDeclaration-&gt;get_typedefBaseTypeContainsDefiningDeclaration() == false) )</span></a>
<a name="10727"><span class="lineNum">   10727 </span>            :                   {</a>
<a name="10728"><span class="lineNum">   10728 </span>            :                  // int amountOfNameQualificationRequiredForBaseType = nameQualificationDepth(baseTypeDeclaration,currentScope,typedefDeclaration);</a>
<a name="10729"><span class="lineNum">   10729 </span><span class="lineCov">      13024 :                     int amountOfNameQualificationRequiredForBaseType = nameQualificationDepth(baseType,currentScope,typedefDeclaration);</span></a>
<a name="10730"><span class="lineNum">   10730 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="10731"><span class="lineNum">   10731 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;SgTypedefDeclaration: amountOfNameQualificationRequiredForBaseType = %d \n&quot;,amountOfNameQualificationRequiredForBaseType);</a>
<a name="10732"><span class="lineNum">   10732 </span>            : #endif</a>
<a name="10733"><span class="lineNum">   10733 </span><span class="lineCov">      13024 :                     ASSERT_not_null(baseTypeDeclaration);</span></a>
<a name="10734"><span class="lineNum">   10734 </span>            :                  // setNameQualification(typedefDeclaration,baseTypeDeclaration,amountOfNameQualificationRequiredForBaseType);</a>
<a name="10735"><span class="lineNum">   10735 </span><span class="lineCov">      13024 :                     setNameQualificationOnBaseType(typedefDeclaration,baseTypeDeclaration,amountOfNameQualificationRequiredForBaseType);</span></a>
<a name="10736"><span class="lineNum">   10736 </span>            :                   }</a>
<a name="10737"><span class="lineNum">   10737 </span>            : </a>
<a name="10738"><span class="lineNum">   10738 </span>            : #if DEBUG_TYPEDEF || 0</a>
<a name="10739"><span class="lineNum">   10739 </span>            :             // DQ (2/15/2017): Note that this output will be the way to identify the start of a failing infinite loop</a>
<a name="10740"><span class="lineNum">   10740 </span>            :             // for tests/nonsmoke/functional/CompileTests/RoseExample_tests/testRoseHeaders_11.C.</a>
<a name="10741"><span class="lineNum">   10741 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Calling traverseType on SgTypedefDeclaration = %p name = %s \n&quot;,typedefDeclaration,typedefDeclaration-&gt;get_name().str());</a>
<a name="10742"><span class="lineNum">   10742 </span>            : #endif</a>
<a name="10743"><span class="lineNum">   10743 </span>            : </a>
<a name="10744"><span class="lineNum">   10744 </span>            : #if DEBUG_TYPEDEF || 0</a>
<a name="10745"><span class="lineNum">   10745 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;typedefDeclaration-&gt;get_typedefBaseTypeContainsDefiningDeclaration() = %s \n&quot;,</a>
<a name="10746"><span class="lineNum">   10746 </span>            :                     typedefDeclaration-&gt;get_typedefBaseTypeContainsDefiningDeclaration() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="10747"><span class="lineNum">   10747 </span>            : #endif</a>
<a name="10748"><span class="lineNum">   10748 </span>            :             // DQ (5/2/2019): check the defining declaration for the associated declaration (see test2019_427.C).</a>
<a name="10749"><span class="lineNum">   10749 </span>            :             // For example, a typedef with multiple declarations (&quot;typedef struct {} A,*Aptr;&quot;).</a>
<a name="10750"><span class="lineNum">   10750 </span>            :             // bool skipTraverseType = typedefDeclaration-&gt;get_typedefBaseTypeContainsDefiningDeclaration();</a>
<a name="10751"><span class="lineNum">   10751 </span><span class="lineCov">      20534 :                SgTypedefDeclaration*   definingTypedefDeclaration = typedefDeclaration;</span></a>
<a name="10752"><span class="lineNum">   10752 </span><span class="lineCov">      20534 :                SgDeclarationStatement* assocaitedDeclaration = typedefDeclaration-&gt;get_declaration();</span></a>
<a name="10753"><span class="lineNum">   10753 </span><span class="lineCov">      20534 :                SgDeclarationStatement* definingDeclaration = assocaitedDeclaration;</span></a>
<a name="10754"><span class="lineNum">   10754 </span><span class="lineCov">      20534 :                if (assocaitedDeclaration != NULL)</span></a>
<a name="10755"><span class="lineNum">   10755 </span>            :                   {</a>
<a name="10756"><span class="lineNum">   10756 </span><span class="lineCov">       8648 :                     definingDeclaration = assocaitedDeclaration-&gt;get_definingDeclaration();</span></a>
<a name="10757"><span class="lineNum">   10757 </span>            :                  // ASSERT_not_null(definingDeclaration);</a>
<a name="10758"><span class="lineNum">   10758 </span><span class="lineCov">       8648 :                     if (definingDeclaration != NULL)</span></a>
<a name="10759"><span class="lineNum">   10759 </span>            :                        {</a>
<a name="10760"><span class="lineNum">   10760 </span><span class="lineCov">       3924 :                          definingTypedefDeclaration = isSgTypedefDeclaration(definingDeclaration-&gt;get_parent());</span></a>
<a name="10761"><span class="lineNum">   10761 </span>            : </a>
<a name="10762"><span class="lineNum">   10762 </span>            :                       // DQ (5/2/2019): If this is NULL, then use the original version.</a>
<a name="10763"><span class="lineNum">   10763 </span><span class="lineCov">       3924 :                          if (definingTypedefDeclaration == NULL)</span></a>
<a name="10764"><span class="lineNum">   10764 </span>            :                             {</a>
<a name="10765"><span class="lineNum">   10765 </span><span class="lineCov">       3373 :                               definingTypedefDeclaration = typedefDeclaration;</span></a>
<a name="10766"><span class="lineNum">   10766 </span>            :                             }</a>
<a name="10767"><span class="lineNum">   10767 </span>            :                        }</a>
<a name="10768"><span class="lineNum">   10768 </span><span class="lineCov">       8648 :                     ASSERT_not_null(definingTypedefDeclaration);</span></a>
<a name="10769"><span class="lineNum">   10769 </span>            :                   }</a>
<a name="10770"><span class="lineNum">   10770 </span>            : </a>
<a name="10771"><span class="lineNum">   10771 </span><span class="lineCov">      20534 :                bool skipTraverseType = definingTypedefDeclaration-&gt;get_typedefBaseTypeContainsDefiningDeclaration();</span></a>
<a name="10772"><span class="lineNum">   10772 </span>            : #if 0</a>
<a name="10773"><span class="lineNum">   10773 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;222222222222222222222 skipTraverseType = %s \n&quot;,skipTraverseType ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="10774"><span class="lineNum">   10774 </span>            : #endif</a>
<a name="10775"><span class="lineNum">   10775 </span>            :             // DQ (6/3/2011): Traverse the type to set any possible template arguments (or other subtypes?) that require name qualification.</a>
<a name="10776"><span class="lineNum">   10776 </span>            :             // traverseType(baseType,typedefDeclaration,currentScope,typedefDeclaration);</a>
<a name="10777"><span class="lineNum">   10777 </span><span class="lineCov">      20534 :                if (skipTraverseType == false)</span></a>
<a name="10778"><span class="lineNum">   10778 </span>            :                   {</a>
<a name="10779"><span class="lineNum">   10779 </span><span class="lineCov">      20064 :                     traverseType(baseType,typedefDeclaration,currentScope,typedefDeclaration);</span></a>
<a name="10780"><span class="lineNum">   10780 </span>            : </a>
<a name="10781"><span class="lineNum">   10781 </span>            : #if DEBUG_TYPEDEF || 0</a>
<a name="10782"><span class="lineNum">   10782 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;DONE: Calling traverseType on SgTypedefDeclaration = %p name = %s \n&quot;,typedefDeclaration,typedefDeclaration-&gt;get_name().str());</a>
<a name="10783"><span class="lineNum">   10783 </span>            : #endif</a>
<a name="10784"><span class="lineNum">   10784 </span>            :                   }</a>
<a name="10785"><span class="lineNum">   10785 </span>            :                  else</a>
<a name="10786"><span class="lineNum">   10786 </span>            :                   {</a>
<a name="10787"><span class="lineNum">   10787 </span>            : #if DEBUG_TYPEDEF || 0</a>
<a name="10788"><span class="lineNum">   10788 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Skipped call to traverseType for case SgTypedefDeclaration = %p name = %s \n&quot;,typedefDeclaration,typedefDeclaration-&gt;get_name().str());</a>
<a name="10789"><span class="lineNum">   10789 </span>            : #endif</a>
<a name="10790"><span class="lineNum">   10790 </span>            :                   }</a>
<a name="10791"><span class="lineNum">   10791 </span>            : </a>
<a name="10792"><span class="lineNum">   10792 </span>            :             // DQ (4/14/2018): Adding support for name qualification of template arguments (though it should not be requirted for the tyepdef directly).</a>
<a name="10793"><span class="lineNum">   10793 </span><span class="lineCov">      20534 :                SgTemplateInstantiationTypedefDeclaration* templateInstantiationTypedefDeclaration = isSgTemplateInstantiationTypedefDeclaration(typedefDeclaration);</span></a>
<a name="10794"><span class="lineNum">   10794 </span>            :                if (templateInstantiationTypedefDeclaration != NULL)</a>
<a name="10795"><span class="lineNum">   10795 </span>            :                   {</a>
<a name="10796"><span class="lineNum">   10796 </span>            :                  // This point of calling this function is to just have the template arguments evaluated for name qualification (see Cxx11_tests/test2018_68.C).</a>
<a name="10797"><span class="lineNum">   10797 </span>            : </a>
<a name="10798"><span class="lineNum">   10798 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="10799"><span class="lineNum">   10799 </span>            :                     int amountOfNameQualificationRequired = nameQualificationDepth(templateInstantiationTypedefDeclaration,currentScope,templateInstantiationTypedefDeclaration);</a>
<a name="10800"><span class="lineNum">   10800 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;SgTemplateInstantiationTypedefDeclaration: amountOfNameQualificationRequired = %d \n&quot;,amountOfNameQualificationRequired);</a>
<a name="10801"><span class="lineNum">   10801 </span>            : </a>
<a name="10802"><span class="lineNum">   10802 </span>            :                  // DQ (4/14/2018): Report anything that is unusual, i.e. non-zero name qualification length.</a>
<a name="10803"><span class="lineNum">   10803 </span>            :                     if (amountOfNameQualificationRequired &gt; 0)</a>
<a name="10804"><span class="lineNum">   10804 </span>            :                        {</a>
<a name="10805"><span class="lineNum">   10805 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;Warning: name qualification length should be zero for a templateInstantiationTypedefDeclaration declared in the same scope: amountOfNameQualificationRequired = %d \n&quot;,amountOfNameQualificationRequired);</a>
<a name="10806"><span class="lineNum">   10806 </span>            : </a>
<a name="10807"><span class="lineNum">   10807 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;templateInstantiationTypedefDeclaration = %p = %s = %s \n&quot;,templateInstantiationTypedefDeclaration,templateInstantiationTypedefDeclaration-&gt;class_name().c_str(),functionDeclaration-&gt;get_mangled_name().str());</a>
<a name="10808"><span class="lineNum">   10808 </span>            :                        }</a>
<a name="10809"><span class="lineNum">   10809 </span>            : #endif</a>
<a name="10810"><span class="lineNum">   10810 </span>            :                   }</a>
<a name="10811"><span class="lineNum">   10811 </span>            : </a>
<a name="10812"><span class="lineNum">   10812 </span>            :             // DQ (4/28/2019): (refactored) Put the rest of the non-SgPointerMemberType support into the false block.</a>
<a name="10813"><span class="lineNum">   10813 </span>            :              }</a>
<a name="10814"><span class="lineNum">   10814 </span>            : </a>
<a name="10815"><span class="lineNum">   10815 </span>            : #if 0</a>
<a name="10816"><span class="lineNum">   10816 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="10817"><span class="lineNum">   10817 </span>            :           ROSE_ABORT();</a>
<a name="10818"><span class="lineNum">   10818 </span>            : #endif</a>
<a name="10819"><span class="lineNum">   10819 </span>            :         }</a>
<a name="10820"><span class="lineNum">   10820 </span>            : </a>
<a name="10821"><span class="lineNum">   10821 </span>            : </a>
<a name="10822"><span class="lineNum">   10822 </span>            :   // Handle references in SgUsingDirectiveStatement...</a>
<a name="10823"><span class="lineNum">   10823 </span><span class="lineCov">    2810440 :      SgUsingDirectiveStatement* usingDirective = isSgUsingDirectiveStatement(n);</span></a>
<a name="10824"><span class="lineNum">   10824 </span><span class="lineCov">    2810440 :      if (usingDirective != NULL)</span></a>
<a name="10825"><span class="lineNum">   10825 </span>            :         {</a>
<a name="10826"><span class="lineNum">   10826 </span><span class="lineCov">         17 :           SgNamespaceDeclarationStatement* namespaceDeclaration = usingDirective-&gt;get_namespaceDeclaration();</span></a>
<a name="10827"><span class="lineNum">   10827 </span><span class="lineCov">         17 :           ASSERT_not_null(namespaceDeclaration);</span></a>
<a name="10828"><span class="lineNum">   10828 </span><span class="lineCov">         17 :           SgScopeStatement* currentScope = usingDirective-&gt;get_scope();</span></a>
<a name="10829"><span class="lineNum">   10829 </span><span class="lineCov">         17 :           ASSERT_not_null(currentScope);</span></a>
<a name="10830"><span class="lineNum">   10830 </span>            : </a>
<a name="10831"><span class="lineNum">   10831 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="10832"><span class="lineNum">   10832 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;currentScope = %p = %s = %s \n&quot;,currentScope,currentScope-&gt;class_name().c_str(),SageInterface::get_name(currentScope).c_str());</a>
<a name="10833"><span class="lineNum">   10833 </span>            : #endif</a>
<a name="10834"><span class="lineNum">   10834 </span>            : </a>
<a name="10835"><span class="lineNum">   10835 </span><span class="lineCov">         17 :           int amountOfNameQualificationRequired = nameQualificationDepth(namespaceDeclaration,currentScope,usingDirective);</span></a>
<a name="10836"><span class="lineNum">   10836 </span>            : </a>
<a name="10837"><span class="lineNum">   10837 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="10838"><span class="lineNum">   10838 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;SgUsingDirectiveStatement's SgNamespaceDeclarationStatement: amountOfNameQualificationRequired = %d \n&quot;,amountOfNameQualificationRequired);</a>
<a name="10839"><span class="lineNum">   10839 </span>            : #endif</a>
<a name="10840"><span class="lineNum">   10840 </span><span class="lineCov">         17 :           setNameQualification(usingDirective,namespaceDeclaration,amountOfNameQualificationRequired);</span></a>
<a name="10841"><span class="lineNum">   10841 </span>            :         }</a>
<a name="10842"><span class="lineNum">   10842 </span>            : </a>
<a name="10843"><span class="lineNum">   10843 </span><span class="lineCov">    2810440 :      SgUsingDeclarationStatement* usingDeclaration = isSgUsingDeclarationStatement(n);</span></a>
<a name="10844"><span class="lineNum">   10844 </span><span class="lineCov">    2810440 :      if (usingDeclaration != NULL)</span></a>
<a name="10845"><span class="lineNum">   10845 </span>            :         {</a>
<a name="10846"><span class="lineNum">   10846 </span><span class="lineCov">       3313 :           SgDeclarationStatement* associatedDeclaration     = usingDeclaration-&gt;get_declaration();</span></a>
<a name="10847"><span class="lineNum">   10847 </span><span class="lineCov">       3313 :           SgInitializedName*      associatedInitializedName = usingDeclaration-&gt;get_initializedName();</span></a>
<a name="10848"><span class="lineNum">   10848 </span>            : </a>
<a name="10849"><span class="lineNum">   10849 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="10850"><span class="lineNum">   10850 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;In case for SgUsingDeclarationStatement: associatedDeclaration = %p associatedInitializedName = %p \n&quot;,associatedDeclaration,associatedInitializedName);</a>
<a name="10851"><span class="lineNum">   10851 </span>            :           if (associatedDeclaration != NULL)</a>
<a name="10852"><span class="lineNum">   10852 </span>            :              mfprintf(mlog [ WARN ] ) (&quot;associatedDeclaration = %p = %s = %s = %s \n&quot;,associatedDeclaration,associatedDeclaration-&gt;class_name().c_str(),SageInterface::get_name(associatedDeclaration).c_str(),SageInterface::generateUniqueName(associatedDeclaration,true).c_str());</a>
<a name="10853"><span class="lineNum">   10853 </span>            :           if (associatedInitializedName != NULL)</a>
<a name="10854"><span class="lineNum">   10854 </span>            :              mfprintf(mlog [ WARN ] ) (&quot;associatedInitializedName = %p = %s = %s = %s \n&quot;,associatedInitializedName,associatedInitializedName-&gt;class_name().c_str(),SageInterface::get_name(associatedInitializedName).c_str(),SageInterface::generateUniqueName(associatedInitializedName,true).c_str());</a>
<a name="10855"><span class="lineNum">   10855 </span>            : #endif</a>
<a name="10856"><span class="lineNum">   10856 </span><span class="lineCov">       3313 :           SgScopeStatement* currentScope = usingDeclaration-&gt;get_scope();</span></a>
<a name="10857"><span class="lineNum">   10857 </span><span class="lineCov">       3313 :           ASSERT_not_null(currentScope);</span></a>
<a name="10858"><span class="lineNum">   10858 </span>            : </a>
<a name="10859"><span class="lineNum">   10859 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="10860"><span class="lineNum">   10860 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;currentScope = %p = %s = %s \n&quot;,currentScope,currentScope-&gt;class_name().c_str(),SageInterface::get_name(currentScope).c_str());</a>
<a name="10861"><span class="lineNum">   10861 </span>            : #endif</a>
<a name="10862"><span class="lineNum">   10862 </span>            : </a>
<a name="10863"><span class="lineNum">   10863 </span><span class="lineCov">       3313 :           int amountOfNameQualificationRequired = 0;</span></a>
<a name="10864"><span class="lineNum">   10864 </span><span class="lineCov">       3313 :           if (associatedDeclaration != NULL)</span></a>
<a name="10865"><span class="lineNum">   10865 </span>            :              {</a>
<a name="10866"><span class="lineNum">   10866 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="10867"><span class="lineNum">   10867 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;associatedDeclaration != NULL: associatedDeclaration = %p = %s = %s \n&quot;,associatedDeclaration,associatedDeclaration-&gt;class_name().c_str(),SageInterface::get_name(associatedDeclaration).c_str());</a>
<a name="10868"><span class="lineNum">   10868 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;associatedDeclaration != NULL: currentScope = %p = %s \n&quot;,currentScope,currentScope-&gt;class_name().c_str());</a>
<a name="10869"><span class="lineNum">   10869 </span>            :                if (currentScope-&gt;get_scope() != NULL)</a>
<a name="10870"><span class="lineNum">   10870 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;associatedDeclaration != NULL: currentScope-&gt;get_scope() = %p = %s \n&quot;,currentScope-&gt;get_scope(),currentScope-&gt;get_scope()-&gt;class_name().c_str());</a>
<a name="10871"><span class="lineNum">   10871 </span>            : #endif</a>
<a name="10872"><span class="lineNum">   10872 </span>            : #if 0</a>
<a name="10873"><span class="lineNum">   10873 </span>            :             // DQ (6/22/2011): The declaration in a SgUsingDeclarationStatement must have some qualification else it is not</a>
<a name="10874"><span class="lineNum">   10874 </span>            :             // required and will be an error.  To avoid it being confused with a name in the current scope we have to start</a>
<a name="10875"><span class="lineNum">   10875 </span>            :             // the process assuming the scope of the current scope. This is a special case in the name qualification handling.</a>
<a name="10876"><span class="lineNum">   10876 </span>            :             // But we also do not need the forceMoreNameQualification mechanism (I think).</a>
<a name="10877"><span class="lineNum">   10877 </span>            :             // DQ (5/14/2011): For the case of test2001_46.C I think we need to force name qualification.</a>
<a name="10878"><span class="lineNum">   10878 </span>            :             // In general any reference using a SgUsingDeclarationStatement should likely be qualified (at least one level, via the parent of the associatedDeclaration).</a>
<a name="10879"><span class="lineNum">   10879 </span>            :             // amountOfNameQualificationRequired = nameQualificationDepth(associatedDeclaration,currentScope,usingDeclaration);</a>
<a name="10880"><span class="lineNum">   10880 </span>            :             // amountOfNameQualificationRequired = nameQualificationDepth(associatedDeclaration,currentScope,usingDeclaration, /* forceMoreNameQualification = */ true);</a>
<a name="10881"><span class="lineNum">   10881 </span>            :                amountOfNameQualificationRequired = nameQualificationDepth(associatedDeclaration,currentScope-&gt;get_scope(),usingDeclaration, /* forceMoreNameQualification = */ false);</a>
<a name="10882"><span class="lineNum">   10882 </span>            : #else</a>
<a name="10883"><span class="lineNum">   10883 </span>            :             // DQ (3/31/2014): Compute the required depth for global qualification (required for using declarations).</a>
<a name="10884"><span class="lineNum">   10884 </span><span class="lineCov">       3263 :                amountOfNameQualificationRequired = depthOfGlobalNameQualification(associatedDeclaration);</span></a>
<a name="10885"><span class="lineNum">   10885 </span>            : #endif</a>
<a name="10886"><span class="lineNum">   10886 </span>            : </a>
<a name="10887"><span class="lineNum">   10887 </span>            :             // DQ (1/11/2019): Don't outout added global qualification for the case of a inheriting constructor.</a>
<a name="10888"><span class="lineNum">   10888 </span>            :             // DQ (6/22/2011): If the amountOfNameQualificationRequired is zero then add one to force at least global qualification.</a>
<a name="10889"><span class="lineNum">   10889 </span>            :             // See test2004_80.C for an example.</a>
<a name="10890"><span class="lineNum">   10890 </span>            :             // if (isSgGlobal(currentScope-&gt;get_scope()) != NULL &amp;&amp; amountOfNameQualificationRequired == 0)</a>
<a name="10891"><span class="lineNum">   10891 </span><span class="lineCov">       3263 :                bool is_inheriting_constructor = usingDeclaration-&gt;get_is_inheriting_constructor();</span></a>
<a name="10892"><span class="lineNum">   10892 </span><span class="lineCov">       3263 :                if (is_inheriting_constructor == false &amp;&amp; isSgGlobal(currentScope-&gt;get_scope()) != NULL &amp;&amp; amountOfNameQualificationRequired == 0)</span></a>
<a name="10893"><span class="lineNum">   10893 </span>            :                   {</a>
<a name="10894"><span class="lineNum">   10894 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="10895"><span class="lineNum">   10895 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Handling special case to force at least global qualification. \n&quot;);</a>
<a name="10896"><span class="lineNum">   10896 </span>            : #endif</a>
<a name="10897"><span class="lineNum">   10897 </span>            :                     amountOfNameQualificationRequired += 1;</a>
<a name="10898"><span class="lineNum">   10898 </span>            :                   }</a>
<a name="10899"><span class="lineNum">   10899 </span>            : </a>
<a name="10900"><span class="lineNum">   10900 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="10901"><span class="lineNum">   10901 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;SgUsingDeclarationStatement's associatedDeclaration: amountOfNameQualificationRequired = %d \n&quot;,amountOfNameQualificationRequired);</a>
<a name="10902"><span class="lineNum">   10902 </span>            : #endif</a>
<a name="10903"><span class="lineNum">   10903 </span>            : </a>
<a name="10904"><span class="lineNum">   10904 </span>            :             // DQ (1/10/2019): If this is a constructor, member function, then we must qualifiy it to distinquish it from the base class name.</a>
<a name="10905"><span class="lineNum">   10905 </span><span class="lineCov">       3263 :                SgMemberFunctionDeclaration* memberFunctionDeclaration = isSgMemberFunctionDeclaration(associatedDeclaration);</span></a>
<a name="10906"><span class="lineNum">   10906 </span><span class="lineCov">       3263 :                if (memberFunctionDeclaration != NULL)</span></a>
<a name="10907"><span class="lineNum">   10907 </span>            :                   {</a>
<a name="10908"><span class="lineNum">   10908 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="10909"><span class="lineNum">   10909 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Found a member function = %p name = %s \n&quot;,memberFunctionDeclaration,memberFunctionDeclaration-&gt;get_name().str());</a>
<a name="10910"><span class="lineNum">   10910 </span>            : #endif</a>
<a name="10911"><span class="lineNum">   10911 </span><span class="lineCov">        198 :                     if (memberFunctionDeclaration-&gt;get_specialFunctionModifier().isConstructor() == true)</span></a>
<a name="10912"><span class="lineNum">   10912 </span>            :                        {</a>
<a name="10913"><span class="lineNum">   10913 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="10914"><span class="lineNum">   10914 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;Found a constructor = %p name = %s \n&quot;,memberFunctionDeclaration,memberFunctionDeclaration-&gt;get_name().str());</a>
<a name="10915"><span class="lineNum">   10915 </span>            : #endif</a>
<a name="10916"><span class="lineNum">   10916 </span>            :                        }</a>
<a name="10917"><span class="lineNum">   10917 </span>            :                   }</a>
<a name="10918"><span class="lineNum">   10918 </span>            : </a>
<a name="10919"><span class="lineNum">   10919 </span><span class="lineCov">       3263 :                setNameQualification(usingDeclaration,associatedDeclaration,amountOfNameQualificationRequired);</span></a>
<a name="10920"><span class="lineNum">   10920 </span>            :              }</a>
<a name="10921"><span class="lineNum">   10921 </span>            :             else</a>
<a name="10922"><span class="lineNum">   10922 </span>            :              {</a>
<a name="10923"><span class="lineNum">   10923 </span><span class="lineCov">         50 :                ASSERT_not_null(associatedInitializedName);</span></a>
<a name="10924"><span class="lineNum">   10924 </span><span class="lineCov">         50 :                amountOfNameQualificationRequired = nameQualificationDepth(associatedInitializedName,currentScope,usingDeclaration);</span></a>
<a name="10925"><span class="lineNum">   10925 </span>            : </a>
<a name="10926"><span class="lineNum">   10926 </span><span class="lineCov">         50 :                setNameQualification(usingDeclaration,associatedInitializedName,amountOfNameQualificationRequired);</span></a>
<a name="10927"><span class="lineNum">   10927 </span>            : #if 0</a>
<a name="10928"><span class="lineNum">   10928 </span>            :             // We want to debug this case later!</a>
<a name="10929"><span class="lineNum">   10929 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Exiting in unimplemented case of SgInitializedName in SgUsingDeclarationStatement \n&quot;);</a>
<a name="10930"><span class="lineNum">   10930 </span>            :                ROSE_ABORT();</a>
<a name="10931"><span class="lineNum">   10931 </span>            : #endif</a>
<a name="10932"><span class="lineNum">   10932 </span>            :              }</a>
<a name="10933"><span class="lineNum">   10933 </span>            : </a>
<a name="10934"><span class="lineNum">   10934 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="10935"><span class="lineNum">   10935 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;SgUsingDeclarationStatement's SgVarRefExp: amountOfNameQualificationRequired = %d \n&quot;,amountOfNameQualificationRequired);</a>
<a name="10936"><span class="lineNum">   10936 </span>            : #endif</a>
<a name="10937"><span class="lineNum">   10937 </span>            :         }</a>
<a name="10938"><span class="lineNum">   10938 </span>            : </a>
<a name="10939"><span class="lineNum">   10939 </span>            : </a>
<a name="10940"><span class="lineNum">   10940 </span>            :   // DQ (7/8/2014): Adding support for name qualification of the SgNamespaceDeclarationStatement referenced by a SgNamespaceAliasDeclarationStatement.</a>
<a name="10941"><span class="lineNum">   10941 </span>            :   // Handle references in SgNamespaceAliasDeclarationStatement...</a>
<a name="10942"><span class="lineNum">   10942 </span><span class="lineCov">    2810440 :      SgNamespaceAliasDeclarationStatement* namespaceAliasDeclaration = isSgNamespaceAliasDeclarationStatement(n);</span></a>
<a name="10943"><span class="lineNum">   10943 </span><span class="lineCov">    2810440 :      if (namespaceAliasDeclaration != NULL)</span></a>
<a name="10944"><span class="lineNum">   10944 </span>            :         {</a>
<a name="10945"><span class="lineNum">   10945 </span>            : #if 0</a>
<a name="10946"><span class="lineNum">   10946 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;In namespace qualification: namespaceAliasDeclaration = %p name = %s \n&quot;,namespaceAliasDeclaration,namespaceAliasDeclaration-&gt;get_name().str());</a>
<a name="10947"><span class="lineNum">   10947 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;   --- is_alias_for_another_namespace_alias = %s \n&quot;,namespaceAliasDeclaration-&gt;get_is_alias_for_another_namespace_alias() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="10948"><span class="lineNum">   10948 </span>            : #endif</a>
<a name="10949"><span class="lineNum">   10949 </span><span class="lineNoCov">          0 :           string namespaceDeclarationName;</span></a>
<a name="10950"><span class="lineNum">   10950 </span>            :        // SgNamespaceDeclarationStatement* namespaceDeclaration = namespaceAliasDeclaration-&gt;get_namespaceDeclaration();</a>
<a name="10951"><span class="lineNum">   10951 </span><span class="lineNoCov">          0 :           SgDeclarationStatement* namespaceDeclaration = NULL;</span></a>
<a name="10952"><span class="lineNum">   10952 </span><span class="lineNoCov">          0 :           if (namespaceAliasDeclaration-&gt;get_is_alias_for_another_namespace_alias() == true)</span></a>
<a name="10953"><span class="lineNum">   10953 </span>            :              {</a>
<a name="10954"><span class="lineNum">   10954 </span><span class="lineNoCov">          0 :                namespaceDeclaration = namespaceAliasDeclaration-&gt;get_namespaceAliasDeclaration();</span></a>
<a name="10955"><span class="lineNum">   10955 </span>            : </a>
<a name="10956"><span class="lineNum">   10956 </span>            :             // DQ (8/1/2020): Set the name.</a>
<a name="10957"><span class="lineNum">   10957 </span><span class="lineNoCov">          0 :                namespaceDeclarationName = namespaceAliasDeclaration-&gt;get_namespaceAliasDeclaration()-&gt;get_name();</span></a>
<a name="10958"><span class="lineNum">   10958 </span>            :              }</a>
<a name="10959"><span class="lineNum">   10959 </span>            :             else</a>
<a name="10960"><span class="lineNum">   10960 </span>            :              {</a>
<a name="10961"><span class="lineNum">   10961 </span><span class="lineNoCov">          0 :                namespaceDeclaration = namespaceAliasDeclaration-&gt;get_namespaceDeclaration();</span></a>
<a name="10962"><span class="lineNum">   10962 </span>            : </a>
<a name="10963"><span class="lineNum">   10963 </span>            :             // DQ (8/1/2020): Set the name.</a>
<a name="10964"><span class="lineNum">   10964 </span><span class="lineNoCov">          0 :                namespaceDeclarationName = namespaceAliasDeclaration-&gt;get_namespaceDeclaration()-&gt;get_name();</span></a>
<a name="10965"><span class="lineNum">   10965 </span>            :              }</a>
<a name="10966"><span class="lineNum">   10966 </span><span class="lineNoCov">          0 :           ASSERT_not_null(namespaceDeclaration);</span></a>
<a name="10967"><span class="lineNum">   10967 </span>            : </a>
<a name="10968"><span class="lineNum">   10968 </span>            :        // DQ (8/1/2020): Record the associated NamespaceAliasDeclarationStatement so it can be used instead in namequalification.</a>
<a name="10969"><span class="lineNum">   10969 </span>            :        // inheritedAttribute.get_namespaceAliasDeclarationMap().insert(pair&lt;SgDeclarationStatement*,SgNamespaceAliasDeclarationStatement*&gt;(namespaceDeclaration,namespaceAliasDeclaration));</a>
<a name="10970"><span class="lineNum">   10970 </span>            : </a>
<a name="10971"><span class="lineNum">   10971 </span><span class="lineNoCov">          0 :           namespaceAliasDeclarationMap.insert(pair&lt;SgDeclarationStatement*,SgNamespaceAliasDeclarationStatement*&gt;(namespaceDeclaration,namespaceAliasDeclaration));</span></a>
<a name="10972"><span class="lineNum">   10972 </span>            : </a>
<a name="10973"><span class="lineNum">   10973 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) &amp;&amp; 0</a>
<a name="10974"><span class="lineNum">   10974 </span>            :           printf (&quot;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ \n&quot;);</a>
<a name="10975"><span class="lineNum">   10975 </span>            :           printf (&quot;In evaluateInheritedAttribute(): Saved namespace alias: %s to namespace declaration = %s \n&quot;,namespaceAliasDeclaration-&gt;get_name().str(),namespaceDeclarationName.c_str());</a>
<a name="10976"><span class="lineNum">   10976 </span>            : #if 0</a>
<a name="10977"><span class="lineNum">   10977 </span>            :           printf (&quot; --- inheritedAttribute.get_namespaceAliasDeclarationMap().size() = %zu \n&quot;,inheritedAttribute.get_namespaceAliasDeclarationMap().size());</a>
<a name="10978"><span class="lineNum">   10978 </span>            :           ROSE_ASSERT(namespaceAliasDeclarationMapFromInheritedAttribute != NULL);</a>
<a name="10979"><span class="lineNum">   10979 </span>            :           printf (&quot; --- namespaceAliasDeclarationMapFromInheritedAttribute-&gt;size() = %zu \n&quot;,namespaceAliasDeclarationMapFromInheritedAttribute-&gt;size());</a>
<a name="10980"><span class="lineNum">   10980 </span>            : #else</a>
<a name="10981"><span class="lineNum">   10981 </span>            :           printf (&quot; --- namespaceAliasDeclarationMap.size() = %zu \n&quot;,namespaceAliasDeclarationMap.size());</a>
<a name="10982"><span class="lineNum">   10982 </span>            : #endif</a>
<a name="10983"><span class="lineNum">   10983 </span>            :           printf (&quot;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ \n&quot;);</a>
<a name="10984"><span class="lineNum">   10984 </span>            : #endif</a>
<a name="10985"><span class="lineNum">   10985 </span><span class="lineNoCov">          0 :           SgScopeStatement* currentScope = namespaceAliasDeclaration-&gt;get_scope();</span></a>
<a name="10986"><span class="lineNum">   10986 </span><span class="lineNoCov">          0 :           ASSERT_not_null(currentScope);</span></a>
<a name="10987"><span class="lineNum">   10987 </span>            : </a>
<a name="10988"><span class="lineNum">   10988 </span><span class="lineNoCov">          0 :           int amountOfNameQualificationRequired = nameQualificationDepth(namespaceDeclaration,currentScope,namespaceAliasDeclaration);</span></a>
<a name="10989"><span class="lineNum">   10989 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || 0</a>
<a name="10990"><span class="lineNum">   10990 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;SgNamespaceAliasDeclarationStatement's SgNamespaceDeclarationStatement: amountOfNameQualificationRequired = %d \n&quot;,amountOfNameQualificationRequired);</a>
<a name="10991"><span class="lineNum">   10991 </span>            : #endif</a>
<a name="10992"><span class="lineNum">   10992 </span><span class="lineNoCov">          0 :           setNameQualification(namespaceAliasDeclaration,namespaceDeclaration,amountOfNameQualificationRequired);</span></a>
<a name="10993"><span class="lineNum">   10993 </span>            : </a>
<a name="10994"><span class="lineNum">   10994 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || 0</a>
<a name="10995"><span class="lineNum">   10995 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;DONE: SgNamespaceAliasDeclarationStatement's SgNamespaceDeclarationStatement: amountOfNameQualificationRequired = %d \n&quot;,amountOfNameQualificationRequired);</a>
<a name="10996"><span class="lineNum">   10996 </span>            : #endif</a>
<a name="10997"><span class="lineNum">   10997 </span>            : #if 0</a>
<a name="10998"><span class="lineNum">   10998 </span>            :        // We want to debug this case later!</a>
<a name="10999"><span class="lineNum">   10999 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Exiting in unimplemented case of name qualification for the SgNamespaceDeclarationStatement in a SgNamespaceAliasDeclarationStatement \n&quot;);</a>
<a name="11000"><span class="lineNum">   11000 </span>            :           ROSE_ABORT();</a>
<a name="11001"><span class="lineNum">   11001 </span>            : #endif</a>
<a name="11002"><span class="lineNum">   11002 </span>            :         }</a>
<a name="11003"><span class="lineNum">   11003 </span>            : </a>
<a name="11004"><span class="lineNum">   11004 </span><span class="lineCov">    2810440 :      SgNonrealRefExp * nrRefExp = isSgNonrealRefExp(n);</span></a>
<a name="11005"><span class="lineNum">   11005 </span><span class="lineCov">    2810440 :      if (nrRefExp != NULL) {</span></a>
<a name="11006"><span class="lineNum">   11006 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="11007"><span class="lineNum">   11007 </span>            :         mfprintf(mlog [ WARN ] ) (&quot;case SgNonrealRefExp: nrRefExp = %p\n&quot;, nrRefExp);</a>
<a name="11008"><span class="lineNum">   11008 </span>            : #endif</a>
<a name="11009"><span class="lineNum">   11009 </span><span class="lineCov">      13159 :        SgNonrealSymbol * nrsym = nrRefExp-&gt;get_symbol();</span></a>
<a name="11010"><span class="lineNum">   11010 </span><span class="lineCov">      13159 :        ASSERT_not_null(nrsym);</span></a>
<a name="11011"><span class="lineNum">   11011 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="11012"><span class="lineNum">   11012 </span>            :        mfprintf(mlog [ WARN ] ) (&quot; --- nrsym = %p : %s\n&quot;, nrsym, nrsym-&gt;get_name().str());</a>
<a name="11013"><span class="lineNum">   11013 </span>            : #endif</a>
<a name="11014"><span class="lineNum">   11014 </span>            : </a>
<a name="11015"><span class="lineNum">   11015 </span><span class="lineCov">      13159 :        SgNonrealDecl * nrdecl = nrsym-&gt;get_declaration();</span></a>
<a name="11016"><span class="lineNum">   11016 </span><span class="lineCov">      13159 :        ASSERT_not_null(nrdecl);</span></a>
<a name="11017"><span class="lineNum">   11017 </span>            : </a>
<a name="11018"><span class="lineNum">   11018 </span><span class="lineCov">      13159 :        SgStatement* currentStatement = TransformationSupport::getStatement(nrRefExp);</span></a>
<a name="11019"><span class="lineNum">   11019 </span><span class="lineCov">      13159 :        if (currentStatement != NULL) {</span></a>
<a name="11020"><span class="lineNum">   11020 </span><span class="lineCov">      13148 :          SgScopeStatement* currentScope = currentStatement-&gt;get_scope();</span></a>
<a name="11021"><span class="lineNum">   11021 </span>            : </a>
<a name="11022"><span class="lineNum">   11022 </span><span class="lineCov">      13148 :          evaluateNameQualificationForTemplateArgumentList(nrdecl-&gt;get_tpl_args(), currentScope, currentStatement);</span></a>
<a name="11023"><span class="lineNum">   11023 </span>            : </a>
<a name="11024"><span class="lineNum">   11024 </span><span class="lineCov">      13148 :          SgDeclarationStatement * declstmt = nrdecl;</span></a>
<a name="11025"><span class="lineNum">   11025 </span><span class="lineCov">      13148 :          if (nrdecl-&gt;get_templateDeclaration() != NULL) {</span></a>
<a name="11026"><span class="lineNum">   11026 </span><span class="lineCov">       1443 :            declstmt = nrdecl-&gt;get_templateDeclaration();</span></a>
<a name="11027"><span class="lineNum">   11027 </span>            :          }</a>
<a name="11028"><span class="lineNum">   11028 </span>            : </a>
<a name="11029"><span class="lineNum">   11029 </span><span class="lineCov">      13148 :          int amountOfNameQualificationRequired = nameQualificationDepth(declstmt, currentScope, currentStatement);</span></a>
<a name="11030"><span class="lineNum">   11030 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="11031"><span class="lineNum">   11031 </span>            :          mfprintf(mlog [ WARN ] ) (&quot; --- amountOfNameQualificationRequired = %d\n&quot;, amountOfNameQualificationRequired);</a>
<a name="11032"><span class="lineNum">   11032 </span>            : #endif</a>
<a name="11033"><span class="lineNum">   11033 </span><span class="lineCov">      13148 :          setNameQualification(nrRefExp, declstmt, amountOfNameQualificationRequired);</span></a>
<a name="11034"><span class="lineNum">   11034 </span>            :        }</a>
<a name="11035"><span class="lineNum">   11035 </span>            :      } else {</a>
<a name="11036"><span class="lineNum">   11036 </span>            : #if WARNING_FOR_NONREAL_DEVEL</a>
<a name="11037"><span class="lineNum">   11037 </span>            :        mfprintf(mlog [ WARN ] ) (&quot;Skipping name-qualification of SgNonrealRefExp as no enclosing statement could be found ROSE-1701 (not an issue while template are unparsed from string).\n&quot;);</a>
<a name="11038"><span class="lineNum">   11038 </span>            : #endif</a>
<a name="11039"><span class="lineNum">   11039 </span>            :      }</a>
<a name="11040"><span class="lineNum">   11040 </span>            : </a>
<a name="11041"><span class="lineNum">   11041 </span>            :   // DQ (5/12/2011): We want to located name qualification information about referenced functions</a>
<a name="11042"><span class="lineNum">   11042 </span>            :   // at the SgFunctionRefExp and SgMemberFunctionRefExp IR node instead of the SgFunctionCallExp IR node.</a>
<a name="11043"><span class="lineNum">   11043 </span><span class="lineCov">    2810440 :      SgFunctionRefExp* functionRefExp = isSgFunctionRefExp(n);</span></a>
<a name="11044"><span class="lineNum">   11044 </span><span class="lineCov">    2810440 :      if (functionRefExp != NULL)</span></a>
<a name="11045"><span class="lineNum">   11045 </span>            :         {</a>
<a name="11046"><span class="lineNum">   11046 </span>            : #if 0</a>
<a name="11047"><span class="lineNum">   11047 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;In evaluateInheritedAttribute(): case functionRefExp: inheritedAttribute.get_currentScope() = %p \n&quot;,inheritedAttribute.get_currentScope());</a>
<a name="11048"><span class="lineNum">   11048 </span>            :           if (inheritedAttribute.get_currentScope() != NULL)</a>
<a name="11049"><span class="lineNum">   11049 </span>            :              {</a>
<a name="11050"><span class="lineNum">   11050 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;In evaluateInheritedAttribute(): case functionRefExp: inheritedAttribute.get_currentScope() = %p = %s \n&quot;,</a>
<a name="11051"><span class="lineNum">   11051 </span>            :                     inheritedAttribute.get_currentScope(),inheritedAttribute.get_currentScope()-&gt;class_name().c_str());</a>
<a name="11052"><span class="lineNum">   11052 </span>            :              }</a>
<a name="11053"><span class="lineNum">   11053 </span>            :             else</a>
<a name="11054"><span class="lineNum">   11054 </span>            :              {</a>
<a name="11055"><span class="lineNum">   11055 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;In evaluateInheritedAttribute(): case functionRefExp: inheritedAttribute.get_currentScope() NOT set \n&quot;);</a>
<a name="11056"><span class="lineNum">   11056 </span>            :              }</a>
<a name="11057"><span class="lineNum">   11057 </span>            : #endif</a>
<a name="11058"><span class="lineNum">   11058 </span>            : </a>
<a name="11059"><span class="lineNum">   11059 </span><span class="lineCov">       6091 :           SgFunctionDeclaration* functionDeclaration = functionRefExp-&gt;getAssociatedFunctionDeclaration();</span></a>
<a name="11060"><span class="lineNum">   11060 </span>            :        // ASSERT_not_null(functionDeclaration);</a>
<a name="11061"><span class="lineNum">   11061 </span><span class="lineCov">       6091 :           if (functionDeclaration != NULL)</span></a>
<a name="11062"><span class="lineNum">   11062 </span>            :              {</a>
<a name="11063"><span class="lineNum">   11063 </span><span class="lineCov">       6091 :                SgStatement* currentStatement = TransformationSupport::getStatement(functionRefExp);</span></a>
<a name="11064"><span class="lineNum">   11064 </span>            : </a>
<a name="11065"><span class="lineNum">   11065 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="11066"><span class="lineNum">   11066 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;!!!!!!!!!!!!!!! case SgFunctionRefExp: currentStatement = %p = %s \n&quot;,currentStatement,currentStatement-&gt;class_name().c_str());</a>
<a name="11067"><span class="lineNum">   11067 </span>            : #endif</a>
<a name="11068"><span class="lineNum">   11068 </span>            :             // DQ (9/17/2011); Added escape for where the currentStatement == NULL (fails for STL code when the original expression trees are used to eliminate the constant folded values).</a>
<a name="11069"><span class="lineNum">   11069 </span>            :             // ASSERT_not_null(currentStatement);</a>
<a name="11070"><span class="lineNum">   11070 </span><span class="lineCov">       6091 :                if (currentStatement != NULL)</span></a>
<a name="11071"><span class="lineNum">   11071 </span>            :                   {</a>
<a name="11072"><span class="lineNum">   11072 </span>            :                  // DQ (3/15/2019): If this is part of an recursive call then the inheritedAttribute.get_currentScope()</a>
<a name="11073"><span class="lineNum">   11073 </span>            :                  // is set and we should use it as the currentScope.</a>
<a name="11074"><span class="lineNum">   11074 </span>            :                  // DQ (9/17/2011): this is the original case we want to restore later...</a>
<a name="11075"><span class="lineNum">   11075 </span>            :                  // SgScopeStatement* currentScope = currentStatement-&gt;get_scope();</a>
<a name="11076"><span class="lineNum">   11076 </span><span class="lineCov">       6091 :                     SgScopeStatement* currentScope = NULL;</span></a>
<a name="11077"><span class="lineNum">   11077 </span><span class="lineCov">       6091 :                     if (inheritedAttribute.get_currentScope() != NULL)</span></a>
<a name="11078"><span class="lineNum">   11078 </span>            :                        {</a>
<a name="11079"><span class="lineNum">   11079 </span>            : #if 0</a>
<a name="11080"><span class="lineNum">   11080 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;Using scope set from a recursive call to name qualification \n&quot;);</a>
<a name="11081"><span class="lineNum">   11081 </span>            : #endif</a>
<a name="11082"><span class="lineNum">   11082 </span><span class="lineCov">       6091 :                          currentScope = inheritedAttribute.get_currentScope();</span></a>
<a name="11083"><span class="lineNum">   11083 </span>            :                        }</a>
<a name="11084"><span class="lineNum">   11084 </span>            :                       else</a>
<a name="11085"><span class="lineNum">   11085 </span>            :                        {</a>
<a name="11086"><span class="lineNum">   11086 </span>            : #if 0</a>
<a name="11087"><span class="lineNum">   11087 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;Using scope set from the scope of the currentStatement \n&quot;);</a>
<a name="11088"><span class="lineNum">   11088 </span>            : #endif</a>
<a name="11089"><span class="lineNum">   11089 </span><span class="lineNoCov">          0 :                          currentScope = currentStatement-&gt;get_scope();</span></a>
<a name="11090"><span class="lineNum">   11090 </span>            :                        }</a>
<a name="11091"><span class="lineNum">   11091 </span>            :                  // ASSERT_not_null(currentScope);</a>
<a name="11092"><span class="lineNum">   11092 </span>            : </a>
<a name="11093"><span class="lineNum">   11093 </span>            :                  // DQ (1/31/2019): If this is a member function or template member function instantiation, AND it is definted</a>
<a name="11094"><span class="lineNum">   11094 </span>            :                  // outside of the class scope THEN we need to use the structural scope instead of the logical scope.</a>
<a name="11095"><span class="lineNum">   11095 </span><span class="lineCov">       6091 :                     if (currentScope != NULL)</span></a>
<a name="11096"><span class="lineNum">   11096 </span>            :                        {</a>
<a name="11097"><span class="lineNum">   11097 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="11098"><span class="lineNum">   11098 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;!!!!!!!!!!!!!!! currentScope = %p = %s \n&quot;,currentScope,currentScope-&gt;class_name().c_str());</a>
<a name="11099"><span class="lineNum">   11099 </span>            : #endif</a>
<a name="11100"><span class="lineNum">   11100 </span><span class="lineCov">       6091 :                          SgStatement* parentStatement = isSgStatement(currentStatement-&gt;get_parent());</span></a>
<a name="11101"><span class="lineNum">   11101 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="11102"><span class="lineNum">   11102 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;!!!!!!!!!!!!!!! parentStatement = %p = %s \n&quot;,parentStatement,parentStatement-&gt;class_name().c_str());</a>
<a name="11103"><span class="lineNum">   11103 </span>            : #endif</a>
<a name="11104"><span class="lineNum">   11104 </span><span class="lineCov">       6091 :                          if (parentStatement != currentScope)</span></a>
<a name="11105"><span class="lineNum">   11105 </span>            :                             {</a>
<a name="11106"><span class="lineNum">   11106 </span><span class="lineCov">        361 :                               currentScope = parentStatement-&gt;get_scope();</span></a>
<a name="11107"><span class="lineNum">   11107 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="11108"><span class="lineNum">   11108 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;!!!!!!!!!!!!!!! RESETTING VIA PARENT: currentScope = %p = %s \n&quot;,currentScope,currentScope-&gt;class_name().c_str());</a>
<a name="11109"><span class="lineNum">   11109 </span>            : #endif</a>
<a name="11110"><span class="lineNum">   11110 </span>            :                             }</a>
<a name="11111"><span class="lineNum">   11111 </span>            : #if 0</a>
<a name="11112"><span class="lineNum">   11112 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="11113"><span class="lineNum">   11113 </span>            :                          ROSE_ABORT();</a>
<a name="11114"><span class="lineNum">   11114 </span>            : #endif</a>
<a name="11115"><span class="lineNum">   11115 </span>            :                        }</a>
<a name="11116"><span class="lineNum">   11116 </span>            : </a>
<a name="11117"><span class="lineNum">   11117 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="11118"><span class="lineNum">   11118 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;case SgFunctionRefExp: currentScope = %p = %s \n&quot;,currentScope,currentScope-&gt;class_name().c_str());</a>
<a name="11119"><span class="lineNum">   11119 </span>            : #endif</a>
<a name="11120"><span class="lineNum">   11120 </span><span class="lineCov">       6091 :                     int amountOfNameQualificationRequired = nameQualificationDepth(functionDeclaration,currentScope,currentStatement);</span></a>
<a name="11121"><span class="lineNum">   11121 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="11122"><span class="lineNum">   11122 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;SgFunctionCallExp's function name: amountOfNameQualificationRequired = %d \n&quot;,amountOfNameQualificationRequired);</a>
<a name="11123"><span class="lineNum">   11123 </span>            : #endif</a>
<a name="11124"><span class="lineNum">   11124 </span>            :                  // DQ (6/9/2011): Support for test2011_78.C (we only qualify function call references where the function has been declared in</a>
<a name="11125"><span class="lineNum">   11125 </span>            :                  // a scope where it could be expected to be defined (e.g. not using a forward declaration in a SgBasicBlock, since the function</a>
<a name="11126"><span class="lineNum">   11126 </span>            :                  // definition could not live in the SgBasicBlock.</a>
<a name="11127"><span class="lineNum">   11127 </span><span class="lineCov">       6091 :                     bool skipNameQualification = skipNameQualificationIfNotProperlyDeclaredWhereDeclarationIsDefinable(functionDeclaration);</span></a>
<a name="11128"><span class="lineNum">   11128 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="11129"><span class="lineNum">   11129 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Test of functionRefExp: skipNameQualification = %s \n&quot;,skipNameQualification ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="11130"><span class="lineNum">   11130 </span>            : #endif</a>
<a name="11131"><span class="lineNum">   11131 </span><span class="lineCov">       6091 :                     if (skipNameQualification == false)</span></a>
<a name="11132"><span class="lineNum">   11132 </span>            :                        {</a>
<a name="11133"><span class="lineNum">   11133 </span><span class="lineCov">       6086 :                          setNameQualification(functionRefExp,functionDeclaration,amountOfNameQualificationRequired);</span></a>
<a name="11134"><span class="lineNum">   11134 </span>            :                        }</a>
<a name="11135"><span class="lineNum">   11135 </span>            :                   }</a>
<a name="11136"><span class="lineNum">   11136 </span>            :                  else</a>
<a name="11137"><span class="lineNum">   11137 </span>            :                   {</a>
<a name="11138"><span class="lineNum">   11138 </span>            : #if 0</a>
<a name="11139"><span class="lineNum">   11139 </span>            :                  // DQ (3/5/2017): Converted to use message logging.</a>
<a name="11140"><span class="lineNum">   11140 </span>            :                  // DQ (9/17/2011): Added this case, print a warning and fix thiat after debugging the constant folding value elimination..</a>
<a name="11141"><span class="lineNum">   11141 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;WARNING: SgFunctionRefExp name qualification not handled for the case of currentStatement == NULL \n&quot;);</a>
<a name="11142"><span class="lineNum">   11142 </span>            : #endif</a>
<a name="11143"><span class="lineNum">   11143 </span>            :                   }</a>
<a name="11144"><span class="lineNum">   11144 </span>            :              }</a>
<a name="11145"><span class="lineNum">   11145 </span>            :             else</a>
<a name="11146"><span class="lineNum">   11146 </span>            :              {</a>
<a name="11147"><span class="lineNum">   11147 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="11148"><span class="lineNum">   11148 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;WARNING: functionDeclaration == NULL in SgFunctionCallExp for name qualification support! \n&quot;);</a>
<a name="11149"><span class="lineNum">   11149 </span>            : #endif</a>
<a name="11150"><span class="lineNum">   11150 </span>            :              }</a>
<a name="11151"><span class="lineNum">   11151 </span>            : </a>
<a name="11152"><span class="lineNum">   11152 </span>            :        // If this is a templated function then we have to save the name because its templated name might have template arguments that require name qualification.</a>
<a name="11153"><span class="lineNum">   11153 </span><span class="lineCov">       6091 :           SgTemplateInstantiationFunctionDecl* templateInstantiationFunctionDeclaration = isSgTemplateInstantiationFunctionDecl(functionRefExp-&gt;getAssociatedFunctionDeclaration());</span></a>
<a name="11154"><span class="lineNum">   11154 </span><span class="lineCov">       6091 :           if (templateInstantiationFunctionDeclaration != NULL)</span></a>
<a name="11155"><span class="lineNum">   11155 </span>            :              {</a>
<a name="11156"><span class="lineNum">   11156 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="11157"><span class="lineNum">   11157 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Found a SgTemplateInstantiationFunctionDecl that will have template arguments that might require qualification. name = %s \n&quot;,templateInstantiationFunctionDeclaration-&gt;get_name().str());</a>
<a name="11158"><span class="lineNum">   11158 </span>            : #endif</a>
<a name="11159"><span class="lineNum">   11159 </span>            :             // DQ (12/18/2016): When this is a function call in an array type index expression we can't identify an associated statement.</a>
<a name="11160"><span class="lineNum">   11160 </span><span class="lineCov">        973 :                SgStatement* currentStatement = TransformationSupport::getStatement(functionRefExp);</span></a>
<a name="11161"><span class="lineNum">   11161 </span>            :             // ASSERT_not_null(currentStatement);</a>
<a name="11162"><span class="lineNum">   11162 </span><span class="lineCov">        973 :                if (currentStatement != NULL)</span></a>
<a name="11163"><span class="lineNum">   11163 </span>            :                   {</a>
<a name="11164"><span class="lineNum">   11164 </span><span class="lineCov">        973 :                     SgScopeStatement* currentScope = currentStatement-&gt;get_scope();</span></a>
<a name="11165"><span class="lineNum">   11165 </span><span class="lineCov">        973 :                     ASSERT_not_null(currentScope);</span></a>
<a name="11166"><span class="lineNum">   11166 </span>            : </a>
<a name="11167"><span class="lineNum">   11167 </span>            :                  // traverseTemplatedFunction(functionRefExp,templateInstantiationFunctionDeclaration,currentScope,currentStatement);</a>
<a name="11168"><span class="lineNum">   11168 </span><span class="lineCov">        973 :                     traverseTemplatedFunction(functionRefExp,functionRefExp,currentScope,currentStatement);</span></a>
<a name="11169"><span class="lineNum">   11169 </span>            :                   }</a>
<a name="11170"><span class="lineNum">   11170 </span>            :                  else</a>
<a name="11171"><span class="lineNum">   11171 </span>            :                   {</a>
<a name="11172"><span class="lineNum">   11172 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="11173"><span class="lineNum">   11173 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Note: Name qualification: parent statement could not be identified (may be hidden in array type index) for functionRefExp = %p = %s \n&quot;,functionRefExp,functionRefExp-&gt;class_name().c_str());</a>
<a name="11174"><span class="lineNum">   11174 </span>            : #endif</a>
<a name="11175"><span class="lineNum">   11175 </span>            :                   }</a>
<a name="11176"><span class="lineNum">   11176 </span>            :              }</a>
<a name="11177"><span class="lineNum">   11177 </span>            :         }</a>
<a name="11178"><span class="lineNum">   11178 </span>            : </a>
<a name="11179"><span class="lineNum">   11179 </span>            : </a>
<a name="11180"><span class="lineNum">   11180 </span>            : #define PSEUDO_DESTRUCTOR_REF_SUPPORT 1</a>
<a name="11181"><span class="lineNum">   11181 </span>            : </a>
<a name="11182"><span class="lineNum">   11182 </span>            : #if PSEUDO_DESTRUCTOR_REF_SUPPORT</a>
<a name="11183"><span class="lineNum">   11183 </span>            :   // DQ (1/18/2020): Adding support for SgPseudoDestructorRefExp (see C++11_tests/test2020_56.C).</a>
<a name="11184"><span class="lineNum">   11184 </span><span class="lineCov">    2810440 :      SgPseudoDestructorRefExp* pseudoDestructorRefExp = isSgPseudoDestructorRefExp(n);</span></a>
<a name="11185"><span class="lineNum">   11185 </span><span class="lineCov">    2810440 :      if (pseudoDestructorRefExp != NULL)</span></a>
<a name="11186"><span class="lineNum">   11186 </span>            :         {</a>
<a name="11187"><span class="lineNum">   11187 </span>            : </a>
<a name="11188"><span class="lineNum">   11188 </span>            : #define DEBUG_PSEUDO_DESTRUCTOR_REF (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || 0</a>
<a name="11189"><span class="lineNum">   11189 </span>            : </a>
<a name="11190"><span class="lineNum">   11190 </span>            : #if DEBUG_PSEUDO_DESTRUCTOR_REF</a>
<a name="11191"><span class="lineNum">   11191 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Detected SgPseudoDestructorRefExp: pseudoDestructorRefExp = %p \n&quot;,pseudoDestructorRefExp);</a>
<a name="11192"><span class="lineNum">   11192 </span>            : #endif</a>
<a name="11193"><span class="lineNum">   11193 </span><span class="lineNoCov">          0 :           SgType* type = pseudoDestructorRefExp-&gt;get_object_type();</span></a>
<a name="11194"><span class="lineNum">   11194 </span><span class="lineNoCov">          0 :           ASSERT_not_null(type);</span></a>
<a name="11195"><span class="lineNum">   11195 </span>            : </a>
<a name="11196"><span class="lineNum">   11196 </span><span class="lineNoCov">          0 :           SgNamedType* namedType = isSgNamedType(type);</span></a>
<a name="11197"><span class="lineNum">   11197 </span><span class="lineNoCov">          0 :           ASSERT_not_null(namedType);</span></a>
<a name="11198"><span class="lineNum">   11198 </span>            : </a>
<a name="11199"><span class="lineNum">   11199 </span><span class="lineNoCov">          0 :           SgDeclarationStatement* declarationStatement = namedType-&gt;get_declaration();</span></a>
<a name="11200"><span class="lineNum">   11200 </span><span class="lineNoCov">          0 :           ASSERT_not_null(declarationStatement);</span></a>
<a name="11201"><span class="lineNum">   11201 </span>            : </a>
<a name="11202"><span class="lineNum">   11202 </span>            :        // if (memberFunctionDeclaration != NULL)</a>
<a name="11203"><span class="lineNum">   11203 </span><span class="lineNoCov">          0 :           if (declarationStatement != NULL)</span></a>
<a name="11204"><span class="lineNum">   11204 </span>            :              {</a>
<a name="11205"><span class="lineNum">   11205 </span>            :             // DQ (2/17/2019): Adding support for pointers to member functions.</a>
<a name="11206"><span class="lineNum">   11206 </span>            :             // if (isMemberFunctionMemberReference == false)</a>
<a name="11207"><span class="lineNum">   11207 </span>            :             // if (isMemberFunctionMemberReference == false || isAddressTaken == true)</a>
<a name="11208"><span class="lineNum">   11208 </span>            : </a>
<a name="11209"><span class="lineNum">   11209 </span>            :             // DQ (2/23/2019): Except that this code works in all cases that I can see at the moment, I think that the</a>
<a name="11210"><span class="lineNum">   11210 </span>            :             // current scope should be taken from the type of the pointer being dereferenced instead of from the location</a>
<a name="11211"><span class="lineNum">   11211 </span>            :             // of the statement containing the memberFunctionRefExp.  But I can't build a counter example that fails.</a>
<a name="11212"><span class="lineNum">   11212 </span>            : </a>
<a name="11213"><span class="lineNum">   11213 </span><span class="lineNoCov">          0 :                SgStatement* currentStatement = TransformationSupport::getStatement(pseudoDestructorRefExp);</span></a>
<a name="11214"><span class="lineNum">   11214 </span>            : </a>
<a name="11215"><span class="lineNum">   11215 </span>            : #if DEBUG_PSEUDO_DESTRUCTOR_REF</a>
<a name="11216"><span class="lineNum">   11216 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Compute the currentStatement: currentStatement = %p \n&quot;,currentStatement);</a>
<a name="11217"><span class="lineNum">   11217 </span>            : #endif</a>
<a name="11218"><span class="lineNum">   11218 </span><span class="lineNoCov">          0 :                if (currentStatement == NULL)</span></a>
<a name="11219"><span class="lineNum">   11219 </span>            :                   {</a>
<a name="11220"><span class="lineNum">   11220 </span><span class="lineNoCov">          0 :                     mfprintf(mlog [ WARN ] ) (&quot;Error: Location of where we can NOT associate the expression to a statement \n&quot;);</span></a>
<a name="11221"><span class="lineNum">   11221 </span><span class="lineNoCov">          0 :                     pseudoDestructorRefExp-&gt;get_file_info()-&gt;display(&quot;Error: currentStatement == NULL: memberFunctionRefExp: debug&quot;);</span></a>
<a name="11222"><span class="lineNum">   11222 </span><span class="lineNoCov">          0 :                     declarationStatement-&gt;get_file_info()  -&gt;display(&quot;Error: currentStatement == NULL: memberFunctionDeclaration: debug&quot;);</span></a>
<a name="11223"><span class="lineNum">   11223 </span>            :                   }</a>
<a name="11224"><span class="lineNum">   11224 </span><span class="lineNoCov">          0 :                ASSERT_not_null(currentStatement);</span></a>
<a name="11225"><span class="lineNum">   11225 </span>            : </a>
<a name="11226"><span class="lineNum">   11226 </span>            : #if DEBUG_PSEUDO_DESTRUCTOR_REF</a>
<a name="11227"><span class="lineNum">   11227 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;case of SgPseudoDestructorRefExp: currentStatement = %p = %s \n&quot;,currentStatement,currentStatement-&gt;class_name().c_str());</a>
<a name="11228"><span class="lineNum">   11228 </span>            : #endif</a>
<a name="11229"><span class="lineNum">   11229 </span><span class="lineNoCov">          0 :                SgScopeStatement* currentScope = currentStatement-&gt;get_scope();</span></a>
<a name="11230"><span class="lineNum">   11230 </span><span class="lineNoCov">          0 :                ASSERT_not_null(currentScope);</span></a>
<a name="11231"><span class="lineNum">   11231 </span>            : </a>
<a name="11232"><span class="lineNum">   11232 </span>            : #if DEBUG_PSEUDO_DESTRUCTOR_REF</a>
<a name="11233"><span class="lineNum">   11233 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;case of SgPseudoDestructorRefExp: currentScope = %p = %s \n&quot;,currentScope,currentScope-&gt;class_name().c_str());</a>
<a name="11234"><span class="lineNum">   11234 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;***** case of SgPseudoDestructorRefExp: Calling nameQualificationDepth() ***** \n&quot;);</a>
<a name="11235"><span class="lineNum">   11235 </span>            : #endif</a>
<a name="11236"><span class="lineNum">   11236 </span>            :             // int amountOfNameQualificationRequired = nameQualificationDepth(memberFunctionDeclaration,currentScope,currentStatement);</a>
<a name="11237"><span class="lineNum">   11237 </span><span class="lineNoCov">          0 :                int amountOfNameQualificationRequired = nameQualificationDepth(declarationStatement,currentScope,currentStatement);</span></a>
<a name="11238"><span class="lineNum">   11238 </span>            : </a>
<a name="11239"><span class="lineNum">   11239 </span>            : #if DEBUG_PSEUDO_DESTRUCTOR_REF</a>
<a name="11240"><span class="lineNum">   11240 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;***** case of SgPseudoDestructorRefExp: DONE: Calling nameQualificationDepth() ***** \n&quot;);</a>
<a name="11241"><span class="lineNum">   11241 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;SgPseudoDestructorRefExp's name: amountOfNameQualificationRequired = %d \n&quot;,amountOfNameQualificationRequired);</a>
<a name="11242"><span class="lineNum">   11242 </span>            : #endif</a>
<a name="11243"><span class="lineNum">   11243 </span>            :                  // setNameQualification(memberFunctionRefExp,memberFunctionDeclaration,amountOfNameQualificationRequired);</a>
<a name="11244"><span class="lineNum">   11244 </span><span class="lineNoCov">          0 :                     setNameQualification(pseudoDestructorRefExp,declarationStatement,amountOfNameQualificationRequired);</span></a>
<a name="11245"><span class="lineNum">   11245 </span>            :                  // DQ (2/17/2019): Case of xxx !(isDataMemberReference == true &amp;&amp; isAddressTaken == true)</a>
<a name="11246"><span class="lineNum">   11246 </span>            :              }</a>
<a name="11247"><span class="lineNum">   11247 </span>            :             else</a>
<a name="11248"><span class="lineNum">   11248 </span>            :              {</a>
<a name="11249"><span class="lineNum">   11249 </span>            : #if DEBUG_PSEUDO_DESTRUCTOR_REF || 0</a>
<a name="11250"><span class="lineNum">   11250 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;WARNING: declarationStatement == NULL in SgPseudoDestructorRefExp for name qualification support! \n&quot;);</a>
<a name="11251"><span class="lineNum">   11251 </span>            : #endif</a>
<a name="11252"><span class="lineNum">   11252 </span>            :              }</a>
<a name="11253"><span class="lineNum">   11253 </span>            : #if 0</a>
<a name="11254"><span class="lineNum">   11254 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="11255"><span class="lineNum">   11255 </span>            :           ROSE_ABORT();</a>
<a name="11256"><span class="lineNum">   11256 </span>            : #endif</a>
<a name="11257"><span class="lineNum">   11257 </span>            :         }</a>
<a name="11258"><span class="lineNum">   11258 </span>            : </a>
<a name="11259"><span class="lineNum">   11259 </span>            : // #endif for #if PSEUDO_DESTRUCTOR_REF_SUPPORT</a>
<a name="11260"><span class="lineNum">   11260 </span>            : #endif</a>
<a name="11261"><span class="lineNum">   11261 </span>            : </a>
<a name="11262"><span class="lineNum">   11262 </span>            : </a>
<a name="11263"><span class="lineNum">   11263 </span><span class="lineCov">    2810440 :      SgMemberFunctionRefExp* memberFunctionRefExp = isSgMemberFunctionRefExp(n);</span></a>
<a name="11264"><span class="lineNum">   11264 </span><span class="lineCov">    2810440 :      if (memberFunctionRefExp != NULL)</span></a>
<a name="11265"><span class="lineNum">   11265 </span>            :         {</a>
<a name="11266"><span class="lineNum">   11266 </span><span class="lineCov">       5161 :           SgMemberFunctionDeclaration* memberFunctionDeclaration = memberFunctionRefExp-&gt;getAssociatedMemberFunctionDeclaration();</span></a>
<a name="11267"><span class="lineNum">   11267 </span>            :        // ASSERT_not_null(functionDeclaration);</a>
<a name="11268"><span class="lineNum">   11268 </span>            : </a>
<a name="11269"><span class="lineNum">   11269 </span>            : #define DEBUG_MEMBER_FUNCTION_REF (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || 0</a>
<a name="11270"><span class="lineNum">   11270 </span>            : </a>
<a name="11271"><span class="lineNum">   11271 </span>            : #if DEBUG_MEMBER_FUNCTION_REF</a>
<a name="11272"><span class="lineNum">   11272 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;case of SgMemberFunctionRefExp: memberFunctionDeclaration = %p \n&quot;,memberFunctionDeclaration);</a>
<a name="11273"><span class="lineNum">   11273 </span>            : #endif</a>
<a name="11274"><span class="lineNum">   11274 </span>            : </a>
<a name="11275"><span class="lineNum">   11275 </span>            :        // DQ (2/7/2019): Adding support for name qualification induced from SgPointerMemberType function paramters.</a>
<a name="11276"><span class="lineNum">   11276 </span><span class="lineCov">       5161 :           bool nameQualificationInducedFromPointerMemberType = false;</span></a>
<a name="11277"><span class="lineNum">   11277 </span>            : </a>
<a name="11278"><span class="lineNum">   11278 </span><span class="lineCov">       5161 :           bool isMemberFunctionMemberReference = SageInterface::isMemberFunctionMemberReference(memberFunctionRefExp);</span></a>
<a name="11279"><span class="lineNum">   11279 </span><span class="lineCov">       5161 :           bool isAddressTaken                  = SageInterface::isAddressTaken(memberFunctionRefExp);</span></a>
<a name="11280"><span class="lineNum">   11280 </span>            : </a>
<a name="11281"><span class="lineNum">   11281 </span>            : #if DEBUG_MEMBER_FUNCTION_REF</a>
<a name="11282"><span class="lineNum">   11282 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;isMemberFunctionMemberReference = %s \n&quot;,isMemberFunctionMemberReference ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="11283"><span class="lineNum">   11283 </span>            : #endif</a>
<a name="11284"><span class="lineNum">   11284 </span>            :        // DQ (2/23/2019): I think that the test code test2019_191.C is not setting this correctly. The logic for</a>
<a name="11285"><span class="lineNum">   11285 </span>            :        // member function pointers (references) is not yet worked out as well as for data membr references.</a>
<a name="11286"><span class="lineNum">   11286 </span>            : #if DEBUG_MEMBER_FUNCTION_REF</a>
<a name="11287"><span class="lineNum">   11287 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Explicitly setting isMemberFunctionMemberReference == false \n&quot;);</a>
<a name="11288"><span class="lineNum">   11288 </span>            : #endif</a>
<a name="11289"><span class="lineNum">   11289 </span>            :        // isMemberFunctionMemberReference = false;</a>
<a name="11290"><span class="lineNum">   11290 </span>            : </a>
<a name="11291"><span class="lineNum">   11291 </span>            : #if DEBUG_MEMBER_FUNCTION_REF || 0</a>
<a name="11292"><span class="lineNum">   11292 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Case of SgMemberFunctionRefExp: isMemberFunctionMemberReference = %s isAddressTaken = %s \n&quot;,isMemberFunctionMemberReference ? &quot;true&quot; : &quot;false&quot;,isAddressTaken ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="11293"><span class="lineNum">   11293 </span>            : #endif</a>
<a name="11294"><span class="lineNum">   11294 </span><span class="lineCov">       5161 :           if (isMemberFunctionMemberReference == true &amp;&amp; isAddressTaken == true)</span></a>
<a name="11295"><span class="lineNum">   11295 </span>            :              {</a>
<a name="11296"><span class="lineNum">   11296 </span>            : #if DEBUG_MEMBER_FUNCTION_REF || 0</a>
<a name="11297"><span class="lineNum">   11297 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Detected case of name qualification required due to pointer to member function reference \n&quot;);</a>
<a name="11298"><span class="lineNum">   11298 </span>            : #endif</a>
<a name="11299"><span class="lineNum">   11299 </span>            :                nameQualificationInducedFromPointerMemberType = true;</a>
<a name="11300"><span class="lineNum">   11300 </span>            :              }</a>
<a name="11301"><span class="lineNum">   11301 </span>            :             else</a>
<a name="11302"><span class="lineNum">   11302 </span>            :              {</a>
<a name="11303"><span class="lineNum">   11303 </span>            :             // bool isMemberFunctionMemberReference = SageInterface::isMemberFunctionMemberReference(memberFunctionRefExp);</a>
<a name="11304"><span class="lineNum">   11304 </span><span class="lineCov">       5161 :                if (isMemberFunctionMemberReference == true)</span></a>
<a name="11305"><span class="lineNum">   11305 </span>            :                   {</a>
<a name="11306"><span class="lineNum">   11306 </span>            : #if DEBUG_MEMBER_FUNCTION_REF</a>
<a name="11307"><span class="lineNum">   11307 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;This is a member function member reference requiring name qualification to the class where the data member reference is referenced \n&quot;);</a>
<a name="11308"><span class="lineNum">   11308 </span>            : #endif</a>
<a name="11309"><span class="lineNum">   11309 </span><span class="lineCov">       4119 :                     ROSE_ASSERT(isAddressTaken == false);</span></a>
<a name="11310"><span class="lineNum">   11310 </span>            : </a>
<a name="11311"><span class="lineNum">   11311 </span>            :                  // DQ (2/17/2019): Debugging pointer to membr function (similar to pointer to member data).</a>
<a name="11312"><span class="lineNum">   11312 </span>            :                  // bool isAddressTaken = SageInterface::isAddressTaken(memberFunctionRefExp);</a>
<a name="11313"><span class="lineNum">   11313 </span>            :                  // mfprintf(mlog [ WARN ] ) (&quot;isAddressTaken = %s \n&quot;,isAddressTaken ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="11314"><span class="lineNum">   11314 </span>            : </a>
<a name="11315"><span class="lineNum">   11315 </span>            :                  // std::list&lt;SgClassType*&gt; classChain = SageInterface::getClassTypeChainForDataMemberReference(memberFunctionRefExp);</a>
<a name="11316"><span class="lineNum">   11316 </span><span class="lineCov">       8238 :                     std::list&lt;SgClassType*&gt; classChain = SageInterface::getClassTypeChainForMemberReference(memberFunctionRefExp);</span></a>
<a name="11317"><span class="lineNum">   11317 </span>            : </a>
<a name="11318"><span class="lineNum">   11318 </span>            : #if DEBUG_MEMBER_FUNCTION_REF</a>
<a name="11319"><span class="lineNum">   11319 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;case SgMemberFunctionRefExp: classChain.size() = %zu \n&quot;,classChain.size());</a>
<a name="11320"><span class="lineNum">   11320 </span>            :                     std::list&lt;SgClassType*&gt;::iterator classChain_iterator = classChain.begin();</a>
<a name="11321"><span class="lineNum">   11321 </span>            :                     while (classChain_iterator != classChain.end())</a>
<a name="11322"><span class="lineNum">   11322 </span>            :                        {</a>
<a name="11323"><span class="lineNum">   11323 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot; --- *classChain_iterator = %p = %s name = %s \n&quot;,*classChain_iterator,(*classChain_iterator)-&gt;class_name().c_str(),(*classChain_iterator)-&gt;get_name().str());</a>
<a name="11324"><span class="lineNum">   11324 </span>            : </a>
<a name="11325"><span class="lineNum">   11325 </span>            :                          classChain_iterator++;</a>
<a name="11326"><span class="lineNum">   11326 </span>            :                        }</a>
<a name="11327"><span class="lineNum">   11327 </span>            : #endif</a>
<a name="11328"><span class="lineNum">   11328 </span>            : #if 0</a>
<a name="11329"><span class="lineNum">   11329 </span>            :                  // DQ (10/31/2020): This is triggered by the codes used to get codeSegregation.</a>
<a name="11330"><span class="lineNum">   11330 </span>            :                  // DQ (2/21/2019): This fails in roseTests/astOutliningTests for file: test2004_35.C.</a>
<a name="11331"><span class="lineNum">   11331 </span>            :                  // DQ (2/16/2019): I think this is always true, since base class abiguity is not allowed in the C++ language.</a>
<a name="11332"><span class="lineNum">   11332 </span>            :                  // ROSE_ASSERT(classChain.size() == 1);</a>
<a name="11333"><span class="lineNum">   11333 </span>            :                     if (classChain.size() &gt; 1)</a>
<a name="11334"><span class="lineNum">   11334 </span>            :                        {</a>
<a name="11335"><span class="lineNum">   11335 </span>            :                       // DQ (9/2/2020): This happens for Cxx11_tests/test2020_78.C</a>
<a name="11336"><span class="lineNum">   11336 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;Note: Not clear how this happens: classChain.size() &gt; 1 size = %zu \n&quot;,classChain.size());</a>
<a name="11337"><span class="lineNum">   11337 </span>            :                        }</a>
<a name="11338"><span class="lineNum">   11338 </span>            :                  // ROSE_ASSERT(classChain.empty() == true || classChain.size() == 1);</a>
<a name="11339"><span class="lineNum">   11339 </span>            : #endif</a>
<a name="11340"><span class="lineNum">   11340 </span>            :                  // DQ (2/16/2019): We need to call something like this, but specialized to just use the single class in the classChain.</a>
<a name="11341"><span class="lineNum">   11341 </span>            :                  // setNameQualification(varRefExp,variableDeclaration,amountOfNameQualificationRequired);</a>
<a name="11342"><span class="lineNum">   11342 </span>            : </a>
<a name="11343"><span class="lineNum">   11343 </span><span class="lineCov">       4119 :                     if (classChain.empty() == false)</span></a>
<a name="11344"><span class="lineNum">   11344 </span>            :                        {</a>
<a name="11345"><span class="lineNum">   11345 </span><span class="lineCov">        136 :                          std::list&lt;SgClassType*&gt;::iterator classChain_first = classChain.begin();</span></a>
<a name="11346"><span class="lineNum">   11346 </span><span class="lineCov">        408 :                          std::string qualifier = std::string((*classChain_first)-&gt;get_name().str()) + &quot;::&quot;;</span></a>
<a name="11347"><span class="lineNum">   11347 </span>            : </a>
<a name="11348"><span class="lineNum">   11348 </span>            : #if DEBUG_MEMBER_FUNCTION_REF</a>
<a name="11349"><span class="lineNum">   11349 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;data member qualifier = %s \n&quot;,qualifier.c_str());</a>
<a name="11350"><span class="lineNum">   11350 </span>            : #endif</a>
<a name="11351"><span class="lineNum">   11351 </span>            :                       // DQ (2/16/2019): Mark this as at least non-zero, but it is computed based on where the ambiguity is instead</a>
<a name="11352"><span class="lineNum">   11352 </span>            :                       // of as a length of the chain of scope from the variable referenced's variable declaration scope.</a>
<a name="11353"><span class="lineNum">   11353 </span><span class="lineCov">        136 :                          memberFunctionRefExp-&gt;set_name_qualification_length(1);</span></a>
<a name="11354"><span class="lineNum">   11354 </span>            : </a>
<a name="11355"><span class="lineNum">   11355 </span><span class="lineCov">        136 :                          memberFunctionRefExp-&gt;set_global_qualification_required(false);</span></a>
<a name="11356"><span class="lineNum">   11356 </span><span class="lineCov">        136 :                          memberFunctionRefExp-&gt;set_type_elaboration_required(false);</span></a>
<a name="11357"><span class="lineNum">   11357 </span>            : </a>
<a name="11358"><span class="lineNum">   11358 </span><span class="lineCov">        272 :                          if (qualifiedNameMapForNames.find(memberFunctionRefExp) == qualifiedNameMapForNames.end())</span></a>
<a name="11359"><span class="lineNum">   11359 </span>            :                             {</a>
<a name="11360"><span class="lineNum">   11360 </span>            : #if DEBUG_MEMBER_FUNCTION_REF</a>
<a name="11361"><span class="lineNum">   11361 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;Inserting qualifier for name = %s into list at IR node = %p = %s \n&quot;,qualifier.c_str(),memberFunctionRefExp,memberFunctionRefExp-&gt;class_name().c_str());</a>
<a name="11362"><span class="lineNum">   11362 </span>            : #endif</a>
<a name="11363"><span class="lineNum">   11363 </span><span class="lineCov">        272 :                               qualifiedNameMapForNames.insert(std::pair&lt;SgNode*,std::string&gt;(memberFunctionRefExp,qualifier));</span></a>
<a name="11364"><span class="lineNum">   11364 </span>            :                             }</a>
<a name="11365"><span class="lineNum">   11365 </span>            :                            else</a>
<a name="11366"><span class="lineNum">   11366 </span>            :                             {</a>
<a name="11367"><span class="lineNum">   11367 </span>            :                            // DQ (6/20/2011): We see this case in test2011_87.C.</a>
<a name="11368"><span class="lineNum">   11368 </span>            :                            // If it already existes then overwrite the existing information.</a>
<a name="11369"><span class="lineNum">   11369 </span><span class="lineNoCov">          0 :                               std::map&lt;SgNode*,std::string&gt;::iterator i = qualifiedNameMapForNames.find(memberFunctionRefExp);</span></a>
<a name="11370"><span class="lineNum">   11370 </span><span class="lineNoCov">          0 :                               ROSE_ASSERT (i != qualifiedNameMapForNames.end());</span></a>
<a name="11371"><span class="lineNum">   11371 </span>            : </a>
<a name="11372"><span class="lineNum">   11372 </span>            : #if DEBUG_MEMBER_FUNCTION_REF</a>
<a name="11373"><span class="lineNum">   11373 </span>            :                               string previousQualifier = i-&gt;second.c_str();</a>
<a name="11374"><span class="lineNum">   11374 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;WARNING: test 0: replacing previousQualifier = %s with new qualifier = %s \n&quot;,previousQualifier.c_str(),qualifier.c_str());</a>
<a name="11375"><span class="lineNum">   11375 </span>            : #endif</a>
<a name="11376"><span class="lineNum">   11376 </span><span class="lineNoCov">          0 :                               if (i-&gt;second != qualifier)</span></a>
<a name="11377"><span class="lineNum">   11377 </span>            :                                  {</a>
<a name="11378"><span class="lineNum">   11378 </span>            :                                 // DQ (7/23/2011): Multiple uses of the SgVarRefExp expression in SgArrayType will cause</a>
<a name="11379"><span class="lineNum">   11379 </span>            :                                 // the name qualification to be reset each time.  This is OK since it is used to build</a>
<a name="11380"><span class="lineNum">   11380 </span>            :                                 // the type name that will be saved.</a>
<a name="11381"><span class="lineNum">   11381 </span><span class="lineCov">        136 :                                    i-&gt;second = qualifier;</span></a>
<a name="11382"><span class="lineNum">   11382 </span>            : #if 0</a>
<a name="11383"><span class="lineNum">   11383 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;Note: name in qualifiedNameMapForNames already exists and is different... \n&quot;);</a>
<a name="11384"><span class="lineNum">   11384 </span>            : #endif</a>
<a name="11385"><span class="lineNum">   11385 </span>            :                                  }</a>
<a name="11386"><span class="lineNum">   11386 </span>            :                             }</a>
<a name="11387"><span class="lineNum">   11387 </span>            :                        }</a>
<a name="11388"><span class="lineNum">   11388 </span>            :                       else</a>
<a name="11389"><span class="lineNum">   11389 </span>            :                        {</a>
<a name="11390"><span class="lineNum">   11390 </span>            : #if DEBUG_MEMBER_FUNCTION_REF</a>
<a name="11391"><span class="lineNum">   11391 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;This has an empty class chain: classChain.size() = %zu \n&quot;,classChain.size());</a>
<a name="11392"><span class="lineNum">   11392 </span>            : #endif</a>
<a name="11393"><span class="lineNum">   11393 </span>            : </a>
<a name="11394"><span class="lineNum">   11394 </span>            : #if 1</a>
<a name="11395"><span class="lineNum">   11395 </span>            :                  // DQ (6/1/2019): When the function called is from a base class and conflicts with a member function</a>
<a name="11396"><span class="lineNum">   11396 </span>            :                  // in the derived class then we need additional name qualification.</a>
<a name="11397"><span class="lineNum">   11397 </span>            : </a>
<a name="11398"><span class="lineNum">   11398 </span>            : #if DEBUG_MEMBER_FUNCTION_REF</a>
<a name="11399"><span class="lineNum">   11399 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot; (isMemberFunctionMemberReference == true &amp;&amp; isAddressTaken == false) == true \n&quot;);</a>
<a name="11400"><span class="lineNum">   11400 </span>            : #endif</a>
<a name="11401"><span class="lineNum">   11401 </span>            :                  // ROSE_ASSERT (isMemberFunctionMemberReference == true &amp;&amp; isAddressTaken == false);</a>
<a name="11402"><span class="lineNum">   11402 </span>            : </a>
<a name="11403"><span class="lineNum">   11403 </span><span class="lineCov">       3983 :                     SgStatement* currentStatement = TransformationSupport::getStatement(memberFunctionRefExp);</span></a>
<a name="11404"><span class="lineNum">   11404 </span>            :                  // ASSERT_not_null(currentStatement);</a>
<a name="11405"><span class="lineNum">   11405 </span><span class="lineCov">       3983 :                     if (currentStatement != NULL)</span></a>
<a name="11406"><span class="lineNum">   11406 </span>            :                        {</a>
<a name="11407"><span class="lineNum">   11407 </span><span class="lineCov">       3983 :                          SgScopeStatement* currentScope = currentStatement-&gt;get_scope();</span></a>
<a name="11408"><span class="lineNum">   11408 </span><span class="lineCov">       3983 :                          ASSERT_not_null(currentScope);</span></a>
<a name="11409"><span class="lineNum">   11409 </span>            : </a>
<a name="11410"><span class="lineNum">   11410 </span><span class="lineCov">       3983 :                          ASSERT_not_null(memberFunctionDeclaration);</span></a>
<a name="11411"><span class="lineNum">   11411 </span>            : </a>
<a name="11412"><span class="lineNum">   11412 </span><span class="lineCov">       3983 :                          int amountOfNameQualificationRequired = nameQualificationDepth(memberFunctionDeclaration,currentScope,currentStatement);</span></a>
<a name="11413"><span class="lineNum">   11413 </span>            : </a>
<a name="11414"><span class="lineNum">   11414 </span>            : #if DEBUG_MEMBER_FUNCTION_REF</a>
<a name="11415"><span class="lineNum">   11415 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;***** case of SgMemberFunctionRefExp: DONE: Calling nameQualificationDepth() ***** \n&quot;);</a>
<a name="11416"><span class="lineNum">   11416 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;SgMemberFunctionCallExp's member function name: amountOfNameQualificationRequired = %d \n&quot;,amountOfNameQualificationRequired);</a>
<a name="11417"><span class="lineNum">   11417 </span>            : #endif</a>
<a name="11418"><span class="lineNum">   11418 </span><span class="lineCov">       3983 :                          ASSERT_not_null(memberFunctionRefExp);</span></a>
<a name="11419"><span class="lineNum">   11419 </span>            : </a>
<a name="11420"><span class="lineNum">   11420 </span><span class="lineCov">       3983 :                          setNameQualification(memberFunctionRefExp,memberFunctionDeclaration,amountOfNameQualificationRequired);</span></a>
<a name="11421"><span class="lineNum">   11421 </span>            :                        }</a>
<a name="11422"><span class="lineNum">   11422 </span>            :                       else</a>
<a name="11423"><span class="lineNum">   11423 </span>            :                        {</a>
<a name="11424"><span class="lineNum">   11424 </span>            : #if DEBUG_MEMBER_FUNCTION_REF || 0</a>
<a name="11425"><span class="lineNum">   11425 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;case of SgMemberFunctionRefExp: currentStatement == NULL (could be a function call hidden in a decltype()) \n&quot;);</a>
<a name="11426"><span class="lineNum">   11426 </span>            : #endif</a>
<a name="11427"><span class="lineNum">   11427 </span>            :                        }</a>
<a name="11428"><span class="lineNum">   11428 </span>            : #endif</a>
<a name="11429"><span class="lineNum">   11429 </span>            : </a>
<a name="11430"><span class="lineNum">   11430 </span>            : #if 0</a>
<a name="11431"><span class="lineNum">   11431 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="11432"><span class="lineNum">   11432 </span>            :                          ROSE_ABORT();</a>
<a name="11433"><span class="lineNum">   11433 </span>            : #endif</a>
<a name="11434"><span class="lineNum">   11434 </span>            :                        }</a>
<a name="11435"><span class="lineNum">   11435 </span>            : #if 0</a>
<a name="11436"><span class="lineNum">   11436 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="11437"><span class="lineNum">   11437 </span>            :                     ROSE_ABORT();</a>
<a name="11438"><span class="lineNum">   11438 </span>            : #endif</a>
<a name="11439"><span class="lineNum">   11439 </span>            :                   }</a>
<a name="11440"><span class="lineNum">   11440 </span>            :                  else</a>
<a name="11441"><span class="lineNum">   11441 </span>            :                   {</a>
<a name="11442"><span class="lineNum">   11442 </span><span class="lineCov">       5161 :                     ROSE_ASSERT (isMemberFunctionMemberReference == false);</span></a>
<a name="11443"><span class="lineNum">   11443 </span>            :                     if (isAddressTaken == true)</a>
<a name="11444"><span class="lineNum">   11444 </span>            :                        {</a>
<a name="11445"><span class="lineNum">   11445 </span>            :                        }</a>
<a name="11446"><span class="lineNum">   11446 </span>            :                       else</a>
<a name="11447"><span class="lineNum">   11447 </span>            :                        {</a>
<a name="11448"><span class="lineNum">   11448 </span><span class="lineCov">       5161 :                          ROSE_ASSERT(isAddressTaken == false);</span></a>
<a name="11449"><span class="lineNum">   11449 </span>            :                        }</a>
<a name="11450"><span class="lineNum">   11450 </span>            : </a>
<a name="11451"><span class="lineNum">   11451 </span>            : #if 0</a>
<a name="11452"><span class="lineNum">   11452 </span>            :                  // DQ (6/1/2019): When the function called is from a base class and conflicts with a member function</a>
<a name="11453"><span class="lineNum">   11453 </span>            :                  // in the derived class then we need additional name qualification.</a>
<a name="11454"><span class="lineNum">   11454 </span>            : </a>
<a name="11455"><span class="lineNum">   11455 </span>            : #if DEBUG_MEMBER_FUNCTION_REF</a>
<a name="11456"><span class="lineNum">   11456 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot; (isMemberFunctionMemberReference == true &amp;&amp; isAddressTaken == false) == true \n&quot;);</a>
<a name="11457"><span class="lineNum">   11457 </span>            : #endif</a>
<a name="11458"><span class="lineNum">   11458 </span>            :                  // ROSE_ASSERT (isMemberFunctionMemberReference == true &amp;&amp; isAddressTaken == false);</a>
<a name="11459"><span class="lineNum">   11459 </span>            : </a>
<a name="11460"><span class="lineNum">   11460 </span>            :                     SgStatement* currentStatement = TransformationSupport::getStatement(memberFunctionRefExp);</a>
<a name="11461"><span class="lineNum">   11461 </span>            :                  // ASSERT_not_null(currentStatement);</a>
<a name="11462"><span class="lineNum">   11462 </span>            :                     if (currentStatement != NULL)</a>
<a name="11463"><span class="lineNum">   11463 </span>            :                        {</a>
<a name="11464"><span class="lineNum">   11464 </span>            :                          SgScopeStatement* currentScope = currentStatement-&gt;get_scope();</a>
<a name="11465"><span class="lineNum">   11465 </span>            :                          ASSERT_not_null(currentScope);</a>
<a name="11466"><span class="lineNum">   11466 </span>            : </a>
<a name="11467"><span class="lineNum">   11467 </span>            :                          ASSERT_not_null(memberFunctionDeclaration);</a>
<a name="11468"><span class="lineNum">   11468 </span>            : </a>
<a name="11469"><span class="lineNum">   11469 </span>            :                          int amountOfNameQualificationRequired = nameQualificationDepth(memberFunctionDeclaration,currentScope,currentStatement);</a>
<a name="11470"><span class="lineNum">   11470 </span>            : </a>
<a name="11471"><span class="lineNum">   11471 </span>            : #if DEBUG_MEMBER_FUNCTION_REF</a>
<a name="11472"><span class="lineNum">   11472 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;***** case of SgMemberFunctionRefExp: DONE: Calling nameQualificationDepth() ***** \n&quot;);</a>
<a name="11473"><span class="lineNum">   11473 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;SgMemberFunctionCallExp's member function name: amountOfNameQualificationRequired = %d \n&quot;,amountOfNameQualificationRequired);</a>
<a name="11474"><span class="lineNum">   11474 </span>            : #endif</a>
<a name="11475"><span class="lineNum">   11475 </span>            :                          ASSERT_not_null(memberFunctionRefExp);</a>
<a name="11476"><span class="lineNum">   11476 </span>            : </a>
<a name="11477"><span class="lineNum">   11477 </span>            :                          setNameQualification(memberFunctionRefExp,memberFunctionDeclaration,amountOfNameQualificationRequired);</a>
<a name="11478"><span class="lineNum">   11478 </span>            :                        }</a>
<a name="11479"><span class="lineNum">   11479 </span>            :                       else</a>
<a name="11480"><span class="lineNum">   11480 </span>            :                        {</a>
<a name="11481"><span class="lineNum">   11481 </span>            : #if DEBUG_MEMBER_FUNCTION_REF || 0</a>
<a name="11482"><span class="lineNum">   11482 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;case of SgMemberFunctionRefExp: currentStatement == NULL (could be a function call hidden in a decltype()) \n&quot;);</a>
<a name="11483"><span class="lineNum">   11483 </span>            : #endif</a>
<a name="11484"><span class="lineNum">   11484 </span>            :                        }</a>
<a name="11485"><span class="lineNum">   11485 </span>            : #endif</a>
<a name="11486"><span class="lineNum">   11486 </span>            : </a>
<a name="11487"><span class="lineNum">   11487 </span>            :                   }</a>
<a name="11488"><span class="lineNum">   11488 </span>            :              }</a>
<a name="11489"><span class="lineNum">   11489 </span>            : </a>
<a name="11490"><span class="lineNum">   11490 </span>            : #if 0</a>
<a name="11491"><span class="lineNum">   11491 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="11492"><span class="lineNum">   11492 </span>            :           ROSE_ABORT();</a>
<a name="11493"><span class="lineNum">   11493 </span>            : #endif</a>
<a name="11494"><span class="lineNum">   11494 </span>            : </a>
<a name="11495"><span class="lineNum">   11495 </span>            : #if DEBUG_MEMBER_FUNCTION_REF</a>
<a name="11496"><span class="lineNum">   11496 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Case of SgMemberFunctionRefExp: memberFunctionDeclaration = %p \n&quot;,memberFunctionDeclaration);</a>
<a name="11497"><span class="lineNum">   11497 </span>            : #endif</a>
<a name="11498"><span class="lineNum">   11498 </span>            : </a>
<a name="11499"><span class="lineNum">   11499 </span><span class="lineCov">       5161 :           if (memberFunctionDeclaration != NULL)</span></a>
<a name="11500"><span class="lineNum">   11500 </span>            :              {</a>
<a name="11501"><span class="lineNum">   11501 </span>            :             // DQ (2/17/2019): Adding support for pointers to member functions.</a>
<a name="11502"><span class="lineNum">   11502 </span>            :             // if (isMemberFunctionMemberReference == false)</a>
<a name="11503"><span class="lineNum">   11503 </span><span class="lineCov">       5161 :                if (isMemberFunctionMemberReference == false || isAddressTaken == true)</span></a>
<a name="11504"><span class="lineNum">   11504 </span>            :                   {</a>
<a name="11505"><span class="lineNum">   11505 </span>            : </a>
<a name="11506"><span class="lineNum">   11506 </span>            :                  // DQ (2/23/2019): Except that this code works in all cases that I can see at the moment, I think that the</a>
<a name="11507"><span class="lineNum">   11507 </span>            :                  // current scope should be taken from the type of the pointer being dereferenced instead of from the location</a>
<a name="11508"><span class="lineNum">   11508 </span>            :                  // of the statement containing the memberFunctionRefExp.  But I can't build a counter example that fails.</a>
<a name="11509"><span class="lineNum">   11509 </span>            : </a>
<a name="11510"><span class="lineNum">   11510 </span><span class="lineCov">       1042 :                     SgStatement* currentStatement = TransformationSupport::getStatement(memberFunctionRefExp);</span></a>
<a name="11511"><span class="lineNum">   11511 </span>            : </a>
<a name="11512"><span class="lineNum">   11512 </span>            : #if DEBUG_MEMBER_FUNCTION_REF</a>
<a name="11513"><span class="lineNum">   11513 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Compute the currentStatement: currentStatement = %p \n&quot;,currentStatement);</a>
<a name="11514"><span class="lineNum">   11514 </span>            : #endif</a>
<a name="11515"><span class="lineNum">   11515 </span><span class="lineCov">       1042 :                     if (currentStatement == NULL)</span></a>
<a name="11516"><span class="lineNum">   11516 </span>            :                        {</a>
<a name="11517"><span class="lineNum">   11517 </span>            :                       // DQ (8/19/2014): Because we know where this can happen we don't need to always output debugging info.</a>
<a name="11518"><span class="lineNum">   11518 </span>            :                       // A better test might be to find the type that embeds the expression and make sure it is a SgArrayType.</a>
<a name="11519"><span class="lineNum">   11519 </span>            :                       // DQ (7/11/2014): test2014_83.C demonstrates how this can happen because the SgMemberFunctionRefExp</a>
<a name="11520"><span class="lineNum">   11520 </span>            :                       // appears in an index expression of an array type in a variable declaration.</a>
<a name="11521"><span class="lineNum">   11521 </span><span class="lineNoCov">          0 :                          SgType* associatedType = TransformationSupport::getAssociatedType(memberFunctionRefExp);</span></a>
<a name="11522"><span class="lineNum">   11522 </span><span class="lineNoCov">          0 :                          if (associatedType != NULL)</span></a>
<a name="11523"><span class="lineNum">   11523 </span>            :                             {</a>
<a name="11524"><span class="lineNum">   11524 </span><span class="lineNoCov">          0 :                               SgArrayType* arrayType = isSgArrayType(associatedType);</span></a>
<a name="11525"><span class="lineNum">   11525 </span>            :                               if (arrayType == NULL)</a>
<a name="11526"><span class="lineNum">   11526 </span>            :                                  {</a>
<a name="11527"><span class="lineNum">   11527 </span>            : #if DEBUG_MEMBER_FUNCTION_REF</a>
<a name="11528"><span class="lineNum">   11528 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;Warning: Location of where we can NOT associate the expression to a SgArrayType \n&quot;);</a>
<a name="11529"><span class="lineNum">   11529 </span>            :                                    memberFunctionRefExp-&gt;get_file_info()     -&gt;display(&quot;Error: currentStatement == NULL: memberFunctionRefExp: debug&quot;);</a>
<a name="11530"><span class="lineNum">   11530 </span>            :                                    memberFunctionDeclaration-&gt;get_file_info()-&gt;display(&quot;Error: currentStatement == NULL: memberFunctionDeclaration: debug&quot;);</a>
<a name="11531"><span class="lineNum">   11531 </span>            : #endif</a>
<a name="11532"><span class="lineNum">   11532 </span>            :                                  }</a>
<a name="11533"><span class="lineNum">   11533 </span>            :                                 else</a>
<a name="11534"><span class="lineNum">   11534 </span>            :                                  {</a>
<a name="11535"><span class="lineNum">   11535 </span>            : #if DEBUG_MEMBER_FUNCTION_REF</a>
<a name="11536"><span class="lineNum">   11536 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;Note: Location of where we CAN associate the expression to a statement: confirmed unassociated expression is buried in a type: associatedType = %p = %s \n&quot;,associatedType,associatedType-&gt;class_name().c_str());</a>
<a name="11537"><span class="lineNum">   11537 </span>            : #endif</a>
<a name="11538"><span class="lineNum">   11538 </span>            :                                  }</a>
<a name="11539"><span class="lineNum">   11539 </span>            :                             }</a>
<a name="11540"><span class="lineNum">   11540 </span>            :                            else</a>
<a name="11541"><span class="lineNum">   11541 </span>            :                             {</a>
<a name="11542"><span class="lineNum">   11542 </span><span class="lineNoCov">          0 :                               mfprintf(mlog [ WARN ] ) (&quot;Error: Location of where we can NOT associate the expression to a statement \n&quot;);</span></a>
<a name="11543"><span class="lineNum">   11543 </span><span class="lineNoCov">          0 :                               memberFunctionRefExp-&gt;get_file_info()     -&gt;display(&quot;Error: currentStatement == NULL: memberFunctionRefExp: debug&quot;);</span></a>
<a name="11544"><span class="lineNum">   11544 </span><span class="lineNoCov">          0 :                               memberFunctionDeclaration-&gt;get_file_info()-&gt;display(&quot;Error: currentStatement == NULL: memberFunctionDeclaration: debug&quot;);</span></a>
<a name="11545"><span class="lineNum">   11545 </span>            :                             }</a>
<a name="11546"><span class="lineNum">   11546 </span>            : </a>
<a name="11547"><span class="lineNum">   11547 </span>            :                       // DQ (7/11/2014): Added support for when this is a nested call and the scope where the call is made from is essential.</a>
<a name="11548"><span class="lineNum">   11548 </span><span class="lineNoCov">          0 :                          if (explictlySpecifiedCurrentScope != NULL)</span></a>
<a name="11549"><span class="lineNum">   11549 </span>            :                             {</a>
<a name="11550"><span class="lineNum">   11550 </span>            : #if DEBUG_MEMBER_FUNCTION_REF</a>
<a name="11551"><span class="lineNum">   11551 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;explictlySpecifiedCurrentScope = %p = %s \n&quot;,explictlySpecifiedCurrentScope,explictlySpecifiedCurrentScope-&gt;class_name().c_str());</a>
<a name="11552"><span class="lineNum">   11552 </span>            : #endif</a>
<a name="11553"><span class="lineNum">   11553 </span>            : </a>
<a name="11554"><span class="lineNum">   11554 </span>            :                            // DQ (4/19/2019): Now that we (optionally) also pass in the explictlySpecifiedCurrentStatement, we might want to use it directly.</a>
<a name="11555"><span class="lineNum">   11555 </span>            : #if 0</a>
<a name="11556"><span class="lineNum">   11556 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;case of SgMemberFunctionRefExp: Using explictlySpecifiedCurrentScope for the value of currentStatement: need to check this! \n&quot;);</a>
<a name="11557"><span class="lineNum">   11557 </span>            : #endif</a>
<a name="11558"><span class="lineNum">   11558 </span>            :                               currentStatement = explictlySpecifiedCurrentScope;</a>
<a name="11559"><span class="lineNum">   11559 </span>            :                             }</a>
<a name="11560"><span class="lineNum">   11560 </span>            :                            else</a>
<a name="11561"><span class="lineNum">   11561 </span>            :                             {</a>
<a name="11562"><span class="lineNum">   11562 </span><span class="lineNoCov">          0 :                               mfprintf(mlog [ WARN ] ) (&quot;Error: explictlySpecifiedCurrentScope == NULL \n&quot;);</span></a>
<a name="11563"><span class="lineNum">   11563 </span>            : </a>
<a name="11564"><span class="lineNum">   11564 </span><span class="lineNoCov">          0 :                               mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</span></a>
<a name="11565"><span class="lineNum">   11565 </span><span class="lineNoCov">          0 :                               ROSE_ABORT();</span></a>
<a name="11566"><span class="lineNum">   11566 </span>            :                             }</a>
<a name="11567"><span class="lineNum">   11567 </span>            :                        }</a>
<a name="11568"><span class="lineNum">   11568 </span><span class="lineCov">       1042 :                     ASSERT_not_null(currentStatement);</span></a>
<a name="11569"><span class="lineNum">   11569 </span>            : </a>
<a name="11570"><span class="lineNum">   11570 </span>            : #if DEBUG_MEMBER_FUNCTION_REF</a>
<a name="11571"><span class="lineNum">   11571 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;case of SgMemberFunctionRefExp: currentStatement = %p = %s \n&quot;,currentStatement,currentStatement-&gt;class_name().c_str());</a>
<a name="11572"><span class="lineNum">   11572 </span>            : #endif</a>
<a name="11573"><span class="lineNum">   11573 </span><span class="lineCov">       1042 :                     SgScopeStatement* currentScope = currentStatement-&gt;get_scope();</span></a>
<a name="11574"><span class="lineNum">   11574 </span><span class="lineCov">       1042 :                     ASSERT_not_null(currentScope);</span></a>
<a name="11575"><span class="lineNum">   11575 </span>            : </a>
<a name="11576"><span class="lineNum">   11576 </span>            : #if DEBUG_MEMBER_FUNCTION_REF</a>
<a name="11577"><span class="lineNum">   11577 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;case of SgMemberFunctionRefExp: currentScope = %p = %s \n&quot;,currentScope,currentScope-&gt;class_name().c_str());</a>
<a name="11578"><span class="lineNum">   11578 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;***** case of SgMemberFunctionRefExp: Calling nameQualificationDepth() ***** \n&quot;);</a>
<a name="11579"><span class="lineNum">   11579 </span>            : #endif</a>
<a name="11580"><span class="lineNum">   11580 </span><span class="lineCov">       1042 :                     int amountOfNameQualificationRequired = nameQualificationDepth(memberFunctionDeclaration,currentScope,currentStatement);</span></a>
<a name="11581"><span class="lineNum">   11581 </span>            : </a>
<a name="11582"><span class="lineNum">   11582 </span>            : #if DEBUG_MEMBER_FUNCTION_REF</a>
<a name="11583"><span class="lineNum">   11583 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;***** case of SgMemberFunctionRefExp: DONE: Calling nameQualificationDepth() ***** \n&quot;);</a>
<a name="11584"><span class="lineNum">   11584 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;SgMemberFunctionCallExp's member function name: amountOfNameQualificationRequired = %d \n&quot;,amountOfNameQualificationRequired);</a>
<a name="11585"><span class="lineNum">   11585 </span>            : #endif</a>
<a name="11586"><span class="lineNum">   11586 </span>            :                  // DQ (2/7/2019): Add an extra level of name qualification if this is pointer-to-member type induced.</a>
<a name="11587"><span class="lineNum">   11587 </span><span class="lineCov">       1042 :                     if (nameQualificationInducedFromPointerMemberType == true)</span></a>
<a name="11588"><span class="lineNum">   11588 </span>            :                        {</a>
<a name="11589"><span class="lineNum">   11589 </span>            :                       // DQ (2/8/2019): Only add name qualification if not present (else we can get over qualification</a>
<a name="11590"><span class="lineNum">   11590 </span>            :                       // that can show up as pointer names in the name qualification, see Cxx11_tests/test2019_86.C).</a>
<a name="11591"><span class="lineNum">   11591 </span><span class="lineNoCov">          0 :                          if (amountOfNameQualificationRequired == 0)</span></a>
<a name="11592"><span class="lineNum">   11592 </span>            :                             {</a>
<a name="11593"><span class="lineNum">   11593 </span><span class="lineNoCov">          0 :                               amountOfNameQualificationRequired++;</span></a>
<a name="11594"><span class="lineNum">   11594 </span>            :                             }</a>
<a name="11595"><span class="lineNum">   11595 </span>            : #if DEBUG_MEMBER_FUNCTION_REF</a>
<a name="11596"><span class="lineNum">   11596 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;Found case of name qualification required because the variable is associated with SgPointerMemberType: amountOfNameQualificationRequired = %d \n&quot;,amountOfNameQualificationRequired);</a>
<a name="11597"><span class="lineNum">   11597 </span>            : #endif</a>
<a name="11598"><span class="lineNum">   11598 </span>            : #if 0</a>
<a name="11599"><span class="lineNum">   11599 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="11600"><span class="lineNum">   11600 </span>            :                          ROSE_ABORT();</a>
<a name="11601"><span class="lineNum">   11601 </span>            : #endif</a>
<a name="11602"><span class="lineNum">   11602 </span>            :                        }</a>
<a name="11603"><span class="lineNum">   11603 </span>            : </a>
<a name="11604"><span class="lineNum">   11604 </span><span class="lineCov">       1042 :                     setNameQualification(memberFunctionRefExp,memberFunctionDeclaration,amountOfNameQualificationRequired);</span></a>
<a name="11605"><span class="lineNum">   11605 </span>            :                  // DQ (2/17/2019): Case of xxx !(isDataMemberReference == true &amp;&amp; isAddressTaken == true)</a>
<a name="11606"><span class="lineNum">   11606 </span>            :                   }</a>
<a name="11607"><span class="lineNum">   11607 </span>            :                  else</a>
<a name="11608"><span class="lineNum">   11608 </span>            :                   {</a>
<a name="11609"><span class="lineNum">   11609 </span>            : #if 0</a>
<a name="11610"><span class="lineNum">   11610 </span>            :                  // DQ (6/1/2019): When the function called is from a base class and conflicts with a member function</a>
<a name="11611"><span class="lineNum">   11611 </span>            :                  // in the derived class then we need additional name qualification.</a>
<a name="11612"><span class="lineNum">   11612 </span>            : </a>
<a name="11613"><span class="lineNum">   11613 </span>            : #if DEBUG_MEMBER_FUNCTION_REF</a>
<a name="11614"><span class="lineNum">   11614 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot; (isMemberFunctionMemberReference == true &amp;&amp; isAddressTaken == false) == true \n&quot;);</a>
<a name="11615"><span class="lineNum">   11615 </span>            : #endif</a>
<a name="11616"><span class="lineNum">   11616 </span>            :                     ROSE_ASSERT (isMemberFunctionMemberReference == true &amp;&amp; isAddressTaken == false);</a>
<a name="11617"><span class="lineNum">   11617 </span>            : </a>
<a name="11618"><span class="lineNum">   11618 </span>            :                     SgStatement* currentStatement = TransformationSupport::getStatement(memberFunctionRefExp);</a>
<a name="11619"><span class="lineNum">   11619 </span>            :                  // ASSERT_not_null(currentStatement);</a>
<a name="11620"><span class="lineNum">   11620 </span>            :                     if (currentStatement != NULL)</a>
<a name="11621"><span class="lineNum">   11621 </span>            :                        {</a>
<a name="11622"><span class="lineNum">   11622 </span>            :                          SgScopeStatement* currentScope = currentStatement-&gt;get_scope();</a>
<a name="11623"><span class="lineNum">   11623 </span>            :                          ASSERT_not_null(currentScope);</a>
<a name="11624"><span class="lineNum">   11624 </span>            : </a>
<a name="11625"><span class="lineNum">   11625 </span>            :                          ASSERT_not_null(memberFunctionDeclaration);</a>
<a name="11626"><span class="lineNum">   11626 </span>            : </a>
<a name="11627"><span class="lineNum">   11627 </span>            :                          int amountOfNameQualificationRequired = nameQualificationDepth(memberFunctionDeclaration,currentScope,currentStatement);</a>
<a name="11628"><span class="lineNum">   11628 </span>            : </a>
<a name="11629"><span class="lineNum">   11629 </span>            : #if DEBUG_MEMBER_FUNCTION_REF</a>
<a name="11630"><span class="lineNum">   11630 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;***** case of SgMemberFunctionRefExp: DONE: Calling nameQualificationDepth() ***** \n&quot;);</a>
<a name="11631"><span class="lineNum">   11631 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;SgMemberFunctionCallExp's member function name: amountOfNameQualificationRequired = %d \n&quot;,amountOfNameQualificationRequired);</a>
<a name="11632"><span class="lineNum">   11632 </span>            : #endif</a>
<a name="11633"><span class="lineNum">   11633 </span>            :                          ASSERT_not_null(memberFunctionRefExp);</a>
<a name="11634"><span class="lineNum">   11634 </span>            : </a>
<a name="11635"><span class="lineNum">   11635 </span>            :                          setNameQualification(memberFunctionRefExp,memberFunctionDeclaration,amountOfNameQualificationRequired);</a>
<a name="11636"><span class="lineNum">   11636 </span>            :                        }</a>
<a name="11637"><span class="lineNum">   11637 </span>            :                       else</a>
<a name="11638"><span class="lineNum">   11638 </span>            :                        {</a>
<a name="11639"><span class="lineNum">   11639 </span>            : #if DEBUG_MEMBER_FUNCTION_REF || 1</a>
<a name="11640"><span class="lineNum">   11640 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;case of SgMemberFunctionRefExp: currentStatement == NULL (could be a function call hidden in a decltype()) \n&quot;);</a>
<a name="11641"><span class="lineNum">   11641 </span>            : #endif</a>
<a name="11642"><span class="lineNum">   11642 </span>            :                        }</a>
<a name="11643"><span class="lineNum">   11643 </span>            : #endif</a>
<a name="11644"><span class="lineNum">   11644 </span>            :                   }</a>
<a name="11645"><span class="lineNum">   11645 </span>            :              }</a>
<a name="11646"><span class="lineNum">   11646 </span>            :             else</a>
<a name="11647"><span class="lineNum">   11647 </span>            :              {</a>
<a name="11648"><span class="lineNum">   11648 </span>            : #if DEBUG_MEMBER_FUNCTION_REF || 0</a>
<a name="11649"><span class="lineNum">   11649 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;WARNING: memberFunctionDeclaration == NULL in SgMemberFunctionCallExp for name qualification support! \n&quot;);</a>
<a name="11650"><span class="lineNum">   11650 </span>            : #endif</a>
<a name="11651"><span class="lineNum">   11651 </span>            :              }</a>
<a name="11652"><span class="lineNum">   11652 </span>            : </a>
<a name="11653"><span class="lineNum">   11653 </span>            :        // If this is a templated function then we have to save the name because its templated name might have template arguments that require name qualification.</a>
<a name="11654"><span class="lineNum">   11654 </span><span class="lineCov">       5161 :           SgTemplateInstantiationMemberFunctionDecl* templateInstantiationMemberFunctionDeclaration = isSgTemplateInstantiationMemberFunctionDecl(memberFunctionRefExp-&gt;getAssociatedMemberFunctionDeclaration());</span></a>
<a name="11655"><span class="lineNum">   11655 </span><span class="lineCov">       5161 :           if (templateInstantiationMemberFunctionDeclaration != NULL)</span></a>
<a name="11656"><span class="lineNum">   11656 </span>            :              {</a>
<a name="11657"><span class="lineNum">   11657 </span>            : #if DEBUG_MEMBER_FUNCTION_REF</a>
<a name="11658"><span class="lineNum">   11658 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Found a SgTemplateInstantiationMemberFunctionDecl that will have template arguments that might require qualification. name = %s \n&quot;,templateInstantiationMemberFunctionDeclaration-&gt;get_name().str());</a>
<a name="11659"><span class="lineNum">   11659 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Must handle templated SgMemberFunctionRefExp! \n&quot;);</a>
<a name="11660"><span class="lineNum">   11660 </span>            : #endif</a>
<a name="11661"><span class="lineNum">   11661 </span>            : </a>
<a name="11662"><span class="lineNum">   11662 </span>            :             // DQ (5/24/2013): Added support for member function template argument lists to have similar handling, such as to</a>
<a name="11663"><span class="lineNum">   11663 </span>            :             // SgTemplateInstantiationFunctionDecl IR nodes.  This is required to support test codes such as test2013_188.C.</a>
<a name="11664"><span class="lineNum">   11664 </span><span class="lineCov">       2803 :                SgStatement* currentStatement = TransformationSupport::getStatement(memberFunctionRefExp);</span></a>
<a name="11665"><span class="lineNum">   11665 </span>            : </a>
<a name="11666"><span class="lineNum">   11666 </span>            :             // DQ (4/15/2019): This fails for EDG 5.0 only, on Cxx_tests/test2004_149.C (as a result of recent work Sunday afternoon).</a>
<a name="11667"><span class="lineNum">   11667 </span>            :             // ASSERT_not_null(currentStatement);</a>
<a name="11668"><span class="lineNum">   11668 </span><span class="lineCov">       2803 :                if (currentStatement != NULL)</span></a>
<a name="11669"><span class="lineNum">   11669 </span>            :                   {</a>
<a name="11670"><span class="lineNum">   11670 </span><span class="lineCov">       2803 :                SgScopeStatement* currentScope = currentStatement-&gt;get_scope();</span></a>
<a name="11671"><span class="lineNum">   11671 </span><span class="lineCov">       2803 :                ASSERT_not_null(currentScope);</span></a>
<a name="11672"><span class="lineNum">   11672 </span>            : </a>
<a name="11673"><span class="lineNum">   11673 </span>            : #if DEBUG_MEMBER_FUNCTION_REF</a>
<a name="11674"><span class="lineNum">   11674 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;case of SgMemberFunctionRefExp: currentStatement = %p = %s \n&quot;,currentStatement,currentStatement-&gt;class_name().c_str());</a>
<a name="11675"><span class="lineNum">   11675 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;case of SgMemberFunctionRefExp: currentScope = %p = %s \n&quot;,currentScope,currentScope-&gt;class_name().c_str());</a>
<a name="11676"><span class="lineNum">   11676 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;***** calling traverseTemplatedMemberFunction() \n&quot;);</a>
<a name="11677"><span class="lineNum">   11677 </span>            : #endif</a>
<a name="11678"><span class="lineNum">   11678 </span>            : </a>
<a name="11679"><span class="lineNum">   11679 </span>            :             // traverseTemplatedFunction(functionRefExp,templateInstantiationFunctionDeclaration,currentScope,currentStatement);</a>
<a name="11680"><span class="lineNum">   11680 </span>            :             // traverseTemplatedFunction(functionRefExp,functionRefExp,currentScope,currentStatement);</a>
<a name="11681"><span class="lineNum">   11681 </span><span class="lineCov">       2803 :                traverseTemplatedMemberFunction(memberFunctionRefExp,memberFunctionRefExp,currentScope,currentStatement);</span></a>
<a name="11682"><span class="lineNum">   11682 </span>            : </a>
<a name="11683"><span class="lineNum">   11683 </span>            : #if DEBUG_MEMBER_FUNCTION_REF</a>
<a name="11684"><span class="lineNum">   11684 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;***** DONE: calling traverseTemplatedMemberFunction() \n&quot;);</a>
<a name="11685"><span class="lineNum">   11685 </span>            : #endif</a>
<a name="11686"><span class="lineNum">   11686 </span>            :                   }</a>
<a name="11687"><span class="lineNum">   11687 </span>            : #if 0</a>
<a name="11688"><span class="lineNum">   11688 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="11689"><span class="lineNum">   11689 </span>            :                ROSE_ABORT();</a>
<a name="11690"><span class="lineNum">   11690 </span>            : #endif</a>
<a name="11691"><span class="lineNum">   11691 </span>            :              }</a>
<a name="11692"><span class="lineNum">   11692 </span>            :         }</a>
<a name="11693"><span class="lineNum">   11693 </span>            : </a>
<a name="11694"><span class="lineNum">   11694 </span>            : </a>
<a name="11695"><span class="lineNum">   11695 </span>            :   // DQ (5/31/2011): This is a derived class from SgExpression and SgInitializer...</a>
<a name="11696"><span class="lineNum">   11696 </span><span class="lineCov">    2810440 :      SgConstructorInitializer* constructorInitializer = isSgConstructorInitializer(n);</span></a>
<a name="11697"><span class="lineNum">   11697 </span><span class="lineCov">    2810440 :      if (constructorInitializer != NULL)</span></a>
<a name="11698"><span class="lineNum">   11698 </span>            :         {</a>
<a name="11699"><span class="lineNum">   11699 </span><span class="lineCov">       4729 :           SgMemberFunctionDeclaration* memberFunctionDeclaration = constructorInitializer-&gt;get_declaration();</span></a>
<a name="11700"><span class="lineNum">   11700 </span>            : </a>
<a name="11701"><span class="lineNum">   11701 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || 0</a>
<a name="11702"><span class="lineNum">   11702 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Case of SgConstructorInitializer: memberFunctionDeclaration = %p \n&quot;,memberFunctionDeclaration);</a>
<a name="11703"><span class="lineNum">   11703 </span>            : #endif</a>
<a name="11704"><span class="lineNum">   11704 </span>            : </a>
<a name="11705"><span class="lineNum">   11705 </span>            : #if 0</a>
<a name="11706"><span class="lineNum">   11706 </span>            :        // DQ (4/27/2019): Debugging test2019_102.C.</a>
<a name="11707"><span class="lineNum">   11707 </span>            :           SgNode* constructorInitializerParent = constructorInitializer-&gt;get_parent();</a>
<a name="11708"><span class="lineNum">   11708 </span>            :           SgInitializedName* initializedName = isSgInitializedName(constructorInitializerParent);</a>
<a name="11709"><span class="lineNum">   11709 </span>            :           if (initializedName != NULL)</a>
<a name="11710"><span class="lineNum">   11710 </span>            :              {</a>
<a name="11711"><span class="lineNum">   11711 </span>            : #if 1</a>
<a name="11712"><span class="lineNum">   11712 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="11713"><span class="lineNum">   11713 </span>            :                ROSE_ABORT();</a>
<a name="11714"><span class="lineNum">   11714 </span>            : #endif</a>
<a name="11715"><span class="lineNum">   11715 </span>            :              }</a>
<a name="11716"><span class="lineNum">   11716 </span>            : #endif</a>
<a name="11717"><span class="lineNum">   11717 </span>            : </a>
<a name="11718"><span class="lineNum">   11718 </span><span class="lineCov">       4729 :           SgStatement* currentStatement = TransformationSupport::getStatement(constructorInitializer);</span></a>
<a name="11719"><span class="lineNum">   11719 </span>            : </a>
<a name="11720"><span class="lineNum">   11720 </span>            : #if 0</a>
<a name="11721"><span class="lineNum">   11721 </span>            :           printf (&quot;Case of SgConstructorInitializer: before if(currentStatement == NULL): currentStatement = %p = %s name = %s \n&quot;,currentStatement,</a>
<a name="11722"><span class="lineNum">   11722 </span>            :                currentStatement-&gt;class_name().c_str(),SageInterface::get_name(currentStatement).c_str());</a>
<a name="11723"><span class="lineNum">   11723 </span>            : #endif</a>
<a name="11724"><span class="lineNum">   11724 </span>            : </a>
<a name="11725"><span class="lineNum">   11725 </span><span class="lineCov">       4729 :           if (currentStatement == NULL)</span></a>
<a name="11726"><span class="lineNum">   11726 </span>            :              {</a>
<a name="11727"><span class="lineNum">   11727 </span>            :             // DQ (1/28/2019): This can happen when the expression is used in an array type declaration (e.g. within a variable declaration for an array).</a>
<a name="11728"><span class="lineNum">   11728 </span>            :             // NOTE: this will be possibly incorrect if there is a using declaration in the scope that would be important to the name qualification.</a>
<a name="11729"><span class="lineNum">   11729 </span>            :             // We would then need to know if the declarration declaring the array type was before or after the using declaration.</a>
<a name="11730"><span class="lineNum">   11730 </span>            :             // Not clear what would be the best way to solve that problem (though it would not be in the set of directived already processed, so it might be fine).</a>
<a name="11731"><span class="lineNum">   11731 </span>            : #if 0</a>
<a name="11732"><span class="lineNum">   11732 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;In name qualification: not possible to locate statement containing constructorInitializer = %p (using first statement from current scope) \n&quot;,constructorInitializer);</a>
<a name="11733"><span class="lineNum">   11733 </span>            : #endif</a>
<a name="11734"><span class="lineNum">   11734 </span><span class="lineNoCov">          0 :                ASSERT_not_null(constructorInitializer-&gt;get_parent());</span></a>
<a name="11735"><span class="lineNum">   11735 </span>            : </a>
<a name="11736"><span class="lineNum">   11736 </span><span class="lineNoCov">          0 :                SgScopeStatement* tmp_currentScope = inheritedAttribute.get_currentScope();</span></a>
<a name="11737"><span class="lineNum">   11737 </span><span class="lineNoCov">          0 :                ASSERT_not_null(tmp_currentScope);</span></a>
<a name="11738"><span class="lineNum">   11738 </span>            : #if 0</a>
<a name="11739"><span class="lineNum">   11739 </span>            :                constructorInitializer-&gt;get_file_info()-&gt;display(&quot;Error in constructorInitializer&quot;);</a>
<a name="11740"><span class="lineNum">   11740 </span>            :                constructorInitializer-&gt;get_parent()-&gt;get_file_info()-&gt;display(&quot;Error in constructorInitializer-&gt;get_parent()&quot;);</a>
<a name="11741"><span class="lineNum">   11741 </span>            : </a>
<a name="11742"><span class="lineNum">   11742 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;inheritedAttribute.get_currentScope() = %p = %s \n&quot;,tmp_currentScope,tmp_currentScope-&gt;class_name().c_str());</a>
<a name="11743"><span class="lineNum">   11743 </span>            : </a>
<a name="11744"><span class="lineNum">   11744 </span>            :                tmp_currentScope-&gt;get_file_info()-&gt;display(&quot;Error in constructorInitializer: currentScope&quot;);</a>
<a name="11745"><span class="lineNum">   11745 </span>            : #endif</a>
<a name="11746"><span class="lineNum">   11746 </span>            :             // If we don't have a statement derived from the expression to reference, then use the first statement in the current scope.</a>
<a name="11747"><span class="lineNum">   11747 </span><span class="lineNoCov">          0 :                currentStatement = tmp_currentScope-&gt;firstStatement();</span></a>
<a name="11748"><span class="lineNum">   11748 </span><span class="lineNoCov">          0 :                ASSERT_not_null(currentStatement);</span></a>
<a name="11749"><span class="lineNum">   11749 </span>            :              }</a>
<a name="11750"><span class="lineNum">   11750 </span><span class="lineCov">       4729 :           ASSERT_not_null(currentStatement);</span></a>
<a name="11751"><span class="lineNum">   11751 </span>            : </a>
<a name="11752"><span class="lineNum">   11752 </span>            :        // If this could occur in a SgForStatement then this should be fixed up as it is elsewhere...</a>
<a name="11753"><span class="lineNum">   11753 </span><span class="lineCov">       4729 :           SgScopeStatement* currentScope = currentStatement-&gt;get_scope();</span></a>
<a name="11754"><span class="lineNum">   11754 </span><span class="lineCov">       4729 :           ASSERT_not_null(currentScope);</span></a>
<a name="11755"><span class="lineNum">   11755 </span>            : </a>
<a name="11756"><span class="lineNum">   11756 </span>            : #if 0</a>
<a name="11757"><span class="lineNum">   11757 </span>            :        // DQ (9/2/2020): Name qualification for the SgCtorInitializerList should use the scope of the associated class declaration.</a>
<a name="11758"><span class="lineNum">   11758 </span>            :           SgCtorInitializerList* ctorInitializerList = isSgCtorInitializerList(currentStatement);</a>
<a name="11759"><span class="lineNum">   11759 </span>            :           if (ctorInitializerList != NULL)</a>
<a name="11760"><span class="lineNum">   11760 </span>            :              {</a>
<a name="11761"><span class="lineNum">   11761 </span>            :                SgMemberFunctionDeclaration* memberFunctionDeclaration = isSgMemberFunctionDeclaration(ctorInitializerList-&gt;get_parent());</a>
<a name="11762"><span class="lineNum">   11762 </span>            :                ROSE_ASSERT(memberFunctionDeclaration != NULL);</a>
<a name="11763"><span class="lineNum">   11763 </span>            :             // currentStatement = memberFunctionDeclaration-&gt;get_firstNondefiningDeclaration();</a>
<a name="11764"><span class="lineNum">   11764 </span>            :                currentScope = memberFunctionDeclaration-&gt;get_scope();</a>
<a name="11765"><span class="lineNum">   11765 </span>            : #if 0</a>
<a name="11766"><span class="lineNum">   11766 </span>            :                printf (&quot;Case of SgConstructorInitializer: currentScope = %p = %s name = %s \n&quot;,currentScope,</a>
<a name="11767"><span class="lineNum">   11767 </span>            :                     currentScope-&gt;class_name().c_str(),SageInterface::get_name(currentScope).c_str());</a>
<a name="11768"><span class="lineNum">   11768 </span>            : #endif</a>
<a name="11769"><span class="lineNum">   11769 </span>            : #if 0</a>
<a name="11770"><span class="lineNum">   11770 </span>            :                printf (&quot;Case of SgConstructorInitializer: case of SgCtorInitializerList before if(currentStatement == NULL): currentStatement = %p = %s name = %s \n&quot;,currentStatement,</a>
<a name="11771"><span class="lineNum">   11771 </span>            :                     currentStatement-&gt;class_name().c_str(),SageInterface::get_name(currentStatement).c_str());</a>
<a name="11772"><span class="lineNum">   11772 </span>            : #endif</a>
<a name="11773"><span class="lineNum">   11773 </span>            :              }</a>
<a name="11774"><span class="lineNum">   11774 </span>            : #endif</a>
<a name="11775"><span class="lineNum">   11775 </span>            : #if 0</a>
<a name="11776"><span class="lineNum">   11776 </span>            :           printf (&quot;Case of SgConstructorInitializer: memberFunctionDeclaration = %p = %s name = %s \n&quot;,</a>
<a name="11777"><span class="lineNum">   11777 </span>            :                memberFunctionDeclaration,memberFunctionDeclaration-&gt;class_name().c_str(),SageInterface::get_name(memberFunctionDeclaration).c_str());</a>
<a name="11778"><span class="lineNum">   11778 </span>            :           printf (&quot;Case of SgConstructorInitializer: currentScope = %p = %s name = %s \n&quot;,currentScope,</a>
<a name="11779"><span class="lineNum">   11779 </span>            :                currentScope-&gt;class_name().c_str(),SageInterface::get_name(currentScope).c_str());</a>
<a name="11780"><span class="lineNum">   11780 </span>            :           printf (&quot;Case of SgConstructorInitializer: currentStatement = %p = %s name = %s \n&quot;,currentStatement,</a>
<a name="11781"><span class="lineNum">   11781 </span>            :                currentStatement-&gt;class_name().c_str(),SageInterface::get_name(currentStatement).c_str());</a>
<a name="11782"><span class="lineNum">   11782 </span>            : #endif</a>
<a name="11783"><span class="lineNum">   11783 </span>            : #if 0</a>
<a name="11784"><span class="lineNum">   11784 </span>            :           printf (&quot;Case of SgConstructorInitializer: currentScope: symbol_table: \n&quot;);</a>
<a name="11785"><span class="lineNum">   11785 </span>            :           currentScope-&gt;get_symbol_table()-&gt;print(&quot;Case of SgConstructorInitializer: currentScope: symbol_table&quot;);</a>
<a name="11786"><span class="lineNum">   11786 </span>            : #endif</a>
<a name="11787"><span class="lineNum">   11787 </span>            : </a>
<a name="11788"><span class="lineNum">   11788 </span><span class="lineCov">       4729 :           if (memberFunctionDeclaration != NULL)</span></a>
<a name="11789"><span class="lineNum">   11789 </span>            :              {</a>
<a name="11790"><span class="lineNum">   11790 </span>            : #if 0</a>
<a name="11791"><span class="lineNum">   11791 </span>            :                printf (&quot;888888888888888888888888888888888888888888888888888 \n&quot;);</a>
<a name="11792"><span class="lineNum">   11792 </span>            :                printf (&quot;888888888888888888888888888888888888888888888888888 \n&quot;);</a>
<a name="11793"><span class="lineNum">   11793 </span>            :                printf (&quot;888888888888888888888888888888888888888888888888888 \n&quot;);</a>
<a name="11794"><span class="lineNum">   11794 </span>            :                printf (&quot;888888888888888888888888888888888888888888888888888 \n&quot;);</a>
<a name="11795"><span class="lineNum">   11795 </span>            : #endif</a>
<a name="11796"><span class="lineNum">   11796 </span><span class="lineCov">        994 :                int amountOfNameQualificationRequired = nameQualificationDepth(memberFunctionDeclaration,currentScope,currentStatement);</span></a>
<a name="11797"><span class="lineNum">   11797 </span>            : </a>
<a name="11798"><span class="lineNum">   11798 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="11799"><span class="lineNum">   11799 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;SgConstructorInitializer's constructor member function name: amountOfNameQualificationRequired = %d \n&quot;,amountOfNameQualificationRequired);</a>
<a name="11800"><span class="lineNum">   11800 </span>            : #endif</a>
<a name="11801"><span class="lineNum">   11801 </span><span class="lineCov">        994 :                setNameQualification(constructorInitializer,memberFunctionDeclaration,amountOfNameQualificationRequired);</span></a>
<a name="11802"><span class="lineNum">   11802 </span>            : #if 0</a>
<a name="11803"><span class="lineNum">   11803 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;In name qualification: Case of SgConstructorInitializer: memberFunctionDeclaration = %p \n&quot;,memberFunctionDeclaration);</a>
<a name="11804"><span class="lineNum">   11804 </span>            : #endif</a>
<a name="11805"><span class="lineNum">   11805 </span>            : #if 0</a>
<a name="11806"><span class="lineNum">   11806 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;DONE: Calling setNameQualification() on constructorInitializer: Exiting as a test! \n&quot;);</a>
<a name="11807"><span class="lineNum">   11807 </span>            :                ROSE_ABORT();</a>
<a name="11808"><span class="lineNum">   11808 </span>            : #endif</a>
<a name="11809"><span class="lineNum">   11809 </span>            : #if 0</a>
<a name="11810"><span class="lineNum">   11810 </span>            :                printf (&quot;999999999999999999999999999999999999999999999999999 \n&quot;);</a>
<a name="11811"><span class="lineNum">   11811 </span>            :                printf (&quot;999999999999999999999999999999999999999999999999999 \n&quot;);</a>
<a name="11812"><span class="lineNum">   11812 </span>            :                printf (&quot;999999999999999999999999999999999999999999999999999 \n&quot;);</a>
<a name="11813"><span class="lineNum">   11813 </span>            :                printf (&quot;999999999999999999999999999999999999999999999999999 \n&quot;);</a>
<a name="11814"><span class="lineNum">   11814 </span>            : #endif</a>
<a name="11815"><span class="lineNum">   11815 </span>            : #if 0</a>
<a name="11816"><span class="lineNum">   11816 </span>            :                if (amountOfNameQualificationRequired &gt; 0)</a>
<a name="11817"><span class="lineNum">   11817 </span>            :                   {</a>
<a name="11818"><span class="lineNum">   11818 </span>            : #if 0</a>
<a name="11819"><span class="lineNum">   11819 </span>            :                     printf(&quot;DONE: Calling setNameQualification() on constructorInitializer: Exiting as a test! \n&quot;);</a>
<a name="11820"><span class="lineNum">   11820 </span>            :                     ROSE_ABORT();</a>
<a name="11821"><span class="lineNum">   11821 </span>            : #endif</a>
<a name="11822"><span class="lineNum">   11822 </span>            :                   }</a>
<a name="11823"><span class="lineNum">   11823 </span>            : #endif</a>
<a name="11824"><span class="lineNum">   11824 </span>            :              }</a>
<a name="11825"><span class="lineNum">   11825 </span>            :             else</a>
<a name="11826"><span class="lineNum">   11826 </span>            :              {</a>
<a name="11827"><span class="lineNum">   11827 </span>            :             // DQ (6/1/2011): This happens when there is no explicit constructor that can be used to build a class, in this case the class name must be used to define a default constructor.</a>
<a name="11828"><span class="lineNum">   11828 </span>            :             // This is a problem for test2004_130.C (at line 165 col = 14 file = /home/dquinlan/ROSE/ROSE_CompileTree/git-LINUX-64bit-4.2.4-dq-cxx-rc/include-staging/g++_HEADERS/hdrs3/bits/stl_iterator_base_types.h).</a>
<a name="11829"><span class="lineNum">   11829 </span>            :             // Need to investigate this later (it is strange that it is not an issue in test2011_63.C, but it is a struct instead of a class and that might be why).</a>
<a name="11830"><span class="lineNum">   11830 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="11831"><span class="lineNum">   11831 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;WARNING: memberFunctionDeclaration == NULL in SgConstructorInitializer for name qualification support! \n&quot;);</a>
<a name="11832"><span class="lineNum">   11832 </span>            : #endif</a>
<a name="11833"><span class="lineNum">   11833 </span>            :             // ROSE_ASSERT(false);</a>
<a name="11834"><span class="lineNum">   11834 </span>            : </a>
<a name="11835"><span class="lineNum">   11835 </span>            :             // DQ (6/4/2011): Added support for this case.</a>
<a name="11836"><span class="lineNum">   11836 </span><span class="lineCov">       3735 :                SgClassDeclaration* classDeclaration = constructorInitializer-&gt;get_class_decl();</span></a>
<a name="11837"><span class="lineNum">   11837 </span>            :             // ASSERT_not_null(classDeclaration);</a>
<a name="11838"><span class="lineNum">   11838 </span><span class="lineCov">       3735 :                if (classDeclaration != NULL)</span></a>
<a name="11839"><span class="lineNum">   11839 </span>            :                   {</a>
<a name="11840"><span class="lineNum">   11840 </span>            :                  // An example of the problem is test2005_42.C, where the class name is used to generate the constructor initializer name.</a>
<a name="11841"><span class="lineNum">   11841 </span><span class="lineCov">        951 :                     int amountOfNameQualificationRequired = nameQualificationDepth(classDeclaration,currentScope,currentStatement);</span></a>
<a name="11842"><span class="lineNum">   11842 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="11843"><span class="lineNum">   11843 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;SgConstructorInitializer's constructor (class default constructor) name: amountOfNameQualificationRequired = %d \n&quot;,amountOfNameQualificationRequired);</a>
<a name="11844"><span class="lineNum">   11844 </span>            : #endif</a>
<a name="11845"><span class="lineNum">   11845 </span>            :                  // This will attach the new type string to the classDeclaration.</a>
<a name="11846"><span class="lineNum">   11846 </span><span class="lineCov">        951 :                     setNameQualification(constructorInitializer,classDeclaration,amountOfNameQualificationRequired);</span></a>
<a name="11847"><span class="lineNum">   11847 </span>            :                   }</a>
<a name="11848"><span class="lineNum">   11848 </span>            :                  else</a>
<a name="11849"><span class="lineNum">   11849 </span>            :                   {</a>
<a name="11850"><span class="lineNum">   11850 </span>            :                  // This is a strange error: see test2004_77.C</a>
<a name="11851"><span class="lineNum">   11851 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="11852"><span class="lineNum">   11852 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;WARNING: In SgConstructorInitializer name qualification support: neither memberFunctionDeclaration or classDeclaration are valid pointers. \n&quot;);</a>
<a name="11853"><span class="lineNum">   11853 </span>            : #endif</a>
<a name="11854"><span class="lineNum">   11854 </span>            :                   }</a>
<a name="11855"><span class="lineNum">   11855 </span>            :              }</a>
<a name="11856"><span class="lineNum">   11856 </span>            : </a>
<a name="11857"><span class="lineNum">   11857 </span>            :        // After processing the name qualification for the class declaration, we need to also process the</a>
<a name="11858"><span class="lineNum">   11858 </span>            :        // reference to the type for any name qualification on possible template arguments.</a>
<a name="11859"><span class="lineNum">   11859 </span><span class="lineCov">       4729 :           ASSERT_not_null(constructorInitializer-&gt;get_type());</span></a>
<a name="11860"><span class="lineNum">   11860 </span>            : </a>
<a name="11861"><span class="lineNum">   11861 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="11862"><span class="lineNum">   11862 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Calling traverseType() on constructorInitializer = %p class type = %p = %s \n&quot;,</a>
<a name="11863"><span class="lineNum">   11863 </span>            :                     constructorInitializer,constructorInitializer-&gt;get_type(),constructorInitializer-&gt;get_type()-&gt;class_name().c_str());</a>
<a name="11864"><span class="lineNum">   11864 </span>            : #endif</a>
<a name="11865"><span class="lineNum">   11865 </span>            :        // DQ (8/19/2013): Added the call to associate the name qualified class name with the constructorInitializer.</a>
<a name="11866"><span class="lineNum">   11866 </span>            :        // DQ (8/19/2013): Traverse the type to set any possible template arguments (or other subtypes?) that require name qualification.</a>
<a name="11867"><span class="lineNum">   11867 </span><span class="lineCov">       4729 :           traverseType(constructorInitializer-&gt;get_type(),constructorInitializer,currentScope,currentStatement);</span></a>
<a name="11868"><span class="lineNum">   11868 </span>            : </a>
<a name="11869"><span class="lineNum">   11869 </span>            : #if 0</a>
<a name="11870"><span class="lineNum">   11870 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;DONE: Calling traverseType() on constructorInitializer: Exiting as a test! \n&quot;);</a>
<a name="11871"><span class="lineNum">   11871 </span>            :           ROSE_ABORT();</a>
<a name="11872"><span class="lineNum">   11872 </span>            : #endif</a>
<a name="11873"><span class="lineNum">   11873 </span>            : </a>
<a name="11874"><span class="lineNum">   11874 </span>            : #if 0</a>
<a name="11875"><span class="lineNum">   11875 </span>            :        // DQ (4/27/2019): Debugging test2019_102.C.</a>
<a name="11876"><span class="lineNum">   11876 </span>            :           SgNode* constructorInitializerParent = constructorInitializer-&gt;get_parent();</a>
<a name="11877"><span class="lineNum">   11877 </span>            :           SgInitializedName* initializedName = isSgInitializedName(constructorInitializerParent);</a>
<a name="11878"><span class="lineNum">   11878 </span>            :           if (initializedName != NULL)</a>
<a name="11879"><span class="lineNum">   11879 </span>            :              {</a>
<a name="11880"><span class="lineNum">   11880 </span>            : #if 0</a>
<a name="11881"><span class="lineNum">   11881 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="11882"><span class="lineNum">   11882 </span>            :                ROSE_ABORT();</a>
<a name="11883"><span class="lineNum">   11883 </span>            : #endif</a>
<a name="11884"><span class="lineNum">   11884 </span>            :              }</a>
<a name="11885"><span class="lineNum">   11885 </span>            : #endif</a>
<a name="11886"><span class="lineNum">   11886 </span>            :         }</a>
<a name="11887"><span class="lineNum">   11887 </span>            : </a>
<a name="11888"><span class="lineNum">   11888 </span>            : </a>
<a name="11889"><span class="lineNum">   11889 </span>            : </a>
<a name="11890"><span class="lineNum">   11890 </span>            :   // DQ (3/21/2018): This is a derived class from SgConstructorInitializer...</a>
<a name="11891"><span class="lineNum">   11891 </span><span class="lineCov">    2810440 :      SgAggregateInitializer* aggregateInitializer = isSgAggregateInitializer(n);</span></a>
<a name="11892"><span class="lineNum">   11892 </span><span class="lineCov">    2810440 :      if (aggregateInitializer != NULL)</span></a>
<a name="11893"><span class="lineNum">   11893 </span>            :         {</a>
<a name="11894"><span class="lineNum">   11894 </span>            :        // DQ (3/21/2018): Ignore the member function for the case of a SgAggregateInitializer.</a>
<a name="11895"><span class="lineNum">   11895 </span>            :        // SgMemberFunctionDeclaration* memberFunctionDeclaration = aggregateInitializer-&gt;get_declaration();</a>
<a name="11896"><span class="lineNum">   11896 </span>            :        // SgMemberFunctionDeclaration* memberFunctionDeclaration = NULL;</a>
<a name="11897"><span class="lineNum">   11897 </span><span class="lineCov">         22 :           SgType* aggregateInitializerType = aggregateInitializer-&gt;get_type();</span></a>
<a name="11898"><span class="lineNum">   11898 </span><span class="lineCov">         22 :           ASSERT_not_null(aggregateInitializerType);</span></a>
<a name="11899"><span class="lineNum">   11899 </span>            : #if 0</a>
<a name="11900"><span class="lineNum">   11900 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Case of SgAggregateInitializer: aggregateInitializerType = %p = %s \n&quot;,aggregateInitializerType,aggregateInitializerType-&gt;class_name().c_str());</a>
<a name="11901"><span class="lineNum">   11901 </span>            : #endif</a>
<a name="11902"><span class="lineNum">   11902 </span><span class="lineCov">         22 :           SgClassType* aggregateInitializerClassType = isSgClassType(aggregateInitializerType);</span></a>
<a name="11903"><span class="lineNum">   11903 </span>            : #if 0</a>
<a name="11904"><span class="lineNum">   11904 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Case of SgAggregateInitializer: aggregateInitializerClassType = %p \n&quot;,aggregateInitializerClassType);</a>
<a name="11905"><span class="lineNum">   11905 </span>            : #endif</a>
<a name="11906"><span class="lineNum">   11906 </span><span class="lineCov">         22 :           SgClassDeclaration* aggregateInitializerClassDeclaration = NULL;</span></a>
<a name="11907"><span class="lineNum">   11907 </span><span class="lineCov">         22 :           if (aggregateInitializerClassType != NULL)</span></a>
<a name="11908"><span class="lineNum">   11908 </span>            :              {</a>
<a name="11909"><span class="lineNum">   11909 </span><span class="lineCov">         11 :                aggregateInitializerClassDeclaration = isSgClassDeclaration(aggregateInitializerClassType-&gt;get_declaration());</span></a>
<a name="11910"><span class="lineNum">   11910 </span><span class="lineCov">         11 :                ASSERT_not_null(aggregateInitializerClassDeclaration);</span></a>
<a name="11911"><span class="lineNum">   11911 </span>            : #if 0</a>
<a name="11912"><span class="lineNum">   11912 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Case of SgAggregateInitializer: classDeclaration = %p = %s name = %s \n&quot;,</a>
<a name="11913"><span class="lineNum">   11913 </span>            :                     aggregateInitializerClassDeclaration,aggregateInitializerClassDeclaration-&gt;class_name().c_str(),aggregateInitializerClassDeclaration-&gt;get_name().str());</a>
<a name="11914"><span class="lineNum">   11914 </span>            : #endif</a>
<a name="11915"><span class="lineNum">   11915 </span>            : #if 0</a>
<a name="11916"><span class="lineNum">   11916 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="11917"><span class="lineNum">   11917 </span>            :                ROSE_ABORT();</a>
<a name="11918"><span class="lineNum">   11918 </span>            : #endif</a>
<a name="11919"><span class="lineNum">   11919 </span>            :              }</a>
<a name="11920"><span class="lineNum">   11920 </span>            : </a>
<a name="11921"><span class="lineNum">   11921 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="11922"><span class="lineNum">   11922 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Case of SgAggregateInitializer: aggregateInitializerClassDeclaration = %p \n&quot;,aggregateInitializerClassDeclaration);</a>
<a name="11923"><span class="lineNum">   11923 </span>            : #endif</a>
<a name="11924"><span class="lineNum">   11924 </span>            : </a>
<a name="11925"><span class="lineNum">   11925 </span><span class="lineCov">         22 :           SgStatement* currentStatement = TransformationSupport::getStatement(aggregateInitializer);</span></a>
<a name="11926"><span class="lineNum">   11926 </span><span class="lineCov">         22 :           if (currentStatement == NULL)</span></a>
<a name="11927"><span class="lineNum">   11927 </span>            :              {</a>
<a name="11928"><span class="lineNum">   11928 </span>            :             // DQ (1/28/2019): This can happen when the expression is used in an array type declaration (e.g. within a variable declaration for an array).</a>
<a name="11929"><span class="lineNum">   11929 </span>            :             // NOTE: this will be possibly incorrect if there is a using declaration in the scope that would be important to the name qualification.</a>
<a name="11930"><span class="lineNum">   11930 </span>            :             // We would then need to know if the declarration declaring the array type was before or after the using declaration.</a>
<a name="11931"><span class="lineNum">   11931 </span>            :             // Not clear what would be the best wayy to solve that problem (though it would not be in the set of directived already processed, so it might be fine).</a>
<a name="11932"><span class="lineNum">   11932 </span>            : #if 0</a>
<a name="11933"><span class="lineNum">   11933 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;In name qualification: not possible to locate statement containing aggregateInitializer = %p (using first statement from current scope) \n&quot;,aggregateInitializer);</a>
<a name="11934"><span class="lineNum">   11934 </span>            : #endif</a>
<a name="11935"><span class="lineNum">   11935 </span><span class="lineNoCov">          0 :                ASSERT_not_null(aggregateInitializer-&gt;get_parent());</span></a>
<a name="11936"><span class="lineNum">   11936 </span>            : </a>
<a name="11937"><span class="lineNum">   11937 </span><span class="lineNoCov">          0 :                SgScopeStatement* tmp_currentScope = inheritedAttribute.get_currentScope();</span></a>
<a name="11938"><span class="lineNum">   11938 </span><span class="lineNoCov">          0 :                ASSERT_not_null(tmp_currentScope);</span></a>
<a name="11939"><span class="lineNum">   11939 </span>            : #if 0</a>
<a name="11940"><span class="lineNum">   11940 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;SgAggregateInitializer: tmp_currentScope = %p = %s \n&quot;,tmp_currentScope,tmp_currentScope-&gt;class_name().c_str());</a>
<a name="11941"><span class="lineNum">   11941 </span>            :                tmp_currentScope-&gt;get_file_info()-&gt;display(&quot;SgAggregateInitializer: debug&quot;);</a>
<a name="11942"><span class="lineNum">   11942 </span>            : #endif</a>
<a name="11943"><span class="lineNum">   11943 </span>            : #if 0</a>
<a name="11944"><span class="lineNum">   11944 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Error in aggregateInitializer = %p \n&quot;,aggregateInitializer);</a>
<a name="11945"><span class="lineNum">   11945 </span>            :                ASSERT_not_null(aggregateInitializer-&gt;get_parent());</a>
<a name="11946"><span class="lineNum">   11946 </span>            :                aggregateInitializer-&gt;get_file_info()-&gt;display(&quot;Error in aggregateInitializer&quot;);</a>
<a name="11947"><span class="lineNum">   11947 </span>            :                aggregateInitializer-&gt;get_parent()-&gt;get_file_info()-&gt;display(&quot;Error in aggregateInitializer-&gt;get_parent()&quot;);</a>
<a name="11948"><span class="lineNum">   11948 </span>            : #endif</a>
<a name="11949"><span class="lineNum">   11949 </span>            :             // If we don't have a statement derived from the expression to reference, then use the first statement in the current scope.</a>
<a name="11950"><span class="lineNum">   11950 </span><span class="lineNoCov">          0 :                currentStatement = tmp_currentScope-&gt;firstStatement();</span></a>
<a name="11951"><span class="lineNum">   11951 </span>            : #if 0</a>
<a name="11952"><span class="lineNum">   11952 </span>            :                if (currentStatement == NULL)</a>
<a name="11953"><span class="lineNum">   11953 </span>            :                   {</a>
<a name="11954"><span class="lineNum">   11954 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;ERROR: currentStatement == NULL: tmp_currentScope = %p = %s \n&quot;,tmp_currentScope,tmp_currentScope-&gt;class_name().c_str());</a>
<a name="11955"><span class="lineNum">   11955 </span>            :                  // tmp_currentScope-&gt;get_file_info()-&gt;display(&quot;ERROR: currentStatement == NULL: debug&quot;);</a>
<a name="11956"><span class="lineNum">   11956 </span>            :                   }</a>
<a name="11957"><span class="lineNum">   11957 </span>            : #endif</a>
<a name="11958"><span class="lineNum">   11958 </span><span class="lineNoCov">          0 :                ASSERT_not_null(currentStatement);</span></a>
<a name="11959"><span class="lineNum">   11959 </span>            :              }</a>
<a name="11960"><span class="lineNum">   11960 </span><span class="lineCov">         22 :           ASSERT_not_null(currentStatement);</span></a>
<a name="11961"><span class="lineNum">   11961 </span>            : </a>
<a name="11962"><span class="lineNum">   11962 </span>            :        // If this could occur in a SgForStatement then this should be fixed up as it is elsewhere...</a>
<a name="11963"><span class="lineNum">   11963 </span><span class="lineCov">         22 :           SgScopeStatement* currentScope = currentStatement-&gt;get_scope();</span></a>
<a name="11964"><span class="lineNum">   11964 </span><span class="lineCov">         22 :           ASSERT_not_null(currentScope);</span></a>
<a name="11965"><span class="lineNum">   11965 </span>            : </a>
<a name="11966"><span class="lineNum">   11966 </span><span class="lineCov">         22 :           if (aggregateInitializerClassDeclaration != NULL)</span></a>
<a name="11967"><span class="lineNum">   11967 </span>            :              {</a>
<a name="11968"><span class="lineNum">   11968 </span>            : #if 0</a>
<a name="11969"><span class="lineNum">   11969 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Case of SgAggregateInitializer: aggregateInitializerClassDeclaration = %p = %s name = %s \n&quot;,</a>
<a name="11970"><span class="lineNum">   11970 </span>            :                     aggregateInitializerClassDeclaration,aggregateInitializerClassDeclaration-&gt;class_name().c_str(),aggregateInitializerClassDeclaration-&gt;get_name().str());</a>
<a name="11971"><span class="lineNum">   11971 </span>            : #endif</a>
<a name="11972"><span class="lineNum">   11972 </span><span class="lineCov">         11 :                int amountOfNameQualificationRequired = nameQualificationDepth(aggregateInitializerClassDeclaration,currentScope,currentStatement);</span></a>
<a name="11973"><span class="lineNum">   11973 </span>            : </a>
<a name="11974"><span class="lineNum">   11974 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="11975"><span class="lineNum">   11975 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;SgAggregateInitializer's class declaration name: amountOfNameQualificationRequired = %d \n&quot;,amountOfNameQualificationRequired);</a>
<a name="11976"><span class="lineNum">   11976 </span>            : #endif</a>
<a name="11977"><span class="lineNum">   11977 </span><span class="lineCov">         11 :                setNameQualification(aggregateInitializer,aggregateInitializerClassDeclaration,amountOfNameQualificationRequired);</span></a>
<a name="11978"><span class="lineNum">   11978 </span>            : #if 0</a>
<a name="11979"><span class="lineNum">   11979 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;In name qualification: Case of SgAggregateInitializer: aggregateInitializerClassDeclaration = %p \n&quot;,aggregateInitializerClassDeclaration);</a>
<a name="11980"><span class="lineNum">   11980 </span>            : #endif</a>
<a name="11981"><span class="lineNum">   11981 </span>            : #if 0</a>
<a name="11982"><span class="lineNum">   11982 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;DONE: Calling setNameQualification() on aggregateInitializer: Exiting as a test! \n&quot;);</a>
<a name="11983"><span class="lineNum">   11983 </span>            :                ROSE_ABORT();</a>
<a name="11984"><span class="lineNum">   11984 </span>            : #endif</a>
<a name="11985"><span class="lineNum">   11985 </span>            : </a>
<a name="11986"><span class="lineNum">   11986 </span>            :             // After processing the name qualification for the class declaration, we need to also process the</a>
<a name="11987"><span class="lineNum">   11987 </span>            :             // reference to the type for any name qualification on possible template arguments.</a>
<a name="11988"><span class="lineNum">   11988 </span><span class="lineCov">         11 :                ASSERT_not_null(aggregateInitializer-&gt;get_type());</span></a>
<a name="11989"><span class="lineNum">   11989 </span>            : </a>
<a name="11990"><span class="lineNum">   11990 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="11991"><span class="lineNum">   11991 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Calling traverseType() on aggregateInitializer = %p class type = %p = %s \n&quot;,</a>
<a name="11992"><span class="lineNum">   11992 </span>            :                     aggregateInitializer,aggregateInitializer-&gt;get_type(),aggregateInitializer-&gt;get_type()-&gt;class_name().c_str());</a>
<a name="11993"><span class="lineNum">   11993 </span>            : #endif</a>
<a name="11994"><span class="lineNum">   11994 </span>            :             // DQ (8/19/2013): Added the call to associate the name qualified class name with the constructorInitializer.</a>
<a name="11995"><span class="lineNum">   11995 </span>            :             // DQ (8/19/2013): Traverse the type to set any possible template arguments (or other subtypes?) that require name qualification.</a>
<a name="11996"><span class="lineNum">   11996 </span><span class="lineCov">         11 :                traverseType(aggregateInitializer-&gt;get_type(),aggregateInitializer,currentScope,currentStatement);</span></a>
<a name="11997"><span class="lineNum">   11997 </span>            : #if 0</a>
<a name="11998"><span class="lineNum">   11998 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;DONE: Calling traverseType() on aggregateInitializer: Exiting as a test! \n&quot;);</a>
<a name="11999"><span class="lineNum">   11999 </span>            :                ROSE_ABORT();</a>
<a name="12000"><span class="lineNum">   12000 </span>            : #endif</a>
<a name="12001"><span class="lineNum">   12001 </span>            :              }</a>
<a name="12002"><span class="lineNum">   12002 </span>            :             else</a>
<a name="12003"><span class="lineNum">   12003 </span>            :              {</a>
<a name="12004"><span class="lineNum">   12004 </span>            :             // This is likely the case of a SgAggregateInitializer used for an array (not associated with a class declaration).</a>
<a name="12005"><span class="lineNum">   12005 </span>            : #if 0</a>
<a name="12006"><span class="lineNum">   12006 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;In name qualification: Case of SgAggregateInitializer: aggregateInitializerClassDeclaration == NULL \n&quot;);</a>
<a name="12007"><span class="lineNum">   12007 </span>            : #endif</a>
<a name="12008"><span class="lineNum">   12008 </span>            :              }</a>
<a name="12009"><span class="lineNum">   12009 </span>            :         }</a>
<a name="12010"><span class="lineNum">   12010 </span>            : </a>
<a name="12011"><span class="lineNum">   12011 </span>            : </a>
<a name="12012"><span class="lineNum">   12012 </span>            : </a>
<a name="12013"><span class="lineNum">   12013 </span><span class="lineCov">    2810440 :      SgVarRefExp* varRefExp = isSgVarRefExp(n);</span></a>
<a name="12014"><span class="lineNum">   12014 </span><span class="lineCov">    2810440 :      if (varRefExp != NULL)</span></a>
<a name="12015"><span class="lineNum">   12015 </span>            :         {</a>
<a name="12016"><span class="lineNum">   12016 </span>            :        // We need to store the information about the required name qualification in the SgVarRefExp IR node.</a>
<a name="12017"><span class="lineNum">   12017 </span>            : </a>
<a name="12018"><span class="lineNum">   12018 </span><span class="lineCov">      66275 :           SgStatement* currentStatement = TransformationSupport::getStatement(varRefExp);</span></a>
<a name="12019"><span class="lineNum">   12019 </span>            : </a>
<a name="12020"><span class="lineNum">   12020 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="12021"><span class="lineNum">   12021 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Case of SgVarRefExp: varRefExp = %p currentStatement = %p = %s \n&quot;,varRefExp,currentStatement,currentStatement != NULL ? currentStatement-&gt;class_name().c_str() : &quot;null&quot;);</a>
<a name="12022"><span class="lineNum">   12022 </span>            : #endif</a>
<a name="12023"><span class="lineNum">   12023 </span>            : </a>
<a name="12024"><span class="lineNum">   12024 </span>            :        // DQ (2/7/2019): Adding support for name qualification induced from SgPointerMemberType function paramters.</a>
<a name="12025"><span class="lineNum">   12025 </span><span class="lineCov">      66275 :           bool nameQualificationInducedFromPointerMemberType = false;</span></a>
<a name="12026"><span class="lineNum">   12026 </span>            : </a>
<a name="12027"><span class="lineNum">   12027 </span>            :        // DQ (2/8/2019): And then I woke up in the morning and had a better idea.</a>
<a name="12028"><span class="lineNum">   12028 </span>            :        // DQ (2/8/2019): An alternative to supporting pointer-to-member name qualification would be to detect member data accessed via a pointer.</a>
<a name="12029"><span class="lineNum">   12029 </span>            :        // so we need to look at the parent of a SgVarRefExp and see if it is a SgAddressOfOp when it is a reference to a data member.</a>
<a name="12030"><span class="lineNum">   12030 </span><span class="lineCov">      66275 :           bool isDataMemberReference = SageInterface::isDataMemberReference(varRefExp);</span></a>
<a name="12031"><span class="lineNum">   12031 </span><span class="lineCov">      66275 :           bool isAddressTaken        = SageInterface::isAddressTaken(varRefExp);</span></a>
<a name="12032"><span class="lineNum">   12032 </span>            : </a>
<a name="12033"><span class="lineNum">   12033 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || 0</a>
<a name="12034"><span class="lineNum">   12034 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Case of SgVarRefExp: isDataMemberReference = %s isAddressTaken = %s \n&quot;,isDataMemberReference ? &quot;true&quot; : &quot;false&quot;,isAddressTaken ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="12035"><span class="lineNum">   12035 </span>            : #endif</a>
<a name="12036"><span class="lineNum">   12036 </span><span class="lineCov">      66275 :           if (isDataMemberReference == true &amp;&amp; isAddressTaken == true)</span></a>
<a name="12037"><span class="lineNum">   12037 </span>            :              {</a>
<a name="12038"><span class="lineNum">   12038 </span>            :                nameQualificationInducedFromPointerMemberType = true;</a>
<a name="12039"><span class="lineNum">   12039 </span>            :              }</a>
<a name="12040"><span class="lineNum">   12040 </span>            :             else</a>
<a name="12041"><span class="lineNum">   12041 </span>            :              {</a>
<a name="12042"><span class="lineNum">   12042 </span>            :             // DQ (2/15/2019): Debugging Cxx11_tests/test2019_129.C.  Data member references should have a current</a>
<a name="12043"><span class="lineNum">   12043 </span>            :             // statement that starts in the class XXX (instead of where XXX.yyy is located.</a>
<a name="12044"><span class="lineNum">   12044 </span>            :             // If this is a data member reference, then we need to change the perspective to a currentStatement of</a>
<a name="12045"><span class="lineNum">   12045 </span>            :             // that of the class where it is a data member reference.  So XXX.yyy would have yyy be a data member</a>
<a name="12046"><span class="lineNum">   12046 </span>            :             // of XXX and so the current statement would be the scope represent by XXX.</a>
<a name="12047"><span class="lineNum">   12047 </span>            : </a>
<a name="12048"><span class="lineNum">   12048 </span>            :             // DQ (2/15/2019): Unfortunately data member name qualification happens top down, instaed of bottom up</a>
<a name="12049"><span class="lineNum">   12049 </span>            :             // like all other name qualification.  So this is going to complicate things.</a>
<a name="12050"><span class="lineNum">   12050 </span>            : </a>
<a name="12051"><span class="lineNum">   12051 </span>            :             // Need to change the name of this function to be more specific.</a>
<a name="12052"><span class="lineNum">   12052 </span><span class="lineCov">      66275 :                if (isDataMemberReference == true)</span></a>
<a name="12053"><span class="lineNum">   12053 </span>            :                   {</a>
<a name="12054"><span class="lineNum">   12054 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="12055"><span class="lineNum">   12055 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Change the starting location for name qualification to the class where the data member reference is referenced \n&quot;);</a>
<a name="12056"><span class="lineNum">   12056 </span>            : #endif</a>
<a name="12057"><span class="lineNum">   12057 </span><span class="lineCov">       5166 :                     ROSE_ASSERT(isAddressTaken == false);</span></a>
<a name="12058"><span class="lineNum">   12058 </span>            :                  // reset the current statement.</a>
<a name="12059"><span class="lineNum">   12059 </span>            : </a>
<a name="12060"><span class="lineNum">   12060 </span>            :                  // Insead of returning the SgClassType at the end of the chain, we actaully need to generate the chain</a>
<a name="12061"><span class="lineNum">   12061 </span>            :                  // of SgClassType the reflects the path taken (represented by the chain of SgCastExp expressions).</a>
<a name="12062"><span class="lineNum">   12062 </span>            : </a>
<a name="12063"><span class="lineNum">   12063 </span>            :                  // Then for each element of the chain, we need to lookup the symbol (a in &quot;X x; x.a;&quot;) in the scope</a>
<a name="12064"><span class="lineNum">   12064 </span>            :                  // representing each class, and see if the number of causal nodes is more than one. The name qualification</a>
<a name="12065"><span class="lineNum">   12065 </span>            :                  // length is the longest chain between scopes where two of the associated SgAliasSymbols have 2 or more</a>
<a name="12066"><span class="lineNum">   12066 </span>            :                  // causal nodes.</a>
<a name="12067"><span class="lineNum">   12067 </span>            : </a>
<a name="12068"><span class="lineNum">   12068 </span>            :                  // DQ (2/16/2019): We need to look for both variable and base class ambiguity.  I don't think we need</a>
<a name="12069"><span class="lineNum">   12069 </span>            :                  // base class ambiguity, since that is not allowed in the langauge.</a>
<a name="12070"><span class="lineNum">   12070 </span>            : </a>
<a name="12071"><span class="lineNum">   12071 </span>            :                  // Second generation of this function.</a>
<a name="12072"><span class="lineNum">   12072 </span>            :                  // std::list&lt;SgClassType*&gt; classChain = SageInterface::getClassTypeChainForDataMemberReference(varRefExp);</a>
<a name="12073"><span class="lineNum">   12073 </span><span class="lineCov">      10332 :                     std::list&lt;SgClassType*&gt; classChain = SageInterface::getClassTypeChainForMemberReference(varRefExp);</span></a>
<a name="12074"><span class="lineNum">   12074 </span>            : </a>
<a name="12075"><span class="lineNum">   12075 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="12076"><span class="lineNum">   12076 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;case SgVarRefExp: classChain.size() = %zu \n&quot;,classChain.size());</a>
<a name="12077"><span class="lineNum">   12077 </span>            :                     std::list&lt;SgClassType*&gt;::iterator classChain_iterator = classChain.begin();</a>
<a name="12078"><span class="lineNum">   12078 </span>            :                     while (classChain_iterator != classChain.end())</a>
<a name="12079"><span class="lineNum">   12079 </span>            :                        {</a>
<a name="12080"><span class="lineNum">   12080 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot; --- *classChain_iterator = %p = %s name = %s \n&quot;,*classChain_iterator,(*classChain_iterator)-&gt;class_name().c_str(),(*classChain_iterator)-&gt;get_name().str());</a>
<a name="12081"><span class="lineNum">   12081 </span>            : </a>
<a name="12082"><span class="lineNum">   12082 </span>            :                          classChain_iterator++;</a>
<a name="12083"><span class="lineNum">   12083 </span>            :                        }</a>
<a name="12084"><span class="lineNum">   12084 </span>            : #endif</a>
<a name="12085"><span class="lineNum">   12085 </span>            :                  // DQ (11/10/2020): This assertion failed (classChain.size() &lt;= 2) where the value was 3 for some of the target code for codeSegregation.</a>
<a name="12086"><span class="lineNum">   12086 </span>            :                  // DQ (11/8/2020): I now think that Cxx11_tests/test_2019_120.C could be used to make this arbitrarily long.</a>
<a name="12087"><span class="lineNum">   12087 </span>            :                  // DQ (12/11/2019): Modified to provide a larger upper bound for classChain.size().</a>
<a name="12088"><span class="lineNum">   12088 </span>            :                  // DQ (2/16/2019): I think this is always true, since base class abiguity is not allowed in the C++ language.</a>
<a name="12089"><span class="lineNum">   12089 </span>            :                  // ROSE_ASSERT(classChain.size() == 1);</a>
<a name="12090"><span class="lineNum">   12090 </span>            :                  // ROSE_ASSERT(classChain.empty() == true || classChain.size() == 1);</a>
<a name="12091"><span class="lineNum">   12091 </span>            :                  // ROSE_ASSERT(classChain.empty() == true || classChain.size() &lt;= 2);</a>
<a name="12092"><span class="lineNum">   12092 </span><span class="lineCov">       5166 :                     if (classChain.size() &gt; 3)</span></a>
<a name="12093"><span class="lineNum">   12093 </span>            :                        {</a>
<a name="12094"><span class="lineNum">   12094 </span><span class="lineNoCov">          0 :                          printf (&quot;In name qualification: Case of SgVarRefExp: classChain.size() &gt; 3: classChain.size() = %zu \n&quot;,classChain.size());</span></a>
<a name="12095"><span class="lineNum">   12095 </span>            :                        }</a>
<a name="12096"><span class="lineNum">   12096 </span>            : </a>
<a name="12097"><span class="lineNum">   12097 </span>            :                  // DQ (2/16/2019): We need to call something like this, but specialized to just use the single class in the classChain.</a>
<a name="12098"><span class="lineNum">   12098 </span>            :                  // setNameQualification(varRefExp,variableDeclaration,amountOfNameQualificationRequired);</a>
<a name="12099"><span class="lineNum">   12099 </span>            : </a>
<a name="12100"><span class="lineNum">   12100 </span><span class="lineCov">       5166 :                     if (classChain.empty() == false)</span></a>
<a name="12101"><span class="lineNum">   12101 </span>            :                        {</a>
<a name="12102"><span class="lineNum">   12102 </span>            :                       // DQ (1/19/2020): Might need to recursively call the name qualification on the classChain_first</a>
<a name="12103"><span class="lineNum">   12103 </span>            :                       // since it can be a class that required name qualificaiton to resolve an ambiguity.</a>
<a name="12104"><span class="lineNum">   12104 </span>            : #if 0</a>
<a name="12105"><span class="lineNum">   12105 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;Might need a recursive call to resolve the possible ambiguity of this class defined by classChain_first \n&quot;);</a>
<a name="12106"><span class="lineNum">   12106 </span>            : #endif</a>
<a name="12107"><span class="lineNum">   12107 </span>            : </a>
<a name="12108"><span class="lineNum">   12108 </span>            : #if 1</a>
<a name="12109"><span class="lineNum">   12109 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="12110"><span class="lineNum">   12110 </span>            :                          std::list&lt;SgClassType*&gt;::iterator classChain_first = classChain.begin();</a>
<a name="12111"><span class="lineNum">   12111 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;(*classChain_first)-&gt;get_name().str() = %s \n&quot;,(*classChain_first)-&gt;get_name().str());</a>
<a name="12112"><span class="lineNum">   12112 </span>            : #endif</a>
<a name="12113"><span class="lineNum">   12113 </span>            : #if 0</a>
<a name="12114"><span class="lineNum">   12114 </span>            :                       // DQ (11/8/2020): Original code.</a>
<a name="12115"><span class="lineNum">   12115 </span>            :                       // This code is required to pass Cxx11_tests/test2019_129.C, test2019_130.C, etc.</a>
<a name="12116"><span class="lineNum">   12116 </span>            :                       // However, there might be a solution to make test_24_2020.cpp in codeSegregation also work.</a>
<a name="12117"><span class="lineNum">   12117 </span>            :                          std::string qualifier = std::string((*classChain_first)-&gt;get_name().str()) + &quot;::&quot;;</a>
<a name="12118"><span class="lineNum">   12118 </span>            : #else</a>
<a name="12119"><span class="lineNum">   12119 </span>            :                       // This is much more complex code, but it satisfies all of the test codes including the ones</a>
<a name="12120"><span class="lineNum">   12120 </span>            :                       // for codeSegragation when the the symbol table for the global scope across file is cleared.</a>
<a name="12121"><span class="lineNum">   12121 </span>            : #if 0</a>
<a name="12122"><span class="lineNum">   12122 </span>            :                          printf (&quot;################################################# \n&quot;);</a>
<a name="12123"><span class="lineNum">   12123 </span>            :                          printf (&quot;Iterate over the classChain: size = %zu \n&quot;,classChain.size());</a>
<a name="12124"><span class="lineNum">   12124 </span>            :                          printf (&quot;################################################# \n&quot;);</a>
<a name="12125"><span class="lineNum">   12125 </span>            : #endif</a>
<a name="12126"><span class="lineNum">   12126 </span>            :                       // DQ (11/8/2020): Potential bug fix for name qualification error that only happens in</a>
<a name="12127"><span class="lineNum">   12127 </span>            :                       // transformations (e.g. codeSegregation and outlining). Note that it appears as an issue</a>
<a name="12128"><span class="lineNum">   12128 </span>            :                       // to fix only when the buildSourceFile() function is used and the symbol table associated</a>
<a name="12129"><span class="lineNum">   12129 </span>            :                       // with the global scope across files is cleared (recently implementd in SageInterface::buildFile()</a>
<a name="12130"><span class="lineNum">   12130 </span>            :                       // (called by SageInterface::getSourceFile()).</a>
<a name="12131"><span class="lineNum">   12131 </span><span class="lineNoCov">          0 :                          std::list&lt;SgClassType*&gt;::iterator classChain_last;</span></a>
<a name="12132"><span class="lineNum">   12132 </span><span class="lineNoCov">          0 :                          std::list&lt;SgClassType*&gt;::iterator classChain_target = classChain.begin();</span></a>
<a name="12133"><span class="lineNum">   12133 </span><span class="lineNoCov">          0 :                          std::list&lt;SgClassType*&gt;::iterator i = classChain.begin();</span></a>
<a name="12134"><span class="lineNum">   12134 </span>            : </a>
<a name="12135"><span class="lineNum">   12135 </span><span class="lineNoCov">          0 :                          bool useNextClass = false;</span></a>
<a name="12136"><span class="lineNum">   12136 </span>            :                       // Note that the start of the chain may not be the most apropriate class to use.</a>
<a name="12137"><span class="lineNum">   12137 </span>            :                       // This is demonstrated by Cxx_tests/test2019_130.C and the codeSegragation tool test_93.cpp.</a>
<a name="12138"><span class="lineNum">   12138 </span><span class="lineNoCov">          0 :                          while (i != classChain.end())</span></a>
<a name="12139"><span class="lineNum">   12139 </span>            :                             {</a>
<a name="12140"><span class="lineNum">   12140 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || 0</a>
<a name="12141"><span class="lineNum">   12141 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot; --- (*i)-&gt;get_name().str() = %s \n&quot;,(*i)-&gt;get_name().str());</a>
<a name="12142"><span class="lineNum">   12142 </span>            : #endif</a>
<a name="12143"><span class="lineNum">   12143 </span>            :                            // Review the length of the causal nodes for the alias symbol.  If is is one then no name qualification</a>
<a name="12144"><span class="lineNum">   12144 </span>            :                            // is needed, if it is more than one then name qualification is required to disambiguate the member access.</a>
<a name="12145"><span class="lineNum">   12145 </span><span class="lineNoCov">          0 :                               SgClassType* classType = *i;</span></a>
<a name="12146"><span class="lineNum">   12146 </span><span class="lineNoCov">          0 :                               ROSE_ASSERT(classType != NULL);</span></a>
<a name="12147"><span class="lineNum">   12147 </span>            : </a>
<a name="12148"><span class="lineNum">   12148 </span><span class="lineNoCov">          0 :                               SgClassDeclaration* classDeclaration = isSgClassDeclaration(classType-&gt;get_declaration());</span></a>
<a name="12149"><span class="lineNum">   12149 </span><span class="lineNoCov">          0 :                               ROSE_ASSERT(classDeclaration != NULL);</span></a>
<a name="12150"><span class="lineNum">   12150 </span>            : #if 0</a>
<a name="12151"><span class="lineNum">   12151 </span>            :                               printf (&quot; ---  --- classDeclaration = %p = %s name = %s \n&quot;,classDeclaration,classDeclaration-&gt;class_name().c_str(),classDeclaration-&gt;get_name().str());</a>
<a name="12152"><span class="lineNum">   12152 </span>            : #endif</a>
<a name="12153"><span class="lineNum">   12153 </span><span class="lineNoCov">          0 :                               SgClassDeclaration* definingClassDeclaration = isSgClassDeclaration(classDeclaration-&gt;get_definingDeclaration());</span></a>
<a name="12154"><span class="lineNum">   12154 </span><span class="lineNoCov">          0 :                               if (definingClassDeclaration != NULL)</span></a>
<a name="12155"><span class="lineNum">   12155 </span>            :                                  {</a>
<a name="12156"><span class="lineNum">   12156 </span><span class="lineNoCov">          0 :                                    SgSymbol* varRefExp_symbol = varRefExp-&gt;get_symbol();</span></a>
<a name="12157"><span class="lineNum">   12157 </span><span class="lineNoCov">          0 :                                    ROSE_ASSERT(varRefExp_symbol != NULL);</span></a>
<a name="12158"><span class="lineNum">   12158 </span>            : </a>
<a name="12159"><span class="lineNum">   12159 </span><span class="lineNoCov">          0 :                                    SgName varRefExp_name = varRefExp_symbol-&gt;get_name();</span></a>
<a name="12160"><span class="lineNum">   12160 </span>            : #if 0</a>
<a name="12161"><span class="lineNum">   12161 </span>            :                                    printf (&quot; ---  --- varRefExp_name = %s \n&quot;,varRefExp_name.str());</a>
<a name="12162"><span class="lineNum">   12162 </span>            : #endif</a>
<a name="12163"><span class="lineNum">   12163 </span><span class="lineNoCov">          0 :                                    SgClassDefinition* classDefinition = definingClassDeclaration-&gt;get_definition();</span></a>
<a name="12164"><span class="lineNum">   12164 </span><span class="lineNoCov">          0 :                                    ROSE_ASSERT(classDefinition != NULL);</span></a>
<a name="12165"><span class="lineNum">   12165 </span>            : </a>
<a name="12166"><span class="lineNum">   12166 </span><span class="lineNoCov">          0 :                                    size_t number_of_alias_symbols = classDefinition-&gt;count_alias_symbol(varRefExp_name);</span></a>
<a name="12167"><span class="lineNum">   12167 </span>            : #if 0</a>
<a name="12168"><span class="lineNum">   12168 </span>            :                                    printf (&quot; ---  --- number_of_alias_symbols = %zu \n&quot;,number_of_alias_symbols);</a>
<a name="12169"><span class="lineNum">   12169 </span>            : #endif</a>
<a name="12170"><span class="lineNum">   12170 </span><span class="lineNoCov">          0 :                                    if (number_of_alias_symbols &gt; 0)</span></a>
<a name="12171"><span class="lineNum">   12171 </span>            :                                       {</a>
<a name="12172"><span class="lineNum">   12172 </span><span class="lineNoCov">          0 :                                         SgAliasSymbol* aliasSymbol = classDefinition-&gt;lookup_alias_symbol(varRefExp_name,varRefExp_symbol);</span></a>
<a name="12173"><span class="lineNum">   12173 </span>            : #if 0</a>
<a name="12174"><span class="lineNum">   12174 </span>            :                                         printf (&quot; ---  --- number_of_alias_symbols &gt; 0: aliasSymbol = %p \n&quot;,aliasSymbol);</a>
<a name="12175"><span class="lineNum">   12175 </span>            : #endif</a>
<a name="12176"><span class="lineNum">   12176 </span><span class="lineNoCov">          0 :                                         if (aliasSymbol != NULL)</span></a>
<a name="12177"><span class="lineNum">   12177 </span>            :                                            {</a>
<a name="12178"><span class="lineNum">   12178 </span>            : #if 0</a>
<a name="12179"><span class="lineNum">   12179 </span>            :                                              printf (&quot; ---  --- number_of_alias_symbols &gt; 0: Found an alias symbol: aliasSymbol = %p = %s \n&quot;,aliasSymbol,aliasSymbol-&gt;class_name().c_str());</a>
<a name="12180"><span class="lineNum">   12180 </span>            :                                              printf (&quot; ---  --- number_of_alias_symbols &gt; 0: Found an alias symbol: causal_nodes list size = %zu \n&quot;,aliasSymbol-&gt;get_causal_nodes().size());</a>
<a name="12181"><span class="lineNum">   12181 </span>            : #endif</a>
<a name="12182"><span class="lineNum">   12182 </span><span class="lineNoCov">          0 :                                              if (aliasSymbol-&gt;get_causal_nodes().size() == 1)</span></a>
<a name="12183"><span class="lineNum">   12183 </span>            :                                                 {</a>
<a name="12184"><span class="lineNum">   12184 </span>            :                                                // Reset to where there will be no ambiguity.</a>
<a name="12185"><span class="lineNum">   12185 </span>            : #if 0</a>
<a name="12186"><span class="lineNum">   12186 </span>            :                                                   printf (&quot;Reset because aliasSymbol-&gt;get_causal_nodes().size() == 1 \n&quot;);</a>
<a name="12187"><span class="lineNum">   12187 </span>            : #endif</a>
<a name="12188"><span class="lineNum">   12188 </span>            :                                                   classChain_target = i;</a>
<a name="12189"><span class="lineNum">   12189 </span>            :                                                 }</a>
<a name="12190"><span class="lineNum">   12190 </span>            :                                                else</a>
<a name="12191"><span class="lineNum">   12191 </span>            :                                                 {</a>
<a name="12192"><span class="lineNum">   12192 </span><span class="lineNoCov">          0 :                                                   if (aliasSymbol-&gt;get_causal_nodes().size() &gt; 1)</span></a>
<a name="12193"><span class="lineNum">   12193 </span>            :                                                      {</a>
<a name="12194"><span class="lineNum">   12194 </span>            :                                                     // Use the next element in the chain.</a>
<a name="12195"><span class="lineNum">   12195 </span><span class="lineNoCov">          0 :                                                        useNextClass = true;</span></a>
<a name="12196"><span class="lineNum">   12196 </span>            :                                                      }</a>
<a name="12197"><span class="lineNum">   12197 </span>            :                                                 }</a>
<a name="12198"><span class="lineNum">   12198 </span>            :                                            }</a>
<a name="12199"><span class="lineNum">   12199 </span>            :                                       }</a>
<a name="12200"><span class="lineNum">   12200 </span>            :                                      else</a>
<a name="12201"><span class="lineNum">   12201 </span>            :                                       {</a>
<a name="12202"><span class="lineNum">   12202 </span>            :                                      // Reset to where there will be no ambiguity.</a>
<a name="12203"><span class="lineNum">   12203 </span>            : #if 0</a>
<a name="12204"><span class="lineNum">   12204 </span>            :                                         printf (&quot;Reset because number_of_alias_symbols == 0: useNextClass = %s \n&quot;,useNextClass ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="12205"><span class="lineNum">   12205 </span>            : #endif</a>
<a name="12206"><span class="lineNum">   12206 </span><span class="lineNoCov">          0 :                                         if (useNextClass == true)</span></a>
<a name="12207"><span class="lineNum">   12207 </span>            :                                            {</a>
<a name="12208"><span class="lineNum">   12208 </span><span class="lineNoCov">          0 :                                              classChain_target = i;</span></a>
<a name="12209"><span class="lineNum">   12209 </span><span class="lineNoCov">          0 :                                              useNextClass = false;</span></a>
<a name="12210"><span class="lineNum">   12210 </span>            :                                            }</a>
<a name="12211"><span class="lineNum">   12211 </span>            :                                       }</a>
<a name="12212"><span class="lineNum">   12212 </span>            : #if 0</a>
<a name="12213"><span class="lineNum">   12213 </span>            :                                    SgSymbol* symbol = classDefinition-&gt;lookup_variable_symbol(varRefExp_name);</a>
<a name="12214"><span class="lineNum">   12214 </span>            :                                 // ROSE_ASSERT(symbol != NULL);</a>
<a name="12215"><span class="lineNum">   12215 </span>            :                                    if (symbol != NULL)</a>
<a name="12216"><span class="lineNum">   12216 </span>            :                                       {</a>
<a name="12217"><span class="lineNum">   12217 </span>            : #if 0</a>
<a name="12218"><span class="lineNum">   12218 </span>            :                                         printf (&quot; ---  --- symbol = %p = %s \n&quot;,symbol,symbol-&gt;class_name().c_str());</a>
<a name="12219"><span class="lineNum">   12219 </span>            :                                         bool hasAmbiguity = classDefinition-&gt;hasAmbiguity(varRefExp_name,symbol);</a>
<a name="12220"><span class="lineNum">   12220 </span>            :                                         printf (&quot; ---  --- hasAmbiguity = %s \n&quot;,hasAmbiguity ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="12221"><span class="lineNum">   12221 </span>            : #endif</a>
<a name="12222"><span class="lineNum">   12222 </span>            :                                         SgAliasSymbol* aliasSymbol = classDefinition-&gt;lookup_alias_symbol(varRefExp_name,symbol);</a>
<a name="12223"><span class="lineNum">   12223 </span>            : #if 0</a>
<a name="12224"><span class="lineNum">   12224 </span>            :                                         printf (&quot; ---  --- aliasSymbol = %p \n&quot;,aliasSymbol);</a>
<a name="12225"><span class="lineNum">   12225 </span>            :                                         if (aliasSymbol != NULL)</a>
<a name="12226"><span class="lineNum">   12226 </span>            :                                            {</a>
<a name="12227"><span class="lineNum">   12227 </span>            :                                              printf (&quot; ---  --- Found an alias symbol: aliasSymbol = %p = %s \n&quot;,aliasSymbol,aliasSymbol-&gt;class_name().c_str());</a>
<a name="12228"><span class="lineNum">   12228 </span>            :                                              printf (&quot; ---  --- Found an alias symbol: causal_nodes list size = %zu \n&quot;,aliasSymbol-&gt;get_causal_nodes().size());</a>
<a name="12229"><span class="lineNum">   12229 </span>            :                                            }</a>
<a name="12230"><span class="lineNum">   12230 </span>            : #endif</a>
<a name="12231"><span class="lineNum">   12231 </span>            :                                       }</a>
<a name="12232"><span class="lineNum">   12232 </span>            :                                      else</a>
<a name="12233"><span class="lineNum">   12233 </span>            :                                       {</a>
<a name="12234"><span class="lineNum">   12234 </span>            : #if 0</a>
<a name="12235"><span class="lineNum">   12235 </span>            :                                         printf (&quot; ---  --- symbol == NULL \n&quot;);</a>
<a name="12236"><span class="lineNum">   12236 </span>            : #endif</a>
<a name="12237"><span class="lineNum">   12237 </span>            :                                       }</a>
<a name="12238"><span class="lineNum">   12238 </span>            : #endif</a>
<a name="12239"><span class="lineNum">   12239 </span>            :                                  }</a>
<a name="12240"><span class="lineNum">   12240 </span>            : </a>
<a name="12241"><span class="lineNum">   12241 </span>            :                            // qualifier += std::string((*i)-&gt;get_name().str()) + &quot;::&quot;;</a>
<a name="12242"><span class="lineNum">   12242 </span><span class="lineNoCov">          0 :                               classChain_last = i;</span></a>
<a name="12243"><span class="lineNum">   12243 </span><span class="lineNoCov">          0 :                               i++;</span></a>
<a name="12244"><span class="lineNum">   12244 </span>            :                             }</a>
<a name="12245"><span class="lineNum">   12245 </span>            :                       // std::string qualifier = std::string((*classChain_last)-&gt;get_name().str()) + &quot;::&quot;;</a>
<a name="12246"><span class="lineNum">   12246 </span><span class="lineNoCov">          0 :                          std::string qualifier = std::string((*classChain_target)-&gt;get_name().str()) + &quot;::&quot;;</span></a>
<a name="12247"><span class="lineNum">   12247 </span>            : #endif</a>
<a name="12248"><span class="lineNum">   12248 </span>            : #else</a>
<a name="12249"><span class="lineNum">   12249 </span>            :                       // DQ (1/20/2020): Accumulate the list of names from the classChain list.</a>
<a name="12250"><span class="lineNum">   12250 </span>            :                          std::list&lt;SgClassType*&gt;::iterator i = classChain.begin();</a>
<a name="12251"><span class="lineNum">   12251 </span>            :                          std::string qualifier;</a>
<a name="12252"><span class="lineNum">   12252 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="12253"><span class="lineNum">   12253 </span>            :                          while (i != classChain.end())</a>
<a name="12254"><span class="lineNum">   12254 </span>            :                             {</a>
<a name="12255"><span class="lineNum">   12255 </span>            : #if 0</a>
<a name="12256"><span class="lineNum">   12256 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;(*i)-&gt;get_name().str() = %s \n&quot;,(*i)-&gt;get_name().str());</a>
<a name="12257"><span class="lineNum">   12257 </span>            : #endif</a>
<a name="12258"><span class="lineNum">   12258 </span>            :                               qualifier += std::string((*i)-&gt;get_name().str()) + &quot;::&quot;;</a>
<a name="12259"><span class="lineNum">   12259 </span>            :                               i++;</a>
<a name="12260"><span class="lineNum">   12260 </span>            :                             }</a>
<a name="12261"><span class="lineNum">   12261 </span>            : #endif</a>
<a name="12262"><span class="lineNum">   12262 </span>            : </a>
<a name="12263"><span class="lineNum">   12263 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="12264"><span class="lineNum">   12264 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;data member qualifier = %s \n&quot;,qualifier.c_str());</a>
<a name="12265"><span class="lineNum">   12265 </span>            : #endif</a>
<a name="12266"><span class="lineNum">   12266 </span>            :                       // DQ (2/16/2019): Mark this as at least non-zero, but it is computed based on where the ambiguity is instead</a>
<a name="12267"><span class="lineNum">   12267 </span>            :                       // of as a length of the chain of scope from the variable referenced's variable declaration scope.</a>
<a name="12268"><span class="lineNum">   12268 </span><span class="lineNoCov">          0 :                          varRefExp-&gt;set_name_qualification_length(1);</span></a>
<a name="12269"><span class="lineNum">   12269 </span>            : </a>
<a name="12270"><span class="lineNum">   12270 </span><span class="lineNoCov">          0 :                          varRefExp-&gt;set_global_qualification_required(false);</span></a>
<a name="12271"><span class="lineNum">   12271 </span><span class="lineNoCov">          0 :                          varRefExp-&gt;set_type_elaboration_required(false);</span></a>
<a name="12272"><span class="lineNum">   12272 </span>            : </a>
<a name="12273"><span class="lineNum">   12273 </span><span class="lineNoCov">          0 :                          if (qualifiedNameMapForNames.find(varRefExp) == qualifiedNameMapForNames.end())</span></a>
<a name="12274"><span class="lineNum">   12274 </span>            :                             {</a>
<a name="12275"><span class="lineNum">   12275 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="12276"><span class="lineNum">   12276 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;Inserting qualifier for name = %s into list at IR node = %p = %s \n&quot;,qualifier.c_str(),varRefExp,varRefExp-&gt;class_name().c_str());</a>
<a name="12277"><span class="lineNum">   12277 </span>            : #endif</a>
<a name="12278"><span class="lineNum">   12278 </span><span class="lineNoCov">          0 :                               qualifiedNameMapForNames.insert(std::pair&lt;SgNode*,std::string&gt;(varRefExp,qualifier));</span></a>
<a name="12279"><span class="lineNum">   12279 </span>            :                             }</a>
<a name="12280"><span class="lineNum">   12280 </span>            :                            else</a>
<a name="12281"><span class="lineNum">   12281 </span>            :                             {</a>
<a name="12282"><span class="lineNum">   12282 </span>            :                            // DQ (6/20/2011): We see this case in test2011_87.C.</a>
<a name="12283"><span class="lineNum">   12283 </span>            :                            // If it already existes then overwrite the existing information.</a>
<a name="12284"><span class="lineNum">   12284 </span><span class="lineNoCov">          0 :                               std::map&lt;SgNode*,std::string&gt;::iterator i = qualifiedNameMapForNames.find(varRefExp);</span></a>
<a name="12285"><span class="lineNum">   12285 </span><span class="lineNoCov">          0 :                               ROSE_ASSERT (i != qualifiedNameMapForNames.end());</span></a>
<a name="12286"><span class="lineNum">   12286 </span>            : </a>
<a name="12287"><span class="lineNum">   12287 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="12288"><span class="lineNum">   12288 </span>            :                               string previousQualifier = i-&gt;second.c_str();</a>
<a name="12289"><span class="lineNum">   12289 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;WARNING: test 1: replacing previousQualifier = %s with new qualifier = %s \n&quot;,previousQualifier.c_str(),qualifier.c_str());</a>
<a name="12290"><span class="lineNum">   12290 </span>            : #endif</a>
<a name="12291"><span class="lineNum">   12291 </span><span class="lineNoCov">          0 :                               if (i-&gt;second != qualifier)</span></a>
<a name="12292"><span class="lineNum">   12292 </span>            :                                  {</a>
<a name="12293"><span class="lineNum">   12293 </span>            :                                 // DQ (7/23/2011): Multiple uses of the SgVarRefExp expression in SgArrayType will cause</a>
<a name="12294"><span class="lineNum">   12294 </span>            :                                 // the name qualification to be reset each time.  This is OK since it is used to build</a>
<a name="12295"><span class="lineNum">   12295 </span>            :                                 // the type name that will be saved.</a>
<a name="12296"><span class="lineNum">   12296 </span><span class="lineNoCov">          0 :                                    i-&gt;second = qualifier;</span></a>
<a name="12297"><span class="lineNum">   12297 </span>            : #if 0</a>
<a name="12298"><span class="lineNum">   12298 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;Note: name in qualifiedNameMapForNames already exists and is different... \n&quot;);</a>
<a name="12299"><span class="lineNum">   12299 </span>            : #endif</a>
<a name="12300"><span class="lineNum">   12300 </span>            :                                  }</a>
<a name="12301"><span class="lineNum">   12301 </span>            :                             }</a>
<a name="12302"><span class="lineNum">   12302 </span>            : #if 0</a>
<a name="12303"><span class="lineNum">   12303 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="12304"><span class="lineNum">   12304 </span>            :                          ROSE_ABORT();</a>
<a name="12305"><span class="lineNum">   12305 </span>            : #endif</a>
<a name="12306"><span class="lineNum">   12306 </span>            :                        }</a>
<a name="12307"><span class="lineNum">   12307 </span>            : </a>
<a name="12308"><span class="lineNum">   12308 </span>            : #if 0</a>
<a name="12309"><span class="lineNum">   12309 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="12310"><span class="lineNum">   12310 </span>            :                     ROSE_ABORT();</a>
<a name="12311"><span class="lineNum">   12311 </span>            : #endif</a>
<a name="12312"><span class="lineNum">   12312 </span>            :                   }</a>
<a name="12313"><span class="lineNum">   12313 </span>            :              }</a>
<a name="12314"><span class="lineNum">   12314 </span>            : </a>
<a name="12315"><span class="lineNum">   12315 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="12316"><span class="lineNum">   12316 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Case of SgVarRefExp: nameQualificationInducedFromPointerMemberType = %s \n&quot;,nameQualificationInducedFromPointerMemberType ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="12317"><span class="lineNum">   12317 </span>            :           mfprintf(mlog [ WARN ] ) (&quot; --- isDataMemberReference = %s isAddressTaken = %s \n&quot;,isDataMemberReference ? &quot;true&quot; : &quot;false&quot;,isAddressTaken ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="12318"><span class="lineNum">   12318 </span>            :           mfprintf(mlog [ WARN ] ) (&quot; --- currentStatement = %p \n&quot;,currentStatement);</a>
<a name="12319"><span class="lineNum">   12319 </span>            : #endif</a>
<a name="12320"><span class="lineNum">   12320 </span>            : </a>
<a name="12321"><span class="lineNum">   12321 </span><span class="lineCov">      66275 :           if (isDataMemberReference == false || isAddressTaken == true)</span></a>
<a name="12322"><span class="lineNum">   12322 </span>            :              {</a>
<a name="12323"><span class="lineNum">   12323 </span>            :             // DQ (7/24/2020): Is this declared above this point?</a>
<a name="12324"><span class="lineNum">   12324 </span>            :             // variableDeclaration = NULL;</a>
<a name="12325"><span class="lineNum">   12325 </span>            : </a>
<a name="12326"><span class="lineNum">   12326 </span>            :             // DQ (6/23/2011): This test fails for the new name qualification after a transformation in tests/nonsmoke/functional/roseTests/programTransformationTests/test1.C</a>
<a name="12327"><span class="lineNum">   12327 </span>            :             // ASSERT_not_null(currentStatement);</a>
<a name="12328"><span class="lineNum">   12328 </span><span class="lineCov">      61109 :                if (currentStatement != NULL)</span></a>
<a name="12329"><span class="lineNum">   12329 </span>            :                   {</a>
<a name="12330"><span class="lineNum">   12330 </span>            :                  // DQ (5/30/2011): Handle the case of test2011_58.C (index declaration in for loop construct).</a>
<a name="12331"><span class="lineNum">   12331 </span>            :                  // SgScopeStatement* currentScope = currentStatement-&gt;get_scope();</a>
<a name="12332"><span class="lineNum">   12332 </span><span class="lineCov">      60998 :                     SgScopeStatement* currentScope = isSgScopeStatement(currentStatement);</span></a>
<a name="12333"><span class="lineNum">   12333 </span><span class="lineCov">      60998 :                     if (currentScope == NULL)</span></a>
<a name="12334"><span class="lineNum">   12334 </span>            :                        {</a>
<a name="12335"><span class="lineNum">   12335 </span><span class="lineCov">      60165 :                          currentScope = currentStatement-&gt;get_scope();</span></a>
<a name="12336"><span class="lineNum">   12336 </span>            :                        }</a>
<a name="12337"><span class="lineNum">   12337 </span><span class="lineCov">      60998 :                     ASSERT_not_null(currentScope);</span></a>
<a name="12338"><span class="lineNum">   12338 </span>            : </a>
<a name="12339"><span class="lineNum">   12339 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="12340"><span class="lineNum">   12340 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Case SgVarRefExp: (could this be in an array type?) currentScope = %p = %s \n&quot;,currentScope,currentScope-&gt;class_name().c_str());</a>
<a name="12341"><span class="lineNum">   12341 </span>            : #endif</a>
<a name="12342"><span class="lineNum">   12342 </span><span class="lineCov">      60998 :                     SgVariableSymbol* variableSymbol = varRefExp-&gt;get_symbol();</span></a>
<a name="12343"><span class="lineNum">   12343 </span><span class="lineCov">      60998 :                     ASSERT_not_null(variableSymbol);</span></a>
<a name="12344"><span class="lineNum">   12344 </span><span class="lineCov">      60998 :                     SgInitializedName* initializedName = variableSymbol-&gt;get_declaration();</span></a>
<a name="12345"><span class="lineNum">   12345 </span><span class="lineCov">      60998 :                     ASSERT_not_null(initializedName);</span></a>
<a name="12346"><span class="lineNum">   12346 </span>            : </a>
<a name="12347"><span class="lineNum">   12347 </span>            :                  // DQ (7/18/2012): Added test as part of debugging test2011_75.C.</a>
<a name="12348"><span class="lineNum">   12348 </span><span class="lineCov">      60998 :                     ASSERT_not_null(initializedName-&gt;get_parent());</span></a>
<a name="12349"><span class="lineNum">   12349 </span>            : </a>
<a name="12350"><span class="lineNum">   12350 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="12351"><span class="lineNum">   12351 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Case of SgVarRefExp: varRefExp = %p : initializedName name = %s parent = %p = %s \n&quot;,</a>
<a name="12352"><span class="lineNum">   12352 </span>            :                          varRefExp,initializedName-&gt;get_name().str(),initializedName-&gt;get_parent(),initializedName-&gt;get_parent()-&gt;class_name().c_str());</a>
<a name="12353"><span class="lineNum">   12353 </span>            : #endif</a>
<a name="12354"><span class="lineNum">   12354 </span>            :                  // DQ (7/24/3030): This variable declaration hides an outer declaration using the same variable name.</a>
<a name="12355"><span class="lineNum">   12355 </span><span class="lineCov">      60998 :                     SgVariableDeclaration* variableDeclaration = isSgVariableDeclaration(initializedName-&gt;get_parent());</span></a>
<a name="12356"><span class="lineNum">   12356 </span>            :                  // ASSERT_not_null(variableDeclaration);</a>
<a name="12357"><span class="lineNum">   12357 </span>            : </a>
<a name="12358"><span class="lineNum">   12358 </span>            :                  // DQ (7/24/2020): Debugging Cxx20_tests/test2020_122.C and Cxx_tests/test2020_14.C.</a>
<a name="12359"><span class="lineNum">   12359 </span>            :                  // bool inDesignatedInitializer = false;</a>
<a name="12360"><span class="lineNum">   12360 </span><span class="lineCov">      60998 :                     if ((variableDeclaration != NULL) &amp;&amp; (variableDeclaration != variableDeclaration-&gt;get_definingDeclaration()) )</span></a>
<a name="12361"><span class="lineNum">   12361 </span>            :                        {</a>
<a name="12362"><span class="lineNum">   12362 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) &amp;&amp; 0</a>
<a name="12363"><span class="lineNum">   12363 </span>            :                          printf (&quot;SgVarRefExp is not in a defining SgVariableDeclaration: might be in a SgDesignatedInitializer \n&quot;);</a>
<a name="12364"><span class="lineNum">   12364 </span>            : #endif</a>
<a name="12365"><span class="lineNum">   12365 </span><span class="lineCov">      20436 :                          SgExprListExp* exprListExp = isSgExprListExp(varRefExp-&gt;get_parent());</span></a>
<a name="12366"><span class="lineNum">   12366 </span><span class="lineCov">      20436 :                          if (exprListExp != NULL)</span></a>
<a name="12367"><span class="lineNum">   12367 </span>            :                             {</a>
<a name="12368"><span class="lineNum">   12368 </span><span class="lineCov">       5351 :                               SgDesignatedInitializer* designatedInitializer = isSgDesignatedInitializer(exprListExp-&gt;get_parent());</span></a>
<a name="12369"><span class="lineNum">   12369 </span><span class="lineCov">       5351 :                               if (designatedInitializer != NULL)</span></a>
<a name="12370"><span class="lineNum">   12370 </span>            :                                  {</a>
<a name="12371"><span class="lineNum">   12371 </span>            :                                 // inDesignatedInitializer = true;</a>
<a name="12372"><span class="lineNum">   12372 </span>            : #if 0</a>
<a name="12373"><span class="lineNum">   12373 </span>            :                                    printf (&quot;Found case of SgVarRefExp in SgDesignatedInitializer (no name qualification is required (allowed)) \n&quot;);</a>
<a name="12374"><span class="lineNum">   12374 </span>            :                                    ROSE_ABORT();</a>
<a name="12375"><span class="lineNum">   12375 </span>            : #endif</a>
<a name="12376"><span class="lineNum">   12376 </span>            :                                 // This is not a SgInitializedName being declared by a variable declaration. Setting</a>
<a name="12377"><span class="lineNum">   12377 </span>            :                                 // this to NULL will force the TRUE case below to be taken, which after the check</a>
<a name="12378"><span class="lineNum">   12378 </span>            :                                 // for some builtin predefined names, will cause not name qualification to be added.</a>
<a name="12379"><span class="lineNum">   12379 </span>            :                                    variableDeclaration = NULL;</a>
<a name="12380"><span class="lineNum">   12380 </span>            :                                  }</a>
<a name="12381"><span class="lineNum">   12381 </span>            :                             }</a>
<a name="12382"><span class="lineNum">   12382 </span>            :                        }</a>
<a name="12383"><span class="lineNum">   12383 </span>            : #if 0</a>
<a name="12384"><span class="lineNum">   12384 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Test 1: Processing varRefExp = %p: Exiting as a test! \n&quot;,varRefExp);</a>
<a name="12385"><span class="lineNum">   12385 </span>            :                     ROSE_ABORT();</a>
<a name="12386"><span class="lineNum">   12386 </span>            : #endif</a>
<a name="12387"><span class="lineNum">   12387 </span><span class="lineCov">      60998 :                     if (variableDeclaration == NULL)</span></a>
<a name="12388"><span class="lineNum">   12388 </span>            :                        {</a>
<a name="12389"><span class="lineNum">   12389 </span>            :                       // This is the special case for the compiler generated variable &quot;__PRETTY_FUNCTION__&quot;.</a>
<a name="12390"><span class="lineNum">   12390 </span><span class="lineCov">      40562 :                          if (initializedName-&gt;get_name() == &quot;__PRETTY_FUNCTION__&quot; ||  initializedName-&gt;get_name() == &quot;__func__&quot;)</span></a>
<a name="12391"><span class="lineNum">   12391 </span>            :                             {</a>
<a name="12392"><span class="lineNum">   12392 </span>            :                            // Skip these cases ... no name qualification is required.</a>
<a name="12393"><span class="lineNum">   12393 </span>            :                             }</a>
<a name="12394"><span class="lineNum">   12394 </span>            :                            else</a>
<a name="12395"><span class="lineNum">   12395 </span>            :                             {</a>
<a name="12396"><span class="lineNum">   12396 </span>            :                            // If this is a SgInitializedName from a function parameter list then it does not need qualification.</a>
<a name="12397"><span class="lineNum">   12397 </span><span class="lineCov">      40562 :                               SgFunctionParameterList* functionParameterList = isSgFunctionParameterList(initializedName-&gt;get_parent());</span></a>
<a name="12398"><span class="lineNum">   12398 </span>            :                               if (functionParameterList != NULL)</a>
<a name="12399"><span class="lineNum">   12399 </span>            :                                  {</a>
<a name="12400"><span class="lineNum">   12400 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="12401"><span class="lineNum">   12401 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;Names from function parameter list can not be name qualified (because they are the initial declarations): name = %s \n&quot;,initializedName-&gt;get_name().str());</a>
<a name="12402"><span class="lineNum">   12402 </span>            : #endif</a>
<a name="12403"><span class="lineNum">   12403 </span>            :                                  }</a>
<a name="12404"><span class="lineNum">   12404 </span>            :                                 else</a>
<a name="12405"><span class="lineNum">   12405 </span>            :                                  {</a>
<a name="12406"><span class="lineNum">   12406 </span>            : </a>
<a name="12407"><span class="lineNum">   12407 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="12408"><span class="lineNum">   12408 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;varRefExp's initialized name = %s is not associated with a SgVariableDeclaration \n&quot;,initializedName-&gt;get_name().str());</a>
<a name="12409"><span class="lineNum">   12409 </span>            :                                    initializedName-&gt;get_file_info()-&gt;display(&quot;This SgInitializedName is not associated with a SgVariableDeclaration&quot;);</a>
<a name="12410"><span class="lineNum">   12410 </span>            : </a>
<a name="12411"><span class="lineNum">   12411 </span>            :                                    SgStatement* currentStatement = TransformationSupport::getStatement(initializedName-&gt;get_parent());</a>
<a name="12412"><span class="lineNum">   12412 </span>            :                                    ASSERT_not_null(currentStatement);</a>
<a name="12413"><span class="lineNum">   12413 </span>            : </a>
<a name="12414"><span class="lineNum">   12414 </span>            :                                    SgScopeStatement* targetScope = initializedName-&gt;get_scope();</a>
<a name="12415"><span class="lineNum">   12415 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;targetScope = %p = %s \n&quot;,targetScope,targetScope-&gt;class_name().c_str());</a>
<a name="12416"><span class="lineNum">   12416 </span>            : </a>
<a name="12417"><span class="lineNum">   12417 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;SgVarRefExp case (no associated variableDeclaration): currentStatement = %p = %s \n&quot;,currentStatement,currentStatement-&gt;class_name().c_str());</a>
<a name="12418"><span class="lineNum">   12418 </span>            : </a>
<a name="12419"><span class="lineNum">   12419 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="12420"><span class="lineNum">   12420 </span>            : #endif</a>
<a name="12421"><span class="lineNum">   12421 </span>            :                                 // DQ (7/18/2012): Uncommented to debug test2011_75.C, not fixed, but test2005_103.C fails and so this should be commented again (I think).</a>
<a name="12422"><span class="lineNum">   12422 </span>            :                                 // ROSE_ASSERT(false);</a>
<a name="12423"><span class="lineNum">   12423 </span>            :                                  }</a>
<a name="12424"><span class="lineNum">   12424 </span>            :                             }</a>
<a name="12425"><span class="lineNum">   12425 </span>            : #if 0</a>
<a name="12426"><span class="lineNum">   12426 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;Test 1.2: Processing varRefExp = %p: Exiting as a test! \n&quot;,varRefExp);</a>
<a name="12427"><span class="lineNum">   12427 </span>            :                          ROSE_ABORT();</a>
<a name="12428"><span class="lineNum">   12428 </span>            : #endif</a>
<a name="12429"><span class="lineNum">   12429 </span>            :                        }</a>
<a name="12430"><span class="lineNum">   12430 </span>            :                       else</a>
<a name="12431"><span class="lineNum">   12431 </span>            :                        {</a>
<a name="12432"><span class="lineNum">   12432 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="12433"><span class="lineNum">   12433 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;In case SgVarRefExp: (variableDeclaration != NULL) Calling nameQualificationDepth() \n&quot;);</a>
<a name="12434"><span class="lineNum">   12434 </span>            : #endif</a>
<a name="12435"><span class="lineNum">   12435 </span>            :                       // DQ (12/21/2015): When this is a data member of a class/struct then we are consistatnly overqualifying the SgVarRefExp</a>
<a name="12436"><span class="lineNum">   12436 </span>            :                       // because we are not considering the case of a variable of type class that is being used with the SgArrowExp or SgDotExp</a>
<a name="12437"><span class="lineNum">   12437 </span>            :                       // which would not require the name qualification.  The only case where we would still need the name qualification is the</a>
<a name="12438"><span class="lineNum">   12438 </span>            :                       // relatively rare case of multiple inheritance (which must be detected seperately).</a>
<a name="12439"><span class="lineNum">   12439 </span>            : #if 0</a>
<a name="12440"><span class="lineNum">   12440 </span>            : </a>
<a name="12441"><span class="lineNum">   12441 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="12442"><span class="lineNum">   12442 </span>            : </a>
<a name="12443"><span class="lineNum">   12443 </span>            : #define DEBUG_MEMBER_DATA_QUALIFICATION 1</a>
<a name="12444"><span class="lineNum">   12444 </span>            : </a>
<a name="12445"><span class="lineNum">   12445 </span>            :                          SgScopeStatement* variableDeclarationScope = variableDeclaration-&gt;get_scope();</a>
<a name="12446"><span class="lineNum">   12446 </span>            :                          ASSERT_not_null(variableDeclarationScope);</a>
<a name="12447"><span class="lineNum">   12447 </span>            : </a>
<a name="12448"><span class="lineNum">   12448 </span>            :                       // If this is the same scoep then it is not interesting to debug this case.</a>
<a name="12449"><span class="lineNum">   12449 </span>            :                          if (variableDeclarationScope != currentScope)</a>
<a name="12450"><span class="lineNum">   12450 </span>            :                             {</a>
<a name="12451"><span class="lineNum">   12451 </span>            :                               SgExpression* parentExpression = isSgExpression(varRefExp-&gt;get_parent());</a>
<a name="12452"><span class="lineNum">   12452 </span>            : </a>
<a name="12453"><span class="lineNum">   12453 </span>            :                               SgBinaryOp* binaryOperator = isSgBinaryOp(parentExpression);</a>
<a name="12454"><span class="lineNum">   12454 </span>            :                               if (binaryOperator != NULL)</a>
<a name="12455"><span class="lineNum">   12455 </span>            :                                  {</a>
<a name="12456"><span class="lineNum">   12456 </span>            :                                    ASSERT_not_null(parentExpression);</a>
<a name="12457"><span class="lineNum">   12457 </span>            : #if DEBUG_MEMBER_DATA_QUALIFICATION</a>
<a name="12458"><span class="lineNum">   12458 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;   --- parentExpression of varRefExp = %p varRefExp = %p = %s \n&quot;,varRefExp,parentExpression,parentExpression-&gt;class_name().c_str());</a>
<a name="12459"><span class="lineNum">   12459 </span>            : #endif</a>
<a name="12460"><span class="lineNum">   12460 </span>            :                                    SgArrowExp* arrowExp = isSgArrowExp(binaryOperator);</a>
<a name="12461"><span class="lineNum">   12461 </span>            :                                    SgDotExp* dotExp     = isSgDotExp(binaryOperator);</a>
<a name="12462"><span class="lineNum">   12462 </span>            : </a>
<a name="12463"><span class="lineNum">   12463 </span>            :                                    SgExpression* lhs  = binaryOperator-&gt;get_lhs_operand();</a>
<a name="12464"><span class="lineNum">   12464 </span>            :                                    ASSERT_not_null(lhs);</a>
<a name="12465"><span class="lineNum">   12465 </span>            :                                    SgCastExp* castExp = isSgCastExp(lhs);</a>
<a name="12466"><span class="lineNum">   12466 </span>            : #if DEBUG_MEMBER_DATA_QUALIFICATION</a>
<a name="12467"><span class="lineNum">   12467 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;   --- lhs = %p = %s \n&quot;,lhs,lhs-&gt;class_name().c_str());</a>
<a name="12468"><span class="lineNum">   12468 </span>            : #endif</a>
<a name="12469"><span class="lineNum">   12469 </span>            :                                 // DQ (12/22/2015): Iterate though any possible chain of SgCastExp IR nodes (see test2005_89.C).</a>
<a name="12470"><span class="lineNum">   12470 </span>            :                                 // if (castExp != NULL &amp;&amp; castExp-&gt;get_file_info()-&gt;isCompilerGenerated() == true)</a>
<a name="12471"><span class="lineNum">   12471 </span>            :                                    while (castExp != NULL &amp;&amp; castExp-&gt;get_file_info()-&gt;isCompilerGenerated() == true)</a>
<a name="12472"><span class="lineNum">   12472 </span>            :                                       {</a>
<a name="12473"><span class="lineNum">   12473 </span>            : #if DEBUG_MEMBER_DATA_QUALIFICATION</a>
<a name="12474"><span class="lineNum">   12474 </span>            :                                         mfprintf(mlog [ WARN ] ) (&quot;   --- detected implicit (compiler generated) cast: castExp = %p \n&quot;,castExp);</a>
<a name="12475"><span class="lineNum">   12475 </span>            : #endif</a>
<a name="12476"><span class="lineNum">   12476 </span>            :                                         lhs = isSgExpression(castExp-&gt;get_operand());</a>
<a name="12477"><span class="lineNum">   12477 </span>            :                                         ASSERT_not_null(lhs);</a>
<a name="12478"><span class="lineNum">   12478 </span>            : </a>
<a name="12479"><span class="lineNum">   12479 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="12480"><span class="lineNum">   12480 </span>            : </a>
<a name="12481"><span class="lineNum">   12481 </span>            :                                      // We have to handle chains of implicit casts.</a>
<a name="12482"><span class="lineNum">   12482 </span>            :                                      // ROSE_ASSERT(isSgCastExp(lhs) == NULL);</a>
<a name="12483"><span class="lineNum">   12483 </span>            : </a>
<a name="12484"><span class="lineNum">   12484 </span>            :                                         castExp = isSgCastExp(lhs);</a>
<a name="12485"><span class="lineNum">   12485 </span>            : #if 0</a>
<a name="12486"><span class="lineNum">   12486 </span>            :                                         if (isSgCastExp(lhs) != NULL)</a>
<a name="12487"><span class="lineNum">   12487 </span>            :                                            {</a>
<a name="12488"><span class="lineNum">   12488 </span>            :                                              mfprintf(mlog [ WARN ] ) (&quot;lhs = %p = %s \n&quot;,lhs,lhs-&gt;class_name().c_str());</a>
<a name="12489"><span class="lineNum">   12489 </span>            :                                              lhs-&gt;get_file_info()-&gt;display(&quot;implicit cast&quot;);</a>
<a name="12490"><span class="lineNum">   12490 </span>            :                                              varRefExp-&gt;get_file_info()-&gt;display(&quot;varRefExp associated with implicit cast&quot;);</a>
<a name="12491"><span class="lineNum">   12491 </span>            :                                            }</a>
<a name="12492"><span class="lineNum">   12492 </span>            : #endif</a>
<a name="12493"><span class="lineNum">   12493 </span>            :                                       }</a>
<a name="12494"><span class="lineNum">   12494 </span>            : </a>
<a name="12495"><span class="lineNum">   12495 </span>            : #if DEBUG_MEMBER_DATA_QUALIFICATION</a>
<a name="12496"><span class="lineNum">   12496 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;   --- (after filtering implicit casts) lhs = %p = %s \n&quot;,lhs,lhs-&gt;class_name().c_str());</a>
<a name="12497"><span class="lineNum">   12497 </span>            : #endif</a>
<a name="12498"><span class="lineNum">   12498 </span>            :                                    SgClassType* classType = NULL;</a>
<a name="12499"><span class="lineNum">   12499 </span>            : </a>
<a name="12500"><span class="lineNum">   12500 </span>            :                                 // DQ (12/22/2015): If the varRefExp is the lhs then we don't want to change the name qualification.</a>
<a name="12501"><span class="lineNum">   12501 </span>            :                                 // See test2015_138.C for example for the case of SgDotExp.</a>
<a name="12502"><span class="lineNum">   12502 </span>            :                                 // if (arrowExp != NULL)</a>
<a name="12503"><span class="lineNum">   12503 </span>            :                                    if (arrowExp != NULL &amp;&amp; lhs != varRefExp)</a>
<a name="12504"><span class="lineNum">   12504 </span>            :                                       {</a>
<a name="12505"><span class="lineNum">   12505 </span>            : #if DEBUG_MEMBER_DATA_QUALIFICATION</a>
<a name="12506"><span class="lineNum">   12506 </span>            :                                         mfprintf(mlog [ WARN ] ) (&quot;   --- Found SgArrowExp: lhs = %p = %s \n&quot;,lhs,lhs-&gt;class_name().c_str());</a>
<a name="12507"><span class="lineNum">   12507 </span>            : #endif</a>
<a name="12508"><span class="lineNum">   12508 </span>            :                                         SgType* lhs_type = lhs-&gt;get_type();</a>
<a name="12509"><span class="lineNum">   12509 </span>            :                                         ASSERT_not_null(lhs_type);</a>
<a name="12510"><span class="lineNum">   12510 </span>            : #if DEBUG_MEMBER_DATA_QUALIFICATION</a>
<a name="12511"><span class="lineNum">   12511 </span>            :                                         mfprintf(mlog [ WARN ] ) (&quot;   --- lhs_type = %p = %s \n&quot;,lhs_type,lhs_type-&gt;class_name().c_str());</a>
<a name="12512"><span class="lineNum">   12512 </span>            : #endif</a>
<a name="12513"><span class="lineNum">   12513 </span>            :                                      // Handle the case of reference to pointer type.</a>
<a name="12514"><span class="lineNum">   12514 </span>            :                                         lhs_type = lhs_type-&gt;stripType(SgType::STRIP_MODIFIER_TYPE | SgType::STRIP_REFERENCE_TYPE | SgType::STRIP_RVALUE_REFERENCE_TYPE | SgType::STRIP_TYPEDEF_TYPE);</a>
<a name="12515"><span class="lineNum">   12515 </span>            : </a>
<a name="12516"><span class="lineNum">   12516 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="12517"><span class="lineNum">   12517 </span>            : </a>
<a name="12518"><span class="lineNum">   12518 </span>            :                                         SgPointerType* pointerType = isSgPointerType(lhs_type);</a>
<a name="12519"><span class="lineNum">   12519 </span>            :                                      // ASSERT_not_null(pointerType);</a>
<a name="12520"><span class="lineNum">   12520 </span>            :                                         if (pointerType != NULL)</a>
<a name="12521"><span class="lineNum">   12521 </span>            :                                            {</a>
<a name="12522"><span class="lineNum">   12522 </span>            :                                              SgType* baseType = pointerType-&gt;get_base_type();</a>
<a name="12523"><span class="lineNum">   12523 </span>            :                                              ASSERT_not_null(baseType);</a>
<a name="12524"><span class="lineNum">   12524 </span>            : </a>
<a name="12525"><span class="lineNum">   12525 </span>            :                                           // Handle the case of pointer to reference type.</a>
<a name="12526"><span class="lineNum">   12526 </span>            :                                           // Not clear if we have to handle array types</a>
<a name="12527"><span class="lineNum">   12527 </span>            :                                              baseType = baseType-&gt;stripType(SgType::STRIP_MODIFIER_TYPE | SgType::STRIP_REFERENCE_TYPE | SgType::STRIP_RVALUE_REFERENCE_TYPE | SgType::STRIP_TYPEDEF_TYPE);</a>
<a name="12528"><span class="lineNum">   12528 </span>            :                                              ASSERT_not_null(baseType);</a>
<a name="12529"><span class="lineNum">   12529 </span>            : #if DEBUG_MEMBER_DATA_QUALIFICATION</a>
<a name="12530"><span class="lineNum">   12530 </span>            :                                              mfprintf(mlog [ WARN ] ) (&quot;   --- baseType = %p = %s \n&quot;,baseType,baseType-&gt;class_name().c_str());</a>
<a name="12531"><span class="lineNum">   12531 </span>            : #endif</a>
<a name="12532"><span class="lineNum">   12532 </span>            :                                           // It might be better to resolve this to a SgNamedType instead of SgClassType.</a>
<a name="12533"><span class="lineNum">   12533 </span>            :                                              classType = isSgClassType(baseType);</a>
<a name="12534"><span class="lineNum">   12534 </span>            :                                              if (classType == NULL)</a>
<a name="12535"><span class="lineNum">   12535 </span>            :                                                 {</a>
<a name="12536"><span class="lineNum">   12536 </span>            :                                                // DQ (12/18/2016): In the case of Cxx11_tests/test2016_97.C the baseType is a SgTemplateType (though the variable is declared with &quot;auto&quot;).</a>
<a name="12537"><span class="lineNum">   12537 </span>            :                                                   mfprintf(mlog [ WARN ] ) (&quot;Note: Name qualification: case of SgVarRefExp: type is not a SgClassType --- baseType = %p = %s \n&quot;,baseType,baseType-&gt;class_name().c_str());</a>
<a name="12538"><span class="lineNum">   12538 </span>            : #if 0</a>
<a name="12539"><span class="lineNum">   12539 </span>            :                                                   lhs-&gt;get_file_info()-&gt;display(&quot;classType == NULL: debug&quot;);</a>
<a name="12540"><span class="lineNum">   12540 </span>            : #endif</a>
<a name="12541"><span class="lineNum">   12541 </span>            :                                                 }</a>
<a name="12542"><span class="lineNum">   12542 </span>            :                                           // ASSERT_not_null(classType);</a>
<a name="12543"><span class="lineNum">   12543 </span>            :                                            }</a>
<a name="12544"><span class="lineNum">   12544 </span>            :                                           else</a>
<a name="12545"><span class="lineNum">   12545 </span>            :                                            {</a>
<a name="12546"><span class="lineNum">   12546 </span>            : #if 0</a>
<a name="12547"><span class="lineNum">   12547 </span>            :                                           // Debug this case!</a>
<a name="12548"><span class="lineNum">   12548 </span>            :                                           // I think this is happening for template classes (might be interesting to look into further).</a>
<a name="12549"><span class="lineNum">   12549 </span>            :                                              mfprintf(mlog [ WARN ] ) (&quot;   --- SgArrowExp without associated SgPointer \n&quot;);</a>
<a name="12550"><span class="lineNum">   12550 </span>            :                                              varRefExp-&gt;get_file_info()-&gt;display(&quot;SgArrowExp without associated SgPointer: debug&quot;);</a>
<a name="12551"><span class="lineNum">   12551 </span>            : #endif</a>
<a name="12552"><span class="lineNum">   12552 </span>            :                                            }</a>
<a name="12553"><span class="lineNum">   12553 </span>            :                                       }</a>
<a name="12554"><span class="lineNum">   12554 </span>            : </a>
<a name="12555"><span class="lineNum">   12555 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="12556"><span class="lineNum">   12556 </span>            : </a>
<a name="12557"><span class="lineNum">   12557 </span>            :                                 // DQ (12/22/2015): If the varRefExp is the lhs then we don't want to change the name qualification. See test2015_138.C for example.</a>
<a name="12558"><span class="lineNum">   12558 </span>            :                                 // if (dotExp != NULL)</a>
<a name="12559"><span class="lineNum">   12559 </span>            :                                    if (dotExp != NULL &amp;&amp; lhs != varRefExp)</a>
<a name="12560"><span class="lineNum">   12560 </span>            :                                       {</a>
<a name="12561"><span class="lineNum">   12561 </span>            : #if DEBUG_MEMBER_DATA_QUALIFICATION</a>
<a name="12562"><span class="lineNum">   12562 </span>            :                                         mfprintf(mlog [ WARN ] ) (&quot;   --- Found SgDotExp: lhs = %p = %s \n&quot;,lhs,lhs-&gt;class_name().c_str());</a>
<a name="12563"><span class="lineNum">   12563 </span>            : #endif</a>
<a name="12564"><span class="lineNum">   12564 </span>            :                                         SgType* lhs_type = lhs-&gt;get_type();</a>
<a name="12565"><span class="lineNum">   12565 </span>            :                                         ASSERT_not_null(lhs_type);</a>
<a name="12566"><span class="lineNum">   12566 </span>            : #if DEBUG_MEMBER_DATA_QUALIFICATION</a>
<a name="12567"><span class="lineNum">   12567 </span>            :                                         mfprintf(mlog [ WARN ] ) (&quot;   --- lhs_type = %p = %s = %s \n&quot;,lhs_type,lhs_type-&gt;class_name().c_str(),lhs_type-&gt;unparseToString().c_str());</a>
<a name="12568"><span class="lineNum">   12568 </span>            : #endif</a>
<a name="12569"><span class="lineNum">   12569 </span>            :                                      // Not clear if we have to handle array types</a>
<a name="12570"><span class="lineNum">   12570 </span>            :                                         SgType* baseType = lhs_type-&gt;stripType(SgType::STRIP_MODIFIER_TYPE | SgType::STRIP_REFERENCE_TYPE | SgType::STRIP_RVALUE_REFERENCE_TYPE | SgType::STRIP_TYPEDEF_TYPE);</a>
<a name="12571"><span class="lineNum">   12571 </span>            :                                         ASSERT_not_null(baseType);</a>
<a name="12572"><span class="lineNum">   12572 </span>            : #if DEBUG_MEMBER_DATA_QUALIFICATION</a>
<a name="12573"><span class="lineNum">   12573 </span>            :                                         mfprintf(mlog [ WARN ] ) (&quot;   --- baseType = %p = %s \n&quot;,baseType,baseType-&gt;class_name().c_str());</a>
<a name="12574"><span class="lineNum">   12574 </span>            : #endif</a>
<a name="12575"><span class="lineNum">   12575 </span>            :                                         classType = isSgClassType(baseType);</a>
<a name="12576"><span class="lineNum">   12576 </span>            :                                      // ASSERT_not_null(classType);</a>
<a name="12577"><span class="lineNum">   12577 </span>            :                                       }</a>
<a name="12578"><span class="lineNum">   12578 </span>            : </a>
<a name="12579"><span class="lineNum">   12579 </span>            :                                    if (classType != NULL)</a>
<a name="12580"><span class="lineNum">   12580 </span>            :                                       {</a>
<a name="12581"><span class="lineNum">   12581 </span>            :                                         SgDeclarationStatement* declarationStatement = classType-&gt;get_declaration();</a>
<a name="12582"><span class="lineNum">   12582 </span>            :                                         ASSERT_not_null(declarationStatement);</a>
<a name="12583"><span class="lineNum">   12583 </span>            : #if DEBUG_MEMBER_DATA_QUALIFICATION</a>
<a name="12584"><span class="lineNum">   12584 </span>            :                                         mfprintf(mlog [ WARN ] ) (&quot;   --- declarationStatement = %p = %s = %s \n&quot;,declarationStatement,declarationStatement-&gt;class_name().c_str(),SageInterface::get_name(declarationStatement).c_str());</a>
<a name="12585"><span class="lineNum">   12585 </span>            : #endif</a>
<a name="12586"><span class="lineNum">   12586 </span>            :                                         SgDeclarationStatement* definingDeclarationStatement = declarationStatement-&gt;get_definingDeclaration();</a>
<a name="12587"><span class="lineNum">   12587 </span>            :                                      // ASSERT_not_null(definingDeclarationStatement);</a>
<a name="12588"><span class="lineNum">   12588 </span>            :                                         if (definingDeclarationStatement != NULL)</a>
<a name="12589"><span class="lineNum">   12589 </span>            :                                            {</a>
<a name="12590"><span class="lineNum">   12590 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="12591"><span class="lineNum">   12591 </span>            : </a>
<a name="12592"><span class="lineNum">   12592 </span>            :                                              SgClassDeclaration* definingClassDeclaration = isSgClassDeclaration(definingDeclarationStatement);</a>
<a name="12593"><span class="lineNum">   12593 </span>            :                                              ASSERT_not_null(definingClassDeclaration);</a>
<a name="12594"><span class="lineNum">   12594 </span>            :                                              SgClassDefinition* classDefinition = definingClassDeclaration-&gt;get_definition();</a>
<a name="12595"><span class="lineNum">   12595 </span>            :                                              ASSERT_not_null(classDefinition);</a>
<a name="12596"><span class="lineNum">   12596 </span>            : </a>
<a name="12597"><span class="lineNum">   12597 </span>            :                                              currentScope = classDefinition;</a>
<a name="12598"><span class="lineNum">   12598 </span>            : #if DEBUG_MEMBER_DATA_QUALIFICATION</a>
<a name="12599"><span class="lineNum">   12599 </span>            :                                              mfprintf(mlog [ WARN ] ) (&quot;   --- Case of SgVarRefExp: recomputed currentScope = %p = %s \n&quot;,currentScope,currentScope-&gt;class_name().c_str());</a>
<a name="12600"><span class="lineNum">   12600 </span>            : #endif</a>
<a name="12601"><span class="lineNum">   12601 </span>            :                                            }</a>
<a name="12602"><span class="lineNum">   12602 </span>            :                                           else</a>
<a name="12603"><span class="lineNum">   12603 </span>            :                                            {</a>
<a name="12604"><span class="lineNum">   12604 </span>            : #if 0</a>
<a name="12605"><span class="lineNum">   12605 </span>            :                                           // Debug this case!</a>
<a name="12606"><span class="lineNum">   12606 </span>            :                                           // I think this happends in template member functions.</a>
<a name="12607"><span class="lineNum">   12607 </span>            :                                           // I think this is happening for template classes (might be interesting to look into further).</a>
<a name="12608"><span class="lineNum">   12608 </span>            :                                              mfprintf(mlog [ WARN ] ) (&quot;   --- SgClassType without associated defining declaration \n&quot;);</a>
<a name="12609"><span class="lineNum">   12609 </span>            :                                              varRefExp-&gt;get_file_info()-&gt;display(&quot;SgClassType without associated defining declaration: debug&quot;);</a>
<a name="12610"><span class="lineNum">   12610 </span>            : #endif</a>
<a name="12611"><span class="lineNum">   12611 </span>            :                                            }</a>
<a name="12612"><span class="lineNum">   12612 </span>            :                                       }</a>
<a name="12613"><span class="lineNum">   12613 </span>            : #if 0</a>
<a name="12614"><span class="lineNum">   12614 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="12615"><span class="lineNum">   12615 </span>            :                                    ROSE_ABORT();</a>
<a name="12616"><span class="lineNum">   12616 </span>            : #endif</a>
<a name="12617"><span class="lineNum">   12617 </span>            :                                  }</a>
<a name="12618"><span class="lineNum">   12618 </span>            :                             }</a>
<a name="12619"><span class="lineNum">   12619 </span>            : </a>
<a name="12620"><span class="lineNum">   12620 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="12621"><span class="lineNum">   12621 </span>            : </a>
<a name="12622"><span class="lineNum">   12622 </span>            : #endif</a>
<a name="12623"><span class="lineNum">   12623 </span>            : </a>
<a name="12624"><span class="lineNum">   12624 </span>            : </a>
<a name="12625"><span class="lineNum">   12625 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="12626"><span class="lineNum">   12626 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;variableDeclaration = %p \n&quot;,variableDeclaration);</a>
<a name="12627"><span class="lineNum">   12627 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;currentScope        = %p = %s \n&quot;,currentScope,currentScope-&gt;class_name().c_str());</a>
<a name="12628"><span class="lineNum">   12628 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;currentStatement    = %p = %s \n&quot;,currentStatement,currentStatement-&gt;class_name().c_str());</a>
<a name="12629"><span class="lineNum">   12629 </span>            :                          variableDeclaration-&gt;get_file_info()-&gt;display(&quot;Before nameQualificationDepth()&quot;);</a>
<a name="12630"><span class="lineNum">   12630 </span>            : #endif</a>
<a name="12631"><span class="lineNum">   12631 </span><span class="lineCov">      20436 :                          int amountOfNameQualificationRequired = nameQualificationDepth(variableDeclaration,currentScope,currentStatement);</span></a>
<a name="12632"><span class="lineNum">   12632 </span>            : </a>
<a name="12633"><span class="lineNum">   12633 </span>            : #if 0</a>
<a name="12634"><span class="lineNum">   12634 </span>            :                       // DQ (2/8/2019): And then I woke up in the morning and had a better idea.</a>
<a name="12635"><span class="lineNum">   12635 </span>            : </a>
<a name="12636"><span class="lineNum">   12636 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="12637"><span class="lineNum">   12637 </span>            : </a>
<a name="12638"><span class="lineNum">   12638 </span>            :                       // DQ (2/7/2019): Adding support for SgPointerMemberType lvalue types that force rvalue name qualification (see Cxx11_tests/test2019_80.C).</a>
<a name="12639"><span class="lineNum">   12639 </span>            :                          SgPointerMemberType* pointerMemberType = inheritedAttribute.get_usingPointerToMemberType();</a>
<a name="12640"><span class="lineNum">   12640 </span>            :                          if (pointerMemberType != NULL)</a>
<a name="12641"><span class="lineNum">   12641 </span>            :                             {</a>
<a name="12642"><span class="lineNum">   12642 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="12643"><span class="lineNum">   12643 </span>            : </a>
<a name="12644"><span class="lineNum">   12644 </span>            : #if 0</a>
<a name="12645"><span class="lineNum">   12645 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;Found case of name qualification required because the lhs type is SgPointerMemberType: pointerMemberType = %p \n&quot;,pointerMemberType);</a>
<a name="12646"><span class="lineNum">   12646 </span>            : #endif</a>
<a name="12647"><span class="lineNum">   12647 </span>            :                               amountOfNameQualificationRequired++;</a>
<a name="12648"><span class="lineNum">   12648 </span>            : #if 0</a>
<a name="12649"><span class="lineNum">   12649 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="12650"><span class="lineNum">   12650 </span>            :                               ROSE_ABORT();</a>
<a name="12651"><span class="lineNum">   12651 </span>            : #endif</a>
<a name="12652"><span class="lineNum">   12652 </span>            :                             }</a>
<a name="12653"><span class="lineNum">   12653 </span>            :                            else</a>
<a name="12654"><span class="lineNum">   12654 </span>            :                             {</a>
<a name="12655"><span class="lineNum">   12655 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="12656"><span class="lineNum">   12656 </span>            : </a>
<a name="12657"><span class="lineNum">   12657 </span>            :                            // DQ (2/7/2019): Add an extra level of name qualification if this is pointer-to-member type induced.</a>
<a name="12658"><span class="lineNum">   12658 </span>            :                               if (nameQualificationInducedFromPointerMemberType == true)</a>
<a name="12659"><span class="lineNum">   12659 </span>            :                                  {</a>
<a name="12660"><span class="lineNum">   12660 </span>            : #if 0</a>
<a name="12661"><span class="lineNum">   12661 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;Found case of name qualification required because the function parameter type is SgPointerMemberType \n&quot;);</a>
<a name="12662"><span class="lineNum">   12662 </span>            : #endif</a>
<a name="12663"><span class="lineNum">   12663 </span>            :                                    amountOfNameQualificationRequired++;</a>
<a name="12664"><span class="lineNum">   12664 </span>            :                                  }</a>
<a name="12665"><span class="lineNum">   12665 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="12666"><span class="lineNum">   12666 </span>            : </a>
<a name="12667"><span class="lineNum">   12667 </span>            :                            }</a>
<a name="12668"><span class="lineNum">   12668 </span>            : #else</a>
<a name="12669"><span class="lineNum">   12669 </span>            :                       // DQ (2/7/2019): Add an extra level of name qualification if this is pointer-to-member type induced.</a>
<a name="12670"><span class="lineNum">   12670 </span><span class="lineCov">      20436 :                          if (nameQualificationInducedFromPointerMemberType == true)</span></a>
<a name="12671"><span class="lineNum">   12671 </span>            :                             {</a>
<a name="12672"><span class="lineNum">   12672 </span>            :                            // DQ (2/8/2019): Only add name qualification if not present (else we can get over qualification</a>
<a name="12673"><span class="lineNum">   12673 </span>            :                            // that can show up as pointer names in the name qualification, see Cxx11_tests/test2019_86.C).</a>
<a name="12674"><span class="lineNum">   12674 </span><span class="lineNoCov">          0 :                               if (amountOfNameQualificationRequired == 0)</span></a>
<a name="12675"><span class="lineNum">   12675 </span>            :                                  {</a>
<a name="12676"><span class="lineNum">   12676 </span>            :                                 // DQ (3/30/2019): Experiment with commenting this out!</a>
<a name="12677"><span class="lineNum">   12677 </span><span class="lineNoCov">          0 :                                    amountOfNameQualificationRequired++;</span></a>
<a name="12678"><span class="lineNum">   12678 </span>            :                                  }</a>
<a name="12679"><span class="lineNum">   12679 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="12680"><span class="lineNum">   12680 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;Found case of name qualification required because the variable is associated with SgPointerMemberType: amountOfNameQualificationRequired = %d \n&quot;,amountOfNameQualificationRequired);</a>
<a name="12681"><span class="lineNum">   12681 </span>            : #endif</a>
<a name="12682"><span class="lineNum">   12682 </span>            :                             }</a>
<a name="12683"><span class="lineNum">   12683 </span>            : #endif</a>
<a name="12684"><span class="lineNum">   12684 </span>            : </a>
<a name="12685"><span class="lineNum">   12685 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="12686"><span class="lineNum">   12686 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;SgVarRefExp's SgDeclarationStatement: amountOfNameQualificationRequired = %d \n&quot;,amountOfNameQualificationRequired);</a>
<a name="12687"><span class="lineNum">   12687 </span>            : #endif</a>
<a name="12688"><span class="lineNum">   12688 </span><span class="lineCov">      20436 :                          setNameQualification(varRefExp,variableDeclaration,amountOfNameQualificationRequired);</span></a>
<a name="12689"><span class="lineNum">   12689 </span>            : </a>
<a name="12690"><span class="lineNum">   12690 </span>            :                       // DQ (12/23/2015): If there are multiple symbols with the same name then we require the name qualification.</a>
<a name="12691"><span class="lineNum">   12691 </span>            :                       // See test2015_140.C for an example.</a>
<a name="12692"><span class="lineNum">   12692 </span><span class="lineCov">      40872 :                          SgName name = initializedName-&gt;get_name().str();</span></a>
<a name="12693"><span class="lineNum">   12693 </span>            : </a>
<a name="12694"><span class="lineNum">   12694 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="12695"><span class="lineNum">   12695 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;SgVarRefExp's SgDeclarationStatement: initializedName-&gt;get_name() = %s \n&quot;,name.str());</a>
<a name="12696"><span class="lineNum">   12696 </span>            : #endif</a>
<a name="12697"><span class="lineNum">   12697 </span>            : </a>
<a name="12698"><span class="lineNum">   12698 </span>            :                       // size_t numberOfAliasSymbols = currentScope-&gt;count_alias_symbol(name);</a>
<a name="12699"><span class="lineNum">   12699 </span><span class="lineCov">      20436 :                          int numberOfAliasSymbols = currentScope-&gt;count_alias_symbol(name);</span></a>
<a name="12700"><span class="lineNum">   12700 </span>            :                       // if (numberOfAliasSymbols &gt; 1)</a>
<a name="12701"><span class="lineNum">   12701 </span>            : </a>
<a name="12702"><span class="lineNum">   12702 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="12703"><span class="lineNum">   12703 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;SgVarRefExp's SgDeclarationStatement: numberOfAliasSymbols              = %d \n&quot;,numberOfAliasSymbols);</a>
<a name="12704"><span class="lineNum">   12704 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;SgVarRefExp's SgDeclarationStatement: amountOfNameQualificationRequired = %d \n&quot;,amountOfNameQualificationRequired);</a>
<a name="12705"><span class="lineNum">   12705 </span>            : #endif</a>
<a name="12706"><span class="lineNum">   12706 </span>            : </a>
<a name="12707"><span class="lineNum">   12707 </span><span class="lineCov">      20436 :                          if (numberOfAliasSymbols &gt; 1 &amp;&amp; amountOfNameQualificationRequired == 0)</span></a>
<a name="12708"><span class="lineNum">   12708 </span>            :                             {</a>
<a name="12709"><span class="lineNum">   12709 </span>            :                            // DQ (3/15/2017): Added support to use message streams.</a>
<a name="12710"><span class="lineNum">   12710 </span><span class="lineNoCov">          0 :                               mfprintf(mlog [ WARN ] ) (&quot;WARNING: name qualification can be required when there are multiple base classes with the same referenced variable via SgAliasSymbol \n&quot;);</span></a>
<a name="12711"><span class="lineNum">   12711 </span>            :                             }</a>
<a name="12712"><span class="lineNum">   12712 </span>            :                            else</a>
<a name="12713"><span class="lineNum">   12713 </span>            :                             {</a>
<a name="12714"><span class="lineNum">   12714 </span>            :                            // DQ (12/23/2015): Note that this is not a count of the SgVariableSymbol IR nodes.</a>
<a name="12715"><span class="lineNum">   12715 </span>            :                            // size_t numberOfSymbolsWithSameName = currentScope-&gt;count_symbol(name);</a>
<a name="12716"><span class="lineNum">   12716 </span><span class="lineCov">      20436 :                               int numberOfSymbolsWithSameName = (int)currentScope-&gt;count_symbol(name);</span></a>
<a name="12717"><span class="lineNum">   12717 </span>            : </a>
<a name="12718"><span class="lineNum">   12718 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="12719"><span class="lineNum">   12719 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;SgVarRefExp's SgDeclarationStatement: numberOfSymbolsWithSameName       = %d \n&quot;,numberOfSymbolsWithSameName);</a>
<a name="12720"><span class="lineNum">   12720 </span>            : #endif</a>
<a name="12721"><span class="lineNum">   12721 </span>            : </a>
<a name="12722"><span class="lineNum">   12722 </span>            :                            // if (numberOfSymbolsWithSameName &gt; 1)</a>
<a name="12723"><span class="lineNum">   12723 </span>            :                            // if (numberOfSymbolsWithSameName &gt; 1 &amp;&amp; amountOfNameQualificationRequired == 0)</a>
<a name="12724"><span class="lineNum">   12724 </span><span class="lineCov">      20436 :                               if ((numberOfSymbolsWithSameName - numberOfAliasSymbols) &gt; 1 &amp;&amp; amountOfNameQualificationRequired == 0)</span></a>
<a name="12725"><span class="lineNum">   12725 </span>            :                                  {</a>
<a name="12726"><span class="lineNum">   12726 </span>            :                                 // DQ (3/15/2017): Added support to use message streams.</a>
<a name="12727"><span class="lineNum">   12727 </span><span class="lineNoCov">          0 :                                    mfprintf(mlog [ WARN ] ) (&quot;WARNING: name qualification can be required when there are multiple base classes with the same referenced variable via SgVariableSymbol \n&quot;);</span></a>
<a name="12728"><span class="lineNum">   12728 </span>            : </a>
<a name="12729"><span class="lineNum">   12729 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="12730"><span class="lineNum">   12730 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;WARNING: name qualification can be required when there are multiple base classes with the same referenced variable via SgVariableSymbol \n&quot;);</a>
<a name="12731"><span class="lineNum">   12731 </span>            : #endif</a>
<a name="12732"><span class="lineNum">   12732 </span>            :                                  }</a>
<a name="12733"><span class="lineNum">   12733 </span>            :                            // ROSE_ASSERT(numberOfSymbolsWithSameName &lt; 2);</a>
<a name="12734"><span class="lineNum">   12734 </span>            :                            // if (numberOfSymbolsWithSameName &gt;= 2 &amp;&amp; amountOfNameQualificationRequired == 0)</a>
<a name="12735"><span class="lineNum">   12735 </span><span class="lineCov">      20436 :                               if ((numberOfSymbolsWithSameName - numberOfAliasSymbols) &gt; 1 &amp;&amp; amountOfNameQualificationRequired == 0)</span></a>
<a name="12736"><span class="lineNum">   12736 </span>            :                                  {</a>
<a name="12737"><span class="lineNum">   12737 </span>            :                                 // DQ (3/15/2017): Added support to use message streams.</a>
<a name="12738"><span class="lineNum">   12738 </span><span class="lineNoCov">          0 :                                    mfprintf(mlog [ WARN ] ) (&quot;   --- numberOfSymbolsWithSameName       = %d \n&quot;,numberOfSymbolsWithSameName);</span></a>
<a name="12739"><span class="lineNum">   12739 </span><span class="lineNoCov">          0 :                                    mfprintf(mlog [ WARN ] ) (&quot;   --- amountOfNameQualificationRequired = %d \n&quot;,amountOfNameQualificationRequired);</span></a>
<a name="12740"><span class="lineNum">   12740 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="12741"><span class="lineNum">   12741 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;   --- numberOfSymbolsWithSameName       = %d \n&quot;,numberOfSymbolsWithSameName);</a>
<a name="12742"><span class="lineNum">   12742 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;   --- amountOfNameQualificationRequired = %d \n&quot;,amountOfNameQualificationRequired);</a>
<a name="12743"><span class="lineNum">   12743 </span>            : #endif</a>
<a name="12744"><span class="lineNum">   12744 </span>            :                                  }</a>
<a name="12745"><span class="lineNum">   12745 </span>            :                             // ROSE_ASSERT(numberOfSymbolsWithSameName &lt; 2 || amountOfNameQualificationRequired &gt; 0);</a>
<a name="12746"><span class="lineNum">   12746 </span>            : </a>
<a name="12747"><span class="lineNum">   12747 </span>            :                             // DQ (12/23/2015): This fails for the LULESH-OMP tests, I think I need to relax this (it is a new assection).</a>
<a name="12748"><span class="lineNum">   12748 </span>            :                             // It might be that we need to also check that these are all SgVariableSymbol (since there could be different</a>
<a name="12749"><span class="lineNum">   12749 </span>            :                             // kinds of SgSymbol (which would have to be allowed)).</a>
<a name="12750"><span class="lineNum">   12750 </span>            :                             // ROSE_ASSERT((numberOfSymbolsWithSameName - numberOfAliasSymbols) &lt;= 1 || amountOfNameQualificationRequired &gt; 0);</a>
<a name="12751"><span class="lineNum">   12751 </span>            :                             }</a>
<a name="12752"><span class="lineNum">   12752 </span>            :                       // ROSE_ASSERT(numberOfAliasSymbols &lt; 2);</a>
<a name="12753"><span class="lineNum">   12753 </span><span class="lineCov">      20436 :                          ROSE_ASSERT(numberOfAliasSymbols &lt;= 1 || amountOfNameQualificationRequired &gt; 0);</span></a>
<a name="12754"><span class="lineNum">   12754 </span>            : </a>
<a name="12755"><span class="lineNum">   12755 </span>            : #if 0</a>
<a name="12756"><span class="lineNum">   12756 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;Test 1.25: Processing varRefExp = %p: Exiting as a test! \n&quot;,varRefExp);</a>
<a name="12757"><span class="lineNum">   12757 </span>            :                          ROSE_ABORT();</a>
<a name="12758"><span class="lineNum">   12758 </span>            : #endif</a>
<a name="12759"><span class="lineNum">   12759 </span>            :                        }</a>
<a name="12760"><span class="lineNum">   12760 </span>            : </a>
<a name="12761"><span class="lineNum">   12761 </span>            : #if 0</a>
<a name="12762"><span class="lineNum">   12762 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Test 1.3: Processing varRefExp = %p: Exiting as a test! \n&quot;,varRefExp);</a>
<a name="12763"><span class="lineNum">   12763 </span>            :                     ROSE_ABORT();</a>
<a name="12764"><span class="lineNum">   12764 </span>            : #endif</a>
<a name="12765"><span class="lineNum">   12765 </span>            :                  // End of new test...</a>
<a name="12766"><span class="lineNum">   12766 </span>            :                   }</a>
<a name="12767"><span class="lineNum">   12767 </span>            :                  else</a>
<a name="12768"><span class="lineNum">   12768 </span>            :                   {</a>
<a name="12769"><span class="lineNum">   12769 </span>            :                  // DQ (7/23/2011): This case happens when the SgVarRefExp can not be associated with a statement.</a>
<a name="12770"><span class="lineNum">   12770 </span>            :                  // I think this only happens when a constant variable is used in an array index of an array type.</a>
<a name="12771"><span class="lineNum">   12771 </span>            : #if 0</a>
<a name="12772"><span class="lineNum">   12772 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Case of TransformationSupport::getStatement(varRefExp) == NULL explictlySpecifiedCurrentScope = %p \n&quot;,explictlySpecifiedCurrentScope);</a>
<a name="12773"><span class="lineNum">   12773 </span>            : #endif</a>
<a name="12774"><span class="lineNum">   12774 </span>            :                  // DQ (7/24/2011): This fails for the tests/nonsmoke/functional/CompileTests/OpenMP_tests/objectLastprivate.cpp test code.</a>
<a name="12775"><span class="lineNum">   12775 </span>            :                  // ASSERT_not_null(explictlySpecifiedCurrentScope);</a>
<a name="12776"><span class="lineNum">   12776 </span><span class="lineCov">        111 :                     if (explictlySpecifiedCurrentScope != NULL)</span></a>
<a name="12777"><span class="lineNum">   12777 </span>            :                        {</a>
<a name="12778"><span class="lineNum">   12778 </span>            :                       // DQ (4/19/2019): Now that we (optionally) also pass in the explictlySpecifiedCurrentStatement, we might want to use it directly.</a>
<a name="12779"><span class="lineNum">   12779 </span>            : #if 0</a>
<a name="12780"><span class="lineNum">   12780 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;case of SgVarRefExp: Using explictlySpecifiedCurrentScope for the value of currentStatement: need to check this! \n&quot;);</a>
<a name="12781"><span class="lineNum">   12781 </span>            : #endif</a>
<a name="12782"><span class="lineNum">   12782 </span><span class="lineCov">        111 :                          currentStatement = explictlySpecifiedCurrentScope;</span></a>
<a name="12783"><span class="lineNum">   12783 </span>            : </a>
<a name="12784"><span class="lineNum">   12784 </span><span class="lineCov">        111 :                          SgVariableSymbol* variableSymbol = varRefExp-&gt;get_symbol();</span></a>
<a name="12785"><span class="lineNum">   12785 </span><span class="lineCov">        111 :                          ASSERT_not_null(variableSymbol);</span></a>
<a name="12786"><span class="lineNum">   12786 </span>            : </a>
<a name="12787"><span class="lineNum">   12787 </span><span class="lineCov">        111 :                          SgInitializedName* initializedName = variableSymbol-&gt;get_declaration();</span></a>
<a name="12788"><span class="lineNum">   12788 </span><span class="lineCov">        111 :                          ASSERT_not_null(initializedName);</span></a>
<a name="12789"><span class="lineNum">   12789 </span>            : </a>
<a name="12790"><span class="lineNum">   12790 </span><span class="lineCov">        111 :                          SgNode * parent = initializedName-&gt;get_parent();</span></a>
<a name="12791"><span class="lineNum">   12791 </span>            : </a>
<a name="12792"><span class="lineNum">   12792 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="12793"><span class="lineNum">   12793 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;In case SgVarRefExp: (currentStatement == NULL) Calling nameQualificationDepth() variableDeclaration = %p initializedName-&gt;get_parent() = %p = %s \n&quot;, variableDeclaration, parent, parent ? parent-&gt;class_name().c_str() : &quot;&quot;);</a>
<a name="12794"><span class="lineNum">   12794 </span>            : #endif</a>
<a name="12795"><span class="lineNum">   12795 </span>            : </a>
<a name="12796"><span class="lineNum">   12796 </span><span class="lineCov">        111 :                          SgVariableDeclaration* variableDeclaration = isSgVariableDeclaration(parent);</span></a>
<a name="12797"><span class="lineNum">   12797 </span><span class="lineCov">        111 :                          SgDeclarationScope * decl_scope = isSgDeclarationScope(parent);</span></a>
<a name="12798"><span class="lineNum">   12798 </span><span class="lineCov">        111 :                          if (variableDeclaration != NULL) {</span></a>
<a name="12799"><span class="lineNum">   12799 </span><span class="lineCov">          1 :                            int amountOfNameQualificationRequired = nameQualificationDepth(variableDeclaration,explictlySpecifiedCurrentScope,currentStatement);</span></a>
<a name="12800"><span class="lineNum">   12800 </span><span class="lineCov">          1 :                            setNameQualification(varRefExp,variableDeclaration,amountOfNameQualificationRequired);</span></a>
<a name="12801"><span class="lineNum">   12801 </span><span class="lineCov">        110 :                          } else if (decl_scope != NULL) {</span></a>
<a name="12802"><span class="lineNum">   12802 </span>            :                            // NOP that is a nontype template parameter</a>
<a name="12803"><span class="lineNum">   12803 </span>            :                          } else {</a>
<a name="12804"><span class="lineNum">   12804 </span><span class="lineCov">        110 :                            SgFunctionParameterList* functionParameterList = isSgFunctionParameterList(parent);</span></a>
<a name="12805"><span class="lineNum">   12805 </span><span class="lineCov">        110 :                            SgTemplateClassDefinition * tpldef = isSgTemplateClassDefinition(parent);</span></a>
<a name="12806"><span class="lineNum">   12806 </span><span class="lineCov">        110 :                            SgTemplateParameter* tplParam = isSgTemplateParameter(parent);</span></a>
<a name="12807"><span class="lineNum">   12807 </span><span class="lineCov">        110 :                            SgTemplateInstantiationDefn * templateInstantiationDefn = isSgTemplateInstantiationDefn(parent);</span></a>
<a name="12808"><span class="lineNum">   12808 </span><span class="lineCov">        110 :                            SgEnumDeclaration * enumDecl = isSgEnumDeclaration(parent);</span></a>
<a name="12809"><span class="lineNum">   12809 </span>            : </a>
<a name="12810"><span class="lineNum">   12810 </span><span class="lineCov">        110 :                            int amountOfNameQualificationRequired = nameQualificationDepth(initializedName,explictlySpecifiedCurrentScope,currentStatement);</span></a>
<a name="12811"><span class="lineNum">   12811 </span><span class="lineCov">        110 :                            if (functionParameterList != NULL) {</span></a>
<a name="12812"><span class="lineNum">   12812 </span><span class="lineNoCov">          0 :                              setNameQualification(varRefExp,functionParameterList,amountOfNameQualificationRequired);</span></a>
<a name="12813"><span class="lineNum">   12813 </span><span class="lineCov">        110 :                            } else if (tpldef != NULL) {</span></a>
<a name="12814"><span class="lineNum">   12814 </span><span class="lineNoCov">          0 :                              mfprintf(mlog [ WARN ] )(&quot;WARNING: In NameQualificationTraversal::evaluateInheritedAttribute: Found SgInitializedName whose parent is a template class definition. It does not sound right!!!\n&quot;);</span></a>
<a name="12815"><span class="lineNum">   12815 </span><span class="lineNoCov">          0 :                              ASSERT_not_null(tpldef-&gt;get_parent());</span></a>
<a name="12816"><span class="lineNum">   12816 </span><span class="lineNoCov">          0 :                              SgDeclarationStatement * tpldecl = isSgDeclarationStatement(tpldef-&gt;get_parent());</span></a>
<a name="12817"><span class="lineNum">   12817 </span><span class="lineNoCov">          0 :                              ASSERT_not_null(tpldecl);</span></a>
<a name="12818"><span class="lineNum">   12818 </span><span class="lineNoCov">          0 :                              ROSE_ASSERT(isSgTemplateClassDeclaration(tpldecl));</span></a>
<a name="12819"><span class="lineNum">   12819 </span><span class="lineNoCov">          0 :                              setNameQualification(varRefExp,tpldecl,amountOfNameQualificationRequired);</span></a>
<a name="12820"><span class="lineNum">   12820 </span><span class="lineCov">        110 :                            } else if (templateInstantiationDefn != NULL) {</span></a>
<a name="12821"><span class="lineNum">   12821 </span><span class="lineNoCov">          0 :                              setNameQualification(varRefExp,templateInstantiationDefn-&gt;get_declaration(),amountOfNameQualificationRequired);</span></a>
<a name="12822"><span class="lineNum">   12822 </span><span class="lineCov">        110 :                            } else if (tplParam != NULL) {</span></a>
<a name="12823"><span class="lineNum">   12823 </span>            : #if 0</a>
<a name="12824"><span class="lineNum">   12824 </span>            :                              mfprintf(mlog [ WARN ] )(&quot;tplParam = %p (%s)\n&quot;, tplParam, tplParam ? tplParam-&gt;class_name().c_str() : &quot;&quot;);</a>
<a name="12825"><span class="lineNum">   12825 </span>            : #endif</a>
<a name="12826"><span class="lineNum">   12826 </span><span class="lineCov">        110 :                              ASSERT_not_null(tplParam-&gt;get_parent());</span></a>
<a name="12827"><span class="lineNum">   12827 </span><span class="lineCov">        110 :                              SgDeclarationStatement * tpldecl = isSgDeclarationStatement(tplParam-&gt;get_parent());</span></a>
<a name="12828"><span class="lineNum">   12828 </span><span class="lineCov">        110 :                              ASSERT_not_null(tpldecl);</span></a>
<a name="12829"><span class="lineNum">   12829 </span>            : #if 0</a>
<a name="12830"><span class="lineNum">   12830 </span>            :                              mfprintf(mlog [ WARN ] )(&quot;tpldecl = %p (%s)\n&quot;, tpldecl, tpldecl ? tpldecl-&gt;class_name().c_str() : &quot;&quot;);</a>
<a name="12831"><span class="lineNum">   12831 </span>            : #endif</a>
<a name="12832"><span class="lineNum">   12832 </span><span class="lineCov">        110 :                              ROSE_ASSERT(</span></a>
<a name="12833"><span class="lineNum">   12833 </span>            :                                  isSgTemplateFunctionDeclaration(tpldecl) ||</a>
<a name="12834"><span class="lineNum">   12834 </span>            :                                  isSgTemplateMemberFunctionDeclaration(tpldecl) ||</a>
<a name="12835"><span class="lineNum">   12835 </span>            :                                  isSgTemplateClassDeclaration(tpldecl) ||</a>
<a name="12836"><span class="lineNum">   12836 </span>            :                                  isSgTemplateTypedefDeclaration(tpldecl) ||</a>
<a name="12837"><span class="lineNum">   12837 </span>            :                                  isSgTemplateVariableDeclaration(tpldecl) ||</a>
<a name="12838"><span class="lineNum">   12838 </span>            :                                  isSgNonrealDecl(tpldecl)</a>
<a name="12839"><span class="lineNum">   12839 </span>            :                              );</a>
<a name="12840"><span class="lineNum">   12840 </span><span class="lineCov">        110 :                              setNameQualification(varRefExp,tpldecl,amountOfNameQualificationRequired);</span></a>
<a name="12841"><span class="lineNum">   12841 </span><span class="lineNoCov">          0 :                            } else if (enumDecl != NULL) {</span></a>
<a name="12842"><span class="lineNum">   12842 </span><span class="lineNoCov">          0 :                              setNameQualification(varRefExp, enumDecl, amountOfNameQualificationRequired);</span></a>
<a name="12843"><span class="lineNum">   12843 </span>            : //                             setNameQualification(varRefExp, isSgScopeStatement(enumDecl-&gt;get_parent()), amountOfNameQualificationRequired);</a>
<a name="12844"><span class="lineNum">   12844 </span>            :                            } else {</a>
<a name="12845"><span class="lineNum">   12845 </span>            :                           // mfprintf(mlog [ WARN ] )(&quot;ERROR: Unexpected parent for SgInitializedName: parent = %p (%s)\n&quot;, parent, parent ? parent-&gt;class_name().c_str() : &quot;&quot;);</a>
<a name="12846"><span class="lineNum">   12846 </span><span class="lineNoCov">          0 :                              printf(&quot;ERROR: Unexpected parent for SgInitializedName: parent = %p (%s)\n&quot;, parent, parent ? parent-&gt;class_name().c_str() : &quot;&quot;);</span></a>
<a name="12847"><span class="lineNum">   12847 </span><span class="lineNoCov">          0 :                              ROSE_ABORT();</span></a>
<a name="12848"><span class="lineNum">   12848 </span>            :                            }</a>
<a name="12849"><span class="lineNum">   12849 </span>            :                          }</a>
<a name="12850"><span class="lineNum">   12850 </span>            :                        }</a>
<a name="12851"><span class="lineNum">   12851 </span><span class="lineNoCov">          0 :                       else if (variableDeclaration != NULL)</span></a>
<a name="12852"><span class="lineNum">   12852 </span>            :                        {</a>
<a name="12853"><span class="lineNum">   12853 </span><span class="lineNoCov">          0 :                          int amountOfNameQualificationRequired = nameQualificationDepth(variableDeclaration,explictlySpecifiedCurrentScope,currentStatement);</span></a>
<a name="12854"><span class="lineNum">   12854 </span><span class="lineNoCov">          0 :                          setNameQualification(varRefExp,variableDeclaration,amountOfNameQualificationRequired);</span></a>
<a name="12855"><span class="lineNum">   12855 </span>            :                        }</a>
<a name="12856"><span class="lineNum">   12856 </span>            :                       else</a>
<a name="12857"><span class="lineNum">   12857 </span>            :                        {</a>
<a name="12858"><span class="lineNum">   12858 </span>            :                        // TV (09/13/2018): in ROSE/tutorial/: ./loopOptimization --edg:no_warnings -w -bk1 -fs0 -c /data1/roseenv/src/tmp-merge/tutorial/inputCode_LoopOptimization_blocking.C</a>
<a name="12859"><span class="lineNum">   12859 </span><span class="lineNoCov">          0 :                          mfprintf(mlog [ WARN ] )(&quot;WARNING: Unexpected conditions in NameQualificationTraversal::evaluateInheritedAttribute.\n&quot;);</span></a>
<a name="12860"><span class="lineNum">   12860 </span>            : //                       ROSE_ASSERT(false);</a>
<a name="12861"><span class="lineNum">   12861 </span>            :                        }</a>
<a name="12862"><span class="lineNum">   12862 </span>            : </a>
<a name="12863"><span class="lineNum">   12863 </span>            : #if 0</a>
<a name="12864"><span class="lineNum">   12864 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Test 1.5: Processing varRefExp = %p: Exiting as a test! \n&quot;,varRefExp);</a>
<a name="12865"><span class="lineNum">   12865 </span>            :                     ROSE_ABORT();</a>
<a name="12866"><span class="lineNum">   12866 </span>            : #endif</a>
<a name="12867"><span class="lineNum">   12867 </span>            :                   }</a>
<a name="12868"><span class="lineNum">   12868 </span>            : </a>
<a name="12869"><span class="lineNum">   12869 </span>            : #if 0</a>
<a name="12870"><span class="lineNum">   12870 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Test 1.7: Processing varRefExp = %p: Exiting as a test! \n&quot;,varRefExp);</a>
<a name="12871"><span class="lineNum">   12871 </span>            :                ROSE_ABORT();</a>
<a name="12872"><span class="lineNum">   12872 </span>            : #endif</a>
<a name="12873"><span class="lineNum">   12873 </span>            :             // DQ (2/16/2019): End of false branch for: if (isDataMemberReference == false)</a>
<a name="12874"><span class="lineNum">   12874 </span>            :              }</a>
<a name="12875"><span class="lineNum">   12875 </span>            :             else</a>
<a name="12876"><span class="lineNum">   12876 </span>            :              {</a>
<a name="12877"><span class="lineNum">   12877 </span>            : #if 0</a>
<a name="12878"><span class="lineNum">   12878 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Test 2: Processing varRefExp = %p: Exiting as a test! \n&quot;,varRefExp);</a>
<a name="12879"><span class="lineNum">   12879 </span>            :                ROSE_ABORT();</a>
<a name="12880"><span class="lineNum">   12880 </span>            : #endif</a>
<a name="12881"><span class="lineNum">   12881 </span>            : #if 0</a>
<a name="12882"><span class="lineNum">   12882 </span>            :             // DQ (7/24/3030): This variable declaration hides an outer declaration using the same variable name.</a>
<a name="12883"><span class="lineNum">   12883 </span>            :                SgVariableDeclaration* variableDeclaration = isSgVariableDeclaration(initializedName-&gt;get_parent());</a>
<a name="12884"><span class="lineNum">   12884 </span>            : </a>
<a name="12885"><span class="lineNum">   12885 </span>            :             // DQ (7/24/2020): Debugging Cxx20_tests/test2020_122.C and Cxx_tests/test2020_14.C.</a>
<a name="12886"><span class="lineNum">   12886 </span>            :                bool inDesignatedInitializer = false;</a>
<a name="12887"><span class="lineNum">   12887 </span>            :                if (variableDeclaration == variableDeclaration-&gt;get_definingDeclaration())</a>
<a name="12888"><span class="lineNum">   12888 </span>            :                   {</a>
<a name="12889"><span class="lineNum">   12889 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) &amp;&amp; 0</a>
<a name="12890"><span class="lineNum">   12890 </span>            :                     printf (&quot;SgVarRefExp is not in a defining SgVariableDeclaration: might be in a SgDesignatedInitializer \n&quot;);</a>
<a name="12891"><span class="lineNum">   12891 </span>            :                     SgExprListExp* exprListExp = isSgExprListExp(varRefExp-&gt;get_parent());</a>
<a name="12892"><span class="lineNum">   12892 </span>            :                     if (exprListExp != NULL)</a>
<a name="12893"><span class="lineNum">   12893 </span>            :                        {</a>
<a name="12894"><span class="lineNum">   12894 </span>            :                          SgDesignatedInitializer* designatedInitializer = isSgDesignatedInitializer(exprListExp-&gt;get_parent());</a>
<a name="12895"><span class="lineNum">   12895 </span>            :                          if (designatedInitializer != NULL)</a>
<a name="12896"><span class="lineNum">   12896 </span>            :                             {</a>
<a name="12897"><span class="lineNum">   12897 </span>            :                               inDesignatedInitializer = true;</a>
<a name="12898"><span class="lineNum">   12898 </span>            : </a>
<a name="12899"><span class="lineNum">   12899 </span>            :                               printf (&quot;Found case of SgVarRefExp in SgDesignatedInitializer (no name qualification is required (allowed)) \n&quot;);</a>
<a name="12900"><span class="lineNum">   12900 </span>            :                               ROSE_ABORT();</a>
<a name="12901"><span class="lineNum">   12901 </span>            :                             }</a>
<a name="12902"><span class="lineNum">   12902 </span>            :                        }</a>
<a name="12903"><span class="lineNum">   12903 </span>            : #endif</a>
<a name="12904"><span class="lineNum">   12904 </span>            :                  // variableDeclaration = NULL;</a>
<a name="12905"><span class="lineNum">   12905 </span>            :                   }</a>
<a name="12906"><span class="lineNum">   12906 </span>            : #endif</a>
<a name="12907"><span class="lineNum">   12907 </span>            :             // DQ (1/14/2020): To support Cxx11_tests/test2020_50.C, a variable in an un-named union we could just argue</a>
<a name="12908"><span class="lineNum">   12908 </span>            :             // that if the union is un-named then the variable declaration should not be considered to be a member</a>
<a name="12909"><span class="lineNum">   12909 </span>            :             // (then the name qualification could proceed using the branch above).</a>
<a name="12910"><span class="lineNum">   12910 </span>            : #if 0</a>
<a name="12911"><span class="lineNum">   12911 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;For the case of Cxx11_tests/test2020_50.C, conside the variable declaration in the un-named union to NOT be a data member (process as isDataMemberReference == false) \n&quot;);</a>
<a name="12912"><span class="lineNum">   12912 </span>            : #endif</a>
<a name="12913"><span class="lineNum">   12913 </span>            : #if 0</a>
<a name="12914"><span class="lineNum">   12914 </span>            :             // DQ (1/14/2020): Added support for variableRefExp from un-named class (or union), see Cxx11_tests/test2020_50.C.</a>
<a name="12915"><span class="lineNum">   12915 </span>            :             // (isDataMemberReference == true &amp;&amp; isAddressTaken == false), example in Cxx11_tests/test2020_50.C.</a>
<a name="12916"><span class="lineNum">   12916 </span>            : #if 0</a>
<a name="12917"><span class="lineNum">   12917 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Case of SgVarRefExp: isDataMemberReference = %s isAddressTaken = %s \n&quot;,isDataMemberReference ? &quot;true&quot; : &quot;false&quot;,isAddressTaken ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="12918"><span class="lineNum">   12918 </span>            : #endif</a>
<a name="12919"><span class="lineNum">   12919 </span>            :                if (currentStatement != NULL)</a>
<a name="12920"><span class="lineNum">   12920 </span>            :                   {</a>
<a name="12921"><span class="lineNum">   12921 </span>            :                  // DQ (5/30/2011): Handle the case of test2011_58.C (index declaration in for loop construct).</a>
<a name="12922"><span class="lineNum">   12922 </span>            :                  // SgScopeStatement* currentScope = currentStatement-&gt;get_scope();</a>
<a name="12923"><span class="lineNum">   12923 </span>            :                     SgScopeStatement* currentScope = isSgScopeStatement(currentStatement);</a>
<a name="12924"><span class="lineNum">   12924 </span>            :                     if (currentScope == NULL)</a>
<a name="12925"><span class="lineNum">   12925 </span>            :                        {</a>
<a name="12926"><span class="lineNum">   12926 </span>            :                          currentScope = currentStatement-&gt;get_scope();</a>
<a name="12927"><span class="lineNum">   12927 </span>            :                        }</a>
<a name="12928"><span class="lineNum">   12928 </span>            :                     ASSERT_not_null(currentScope);</a>
<a name="12929"><span class="lineNum">   12929 </span>            : </a>
<a name="12930"><span class="lineNum">   12930 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="12931"><span class="lineNum">   12931 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Case SgVarRefExp: (could this be in an array type?) currentScope = %p = %s \n&quot;,currentScope,currentScope-&gt;class_name().c_str());</a>
<a name="12932"><span class="lineNum">   12932 </span>            : #endif</a>
<a name="12933"><span class="lineNum">   12933 </span>            :                     SgVariableSymbol* variableSymbol = varRefExp-&gt;get_symbol();</a>
<a name="12934"><span class="lineNum">   12934 </span>            :                     ASSERT_not_null(variableSymbol);</a>
<a name="12935"><span class="lineNum">   12935 </span>            :                     SgInitializedName* initializedName = variableSymbol-&gt;get_declaration();</a>
<a name="12936"><span class="lineNum">   12936 </span>            :                     ASSERT_not_null(initializedName);</a>
<a name="12937"><span class="lineNum">   12937 </span>            : </a>
<a name="12938"><span class="lineNum">   12938 </span>            :                  // DQ (7/18/2012): Added test as part of debugging test2011_75.C.</a>
<a name="12939"><span class="lineNum">   12939 </span>            :                     ASSERT_not_null(initializedName-&gt;get_parent());</a>
<a name="12940"><span class="lineNum">   12940 </span>            : </a>
<a name="12941"><span class="lineNum">   12941 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="12942"><span class="lineNum">   12942 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Case of SgVarRefExp: varRefExp = %p : initializedName name = %s parent = %p = %s \n&quot;,</a>
<a name="12943"><span class="lineNum">   12943 </span>            :                          varRefExp,initializedName-&gt;get_name().str(),initializedName-&gt;get_parent(),initializedName-&gt;get_parent()-&gt;class_name().c_str());</a>
<a name="12944"><span class="lineNum">   12944 </span>            : #endif</a>
<a name="12945"><span class="lineNum">   12945 </span>            : </a>
<a name="12946"><span class="lineNum">   12946 </span>            :                  // SgNode* parent = initializedName-&gt;get_parent();</a>
<a name="12947"><span class="lineNum">   12947 </span>            :                  // mfprintf(mlog [ WARN ] ) (&quot;parent = %p = %s \n&quot;,parent,parent-&gt;class_name().c_str());</a>
<a name="12948"><span class="lineNum">   12948 </span>            : </a>
<a name="12949"><span class="lineNum">   12949 </span>            :                     SgVariableDeclaration* variableDeclaration = isSgVariableDeclaration(initializedName-&gt;get_parent());</a>
<a name="12950"><span class="lineNum">   12950 </span>            :                     ASSERT_not_null(variableDeclaration);</a>
<a name="12951"><span class="lineNum">   12951 </span>            : </a>
<a name="12952"><span class="lineNum">   12952 </span>            :                     int amountOfNameQualificationRequired = nameQualificationDepth(variableDeclaration,currentScope,currentStatement);</a>
<a name="12953"><span class="lineNum">   12953 </span>            : #if 0</a>
<a name="12954"><span class="lineNum">   12954 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;amountOfNameQualificationRequired = %d \n&quot;,amountOfNameQualificationRequired);</a>
<a name="12955"><span class="lineNum">   12955 </span>            : #endif</a>
<a name="12956"><span class="lineNum">   12956 </span>            :                     setNameQualification(varRefExp,variableDeclaration,amountOfNameQualificationRequired);</a>
<a name="12957"><span class="lineNum">   12957 </span>            :                   }</a>
<a name="12958"><span class="lineNum">   12958 </span>            : #if 0</a>
<a name="12959"><span class="lineNum">   12959 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="12960"><span class="lineNum">   12960 </span>            :                ROSE_ABORT();</a>
<a name="12961"><span class="lineNum">   12961 </span>            : #endif</a>
<a name="12962"><span class="lineNum">   12962 </span>            : #endif</a>
<a name="12963"><span class="lineNum">   12963 </span>            :              }</a>
<a name="12964"><span class="lineNum">   12964 </span>            : #if 0</a>
<a name="12965"><span class="lineNum">   12965 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Test 3: Processing varRefExp = %p: Exiting as a test! \n&quot;,varRefExp);</a>
<a name="12966"><span class="lineNum">   12966 </span>            :           ROSE_ABORT();</a>
<a name="12967"><span class="lineNum">   12967 </span>            : #endif</a>
<a name="12968"><span class="lineNum">   12968 </span>            :         }</a>
<a name="12969"><span class="lineNum">   12969 </span>            : </a>
<a name="12970"><span class="lineNum">   12970 </span>            :   // DQ (6/9/2011): Added support for test2011_79.C (enum values can require name qualification).</a>
<a name="12971"><span class="lineNum">   12971 </span><span class="lineCov">    2810440 :      SgEnumVal* enumVal = isSgEnumVal(n);</span></a>
<a name="12972"><span class="lineNum">   12972 </span><span class="lineCov">    2810440 :      if (enumVal != NULL)</span></a>
<a name="12973"><span class="lineNum">   12973 </span>            :         {</a>
<a name="12974"><span class="lineNum">   12974 </span><span class="lineCov">       5141 :           SgScopeStatement* currentScope = NULL;</span></a>
<a name="12975"><span class="lineNum">   12975 </span>            : </a>
<a name="12976"><span class="lineNum">   12976 </span><span class="lineCov">       5141 :           SgEnumDeclaration* enumDeclaration = enumVal-&gt;get_declaration();</span></a>
<a name="12977"><span class="lineNum">   12977 </span><span class="lineCov">       5141 :           ASSERT_not_null(enumDeclaration);</span></a>
<a name="12978"><span class="lineNum">   12978 </span>            : #if 0</a>
<a name="12979"><span class="lineNum">   12979 </span>            :           SgName tmp_enumVal_name = enumVal-&gt;get_name();</a>
<a name="12980"><span class="lineNum">   12980 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;tmp_enumVal_name = %s \n&quot;,tmp_enumVal_name.str());</a>
<a name="12981"><span class="lineNum">   12981 </span>            : #endif</a>
<a name="12982"><span class="lineNum">   12982 </span>            : #if 0</a>
<a name="12983"><span class="lineNum">   12983 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="12984"><span class="lineNum">   12984 </span>            :           ROSE_ABORT();</a>
<a name="12985"><span class="lineNum">   12985 </span>            : #endif</a>
<a name="12986"><span class="lineNum">   12986 </span>            : </a>
<a name="12987"><span class="lineNum">   12987 </span>            : #if 1</a>
<a name="12988"><span class="lineNum">   12988 </span>            :        // DQ (7/9/2019): Original code which addresses requirements for name qualification based on visability, but not ambiguity.</a>
<a name="12989"><span class="lineNum">   12989 </span>            : </a>
<a name="12990"><span class="lineNum">   12990 </span><span class="lineCov">       5141 :           SgStatement* currentStatement = TransformationSupport::getStatement(enumVal);</span></a>
<a name="12991"><span class="lineNum">   12991 </span>            :        // ASSERT_not_null(currentStatement);</a>
<a name="12992"><span class="lineNum">   12992 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="12993"><span class="lineNum">   12993 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;case of SgEnumVal: currentStatement = %p \n&quot;,currentStatement);</a>
<a name="12994"><span class="lineNum">   12994 </span>            : #endif</a>
<a name="12995"><span class="lineNum">   12995 </span>            : </a>
<a name="12996"><span class="lineNum">   12996 </span>            : </a>
<a name="12997"><span class="lineNum">   12997 </span><span class="lineCov">       5141 :           if (currentStatement != NULL)</span></a>
<a name="12998"><span class="lineNum">   12998 </span>            :              {</a>
<a name="12999"><span class="lineNum">   12999 </span><span class="lineCov">       5078 :                currentScope = isSgScopeStatement(currentStatement);</span></a>
<a name="13000"><span class="lineNum">   13000 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="13001"><span class="lineNum">   13001 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;case of SgEnumVal: currentStatement = %p = %s currentScope = %p = %s \n&quot;,</a>
<a name="13002"><span class="lineNum">   13002 </span>            :                     currentStatement,currentStatement-&gt;class_name().c_str(),currentScope,currentScope != NULL ? currentScope-&gt;class_name().c_str() : &quot;NULL&quot;);</a>
<a name="13003"><span class="lineNum">   13003 </span>            : #endif</a>
<a name="13004"><span class="lineNum">   13004 </span>            :             // If the current statement was not a scope, then what scope contains the current statement.</a>
<a name="13005"><span class="lineNum">   13005 </span><span class="lineCov">       5078 :                if (currentScope == NULL)</span></a>
<a name="13006"><span class="lineNum">   13006 </span>            :                   {</a>
<a name="13007"><span class="lineNum">   13007 </span>            :                  // DQ (5/24/2013): This is a better way to set the scope (see test2013_187.C).</a>
<a name="13008"><span class="lineNum">   13008 </span>            :                  // currentScope = currentStatement-&gt;get_scope();</a>
<a name="13009"><span class="lineNum">   13009 </span><span class="lineCov">       5078 :                     ASSERT_not_null(inheritedAttribute.get_currentScope());</span></a>
<a name="13010"><span class="lineNum">   13010 </span><span class="lineCov">       5078 :                     currentScope = inheritedAttribute.get_currentScope();</span></a>
<a name="13011"><span class="lineNum">   13011 </span>            :                   }</a>
<a name="13012"><span class="lineNum">   13012 </span><span class="lineCov">       5078 :                ASSERT_not_null(currentScope);</span></a>
<a name="13013"><span class="lineNum">   13013 </span>            : </a>
<a name="13014"><span class="lineNum">   13014 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="13015"><span class="lineNum">   13015 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;case of SgEnumVal (after setting currentScope): currentStatement = %p = %s currentScope = %p = %s \n&quot;,</a>
<a name="13016"><span class="lineNum">   13016 </span>            :                     currentStatement,currentStatement-&gt;class_name().c_str(),currentScope,currentScope != NULL ? currentScope-&gt;class_name().c_str() : &quot;NULL&quot;);</a>
<a name="13017"><span class="lineNum">   13017 </span>            : #endif</a>
<a name="13018"><span class="lineNum">   13018 </span><span class="lineCov">       5078 :                ASSERT_not_null(inheritedAttribute.get_currentScope());</span></a>
<a name="13019"><span class="lineNum">   13019 </span>            : </a>
<a name="13020"><span class="lineNum">   13020 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="13021"><span class="lineNum">   13021 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;case of SgEnumVal : inheritedAttribute.get_currentScope() = %p = %s \n&quot;,</a>
<a name="13022"><span class="lineNum">   13022 </span>            :                        inheritedAttribute.get_currentScope(),inheritedAttribute.get_currentScope()-&gt;class_name().c_str());</a>
<a name="13023"><span class="lineNum">   13023 </span>            : #endif</a>
<a name="13024"><span class="lineNum">   13024 </span>            :              }</a>
<a name="13025"><span class="lineNum">   13025 </span>            :             else</a>
<a name="13026"><span class="lineNum">   13026 </span>            :              {</a>
<a name="13027"><span class="lineNum">   13027 </span>            :             // If the enum value is contained in an index expression then currentStatement will be NULL.</a>
<a name="13028"><span class="lineNum">   13028 </span>            :             // But then the current scope should be known explicitly.</a>
<a name="13029"><span class="lineNum">   13029 </span><span class="lineCov">         63 :                currentScope = explictlySpecifiedCurrentScope;</span></a>
<a name="13030"><span class="lineNum">   13030 </span>            : </a>
<a name="13031"><span class="lineNum">   13031 </span>            :             // DQ (9/17/2011); Added escape for where the currentScope == NULL (fails for STL code when the original expression trees are used to eliminate the constant folded values).</a>
<a name="13032"><span class="lineNum">   13032 </span>            :             // ASSERT_not_null(currentScope);</a>
<a name="13033"><span class="lineNum">   13033 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="13034"><span class="lineNum">   13034 </span>            :             // DQ (4/19/2019): Now that we (optionally) also pass in the explictlySpecifiedCurrentStatement, we might want to use it directly.</a>
<a name="13035"><span class="lineNum">   13035 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;case of SgEnumVal: Using explictlySpecifiedCurrentScope for the value of currentStatement: need to check this! \n&quot;);</a>
<a name="13036"><span class="lineNum">   13036 </span>            : #endif</a>
<a name="13037"><span class="lineNum">   13037 </span>            :             // Use the currentScope as the currentStatement</a>
<a name="13038"><span class="lineNum">   13038 </span><span class="lineCov">         63 :                currentStatement = currentScope;</span></a>
<a name="13039"><span class="lineNum">   13039 </span>            :              }</a>
<a name="13040"><span class="lineNum">   13040 </span>            : #else</a>
<a name="13041"><span class="lineNum">   13041 </span>            :        // DQ (7/8/2019): Compute this from the perspective where they are referenced.</a>
<a name="13042"><span class="lineNum">   13042 </span>            :           SgStatement* currentStatement = TransformationSupport::getStatement(enumVal);</a>
<a name="13043"><span class="lineNum">   13043 </span>            :           if (currentStatement == NULL)</a>
<a name="13044"><span class="lineNum">   13044 </span>            :              {</a>
<a name="13045"><span class="lineNum">   13045 </span>            :             // This is the case of an enum in a array index expression or a template argument.</a>
<a name="13046"><span class="lineNum">   13046 </span>            :             // Either one might require name qualification of the enum field value.  Unclear</a>
<a name="13047"><span class="lineNum">   13047 </span>            :             // how to handle these cases (defer for now).</a>
<a name="13048"><span class="lineNum">   13048 </span>            : </a>
<a name="13049"><span class="lineNum">   13049 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Found case of enumVal with no associated statement \n&quot;);</a>
<a name="13050"><span class="lineNum">   13050 </span>            :                enumVal-&gt;get_file_info()-&gt;display(&quot;Found case of enumVal with no associated statement&quot;);</a>
<a name="13051"><span class="lineNum">   13051 </span>            : #if 0</a>
<a name="13052"><span class="lineNum">   13052 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="13053"><span class="lineNum">   13053 </span>            :                ROSE_ABORT();</a>
<a name="13054"><span class="lineNum">   13054 </span>            : #endif</a>
<a name="13055"><span class="lineNum">   13055 </span>            :              }</a>
<a name="13056"><span class="lineNum">   13056 </span>            :             else</a>
<a name="13057"><span class="lineNum">   13057 </span>            :              {</a>
<a name="13058"><span class="lineNum">   13058 </span>            :                currentScope = currentStatement-&gt;get_scope();</a>
<a name="13059"><span class="lineNum">   13059 </span>            :                ASSERT_not_null(currentScope);</a>
<a name="13060"><span class="lineNum">   13060 </span>            :              }</a>
<a name="13061"><span class="lineNum">   13061 </span>            :        // ASSERT_not_null(currentStatement);</a>
<a name="13062"><span class="lineNum">   13062 </span>            : </a>
<a name="13063"><span class="lineNum">   13063 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="13064"><span class="lineNum">   13064 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;enumVal = %p = %s \n&quot;,enumVal,SageInterface::get_name(enumVal).c_str());</a>
<a name="13065"><span class="lineNum">   13065 </span>            : #endif</a>
<a name="13066"><span class="lineNum">   13066 </span>            : #endif</a>
<a name="13067"><span class="lineNum">   13067 </span>            : </a>
<a name="13068"><span class="lineNum">   13068 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="13069"><span class="lineNum">   13069 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;currentStatement = %p \n&quot;,currentStatement);</a>
<a name="13070"><span class="lineNum">   13070 </span>            :           if (currentStatement != NULL)</a>
<a name="13071"><span class="lineNum">   13071 </span>            :              {</a>
<a name="13072"><span class="lineNum">   13072 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;currentStatement = %p = %s = %s \n&quot;,currentStatement,currentStatement-&gt;class_name().c_str(),SageInterface::get_name(currentStatement).c_str());</a>
<a name="13073"><span class="lineNum">   13073 </span>            :              }</a>
<a name="13074"><span class="lineNum">   13074 </span>            : </a>
<a name="13075"><span class="lineNum">   13075 </span>            : </a>
<a name="13076"><span class="lineNum">   13076 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;currentScope = %p \n&quot;,currentScope);</a>
<a name="13077"><span class="lineNum">   13077 </span>            :           if (currentScope != NULL)</a>
<a name="13078"><span class="lineNum">   13078 </span>            :              {</a>
<a name="13079"><span class="lineNum">   13079 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;currentScope = %p = %s = %s \n&quot;,currentScope,currentScope-&gt;class_name().c_str(),SageInterface::get_name(currentScope).c_str());</a>
<a name="13080"><span class="lineNum">   13080 </span>            :              }</a>
<a name="13081"><span class="lineNum">   13081 </span>            : #endif</a>
<a name="13082"><span class="lineNum">   13082 </span>            : </a>
<a name="13083"><span class="lineNum">   13083 </span>            :        // DQ (9/17/2011); Added escape for where the currentScope == NULL (fails for STL code when the original expression trees are used to eliminate the constant folded values).</a>
<a name="13084"><span class="lineNum">   13084 </span>            :        // ASSERT_not_null(currentScope);</a>
<a name="13085"><span class="lineNum">   13085 </span><span class="lineCov">       5141 :           if (currentScope != NULL)</span></a>
<a name="13086"><span class="lineNum">   13086 </span>            :              {</a>
<a name="13087"><span class="lineNum">   13087 </span>            :             // DQ (9/17/2011): this is the original case we waant to restore later...</a>
<a name="13088"><span class="lineNum">   13088 </span><span class="lineCov">       5141 :                ASSERT_not_null(currentScope);</span></a>
<a name="13089"><span class="lineNum">   13089 </span>            : </a>
<a name="13090"><span class="lineNum">   13090 </span>            :             // We need to look up the qualification for the enum name and not the enum declaration (which may have a different name (or no name).</a>
<a name="13091"><span class="lineNum">   13091 </span>            : </a>
<a name="13092"><span class="lineNum">   13092 </span>            :             // DQ (7/8/2019): Ideally this would form an iteration over the scopes from the current scope through the scopes connect via the base class.</a>
<a name="13093"><span class="lineNum">   13093 </span>            : </a>
<a name="13094"><span class="lineNum">   13094 </span>            :             // DQ (7/8/2019): Added varialbe to store the contribution to name qualification from ambiguity, as uposed to visability.</a>
<a name="13095"><span class="lineNum">   13095 </span><span class="lineCov">       5141 :                int additionalNameQualificationToResolveAmbiguity = 0;</span></a>
<a name="13096"><span class="lineNum">   13096 </span>            : </a>
<a name="13097"><span class="lineNum">   13097 </span>            : #if 1</a>
<a name="13098"><span class="lineNum">   13098 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="13099"><span class="lineNum">   13099 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;######################################################## \n&quot;);</a>
<a name="13100"><span class="lineNum">   13100 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Testing the EnumVal name instead of the Enum declaration \n&quot;);</a>
<a name="13101"><span class="lineNum">   13101 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;######################################################## \n&quot;);</a>
<a name="13102"><span class="lineNum">   13102 </span>            : #endif</a>
<a name="13103"><span class="lineNum">   13103 </span><span class="lineCov">      10282 :                SgName enumVal_name = enumVal-&gt;get_name();</span></a>
<a name="13104"><span class="lineNum">   13104 </span>            : </a>
<a name="13105"><span class="lineNum">   13105 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="13106"><span class="lineNum">   13106 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;enumVal_name = %s \n&quot;,enumVal_name.str());</a>
<a name="13107"><span class="lineNum">   13107 </span>            : #endif</a>
<a name="13108"><span class="lineNum">   13108 </span>            : </a>
<a name="13109"><span class="lineNum">   13109 </span>            : #if 0</a>
<a name="13110"><span class="lineNum">   13110 </span>            :                SgSymbol* symbol = currentScope-&gt;lookup_enum_field_symbol(enumVal_name);</a>
<a name="13111"><span class="lineNum">   13111 </span>            :                if (symbol != NULL)</a>
<a name="13112"><span class="lineNum">   13112 </span>            :                   {</a>
<a name="13113"><span class="lineNum">   13113 </span>            :                     SgEnumFieldSymbol* enumFieldSymbol = isSgEnumFieldSymbol(symbol);</a>
<a name="13114"><span class="lineNum">   13114 </span>            : </a>
<a name="13115"><span class="lineNum">   13115 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="13116"><span class="lineNum">   13116 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;enumFieldSymbol = %p \n&quot;,enumFieldSymbol);</a>
<a name="13117"><span class="lineNum">   13117 </span>            : #endif</a>
<a name="13118"><span class="lineNum">   13118 </span>            :                     if (enumFieldSymbol != NULL)</a>
<a name="13119"><span class="lineNum">   13119 </span>            :                        {</a>
<a name="13120"><span class="lineNum">   13120 </span>            :                          SgInitializedName* initializedName = enumFieldSymbol-&gt;get_declaration();</a>
<a name="13121"><span class="lineNum">   13121 </span>            :                          ASSERT_not_null(initializedName);</a>
<a name="13122"><span class="lineNum">   13122 </span>            : </a>
<a name="13123"><span class="lineNum">   13123 </span>            :                          int amountOfNameQualificationRequiredByName = nameQualificationDepth(initializedName,currentScope,currentStatement);</a>
<a name="13124"><span class="lineNum">   13124 </span>            : </a>
<a name="13125"><span class="lineNum">   13125 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="13126"><span class="lineNum">   13126 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;amountOfNameQualificationRequiredByName = %d \n&quot;,amountOfNameQualificationRequiredByName);</a>
<a name="13127"><span class="lineNum">   13127 </span>            : #endif</a>
<a name="13128"><span class="lineNum">   13128 </span>            :                        }</a>
<a name="13129"><span class="lineNum">   13129 </span>            :                       else</a>
<a name="13130"><span class="lineNum">   13130 </span>            :                        {</a>
<a name="13131"><span class="lineNum">   13131 </span>            :                       // There is not another SgEnumFieldSymbol is this scope.</a>
<a name="13132"><span class="lineNum">   13132 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="13133"><span class="lineNum">   13133 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;There is not another SgEnumFieldSymbol is this scope \n&quot;);</a>
<a name="13134"><span class="lineNum">   13134 </span>            : #endif</a>
<a name="13135"><span class="lineNum">   13135 </span>            :                        }</a>
<a name="13136"><span class="lineNum">   13136 </span>            :                   }</a>
<a name="13137"><span class="lineNum">   13137 </span>            :                  else</a>
<a name="13138"><span class="lineNum">   13138 </span>            : #endif</a>
<a name="13139"><span class="lineNum">   13139 </span><span class="lineCov">       5141 :                   {</span></a>
<a name="13140"><span class="lineNum">   13140 </span>            :                  // If there was no symbol, then there was no ambiguity to force the name qualification.</a>
<a name="13141"><span class="lineNum">   13141 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="13142"><span class="lineNum">   13142 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;If there was no symbol, then there was no ambiguity to force the name qualification in the current scope directly \n&quot;);</a>
<a name="13143"><span class="lineNum">   13143 </span>            : #endif</a>
<a name="13144"><span class="lineNum">   13144 </span>            :                  // DQ (8/16/2013): Build the template parameters and template arguments as appropriate (will be NULL pointers for some types of declarations).</a>
<a name="13145"><span class="lineNum">   13145 </span><span class="lineCov">       5141 :                     SgTemplateParameterPtrList* templateParameterList = NULL; // SageBuilder::getTemplateParameterList(declaration);</span></a>
<a name="13146"><span class="lineNum">   13146 </span><span class="lineCov">       5141 :                     SgTemplateArgumentPtrList*  templateArgumentList  = NULL; // SageBuilder::getTemplateArgumentList(declaration);</span></a>
<a name="13147"><span class="lineNum">   13147 </span>            : </a>
<a name="13148"><span class="lineNum">   13148 </span><span class="lineCov">       5141 :                     SgEnumDeclaration* enumDeclaration = enumVal-&gt;get_declaration();</span></a>
<a name="13149"><span class="lineNum">   13149 </span><span class="lineCov">       5141 :                     ASSERT_not_null(enumDeclaration);</span></a>
<a name="13150"><span class="lineNum">   13150 </span><span class="lineCov">       5141 :                     SgScopeStatement* enumDeclarationScope = enumDeclaration-&gt;get_scope();</span></a>
<a name="13151"><span class="lineNum">   13151 </span><span class="lineCov">       5141 :                     ASSERT_not_null(enumDeclarationScope);</span></a>
<a name="13152"><span class="lineNum">   13152 </span>            : </a>
<a name="13153"><span class="lineNum">   13153 </span><span class="lineCov">       5141 :                     SgSymbol* symbolFromEnumDeclarationScope = enumDeclarationScope-&gt;lookup_enum_field_symbol(enumVal_name);</span></a>
<a name="13154"><span class="lineNum">   13154 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="13155"><span class="lineNum">   13155 </span>            :                     if (symbolFromEnumDeclarationScope == NULL)</a>
<a name="13156"><span class="lineNum">   13156 </span>            :                        {</a>
<a name="13157"><span class="lineNum">   13157 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;name qualification: case of SgEnumVal: Found case of enumVal_name = %s not in scope of enumDeclaration = %p = %s \n&quot;,</a>
<a name="13158"><span class="lineNum">   13158 </span>            :                                  enumVal_name.str(),enumDeclaration,enumDeclaration-&gt;class_name().c_str());</a>
<a name="13159"><span class="lineNum">   13159 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot; --- symbolFromEnumDeclarationScope == NULL \n&quot;);</a>
<a name="13160"><span class="lineNum">   13160 </span>            :                        }</a>
<a name="13161"><span class="lineNum">   13161 </span>            : #endif</a>
<a name="13162"><span class="lineNum">   13162 </span>            :                  // ASSERT_not_null(symbolFromEnumDeclarationScope);</a>
<a name="13163"><span class="lineNum">   13163 </span>            : </a>
<a name="13164"><span class="lineNum">   13164 </span><span class="lineCov">       5141 :                     SgSymbol* symbolFromParents = SageInterface::lookupSymbolInParentScopes(enumVal_name,currentScope,templateParameterList,templateArgumentList);</span></a>
<a name="13165"><span class="lineNum">   13165 </span>            : </a>
<a name="13166"><span class="lineNum">   13166 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="13167"><span class="lineNum">   13167 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;symbolFromParents = %p \n&quot;,symbolFromParents);</a>
<a name="13168"><span class="lineNum">   13168 </span>            : #endif</a>
<a name="13169"><span class="lineNum">   13169 </span><span class="lineCov">       5141 :                     if (symbolFromParents != NULL &amp;&amp; symbolFromEnumDeclarationScope != NULL &amp;&amp; symbolFromParents != symbolFromEnumDeclarationScope)</span></a>
<a name="13170"><span class="lineNum">   13170 </span>            :                        {</a>
<a name="13171"><span class="lineNum">   13171 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="13172"><span class="lineNum">   13172 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;Found a reason for adding name qualification \n&quot;);</a>
<a name="13173"><span class="lineNum">   13173 </span>            : #endif</a>
<a name="13174"><span class="lineNum">   13174 </span><span class="lineCov">          9 :                          additionalNameQualificationToResolveAmbiguity++;</span></a>
<a name="13175"><span class="lineNum">   13175 </span>            :                        }</a>
<a name="13176"><span class="lineNum">   13176 </span>            :                   }</a>
<a name="13177"><span class="lineNum">   13177 </span>            : </a>
<a name="13178"><span class="lineNum">   13178 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="13179"><span class="lineNum">   13179 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;############################################################## \n&quot;);</a>
<a name="13180"><span class="lineNum">   13180 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;DONE: Testing the EnumVal name instead of the Enum declaration \n&quot;);</a>
<a name="13181"><span class="lineNum">   13181 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;############################################################## \n&quot;);</a>
<a name="13182"><span class="lineNum">   13182 </span>            : #endif</a>
<a name="13183"><span class="lineNum">   13183 </span>            : #endif</a>
<a name="13184"><span class="lineNum">   13184 </span>            : </a>
<a name="13185"><span class="lineNum">   13185 </span>            : #if 0</a>
<a name="13186"><span class="lineNum">   13186 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="13187"><span class="lineNum">   13187 </span>            :                ROSE_ABORT();</a>
<a name="13188"><span class="lineNum">   13188 </span>            : #endif</a>
<a name="13189"><span class="lineNum">   13189 </span>            : </a>
<a name="13190"><span class="lineNum">   13190 </span><span class="lineCov">       5141 :                int amountOfNameQualificationRequired = nameQualificationDepth(enumDeclaration,currentScope,currentStatement);</span></a>
<a name="13191"><span class="lineNum">   13191 </span>            : </a>
<a name="13192"><span class="lineNum">   13192 </span><span class="lineCov">       5141 :                if (amountOfNameQualificationRequired == 0)</span></a>
<a name="13193"><span class="lineNum">   13193 </span>            :                   {</a>
<a name="13194"><span class="lineNum">   13194 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="13195"><span class="lineNum">   13195 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Specify name qualification to resolve ambiguity: additionalNameQualificationToResolveAmbiguity = %d \n&quot;,additionalNameQualificationToResolveAmbiguity);</a>
<a name="13196"><span class="lineNum">   13196 </span>            : #endif</a>
<a name="13197"><span class="lineNum">   13197 </span><span class="lineCov">       4518 :                     amountOfNameQualificationRequired = additionalNameQualificationToResolveAmbiguity;</span></a>
<a name="13198"><span class="lineNum">   13198 </span>            :                   }</a>
<a name="13199"><span class="lineNum">   13199 </span>            : </a>
<a name="13200"><span class="lineNum">   13200 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="13201"><span class="lineNum">   13201 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;SgEnumVal: amountOfNameQualificationRequired = %d \n&quot;,amountOfNameQualificationRequired);</a>
<a name="13202"><span class="lineNum">   13202 </span>            : #endif</a>
<a name="13203"><span class="lineNum">   13203 </span><span class="lineCov">       5141 :                setNameQualification(enumVal,enumDeclaration,amountOfNameQualificationRequired);</span></a>
<a name="13204"><span class="lineNum">   13204 </span>            :              }</a>
<a name="13205"><span class="lineNum">   13205 </span>            :             else</a>
<a name="13206"><span class="lineNum">   13206 </span>            :              {</a>
<a name="13207"><span class="lineNum">   13207 </span>            :             // DQ (9/17/2011): Added this case, print a warning and fix thiat after debugging the constant folding value elimination..</a>
<a name="13208"><span class="lineNum">   13208 </span><span class="lineNoCov">          0 :                mfprintf(mlog [ WARN ] ) (&quot;WARNING: SgEnumVal name qualification not handled for the case of currentScope == NULL \n&quot;);</span></a>
<a name="13209"><span class="lineNum">   13209 </span>            :              }</a>
<a name="13210"><span class="lineNum">   13210 </span>            : </a>
<a name="13211"><span class="lineNum">   13211 </span>            : #if 0</a>
<a name="13212"><span class="lineNum">   13212 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test: case of SgEnumVal \n&quot;);</a>
<a name="13213"><span class="lineNum">   13213 </span>            :           ROSE_ABORT();</a>
<a name="13214"><span class="lineNum">   13214 </span>            : #endif</a>
<a name="13215"><span class="lineNum">   13215 </span>            :         }</a>
<a name="13216"><span class="lineNum">   13216 </span>            : </a>
<a name="13217"><span class="lineNum">   13217 </span>            : </a>
<a name="13218"><span class="lineNum">   13218 </span>            :   // DQ (6/2/2011): Handle the range of expressions that can reference types that might require name qualification...</a>
<a name="13219"><span class="lineNum">   13219 </span><span class="lineCov">    2810440 :      SgNewExp*   newExp   = isSgNewExp(n);</span></a>
<a name="13220"><span class="lineNum">   13220 </span><span class="lineCov">    2810440 :      SgSizeOfOp* sizeOfOp = isSgSizeOfOp(n);</span></a>
<a name="13221"><span class="lineNum">   13221 </span><span class="lineCov">    2810440 :      SgCastExp*  castExp  = isSgCastExp(n);</span></a>
<a name="13222"><span class="lineNum">   13222 </span><span class="lineCov">    2810440 :      SgTypeIdOp* typeIdOp = isSgTypeIdOp(n);</span></a>
<a name="13223"><span class="lineNum">   13223 </span><span class="lineCov">    2810440 :      if (newExp != NULL || sizeOfOp != NULL || castExp != NULL || typeIdOp != NULL)</span></a>
<a name="13224"><span class="lineNum">   13224 </span>            :         {</a>
<a name="13225"><span class="lineNum">   13225 </span><span class="lineCov">      21809 :           SgExpression* referenceToType = isSgExpression(n);</span></a>
<a name="13226"><span class="lineNum">   13226 </span>            : </a>
<a name="13227"><span class="lineNum">   13227 </span><span class="lineCov">      21809 :           bool skipQualification = false;</span></a>
<a name="13228"><span class="lineNum">   13228 </span>            : </a>
<a name="13229"><span class="lineNum">   13229 </span><span class="lineCov">      21809 :           SgType* qualifiedType = NULL;</span></a>
<a name="13230"><span class="lineNum">   13230 </span><span class="lineCov">      21809 :           switch(n-&gt;variantT())</span></a>
<a name="13231"><span class="lineNum">   13231 </span>            :              {</a>
<a name="13232"><span class="lineNum">   13232 </span><span class="lineCov">        143 :                case V_SgNewExp:</span></a>
<a name="13233"><span class="lineNum">   13233 </span><span class="lineCov">        143 :                   {</span></a>
<a name="13234"><span class="lineNum">   13234 </span><span class="lineCov">        143 :                     qualifiedType = newExp-&gt;get_specified_type();</span></a>
<a name="13235"><span class="lineNum">   13235 </span>            :                     break;</a>
<a name="13236"><span class="lineNum">   13236 </span>            :                   }</a>
<a name="13237"><span class="lineNum">   13237 </span>            : </a>
<a name="13238"><span class="lineNum">   13238 </span><span class="lineCov">        932 :                case V_SgSizeOfOp:</span></a>
<a name="13239"><span class="lineNum">   13239 </span><span class="lineCov">        932 :                   {</span></a>
<a name="13240"><span class="lineNum">   13240 </span><span class="lineCov">        932 :                     qualifiedType = sizeOfOp-&gt;get_operand_type();</span></a>
<a name="13241"><span class="lineNum">   13241 </span><span class="lineCov">        932 :                     if (qualifiedType == NULL)</span></a>
<a name="13242"><span class="lineNum">   13242 </span>            :                        {</a>
<a name="13243"><span class="lineNum">   13243 </span>            :                       // This is the case of a value, which need not be qualified. Except that it could be a variable, but then it should be a SgVarRefExp</a>
<a name="13244"><span class="lineNum">   13244 </span><span class="lineCov">         41 :                          ASSERT_not_null(sizeOfOp-&gt;get_operand_expr());</span></a>
<a name="13245"><span class="lineNum">   13245 </span><span class="lineCov">         41 :                          skipQualification = true;</span></a>
<a name="13246"><span class="lineNum">   13246 </span>            :                        }</a>
<a name="13247"><span class="lineNum">   13247 </span>            :                     break;</a>
<a name="13248"><span class="lineNum">   13248 </span>            :                   }</a>
<a name="13249"><span class="lineNum">   13249 </span>            : </a>
<a name="13250"><span class="lineNum">   13250 </span><span class="lineCov">      20723 :                case V_SgCastExp:</span></a>
<a name="13251"><span class="lineNum">   13251 </span><span class="lineCov">      20723 :                   {</span></a>
<a name="13252"><span class="lineNum">   13252 </span><span class="lineCov">      20723 :                     qualifiedType = castExp-&gt;get_type();</span></a>
<a name="13253"><span class="lineNum">   13253 </span>            : #if 0</a>
<a name="13254"><span class="lineNum">   13254 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="13255"><span class="lineNum">   13255 </span>            :                     ROSE_ABORT();</a>
<a name="13256"><span class="lineNum">   13256 </span>            : #endif</a>
<a name="13257"><span class="lineNum">   13257 </span>            :                     break;</a>
<a name="13258"><span class="lineNum">   13258 </span>            :                   }</a>
<a name="13259"><span class="lineNum">   13259 </span>            : </a>
<a name="13260"><span class="lineNum">   13260 </span>            :             // DQ (1/26/2013): typeId operator can take either an expression or a type, get_type() returns the type independent of which is specified.</a>
<a name="13261"><span class="lineNum">   13261 </span>            :             // case V_SgTypeIdOp: qualifiedType = typeIdOp-&gt;get_type(); break;</a>
<a name="13262"><span class="lineNum">   13262 </span><span class="lineCov">         11 :                case V_SgTypeIdOp:</span></a>
<a name="13263"><span class="lineNum">   13263 </span><span class="lineCov">         11 :                   {</span></a>
<a name="13264"><span class="lineNum">   13264 </span><span class="lineCov">         11 :                     qualifiedType = typeIdOp-&gt;get_operand_type();</span></a>
<a name="13265"><span class="lineNum">   13265 </span>            :                     break;</a>
<a name="13266"><span class="lineNum">   13266 </span>            :                   }</a>
<a name="13267"><span class="lineNum">   13267 </span>            : </a>
<a name="13268"><span class="lineNum">   13268 </span><span class="lineNoCov">          0 :                default:</span></a>
<a name="13269"><span class="lineNum">   13269 </span><span class="lineNoCov">          0 :                   {</span></a>
<a name="13270"><span class="lineNum">   13270 </span>            :                  // Anything else should not make it this far...</a>
<a name="13271"><span class="lineNum">   13271 </span><span class="lineNoCov">          0 :                     mfprintf(mlog [ WARN ] ) (&quot;Error: default reached in switch... n = %p = %s \n&quot;,n,n-&gt;class_name().c_str());</span></a>
<a name="13272"><span class="lineNum">   13272 </span><span class="lineNoCov">          0 :                     ROSE_ABORT();</span></a>
<a name="13273"><span class="lineNum">   13273 </span>            :                   }</a>
<a name="13274"><span class="lineNum">   13274 </span>            :              }</a>
<a name="13275"><span class="lineNum">   13275 </span>            : </a>
<a name="13276"><span class="lineNum">   13276 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="13277"><span class="lineNum">   13277 </span>            :           if (qualifiedType == NULL)</a>
<a name="13278"><span class="lineNum">   13278 </span>            :              {</a>
<a name="13279"><span class="lineNum">   13279 </span>            :             // We see this case for test2006_139.C  (code is: &quot;sizeof(&quot;string&quot;)&quot; or &quot;sizeof(&lt;SgVarRefExp&gt;)&quot; ).</a>
<a name="13280"><span class="lineNum">   13280 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Note: qualifiedType == NULL for n = %p = %s \n&quot;,n,n-&gt;class_name().c_str());</a>
<a name="13281"><span class="lineNum">   13281 </span>            :              }</a>
<a name="13282"><span class="lineNum">   13282 </span>            : #endif</a>
<a name="13283"><span class="lineNum">   13283 </span>            :        // ASSERT_not_null(qualifiedType);</a>
<a name="13284"><span class="lineNum">   13284 </span>            : </a>
<a name="13285"><span class="lineNum">   13285 </span><span class="lineCov">         41 :           if (skipQualification == false)</span></a>
<a name="13286"><span class="lineNum">   13286 </span>            :              {</a>
<a name="13287"><span class="lineNum">   13287 </span>            :             // DQ (1/26/2013): added assertion.</a>
<a name="13288"><span class="lineNum">   13288 </span><span class="lineCov">      21768 :                ASSERT_not_null(qualifiedType);</span></a>
<a name="13289"><span class="lineNum">   13289 </span>            : </a>
<a name="13290"><span class="lineNum">   13290 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="13291"><span class="lineNum">   13291 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;before stripType(): qualifiedType = %p = %s \n&quot;,qualifiedType,qualifiedType-&gt;class_name().c_str());</a>
<a name="13292"><span class="lineNum">   13292 </span>            : #endif</a>
<a name="13293"><span class="lineNum">   13293 </span>            :             // DQ (5/19/2019): Comment this out since it causes the cast to loose the information about casts of pointer types.</a>
<a name="13294"><span class="lineNum">   13294 </span>            :             // See test2019_433.C.</a>
<a name="13295"><span class="lineNum">   13295 </span>            : #if 0</a>
<a name="13296"><span class="lineNum">   13296 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Comment out strip type: qualifiedType-&gt;stripType(SgType::STRIP_POINTER_TYPE) \n&quot;);</a>
<a name="13297"><span class="lineNum">   13297 </span>            : #endif</a>
<a name="13298"><span class="lineNum">   13298 </span>            :             // qualifiedType = qualifiedType-&gt;stripType(SgType::STRIP_POINTER_TYPE);</a>
<a name="13299"><span class="lineNum">   13299 </span><span class="lineCov">      21768 :                SgType* strippedQualifiedType = qualifiedType-&gt;stripType(SgType::STRIP_POINTER_TYPE);</span></a>
<a name="13300"><span class="lineNum">   13300 </span>            : </a>
<a name="13301"><span class="lineNum">   13301 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="13302"><span class="lineNum">   13302 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;after stripType():  qualifiedType         = %p = %s \n&quot;,qualifiedType,qualifiedType-&gt;class_name().c_str());</a>
<a name="13303"><span class="lineNum">   13303 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;after stripType():  strippedQualifiedType = %p = %s \n&quot;,strippedQualifiedType,strippedQualifiedType-&gt;class_name().c_str());</a>
<a name="13304"><span class="lineNum">   13304 </span>            : #endif</a>
<a name="13305"><span class="lineNum">   13305 </span>            : </a>
<a name="13306"><span class="lineNum">   13306 </span>            :             // DQ (4/26/2019): This variable is not used.</a>
<a name="13307"><span class="lineNum">   13307 </span>            :             // DQ (4/16/2019): If the qualifiedType is a SgPointerMemberType, then we need to have this return the declaration</a>
<a name="13308"><span class="lineNum">   13308 </span>            :             // associated with the base type.</a>
<a name="13309"><span class="lineNum">   13309 </span>            :             // SgDeclarationStatement* associatedTypeDeclaration = associatedDeclaration(qualifiedType);</a>
<a name="13310"><span class="lineNum">   13310 </span><span class="lineCov">      21768 :                SgDeclarationStatement* associatedTypeDeclaration = associatedDeclaration(strippedQualifiedType);</span></a>
<a name="13311"><span class="lineNum">   13311 </span>            : </a>
<a name="13312"><span class="lineNum">   13312 </span>            :             // DQ (4/15/2019): Adding SgPointerMemberType support for the few expressions that contain explicit references to types</a>
<a name="13313"><span class="lineNum">   13313 </span>            :             // SgPointerMemberType* pointerMemberType = isSgPointerMemberType(qualifiedType);</a>
<a name="13314"><span class="lineNum">   13314 </span><span class="lineCov">      21768 :                SgPointerMemberType* pointerMemberType = isSgPointerMemberType(strippedQualifiedType);</span></a>
<a name="13315"><span class="lineNum">   13315 </span><span class="lineCov">      21768 :                if (pointerMemberType != NULL)</span></a>
<a name="13316"><span class="lineNum">   13316 </span>            :                   {</a>
<a name="13317"><span class="lineNum">   13317 </span>            : #if 0</a>
<a name="13318"><span class="lineNum">   13318 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Case SgExpression: SgPointerMemberType: Shouldn't this be a recursive call via a type traversal \n&quot;);</a>
<a name="13319"><span class="lineNum">   13319 </span>            : #endif</a>
<a name="13320"><span class="lineNum">   13320 </span>            : #if 0</a>
<a name="13321"><span class="lineNum">   13321 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;############################################################################### \n&quot;);</a>
<a name="13322"><span class="lineNum">   13322 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Case SgExpression: containing reference to type: processing SgPointerMemberType \n&quot;);</a>
<a name="13323"><span class="lineNum">   13323 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;############################################################################### \n&quot;);</a>
<a name="13324"><span class="lineNum">   13324 </span>            : #endif</a>
<a name="13325"><span class="lineNum">   13325 </span>            : </a>
<a name="13326"><span class="lineNum">   13326 </span>            : </a>
<a name="13327"><span class="lineNum">   13327 </span>            : #if 0</a>
<a name="13328"><span class="lineNum">   13328 </span>            :                  // DQ (4/27/2019): This is older code that might NOT be better than the older code it is replacing</a>
<a name="13329"><span class="lineNum">   13329 </span>            :                  // (at least specific to SgPointerMemberType support).</a>
<a name="13330"><span class="lineNum">   13330 </span>            : </a>
<a name="13331"><span class="lineNum">   13331 </span>            :                     SgClassDeclaration* classDeclaration = isSgClassDeclaration(pointerMemberType-&gt;get_class_declaration_of());</a>
<a name="13332"><span class="lineNum">   13332 </span>            : </a>
<a name="13333"><span class="lineNum">   13333 </span>            :                     SgExpression* expressionHoldingTypeReference = isSgExpression(n);</a>
<a name="13334"><span class="lineNum">   13334 </span>            :                     ASSERT_not_null(expressionHoldingTypeReference);</a>
<a name="13335"><span class="lineNum">   13335 </span>            : </a>
<a name="13336"><span class="lineNum">   13336 </span>            :                     SgStatement* currentStatement = TransformationSupport::getStatement(expressionHoldingTypeReference);</a>
<a name="13337"><span class="lineNum">   13337 </span>            :                     ASSERT_not_null(currentStatement);</a>
<a name="13338"><span class="lineNum">   13338 </span>            :                     SgScopeStatement* currentScope = currentStatement-&gt;get_scope();</a>
<a name="13339"><span class="lineNum">   13339 </span>            :                     ASSERT_not_null(currentScope);</a>
<a name="13340"><span class="lineNum">   13340 </span>            : </a>
<a name="13341"><span class="lineNum">   13341 </span>            :                     if (classDeclaration != NULL)</a>
<a name="13342"><span class="lineNum">   13342 </span>            :                        {</a>
<a name="13343"><span class="lineNum">   13343 </span>            :                       // SgClassDeclaration* classDeclaration = classDefinition-&gt;get_declaration();</a>
<a name="13344"><span class="lineNum">   13344 </span>            :                          ASSERT_not_null(classDeclaration);</a>
<a name="13345"><span class="lineNum">   13345 </span>            : </a>
<a name="13346"><span class="lineNum">   13346 </span>            :                          SgDeclarationStatement* declarationForExpressionTypeReference = classDeclaration;</a>
<a name="13347"><span class="lineNum">   13347 </span>            :                          ASSERT_not_null(declarationForExpressionTypeReference);</a>
<a name="13348"><span class="lineNum">   13348 </span>            : </a>
<a name="13349"><span class="lineNum">   13349 </span>            :                       // SgDeclarationStatement* positionStatement = isSgDeclarationStatement(expressionHoldingTypeReference-&gt;get_parent());</a>
<a name="13350"><span class="lineNum">   13350 </span>            :                          SgStatement* positionStatement = currentStatement;</a>
<a name="13351"><span class="lineNum">   13351 </span>            :                          ASSERT_not_null(positionStatement);</a>
<a name="13352"><span class="lineNum">   13352 </span>            : </a>
<a name="13353"><span class="lineNum">   13353 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="13354"><span class="lineNum">   13354 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;SgExpression with type reference: declarationForExpresionTypeReference = %p = %s \n&quot;,</a>
<a name="13355"><span class="lineNum">   13355 </span>            :                               declarationForExpressionTypeReference,declarationForExpressionTypeReference-&gt;class_name().c_str());</a>
<a name="13356"><span class="lineNum">   13356 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;SgExpression with type reference: positionStatement = %p = %s \n&quot;,</a>
<a name="13357"><span class="lineNum">   13357 </span>            :                               positionStatement,positionStatement-&gt;class_name().c_str());</a>
<a name="13358"><span class="lineNum">   13358 </span>            : #endif</a>
<a name="13359"><span class="lineNum">   13359 </span>            :                          int amountOfNameQualificationRequiredForExpressionTypeReference = nameQualificationDepth(declarationForExpressionTypeReference,currentScope,positionStatement);</a>
<a name="13360"><span class="lineNum">   13360 </span>            : </a>
<a name="13361"><span class="lineNum">   13361 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="13362"><span class="lineNum">   13362 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;SgExpression with type reference: SgPointerMemberType: name: amountOfNameQualificationRequiredForExpressionTypeReference = %d \n&quot;,amountOfNameQualificationRequiredForExpressionTypeReference);</a>
<a name="13363"><span class="lineNum">   13363 </span>            : #endif</a>
<a name="13364"><span class="lineNum">   13364 </span>            : </a>
<a name="13365"><span class="lineNum">   13365 </span>            :                       // DQ (4/16/2019): I think we need yet another function to support this.</a>
<a name="13366"><span class="lineNum">   13366 </span>            :                       // bool skipGlobalNameQualification = false;</a>
<a name="13367"><span class="lineNum">   13367 </span>            : #if 1</a>
<a name="13368"><span class="lineNum">   13368 </span>            :                       // setNameQualificationForPointerToMemberClass(</a>
<a name="13369"><span class="lineNum">   13369 </span>            :                       // setNameQualification(expressionHoldingTypeReference,declarationForExpressionTypeReference,</a>
<a name="13370"><span class="lineNum">   13370 </span>            :                       //                      amountOfNameQualificationRequiredForExpressionTypeReference,skipGlobalNameQualification);</a>
<a name="13371"><span class="lineNum">   13371 </span>            :                       // setNameQualification(expressionHoldingTypeReference,declarationForExpressionTypeReference,amountOfNameQualificationRequiredForExpressionTypeReference);</a>
<a name="13372"><span class="lineNum">   13372 </span>            :                          setNameQualificationForPointerToMember(expressionHoldingTypeReference,declarationForExpressionTypeReference,amountOfNameQualificationRequiredForExpressionTypeReference);</a>
<a name="13373"><span class="lineNum">   13373 </span>            : #endif</a>
<a name="13374"><span class="lineNum">   13374 </span>            : #if 0</a>
<a name="13375"><span class="lineNum">   13375 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="13376"><span class="lineNum">   13376 </span>            :                          ROSE_ABORT();</a>
<a name="13377"><span class="lineNum">   13377 </span>            : #endif</a>
<a name="13378"><span class="lineNum">   13378 </span>            :                        }</a>
<a name="13379"><span class="lineNum">   13379 </span>            :                       else</a>
<a name="13380"><span class="lineNum">   13380 </span>            :                        {</a>
<a name="13381"><span class="lineNum">   13381 </span>            :                       // DQ (4/11/2019): If this is not a SgClassDeclaration then it can be a nonreal declaration which is not handled yet.</a>
<a name="13382"><span class="lineNum">   13382 </span>            :                        }</a>
<a name="13383"><span class="lineNum">   13383 </span>            : </a>
<a name="13384"><span class="lineNum">   13384 </span>            :                     SgType* baseType = pointerMemberType-&gt;get_base_type();</a>
<a name="13385"><span class="lineNum">   13385 </span>            :                  // baseType = baseType-&gt;stripType(SgType::STRIP_MODIFIER_TYPE);</a>
<a name="13386"><span class="lineNum">   13386 </span>            :                     baseType = baseType-&gt;stripType(SgType::STRIP_MODIFIER_TYPE|SgType::STRIP_REFERENCE_TYPE|SgType::STRIP_RVALUE_REFERENCE_TYPE|SgType::STRIP_POINTER_TYPE|SgType::STRIP_ARRAY_TYPE);</a>
<a name="13387"><span class="lineNum">   13387 </span>            :                  // if (isSgPointerMemberType(pointerMemberType-&gt;get_base_type()) != NULL)</a>
<a name="13388"><span class="lineNum">   13388 </span>            :                     if (baseType != NULL)</a>
<a name="13389"><span class="lineNum">   13389 </span>            :                        {</a>
<a name="13390"><span class="lineNum">   13390 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;Not prepared for this case! (SgPointerMemberType base type of SgPointerMemberType) \n&quot;);</a>
<a name="13391"><span class="lineNum">   13391 </span>            :                          ROSE_ABORT();</a>
<a name="13392"><span class="lineNum">   13392 </span>            :                        }</a>
<a name="13393"><span class="lineNum">   13393 </span>            : </a>
<a name="13394"><span class="lineNum">   13394 </span>            :                     associatedTypeDeclaration = associatedDeclaration(pointerMemberType-&gt;get_base_type());</a>
<a name="13395"><span class="lineNum">   13395 </span>            : </a>
<a name="13396"><span class="lineNum">   13396 </span>            :                  // DQ (4/27/2019): This is older code that might NOT be better than the older code it is replacing</a>
<a name="13397"><span class="lineNum">   13397 </span>            :                  // (at least specific to SgPointerMemberType support).</a>
<a name="13398"><span class="lineNum">   13398 </span>            : #else</a>
<a name="13399"><span class="lineNum">   13399 </span>            :                  // DQ (4/27/2019): This is the newer code for what we have detected a SgPointerMemberType.</a>
<a name="13400"><span class="lineNum">   13400 </span>            : </a>
<a name="13401"><span class="lineNum">   13401 </span>            : #if 0</a>
<a name="13402"><span class="lineNum">   13402 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Make the recursive call to evaluate the SgPointerMemberType \n&quot;);</a>
<a name="13403"><span class="lineNum">   13403 </span>            : #endif</a>
<a name="13404"><span class="lineNum">   13404 </span>            :                  // DQ (4/21/2019): Then save call traverseType to save the type as a string to be accessed when unparsing the type from this expression (e.g. new operator).</a>
<a name="13405"><span class="lineNum">   13405 </span>            : </a>
<a name="13406"><span class="lineNum">   13406 </span>            : #if 0</a>
<a name="13407"><span class="lineNum">   13407 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;#################################################################################################### \n&quot;);</a>
<a name="13408"><span class="lineNum">   13408 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Case SgNewExp, SgCastExp, SgSizeOfOp, SgTypeIdOp: Calling generateNestedTraversalWithExplicitScope() \n&quot;);</a>
<a name="13409"><span class="lineNum">   13409 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;#################################################################################################### \n&quot;);</a>
<a name="13410"><span class="lineNum">   13410 </span>            : #endif</a>
<a name="13411"><span class="lineNum">   13411 </span>            : </a>
<a name="13412"><span class="lineNum">   13412 </span><span class="lineNoCov">          0 :                     SgStatement*      currentStatement = TransformationSupport::getStatement(referenceToType);</span></a>
<a name="13413"><span class="lineNum">   13413 </span><span class="lineNoCov">          0 :                     SgScopeStatement* currentScope     = currentStatement-&gt;get_scope();</span></a>
<a name="13414"><span class="lineNum">   13414 </span>            : #if 1</a>
<a name="13415"><span class="lineNum">   13415 </span><span class="lineNoCov">          0 :                     ASSERT_not_null(currentScope);</span></a>
<a name="13416"><span class="lineNum">   13416 </span>            :                  // generateNestedTraversalWithExplicitScope(type,currentScope,currentStatement,initializedName);</a>
<a name="13417"><span class="lineNum">   13417 </span><span class="lineNoCov">          0 :                     generateNestedTraversalWithExplicitScope(pointerMemberType,currentScope,currentStatement,referenceToType);</span></a>
<a name="13418"><span class="lineNum">   13418 </span>            : #endif</a>
<a name="13419"><span class="lineNum">   13419 </span>            :                  // DQ (4/19/2019): It might be that we should call this after the traveral over each type instead of before we traverse the type.</a>
<a name="13420"><span class="lineNum">   13420 </span>            :                  // This way we save the correctly computed string for each type after the different parts of name qualificaiton are in place.</a>
<a name="13421"><span class="lineNum">   13421 </span>            :                  // traverseType(initializedName-&gt;get_type(),initializedName,currentScope,currentStatement);</a>
<a name="13422"><span class="lineNum">   13422 </span><span class="lineNoCov">          0 :                     traverseType(pointerMemberType,referenceToType,currentScope,currentStatement);</span></a>
<a name="13423"><span class="lineNum">   13423 </span>            : #if 0</a>
<a name="13424"><span class="lineNum">   13424 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;###################################################################################### \n&quot;);</a>
<a name="13425"><span class="lineNum">   13425 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Case SgNewExp, SgCastExp, SgSizeOfOp, SgTypeIdOp: DONE: Processing the associated type \n&quot;);</a>
<a name="13426"><span class="lineNum">   13426 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;###################################################################################### \n&quot;);</a>
<a name="13427"><span class="lineNum">   13427 </span>            : #endif</a>
<a name="13428"><span class="lineNum">   13428 </span>            : </a>
<a name="13429"><span class="lineNum">   13429 </span>            : #if 0</a>
<a name="13430"><span class="lineNum">   13430 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="13431"><span class="lineNum">   13431 </span>            :                     ROSE_ABORT();</a>
<a name="13432"><span class="lineNum">   13432 </span>            : #endif</a>
<a name="13433"><span class="lineNum">   13433 </span>            : #endif</a>
<a name="13434"><span class="lineNum">   13434 </span>            :                   }</a>
<a name="13435"><span class="lineNum">   13435 </span>            :                  else</a>
<a name="13436"><span class="lineNum">   13436 </span>            :                   {</a>
<a name="13437"><span class="lineNum">   13437 </span>            : #if 0</a>
<a name="13438"><span class="lineNum">   13438 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Case SgNewExp, SgCastExp, SgSizeOfOp, SgTypeIdOp: This is not a SgPointerMemberType \n&quot;);</a>
<a name="13439"><span class="lineNum">   13439 </span>            : #endif</a>
<a name="13440"><span class="lineNum">   13440 </span>            : #if 0</a>
<a name="13441"><span class="lineNum">   13441 </span>            :                  // DQ (4/27/2019): This brace should be extended to include the code below which is supporting the non-SgPointerMemberType.</a>
<a name="13442"><span class="lineNum">   13442 </span>            :                   }</a>
<a name="13443"><span class="lineNum">   13443 </span>            : #endif</a>
<a name="13444"><span class="lineNum">   13444 </span>            : </a>
<a name="13445"><span class="lineNum">   13445 </span>            :                  // DQ (4/27/2019): Turn on this code that was previously disabled (does not address SgPointerMemberType support requirements.</a>
<a name="13446"><span class="lineNum">   13446 </span>            : #if 1</a>
<a name="13447"><span class="lineNum">   13447 </span>            :                  // SgDeclarationStatement* associatedTypeDeclaration = associatedDeclaration(qualifiedType);</a>
<a name="13448"><span class="lineNum">   13448 </span><span class="lineCov">      21768 :                     if (associatedTypeDeclaration != NULL)</span></a>
<a name="13449"><span class="lineNum">   13449 </span>            :                        {</a>
<a name="13450"><span class="lineNum">   13450 </span>            : #if 0</a>
<a name="13451"><span class="lineNum">   13451 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;##################################################################################### \n&quot;);</a>
<a name="13452"><span class="lineNum">   13452 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;Case SgExpression: containing reference to type: processing associatedTypeDeclaration \n&quot;);</a>
<a name="13453"><span class="lineNum">   13453 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;##################################################################################### \n&quot;);</a>
<a name="13454"><span class="lineNum">   13454 </span>            : #endif</a>
<a name="13455"><span class="lineNum">   13455 </span>            : #if 0</a>
<a name="13456"><span class="lineNum">   13456 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;associatedTypeDeclaration = %p = %s = %s \n&quot;,associatedTypeDeclaration,</a>
<a name="13457"><span class="lineNum">   13457 </span>            :                               associatedTypeDeclaration-&gt;class_name().c_str(),SageInterface::get_name(associatedTypeDeclaration).c_str());</a>
<a name="13458"><span class="lineNum">   13458 </span>            : #endif</a>
<a name="13459"><span class="lineNum">   13459 </span><span class="lineCov">       8824 :                          SgStatement* currentStatement = TransformationSupport::getStatement(n);</span></a>
<a name="13460"><span class="lineNum">   13460 </span>            : </a>
<a name="13461"><span class="lineNum">   13461 </span>            :                       // ASSERT_not_null(currentStatement);</a>
<a name="13462"><span class="lineNum">   13462 </span><span class="lineCov">       8824 :                          if (currentStatement != NULL)</span></a>
<a name="13463"><span class="lineNum">   13463 </span>            :                             {</a>
<a name="13464"><span class="lineNum">   13464 </span><span class="lineCov">       8779 :                               SgScopeStatement* currentScope = currentStatement-&gt;get_scope();</span></a>
<a name="13465"><span class="lineNum">   13465 </span><span class="lineCov">       8779 :                               if (currentScope != NULL)</span></a>
<a name="13466"><span class="lineNum">   13466 </span>            :                                  {</a>
<a name="13467"><span class="lineNum">   13467 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="13468"><span class="lineNum">   13468 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;INFO: currentStatement = %p (%s)\n&quot;, currentStatement, currentStatement-&gt;class_name().c_str());</a>
<a name="13469"><span class="lineNum">   13469 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;INFO: currentScope     = %p (%s)\n&quot;, currentScope, currentScope-&gt;class_name().c_str());</a>
<a name="13470"><span class="lineNum">   13470 </span>            : #endif</a>
<a name="13471"><span class="lineNum">   13471 </span>            : </a>
<a name="13472"><span class="lineNum">   13472 </span><span class="lineCov">       8779 :                                    int amountOfNameQualificationRequiredForType = nameQualificationDepth(associatedTypeDeclaration,currentScope,currentStatement);</span></a>
<a name="13473"><span class="lineNum">   13473 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="13474"><span class="lineNum">   13474 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;SgExpression (name = %s) type: amountOfNameQualificationRequiredForType = %d \n&quot;,referenceToType-&gt;class_name().c_str(),amountOfNameQualificationRequiredForType);</a>
<a name="13475"><span class="lineNum">   13475 </span>            : #endif</a>
<a name="13476"><span class="lineNum">   13476 </span><span class="lineCov">       8779 :                                    setNameQualification(referenceToType,associatedTypeDeclaration,amountOfNameQualificationRequiredForType);</span></a>
<a name="13477"><span class="lineNum">   13477 </span>            : #if 0</a>
<a name="13478"><span class="lineNum">   13478 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;Calling traverseType on referenceToType = %p = %s \n&quot;,referenceToType,referenceToType-&gt;class_name().c_str());</a>
<a name="13479"><span class="lineNum">   13479 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;Calling traverseType on qualifiedType   = %p = %s \n&quot;,qualifiedType,qualifiedType-&gt;class_name().c_str());</a>
<a name="13480"><span class="lineNum">   13480 </span>            : #endif</a>
<a name="13481"><span class="lineNum">   13481 </span>            :                                 // DQ (6/3/2011): Traverse the type to set any possible template arguments (or other subtypes?) that require name qualification.</a>
<a name="13482"><span class="lineNum">   13482 </span><span class="lineCov">       8779 :                                    traverseType(qualifiedType,referenceToType,currentScope,currentStatement);</span></a>
<a name="13483"><span class="lineNum">   13483 </span>            : #if 0</a>
<a name="13484"><span class="lineNum">   13484 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="13485"><span class="lineNum">   13485 </span>            :                                    ROSE_ABORT();</a>
<a name="13486"><span class="lineNum">   13486 </span>            : #endif</a>
<a name="13487"><span class="lineNum">   13487 </span>            :                                  }</a>
<a name="13488"><span class="lineNum">   13488 </span>            :                                 else</a>
<a name="13489"><span class="lineNum">   13489 </span>            :                                  {</a>
<a name="13490"><span class="lineNum">   13490 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="13491"><span class="lineNum">   13491 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;WARNING: currentStatement-&gt;get_scope() == NULL for case of referenceToType = %p = %s \n&quot;,referenceToType,referenceToType-&gt;class_name().c_str());</a>
<a name="13492"><span class="lineNum">   13492 </span>            : #endif</a>
<a name="13493"><span class="lineNum">   13493 </span>            :                                  }</a>
<a name="13494"><span class="lineNum">   13494 </span>            :                             }</a>
<a name="13495"><span class="lineNum">   13495 </span>            :                            else</a>
<a name="13496"><span class="lineNum">   13496 </span>            :                             {</a>
<a name="13497"><span class="lineNum">   13497 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="13498"><span class="lineNum">   13498 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;WARNING: currentStatement == NULL for case of referenceToType = %p = %s \n&quot;,referenceToType,referenceToType-&gt;class_name().c_str());</a>
<a name="13499"><span class="lineNum">   13499 </span>            : #endif</a>
<a name="13500"><span class="lineNum">   13500 </span>            :                             }</a>
<a name="13501"><span class="lineNum">   13501 </span>            :                        }</a>
<a name="13502"><span class="lineNum">   13502 </span>            :                       else</a>
<a name="13503"><span class="lineNum">   13503 </span>            :                        {</a>
<a name="13504"><span class="lineNum">   13504 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="13505"><span class="lineNum">   13505 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;Note: associatedTypeDeclaration == NULL in SgExpression for name qualification support! referenceToType = %s \n&quot;,referenceToType-&gt;class_name().c_str());</a>
<a name="13506"><span class="lineNum">   13506 </span>            : #endif</a>
<a name="13507"><span class="lineNum">   13507 </span>            :                        }</a>
<a name="13508"><span class="lineNum">   13508 </span>            : #endif</a>
<a name="13509"><span class="lineNum">   13509 </span>            : #if 1</a>
<a name="13510"><span class="lineNum">   13510 </span>            :                  // DQ (4/27/2019): This has been moved from above since it should be extended to include this code which is supporting the non-SgPointerMemberType.</a>
<a name="13511"><span class="lineNum">   13511 </span>            :                   }</a>
<a name="13512"><span class="lineNum">   13512 </span>            : #endif</a>
<a name="13513"><span class="lineNum">   13513 </span>            :              }</a>
<a name="13514"><span class="lineNum">   13514 </span>            :             else</a>
<a name="13515"><span class="lineNum">   13515 </span>            :              {</a>
<a name="13516"><span class="lineNum">   13516 </span>            :             // DQ (4/21/2019): We can skip this because it was not a type (likely an expression, which will be traversed next).</a>
<a name="13517"><span class="lineNum">   13517 </span>            :              }</a>
<a name="13518"><span class="lineNum">   13518 </span>            : #if 0</a>
<a name="13519"><span class="lineNum">   13519 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="13520"><span class="lineNum">   13520 </span>            :           ROSE_ABORT();</a>
<a name="13521"><span class="lineNum">   13521 </span>            : #endif</a>
<a name="13522"><span class="lineNum">   13522 </span>            :         }</a>
<a name="13523"><span class="lineNum">   13523 </span>            : </a>
<a name="13524"><span class="lineNum">   13524 </span>            : </a>
<a name="13525"><span class="lineNum">   13525 </span>            :   // DQ (6/21/2011): Added support for name qualification of expressions contained in originalExpressionTree's where they are stored.</a>
<a name="13526"><span class="lineNum">   13526 </span><span class="lineCov">    2810440 :      SgExpression* expression = isSgExpression(n);</span></a>
<a name="13527"><span class="lineNum">   13527 </span><span class="lineCov">    2810440 :      if (expression != NULL)</span></a>
<a name="13528"><span class="lineNum">   13528 </span>            :         {</a>
<a name="13529"><span class="lineNum">   13529 </span><span class="lineCov">     303852 :           SgExpression* originalExpressionTree = expression-&gt;get_originalExpressionTree();</span></a>
<a name="13530"><span class="lineNum">   13530 </span><span class="lineCov">     303852 :           if (originalExpressionTree != NULL)</span></a>
<a name="13531"><span class="lineNum">   13531 </span>            :              {</a>
<a name="13532"><span class="lineNum">   13532 </span>            : #if 0</a>
<a name="13533"><span class="lineNum">   13533 </span>            :             // DQ (7/23/2011): I don't think this code is required or executed (testing this!)</a>
<a name="13534"><span class="lineNum">   13534 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;I don't think this is executed since original expression tree's are traversed as part of the AST \n&quot;);</a>
<a name="13535"><span class="lineNum">   13535 </span>            :                ROSE_ABORT();</a>
<a name="13536"><span class="lineNum">   13536 </span>            : #endif</a>
<a name="13537"><span class="lineNum">   13537 </span>            :             // Note that we have to pass the local copy of the referencedNameSet so that the same set will be used for all recursive calls (see test2011_89.C).</a>
<a name="13538"><span class="lineNum">   13538 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="13539"><span class="lineNum">   13539 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;@@@@@@@@@@@@@ Recursive call to the originalExpressionTree = %p = %s \n&quot;,originalExpressionTree,originalExpressionTree-&gt;class_name().c_str());</a>
<a name="13540"><span class="lineNum">   13540 </span>            : #endif</a>
<a name="13541"><span class="lineNum">   13541 </span><span class="lineNoCov">          0 :                SgStatement* currentStatement = TransformationSupport::getStatement(n);</span></a>
<a name="13542"><span class="lineNum">   13542 </span>            :             // DQ (9/14/2015): Added debugging code.</a>
<a name="13543"><span class="lineNum">   13543 </span>            :             // DQ (9/14/2015): This can be an expression in a type, in which case we don't have an associated scope.</a>
<a name="13544"><span class="lineNum">   13544 </span><span class="lineNoCov">          0 :                if (currentStatement == NULL)</span></a>
<a name="13545"><span class="lineNum">   13545 </span>            :                   {</a>
<a name="13546"><span class="lineNum">   13546 </span>            :                  // This can be an expression in a type, in which case we don't have an associated scope.</a>
<a name="13547"><span class="lineNum">   13547 </span>            : #if 0</a>
<a name="13548"><span class="lineNum">   13548 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Note: This can be an expression in a type, in which case we don't have an associated scope: expression = %p = %s originalExpressionTree = %p = %s \n&quot;,</a>
<a name="13549"><span class="lineNum">   13549 </span>            :                          expression,expression-&gt;class_name().c_str(),originalExpressionTree,originalExpressionTree-&gt;class_name().c_str());</a>
<a name="13550"><span class="lineNum">   13550 </span>            : #endif</a>
<a name="13551"><span class="lineNum">   13551 </span>            :                   }</a>
<a name="13552"><span class="lineNum">   13552 </span>            :                  else</a>
<a name="13553"><span class="lineNum">   13553 </span>            :                   {</a>
<a name="13554"><span class="lineNum">   13554 </span><span class="lineNoCov">          0 :                     ASSERT_not_null(currentStatement);</span></a>
<a name="13555"><span class="lineNum">   13555 </span><span class="lineNoCov">          0 :                     SgScopeStatement* currentScope = currentStatement-&gt;get_scope();</span></a>
<a name="13556"><span class="lineNum">   13556 </span><span class="lineNoCov">          0 :                     ASSERT_not_null(currentScope);</span></a>
<a name="13557"><span class="lineNum">   13557 </span>            : </a>
<a name="13558"><span class="lineNum">   13558 </span><span class="lineNoCov">          0 :                     generateNestedTraversalWithExplicitScope(originalExpressionTree,currentScope);</span></a>
<a name="13559"><span class="lineNum">   13559 </span>            :                   }</a>
<a name="13560"><span class="lineNum">   13560 </span>            : </a>
<a name="13561"><span class="lineNum">   13561 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="13562"><span class="lineNum">   13562 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;@@@@@@@@@@@@@ DONE: Recursive call to the originalExpressionTree = %p = %s \n&quot;,originalExpressionTree,originalExpressionTree-&gt;class_name().c_str());</a>
<a name="13563"><span class="lineNum">   13563 </span>            : #endif</a>
<a name="13564"><span class="lineNum">   13564 </span>            :              }</a>
<a name="13565"><span class="lineNum">   13565 </span>            :         }</a>
<a name="13566"><span class="lineNum">   13566 </span>            : </a>
<a name="13567"><span class="lineNum">   13567 </span>            :   // DQ (6/25/2011): Added support for use from unparseToString().</a>
<a name="13568"><span class="lineNum">   13568 </span>            :   // I don't think that we need this case since the unparser handles the case of using</a>
<a name="13569"><span class="lineNum">   13569 </span>            :   // the fully qualified name directly when called from the unparseToString() function.</a>
<a name="13570"><span class="lineNum">   13570 </span><span class="lineCov">    2810440 :      SgType* type = isSgType(n);</span></a>
<a name="13571"><span class="lineNum">   13571 </span><span class="lineCov">    2810440 :      if (type != NULL)</span></a>
<a name="13572"><span class="lineNum">   13572 </span>            :         {</a>
<a name="13573"><span class="lineNum">   13573 </span>            : #if 0</a>
<a name="13574"><span class="lineNum">   13574 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Found a type in the evaluation of name qualification type = %p = %s \n&quot;,type,type-&gt;class_name().c_str());</a>
<a name="13575"><span class="lineNum">   13575 </span>            : #endif</a>
<a name="13576"><span class="lineNum">   13576 </span>            :        // void NameQualificationTraversal::traverseType ( SgType* type, SgNode* nodeReferenceToType, SgScopeStatement* currentScope, SgStatement* positionStatement )</a>
<a name="13577"><span class="lineNum">   13577 </span>            :        // SgNode* nodeReferenceToType    = NULL;</a>
<a name="13578"><span class="lineNum">   13578 </span>            :        // SgScopeStatement* currentScope = NULL;</a>
<a name="13579"><span class="lineNum">   13579 </span>            :        // SgStatement* positionStatement = NULL;</a>
<a name="13580"><span class="lineNum">   13580 </span>            :        // traverseType(type,initializedName,currentScope,currentStatement);</a>
<a name="13581"><span class="lineNum">   13581 </span>            :         }</a>
<a name="13582"><span class="lineNum">   13582 </span>            : </a>
<a name="13583"><span class="lineNum">   13583 </span>            :   // ******************************************************************************</a>
<a name="13584"><span class="lineNum">   13584 </span>            :   // Now that this declaration is processed, mark it as being seen (place into set).</a>
<a name="13585"><span class="lineNum">   13585 </span>            :   // ******************************************************************************</a>
<a name="13586"><span class="lineNum">   13586 </span>            : </a>
<a name="13587"><span class="lineNum">   13587 </span>            :   // DQ (2/13/2019): I think that this kind of declaration was not previously processed for name qualification.</a>
<a name="13588"><span class="lineNum">   13588 </span>            :   // Likely missed because enums previously could not have a prototype declaration (but can under C++11).</a>
<a name="13589"><span class="lineNum">   13589 </span><span class="lineCov">    2810440 :      SgEnumDeclaration* enumDeclaration = isSgEnumDeclaration(n);</span></a>
<a name="13590"><span class="lineNum">   13590 </span><span class="lineCov">    2810440 :      if (enumDeclaration != NULL)</span></a>
<a name="13591"><span class="lineNum">   13591 </span>            :         {</a>
<a name="13592"><span class="lineNum">   13592 </span>            : #if 0</a>
<a name="13593"><span class="lineNum">   13593 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Case of SgEnumDeclaration: enumDeclaration              = %p \n&quot;,enumDeclaration);</a>
<a name="13594"><span class="lineNum">   13594 </span>            :           mfprintf(mlog [ WARN ] ) (&quot; --- enumDeclaration-&gt;get_firstNondefiningDeclaration() = %p \n&quot;,enumDeclaration-&gt;get_firstNondefiningDeclaration());</a>
<a name="13595"><span class="lineNum">   13595 </span>            :           mfprintf(mlog [ WARN ] ) (&quot; --- enumDeclaration-&gt;get_definingDeclaration()         = %p \n&quot;,enumDeclaration-&gt;get_definingDeclaration());</a>
<a name="13596"><span class="lineNum">   13596 </span>            : #endif</a>
<a name="13597"><span class="lineNum">   13597 </span>            :        // We need the structural location in scope (not the semantic one).</a>
<a name="13598"><span class="lineNum">   13598 </span><span class="lineCov">        909 :           SgScopeStatement* currentScope = isSgScopeStatement(enumDeclaration-&gt;get_parent());</span></a>
<a name="13599"><span class="lineNum">   13599 </span>            : </a>
<a name="13600"><span class="lineNum">   13600 </span><span class="lineCov">        909 :           if (currentScope == NULL)</span></a>
<a name="13601"><span class="lineNum">   13601 </span>            :              {</a>
<a name="13602"><span class="lineNum">   13602 </span>            :             // DQ (2/18/2019): Adding support for when the SgEnumDeclaration is defined in another declaration (e.g. SgTypedefDeclaration).</a>
<a name="13603"><span class="lineNum">   13603 </span><span class="lineCov">         30 :                SgNode* parent = enumDeclaration-&gt;get_parent();</span></a>
<a name="13604"><span class="lineNum">   13604 </span><span class="lineCov">         30 :                SgTypedefDeclaration* typedefDeclaration = isSgTypedefDeclaration(parent);</span></a>
<a name="13605"><span class="lineNum">   13605 </span><span class="lineCov">         30 :                if (typedefDeclaration != NULL)</span></a>
<a name="13606"><span class="lineNum">   13606 </span>            :                   {</a>
<a name="13607"><span class="lineNum">   13607 </span><span class="lineCov">         29 :                     currentScope = isSgScopeStatement(typedefDeclaration-&gt;get_parent());</span></a>
<a name="13608"><span class="lineNum">   13608 </span>            : </a>
<a name="13609"><span class="lineNum">   13609 </span>            :                  // DQ (2/18/2019): We should have a valid currentScope at this point.</a>
<a name="13610"><span class="lineNum">   13610 </span><span class="lineCov">         29 :                     if (currentScope == NULL)</span></a>
<a name="13611"><span class="lineNum">   13611 </span>            :                        {</a>
<a name="13612"><span class="lineNum">   13612 </span><span class="lineNoCov">          0 :                          mfprintf(mlog [ WARN ] ) (&quot;NOTE: Could not identify scope for enum declaration: parent = %p = %s \n&quot;,parent,parent-&gt;class_name().c_str());</span></a>
<a name="13613"><span class="lineNum">   13613 </span>            : #if 1</a>
<a name="13614"><span class="lineNum">   13614 </span><span class="lineNoCov">          0 :                          mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</span></a>
<a name="13615"><span class="lineNum">   13615 </span><span class="lineNoCov">          0 :                          ROSE_ABORT();</span></a>
<a name="13616"><span class="lineNum">   13616 </span>            : #endif</a>
<a name="13617"><span class="lineNum">   13617 </span>            :                        }</a>
<a name="13618"><span class="lineNum">   13618 </span>            :                       else</a>
<a name="13619"><span class="lineNum">   13619 </span>            :                        {</a>
<a name="13620"><span class="lineNum">   13620 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="13621"><span class="lineNum">   13621 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;Found SgEnumDeclaration in SgTypedefDeclaration: currentScope = %p = %s \n&quot;,currentScope,currentScope-&gt;class_name().c_str());</a>
<a name="13622"><span class="lineNum">   13622 </span>            : #endif</a>
<a name="13623"><span class="lineNum">   13623 </span>            :                        }</a>
<a name="13624"><span class="lineNum">   13624 </span>            :                   }</a>
<a name="13625"><span class="lineNum">   13625 </span>            :                  else</a>
<a name="13626"><span class="lineNum">   13626 </span>            :                   {</a>
<a name="13627"><span class="lineNum">   13627 </span>            :                  // DQ (2/19/2019): This is frequently a SgLambdaExp or a SgVariableDeclaration</a>
<a name="13628"><span class="lineNum">   13628 </span>            :                  // Computing the current scope does not always seem possible.</a>
<a name="13629"><span class="lineNum">   13629 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="13630"><span class="lineNum">   13630 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;In name qualification: Cannot compute a valid scope for the enumDeclaration = %p = %s \n&quot;,enumDeclaration,enumDeclaration-&gt;class_name().c_str());</a>
<a name="13631"><span class="lineNum">   13631 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot; --- parent = %p = %s \n&quot;,parent,parent-&gt;class_name().c_str());</a>
<a name="13632"><span class="lineNum">   13632 </span>            : #endif</a>
<a name="13633"><span class="lineNum">   13633 </span>            :                   }</a>
<a name="13634"><span class="lineNum">   13634 </span>            :              }</a>
<a name="13635"><span class="lineNum">   13635 </span>            : </a>
<a name="13636"><span class="lineNum">   13636 </span>            :        // ASSERT_not_null(currentScope);</a>
<a name="13637"><span class="lineNum">   13637 </span><span class="lineCov">        909 :           if (currentScope != NULL)</span></a>
<a name="13638"><span class="lineNum">   13638 </span>            :              {</a>
<a name="13639"><span class="lineNum">   13639 </span>            :             // Only use name qualification where the scopes of the declaration's use (currentScope) is not the same</a>
<a name="13640"><span class="lineNum">   13640 </span>            :             // as the scope of the class declaration.  However, the analysis should work and determin that the</a>
<a name="13641"><span class="lineNum">   13641 </span>            :             // required name qualification length is zero.</a>
<a name="13642"><span class="lineNum">   13642 </span>            : </a>
<a name="13643"><span class="lineNum">   13643 </span>            :             // DQ (7/22/2017): Refactored this code.</a>
<a name="13644"><span class="lineNum">   13644 </span><span class="lineCov">        908 :                SgScopeStatement* enum_scope = enumDeclaration-&gt;get_scope();</span></a>
<a name="13645"><span class="lineNum">   13645 </span>            : </a>
<a name="13646"><span class="lineNum">   13646 </span>            :             // DQ (7/22/2017): I think we can assert this.</a>
<a name="13647"><span class="lineNum">   13647 </span><span class="lineCov">        908 :                ASSERT_not_null(enum_scope);</span></a>
<a name="13648"><span class="lineNum">   13648 </span>            : #if 0</a>
<a name="13649"><span class="lineNum">   13649 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;currentScope                 = %p = %s \n&quot;,currentScope,currentScope-&gt;class_name().c_str());</a>
<a name="13650"><span class="lineNum">   13650 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;enumDeclaration-&gt;get_scope() = %p = %s \n&quot;,enum_scope,enum_scope-&gt;class_name().c_str());</a>
<a name="13651"><span class="lineNum">   13651 </span>            : #endif</a>
<a name="13652"><span class="lineNum">   13652 </span>            :             // if (currentScope != classDeclaration-&gt;get_scope())</a>
<a name="13653"><span class="lineNum">   13653 </span><span class="lineCov">        908 :                if (currentScope != enum_scope)</span></a>
<a name="13654"><span class="lineNum">   13654 </span>            :                   {</a>
<a name="13655"><span class="lineNum">   13655 </span>            :                  // DQ (1/21/2013): We should be able to assert this.</a>
<a name="13656"><span class="lineNum">   13656 </span><span class="lineCov">         57 :                     ASSERT_not_null(enumDeclaration-&gt;get_scope());</span></a>
<a name="13657"><span class="lineNum">   13657 </span>            : </a>
<a name="13658"><span class="lineNum">   13658 </span>            :                  // DQ (1/21/2013): Added new static function to support testing for equivalent when the scopes are namespaces.</a>
<a name="13659"><span class="lineNum">   13659 </span><span class="lineCov">         57 :                     bool isSameNamespace = SgScopeStatement::isEquivalentScope(currentScope,enumDeclaration-&gt;get_scope());</span></a>
<a name="13660"><span class="lineNum">   13660 </span>            : </a>
<a name="13661"><span class="lineNum">   13661 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="13662"><span class="lineNum">   13662 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;isSameNamespace = %s \n&quot;,isSameNamespace ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="13663"><span class="lineNum">   13663 </span>            : #endif</a>
<a name="13664"><span class="lineNum">   13664 </span>            :                  // DQ (1/21/2013): Added code to support when equivalent namespaces are detected.</a>
<a name="13665"><span class="lineNum">   13665 </span><span class="lineCov">         57 :                     if (isSameNamespace == false)</span></a>
<a name="13666"><span class="lineNum">   13666 </span>            :                        {</a>
<a name="13667"><span class="lineNum">   13667 </span>            :                       // DQ (6/11/2013): Added test to make sure that name qualification is ignored for friend function where the class has not yet been seen.</a>
<a name="13668"><span class="lineNum">   13668 </span>            :                       // if (classDeclaration-&gt;get_declarationModifier().isFriend() == false)</a>
<a name="13669"><span class="lineNum">   13669 </span><span class="lineNoCov">          0 :                          SgDeclarationStatement* declarationForReferencedNameSet = enumDeclaration-&gt;get_firstNondefiningDeclaration();</span></a>
<a name="13670"><span class="lineNum">   13670 </span><span class="lineNoCov">          0 :                          ASSERT_not_null(declarationForReferencedNameSet);</span></a>
<a name="13671"><span class="lineNum">   13671 </span><span class="lineNoCov">          0 :                          if (referencedNameSet.find(declarationForReferencedNameSet) != referencedNameSet.end())</span></a>
<a name="13672"><span class="lineNum">   13672 </span>            :                             {</a>
<a name="13673"><span class="lineNum">   13673 </span><span class="lineNoCov">          0 :                               int amountOfNameQualificationRequired = nameQualificationDepth(enumDeclaration,currentScope,enumDeclaration);</span></a>
<a name="13674"><span class="lineNum">   13674 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="13675"><span class="lineNum">   13675 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;SgEnumDeclaration: amountOfNameQualificationRequired = %d \n&quot;,amountOfNameQualificationRequired);</a>
<a name="13676"><span class="lineNum">   13676 </span>            : #endif</a>
<a name="13677"><span class="lineNum">   13677 </span><span class="lineNoCov">          0 :                               setNameQualification(enumDeclaration,amountOfNameQualificationRequired);</span></a>
<a name="13678"><span class="lineNum">   13678 </span>            : #if 0</a>
<a name="13679"><span class="lineNum">   13679 </span>            :                               if (amountOfNameQualificationRequired &gt; 0)</a>
<a name="13680"><span class="lineNum">   13680 </span>            :                                  {</a>
<a name="13681"><span class="lineNum">   13681 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;Need setNameQualification() for SgEnumDeclaration \n&quot;);</a>
<a name="13682"><span class="lineNum">   13682 </span>            :                                    ROSE_ABORT();</a>
<a name="13683"><span class="lineNum">   13683 </span>            :                                  }</a>
<a name="13684"><span class="lineNum">   13684 </span>            : #endif</a>
<a name="13685"><span class="lineNum">   13685 </span>            :                             }</a>
<a name="13686"><span class="lineNum">   13686 </span>            :                            else</a>
<a name="13687"><span class="lineNum">   13687 </span>            :                             {</a>
<a name="13688"><span class="lineNum">   13688 </span>            :                            // DQ (2/12/2019): This branch is taken within Cxx11_tests/test2019_120.C where the associated</a>
<a name="13689"><span class="lineNum">   13689 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="13690"><span class="lineNum">   13690 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;This enumDeclaration has not been seen before so skip the name qualification \n&quot;);</a>
<a name="13691"><span class="lineNum">   13691 </span>            : #endif</a>
<a name="13692"><span class="lineNum">   13692 </span>            :                             }</a>
<a name="13693"><span class="lineNum">   13693 </span>            :                        }</a>
<a name="13694"><span class="lineNum">   13694 </span>            :                   }</a>
<a name="13695"><span class="lineNum">   13695 </span>            :                  else</a>
<a name="13696"><span class="lineNum">   13696 </span>            :                   {</a>
<a name="13697"><span class="lineNum">   13697 </span>            :                  // Don't know what test code exercises this case (see test2011_62.C).</a>
<a name="13698"><span class="lineNum">   13698 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="13699"><span class="lineNum">   13699 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;WARNING: SgEnumDeclaration -- currentScope is not available through predicate (currentScope != enumDeclaration-&gt;get_scope()), not clear why! \n&quot;);</a>
<a name="13700"><span class="lineNum">   13700 </span>            : #endif</a>
<a name="13701"><span class="lineNum">   13701 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="13702"><span class="lineNum">   13702 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Commenting out: enumDeclaration-&gt;get_parent() == enumDeclaration-&gt;get_scope() in name qualitication \n&quot;);</a>
<a name="13703"><span class="lineNum">   13703 </span>            :                  // ROSE_ASSERT(classDeclaration-&gt;get_parent() == classDeclaration-&gt;get_scope());</a>
<a name="13704"><span class="lineNum">   13704 </span>            : #endif</a>
<a name="13705"><span class="lineNum">   13705 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="13706"><span class="lineNum">   13706 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;name qualification for enumDeclaration-&gt;get_scope()  = %p = %s \n&quot;,enumDeclaration-&gt;get_scope(),enumDeclaration-&gt;get_scope()-&gt;class_name().c_str());</a>
<a name="13707"><span class="lineNum">   13707 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;enumDeclaration-&gt;get_parent()                        = %p = %s \n&quot;,enumDeclaration-&gt;get_parent(),enumDeclaration-&gt;get_parent()-&gt;class_name().c_str());</a>
<a name="13708"><span class="lineNum">   13708 </span>            : #endif</a>
<a name="13709"><span class="lineNum">   13709 </span>            :                  // ROSE_ASSERT(false);</a>
<a name="13710"><span class="lineNum">   13710 </span>            : </a>
<a name="13711"><span class="lineNum">   13711 </span>            :                  // DQ (7/22/2017): I think the template arguments name qualification can be required, but is ignored.</a>
<a name="13712"><span class="lineNum">   13712 </span>            : #if 0</a>
<a name="13713"><span class="lineNum">   13713 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;ERROR: When the scopes are the same we don't require name qualification on the template instnatiation, but it might still be required for it's template arguments! \n&quot;);</a>
<a name="13714"><span class="lineNum">   13714 </span>            : #endif</a>
<a name="13715"><span class="lineNum">   13715 </span>            :                  // DQ (7/22/2017): I think the template arguments name qualification can be required. This fixes test2017_56.C.</a>
<a name="13716"><span class="lineNum">   13716 </span><span class="lineCov">        851 :                     int amountOfNameQualificationRequired = nameQualificationDepth(enumDeclaration,currentScope,enumDeclaration);</span></a>
<a name="13717"><span class="lineNum">   13717 </span>            : #if 0</a>
<a name="13718"><span class="lineNum">   13718 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;For this case: force amountOfNameQualificationRequired == 0: previously amountOfNameQualificationRequired = %d \n&quot;,amountOfNameQualificationRequired);</a>
<a name="13719"><span class="lineNum">   13719 </span>            : #endif</a>
<a name="13720"><span class="lineNum">   13720 </span>            :                  // We only really wanted to make sure that any template arguments were properly name qualified.</a>
<a name="13721"><span class="lineNum">   13721 </span><span class="lineCov">        851 :                     amountOfNameQualificationRequired = 0;</span></a>
<a name="13722"><span class="lineNum">   13722 </span>            : </a>
<a name="13723"><span class="lineNum">   13723 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="13724"><span class="lineNum">   13724 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;NEW CASE: currentScope != enumDeclaration-&gt;get_scope(): SgEnumDeclaration: amountOfNameQualificationRequired = %d \n&quot;,amountOfNameQualificationRequired);</a>
<a name="13725"><span class="lineNum">   13725 </span>            : #endif</a>
<a name="13726"><span class="lineNum">   13726 </span><span class="lineCov">        851 :                     setNameQualification(enumDeclaration,amountOfNameQualificationRequired);</span></a>
<a name="13727"><span class="lineNum">   13727 </span>            : #if 0</a>
<a name="13728"><span class="lineNum">   13728 </span>            :                  // DQ (5/30/2019): uncomment this code as part of debugging only.</a>
<a name="13729"><span class="lineNum">   13729 </span>            :                     if (amountOfNameQualificationRequired &gt; 0)</a>
<a name="13730"><span class="lineNum">   13730 </span>            :                        {</a>
<a name="13731"><span class="lineNum">   13731 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;Need setNameQualification() for SgEnumDeclaration \n&quot;);</a>
<a name="13732"><span class="lineNum">   13732 </span>            :                          ROSE_ABORT();</a>
<a name="13733"><span class="lineNum">   13733 </span>            :                        }</a>
<a name="13734"><span class="lineNum">   13734 </span>            : #endif</a>
<a name="13735"><span class="lineNum">   13735 </span>            :                   }</a>
<a name="13736"><span class="lineNum">   13736 </span>            :              }</a>
<a name="13737"><span class="lineNum">   13737 </span>            :             else</a>
<a name="13738"><span class="lineNum">   13738 </span>            :              {</a>
<a name="13739"><span class="lineNum">   13739 </span>            :             // DQ (2/13/2019): I think this can happen if the enum declaration is in a typedef declaration</a>
<a name="13740"><span class="lineNum">   13740 </span>            :             // or parameter list, etc (less common places to find enum declarations).</a>
<a name="13741"><span class="lineNum">   13741 </span>            : </a>
<a name="13742"><span class="lineNum">   13742 </span>            :             // NOTE: Cxx_tests/test2019_125.C demonstrates where this kind of enum requires name qualification.</a>
<a name="13743"><span class="lineNum">   13743 </span>            : </a>
<a name="13744"><span class="lineNum">   13744 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="13745"><span class="lineNum">   13745 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;WARNING: SgEnumDeclaration -- currentScope is not available, not clear why! \n&quot;);</a>
<a name="13746"><span class="lineNum">   13746 </span>            : #endif</a>
<a name="13747"><span class="lineNum">   13747 </span>            : #if 0</a>
<a name="13748"><span class="lineNum">   13748 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;@@@@@@@@@@@@@@@@@@@ Cannot determine current scope for SgEnumDeclaration (likely a enum in a typedef declaration) \n&quot;);</a>
<a name="13749"><span class="lineNum">   13749 </span>            : #endif</a>
<a name="13750"><span class="lineNum">   13750 </span>            :             // enumDeclaration-&gt;get_file_info()-&gt;display(&quot;Cannot determine current scope for SgEnumDeclaration&quot;);</a>
<a name="13751"><span class="lineNum">   13751 </span>            : </a>
<a name="13752"><span class="lineNum">   13752 </span><span class="lineCov">          1 :                SgDeclarationStatement* outerDeclaration = isSgDeclarationStatement(enumDeclaration-&gt;get_parent());</span></a>
<a name="13753"><span class="lineNum">   13753 </span><span class="lineCov">          1 :                ASSERT_not_null(outerDeclaration);</span></a>
<a name="13754"><span class="lineNum">   13754 </span><span class="lineCov">          1 :                currentScope = isSgScopeStatement(outerDeclaration-&gt;get_parent());</span></a>
<a name="13755"><span class="lineNum">   13755 </span><span class="lineCov">          1 :                ASSERT_not_null(currentScope);</span></a>
<a name="13756"><span class="lineNum">   13756 </span>            : </a>
<a name="13757"><span class="lineNum">   13757 </span><span class="lineCov">          1 :                int amountOfNameQualificationRequired = nameQualificationDepth(enumDeclaration,currentScope,enumDeclaration);</span></a>
<a name="13758"><span class="lineNum">   13758 </span>            : </a>
<a name="13759"><span class="lineNum">   13759 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="13760"><span class="lineNum">   13760 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;NEW CASE: currentScope != enumDeclaration-&gt;get_scope(): SgEnumDeclaration: amountOfNameQualificationRequired = %d \n&quot;,amountOfNameQualificationRequired);</a>
<a name="13761"><span class="lineNum">   13761 </span>            : #endif</a>
<a name="13762"><span class="lineNum">   13762 </span><span class="lineCov">          1 :                setNameQualification(enumDeclaration,amountOfNameQualificationRequired);</span></a>
<a name="13763"><span class="lineNum">   13763 </span>            : </a>
<a name="13764"><span class="lineNum">   13764 </span>            :             // DQ (2/13/2019): Make this an error for now!</a>
<a name="13765"><span class="lineNum">   13765 </span>            :             // ROSE_ASSERT(false);</a>
<a name="13766"><span class="lineNum">   13766 </span>            :              }</a>
<a name="13767"><span class="lineNum">   13767 </span>            : </a>
<a name="13768"><span class="lineNum">   13768 </span>            : #if 0</a>
<a name="13769"><span class="lineNum">   13769 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test (case of SgEnumDeclaration) \n&quot;);</a>
<a name="13770"><span class="lineNum">   13770 </span>            :           ROSE_ABORT();</a>
<a name="13771"><span class="lineNum">   13771 </span>            : #endif</a>
<a name="13772"><span class="lineNum">   13772 </span>            :         }</a>
<a name="13773"><span class="lineNum">   13773 </span>            : </a>
<a name="13774"><span class="lineNum">   13774 </span>            : </a>
<a name="13775"><span class="lineNum">   13775 </span><span class="lineCov">    2810440 :      SgDeclarationStatement* declaration = isSgDeclarationStatement(n);</span></a>
<a name="13776"><span class="lineNum">   13776 </span><span class="lineCov">    2810440 :      if (declaration != NULL)</span></a>
<a name="13777"><span class="lineNum">   13777 </span>            :         {</a>
<a name="13778"><span class="lineNum">   13778 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="13779"><span class="lineNum">   13779 </span>            :           printf (&quot;$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ \n&quot;);</a>
<a name="13780"><span class="lineNum">   13780 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Found a SgDeclarationStatement in the evaluation of name qualification declaration = %p = %s \n&quot;,declaration,declaration-&gt;class_name().c_str());</a>
<a name="13781"><span class="lineNum">   13781 </span>            :           printf (&quot;$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ \n&quot;);</a>
<a name="13782"><span class="lineNum">   13782 </span>            : #endif</a>
<a name="13783"><span class="lineNum">   13783 </span>            :        // If this is a declaration of something that has a name then we need to mark it as having been seen.</a>
<a name="13784"><span class="lineNum">   13784 </span>            : </a>
<a name="13785"><span class="lineNum">   13785 </span>            :        // In some cases of C++ name qualification depending on if the defining declaration (or a forward</a>
<a name="13786"><span class="lineNum">   13786 </span>            :        // declaration is in a scope that would define the declaration to a scope where the declaration could be</a>
<a name="13787"><span class="lineNum">   13787 </span>            :        // present).  This detail is handled by reporting if such a declaration has been seen yet.  Since the</a>
<a name="13788"><span class="lineNum">   13788 </span>            :        // preorder traversal is the same as the traversal used in the unparsing it is sufficient to record</a>
<a name="13789"><span class="lineNum">   13789 </span>            :        // the order of the processing here and not complicate the unparser directly.  Note that the use of</a>
<a name="13790"><span class="lineNum">   13790 </span>            :        // function declarations follow these rules and so are a problem when the prototype is defined in a</a>
<a name="13791"><span class="lineNum">   13791 </span>            :        // function (where it does not communicate the defining declarations location) instead of in a global</a>
<a name="13792"><span class="lineNum">   13792 </span>            :        // scope or namespace scope (where it does appear to communicate its position.</a>
<a name="13793"><span class="lineNum">   13793 </span>            : </a>
<a name="13794"><span class="lineNum">   13794 </span>            :        // SgDeclarationStatement* firstNondefiningDeclaration   = declaration-&gt;get_firstNondefiningDeclaration();</a>
<a name="13795"><span class="lineNum">   13795 </span><span class="lineCov">     936844 :           SgDeclarationStatement* declarationForReferencedNameSet = declaration-&gt;get_firstNondefiningDeclaration();</span></a>
<a name="13796"><span class="lineNum">   13796 </span>            :        // ROSE_ASSERT(declarationForReferencedNameSet == NULL);</a>
<a name="13797"><span class="lineNum">   13797 </span>            :        // declarationForReferencedNameSet = declaration-&gt;get_firstNondefiningDeclaration();</a>
<a name="13798"><span class="lineNum">   13798 </span>            : </a>
<a name="13799"><span class="lineNum">   13799 </span><span class="lineCov">     936844 :           if (declarationForReferencedNameSet == NULL)</span></a>
<a name="13800"><span class="lineNum">   13800 </span>            :              {</a>
<a name="13801"><span class="lineNum">   13801 </span>            :             // Note that a function with only a defining declaration will not have a nondefining declaration</a>
<a name="13802"><span class="lineNum">   13802 </span>            :             // automatically constructed in the AST (unlike classes and some other sorts of declarations).</a>
<a name="13803"><span class="lineNum">   13803 </span><span class="lineNoCov">          0 :                declarationForReferencedNameSet = declaration-&gt;get_definingDeclaration();</span></a>
<a name="13804"><span class="lineNum">   13804 </span>            : </a>
<a name="13805"><span class="lineNum">   13805 </span>            :             // DQ (6/22/2011): I think this is true.  This assertion fails for test2006_78.C (a template example code).</a>
<a name="13806"><span class="lineNum">   13806 </span>            :             // ROSE_ASSERT(declarationForReferencedNameSet == declaration);</a>
<a name="13807"><span class="lineNum">   13807 </span>            : </a>
<a name="13808"><span class="lineNum">   13808 </span>            :             // DQ (6/23/2011): This assertion fails for the LoopProcessor on tests/nonsmoke/functional/roseTests/loopProcessingTests/mm.C</a>
<a name="13809"><span class="lineNum">   13809 </span>            :             // ASSERT_not_null(declarationForReferencedNameSet);</a>
<a name="13810"><span class="lineNum">   13810 </span><span class="lineNoCov">          0 :                if (declarationForReferencedNameSet == NULL)</span></a>
<a name="13811"><span class="lineNum">   13811 </span>            :                   {</a>
<a name="13812"><span class="lineNum">   13812 </span><span class="lineNoCov">          0 :                     declarationForReferencedNameSet = declaration;</span></a>
<a name="13813"><span class="lineNum">   13813 </span><span class="lineNoCov">          0 :                     ASSERT_not_null(declarationForReferencedNameSet);</span></a>
<a name="13814"><span class="lineNum">   13814 </span>            :                   }</a>
<a name="13815"><span class="lineNum">   13815 </span><span class="lineNoCov">          0 :                ASSERT_not_null(declarationForReferencedNameSet);</span></a>
<a name="13816"><span class="lineNum">   13816 </span>            :              }</a>
<a name="13817"><span class="lineNum">   13817 </span><span class="lineCov">     936844 :           ASSERT_not_null(declarationForReferencedNameSet);</span></a>
<a name="13818"><span class="lineNum">   13818 </span>            : #if 0</a>
<a name="13819"><span class="lineNum">   13819 </span>            :        // ASSERT_not_null(firstNondefiningDeclaration);</a>
<a name="13820"><span class="lineNum">   13820 </span>            :           if (firstNondefiningDeclaration == NULL)</a>
<a name="13821"><span class="lineNum">   13821 </span>            :              {</a>
<a name="13822"><span class="lineNum">   13822 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;WARNING: declaration-&gt;get_firstNondefiningDeclaration() == NULL for declaration = %p = %s \n&quot;,declaration,declaration-&gt;class_name().c_str());</a>
<a name="13823"><span class="lineNum">   13823 </span>            :              }</a>
<a name="13824"><span class="lineNum">   13824 </span>            : #endif</a>
<a name="13825"><span class="lineNum">   13825 </span>            :        // Look at each declaration, but as soon as we find an acceptable one put the declarationForReferencedNameSet</a>
<a name="13826"><span class="lineNum">   13826 </span>            :        // into the set so that we can search on a uniform representation of the declaration. Note that we want the</a>
<a name="13827"><span class="lineNum">   13827 </span>            :        // scope of where it is located and not it's scope if it were name qualified...</a>
<a name="13828"><span class="lineNum">   13828 </span>            :        // SgScopeStatement* scopeOfNondefiningDeclaration = isSgScopeStatement(firstNondefiningDeclaration-&gt;get_parent());</a>
<a name="13829"><span class="lineNum">   13829 </span><span class="lineCov">     936844 :           ASSERT_not_null(declaration-&gt;get_parent());</span></a>
<a name="13830"><span class="lineNum">   13830 </span><span class="lineCov">     936844 :           SgScopeStatement* scopeOfDeclaration = isSgScopeStatement(declaration-&gt;get_parent());</span></a>
<a name="13831"><span class="lineNum">   13831 </span>            : </a>
<a name="13832"><span class="lineNum">   13832 </span>            :        // DQ (5/19/2017): added support for test2017_39.C (SgTemplateInstantiationDirectiveStatement support).</a>
<a name="13833"><span class="lineNum">   13833 </span>            :        // In this case the SgTemplateInstantiation is a declaration hidden inside of the SgTemplateInstantiationDirectiveStatement.</a>
<a name="13834"><span class="lineNum">   13834 </span><span class="lineCov">     936844 :           SgTemplateInstantiationDirectiveStatement* templateInstantiationDirective = isSgTemplateInstantiationDirectiveStatement(declaration-&gt;get_parent());</span></a>
<a name="13835"><span class="lineNum">   13835 </span><span class="lineCov">     936844 :           if (templateInstantiationDirective != NULL)</span></a>
<a name="13836"><span class="lineNum">   13836 </span>            :              {</a>
<a name="13837"><span class="lineNum">   13837 </span><span class="lineCov">        996 :                scopeOfDeclaration = isSgScopeStatement(templateInstantiationDirective-&gt;get_parent());</span></a>
<a name="13838"><span class="lineNum">   13838 </span><span class="lineCov">        996 :                ASSERT_not_null(scopeOfDeclaration);</span></a>
<a name="13839"><span class="lineNum">   13839 </span>            : </a>
<a name="13840"><span class="lineNum">   13840 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="13841"><span class="lineNum">   13841 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;************* Found SgTemplateInstantiationDirectiveStatement: reset scope to that of the template instantiation directive: scope = %p = %s  \n&quot;,</a>
<a name="13842"><span class="lineNum">   13842 </span>            :                     scopeOfDeclaration,scopeOfDeclaration-&gt;class_name().c_str());</a>
<a name="13843"><span class="lineNum">   13843 </span>            : #endif</a>
<a name="13844"><span class="lineNum">   13844 </span>            :              }</a>
<a name="13845"><span class="lineNum">   13845 </span>            : </a>
<a name="13846"><span class="lineNum">   13846 </span><span class="lineCov">     936844 :           bool acceptableDeclarationScope = false;</span></a>
<a name="13847"><span class="lineNum">   13847 </span>            : </a>
<a name="13848"><span class="lineNum">   13848 </span>            :        // I think that some declarations might not appear in a scope properly (e.g pointer to function, etc.)</a>
<a name="13849"><span class="lineNum">   13849 </span>            :        // ASSERT_not_null(scopeOfNondefiningDeclaration);</a>
<a name="13850"><span class="lineNum">   13850 </span><span class="lineCov">     936844 :           if (scopeOfDeclaration != NULL)</span></a>
<a name="13851"><span class="lineNum">   13851 </span>            :              {</a>
<a name="13852"><span class="lineNum">   13852 </span><span class="lineCov">     349508 :                switch(scopeOfDeclaration-&gt;variantT())</span></a>
<a name="13853"><span class="lineNum">   13853 </span>            :                   {</a>
<a name="13854"><span class="lineNum">   13854 </span>            :                  // At least this case is not allowed.</a>
<a name="13855"><span class="lineNum">   13855 </span>            :                     case V_SgBasicBlock: acceptableDeclarationScope = false;</a>
<a name="13856"><span class="lineNum">   13856 </span>            :                          break;</a>
<a name="13857"><span class="lineNum">   13857 </span>            : </a>
<a name="13858"><span class="lineNum">   13858 </span>            :                  // Everything else is OK!</a>
<a name="13859"><span class="lineNum">   13859 </span>            :                  // DQ (6/22/2011): Note that a declaration in a typedef is an acceptable scope under some cases (not clear on the limits of this case).</a>
<a name="13860"><span class="lineNum">   13860 </span><span class="lineCov">     341166 :                     default:</span></a>
<a name="13861"><span class="lineNum">   13861 </span><span class="lineCov">     341166 :                        {</span></a>
<a name="13862"><span class="lineNum">   13862 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="13863"><span class="lineNum">   13863 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;scopeOfNondefiningDeclaration = %p = %s \n&quot;,scopeOfDeclaration,scopeOfDeclaration-&gt;class_name().c_str());</a>
<a name="13864"><span class="lineNum">   13864 </span>            : #endif</a>
<a name="13865"><span class="lineNum">   13865 </span><span class="lineCov">     341166 :                          acceptableDeclarationScope = true;</span></a>
<a name="13866"><span class="lineNum">   13866 </span>            :                        }</a>
<a name="13867"><span class="lineNum">   13867 </span>            :                   }</a>
<a name="13868"><span class="lineNum">   13868 </span>            :              }</a>
<a name="13869"><span class="lineNum">   13869 </span>            :             else</a>
<a name="13870"><span class="lineNum">   13870 </span>            :              {</a>
<a name="13871"><span class="lineNum">   13871 </span>            :             // This appears to fail for something in rose_edg_required_macros_and_functions.h.</a>
<a name="13872"><span class="lineNum">   13872 </span>            : </a>
<a name="13873"><span class="lineNum">   13873 </span>            :             // DQ (2/18/2019): This case happens when an enum declaration is contained as the base type in a typedef declaration.</a>
<a name="13874"><span class="lineNum">   13874 </span>            :             // In which case the scope is just the scope of the enclosing typedef declaration.</a>
<a name="13875"><span class="lineNum">   13875 </span><span class="lineCov">     587336 :                SgNode* parent = declaration-&gt;get_parent();</span></a>
<a name="13876"><span class="lineNum">   13876 </span>            : </a>
<a name="13877"><span class="lineNum">   13877 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || 0</a>
<a name="13878"><span class="lineNum">   13878 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;scopeOfDeclaration == NULL: declaration               = %p = %s \n&quot;,declaration,declaration-&gt;class_name().c_str());</a>
<a name="13879"><span class="lineNum">   13879 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;scopeOfDeclaration == NULL: declaration-&gt;get_parent() = %p = %s \n&quot;,parent,parent-&gt;class_name().c_str());</a>
<a name="13880"><span class="lineNum">   13880 </span>            : #endif</a>
<a name="13881"><span class="lineNum">   13881 </span>            : </a>
<a name="13882"><span class="lineNum">   13882 </span>            :             // DQ (2/18/2019): Chasing down all the things that can be the parent when the scope of a declaration computed via the parent is not clear.</a>
<a name="13883"><span class="lineNum">   13883 </span><span class="lineCov">     587336 :                SgTypedefDeclaration* typedefDeclaration = isSgTypedefDeclaration(parent);</span></a>
<a name="13884"><span class="lineNum">   13884 </span><span class="lineCov">     587336 :                if (typedefDeclaration != NULL)</span></a>
<a name="13885"><span class="lineNum">   13885 </span>            :                   {</a>
<a name="13886"><span class="lineNum">   13886 </span><span class="lineCov">        339 :                     scopeOfDeclaration = isSgScopeStatement(typedefDeclaration-&gt;get_parent());</span></a>
<a name="13887"><span class="lineNum">   13887 </span>            :                   }</a>
<a name="13888"><span class="lineNum">   13888 </span>            :                  else</a>
<a name="13889"><span class="lineNum">   13889 </span>            :                   {</a>
<a name="13890"><span class="lineNum">   13890 </span><span class="lineCov">     586997 :                     SgFunctionDeclaration* functionDeclaration = isSgFunctionDeclaration(parent);</span></a>
<a name="13891"><span class="lineNum">   13891 </span><span class="lineCov">     586997 :                     if (functionDeclaration != NULL)</span></a>
<a name="13892"><span class="lineNum">   13892 </span>            :                        {</a>
<a name="13893"><span class="lineNum">   13893 </span><span class="lineCov">     586609 :                          ASSERT_not_null(functionDeclaration);</span></a>
<a name="13894"><span class="lineNum">   13894 </span><span class="lineCov">     586609 :                          scopeOfDeclaration = isSgScopeStatement(functionDeclaration-&gt;get_parent());</span></a>
<a name="13895"><span class="lineNum">   13895 </span>            :                          if (scopeOfDeclaration == NULL)</a>
<a name="13896"><span class="lineNum">   13896 </span>            :                             {</a>
<a name="13897"><span class="lineNum">   13897 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || 0</a>
<a name="13898"><span class="lineNum">   13898 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;test 1: SgFunctionDeclaration: scopeOfDeclaration == NULL: cannot support name qualification: functionDeclaration-&gt;get_parent() = %p = %s \n&quot;,</a>
<a name="13899"><span class="lineNum">   13899 </span>            :                                    functionDeclaration-&gt;get_parent(),functionDeclaration-&gt;get_parent()-&gt;class_name().c_str());</a>
<a name="13900"><span class="lineNum">   13900 </span>            : #endif</a>
<a name="13901"><span class="lineNum">   13901 </span>            :                             }</a>
<a name="13902"><span class="lineNum">   13902 </span>            :                        }</a>
<a name="13903"><span class="lineNum">   13903 </span>            :                       else</a>
<a name="13904"><span class="lineNum">   13904 </span>            :                        {</a>
<a name="13905"><span class="lineNum">   13905 </span><span class="lineCov">        388 :                          SgFunctionParameterList* functionParameterList = isSgFunctionParameterList(parent);</span></a>
<a name="13906"><span class="lineNum">   13906 </span><span class="lineCov">        388 :                          if (functionParameterList != NULL)</span></a>
<a name="13907"><span class="lineNum">   13907 </span>            :                             {</a>
<a name="13908"><span class="lineNum">   13908 </span><span class="lineNoCov">          0 :                               SgFunctionDeclaration* functionDeclaration = isSgFunctionDeclaration(functionParameterList-&gt;get_parent());</span></a>
<a name="13909"><span class="lineNum">   13909 </span><span class="lineNoCov">          0 :                               ASSERT_not_null(functionDeclaration);</span></a>
<a name="13910"><span class="lineNum">   13910 </span><span class="lineNoCov">          0 :                               scopeOfDeclaration = isSgScopeStatement(functionDeclaration-&gt;get_parent());</span></a>
<a name="13911"><span class="lineNum">   13911 </span>            :                               if (scopeOfDeclaration == NULL)</a>
<a name="13912"><span class="lineNum">   13912 </span>            :                                  {</a>
<a name="13913"><span class="lineNum">   13913 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || 0</a>
<a name="13914"><span class="lineNum">   13914 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;test 2: SgFunctionParameterList: SgFunctionDeclaration: scopeOfDeclaration == NULL: cannot support name qualification: functionDeclaration-&gt;get_parent() = %p = %s \n&quot;,</a>
<a name="13915"><span class="lineNum">   13915 </span>            :                                         functionDeclaration-&gt;get_parent(),functionDeclaration-&gt;get_parent()-&gt;class_name().c_str());</a>
<a name="13916"><span class="lineNum">   13916 </span>            : #endif</a>
<a name="13917"><span class="lineNum">   13917 </span>            :                                  }</a>
<a name="13918"><span class="lineNum">   13918 </span>            :                             }</a>
<a name="13919"><span class="lineNum">   13919 </span>            :                        }</a>
<a name="13920"><span class="lineNum">   13920 </span>            :                   }</a>
<a name="13921"><span class="lineNum">   13921 </span>            : </a>
<a name="13922"><span class="lineNum">   13922 </span>            :                if (scopeOfDeclaration == NULL)</a>
<a name="13923"><span class="lineNum">   13923 </span>            :                   {</a>
<a name="13924"><span class="lineNum">   13924 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || 0</a>
<a name="13925"><span class="lineNum">   13925 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;scopeOfDeclaration == NULL: Could not identify scope of declaration to support name qualification: parent = %p = %s \n&quot;,parent,parent-&gt;class_name().c_str());</a>
<a name="13926"><span class="lineNum">   13926 </span>            : #endif</a>
<a name="13927"><span class="lineNum">   13927 </span>            : #if 0</a>
<a name="13928"><span class="lineNum">   13928 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="13929"><span class="lineNum">   13929 </span>            :                     ROSE_ABORT();</a>
<a name="13930"><span class="lineNum">   13930 </span>            : #endif</a>
<a name="13931"><span class="lineNum">   13931 </span>            :                   }</a>
<a name="13932"><span class="lineNum">   13932 </span>            :                  else</a>
<a name="13933"><span class="lineNum">   13933 </span>            :                   {</a>
<a name="13934"><span class="lineNum">   13934 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="13935"><span class="lineNum">   13935 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;lost scope: scopeOfDeclaration = %p = %s \n&quot;,scopeOfDeclaration,scopeOfDeclaration-&gt;class_name().c_str());</a>
<a name="13936"><span class="lineNum">   13936 </span>            : #endif</a>
<a name="13937"><span class="lineNum">   13937 </span>            :                   }</a>
<a name="13938"><span class="lineNum">   13938 </span>            : </a>
<a name="13939"><span class="lineNum">   13939 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="13940"><span class="lineNum">   13940 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;I hope that we can make this an error (scopeOfDeclaration == NULL) declaration = %p = %s declaration-&gt;get_parent() = %p = %s \n&quot;,</a>
<a name="13941"><span class="lineNum">   13941 </span>            :                     declaration,declaration-&gt;class_name().c_str(),declaration-&gt;get_parent(),declaration-&gt;get_parent()-&gt;class_name().c_str());</a>
<a name="13942"><span class="lineNum">   13942 </span>            : #endif</a>
<a name="13943"><span class="lineNum">   13943 </span>            :             // ROSE_ASSERT(false);</a>
<a name="13944"><span class="lineNum">   13944 </span>            :              }</a>
<a name="13945"><span class="lineNum">   13945 </span>            : #if 0</a>
<a name="13946"><span class="lineNum">   13946 </span>            :           printf (&quot;acceptableDeclarationScope                                                         = %s \n&quot;,acceptableDeclarationScope ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="13947"><span class="lineNum">   13947 </span>            :           printf (&quot;referencedNameSet.find(declarationForReferencedNameSet) == referencedNameSet.end() = %s \n&quot;,referencedNameSet.find(declarationForReferencedNameSet) == referencedNameSet.end() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="13948"><span class="lineNum">   13948 </span>            : #endif</a>
<a name="13949"><span class="lineNum">   13949 </span><span class="lineCov">     936844 :           ASSERT_not_null(declarationForReferencedNameSet);</span></a>
<a name="13950"><span class="lineNum">   13950 </span>            :        // if (referencedNameSet.find(firstNondefiningDeclaration) == referencedNameSet.end())</a>
<a name="13951"><span class="lineNum">   13951 </span>            :        // if (acceptableDeclarationScope == true &amp;&amp; firstNondefiningDeclaration != NULL &amp;&amp; referencedNameSet.find(firstNondefiningDeclaration) == referencedNameSet.end())</a>
<a name="13952"><span class="lineNum">   13952 </span><span class="lineCov">    1278010 :           if (acceptableDeclarationScope == true &amp;&amp; referencedNameSet.find(declarationForReferencedNameSet) == referencedNameSet.end())</span></a>
<a name="13953"><span class="lineNum">   13953 </span>            :              {</a>
<a name="13954"><span class="lineNum">   13954 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="13955"><span class="lineNum">   13955 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Adding declarationForReferencedNameSet = %p = %s to set of visited declarations \n&quot;,declarationForReferencedNameSet,declarationForReferencedNameSet-&gt;class_name().c_str());</a>
<a name="13956"><span class="lineNum">   13956 </span>            : #endif</a>
<a name="13957"><span class="lineNum">   13957 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="13958"><span class="lineNum">   13958 </span>            :                printf (&quot;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ \n&quot;);</a>
<a name="13959"><span class="lineNum">   13959 </span>            :                printf (&quot;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ \n&quot;);</a>
<a name="13960"><span class="lineNum">   13960 </span>            :                printf (&quot;INSERTING INTO referencedNameSet: declarationForReferencedNameSet = %p = %s name = %s \n&quot;,</a>
<a name="13961"><span class="lineNum">   13961 </span>            :                     declarationForReferencedNameSet,declarationForReferencedNameSet-&gt;class_name().c_str(),SageInterface::get_name(declarationForReferencedNameSet).c_str());</a>
<a name="13962"><span class="lineNum">   13962 </span>            :                printf (&quot; --- Could have used: declaration = %p = %s name = %s \n&quot;,declaration,declaration-&gt;class_name().c_str(),SageInterface::get_name(declaration).c_str());</a>
<a name="13963"><span class="lineNum">   13963 </span>            :                printf (&quot;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ \n&quot;);</a>
<a name="13964"><span class="lineNum">   13964 </span>            :                printf (&quot;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ \n&quot;);</a>
<a name="13965"><span class="lineNum">   13965 </span>            : #endif</a>
<a name="13966"><span class="lineNum">   13966 </span><span class="lineCov">     260362 :                referencedNameSet.insert(declarationForReferencedNameSet);</span></a>
<a name="13967"><span class="lineNum">   13967 </span>            :              }</a>
<a name="13968"><span class="lineNum">   13968 </span>            :             else</a>
<a name="13969"><span class="lineNum">   13969 </span>            :              {</a>
<a name="13970"><span class="lineNum">   13970 </span>            :             // mfprintf(mlog [ WARN ] ) (&quot;firstNondefiningDeclaration = %p NOT added to referencedNameSet \n&quot;,firstNondefiningDeclaration);</a>
<a name="13971"><span class="lineNum">   13971 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="13972"><span class="lineNum">   13972 </span>            :                printf (&quot;$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ \n&quot;);</a>
<a name="13973"><span class="lineNum">   13973 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;declarationForReferencedNameSet = %p NOT added to referencedNameSet \n&quot;,declarationForReferencedNameSet);</a>
<a name="13974"><span class="lineNum">   13974 </span>            :                printf (&quot;$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ \n&quot;);</a>
<a name="13975"><span class="lineNum">   13975 </span>            : #endif</a>
<a name="13976"><span class="lineNum">   13976 </span>            :              }</a>
<a name="13977"><span class="lineNum">   13977 </span>            :         }</a>
<a name="13978"><span class="lineNum">   13978 </span>            : </a>
<a name="13979"><span class="lineNum">   13979 </span>            :   // DQ (7/12/2014): Add any possible nodes that can generate SgAliasSymbols to the SgSymbolTable::p_aliasSymbolCausalNodeSet SgNodeSet.</a>
<a name="13980"><span class="lineNum">   13980 </span>            :   // This is used by the symbol table to know when to use or ignore SgAliasSymbols in symbol table lookups.</a>
<a name="13981"><span class="lineNum">   13981 </span><span class="lineCov">    2810440 :      if (isSgUsingDirectiveStatement(n) != NULL || isSgUsingDeclarationStatement(n) != NULL || isSgBaseClass(n) != NULL)</span></a>
<a name="13982"><span class="lineNum">   13982 </span>            :         {</a>
<a name="13983"><span class="lineNum">   13983 </span>            :        // SgNodeSet &amp; get_aliasSymbolCausalNodeSet()</a>
<a name="13984"><span class="lineNum">   13984 </span>            : </a>
<a name="13985"><span class="lineNum">   13985 </span><span class="lineCov">       3330 :           SgSymbolTable::get_aliasSymbolCausalNodeSet().insert(n);</span></a>
<a name="13986"><span class="lineNum">   13986 </span>            : </a>
<a name="13987"><span class="lineNum">   13987 </span>            : #if 0</a>
<a name="13988"><span class="lineNum">   13988 </span>            :        // DQ (8/3/2019): Output the aliasSymbolCausalNodeSet.  To support multiple files, or the stame file read twice,</a>
<a name="13989"><span class="lineNum">   13989 </span>            :        // we need to clear this set before starting the name qualification process.</a>
<a name="13990"><span class="lineNum">   13990 </span>            :           SgSymbolTable::display_aliasSymbolCausalNodeSet();</a>
<a name="13991"><span class="lineNum">   13991 </span>            : #endif</a>
<a name="13992"><span class="lineNum">   13992 </span>            : #if 0</a>
<a name="13993"><span class="lineNum">   13993 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="13994"><span class="lineNum">   13994 </span>            :           ROSE_ABORT();</a>
<a name="13995"><span class="lineNum">   13995 </span>            : #endif</a>
<a name="13996"><span class="lineNum">   13996 </span>            : </a>
<a name="13997"><span class="lineNum">   13997 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="13998"><span class="lineNum">   13998 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::evaluateInheritedAttribute(): Added SgAliasSymbols causal node = %p = %s to SgSymbolTable::p_aliasSymbolCausalNodeSet size = %&quot; PRIuPTR &quot; \n&quot;,</a>
<a name="13999"><span class="lineNum">   13999 </span>            :                n,n-&gt;class_name().c_str(),SgSymbolTable::get_aliasSymbolCausalNodeSet().size());</a>
<a name="14000"><span class="lineNum">   14000 </span>            : #endif</a>
<a name="14001"><span class="lineNum">   14001 </span>            : </a>
<a name="14002"><span class="lineNum">   14002 </span>            : #if 1</a>
<a name="14003"><span class="lineNum">   14003 </span>            :        // DQ (12/23/2015): This does not appear to have any effect (the SgBaseClass is not traversed in the AST).</a>
<a name="14004"><span class="lineNum">   14004 </span><span class="lineCov">       3330 :           if (isSgBaseClass(n) != NULL)</span></a>
<a name="14005"><span class="lineNum">   14005 </span>            :              {</a>
<a name="14006"><span class="lineNum">   14006 </span><span class="lineNoCov">          0 :                mfprintf(mlog [ WARN ] ) (&quot;NameQualificationTraversal::evaluateInheritedAttribute(): Identified SgBaseClass in traversal \n&quot;);</span></a>
<a name="14007"><span class="lineNum">   14007 </span><span class="lineNoCov">          0 :                ROSE_ABORT();</span></a>
<a name="14008"><span class="lineNum">   14008 </span>            :              }</a>
<a name="14009"><span class="lineNum">   14009 </span>            : #endif</a>
<a name="14010"><span class="lineNum">   14010 </span>            :         }</a>
<a name="14011"><span class="lineNum">   14011 </span>            : </a>
<a name="14012"><span class="lineNum">   14012 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="14013"><span class="lineNum">   14013 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;****************************************************** \n&quot;);</a>
<a name="14014"><span class="lineNum">   14014 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;Leaving NameQualificationTraversal::evaluateInheritedAttribute(): node = %p = %s \n&quot;,n,n-&gt;class_name().c_str());</a>
<a name="14015"><span class="lineNum">   14015 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;******************************************************\n\n\n&quot;);</a>
<a name="14016"><span class="lineNum">   14016 </span>            : #endif</a>
<a name="14017"><span class="lineNum">   14017 </span>            : #if 0</a>
<a name="14018"><span class="lineNum">   14018 </span>            :      SgLocatedNode* locatedNode = isSgLocatedNode(n);</a>
<a name="14019"><span class="lineNum">   14019 </span>            :      if (locatedNode != NULL)</a>
<a name="14020"><span class="lineNum">   14020 </span>            :         {</a>
<a name="14021"><span class="lineNum">   14021 </span>            :           locatedNode-&gt;get_file_info()-&gt;display(&quot;Leaving NameQualificationTraversal::evaluateInheritedAttribute()&quot;);</a>
<a name="14022"><span class="lineNum">   14022 </span>            :         }</a>
<a name="14023"><span class="lineNum">   14023 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;******************************************************\n\n\n&quot;);</a>
<a name="14024"><span class="lineNum">   14024 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;******************************************************\n\n\n&quot;);</a>
<a name="14025"><span class="lineNum">   14025 </span>            : #endif</a>
<a name="14026"><span class="lineNum">   14026 </span>            : </a>
<a name="14027"><span class="lineNum">   14027 </span><span class="lineCov">    2810440 :      return NameQualificationInheritedAttribute(inheritedAttribute);</span></a>
<a name="14028"><span class="lineNum">   14028 </span>            :    }</a>
<a name="14029"><span class="lineNum">   14029 </span>            : </a>
<a name="14030"><span class="lineNum">   14030 </span>            : </a>
<a name="14031"><span class="lineNum">   14031 </span>            : NameQualificationSynthesizedAttribute</a>
<a name="14032"><span class="lineNum">   14032 </span><span class="lineCov">    2810440 : NameQualificationTraversal::evaluateSynthesizedAttribute(SgNode* n, NameQualificationInheritedAttribute inheritedAttribute, SynthesizedAttributesList synthesizedAttributeList)</span></a>
<a name="14033"><span class="lineNum">   14033 </span>            :    {</a>
<a name="14034"><span class="lineNum">   14034 </span>            :   // This is not used now but will likely be used later.</a>
<a name="14035"><span class="lineNum">   14035 </span>            :   // NameQualificationSynthesizedAttribute returnAttribute;</a>
<a name="14036"><span class="lineNum">   14036 </span><span class="lineCov">    2810440 :      NameQualificationSynthesizedAttribute returnAttribute(n);</span></a>
<a name="14037"><span class="lineNum">   14037 </span>            : </a>
<a name="14038"><span class="lineNum">   14038 </span>            :   // DQ (8/2/2020): Added assertion.</a>
<a name="14039"><span class="lineNum">   14039 </span><span class="lineCov">    2810440 :      ROSE_ASSERT(n != NULL);</span></a>
<a name="14040"><span class="lineNum">   14040 </span>            : </a>
<a name="14041"><span class="lineNum">   14041 </span>            : // #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="14042"><span class="lineNum">   14042 </span>            : #if 0</a>
<a name="14043"><span class="lineNum">   14043 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;\n\n****************************************************** \n&quot;);</a>
<a name="14044"><span class="lineNum">   14044 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;****************************************************** \n&quot;);</a>
<a name="14045"><span class="lineNum">   14045 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;Inside of NameQualificationTraversal::evaluateSynthesizedAttribute(): node = %p = %s = %s \n&quot;,n,n-&gt;class_name().c_str(),SageInterface::get_name(n).c_str());</a>
<a name="14046"><span class="lineNum">   14046 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;****************************************************** \n&quot;);</a>
<a name="14047"><span class="lineNum">   14047 </span>            : #endif</a>
<a name="14048"><span class="lineNum">   14048 </span>            : </a>
<a name="14049"><span class="lineNum">   14049 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="14050"><span class="lineNum">   14050 </span>            :   // DQ (6/23/2013): Output the generated name with required name qualification for debugging.</a>
<a name="14051"><span class="lineNum">   14051 </span>            :      switch(n-&gt;variantT())</a>
<a name="14052"><span class="lineNum">   14052 </span>            :         {</a>
<a name="14053"><span class="lineNum">   14053 </span>            :        // DQ (8/19/2013): Added case to support debugging.</a>
<a name="14054"><span class="lineNum">   14054 </span>            :           case V_SgConstructorInitializer:</a>
<a name="14055"><span class="lineNum">   14055 </span>            : </a>
<a name="14056"><span class="lineNum">   14056 </span>            :           case V_SgMemberFunctionRefExp:</a>
<a name="14057"><span class="lineNum">   14057 </span>            :              {</a>
<a name="14058"><span class="lineNum">   14058 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;************************************************************************************** \n&quot;);</a>
<a name="14059"><span class="lineNum">   14059 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;In evaluateSynthesizedAttribute(): node = %p = %s node-&gt;unparseToString() = %s \n&quot;,n,n-&gt;class_name().c_str(),n-&gt;unparseToString().c_str());</a>
<a name="14060"><span class="lineNum">   14060 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;************************************************************************************** \n&quot;);</a>
<a name="14061"><span class="lineNum">   14061 </span>            :                break;</a>
<a name="14062"><span class="lineNum">   14062 </span>            :              }</a>
<a name="14063"><span class="lineNum">   14063 </span>            : </a>
<a name="14064"><span class="lineNum">   14064 </span>            :           default:</a>
<a name="14065"><span class="lineNum">   14065 </span>            :              {</a>
<a name="14066"><span class="lineNum">   14066 </span>            :             // do nothing</a>
<a name="14067"><span class="lineNum">   14067 </span>            :              }</a>
<a name="14068"><span class="lineNum">   14068 </span>            :         }</a>
<a name="14069"><span class="lineNum">   14069 </span>            : #endif</a>
<a name="14070"><span class="lineNum">   14070 </span>            : </a>
<a name="14071"><span class="lineNum">   14071 </span>            : #if 0</a>
<a name="14072"><span class="lineNum">   14072 </span>            :   // DQ (2/13/2017): This will report progress through the global scope.</a>
<a name="14073"><span class="lineNum">   14073 </span>            :      if (SgProject::get_verbose() &gt;= 0)</a>
<a name="14074"><span class="lineNum">   14074 </span>            :        {</a>
<a name="14075"><span class="lineNum">   14075 </span>            :          SgDeclarationStatement* declarationStatement = isSgDeclarationStatement(n);</a>
<a name="14076"><span class="lineNum">   14076 </span>            :          SgDeclarationStatement* definingDeclarationStatement = NULL;</a>
<a name="14077"><span class="lineNum">   14077 </span>            :          if (declarationStatement != NULL)</a>
<a name="14078"><span class="lineNum">   14078 </span>            :             {</a>
<a name="14079"><span class="lineNum">   14079 </span>            : #if 0</a>
<a name="14080"><span class="lineNum">   14080 </span>            :               mfprintf(mlog [ WARN ] ) (&quot;Name qualification progress (synthesized attribute): test: declarationStatement = %p = %s \n&quot;,declarationStatement,declarationStatement-&gt;class_name().c_str());</a>
<a name="14081"><span class="lineNum">   14081 </span>            : #endif</a>
<a name="14082"><span class="lineNum">   14082 </span>            :               definingDeclarationStatement = declarationStatement-&gt;get_definingDeclaration();</a>
<a name="14083"><span class="lineNum">   14083 </span>            :             }</a>
<a name="14084"><span class="lineNum">   14084 </span>            :          if (declarationStatement != NULL &amp;&amp; declarationStatement == definingDeclarationStatement)</a>
<a name="14085"><span class="lineNum">   14085 </span>            :             {</a>
<a name="14086"><span class="lineNum">   14086 </span>            :            // This is the defining declaration</a>
<a name="14087"><span class="lineNum">   14087 </span>            :               mfprintf(mlog [ WARN ] ) (&quot;Name qualification progress (synthesized attribute): declarationStatement = %p = %s \n&quot;,declarationStatement,declarationStatement-&gt;class_name().c_str());</a>
<a name="14088"><span class="lineNum">   14088 </span>            :               string filename = declarationStatement-&gt;get_file_info()-&gt;get_filename();</a>
<a name="14089"><span class="lineNum">   14089 </span>            :               int linenumber  = declarationStatement-&gt;get_file_info()-&gt;get_line();</a>
<a name="14090"><span class="lineNum">   14090 </span>            :               mfprintf(mlog [ WARN ] ) (&quot;--- filename = %s line = %d \n&quot;,filename.c_str(),linenumber);</a>
<a name="14091"><span class="lineNum">   14091 </span>            :             }</a>
<a name="14092"><span class="lineNum">   14092 </span>            :          SgTypedefDeclaration* typedefDeclaration = isSgTypedefDeclaration(n);</a>
<a name="14093"><span class="lineNum">   14093 </span>            :          if (typedefDeclaration != NULL)</a>
<a name="14094"><span class="lineNum">   14094 </span>            :             {</a>
<a name="14095"><span class="lineNum">   14095 </span>            :               mfprintf(mlog [ WARN ] ) (&quot;Name qualification progress (synthesized attribute): typedefDeclaration = %p = %s name = %s \n&quot;,typedefDeclaration,typedefDeclaration-&gt;class_name().c_str(),typedefDeclaration-&gt;get_name().str());</a>
<a name="14096"><span class="lineNum">   14096 </span>            :             }</a>
<a name="14097"><span class="lineNum">   14097 </span>            :        }</a>
<a name="14098"><span class="lineNum">   14098 </span>            : #endif</a>
<a name="14099"><span class="lineNum">   14099 </span>            : </a>
<a name="14100"><span class="lineNum">   14100 </span>            : </a>
<a name="14101"><span class="lineNum">   14101 </span>            :   // DQ (4/21/2019): We need to compute the final generated string for the type from the parts that</a>
<a name="14102"><span class="lineNum">   14102 </span>            :   // have been constructed from the type traversal in the evaluation of the inherited attribute.</a>
<a name="14103"><span class="lineNum">   14103 </span>            :   // This we should not miss type modifieres in between the referenceNode and the SgPointerMemberType</a>
<a name="14104"><span class="lineNum">   14104 </span>            :   // IR node (need to look into this).</a>
<a name="14105"><span class="lineNum">   14105 </span>            : #if 0</a>
<a name="14106"><span class="lineNum">   14106 </span>            :      SgPointerMemberType* pointerMemberType = isSgPointerMemberType(n);</a>
<a name="14107"><span class="lineNum">   14107 </span>            :      if (pointerMemberType != NULL)</a>
<a name="14108"><span class="lineNum">   14108 </span>            :         {</a>
<a name="14109"><span class="lineNum">   14109 </span>            : #if 0</a>
<a name="14110"><span class="lineNum">   14110 </span>            :        // DQ (4/21/2019): I think this must be called on in the evaluateSythesisedAttribute traversal,</a>
<a name="14111"><span class="lineNum">   14111 </span>            :        // since it requires that the string results already be computed for nested types (visited first</a>
<a name="14112"><span class="lineNum">   14112 </span>            :        // in the evaluation of the inherited attributes)</a>
<a name="14113"><span class="lineNum">   14113 </span>            : #if 0</a>
<a name="14114"><span class="lineNum">   14114 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;################################################################################### \n&quot;);</a>
<a name="14115"><span class="lineNum">   14115 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;In evaluateSynthesizedAttribute(): Case SgPointerMemberType: Calling traverseType() \n&quot;);</a>
<a name="14116"><span class="lineNum">   14116 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;################################################################################### \n&quot;);</a>
<a name="14117"><span class="lineNum">   14117 </span>            : #endif</a>
<a name="14118"><span class="lineNum">   14118 </span>            : </a>
<a name="14119"><span class="lineNum">   14119 </span>            :        // NOTE: We might also just call this once when n is the same as a saved referenceNode.</a>
<a name="14120"><span class="lineNum">   14120 </span>            :           SgNode* referenceNode = inheritedAttribute.get_referenceNode();</a>
<a name="14121"><span class="lineNum">   14121 </span>            :           ASSERT_not_null(referenceNode);</a>
<a name="14122"><span class="lineNum">   14122 </span>            : </a>
<a name="14123"><span class="lineNum">   14123 </span>            :           SgScopeStatement* currentScope = inheritedAttribute.get_currentScope();</a>
<a name="14124"><span class="lineNum">   14124 </span>            :           ASSERT_not_null(currentScope);</a>
<a name="14125"><span class="lineNum">   14125 </span>            : </a>
<a name="14126"><span class="lineNum">   14126 </span>            :           SgStatement* currentStatement = inheritedAttribute.get_currentStatement();</a>
<a name="14127"><span class="lineNum">   14127 </span>            :           ASSERT_not_null(currentStatement);</a>
<a name="14128"><span class="lineNum">   14128 </span>            : #if 0</a>
<a name="14129"><span class="lineNum">   14129 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;In evaluateSynthesizedAttribute(): Case SgPointerMemberType: referenceNode    = %p = %s \n&quot;,referenceNode,referenceNode-&gt;class_name().c_str());</a>
<a name="14130"><span class="lineNum">   14130 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;In evaluateSynthesizedAttribute(): Case SgPointerMemberType: currentScope     = %p = %s \n&quot;,currentScope,currentScope-&gt;class_name().c_str());</a>
<a name="14131"><span class="lineNum">   14131 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;In evaluateSynthesizedAttribute(): Case SgPointerMemberType: currentStatement = %p = %s \n&quot;,currentStatement,currentStatement-&gt;class_name().c_str());</a>
<a name="14132"><span class="lineNum">   14132 </span>            : #endif</a>
<a name="14133"><span class="lineNum">   14133 </span>            :        // SgNode*           referenceNode    = NULL;</a>
<a name="14134"><span class="lineNum">   14134 </span>            :        // SgScopeStatement* currentScope     = NULL;</a>
<a name="14135"><span class="lineNum">   14135 </span>            :        // SgStatement*      currentStatement = NULL;</a>
<a name="14136"><span class="lineNum">   14136 </span>            :        // ASSERT_not_null(referenceNode);</a>
<a name="14137"><span class="lineNum">   14137 </span>            :        // ASSERT_not_null(currentScope);</a>
<a name="14138"><span class="lineNum">   14138 </span>            :        // ASSERT_not_null(currentStatement);</a>
<a name="14139"><span class="lineNum">   14139 </span>            : </a>
<a name="14140"><span class="lineNum">   14140 </span>            :           traverseType(pointerMemberType,referenceNode,currentScope,currentStatement);</a>
<a name="14141"><span class="lineNum">   14141 </span>            : #endif</a>
<a name="14142"><span class="lineNum">   14142 </span>            : </a>
<a name="14143"><span class="lineNum">   14143 </span>            : #if 0</a>
<a name="14144"><span class="lineNum">   14144 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="14145"><span class="lineNum">   14145 </span>            :           ROSE_ABORT();</a>
<a name="14146"><span class="lineNum">   14146 </span>            : #endif</a>
<a name="14147"><span class="lineNum">   14147 </span>            :         }</a>
<a name="14148"><span class="lineNum">   14148 </span>            : #endif</a>
<a name="14149"><span class="lineNum">   14149 </span>            : </a>
<a name="14150"><span class="lineNum">   14150 </span>            :   // DQ (4/21/2019): I now think that we don't need this, but how is the referenceNode a SgPointerMemberType.</a>
<a name="14151"><span class="lineNum">   14151 </span>            :   // NOTE: We might also just call this once when n is the same as a saved referenceNode.</a>
<a name="14152"><span class="lineNum">   14152 </span><span class="lineCov">    2810440 :      SgNode* referenceNode = inheritedAttribute.get_referenceNode();</span></a>
<a name="14153"><span class="lineNum">   14153 </span><span class="lineCov">    2810440 :      if (n == referenceNode)</span></a>
<a name="14154"><span class="lineNum">   14154 </span>            :         {</a>
<a name="14155"><span class="lineNum">   14155 </span>            :        // DQ (4/21/2019): I think this must be called on in the evaluateSythesisedAttribute traversal,</a>
<a name="14156"><span class="lineNum">   14156 </span>            :        // since it requires that the string results already be computed for nested types (visited first</a>
<a name="14157"><span class="lineNum">   14157 </span>            :        // in the evaluation of the inherited attributes)</a>
<a name="14158"><span class="lineNum">   14158 </span>            : </a>
<a name="14159"><span class="lineNum">   14159 </span><span class="lineNoCov">          0 :           ASSERT_not_null(referenceNode);</span></a>
<a name="14160"><span class="lineNum">   14160 </span>            : #if 1</a>
<a name="14161"><span class="lineNum">   14161 </span><span class="lineNoCov">          0 :           mfprintf(mlog [ WARN ] ) (&quot;##################################################################################################################### \n&quot;);</span></a>
<a name="14162"><span class="lineNum">   14162 </span><span class="lineNoCov">          0 :           mfprintf(mlog [ WARN ] ) (&quot;In evaluateSynthesizedAttribute(): Case n == referenceNode: referenceNode = %p = %s: Calling traverseType() \n&quot;,referenceNode,referenceNode-&gt;class_name().c_str());</span></a>
<a name="14163"><span class="lineNum">   14163 </span><span class="lineNoCov">          0 :           mfprintf(mlog [ WARN ] ) (&quot;##################################################################################################################### \n&quot;);</span></a>
<a name="14164"><span class="lineNum">   14164 </span>            : #endif</a>
<a name="14165"><span class="lineNum">   14165 </span>            : </a>
<a name="14166"><span class="lineNum">   14166 </span><span class="lineNoCov">          0 :           SgScopeStatement* currentScope = inheritedAttribute.get_currentScope();</span></a>
<a name="14167"><span class="lineNum">   14167 </span><span class="lineNoCov">          0 :           ASSERT_not_null(currentScope);</span></a>
<a name="14168"><span class="lineNum">   14168 </span>            : </a>
<a name="14169"><span class="lineNum">   14169 </span><span class="lineNoCov">          0 :           SgStatement* currentStatement = inheritedAttribute.get_currentStatement();</span></a>
<a name="14170"><span class="lineNum">   14170 </span><span class="lineNoCov">          0 :           ASSERT_not_null(currentStatement);</span></a>
<a name="14171"><span class="lineNum">   14171 </span>            : </a>
<a name="14172"><span class="lineNum">   14172 </span><span class="lineNoCov">          0 :           mfprintf(mlog [ WARN ] ) (&quot;In evaluateSynthesizedAttribute(): referenceNode    = %p = %s \n&quot;,referenceNode,referenceNode-&gt;class_name().c_str());</span></a>
<a name="14173"><span class="lineNum">   14173 </span><span class="lineNoCov">          0 :           mfprintf(mlog [ WARN ] ) (&quot;In evaluateSynthesizedAttribute(): currentScope     = %p = %s \n&quot;,currentScope,currentScope-&gt;class_name().c_str());</span></a>
<a name="14174"><span class="lineNum">   14174 </span><span class="lineNoCov">          0 :           mfprintf(mlog [ WARN ] ) (&quot;In evaluateSynthesizedAttribute(): currentStatement = %p = %s \n&quot;,currentStatement,currentStatement-&gt;class_name().c_str());</span></a>
<a name="14175"><span class="lineNum">   14175 </span>            : </a>
<a name="14176"><span class="lineNum">   14176 </span><span class="lineNoCov">          0 :           SgInitializedName* initializedName = isSgInitializedName(referenceNode);</span></a>
<a name="14177"><span class="lineNum">   14177 </span><span class="lineNoCov">          0 :           if (initializedName != NULL)</span></a>
<a name="14178"><span class="lineNum">   14178 </span>            :              {</a>
<a name="14179"><span class="lineNum">   14179 </span><span class="lineNoCov">          0 :                SgType* generateStringForType = initializedName-&gt;get_type();</span></a>
<a name="14180"><span class="lineNum">   14180 </span><span class="lineNoCov">          0 :                ASSERT_not_null(generateStringForType);</span></a>
<a name="14181"><span class="lineNum">   14181 </span>            : </a>
<a name="14182"><span class="lineNum">   14182 </span><span class="lineNoCov">          0 :                traverseType(generateStringForType,referenceNode,currentScope,currentStatement);</span></a>
<a name="14183"><span class="lineNum">   14183 </span>            :              }</a>
<a name="14184"><span class="lineNum">   14184 </span>            :             else</a>
<a name="14185"><span class="lineNum">   14185 </span>            :              {</a>
<a name="14186"><span class="lineNum">   14186 </span>            :             // DQ (4/21/2019): We will have to handle every kind of IR node that will require a computed string for it's type (a few, but not too many).</a>
<a name="14187"><span class="lineNum">   14187 </span><span class="lineNoCov">          0 :                mfprintf(mlog [ WARN ] ) (&quot;Error: We need to find the type and the kind of IR node from which it is to be generated as a string: referenceNode = %p = %s \n&quot;,referenceNode,referenceNode-&gt;class_name().c_str());</span></a>
<a name="14188"><span class="lineNum">   14188 </span><span class="lineNoCov">          0 :                ROSE_ABORT();</span></a>
<a name="14189"><span class="lineNum">   14189 </span>            :              }</a>
<a name="14190"><span class="lineNum">   14190 </span>            : </a>
<a name="14191"><span class="lineNum">   14191 </span>            : #if 1</a>
<a name="14192"><span class="lineNum">   14192 </span><span class="lineNoCov">          0 :           mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</span></a>
<a name="14193"><span class="lineNum">   14193 </span><span class="lineNoCov">          0 :           ROSE_ABORT();</span></a>
<a name="14194"><span class="lineNum">   14194 </span>            : #endif</a>
<a name="14195"><span class="lineNum">   14195 </span>            :         }</a>
<a name="14196"><span class="lineNum">   14196 </span>            : </a>
<a name="14197"><span class="lineNum">   14197 </span>            :   // Iterate over the synthesizedAttributeList.</a>
<a name="14198"><span class="lineNum">   14198 </span><span class="lineCov">    2810440 :      SynthesizedAttributesList::iterator i = synthesizedAttributeList.begin();</span></a>
<a name="14199"><span class="lineNum">   14199 </span><span class="lineCov">    7421930 :      while (i != synthesizedAttributeList.end())</span></a>
<a name="14200"><span class="lineNum">   14200 </span>            :         {</a>
<a name="14201"><span class="lineNum">   14201 </span><span class="lineCov">    4611490 :           NameQualificationSynthesizedAttribute synthesizedAttribute = *i;</span></a>
<a name="14202"><span class="lineNum">   14202 </span>            :        // ROSE_ASSERT(synthesizedAttribute != NULL);</a>
<a name="14203"><span class="lineNum">   14203 </span><span class="lineCov">    4611490 :           SgNode* synthesizedAttributeNode = synthesizedAttribute.node;</span></a>
<a name="14204"><span class="lineNum">   14204 </span>            : </a>
<a name="14205"><span class="lineNum">   14205 </span>            :        // DQ (8/2/2020): Not clear why this can be NULL.</a>
<a name="14206"><span class="lineNum">   14206 </span>            :        // ROSE_ASSERT(synthesizedAttributeNode != NULL);</a>
<a name="14207"><span class="lineNum">   14207 </span>            : </a>
<a name="14208"><span class="lineNum">   14208 </span><span class="lineCov">    4611490 :           if (synthesizedAttributeNode != NULL)</span></a>
<a name="14209"><span class="lineNum">   14209 </span>            :              {</a>
<a name="14210"><span class="lineNum">   14210 </span>            : #if 0</a>
<a name="14211"><span class="lineNum">   14211 </span>            :                printf (&quot;iterate over synthesizedAttributeList: synthesizedAttributeNode = %p = %s \n&quot;,synthesizedAttributeNode,synthesizedAttributeNode-&gt;class_name().c_str());</a>
<a name="14212"><span class="lineNum">   14212 </span>            : #endif</a>
<a name="14213"><span class="lineNum">   14213 </span><span class="lineCov">    2538510 :                SgNamespaceAliasDeclarationStatement* namespaceAliasDeclaration = isSgNamespaceAliasDeclarationStatement(synthesizedAttributeNode);</span></a>
<a name="14214"><span class="lineNum">   14214 </span><span class="lineCov">    2538510 :                if (namespaceAliasDeclaration != NULL)</span></a>
<a name="14215"><span class="lineNum">   14215 </span>            :                   {</a>
<a name="14216"><span class="lineNum">   14216 </span><span class="lineNoCov">          0 :                     SgDeclarationStatement* declaration = namespaceAliasDeclaration-&gt;get_is_alias_for_another_namespace_alias() ?</span></a>
<a name="14217"><span class="lineNum">   14217 </span><span class="lineNoCov">          0 :                                                                isSgDeclarationStatement(namespaceAliasDeclaration-&gt;get_namespaceAliasDeclaration()) :</span></a>
<a name="14218"><span class="lineNum">   14218 </span><span class="lineNoCov">          0 :                                                                isSgDeclarationStatement(namespaceAliasDeclaration-&gt;get_namespaceDeclaration());</span></a>
<a name="14219"><span class="lineNum">   14219 </span><span class="lineNoCov">          0 :                     ROSE_ASSERT(declaration != NULL);</span></a>
<a name="14220"><span class="lineNum">   14220 </span>            : #if 0</a>
<a name="14221"><span class="lineNum">   14221 </span>            :                     printf (&quot;namespaceAliasDeclaration = %p = %s \n&quot;,namespaceAliasDeclaration,namespaceAliasDeclaration-&gt;class_name().c_str());</a>
<a name="14222"><span class="lineNum">   14222 </span>            :                     printf (&quot;Before erase: namespaceAliasDeclarationMap.size() = %zu \n&quot;,namespaceAliasDeclarationMap.size());</a>
<a name="14223"><span class="lineNum">   14223 </span>            : #endif</a>
<a name="14224"><span class="lineNum">   14224 </span>            : #if 0</a>
<a name="14225"><span class="lineNum">   14225 </span>            :                  // Debugging the list.</a>
<a name="14226"><span class="lineNum">   14226 </span>            :                     namespaceAliasMapType::iterator j = namespaceAliasDeclarationMap.begin();</a>
<a name="14227"><span class="lineNum">   14227 </span>            :                     while (j != namespaceAliasDeclarationMap.end())</a>
<a name="14228"><span class="lineNum">   14228 </span>            :                        {</a>
<a name="14229"><span class="lineNum">   14229 </span>            :                          SgDeclarationStatement*               tmp_Declaration               = j-&gt;first;</a>
<a name="14230"><span class="lineNum">   14230 </span>            :                          SgNamespaceAliasDeclarationStatement* tmp_namespaceAliasDeclaration = j-&gt;second;</a>
<a name="14231"><span class="lineNum">   14231 </span>            : </a>
<a name="14232"><span class="lineNum">   14232 </span>            :                          printf (&quot;tmp_Declaration               = %p = %s \n&quot;,tmp_Declaration,tmp_Declaration-&gt;class_name().c_str());</a>
<a name="14233"><span class="lineNum">   14233 </span>            :                          printf (&quot;tmp_namespaceAliasDeclaration = %p \n&quot;,tmp_namespaceAliasDeclaration);</a>
<a name="14234"><span class="lineNum">   14234 </span>            : </a>
<a name="14235"><span class="lineNum">   14235 </span>            :                          j++;</a>
<a name="14236"><span class="lineNum">   14236 </span>            :                        }</a>
<a name="14237"><span class="lineNum">   14237 </span>            : #endif</a>
<a name="14238"><span class="lineNum">   14238 </span>            : #if 0</a>
<a name="14239"><span class="lineNum">   14239 </span>            :                     printf (&quot;Found a SgNamespaceAliasDeclarationStatement: Exiting as a test! \n&quot;);</a>
<a name="14240"><span class="lineNum">   14240 </span>            :                     ROSE_ABORT();</a>
<a name="14241"><span class="lineNum">   14241 </span>            : #endif</a>
<a name="14242"><span class="lineNum">   14242 </span>            :                  // ROSE_ASSERT(namespaceAliasDeclarationMap.find(declaration) != namespaceAliasDeclarationMap.end());</a>
<a name="14243"><span class="lineNum">   14243 </span><span class="lineNoCov">          0 :                     if (namespaceAliasDeclarationMap.find(declaration) != namespaceAliasDeclarationMap.end())</span></a>
<a name="14244"><span class="lineNum">   14244 </span>            :                        {</a>
<a name="14245"><span class="lineNum">   14245 </span><span class="lineNoCov">          0 :                          namespaceAliasMapType::iterator i = namespaceAliasDeclarationMap.find(declaration);</span></a>
<a name="14246"><span class="lineNum">   14246 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(i != namespaceAliasDeclarationMap.end());</span></a>
<a name="14247"><span class="lineNum">   14247 </span><span class="lineNoCov">          0 :                          namespaceAliasDeclarationMap.erase(i);</span></a>
<a name="14248"><span class="lineNum">   14248 </span>            : #if 0</a>
<a name="14249"><span class="lineNum">   14249 </span>            :                          printf (&quot;After erase: namespaceAliasDeclarationMap.size() = %zu \n&quot;,namespaceAliasDeclarationMap.size());</a>
<a name="14250"><span class="lineNum">   14250 </span>            : #endif</a>
<a name="14251"><span class="lineNum">   14251 </span>            : #if 0</a>
<a name="14252"><span class="lineNum">   14252 </span>            :                          printf (&quot;Found a SgNamespaceAliasDeclarationStatement: Exiting as a test! \n&quot;);</a>
<a name="14253"><span class="lineNum">   14253 </span>            :                          ROSE_ABORT();</a>
<a name="14254"><span class="lineNum">   14254 </span>            : #endif</a>
<a name="14255"><span class="lineNum">   14255 </span>            :                        }</a>
<a name="14256"><span class="lineNum">   14256 </span>            :                   }</a>
<a name="14257"><span class="lineNum">   14257 </span>            :              }</a>
<a name="14258"><span class="lineNum">   14258 </span>            : </a>
<a name="14259"><span class="lineNum">   14259 </span><span class="lineCov">    4611490 :           i++;</span></a>
<a name="14260"><span class="lineNum">   14260 </span>            :         }</a>
<a name="14261"><span class="lineNum">   14261 </span>            : </a>
<a name="14262"><span class="lineNum">   14262 </span>            : #if 0</a>
<a name="14263"><span class="lineNum">   14263 </span>            :   // DQ (11/24/2020): This is support for testing a specific new tool.</a>
<a name="14264"><span class="lineNum">   14264 </span>            :      SgSourceFile* sourceFile = isSgSourceFile(n);</a>
<a name="14265"><span class="lineNum">   14265 </span>            :      if (sourceFile != NULL)</a>
<a name="14266"><span class="lineNum">   14266 </span>            :         {</a>
<a name="14267"><span class="lineNum">   14267 </span>            :           printf (&quot;In NameQualificationTraversal::evaluateSynthesizedAttribute(): case of SgSourceFile: filename = %s \n&quot;,sourceFile-&gt;getFileName().c_str());</a>
<a name="14268"><span class="lineNum">   14268 </span>            : </a>
<a name="14269"><span class="lineNum">   14269 </span>            :           if (sourceFile-&gt;getFileName() == &quot;rose_test_107_lib.cpp&quot;)</a>
<a name="14270"><span class="lineNum">   14270 </span>            :              {</a>
<a name="14271"><span class="lineNum">   14271 </span>            :                printf (&quot;Exiting as a test after name qualification of rose_test_107_lib.cpp \n&quot;);</a>
<a name="14272"><span class="lineNum">   14272 </span>            :                ROSE_ABORT();</a>
<a name="14273"><span class="lineNum">   14273 </span>            :              }</a>
<a name="14274"><span class="lineNum">   14274 </span>            :         }</a>
<a name="14275"><span class="lineNum">   14275 </span>            : #endif</a>
<a name="14276"><span class="lineNum">   14276 </span>            : </a>
<a name="14277"><span class="lineNum">   14277 </span>            :   // DQ (8/2/2020): Added assertion.</a>
<a name="14278"><span class="lineNum">   14278 </span><span class="lineCov">    2810440 :      ROSE_ASSERT(returnAttribute.node != NULL);</span></a>
<a name="14279"><span class="lineNum">   14279 </span>            : </a>
<a name="14280"><span class="lineNum">   14280 </span><span class="lineCov">    2810440 :      return returnAttribute;</span></a>
<a name="14281"><span class="lineNum">   14281 </span>            :    }</a>
<a name="14282"><span class="lineNum">   14282 </span>            : </a>
<a name="14283"><span class="lineNum">   14283 </span>            : </a>
<a name="14284"><span class="lineNum">   14284 </span>            : #define DEBUG_TRAVERSE_NONREAL_FOR_SCOPE 0</a>
<a name="14285"><span class="lineNum">   14285 </span>            : </a>
<a name="14286"><span class="lineNum">   14286 </span>            : // Dealing with nonreal's scope: the scope is where the nonreal is instantiated this code either:</a>
<a name="14287"><span class="lineNum">   14287 </span>            : //  - Uses the scope of the associated template, if it exists</a>
<a name="14288"><span class="lineNum">   14288 </span>            : //  - Traverse nonreal parent using while loop, else</a>
<a name="14289"><span class="lineNum">   14289 </span><span class="lineCov">    1620580 : SgScopeStatement * traverseNonrealDeclForCorrectScope(SgDeclarationStatement * declaration) {</span></a>
<a name="14290"><span class="lineNum">   14290 </span><span class="lineCov">    1620580 :   SgScopeStatement * scope = declaration-&gt;get_scope();</span></a>
<a name="14291"><span class="lineNum">   14291 </span><span class="lineCov">    1620580 :   ASSERT_not_null(scope);</span></a>
<a name="14292"><span class="lineNum">   14292 </span>            : </a>
<a name="14293"><span class="lineNum">   14293 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || DEBUG_TRAVERSE_NONREAL_FOR_SCOPE</a>
<a name="14294"><span class="lineNum">   14294 </span>            :   mfprintf(mlog [ WARN ] ) (&quot;In traverseNonrealDeclForCorrectScope():\n&quot;);</a>
<a name="14295"><span class="lineNum">   14295 </span>            :   mfprintf(mlog [ WARN ] ) (&quot; --- declaration = %p (%s)\n&quot;, declaration, declaration-&gt;class_name().c_str());</a>
<a name="14296"><span class="lineNum">   14296 </span>            :   mfprintf(mlog [ WARN ] ) (&quot; --- scope = %p (%s)\n&quot;, scope, scope-&gt;class_name().c_str());</a>
<a name="14297"><span class="lineNum">   14297 </span>            : #endif</a>
<a name="14298"><span class="lineNum">   14298 </span>            : </a>
<a name="14299"><span class="lineNum">   14299 </span><span class="lineCov">    1620580 :   SgNonrealDecl * nrdecl = isSgNonrealDecl(declaration);</span></a>
<a name="14300"><span class="lineNum">   14300 </span><span class="lineCov">    1634970 :   while (nrdecl != NULL) {</span></a>
<a name="14301"><span class="lineNum">   14301 </span><span class="lineCov">      57056 :     if (nrdecl-&gt;get_templateDeclaration() == NULL) {</span></a>
<a name="14302"><span class="lineNum">   14302 </span><span class="lineCov">      40695 :       SgDeclarationScope * decl_scope = isSgDeclarationScope(nrdecl-&gt;get_scope());</span></a>
<a name="14303"><span class="lineNum">   14303 </span><span class="lineCov">      40695 :       ASSERT_not_null(decl_scope);</span></a>
<a name="14304"><span class="lineNum">   14304 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || DEBUG_TRAVERSE_NONREAL_FOR_SCOPE</a>
<a name="14305"><span class="lineNum">   14305 </span>            :       mfprintf(mlog [ WARN ] ) (&quot; --- decl_scope = %p (%s)\n&quot;, decl_scope,decl_scope-&gt;class_name().c_str());</a>
<a name="14306"><span class="lineNum">   14306 </span>            : #endif</a>
<a name="14307"><span class="lineNum">   14307 </span>            : </a>
<a name="14308"><span class="lineNum">   14308 </span><span class="lineCov">      40695 :       SgNode * decl_scope_parent = decl_scope-&gt;get_parent();</span></a>
<a name="14309"><span class="lineNum">   14309 </span><span class="lineCov">      40695 :       ASSERT_not_null(decl_scope_parent);</span></a>
<a name="14310"><span class="lineNum">   14310 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || DEBUG_TRAVERSE_NONREAL_FOR_SCOPE</a>
<a name="14311"><span class="lineNum">   14311 </span>            :       mfprintf(mlog [ WARN ] ) (&quot; --- decl_scope_parent = %p (%s)\n&quot;, decl_scope_parent, decl_scope_parent-&gt;class_name().c_str());</a>
<a name="14312"><span class="lineNum">   14312 </span>            : #endif</a>
<a name="14313"><span class="lineNum">   14313 </span>            : </a>
<a name="14314"><span class="lineNum">   14314 </span><span class="lineCov">      40695 :       SgTemplateClassDeclaration * tcdecl_parent = isSgTemplateClassDeclaration(decl_scope_parent);</span></a>
<a name="14315"><span class="lineNum">   14315 </span><span class="lineCov">      40695 :       SgTemplateFunctionDeclaration * tfdecl_parent = isSgTemplateFunctionDeclaration(decl_scope_parent);</span></a>
<a name="14316"><span class="lineNum">   14316 </span><span class="lineCov">      40695 :       SgTemplateMemberFunctionDeclaration * tmfdecl_parent = isSgTemplateMemberFunctionDeclaration(decl_scope_parent);</span></a>
<a name="14317"><span class="lineNum">   14317 </span><span class="lineCov">      40695 :       SgTemplateTypedefDeclaration * ttddecl_parent = isSgTemplateTypedefDeclaration(decl_scope_parent);</span></a>
<a name="14318"><span class="lineNum">   14318 </span><span class="lineCov">      40695 :       SgTemplateVariableDeclaration * tvdecl_parent = isSgTemplateVariableDeclaration(decl_scope_parent);</span></a>
<a name="14319"><span class="lineNum">   14319 </span><span class="lineCov">      40695 :       SgNonrealDecl * nr_parent = isSgNonrealDecl(decl_scope_parent);</span></a>
<a name="14320"><span class="lineNum">   14320 </span><span class="lineCov">      40695 :       if (nr_parent != NULL) {</span></a>
<a name="14321"><span class="lineNum">   14321 </span><span class="lineCov">      14391 :         ROSE_ASSERT(nr_parent != nrdecl); // LOOP in the nonreal declaration: forbidden</span></a>
<a name="14322"><span class="lineNum">   14322 </span><span class="lineCov">      14391 :         nrdecl = nr_parent;</span></a>
<a name="14323"><span class="lineNum">   14323 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || DEBUG_TRAVERSE_NONREAL_FOR_SCOPE</a>
<a name="14324"><span class="lineNum">   14324 </span>            :         mfprintf(mlog [ WARN ] ) (&quot; --- nrdecl = %p (%s)\n&quot;, nrdecl, nrdecl-&gt;class_name().c_str());</a>
<a name="14325"><span class="lineNum">   14325 </span>            : #endif</a>
<a name="14326"><span class="lineNum">   14326 </span>            :       } else {</a>
<a name="14327"><span class="lineNum">   14327 </span><span class="lineCov">      26304 :         ROSE_ASSERT(tcdecl_parent || tfdecl_parent || tmfdecl_parent || ttddecl_parent || tvdecl_parent);</span></a>
<a name="14328"><span class="lineNum">   14328 </span><span class="lineCov">      26304 :         break;</span></a>
<a name="14329"><span class="lineNum">   14329 </span>            :       }</a>
<a name="14330"><span class="lineNum">   14330 </span>            :     } else {</a>
<a name="14331"><span class="lineNum">   14331 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || DEBUG_TRAVERSE_NONREAL_FOR_SCOPE</a>
<a name="14332"><span class="lineNum">   14332 </span>            :       mfprintf(mlog [ WARN ] ) (&quot; --- nrdecl-&gt;get_templateDeclaration() = %p (%s)\n&quot;, nrdecl-&gt;get_templateDeclaration(), nrdecl-&gt;get_templateDeclaration()-&gt;class_name().c_str());</a>
<a name="14333"><span class="lineNum">   14333 </span>            : #endif</a>
<a name="14334"><span class="lineNum">   14334 </span>            : </a>
<a name="14335"><span class="lineNum">   14335 </span><span class="lineCov">      16361 :       scope = nrdecl-&gt;get_templateDeclaration()-&gt;get_scope();</span></a>
<a name="14336"><span class="lineNum">   14336 </span><span class="lineCov">      16361 :       ASSERT_not_null(scope);</span></a>
<a name="14337"><span class="lineNum">   14337 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || DEBUG_TRAVERSE_NONREAL_FOR_SCOPE</a>
<a name="14338"><span class="lineNum">   14338 </span>            :       mfprintf(mlog [ WARN ] ) (&quot; --- scope = %p (%s)\n&quot;, scope, scope-&gt;class_name().c_str());</a>
<a name="14339"><span class="lineNum">   14339 </span>            : #endif</a>
<a name="14340"><span class="lineNum">   14340 </span>            : </a>
<a name="14341"><span class="lineNum">   14341 </span><span class="lineCov">      16361 :       break;</span></a>
<a name="14342"><span class="lineNum">   14342 </span>            :     }</a>
<a name="14343"><span class="lineNum">   14343 </span>            :   }</a>
<a name="14344"><span class="lineNum">   14344 </span>            : </a>
<a name="14345"><span class="lineNum">   14345 </span><span class="lineCov">    1620580 :   return scope;</span></a>
<a name="14346"><span class="lineNum">   14346 </span>            : }</a>
<a name="14347"><span class="lineNum">   14347 </span>            : </a>
<a name="14348"><span class="lineNum">   14348 </span>            : // ************************************************************************************</a>
<a name="14349"><span class="lineNum">   14349 </span>            : //    These overloaded functions, setNameQualification(), support references to IR</a>
<a name="14350"><span class="lineNum">   14350 </span>            : // nodes that require name qualification.  Each function inserts a qualified name</a>
<a name="14351"><span class="lineNum">   14351 </span>            : // (string) into a map stored as a static data member in SgNode. For each IR node</a>
<a name="14352"><span class="lineNum">   14352 </span>            : // that is qualified, the reference to the IR node carries the name qualification</a>
<a name="14353"><span class="lineNum">   14353 </span>            : // (is used as a key in the map of qualified names).  There are two maps, one for</a>
<a name="14354"><span class="lineNum">   14354 </span>            : // the qualification of names and one for qualification of types.  Note that, since</a>
<a name="14355"><span class="lineNum">   14355 </span>            : // types are shared, it is more clear that the type can't carry the qualified name</a>
<a name="14356"><span class="lineNum">   14356 </span>            : // because it could be different at each location where the type is referenced; thus</a>
<a name="14357"><span class="lineNum">   14357 </span>            : // the reference to the type carries the qualified name (via the map).  The case of</a>
<a name="14358"><span class="lineNum">   14358 </span>            : // why named IR constructs have to have there qualified name in the IR node referencing</a>
<a name="14359"><span class="lineNum">   14359 </span>            : // the named construct is similar.</a>
<a name="14360"><span class="lineNum">   14360 </span>            : //</a>
<a name="14361"><span class="lineNum">   14361 </span>            : // They are only a few IR nodes that reference IR nodes that can be qualified:</a>
<a name="14362"><span class="lineNum">   14362 </span>            : //    SgExpression IR nodes:</a>
<a name="14363"><span class="lineNum">   14363 </span>            : //       SgVarRefExp</a>
<a name="14364"><span class="lineNum">   14364 </span>            : //       SgFunctionRefExp</a>
<a name="14365"><span class="lineNum">   14365 </span>            : //       SgMemberFunctionRefExp</a>
<a name="14366"><span class="lineNum">   14366 </span>            : //       SgConstructorInitializer</a>
<a name="14367"><span class="lineNum">   14367 </span>            : //       SgNewExp</a>
<a name="14368"><span class="lineNum">   14368 </span>            : //       SgCastExp</a>
<a name="14369"><span class="lineNum">   14369 </span>            : //       SgSizeOfOp</a>
<a name="14370"><span class="lineNum">   14370 </span>            : //       SgTypeIdOp</a>
<a name="14371"><span class="lineNum">   14371 </span>            : //</a>
<a name="14372"><span class="lineNum">   14372 </span>            : //    SgDeclarationStatement IR nodes:</a>
<a name="14373"><span class="lineNum">   14373 </span>            : //       SgFunctionDeclaration (for the function name)</a>
<a name="14374"><span class="lineNum">   14374 </span>            : //       SgFunctionDeclaration (for the return type)</a>
<a name="14375"><span class="lineNum">   14375 </span>            : //       SgUsingDeclarationStatement (for references to a declaration (e.g. namespace or class))</a>
<a name="14376"><span class="lineNum">   14376 </span>            : //       SgUsingDeclarationStatement (for references to a SgInitializedName)</a>
<a name="14377"><span class="lineNum">   14377 </span>            : //       SgUsingDirectiveStatement</a>
<a name="14378"><span class="lineNum">   14378 </span>            : //       SgVariableDeclaration</a>
<a name="14379"><span class="lineNum">   14379 </span>            : //       SgTypedefDeclaration</a>
<a name="14380"><span class="lineNum">   14380 </span>            : //       SgClassDeclaration</a>
<a name="14381"><span class="lineNum">   14381 </span>            : //       SgEnumDeclaration</a>
<a name="14382"><span class="lineNum">   14382 </span>            : //</a>
<a name="14383"><span class="lineNum">   14383 </span>            : //    SgStatement IR nodes:</a>
<a name="14384"><span class="lineNum">   14384 </span>            : //       SgForInitStatement is not a problems since it is a list of SgInitializedName</a>
<a name="14385"><span class="lineNum">   14385 </span>            : //</a>
<a name="14386"><span class="lineNum">   14386 </span>            : //    SgLocatedNode nodes:</a>
<a name="14387"><span class="lineNum">   14387 </span>            : //       SgInitializedName</a>
<a name="14388"><span class="lineNum">   14388 </span>            : //</a>
<a name="14389"><span class="lineNum">   14389 </span>            : //    SgSupport nodes:</a>
<a name="14390"><span class="lineNum">   14390 </span>            : //       SgBaseClass</a>
<a name="14391"><span class="lineNum">   14391 </span>            : //       SgTemplateArgument</a>
<a name="14392"><span class="lineNum">   14392 </span>            : //</a>
<a name="14393"><span class="lineNum">   14393 </span>            : // Other (not yet supported) IR nodes recognized to reference types that could require name</a>
<a name="14394"><span class="lineNum">   14394 </span>            : // qualification support:</a>
<a name="14395"><span class="lineNum">   14395 </span>            : //    SgExpression IR nodes:</a>
<a name="14396"><span class="lineNum">   14396 </span>            : //</a>
<a name="14397"><span class="lineNum">   14397 </span>            : //    And maybe also:</a>
<a name="14398"><span class="lineNum">   14398 </span>            : //       SgPseudoDestructorRefExp</a>
<a name="14399"><span class="lineNum">   14399 </span>            : //       SgTemplateParameter</a>
<a name="14400"><span class="lineNum">   14400 </span>            : //</a>
<a name="14401"><span class="lineNum">   14401 </span>            : // Note also that name qualifiction can be required on expressions that are a part of</a>
<a name="14402"><span class="lineNum">   14402 </span>            : // the originalExpressionTree that represent the expanded representation from constant</a>
<a name="14403"><span class="lineNum">   14403 </span>            : // folding.  Thus we have to make a recursive call on all valid originalExpressionTree</a>
<a name="14404"><span class="lineNum">   14404 </span>            : // pointers where they are present:</a>
<a name="14405"><span class="lineNum">   14405 </span>            : //     SgBinaryOp</a>
<a name="14406"><span class="lineNum">   14406 </span>            : //     SgValueExp</a>
<a name="14407"><span class="lineNum">   14407 </span>            : //     SgFunctionRefExp</a>
<a name="14408"><span class="lineNum">   14408 </span>            : //     SgValueExp</a>
<a name="14409"><span class="lineNum">   14409 </span>            : //     SgCastExp</a>
<a name="14410"><span class="lineNum">   14410 </span>            : // ************************************************************************************</a>
<a name="14411"><span class="lineNum">   14411 </span>            : </a>
<a name="14412"><span class="lineNum">   14412 </span>            : </a>
<a name="14413"><span class="lineNum">   14413 </span>            : // DQ (4/20/2019): For where the input is a type (SgPointerMemberType) we need to pass in a</a>
<a name="14414"><span class="lineNum">   14414 </span>            : // referenceNode for what will become the key in the map for the name qualification prefix.</a>
<a name="14415"><span class="lineNum">   14415 </span>            : // void NameQualificationTraversal::setNameQualification ( SgPointerMemberType* pointerMemberType, SgNode* referenceNode, int amountOfNameQualificationRequired )</a>
<a name="14416"><span class="lineNum">   14416 </span>            : // void NameQualificationTraversal::setNameQualification ( SgNode* referenceNode, SgDeclarationStatement* declaration, int amountOfNameQualificationRequired )</a>
<a name="14417"><span class="lineNum">   14417 </span><span class="lineCov">        382 : void NameQualificationTraversal::setNameQualificationOnClassOf ( SgPointerMemberType* pointerMemberType, SgDeclarationStatement* declaration, int amountOfNameQualificationRequired )</span></a>
<a name="14418"><span class="lineNum">   14418 </span>            :    {</a>
<a name="14419"><span class="lineNum">   14419 </span>            :   // DQ (4/19/2019): Adding support for chains of SpPointerMemberType types (requires type traversal).</a>
<a name="14420"><span class="lineNum">   14420 </span>            : </a>
<a name="14421"><span class="lineNum">   14421 </span>            :   // Setup call to refactored code.</a>
<a name="14422"><span class="lineNum">   14422 </span><span class="lineCov">        382 :      int  outputNameQualificationLength = 0;</span></a>
<a name="14423"><span class="lineNum">   14423 </span><span class="lineCov">        382 :      bool outputGlobalQualification     = false;</span></a>
<a name="14424"><span class="lineNum">   14424 </span><span class="lineCov">        382 :      bool outputTypeEvaluation          = false;</span></a>
<a name="14425"><span class="lineNum">   14425 </span>            : </a>
<a name="14426"><span class="lineNum">   14426 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="14427"><span class="lineNum">   14427 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In setNameQualification(SgPointerMemberType*) \n&quot;);</a>
<a name="14428"><span class="lineNum">   14428 </span>            : #endif</a>
<a name="14429"><span class="lineNum">   14429 </span>            : </a>
<a name="14430"><span class="lineNum">   14430 </span><span class="lineCov">        382 :      SgScopeStatement * scope = traverseNonrealDeclForCorrectScope(declaration);</span></a>
<a name="14431"><span class="lineNum">   14431 </span>            :   // SgScopeStatement * scope = traverseNonrealDeclForCorrectScope(referenceNode);</a>
<a name="14432"><span class="lineNum">   14432 </span><span class="lineCov">        382 :      string qualifier = setNameQualificationSupport(scope,amountOfNameQualificationRequired, outputNameQualificationLength, outputGlobalQualification, outputTypeEvaluation);</span></a>
<a name="14433"><span class="lineNum">   14433 </span>            : </a>
<a name="14434"><span class="lineNum">   14434 </span>            :   // DQ (4/19/2019): I would like to not have to add these data members to the SgPointerMemberType IR node (see if we can do this).</a>
<a name="14435"><span class="lineNum">   14435 </span>            :   // pointerMemberType-&gt;set_global_qualification_required(outputGlobalQualification);</a>
<a name="14436"><span class="lineNum">   14436 </span>            :   // pointerMemberType-&gt;set_name_qualification_length(outputNameQualificationLength);</a>
<a name="14437"><span class="lineNum">   14437 </span>            : </a>
<a name="14438"><span class="lineNum">   14438 </span>            :   // There should be no type evaluation required for a variable reference, as I recall.</a>
<a name="14439"><span class="lineNum">   14439 </span><span class="lineCov">        382 :      ROSE_ASSERT(outputTypeEvaluation == false);</span></a>
<a name="14440"><span class="lineNum">   14440 </span>            :   // pointerMemberType-&gt;set_type_elaboration_required(outputTypeEvaluation);</a>
<a name="14441"><span class="lineNum">   14441 </span>            : </a>
<a name="14442"><span class="lineNum">   14442 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="14443"><span class="lineNum">   14443 </span>            :   // mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): pointerMemberType-&gt;get_name_qualification_length()     = %d \n&quot;,pointerMemberType-&gt;get_name_qualification_length());</a>
<a name="14444"><span class="lineNum">   14444 </span>            :   // mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): pointerMemberType-&gt;get_type_elaboration_required()     = %s \n&quot;,pointerMemberType-&gt;get_type_elaboration_required() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="14445"><span class="lineNum">   14445 </span>            :   // mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): pointerMemberType-&gt;get_global_qualification_required() = %s \n&quot;,pointerMemberType-&gt;get_global_qualification_required() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="14446"><span class="lineNum">   14446 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): pointerMemberType: outputNameQualificationLength  = %d \n&quot;,outputNameQualificationLength);</a>
<a name="14447"><span class="lineNum">   14447 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): pointerMemberType: outputTypeEvaluation           = %s \n&quot;,outputTypeEvaluation ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="14448"><span class="lineNum">   14448 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): pointerMemberType: outputGlobalQualification      = %s \n&quot;,outputGlobalQualification ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="14449"><span class="lineNum">   14449 </span>            : </a>
<a name="14450"><span class="lineNum">   14450 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): qualifier = %s \n&quot;,qualifier.c_str());</a>
<a name="14451"><span class="lineNum">   14451 </span>            : #endif</a>
<a name="14452"><span class="lineNum">   14452 </span>            : </a>
<a name="14453"><span class="lineNum">   14453 </span>            : #if 0</a>
<a name="14454"><span class="lineNum">   14454 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;Checking qualifiedNameMapForNames using pointerMemberType (should be what pointed to this type) \n&quot;);</a>
<a name="14455"><span class="lineNum">   14455 </span>            : #endif</a>
<a name="14456"><span class="lineNum">   14456 </span>            : </a>
<a name="14457"><span class="lineNum">   14457 </span>            : #if 0</a>
<a name="14458"><span class="lineNum">   14458 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="14459"><span class="lineNum">   14459 </span>            :      ROSE_ABORT();</a>
<a name="14460"><span class="lineNum">   14460 </span>            : #endif</a>
<a name="14461"><span class="lineNum">   14461 </span>            : </a>
<a name="14462"><span class="lineNum">   14462 </span>            :   // if (qualifiedNameMapForTypes.find(pointerMemberType) == qualifiedNameMapForTypes.end())</a>
<a name="14463"><span class="lineNum">   14463 </span><span class="lineCov">        764 :      if (qualifiedNameMapForNames.find(pointerMemberType) == qualifiedNameMapForNames.end())</span></a>
<a name="14464"><span class="lineNum">   14464 </span>            :         {</a>
<a name="14465"><span class="lineNum">   14465 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="14466"><span class="lineNum">   14466 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Inserting qualifier for (SgPointerMemberType) name = %s into list at IR node = %p = %s \n&quot;,qualifier.c_str(),pointerMemberType,pointerMemberType-&gt;class_name().c_str());</a>
<a name="14467"><span class="lineNum">   14467 </span>            : #endif</a>
<a name="14468"><span class="lineNum">   14468 </span>            :        // qualifiedNameMapForNames.insert(std::pair&lt;SgNode*,std::string&gt;(pointerMemberType,qualifier));</a>
<a name="14469"><span class="lineNum">   14469 </span>            :        // qualifiedNameMapForTypes.insert(std::pair&lt;SgNode*,std::string&gt;(pointerMemberType,qualifier));</a>
<a name="14470"><span class="lineNum">   14470 </span><span class="lineCov">        434 :           qualifiedNameMapForNames.insert(std::pair&lt;SgNode*,std::string&gt;(pointerMemberType,qualifier));</span></a>
<a name="14471"><span class="lineNum">   14471 </span>            : </a>
<a name="14472"><span class="lineNum">   14472 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="14473"><span class="lineNum">   14473 </span>            :        // mfprintf(mlog [ WARN ] ) (&quot;Testing name in map: for SgPointerMemberType = %p qualified name = %s \n&quot;,pointerMemberType,pointerMemberType-&gt;get_qualified_name_prefix().str());</a>
<a name="14474"><span class="lineNum">   14474 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Testing name in map: for SgPointerMemberType = %p qualified name = %s \n&quot;,pointerMemberType,pointerMemberType-&gt;get_qualified_name_prefix_for_class_of().str());</a>
<a name="14475"><span class="lineNum">   14475 </span>            :        // mfprintf(mlog [ WARN ] ) (&quot;SgNode::get_globalQualifiedNameMapForNames().size() = %&quot; PRIuPTR &quot; \n&quot;,SgNode::get_globalQualifiedNameMapForNames().size());</a>
<a name="14476"><span class="lineNum">   14476 </span>            :        // mfprintf(mlog [ WARN ] ) (&quot;SgNode::get_globalQualifiedNameMapForTypes().size() = %&quot; PRIuPTR &quot; \n&quot;,SgNode::get_globalQualifiedNameMapForTypes().size());</a>
<a name="14477"><span class="lineNum">   14477 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;SgNode::get_globalQualifiedNameMapForNames().size() = %&quot; PRIuPTR &quot; \n&quot;,SgNode::get_globalQualifiedNameMapForNames().size());</a>
<a name="14478"><span class="lineNum">   14478 </span>            : #endif</a>
<a name="14479"><span class="lineNum">   14479 </span>            :         }</a>
<a name="14480"><span class="lineNum">   14480 </span>            :        else</a>
<a name="14481"><span class="lineNum">   14481 </span>            :         {</a>
<a name="14482"><span class="lineNum">   14482 </span>            :        // If it already existes then overwrite the existing information.</a>
<a name="14483"><span class="lineNum">   14483 </span>            :        // std::map&lt;SgNode*,std::string&gt;::iterator i = qualifiedNameMapForNames.find(pointerMemberType);</a>
<a name="14484"><span class="lineNum">   14484 </span>            :        // ROSE_ASSERT (i != qualifiedNameMapForNames.end());</a>
<a name="14485"><span class="lineNum">   14485 </span>            :        // std::map&lt;SgNode*,std::string&gt;::iterator i = qualifiedNameMapForTypes.find(pointerMemberType);</a>
<a name="14486"><span class="lineNum">   14486 </span><span class="lineCov">       2511 :           std::map&lt;SgNode*,std::string&gt;::iterator i = qualifiedNameMapForNames.find(pointerMemberType);</span></a>
<a name="14487"><span class="lineNum">   14487 </span>            :        // ROSE_ASSERT (i != qualifiedNameMapForTypes.end());</a>
<a name="14488"><span class="lineNum">   14488 </span><span class="lineCov">        165 :           ROSE_ASSERT (i != qualifiedNameMapForNames.end());</span></a>
<a name="14489"><span class="lineNum">   14489 </span>            : </a>
<a name="14490"><span class="lineNum">   14490 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="14491"><span class="lineNum">   14491 </span>            :           string previousQualifier = i-&gt;second.c_str();</a>
<a name="14492"><span class="lineNum">   14492 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;WARNING: test 3: replacing previousQualifier = %s with new qualifier = %s \n&quot;,previousQualifier.c_str(),qualifier.c_str());</a>
<a name="14493"><span class="lineNum">   14493 </span>            : #endif</a>
<a name="14494"><span class="lineNum">   14494 </span><span class="lineCov">        165 :           if (i-&gt;second != qualifier)</span></a>
<a name="14495"><span class="lineNum">   14495 </span>            :              {</a>
<a name="14496"><span class="lineNum">   14496 </span>            :             // DQ (3/15/2019): We need to disable the assertion below because it can happen (see Cxx11_tests/test2019_214.C).</a>
<a name="14497"><span class="lineNum">   14497 </span><span class="lineCov">        382 :                i-&gt;second = qualifier;</span></a>
<a name="14498"><span class="lineNum">   14498 </span>            : #if 0</a>
<a name="14499"><span class="lineNum">   14499 </span>            :             // mfprintf(mlog [ WARN ] ) (&quot;Error: name in qualifiedNameMapForTypes already exists and is different... \n&quot;);</a>
<a name="14500"><span class="lineNum">   14500 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Error: name in qualifiedNameMapForNames already exists and is different... \n&quot;);</a>
<a name="14501"><span class="lineNum">   14501 </span>            :                ROSE_ABORT();</a>
<a name="14502"><span class="lineNum">   14502 </span>            : #endif</a>
<a name="14503"><span class="lineNum">   14503 </span>            :              }</a>
<a name="14504"><span class="lineNum">   14504 </span>            :         }</a>
<a name="14505"><span class="lineNum">   14505 </span>            : </a>
<a name="14506"><span class="lineNum">   14506 </span>            : #if 0</a>
<a name="14507"><span class="lineNum">   14507 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="14508"><span class="lineNum">   14508 </span>            :      ROSE_ABORT();</a>
<a name="14509"><span class="lineNum">   14509 </span>            : #endif</a>
<a name="14510"><span class="lineNum">   14510 </span><span class="lineCov">        382 :    }</span></a>
<a name="14511"><span class="lineNum">   14511 </span>            : </a>
<a name="14512"><span class="lineNum">   14512 </span>            : </a>
<a name="14513"><span class="lineNum">   14513 </span>            : </a>
<a name="14514"><span class="lineNum">   14514 </span><span class="lineCov">        382 : void NameQualificationTraversal::setNameQualificationOnBaseType ( SgPointerMemberType* pointerMemberType, SgDeclarationStatement* declaration, int amountOfNameQualificationRequired )</span></a>
<a name="14515"><span class="lineNum">   14515 </span>            :    {</a>
<a name="14516"><span class="lineNum">   14516 </span>            :   // DQ (4/19/2019): Adding support for chains of SpPointerMemberType types (requires type traversal).</a>
<a name="14517"><span class="lineNum">   14517 </span>            : </a>
<a name="14518"><span class="lineNum">   14518 </span>            :   // Setup call to refactored code.</a>
<a name="14519"><span class="lineNum">   14519 </span><span class="lineCov">        382 :      int  outputNameQualificationLength = 0;</span></a>
<a name="14520"><span class="lineNum">   14520 </span><span class="lineCov">        382 :      bool outputGlobalQualification     = false;</span></a>
<a name="14521"><span class="lineNum">   14521 </span><span class="lineCov">        382 :      bool outputTypeEvaluation          = false;</span></a>
<a name="14522"><span class="lineNum">   14522 </span>            : </a>
<a name="14523"><span class="lineNum">   14523 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="14524"><span class="lineNum">   14524 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In setNameQualification(SgPointerMemberType*) \n&quot;);</a>
<a name="14525"><span class="lineNum">   14525 </span>            : #endif</a>
<a name="14526"><span class="lineNum">   14526 </span>            : </a>
<a name="14527"><span class="lineNum">   14527 </span><span class="lineCov">        382 :      SgScopeStatement * scope = traverseNonrealDeclForCorrectScope(declaration);</span></a>
<a name="14528"><span class="lineNum">   14528 </span>            :   // SgScopeStatement * scope = traverseNonrealDeclForCorrectScope(referenceNode);</a>
<a name="14529"><span class="lineNum">   14529 </span><span class="lineCov">        382 :      string qualifier = setNameQualificationSupport(scope,amountOfNameQualificationRequired, outputNameQualificationLength, outputGlobalQualification, outputTypeEvaluation);</span></a>
<a name="14530"><span class="lineNum">   14530 </span>            : </a>
<a name="14531"><span class="lineNum">   14531 </span>            :   // DQ (4/19/2019): I would like to not have to add these data members to the SgPointerMemberType IR node (see if we can do this).</a>
<a name="14532"><span class="lineNum">   14532 </span>            :   // pointerMemberType-&gt;set_global_qualification_required(outputGlobalQualification);</a>
<a name="14533"><span class="lineNum">   14533 </span>            :   // pointerMemberType-&gt;set_name_qualification_length(outputNameQualificationLength);</a>
<a name="14534"><span class="lineNum">   14534 </span>            : </a>
<a name="14535"><span class="lineNum">   14535 </span>            :   // There should be no type evaluation required for a variable reference, as I recall.</a>
<a name="14536"><span class="lineNum">   14536 </span><span class="lineCov">        382 :      ROSE_ASSERT(outputTypeEvaluation == false);</span></a>
<a name="14537"><span class="lineNum">   14537 </span>            :   // pointerMemberType-&gt;set_type_elaboration_required(outputTypeEvaluation);</a>
<a name="14538"><span class="lineNum">   14538 </span>            : </a>
<a name="14539"><span class="lineNum">   14539 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="14540"><span class="lineNum">   14540 </span>            :   // mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): pointerMemberType-&gt;get_name_qualification_length()     = %d \n&quot;,pointerMemberType-&gt;get_name_qualification_length());</a>
<a name="14541"><span class="lineNum">   14541 </span>            :   // mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): pointerMemberType-&gt;get_type_elaboration_required()     = %s \n&quot;,pointerMemberType-&gt;get_type_elaboration_required() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="14542"><span class="lineNum">   14542 </span>            :   // mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): pointerMemberType-&gt;get_global_qualification_required() = %s \n&quot;,pointerMemberType-&gt;get_global_qualification_required() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="14543"><span class="lineNum">   14543 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): pointerMemberType: outputNameQualificationLength  = %d \n&quot;,outputNameQualificationLength);</a>
<a name="14544"><span class="lineNum">   14544 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): pointerMemberType: outputTypeEvaluation           = %s \n&quot;,outputTypeEvaluation ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="14545"><span class="lineNum">   14545 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): pointerMemberType: outputGlobalQualification      = %s \n&quot;,outputGlobalQualification ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="14546"><span class="lineNum">   14546 </span>            : </a>
<a name="14547"><span class="lineNum">   14547 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): qualifier = %s \n&quot;,qualifier.c_str());</a>
<a name="14548"><span class="lineNum">   14548 </span>            : #endif</a>
<a name="14549"><span class="lineNum">   14549 </span>            : </a>
<a name="14550"><span class="lineNum">   14550 </span>            : #if 0</a>
<a name="14551"><span class="lineNum">   14551 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;Checking qualifiedNameMapForTypes using pointerMemberType (should be what pointed to this type) \n&quot;);</a>
<a name="14552"><span class="lineNum">   14552 </span>            : #endif</a>
<a name="14553"><span class="lineNum">   14553 </span>            : </a>
<a name="14554"><span class="lineNum">   14554 </span>            : #if 0</a>
<a name="14555"><span class="lineNum">   14555 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="14556"><span class="lineNum">   14556 </span>            :      ROSE_ABORT();</a>
<a name="14557"><span class="lineNum">   14557 </span>            : #endif</a>
<a name="14558"><span class="lineNum">   14558 </span>            : </a>
<a name="14559"><span class="lineNum">   14559 </span><span class="lineCov">        764 :      if (qualifiedNameMapForTypes.find(pointerMemberType) == qualifiedNameMapForTypes.end())</span></a>
<a name="14560"><span class="lineNum">   14560 </span>            :         {</a>
<a name="14561"><span class="lineNum">   14561 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="14562"><span class="lineNum">   14562 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Inserting qualifier for (SgPointerMemberType) name = %s into list at IR node = %p = %s \n&quot;,qualifier.c_str(),pointerMemberType,pointerMemberType-&gt;class_name().c_str());</a>
<a name="14563"><span class="lineNum">   14563 </span>            : #endif</a>
<a name="14564"><span class="lineNum">   14564 </span>            :        // qualifiedNameMapForNames.insert(std::pair&lt;SgNode*,std::string&gt;(pointerMemberType,qualifier));</a>
<a name="14565"><span class="lineNum">   14565 </span><span class="lineCov">        434 :           qualifiedNameMapForTypes.insert(std::pair&lt;SgNode*,std::string&gt;(pointerMemberType,qualifier));</span></a>
<a name="14566"><span class="lineNum">   14566 </span>            : </a>
<a name="14567"><span class="lineNum">   14567 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="14568"><span class="lineNum">   14568 </span>            :        // mfprintf(mlog [ WARN ] ) (&quot;Testing name in map: for SgPointerMemberType = %p qualified name = %s \n&quot;,pointerMemberType,pointerMemberType-&gt;get_qualified_name_prefix().str());</a>
<a name="14569"><span class="lineNum">   14569 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Testing name in map: for SgPointerMemberType = %p qualified name = %s \n&quot;,pointerMemberType,pointerMemberType-&gt;get_qualified_name_prefix_for_base_type().str());</a>
<a name="14570"><span class="lineNum">   14570 </span>            :        // mfprintf(mlog [ WARN ] ) (&quot;SgNode::get_globalQualifiedNameMapForNames().size() = %&quot; PRIuPTR &quot; \n&quot;,SgNode::get_globalQualifiedNameMapForNames().size());</a>
<a name="14571"><span class="lineNum">   14571 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;SgNode::get_globalQualifiedNameMapForTypes().size() = %&quot; PRIuPTR &quot; \n&quot;,SgNode::get_globalQualifiedNameMapForTypes().size());</a>
<a name="14572"><span class="lineNum">   14572 </span>            : #endif</a>
<a name="14573"><span class="lineNum">   14573 </span>            :         }</a>
<a name="14574"><span class="lineNum">   14574 </span>            :        else</a>
<a name="14575"><span class="lineNum">   14575 </span>            :         {</a>
<a name="14576"><span class="lineNum">   14576 </span>            :        // If it already existes then overwrite the existing information.</a>
<a name="14577"><span class="lineNum">   14577 </span>            :        // std::map&lt;SgNode*,std::string&gt;::iterator i = qualifiedNameMapForNames.find(pointerMemberType);</a>
<a name="14578"><span class="lineNum">   14578 </span>            :        // ROSE_ASSERT (i != qualifiedNameMapForNames.end());</a>
<a name="14579"><span class="lineNum">   14579 </span><span class="lineCov">       3347 :           std::map&lt;SgNode*,std::string&gt;::iterator i = qualifiedNameMapForTypes.find(pointerMemberType);</span></a>
<a name="14580"><span class="lineNum">   14580 </span><span class="lineCov">        165 :           ROSE_ASSERT (i != qualifiedNameMapForTypes.end());</span></a>
<a name="14581"><span class="lineNum">   14581 </span>            : </a>
<a name="14582"><span class="lineNum">   14582 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="14583"><span class="lineNum">   14583 </span>            :           string previousQualifier = i-&gt;second.c_str();</a>
<a name="14584"><span class="lineNum">   14584 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;WARNING: test 3: replacing previousQualifier = %s with new qualifier = %s \n&quot;,previousQualifier.c_str(),qualifier.c_str());</a>
<a name="14585"><span class="lineNum">   14585 </span>            : #endif</a>
<a name="14586"><span class="lineNum">   14586 </span><span class="lineCov">        165 :           if (i-&gt;second != qualifier)</span></a>
<a name="14587"><span class="lineNum">   14587 </span>            :              {</a>
<a name="14588"><span class="lineNum">   14588 </span>            :             // DQ (3/15/2019): We need to disable the assertion below because it can happen (see Cxx11_tests/test2019_214.C).</a>
<a name="14589"><span class="lineNum">   14589 </span><span class="lineCov">        382 :                i-&gt;second = qualifier;</span></a>
<a name="14590"><span class="lineNum">   14590 </span>            : #if 0</a>
<a name="14591"><span class="lineNum">   14591 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Error: name in qualifiedNameMapForTypes already exists and is different... \n&quot;);</a>
<a name="14592"><span class="lineNum">   14592 </span>            :                ROSE_ABORT();</a>
<a name="14593"><span class="lineNum">   14593 </span>            : #endif</a>
<a name="14594"><span class="lineNum">   14594 </span>            :              }</a>
<a name="14595"><span class="lineNum">   14595 </span>            :         }</a>
<a name="14596"><span class="lineNum">   14596 </span>            : </a>
<a name="14597"><span class="lineNum">   14597 </span>            : #if 0</a>
<a name="14598"><span class="lineNum">   14598 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="14599"><span class="lineNum">   14599 </span>            :      ROSE_ABORT();</a>
<a name="14600"><span class="lineNum">   14600 </span>            : #endif</a>
<a name="14601"><span class="lineNum">   14601 </span><span class="lineCov">        382 :    }</span></a>
<a name="14602"><span class="lineNum">   14602 </span>            : </a>
<a name="14603"><span class="lineNum">   14603 </span>            : </a>
<a name="14604"><span class="lineNum">   14604 </span>            : </a>
<a name="14605"><span class="lineNum">   14605 </span>            : </a>
<a name="14606"><span class="lineNum">   14606 </span>            : void</a>
<a name="14607"><span class="lineNum">   14607 </span><span class="lineCov">      20437 : NameQualificationTraversal::setNameQualification(SgVarRefExp* varRefExp, SgVariableDeclaration* variableDeclaration, int amountOfNameQualificationRequired)</span></a>
<a name="14608"><span class="lineNum">   14608 </span>            :    {</a>
<a name="14609"><span class="lineNum">   14609 </span>            :   // This is where we hide the details of translating the intepretation of the amountOfNameQualificationRequired</a>
<a name="14610"><span class="lineNum">   14610 </span>            :   // which can be greater than the number of nested scopes to a representation that is bounded by the number of</a>
<a name="14611"><span class="lineNum">   14611 </span>            :   // nested scopes and sets the global qualification to be true. If I decide I don't like this here, then we</a>
<a name="14612"><span class="lineNum">   14612 </span>            :   // might find a way to handling this point more directly later. This at least gets it set properly in the AST.</a>
<a name="14613"><span class="lineNum">   14613 </span>            : </a>
<a name="14614"><span class="lineNum">   14614 </span>            :   // Setup call to refactored code.</a>
<a name="14615"><span class="lineNum">   14615 </span><span class="lineCov">      20437 :      int  outputNameQualificationLength = 0;</span></a>
<a name="14616"><span class="lineNum">   14616 </span><span class="lineCov">      20437 :      bool outputGlobalQualification     = false;</span></a>
<a name="14617"><span class="lineNum">   14617 </span><span class="lineCov">      20437 :      bool outputTypeEvaluation          = false;</span></a>
<a name="14618"><span class="lineNum">   14618 </span>            : </a>
<a name="14619"><span class="lineNum">   14619 </span>            :   // DQ (7/31/2012): check if this is a SgVarRefExp that is associated with a class that is un-named, if so then</a>
<a name="14620"><span class="lineNum">   14620 </span>            :   // supress the name qualification (which would use the internally generated name).  Note that all constructs</a>
<a name="14621"><span class="lineNum">   14621 </span>            :   // that are un-named have names generated internally for them so that we can support the AST merge process</a>
<a name="14622"><span class="lineNum">   14622 </span>            :   // and generally reference multiple un-named constructs that may exist in a single compilation unit.</a>
<a name="14623"><span class="lineNum">   14623 </span>            :   // SgClassDeclaration* classDeclaration = isSgClassDeclaration(varRefExp-&gt;parent());</a>
<a name="14624"><span class="lineNum">   14624 </span>            : </a>
<a name="14625"><span class="lineNum">   14625 </span><span class="lineCov">      20437 :      ASSERT_not_null(varRefExp);</span></a>
<a name="14626"><span class="lineNum">   14626 </span><span class="lineCov">      20437 :      SgBinaryOp* dotExp   = isSgDotExp(varRefExp-&gt;get_parent());</span></a>
<a name="14627"><span class="lineNum">   14627 </span><span class="lineCov">      20437 :      SgBinaryOp* arrowExp = isSgArrowExp(varRefExp-&gt;get_parent());</span></a>
<a name="14628"><span class="lineNum">   14628 </span>            : </a>
<a name="14629"><span class="lineNum">   14629 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="14630"><span class="lineNum">   14630 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In setNameQualification(SgVarRefExp*) \n&quot;);</a>
<a name="14631"><span class="lineNum">   14631 </span>            : #endif</a>
<a name="14632"><span class="lineNum">   14632 </span>            : </a>
<a name="14633"><span class="lineNum">   14633 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="14634"><span class="lineNum">   14634 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;dotExp = %p arrowExp = %p \n&quot;,dotExp,arrowExp);</a>
<a name="14635"><span class="lineNum">   14635 </span>            : #endif</a>
<a name="14636"><span class="lineNum">   14636 </span>            : </a>
<a name="14637"><span class="lineNum">   14637 </span><span class="lineCov">      20437 :      SgVarRefExp* possibleClassVarRefExp = NULL;</span></a>
<a name="14638"><span class="lineNum">   14638 </span><span class="lineCov">      20437 :      if (dotExp != NULL)</span></a>
<a name="14639"><span class="lineNum">   14639 </span>            :         {</a>
<a name="14640"><span class="lineNum">   14640 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="14641"><span class="lineNum">   14641 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Note that this code is overly sensitive to the local structure of the AST expressions \n&quot;);</a>
<a name="14642"><span class="lineNum">   14642 </span>            : #endif</a>
<a name="14643"><span class="lineNum">   14643 </span><span class="lineCov">        763 :           possibleClassVarRefExp = isSgVarRefExp(dotExp-&gt;get_lhs_operand());</span></a>
<a name="14644"><span class="lineNum">   14644 </span>            : </a>
<a name="14645"><span class="lineNum">   14645 </span><span class="lineCov">        763 :           if (possibleClassVarRefExp == NULL)</span></a>
<a name="14646"><span class="lineNum">   14646 </span>            :              {</a>
<a name="14647"><span class="lineNum">   14647 </span><span class="lineNoCov">          0 :                SgPntrArrRefExp* possiblePntrArrRefExp = isSgPntrArrRefExp(dotExp-&gt;get_lhs_operand());</span></a>
<a name="14648"><span class="lineNum">   14648 </span><span class="lineNoCov">          0 :                if (possiblePntrArrRefExp != NULL)</span></a>
<a name="14649"><span class="lineNum">   14649 </span>            :                   {</a>
<a name="14650"><span class="lineNum">   14650 </span><span class="lineNoCov">          0 :                     possibleClassVarRefExp = isSgVarRefExp(possiblePntrArrRefExp-&gt;get_lhs_operand());</span></a>
<a name="14651"><span class="lineNum">   14651 </span>            :                   }</a>
<a name="14652"><span class="lineNum">   14652 </span>            :                  else</a>
<a name="14653"><span class="lineNum">   14653 </span>            :                   {</a>
<a name="14654"><span class="lineNum">   14654 </span>            : #if 0</a>
<a name="14655"><span class="lineNum">   14655 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;dotExp-&gt;get_lhs_operand() = %p = %s \n&quot;,dotExp-&gt;get_lhs_operand(),dotExp-&gt;get_lhs_operand()-&gt;class_name().c_str());</a>
<a name="14656"><span class="lineNum">   14656 </span>            : #endif</a>
<a name="14657"><span class="lineNum">   14657 </span>            :                   }</a>
<a name="14658"><span class="lineNum">   14658 </span>            :              }</a>
<a name="14659"><span class="lineNum">   14659 </span>            :         }</a>
<a name="14660"><span class="lineNum">   14660 </span>            : </a>
<a name="14661"><span class="lineNum">   14661 </span><span class="lineCov">      20437 :      if (arrowExp != NULL)</span></a>
<a name="14662"><span class="lineNum">   14662 </span>            :         {</a>
<a name="14663"><span class="lineNum">   14663 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="14664"><span class="lineNum">   14664 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Note that this code is overly sensitive to the local structure of the AST expressions \n&quot;);</a>
<a name="14665"><span class="lineNum">   14665 </span>            : #endif</a>
<a name="14666"><span class="lineNum">   14666 </span><span class="lineCov">        920 :           possibleClassVarRefExp = isSgVarRefExp(arrowExp-&gt;get_lhs_operand());</span></a>
<a name="14667"><span class="lineNum">   14667 </span>            : </a>
<a name="14668"><span class="lineNum">   14668 </span><span class="lineCov">        920 :           if (possibleClassVarRefExp == NULL)</span></a>
<a name="14669"><span class="lineNum">   14669 </span>            :              {</a>
<a name="14670"><span class="lineNum">   14670 </span><span class="lineNoCov">          0 :                SgPntrArrRefExp* possiblePntrArrRefExp = isSgPntrArrRefExp(arrowExp-&gt;get_lhs_operand());</span></a>
<a name="14671"><span class="lineNum">   14671 </span><span class="lineNoCov">          0 :                if (possiblePntrArrRefExp != NULL)</span></a>
<a name="14672"><span class="lineNum">   14672 </span>            :                   {</a>
<a name="14673"><span class="lineNum">   14673 </span><span class="lineNoCov">          0 :                     possibleClassVarRefExp = isSgVarRefExp(possiblePntrArrRefExp-&gt;get_lhs_operand());</span></a>
<a name="14674"><span class="lineNum">   14674 </span>            :                   }</a>
<a name="14675"><span class="lineNum">   14675 </span>            :              }</a>
<a name="14676"><span class="lineNum">   14676 </span>            : #if 0</a>
<a name="14677"><span class="lineNum">   14677 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Case of SgVarRefExp to un-named class not finished yet! \n&quot;);</a>
<a name="14678"><span class="lineNum">   14678 </span>            :           ROSE_ABORT();</a>
<a name="14679"><span class="lineNum">   14679 </span>            : #endif</a>
<a name="14680"><span class="lineNum">   14680 </span>            :         }</a>
<a name="14681"><span class="lineNum">   14681 </span>            : </a>
<a name="14682"><span class="lineNum">   14682 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="14683"><span class="lineNum">   14683 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;possibleClassVarRefExp = %p \n&quot;,possibleClassVarRefExp);</a>
<a name="14684"><span class="lineNum">   14684 </span>            : #endif</a>
<a name="14685"><span class="lineNum">   14685 </span>            : </a>
<a name="14686"><span class="lineNum">   14686 </span><span class="lineCov">      20437 :      SgClassType* classType = NULL;</span></a>
<a name="14687"><span class="lineNum">   14687 </span><span class="lineCov">      20437 :      if (possibleClassVarRefExp != NULL)</span></a>
<a name="14688"><span class="lineNum">   14688 </span>            :         {</a>
<a name="14689"><span class="lineNum">   14689 </span><span class="lineCov">       1683 :           SgType* varRefExpType = possibleClassVarRefExp-&gt;get_type();</span></a>
<a name="14690"><span class="lineNum">   14690 </span><span class="lineCov">       1683 :           ASSERT_not_null(varRefExpType);</span></a>
<a name="14691"><span class="lineNum">   14691 </span>            : </a>
<a name="14692"><span class="lineNum">   14692 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="14693"><span class="lineNum">   14693 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): varRefExpType = %p = %s \n&quot;,varRefExpType,varRefExpType-&gt;class_name().c_str());</a>
<a name="14694"><span class="lineNum">   14694 </span>            : #endif</a>
<a name="14695"><span class="lineNum">   14695 </span>            : </a>
<a name="14696"><span class="lineNum">   14696 </span>            :        // DQ (8/2/2012): test2007_06.C and test2012_156.C show that we need to strip past the typedefs.</a>
<a name="14697"><span class="lineNum">   14697 </span>            :        // Note that we don't want to strip typedefs, since that could take us past public types and into private types.</a>
<a name="14698"><span class="lineNum">   14698 </span>            :        // SgType* possibleClassType = varRefExpType-&gt;stripType(SgType::STRIP_MODIFIER_TYPE|SgType::STRIP_REFERENCE_TYPE|SgType::STRIP_POINTER_TYPE|SgType::STRIP_ARRAY_TYPE); // Excluding SgType::STRIP_TYPEDEF_TYPE</a>
<a name="14699"><span class="lineNum">   14699 </span><span class="lineCov">       1683 :           SgType* possibleClassType = varRefExpType-&gt;stripType(SgType::STRIP_MODIFIER_TYPE|SgType::STRIP_REFERENCE_TYPE|SgType::STRIP_RVALUE_REFERENCE_TYPE|SgType::STRIP_POINTER_TYPE|SgType::STRIP_ARRAY_TYPE|SgType::STRIP_TYPEDEF_TYPE);</span></a>
<a name="14700"><span class="lineNum">   14700 </span><span class="lineCov">       1683 :           classType = isSgClassType(possibleClassType);</span></a>
<a name="14701"><span class="lineNum">   14701 </span>            :         }</a>
<a name="14702"><span class="lineNum">   14702 </span>            : </a>
<a name="14703"><span class="lineNum">   14703 </span>            : </a>
<a name="14704"><span class="lineNum">   14704 </span><span class="lineCov">       1683 :      bool isAnUnamedConstructs = false;</span></a>
<a name="14705"><span class="lineNum">   14705 </span><span class="lineCov">       1683 :      if (classType != NULL)</span></a>
<a name="14706"><span class="lineNum">   14706 </span>            :         {</a>
<a name="14707"><span class="lineNum">   14707 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="14708"><span class="lineNum">   14708 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): classType = %p = %s \n&quot;,classType,classType-&gt;class_name().c_str());</a>
<a name="14709"><span class="lineNum">   14709 </span>            : #endif</a>
<a name="14710"><span class="lineNum">   14710 </span><span class="lineCov">        387 :           SgClassDeclaration* classDeclaration = isSgClassDeclaration(classType-&gt;get_declaration());</span></a>
<a name="14711"><span class="lineNum">   14711 </span><span class="lineCov">        387 :           ASSERT_not_null(classDeclaration);</span></a>
<a name="14712"><span class="lineNum">   14712 </span>            : </a>
<a name="14713"><span class="lineNum">   14713 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="14714"><span class="lineNum">   14714 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): classDeclaration = %p = %s \n&quot;,classDeclaration,classDeclaration-&gt;class_name().c_str());</a>
<a name="14715"><span class="lineNum">   14715 </span>            : #endif</a>
<a name="14716"><span class="lineNum">   14716 </span>            : </a>
<a name="14717"><span class="lineNum">   14717 </span>            : #if 0</a>
<a name="14718"><span class="lineNum">   14718 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): classDeclaration-&gt;get_definingDeclaration() = %p \n&quot;,classDeclaration-&gt;get_definingDeclaration());</a>
<a name="14719"><span class="lineNum">   14719 </span>            : #endif</a>
<a name="14720"><span class="lineNum">   14720 </span>            : </a>
<a name="14721"><span class="lineNum">   14721 </span>            :        // DQ (9/4/2012): I don't think that the defining declaration should have to exist.</a>
<a name="14722"><span class="lineNum">   14722 </span>            :        // However this was a previously passing test for all of the regression tests.</a>
<a name="14723"><span class="lineNum">   14723 </span>            :        // ASSERT_not_null(classDeclaration-&gt;get_definingDeclaration());</a>
<a name="14724"><span class="lineNum">   14724 </span><span class="lineCov">        387 :           if (classDeclaration-&gt;get_definingDeclaration() != NULL)</span></a>
<a name="14725"><span class="lineNum">   14725 </span>            :              {</a>
<a name="14726"><span class="lineNum">   14726 </span><span class="lineCov">        387 :                SgClassDeclaration* definingClassDeclaration = isSgClassDeclaration(classDeclaration-&gt;get_definingDeclaration());</span></a>
<a name="14727"><span class="lineNum">   14727 </span>            : #if 0</a>
<a name="14728"><span class="lineNum">   14728 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): definingClassDeclaration = %p \n&quot;,definingClassDeclaration);</a>
<a name="14729"><span class="lineNum">   14729 </span>            : #endif</a>
<a name="14730"><span class="lineNum">   14730 </span><span class="lineCov">        387 :                if (definingClassDeclaration == NULL)</span></a>
<a name="14731"><span class="lineNum">   14731 </span>            :                   {</a>
<a name="14732"><span class="lineNum">   14732 </span><span class="lineNoCov">          0 :                     mfprintf(mlog [ WARN ] ) (&quot;ERROR: definingClassDeclaration == NULL: classDeclaration-&gt;get_definingDeclaration() = %p = %s \n&quot;,classDeclaration-&gt;get_definingDeclaration(),classDeclaration-&gt;get_definingDeclaration()-&gt;class_name().c_str());</span></a>
<a name="14733"><span class="lineNum">   14733 </span>            :                   }</a>
<a name="14734"><span class="lineNum">   14734 </span><span class="lineCov">        387 :                ASSERT_not_null(definingClassDeclaration);</span></a>
<a name="14735"><span class="lineNum">   14735 </span>            : </a>
<a name="14736"><span class="lineNum">   14736 </span>            :             // This should be true so assert this here.</a>
<a name="14737"><span class="lineNum">   14737 </span><span class="lineCov">        387 :                ROSE_ASSERT(classDeclaration-&gt;get_isUnNamed() == definingClassDeclaration-&gt;get_isUnNamed());</span></a>
<a name="14738"><span class="lineNum">   14738 </span>            :              }</a>
<a name="14739"><span class="lineNum">   14739 </span>            :             else</a>
<a name="14740"><span class="lineNum">   14740 </span>            :              {</a>
<a name="14741"><span class="lineNum">   14741 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="14742"><span class="lineNum">   14742 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;WARNING: classDeclaration-&gt;get_definingDeclaration() == NULL: This was a previously passing test, but not now that we have force SgTemplateTypes to be handled in the local type table. \n&quot;);</a>
<a name="14743"><span class="lineNum">   14743 </span>            : #endif</a>
<a name="14744"><span class="lineNum">   14744 </span>            :              }</a>
<a name="14745"><span class="lineNum">   14745 </span>            : </a>
<a name="14746"><span class="lineNum">   14746 </span><span class="lineCov">        387 :           if (classDeclaration-&gt;get_isUnNamed() == true)</span></a>
<a name="14747"><span class="lineNum">   14747 </span>            :              {</a>
<a name="14748"><span class="lineNum">   14748 </span><span class="lineCov">         26 :                isAnUnamedConstructs = true;</span></a>
<a name="14749"><span class="lineNum">   14749 </span>            : #if 0</a>
<a name="14750"><span class="lineNum">   14750 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Error: This is an un-named class/struct and so we can't generate name qualification for it's data members. \n&quot;);</a>
<a name="14751"><span class="lineNum">   14751 </span>            :                ROSE_ABORT();</a>
<a name="14752"><span class="lineNum">   14752 </span>            : #endif</a>
<a name="14753"><span class="lineNum">   14753 </span>            :              }</a>
<a name="14754"><span class="lineNum">   14754 </span>            :         }</a>
<a name="14755"><span class="lineNum">   14755 </span>            : </a>
<a name="14756"><span class="lineNum">   14756 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="14757"><span class="lineNum">   14757 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): isAnUnamedConstructs = %s \n&quot;,isAnUnamedConstructs ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="14758"><span class="lineNum">   14758 </span>            : #endif</a>
<a name="14759"><span class="lineNum">   14759 </span>            : </a>
<a name="14760"><span class="lineNum">   14760 </span>            :   // DQ (7/31/2012): If this is an un-named construct then no qualifiaction can be used since there is no associated name.</a>
<a name="14761"><span class="lineNum">   14761 </span><span class="lineCov">         26 :      if (isAnUnamedConstructs == false)</span></a>
<a name="14762"><span class="lineNum">   14762 </span>            :         {</a>
<a name="14763"><span class="lineNum">   14763 </span><span class="lineCov">      20411 :           SgScopeStatement * scope = traverseNonrealDeclForCorrectScope(variableDeclaration);</span></a>
<a name="14764"><span class="lineNum">   14764 </span><span class="lineCov">      40822 :           string qualifier = setNameQualificationSupport(scope,amountOfNameQualificationRequired, outputNameQualificationLength, outputGlobalQualification, outputTypeEvaluation);</span></a>
<a name="14765"><span class="lineNum">   14765 </span>            : </a>
<a name="14766"><span class="lineNum">   14766 </span><span class="lineCov">      20411 :           varRefExp-&gt;set_global_qualification_required(outputGlobalQualification);</span></a>
<a name="14767"><span class="lineNum">   14767 </span><span class="lineCov">      20411 :           varRefExp-&gt;set_name_qualification_length(outputNameQualificationLength);</span></a>
<a name="14768"><span class="lineNum">   14768 </span>            : </a>
<a name="14769"><span class="lineNum">   14769 </span>            :        // There should be no type evaluation required for a variable reference, as I recall.</a>
<a name="14770"><span class="lineNum">   14770 </span><span class="lineCov">      20411 :           ROSE_ASSERT(outputTypeEvaluation == false);</span></a>
<a name="14771"><span class="lineNum">   14771 </span><span class="lineCov">      20411 :           varRefExp-&gt;set_type_elaboration_required(outputTypeEvaluation);</span></a>
<a name="14772"><span class="lineNum">   14772 </span>            : </a>
<a name="14773"><span class="lineNum">   14773 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="14774"><span class="lineNum">   14774 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): varRefExp-&gt;get_name_qualification_length()     = %d \n&quot;,varRefExp-&gt;get_name_qualification_length());</a>
<a name="14775"><span class="lineNum">   14775 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): varRefExp-&gt;get_type_elaboration_required()     = %s \n&quot;,varRefExp-&gt;get_type_elaboration_required() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="14776"><span class="lineNum">   14776 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): varRefExp-&gt;get_global_qualification_required() = %s \n&quot;,varRefExp-&gt;get_global_qualification_required() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="14777"><span class="lineNum">   14777 </span>            : #endif</a>
<a name="14778"><span class="lineNum">   14778 </span>            : </a>
<a name="14779"><span class="lineNum">   14779 </span><span class="lineCov">      40822 :           if (qualifiedNameMapForNames.find(varRefExp) == qualifiedNameMapForNames.end())</span></a>
<a name="14780"><span class="lineNum">   14780 </span>            :              {</a>
<a name="14781"><span class="lineNum">   14781 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="14782"><span class="lineNum">   14782 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Inserting qualifier for name = %s into list at IR node = %p = %s \n&quot;,qualifier.c_str(),varRefExp,varRefExp-&gt;class_name().c_str());</a>
<a name="14783"><span class="lineNum">   14783 </span>            : #endif</a>
<a name="14784"><span class="lineNum">   14784 </span><span class="lineCov">      40822 :                qualifiedNameMapForNames.insert(std::pair&lt;SgNode*,std::string&gt;(varRefExp,qualifier));</span></a>
<a name="14785"><span class="lineNum">   14785 </span>            :              }</a>
<a name="14786"><span class="lineNum">   14786 </span>            :             else</a>
<a name="14787"><span class="lineNum">   14787 </span>            :              {</a>
<a name="14788"><span class="lineNum">   14788 </span>            :             // DQ (6/20/2011): We see this case in test2011_87.C.</a>
<a name="14789"><span class="lineNum">   14789 </span>            :             // If it already existes then overwrite the existing information.</a>
<a name="14790"><span class="lineNum">   14790 </span><span class="lineNoCov">          0 :                std::map&lt;SgNode*,std::string&gt;::iterator i = qualifiedNameMapForNames.find(varRefExp);</span></a>
<a name="14791"><span class="lineNum">   14791 </span><span class="lineNoCov">          0 :                ROSE_ASSERT (i != qualifiedNameMapForNames.end());</span></a>
<a name="14792"><span class="lineNum">   14792 </span>            : </a>
<a name="14793"><span class="lineNum">   14793 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="14794"><span class="lineNum">   14794 </span>            :                string previousQualifier = i-&gt;second.c_str();</a>
<a name="14795"><span class="lineNum">   14795 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;WARNING: test 2: replacing previousQualifier = %s with new qualifier = %s \n&quot;,previousQualifier.c_str(),qualifier.c_str());</a>
<a name="14796"><span class="lineNum">   14796 </span>            : #endif</a>
<a name="14797"><span class="lineNum">   14797 </span><span class="lineNoCov">          0 :                if (i-&gt;second != qualifier)</span></a>
<a name="14798"><span class="lineNum">   14798 </span>            :                   {</a>
<a name="14799"><span class="lineNum">   14799 </span>            :                  // DQ (7/23/2011): Multiple uses of the SgVarRefExp expression in SgArrayType will cause</a>
<a name="14800"><span class="lineNum">   14800 </span>            :                  // the name qualification to be reset each time.  This is OK since it is used to build</a>
<a name="14801"><span class="lineNum">   14801 </span>            :                  // the type name that will be saved.</a>
<a name="14802"><span class="lineNum">   14802 </span><span class="lineCov">      20411 :                     i-&gt;second = qualifier;</span></a>
<a name="14803"><span class="lineNum">   14803 </span>            : #if 0</a>
<a name="14804"><span class="lineNum">   14804 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Note: name in qualifiedNameMapForNames already exists and is different... \n&quot;);</a>
<a name="14805"><span class="lineNum">   14805 </span>            : #endif</a>
<a name="14806"><span class="lineNum">   14806 </span>            :                   }</a>
<a name="14807"><span class="lineNum">   14807 </span>            :              }</a>
<a name="14808"><span class="lineNum">   14808 </span>            :         }</a>
<a name="14809"><span class="lineNum">   14809 </span>            :        else</a>
<a name="14810"><span class="lineNum">   14810 </span>            :         {</a>
<a name="14811"><span class="lineNum">   14811 </span>            : #if 0</a>
<a name="14812"><span class="lineNum">   14812 </span>            :        // DQ (1/14/2020): Adding support to ignore un-named classes.</a>
<a name="14813"><span class="lineNum">   14813 </span>            :        // It might be that we need to check the name of the type of the variable instead of the name of the variable.</a>
<a name="14814"><span class="lineNum">   14814 </span>            : </a>
<a name="14815"><span class="lineNum">   14815 </span>            :           bool isVariableClassUnnamed = false;</a>
<a name="14816"><span class="lineNum">   14816 </span>            : </a>
<a name="14817"><span class="lineNum">   14817 </span>            :           SgVariableSymbol* variableSymbol = varRefExp-&gt;get_symbol();</a>
<a name="14818"><span class="lineNum">   14818 </span>            : #if 0</a>
<a name="14819"><span class="lineNum">   14819 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;variableSymbol-&gt;get_name() = %s \n&quot;,variableSymbol-&gt;get_name().str());</a>
<a name="14820"><span class="lineNum">   14820 </span>            : #endif</a>
<a name="14821"><span class="lineNum">   14821 </span>            :           string variable_name = variableSymbol-&gt;get_name().str();</a>
<a name="14822"><span class="lineNum">   14822 </span>            :           if (variable_name.substr(0,14) == &quot;__anonymous_0x&quot;)</a>
<a name="14823"><span class="lineNum">   14823 </span>            :              {</a>
<a name="14824"><span class="lineNum">   14824 </span>            :             // If this is an unnamed variable then do nothing.</a>
<a name="14825"><span class="lineNum">   14825 </span>            : #if 0</a>
<a name="14826"><span class="lineNum">   14826 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Detected unnamed variable (from unnamed class and so we want to skip name qualification here) \n&quot;);</a>
<a name="14827"><span class="lineNum">   14827 </span>            : #endif</a>
<a name="14828"><span class="lineNum">   14828 </span>            : #if 0</a>
<a name="14829"><span class="lineNum">   14829 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="14830"><span class="lineNum">   14830 </span>            :                ROSE_ABORT();</a>
<a name="14831"><span class="lineNum">   14831 </span>            : #endif</a>
<a name="14832"><span class="lineNum">   14832 </span>            :              }</a>
<a name="14833"><span class="lineNum">   14833 </span>            :             else</a>
<a name="14834"><span class="lineNum">   14834 </span>            :              {</a>
<a name="14835"><span class="lineNum">   14835 </span>            : #endif</a>
<a name="14836"><span class="lineNum">   14836 </span><span class="lineCov">         26 :                SgScopeStatement * scope = traverseNonrealDeclForCorrectScope(variableDeclaration);</span></a>
<a name="14837"><span class="lineNum">   14837 </span><span class="lineCov">         52 :                string qualifier = setNameQualificationSupport(scope,amountOfNameQualificationRequired, outputNameQualificationLength, outputGlobalQualification, outputTypeEvaluation);</span></a>
<a name="14838"><span class="lineNum">   14838 </span>            : </a>
<a name="14839"><span class="lineNum">   14839 </span><span class="lineCov">         26 :                varRefExp-&gt;set_global_qualification_required(outputGlobalQualification);</span></a>
<a name="14840"><span class="lineNum">   14840 </span><span class="lineCov">         26 :                varRefExp-&gt;set_name_qualification_length(outputNameQualificationLength);</span></a>
<a name="14841"><span class="lineNum">   14841 </span>            : </a>
<a name="14842"><span class="lineNum">   14842 </span>            :             // There should be no type evaluation required for a variable reference, as I recall.</a>
<a name="14843"><span class="lineNum">   14843 </span><span class="lineCov">         26 :                ROSE_ASSERT(outputTypeEvaluation == false);</span></a>
<a name="14844"><span class="lineNum">   14844 </span><span class="lineCov">         26 :                varRefExp-&gt;set_type_elaboration_required(outputTypeEvaluation);</span></a>
<a name="14845"><span class="lineNum">   14845 </span>            : </a>
<a name="14846"><span class="lineNum">   14846 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="14847"><span class="lineNum">   14847 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): varRefExp-&gt;get_name_qualification_length()     = %d \n&quot;,varRefExp-&gt;get_name_qualification_length());</a>
<a name="14848"><span class="lineNum">   14848 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): varRefExp-&gt;get_type_elaboration_required()     = %s \n&quot;,varRefExp-&gt;get_type_elaboration_required() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="14849"><span class="lineNum">   14849 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): varRefExp-&gt;get_global_qualification_required() = %s \n&quot;,varRefExp-&gt;get_global_qualification_required() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="14850"><span class="lineNum">   14850 </span>            : #endif</a>
<a name="14851"><span class="lineNum">   14851 </span>            : </a>
<a name="14852"><span class="lineNum">   14852 </span><span class="lineCov">         52 :                if (qualifiedNameMapForNames.find(varRefExp) == qualifiedNameMapForNames.end())</span></a>
<a name="14853"><span class="lineNum">   14853 </span>            :                   {</a>
<a name="14854"><span class="lineNum">   14854 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="14855"><span class="lineNum">   14855 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Inserting qualifier for name = %s into list at IR node = %p = %s \n&quot;,qualifier.c_str(),varRefExp,varRefExp-&gt;class_name().c_str());</a>
<a name="14856"><span class="lineNum">   14856 </span>            : #endif</a>
<a name="14857"><span class="lineNum">   14857 </span><span class="lineCov">         52 :                     qualifiedNameMapForNames.insert(std::pair&lt;SgNode*,std::string&gt;(varRefExp,qualifier));</span></a>
<a name="14858"><span class="lineNum">   14858 </span>            :                   }</a>
<a name="14859"><span class="lineNum">   14859 </span>            :                  else</a>
<a name="14860"><span class="lineNum">   14860 </span>            :                   {</a>
<a name="14861"><span class="lineNum">   14861 </span>            :                  // DQ (6/20/2011): We see this case in test2011_87.C.</a>
<a name="14862"><span class="lineNum">   14862 </span>            :                  // If it already existes then overwrite the existing information.</a>
<a name="14863"><span class="lineNum">   14863 </span><span class="lineNoCov">          0 :                     std::map&lt;SgNode*,std::string&gt;::iterator i = qualifiedNameMapForNames.find(varRefExp);</span></a>
<a name="14864"><span class="lineNum">   14864 </span><span class="lineNoCov">          0 :                     ROSE_ASSERT (i != qualifiedNameMapForNames.end());</span></a>
<a name="14865"><span class="lineNum">   14865 </span>            : </a>
<a name="14866"><span class="lineNum">   14866 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="14867"><span class="lineNum">   14867 </span>            :                     string previousQualifier = i-&gt;second.c_str();</a>
<a name="14868"><span class="lineNum">   14868 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;WARNING: test 2: replacing previousQualifier = %s with new qualifier = %s \n&quot;,previousQualifier.c_str(),qualifier.c_str());</a>
<a name="14869"><span class="lineNum">   14869 </span>            : #endif</a>
<a name="14870"><span class="lineNum">   14870 </span><span class="lineNoCov">          0 :                     if (i-&gt;second != qualifier)</span></a>
<a name="14871"><span class="lineNum">   14871 </span>            :                        {</a>
<a name="14872"><span class="lineNum">   14872 </span>            :                       // DQ (7/23/2011): Multiple uses of the SgVarRefExp expression in SgArrayType will cause</a>
<a name="14873"><span class="lineNum">   14873 </span>            :                       // the name qualification to be reset each time.  This is OK since it is used to build</a>
<a name="14874"><span class="lineNum">   14874 </span>            :                       // the type name that will be saved.</a>
<a name="14875"><span class="lineNum">   14875 </span><span class="lineCov">         26 :                          i-&gt;second = qualifier;</span></a>
<a name="14876"><span class="lineNum">   14876 </span>            : #if 0</a>
<a name="14877"><span class="lineNum">   14877 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;Note: name in qualifiedNameMapForNames already exists and is different... \n&quot;);</a>
<a name="14878"><span class="lineNum">   14878 </span>            : #endif</a>
<a name="14879"><span class="lineNum">   14879 </span>            :                        }</a>
<a name="14880"><span class="lineNum">   14880 </span>            :                   }</a>
<a name="14881"><span class="lineNum">   14881 </span>            : #if 0</a>
<a name="14882"><span class="lineNum">   14882 </span>            :        // DQ (1/14/2020): Adding support to ignore un-named classes.</a>
<a name="14883"><span class="lineNum">   14883 </span>            :              }</a>
<a name="14884"><span class="lineNum">   14884 </span>            : #endif</a>
<a name="14885"><span class="lineNum">   14885 </span>            :         }</a>
<a name="14886"><span class="lineNum">   14886 </span>            : </a>
<a name="14887"><span class="lineNum">   14887 </span>            : #if 0</a>
<a name="14888"><span class="lineNum">   14888 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;Leaving setNameQualification(SgVarRefExp*) \n&quot;);</a>
<a name="14889"><span class="lineNum">   14889 </span>            :      ROSE_ABORT();</a>
<a name="14890"><span class="lineNum">   14890 </span>            : #endif</a>
<a name="14891"><span class="lineNum">   14891 </span><span class="lineCov">      20437 :    }</span></a>
<a name="14892"><span class="lineNum">   14892 </span>            : </a>
<a name="14893"><span class="lineNum">   14893 </span>            : </a>
<a name="14894"><span class="lineNum">   14894 </span>            : void</a>
<a name="14895"><span class="lineNum">   14895 </span><span class="lineCov">       6086 : NameQualificationTraversal::setNameQualification(SgFunctionRefExp* functionRefExp, SgFunctionDeclaration* functionDeclaration, int amountOfNameQualificationRequired)</span></a>
<a name="14896"><span class="lineNum">   14896 </span>            :    {</a>
<a name="14897"><span class="lineNum">   14897 </span>            :   // This is where we hide the details of translating the intepretation of the amountOfNameQualificationRequired</a>
<a name="14898"><span class="lineNum">   14898 </span>            :   // which can be greater than the number of nested scopes to a representation that is bounded by the number of</a>
<a name="14899"><span class="lineNum">   14899 </span>            :   // nested scopes and sets the global qualification to be true. If I decide I don't like this here, then we</a>
<a name="14900"><span class="lineNum">   14900 </span>            :   // might find a way to handling this point more directly later. This at least gets it set properly in the AST.</a>
<a name="14901"><span class="lineNum">   14901 </span>            : </a>
<a name="14902"><span class="lineNum">   14902 </span>            :   // Setup call to refactored code.</a>
<a name="14903"><span class="lineNum">   14903 </span><span class="lineCov">       6086 :      int  outputNameQualificationLength = 0;</span></a>
<a name="14904"><span class="lineNum">   14904 </span><span class="lineCov">       6086 :      bool outputGlobalQualification     = false;</span></a>
<a name="14905"><span class="lineNum">   14905 </span><span class="lineCov">       6086 :      bool outputTypeEvaluation          = false;</span></a>
<a name="14906"><span class="lineNum">   14906 </span>            : </a>
<a name="14907"><span class="lineNum">   14907 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="14908"><span class="lineNum">   14908 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In setNameQualification(SgFunctionRefExp*) \n&quot;);</a>
<a name="14909"><span class="lineNum">   14909 </span>            : #endif</a>
<a name="14910"><span class="lineNum">   14910 </span>            : </a>
<a name="14911"><span class="lineNum">   14911 </span><span class="lineCov">       6086 :      SgScopeStatement * scope = traverseNonrealDeclForCorrectScope(functionDeclaration);</span></a>
<a name="14912"><span class="lineNum">   14912 </span><span class="lineCov">       6086 :      string qualifier = setNameQualificationSupport(scope,amountOfNameQualificationRequired, outputNameQualificationLength, outputGlobalQualification, outputTypeEvaluation);</span></a>
<a name="14913"><span class="lineNum">   14913 </span>            : </a>
<a name="14914"><span class="lineNum">   14914 </span><span class="lineCov">       6086 :      functionRefExp-&gt;set_global_qualification_required(outputGlobalQualification);</span></a>
<a name="14915"><span class="lineNum">   14915 </span><span class="lineCov">       6086 :      functionRefExp-&gt;set_name_qualification_length(outputNameQualificationLength);</span></a>
<a name="14916"><span class="lineNum">   14916 </span>            : </a>
<a name="14917"><span class="lineNum">   14917 </span>            :   // There should be no type evaluation required for a variable reference, as I recall.</a>
<a name="14918"><span class="lineNum">   14918 </span><span class="lineCov">       6086 :      ROSE_ASSERT(outputTypeEvaluation == false);</span></a>
<a name="14919"><span class="lineNum">   14919 </span><span class="lineCov">       6086 :      functionRefExp-&gt;set_type_elaboration_required(outputTypeEvaluation);</span></a>
<a name="14920"><span class="lineNum">   14920 </span>            : </a>
<a name="14921"><span class="lineNum">   14921 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="14922"><span class="lineNum">   14922 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): functionRefExp-&gt;get_name_qualification_length()     = %d \n&quot;,functionRefExp-&gt;get_name_qualification_length());</a>
<a name="14923"><span class="lineNum">   14923 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): functionRefExp-&gt;get_type_elaboration_required()     = %s \n&quot;,functionRefExp-&gt;get_type_elaboration_required() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="14924"><span class="lineNum">   14924 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): functionRefExp-&gt;get_global_qualification_required() = %s \n&quot;,functionRefExp-&gt;get_global_qualification_required() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="14925"><span class="lineNum">   14925 </span>            : #endif</a>
<a name="14926"><span class="lineNum">   14926 </span>            : </a>
<a name="14927"><span class="lineNum">   14927 </span>            :   // DQ (5/2/2012): I don't think that global qualification is allowed for friend functions (so test for this).</a>
<a name="14928"><span class="lineNum">   14928 </span>            :   // test2012_59.C is an example of this issue.</a>
<a name="14929"><span class="lineNum">   14929 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="14930"><span class="lineNum">   14930 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): functionDeclaration-&gt;get_declarationModifier().isFriend() = %s \n&quot;,functionDeclaration-&gt;get_declarationModifier().isFriend() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="14931"><span class="lineNum">   14931 </span>            :      if (functionDeclaration-&gt;get_firstNondefiningDeclaration() != NULL)</a>
<a name="14932"><span class="lineNum">   14932 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): functionDeclaration-&gt;get_firstNondefiningDeclaration()-&gt;get_declarationModifier().isFriend() = %s \n&quot;,functionDeclaration-&gt;get_firstNondefiningDeclaration()-&gt;get_declarationModifier().isFriend() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="14933"><span class="lineNum">   14933 </span>            :      if (functionDeclaration-&gt;get_definingDeclaration() != NULL)</a>
<a name="14934"><span class="lineNum">   14934 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): functionDeclaration-&gt;get_definingDeclaration()-&gt;get_declarationModifier().isFriend()         = %s \n&quot;,functionDeclaration-&gt;get_definingDeclaration()-&gt;get_declarationModifier().isFriend() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="14935"><span class="lineNum">   14935 </span>            : #endif</a>
<a name="14936"><span class="lineNum">   14936 </span>            : </a>
<a name="14937"><span class="lineNum">   14937 </span>            :   // Look for friend declaration on both declaration (defining and non-defining).</a>
<a name="14938"><span class="lineNum">   14938 </span><span class="lineCov">       6086 :      bool isFriend = false;</span></a>
<a name="14939"><span class="lineNum">   14939 </span><span class="lineCov">       6086 :      if (functionDeclaration-&gt;get_firstNondefiningDeclaration() != NULL)</span></a>
<a name="14940"><span class="lineNum">   14940 </span>            :         {</a>
<a name="14941"><span class="lineNum">   14941 </span><span class="lineCov">       6086 :           isFriend = isFriend || functionDeclaration-&gt;get_firstNondefiningDeclaration()-&gt;get_declarationModifier().isFriend();</span></a>
<a name="14942"><span class="lineNum">   14942 </span>            :         }</a>
<a name="14943"><span class="lineNum">   14943 </span><span class="lineCov">       6086 :      if (functionDeclaration-&gt;get_definingDeclaration() != NULL)</span></a>
<a name="14944"><span class="lineNum">   14944 </span>            :         {</a>
<a name="14945"><span class="lineNum">   14945 </span><span class="lineCov">       2491 :           isFriend = isFriend || functionDeclaration-&gt;get_definingDeclaration()-&gt;get_declarationModifier().isFriend();</span></a>
<a name="14946"><span class="lineNum">   14946 </span>            :         }</a>
<a name="14947"><span class="lineNum">   14947 </span>            : </a>
<a name="14948"><span class="lineNum">   14948 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="14949"><span class="lineNum">   14949 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;isFriend                                       = %s \n&quot;,isFriend ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="14950"><span class="lineNum">   14950 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;functionDeclaration-&gt;get_definingDeclaration() = %p \n&quot;,functionDeclaration-&gt;get_definingDeclaration());</a>
<a name="14951"><span class="lineNum">   14951 </span>            : #endif</a>
<a name="14952"><span class="lineNum">   14952 </span>            : </a>
<a name="14953"><span class="lineNum">   14953 </span>            :   // DQ (4/2/2014): After discusion with Markus, this is a problem that is a significant</a>
<a name="14954"><span class="lineNum">   14954 </span>            :   // issue and requires a general solution that would be useful more generally than just</a>
<a name="14955"><span class="lineNum">   14955 </span>            :   // to this specific problem.  We need to build a data stucture and hide it behind a</a>
<a name="14956"><span class="lineNum">   14956 </span>            :   // class with an appropriate API.  The data structure should have a container of</a>
<a name="14957"><span class="lineNum">   14957 </span>            :   // non-defining declarations for each first-non-defining declaration.  Thus we would</a>
<a name="14958"><span class="lineNum">   14958 </span>            :   // have a way to find all of the non-defining declarations associated with any</a>
<a name="14959"><span class="lineNum">   14959 </span>            :   // function and thus query if one of them was declard in a scope that defined its</a>
<a name="14960"><span class="lineNum">   14960 </span>            :   // scope definatively.  This class should be a part of an AST Information sort of</a>
<a name="14961"><span class="lineNum">   14961 </span>            :   // object that we would use to collect similar analysis information that would be</a>
<a name="14962"><span class="lineNum">   14962 </span>            :   // seperate from the AST, but might be used with the AST for certain purposes</a>
<a name="14963"><span class="lineNum">   14963 </span>            :   // (e.g. removning all functions including all associated non-defining declarations).</a>
<a name="14964"><span class="lineNum">   14964 </span>            : </a>
<a name="14965"><span class="lineNum">   14965 </span>            :   // DQ (4/6/2014): Adding support for new analysis results. Fails for test2013_242.C.</a>
<a name="14966"><span class="lineNum">   14966 </span><span class="lineCov">       6086 :      ASSERT_not_null(declarationSet);</span></a>
<a name="14967"><span class="lineNum">   14967 </span>            :   // ROSE_ASSERT(declarationSet-&gt;getDeclarationMap().size() != 0);</a>
<a name="14968"><span class="lineNum">   14968 </span>            : </a>
<a name="14969"><span class="lineNum">   14969 </span>            : #if 0</a>
<a name="14970"><span class="lineNum">   14970 </span>            :   // DQ (4/14/2019): I think that this logic is incorrect, and it is causeing Cxx11_tess/test2019_363.C to fail.</a>
<a name="14971"><span class="lineNum">   14971 </span>            :   // Experiment with commenting it out to run more tests.  Skipping this appears to work will for Cxx11_tess/test2019_363.C.</a>
<a name="14972"><span class="lineNum">   14972 </span>            : </a>
<a name="14973"><span class="lineNum">   14973 </span>            :   // DQ (4/1/2014): It might be that we need a still better test (such as if it a friend function).</a>
<a name="14974"><span class="lineNum">   14974 </span>            :      if (isFriend == true)</a>
<a name="14975"><span class="lineNum">   14975 </span>            :         {</a>
<a name="14976"><span class="lineNum">   14976 </span>            :           if (functionDeclaration-&gt;get_definingDeclaration() == NULL)</a>
<a name="14977"><span class="lineNum">   14977 </span>            :              {</a>
<a name="14978"><span class="lineNum">   14978 </span>            :             // We need to check if there is a non-defining declaration (beyond the friend declaration</a>
<a name="14979"><span class="lineNum">   14979 </span>            :             // in the Class definition) appearing in a named scope (which specifies the scope where</a>
<a name="14980"><span class="lineNum">   14980 </span>            :             // the defining declaration would appear).</a>
<a name="14981"><span class="lineNum">   14981 </span>            : </a>
<a name="14982"><span class="lineNum">   14982 </span>            :                SgDeclarationStatement* firstNondefiningDeclaration = functionDeclaration-&gt;get_firstNondefiningDeclaration();</a>
<a name="14983"><span class="lineNum">   14983 </span>            :                ASSERT_not_null(firstNondefiningDeclaration);</a>
<a name="14984"><span class="lineNum">   14984 </span>            :                bool declarationIsLocatedInDefiningScope = declarationSet-&gt;isLocatedInDefiningScope(firstNondefiningDeclaration);</a>
<a name="14985"><span class="lineNum">   14985 </span>            : </a>
<a name="14986"><span class="lineNum">   14986 </span>            :             // This is required to allow test2013_115.C to pass.</a>
<a name="14987"><span class="lineNum">   14987 </span>            :             // declarationIsLocatedInDefiningScope = false;</a>
<a name="14988"><span class="lineNum">   14988 </span>            : </a>
<a name="14989"><span class="lineNum">   14989 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="14990"><span class="lineNum">   14990 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;declarationIsLocatedInDefiningScope = %s \n&quot;,declarationIsLocatedInDefiningScope ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="14991"><span class="lineNum">   14991 </span>            : #endif</a>
<a name="14992"><span class="lineNum">   14992 </span>            : </a>
<a name="14993"><span class="lineNum">   14993 </span>            :             // DQ (1/11/2019): I think this does not apply to template declarations, since the instantiation always appear later in the global scope.</a>
<a name="14994"><span class="lineNum">   14994 </span>            :                SgTemplateInstantiationFunctionDecl* templateInstantiationFunctionDeclaration = isSgTemplateInstantiationFunctionDecl(functionDeclaration);</a>
<a name="14995"><span class="lineNum">   14995 </span>            :                bool isTemplateInstantiationFunctionDecl = false;</a>
<a name="14996"><span class="lineNum">   14996 </span>            :                if (templateInstantiationFunctionDeclaration != NULL)</a>
<a name="14997"><span class="lineNum">   14997 </span>            :                   {</a>
<a name="14998"><span class="lineNum">   14998 </span>            :                     isTemplateInstantiationFunctionDecl = true;</a>
<a name="14999"><span class="lineNum">   14999 </span>            :                   }</a>
<a name="15000"><span class="lineNum">   15000 </span>            : </a>
<a name="15001"><span class="lineNum">   15001 </span>            :             // DQ (1/11/2019): I think that where we don't want global qualification in the case of a non-template function, we do want one for an instantiation.</a>
<a name="15002"><span class="lineNum">   15002 </span>            :             // if (declarationIsLocatedInDefiningScope == true)</a>
<a name="15003"><span class="lineNum">   15003 </span>            :                if (isTemplateInstantiationFunctionDecl == true || declarationIsLocatedInDefiningScope == true)</a>
<a name="15004"><span class="lineNum">   15004 </span>            :                   {</a>
<a name="15005"><span class="lineNum">   15005 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="15006"><span class="lineNum">   15006 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;NOTE: using global qualification because there is a declaration in a defining scope \n&quot;);</a>
<a name="15007"><span class="lineNum">   15007 </span>            : #endif</a>
<a name="15008"><span class="lineNum">   15008 </span>            :                   }</a>
<a name="15009"><span class="lineNum">   15009 </span>            :                  else</a>
<a name="15010"><span class="lineNum">   15010 </span>            :                   {</a>
<a name="15011"><span class="lineNum">   15011 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="15012"><span class="lineNum">   15012 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;WARNING: skipping global qualification because there is no defining declaration \n&quot;);</a>
<a name="15013"><span class="lineNum">   15013 </span>            : #endif</a>
<a name="15014"><span class="lineNum">   15014 </span>            :                     outputGlobalQualification = false;</a>
<a name="15015"><span class="lineNum">   15015 </span>            :                     qualifier = &quot;&quot;;</a>
<a name="15016"><span class="lineNum">   15016 </span>            :                   }</a>
<a name="15017"><span class="lineNum">   15017 </span>            :              }</a>
<a name="15018"><span class="lineNum">   15018 </span>            :             else</a>
<a name="15019"><span class="lineNum">   15019 </span>            :              {</a>
<a name="15020"><span class="lineNum">   15020 </span>            :                 SgClassDefinition* classDefinition = isSgClassDefinition(functionDeclaration-&gt;get_definingDeclaration()-&gt;get_parent());</a>
<a name="15021"><span class="lineNum">   15021 </span>            :              // if (functionDeclaration-&gt;get_definingDeclaration() != NULL &amp;&amp; functionDeclaration-&gt;get_definingDeclaration()-&gt;get_parent() == functionDeclaration-&gt;get_scope())</a>
<a name="15022"><span class="lineNum">   15022 </span>            :                 if (functionDeclaration-&gt;get_definingDeclaration() != NULL &amp;&amp; classDefinition != NULL)</a>
<a name="15023"><span class="lineNum">   15023 </span>            :                   {</a>
<a name="15024"><span class="lineNum">   15024 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="15025"><span class="lineNum">   15025 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;WARNING: skipping global qualification because the defining declaration is defined in the class declaration \n&quot;);</a>
<a name="15026"><span class="lineNum">   15026 </span>            : #endif</a>
<a name="15027"><span class="lineNum">   15027 </span>            :                     outputGlobalQualification = false;</a>
<a name="15028"><span class="lineNum">   15028 </span>            :                     qualifier = &quot;&quot;;</a>
<a name="15029"><span class="lineNum">   15029 </span>            :                   }</a>
<a name="15030"><span class="lineNum">   15030 </span>            :                  else</a>
<a name="15031"><span class="lineNum">   15031 </span>            :                   {</a>
<a name="15032"><span class="lineNum">   15032 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="15033"><span class="lineNum">   15033 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;WARNING: allow global name qualification if required since function is defined outside of the class \n&quot;);</a>
<a name="15034"><span class="lineNum">   15034 </span>            : #endif</a>
<a name="15035"><span class="lineNum">   15035 </span>            :                  // DQ (11/26/2015): See test2012_59.C for an example of where this is required to be turned off.</a>
<a name="15036"><span class="lineNum">   15036 </span>            :                  // In this case it is associated with a case of multiple defining declarations due to EDG template function normalization.</a>
<a name="15037"><span class="lineNum">   15037 </span>            :                     outputGlobalQualification = false;</a>
<a name="15038"><span class="lineNum">   15038 </span>            :                     qualifier = &quot;&quot;;</a>
<a name="15039"><span class="lineNum">   15039 </span>            :                   }</a>
<a name="15040"><span class="lineNum">   15040 </span>            :              }</a>
<a name="15041"><span class="lineNum">   15041 </span>            :         }</a>
<a name="15042"><span class="lineNum">   15042 </span>            : #endif</a>
<a name="15043"><span class="lineNum">   15043 </span>            : </a>
<a name="15044"><span class="lineNum">   15044 </span>            : #if 0</a>
<a name="15045"><span class="lineNum">   15045 </span>            :   // DQ (4/1/2014): This causes test2014_29.C to fail I think it might be that the defining declaration</a>
<a name="15046"><span class="lineNum">   15046 </span>            :   // that nails down the location (scope) has been seen, but it id had not then we would want to</a>
<a name="15047"><span class="lineNum">   15047 </span>            :   // disable name qualification.</a>
<a name="15048"><span class="lineNum">   15048 </span>            :      if (outputGlobalQualification == true &amp;&amp; isFriend == true)</a>
<a name="15049"><span class="lineNum">   15049 </span>            :         {</a>
<a name="15050"><span class="lineNum">   15050 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="15051"><span class="lineNum">   15051 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;WARNING: We can't specify global qualification of friend function (qualifier reset to be empty string) \n&quot;);</a>
<a name="15052"><span class="lineNum">   15052 </span>            : #endif</a>
<a name="15053"><span class="lineNum">   15053 </span>            :        // Note that I think this might only be an issue where outputNameQualificationLength == 0.</a>
<a name="15054"><span class="lineNum">   15054 </span>            :           ROSE_ASSERT (outputNameQualificationLength == 0);</a>
<a name="15055"><span class="lineNum">   15055 </span>            : </a>
<a name="15056"><span class="lineNum">   15056 </span>            :        // Reset the values (and the qualifier string).</a>
<a name="15057"><span class="lineNum">   15057 </span>            :        // outputNameQualificationLength = 0;</a>
<a name="15058"><span class="lineNum">   15058 </span>            :           outputGlobalQualification = false;</a>
<a name="15059"><span class="lineNum">   15059 </span>            :           qualifier = &quot;&quot;;</a>
<a name="15060"><span class="lineNum">   15060 </span>            :         }</a>
<a name="15061"><span class="lineNum">   15061 </span>            : #endif</a>
<a name="15062"><span class="lineNum">   15062 </span>            : </a>
<a name="15063"><span class="lineNum">   15063 </span>            :   // mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): qualifier = %s \n&quot;,qualifier.c_str());</a>
<a name="15064"><span class="lineNum">   15064 </span>            : </a>
<a name="15065"><span class="lineNum">   15065 </span><span class="lineCov">      12172 :      if (qualifiedNameMapForNames.find(functionRefExp) == qualifiedNameMapForNames.end())</span></a>
<a name="15066"><span class="lineNum">   15066 </span>            :         {</a>
<a name="15067"><span class="lineNum">   15067 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="15068"><span class="lineNum">   15068 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Inserting qualifier for (SgFunctionRefExp) name = %s into list at IR node = %p = %s \n&quot;,qualifier.c_str(),functionRefExp,functionRefExp-&gt;class_name().c_str());</a>
<a name="15069"><span class="lineNum">   15069 </span>            : #endif</a>
<a name="15070"><span class="lineNum">   15070 </span><span class="lineCov">      12130 :           qualifiedNameMapForNames.insert(std::pair&lt;SgNode*,std::string&gt;(functionRefExp,qualifier));</span></a>
<a name="15071"><span class="lineNum">   15071 </span>            : </a>
<a name="15072"><span class="lineNum">   15072 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="15073"><span class="lineNum">   15073 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Testing name in map: for SgFunctionRefExp = %p qualified name = %s \n&quot;,functionRefExp,functionRefExp-&gt;get_qualified_name_prefix().str());</a>
<a name="15074"><span class="lineNum">   15074 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;SgNode::get_globalQualifiedNameMapForNames().size() = %&quot; PRIuPTR &quot; \n&quot;,SgNode::get_globalQualifiedNameMapForNames().size());</a>
<a name="15075"><span class="lineNum">   15075 </span>            : #endif</a>
<a name="15076"><span class="lineNum">   15076 </span>            :         }</a>
<a name="15077"><span class="lineNum">   15077 </span>            :        else</a>
<a name="15078"><span class="lineNum">   15078 </span>            :         {</a>
<a name="15079"><span class="lineNum">   15079 </span>            :        // If it already existes then overwrite the existing information.</a>
<a name="15080"><span class="lineNum">   15080 </span><span class="lineCov">        422 :           std::map&lt;SgNode*,std::string&gt;::iterator i = qualifiedNameMapForNames.find(functionRefExp);</span></a>
<a name="15081"><span class="lineNum">   15081 </span><span class="lineCov">         21 :           ROSE_ASSERT (i != qualifiedNameMapForNames.end());</span></a>
<a name="15082"><span class="lineNum">   15082 </span>            : </a>
<a name="15083"><span class="lineNum">   15083 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="15084"><span class="lineNum">   15084 </span>            :           string previousQualifier = i-&gt;second.c_str();</a>
<a name="15085"><span class="lineNum">   15085 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;WARNING: test 3: replacing previousQualifier = %s with new qualifier = %s \n&quot;,previousQualifier.c_str(),qualifier.c_str());</a>
<a name="15086"><span class="lineNum">   15086 </span>            : #endif</a>
<a name="15087"><span class="lineNum">   15087 </span><span class="lineCov">         21 :           if (i-&gt;second != qualifier)</span></a>
<a name="15088"><span class="lineNum">   15088 </span>            :              {</a>
<a name="15089"><span class="lineNum">   15089 </span>            :             // DQ (3/15/2019): We need to disable the assertion below because it can happen (see Cxx11_tests/test2019_214.C).</a>
<a name="15090"><span class="lineNum">   15090 </span><span class="lineCov">       6086 :                i-&gt;second = qualifier;</span></a>
<a name="15091"><span class="lineNum">   15091 </span>            : #if 0</a>
<a name="15092"><span class="lineNum">   15092 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Error: name in qualifiedNameMapForNames already exists and is different... \n&quot;);</a>
<a name="15093"><span class="lineNum">   15093 </span>            :                ROSE_ABORT();</a>
<a name="15094"><span class="lineNum">   15094 </span>            : #endif</a>
<a name="15095"><span class="lineNum">   15095 </span>            :              }</a>
<a name="15096"><span class="lineNum">   15096 </span>            :         }</a>
<a name="15097"><span class="lineNum">   15097 </span><span class="lineCov">       6086 :    }</span></a>
<a name="15098"><span class="lineNum">   15098 </span>            : </a>
<a name="15099"><span class="lineNum">   15099 </span>            : void</a>
<a name="15100"><span class="lineNum">   15100 </span><span class="lineCov">       5025 : NameQualificationTraversal::setNameQualification(SgMemberFunctionRefExp* functionRefExp, SgMemberFunctionDeclaration* functionDeclaration, int amountOfNameQualificationRequired)</span></a>
<a name="15101"><span class="lineNum">   15101 </span>            :    {</a>
<a name="15102"><span class="lineNum">   15102 </span>            :   // This is where we hide the details of translating the intepretation of the amountOfNameQualificationRequired</a>
<a name="15103"><span class="lineNum">   15103 </span>            :   // which can be greater than the number of nested scopes to a representation that is bounded by the number of</a>
<a name="15104"><span class="lineNum">   15104 </span>            :   // nested scopes and sets the global qualification to be true. If I decide I don't like this here, then we</a>
<a name="15105"><span class="lineNum">   15105 </span>            :   // might find a way to handling this point more directly later. This at least gets it set properly in the AST.</a>
<a name="15106"><span class="lineNum">   15106 </span>            : </a>
<a name="15107"><span class="lineNum">   15107 </span>            :   // Setup call to refactored code.</a>
<a name="15108"><span class="lineNum">   15108 </span><span class="lineCov">       5025 :      int  outputNameQualificationLength = 0;</span></a>
<a name="15109"><span class="lineNum">   15109 </span><span class="lineCov">       5025 :      bool outputGlobalQualification     = false;</span></a>
<a name="15110"><span class="lineNum">   15110 </span><span class="lineCov">       5025 :      bool outputTypeEvaluation          = false;</span></a>
<a name="15111"><span class="lineNum">   15111 </span>            : </a>
<a name="15112"><span class="lineNum">   15112 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="15113"><span class="lineNum">   15113 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In setNameQualification(SgMemberFunctionRefExp*) \n&quot;);</a>
<a name="15114"><span class="lineNum">   15114 </span>            : #endif</a>
<a name="15115"><span class="lineNum">   15115 </span>            : </a>
<a name="15116"><span class="lineNum">   15116 </span><span class="lineCov">       5025 :      SgScopeStatement * scope = traverseNonrealDeclForCorrectScope(functionDeclaration);</span></a>
<a name="15117"><span class="lineNum">   15117 </span><span class="lineCov">       5025 :      string qualifier = setNameQualificationSupport(scope,amountOfNameQualificationRequired, outputNameQualificationLength, outputGlobalQualification, outputTypeEvaluation);</span></a>
<a name="15118"><span class="lineNum">   15118 </span>            : </a>
<a name="15119"><span class="lineNum">   15119 </span><span class="lineCov">       5025 :      functionRefExp-&gt;set_global_qualification_required(outputGlobalQualification);</span></a>
<a name="15120"><span class="lineNum">   15120 </span><span class="lineCov">       5025 :      functionRefExp-&gt;set_name_qualification_length(outputNameQualificationLength);</span></a>
<a name="15121"><span class="lineNum">   15121 </span>            : </a>
<a name="15122"><span class="lineNum">   15122 </span>            :   // There should be no type evaluation required for a variable reference, as I recall.</a>
<a name="15123"><span class="lineNum">   15123 </span><span class="lineCov">       5025 :      ROSE_ASSERT(outputTypeEvaluation == false);</span></a>
<a name="15124"><span class="lineNum">   15124 </span><span class="lineCov">       5025 :      functionRefExp-&gt;set_type_elaboration_required(outputTypeEvaluation);</span></a>
<a name="15125"><span class="lineNum">   15125 </span>            : </a>
<a name="15126"><span class="lineNum">   15126 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="15127"><span class="lineNum">   15127 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): memberFunctionRefExp-&gt;get_name_qualification_length()     = %d \n&quot;,functionRefExp-&gt;get_name_qualification_length());</a>
<a name="15128"><span class="lineNum">   15128 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): memberFunctionRefExp-&gt;get_type_elaboration_required()     = %s \n&quot;,functionRefExp-&gt;get_type_elaboration_required() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="15129"><span class="lineNum">   15129 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): memberFunctionRefExp-&gt;get_global_qualification_required() = %s \n&quot;,functionRefExp-&gt;get_global_qualification_required() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="15130"><span class="lineNum">   15130 </span>            : #endif</a>
<a name="15131"><span class="lineNum">   15131 </span><span class="lineCov">      10050 :      if (qualifiedNameMapForNames.find(functionRefExp) == qualifiedNameMapForNames.end())</span></a>
<a name="15132"><span class="lineNum">   15132 </span>            :         {</a>
<a name="15133"><span class="lineNum">   15133 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="15134"><span class="lineNum">   15134 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Inserting (memberFunction) qualifier for name = %s into list at IR node = %p = %s \n&quot;,qualifier.c_str(),functionRefExp,functionRefExp-&gt;class_name().c_str());</a>
<a name="15135"><span class="lineNum">   15135 </span>            : #endif</a>
<a name="15136"><span class="lineNum">   15136 </span><span class="lineCov">      10038 :           qualifiedNameMapForNames.insert(std::pair&lt;SgNode*,std::string&gt;(functionRefExp,qualifier));</span></a>
<a name="15137"><span class="lineNum">   15137 </span>            :         }</a>
<a name="15138"><span class="lineNum">   15138 </span>            :        else</a>
<a name="15139"><span class="lineNum">   15139 </span>            :         {</a>
<a name="15140"><span class="lineNum">   15140 </span>            :        // If it already existes then overwrite the existing information.</a>
<a name="15141"><span class="lineNum">   15141 </span><span class="lineCov">        112 :           std::map&lt;SgNode*,std::string&gt;::iterator i = qualifiedNameMapForNames.find(functionRefExp);</span></a>
<a name="15142"><span class="lineNum">   15142 </span><span class="lineCov">          6 :           ROSE_ASSERT (i != qualifiedNameMapForNames.end());</span></a>
<a name="15143"><span class="lineNum">   15143 </span>            : </a>
<a name="15144"><span class="lineNum">   15144 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || 0</a>
<a name="15145"><span class="lineNum">   15145 </span>            :           string previousQualifier = i-&gt;second.c_str();</a>
<a name="15146"><span class="lineNum">   15146 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;WARNING: test 4: replacing previousQualifier = %s with new qualifier = %s \n&quot;,previousQualifier.c_str(),qualifier.c_str());</a>
<a name="15147"><span class="lineNum">   15147 </span>            : #endif</a>
<a name="15148"><span class="lineNum">   15148 </span><span class="lineCov">          6 :           if (i-&gt;second != qualifier)</span></a>
<a name="15149"><span class="lineNum">   15149 </span>            :              {</a>
<a name="15150"><span class="lineNum">   15150 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || 1</a>
<a name="15151"><span class="lineNum">   15151 </span><span class="lineNoCov">          0 :                mfprintf(mlog [ WARN ] ) (&quot;NOTE: test 4: replacing previousQualifier = %s with new qualifier = %s \n&quot;,i-&gt;second.c_str(),qualifier.c_str());</span></a>
<a name="15152"><span class="lineNum">   15152 </span>            : #endif</a>
<a name="15153"><span class="lineNum">   15153 </span><span class="lineNoCov">          0 :                i-&gt;second = qualifier;</span></a>
<a name="15154"><span class="lineNum">   15154 </span>            : #if 0</a>
<a name="15155"><span class="lineNum">   15155 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Error: name in qualifiedNameMapForNames already exists and is different... \n&quot;);</a>
<a name="15156"><span class="lineNum">   15156 </span>            :                ROSE_ABORT();</a>
<a name="15157"><span class="lineNum">   15157 </span>            : #else</a>
<a name="15158"><span class="lineNum">   15158 </span><span class="lineNoCov">          0 :                mfprintf(mlog [ WARN ] ) (&quot; --- Name qualificaiton was previously and error: we may need to set it to something different: qualifier = %s \n&quot;,qualifier.c_str());</span></a>
<a name="15159"><span class="lineNum">   15159 </span>            : #endif</a>
<a name="15160"><span class="lineNum">   15160 </span>            :              }</a>
<a name="15161"><span class="lineNum">   15161 </span>            :         }</a>
<a name="15162"><span class="lineNum">   15162 </span><span class="lineCov">       5025 :    }</span></a>
<a name="15163"><span class="lineNum">   15163 </span>            : </a>
<a name="15164"><span class="lineNum">   15164 </span>            : </a>
<a name="15165"><span class="lineNum">   15165 </span>            : void</a>
<a name="15166"><span class="lineNum">   15166 </span><span class="lineNoCov">          0 : NameQualificationTraversal::setNameQualification(SgPseudoDestructorRefExp* pseudoDestructorRefExp, SgDeclarationStatement* declarationStatement, int amountOfNameQualificationRequired)</span></a>
<a name="15167"><span class="lineNum">   15167 </span>            :    {</a>
<a name="15168"><span class="lineNum">   15168 </span>            :   // This is where we hide the details of translating the intepretation of the amountOfNameQualificationRequired</a>
<a name="15169"><span class="lineNum">   15169 </span>            :   // which can be greater than the number of nested scopes to a representation that is bounded by the number of</a>
<a name="15170"><span class="lineNum">   15170 </span>            :   // nested scopes and sets the global qualification to be true. If I decide I don't like this here, then we</a>
<a name="15171"><span class="lineNum">   15171 </span>            :   // might find a way to handling this point more directly later. This at least gets it set properly in the AST.</a>
<a name="15172"><span class="lineNum">   15172 </span>            : </a>
<a name="15173"><span class="lineNum">   15173 </span>            :   // Setup call to refactored code.</a>
<a name="15174"><span class="lineNum">   15174 </span><span class="lineNoCov">          0 :      int  outputNameQualificationLength = 0;</span></a>
<a name="15175"><span class="lineNum">   15175 </span><span class="lineNoCov">          0 :      bool outputGlobalQualification     = false;</span></a>
<a name="15176"><span class="lineNum">   15176 </span><span class="lineNoCov">          0 :      bool outputTypeEvaluation          = false;</span></a>
<a name="15177"><span class="lineNum">   15177 </span>            : </a>
<a name="15178"><span class="lineNum">   15178 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="15179"><span class="lineNum">   15179 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In setNameQualification(SgPseudoDestructorRefExp*) \n&quot;);</a>
<a name="15180"><span class="lineNum">   15180 </span>            : #endif</a>
<a name="15181"><span class="lineNum">   15181 </span>            : </a>
<a name="15182"><span class="lineNum">   15182 </span><span class="lineNoCov">          0 :      SgScopeStatement * scope = traverseNonrealDeclForCorrectScope(declarationStatement);</span></a>
<a name="15183"><span class="lineNum">   15183 </span><span class="lineNoCov">          0 :      string qualifier = setNameQualificationSupport(scope,amountOfNameQualificationRequired, outputNameQualificationLength, outputGlobalQualification, outputTypeEvaluation);</span></a>
<a name="15184"><span class="lineNum">   15184 </span>            : </a>
<a name="15185"><span class="lineNum">   15185 </span><span class="lineNoCov">          0 :      pseudoDestructorRefExp-&gt;set_global_qualification_required(outputGlobalQualification);</span></a>
<a name="15186"><span class="lineNum">   15186 </span><span class="lineNoCov">          0 :      pseudoDestructorRefExp-&gt;set_name_qualification_length(outputNameQualificationLength);</span></a>
<a name="15187"><span class="lineNum">   15187 </span>            : </a>
<a name="15188"><span class="lineNum">   15188 </span>            :   // There should be no type evaluation required for a variable reference, as I recall.</a>
<a name="15189"><span class="lineNum">   15189 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(outputTypeEvaluation == false);</span></a>
<a name="15190"><span class="lineNum">   15190 </span><span class="lineNoCov">          0 :      pseudoDestructorRefExp-&gt;set_type_elaboration_required(outputTypeEvaluation);</span></a>
<a name="15191"><span class="lineNum">   15191 </span>            : </a>
<a name="15192"><span class="lineNum">   15192 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="15193"><span class="lineNum">   15193 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): pseudoDestructorRefExp-&gt;get_name_qualification_length()     = %d \n&quot;,pseudoDestructorRefExp-&gt;get_name_qualification_length());</a>
<a name="15194"><span class="lineNum">   15194 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): pseudoDestructorRefExp-&gt;get_type_elaboration_required()     = %s \n&quot;,pseudoDestructorRefExp-&gt;get_type_elaboration_required() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="15195"><span class="lineNum">   15195 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): pseudoDestructorRefExp-&gt;get_global_qualification_required() = %s \n&quot;,pseudoDestructorRefExp-&gt;get_global_qualification_required() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="15196"><span class="lineNum">   15196 </span>            : #endif</a>
<a name="15197"><span class="lineNum">   15197 </span><span class="lineNoCov">          0 :      if (qualifiedNameMapForNames.find(pseudoDestructorRefExp) == qualifiedNameMapForNames.end())</span></a>
<a name="15198"><span class="lineNum">   15198 </span>            :         {</a>
<a name="15199"><span class="lineNum">   15199 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="15200"><span class="lineNum">   15200 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Inserting (pseudoDestructorRefExp) qualifier for name = %s into list at IR node = %p = %s \n&quot;,qualifier.c_str(),pseudoDestructorRefExp,pseudoDestructorRefExp-&gt;class_name().c_str());</a>
<a name="15201"><span class="lineNum">   15201 </span>            : #endif</a>
<a name="15202"><span class="lineNum">   15202 </span><span class="lineNoCov">          0 :           qualifiedNameMapForNames.insert(std::pair&lt;SgNode*,std::string&gt;(pseudoDestructorRefExp,qualifier));</span></a>
<a name="15203"><span class="lineNum">   15203 </span>            :         }</a>
<a name="15204"><span class="lineNum">   15204 </span>            :        else</a>
<a name="15205"><span class="lineNum">   15205 </span>            :         {</a>
<a name="15206"><span class="lineNum">   15206 </span>            :        // If it already existes then overwrite the existing information.</a>
<a name="15207"><span class="lineNum">   15207 </span><span class="lineNoCov">          0 :           std::map&lt;SgNode*,std::string&gt;::iterator i = qualifiedNameMapForNames.find(pseudoDestructorRefExp);</span></a>
<a name="15208"><span class="lineNum">   15208 </span><span class="lineNoCov">          0 :           ROSE_ASSERT (i != qualifiedNameMapForNames.end());</span></a>
<a name="15209"><span class="lineNum">   15209 </span>            : </a>
<a name="15210"><span class="lineNum">   15210 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || 0</a>
<a name="15211"><span class="lineNum">   15211 </span>            :           string previousQualifier = i-&gt;second.c_str();</a>
<a name="15212"><span class="lineNum">   15212 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;WARNING: test 4.5: replacing previousQualifier = %s with new qualifier = %s \n&quot;,previousQualifier.c_str(),qualifier.c_str());</a>
<a name="15213"><span class="lineNum">   15213 </span>            : #endif</a>
<a name="15214"><span class="lineNum">   15214 </span><span class="lineNoCov">          0 :           if (i-&gt;second != qualifier)</span></a>
<a name="15215"><span class="lineNum">   15215 </span>            :              {</a>
<a name="15216"><span class="lineNum">   15216 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || 0</a>
<a name="15217"><span class="lineNum">   15217 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;NOTE: test 4.5: replacing previousQualifier = %s with new qualifier = %s \n&quot;,i-&gt;second.c_str(),qualifier.c_str());</a>
<a name="15218"><span class="lineNum">   15218 </span>            : #endif</a>
<a name="15219"><span class="lineNum">   15219 </span><span class="lineNoCov">          0 :                i-&gt;second = qualifier;</span></a>
<a name="15220"><span class="lineNum">   15220 </span>            : #if 0</a>
<a name="15221"><span class="lineNum">   15221 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Error: name in qualifiedNameMapForNames already exists and is different... \n&quot;);</a>
<a name="15222"><span class="lineNum">   15222 </span>            :                ROSE_ABORT();</a>
<a name="15223"><span class="lineNum">   15223 </span>            : #else</a>
<a name="15224"><span class="lineNum">   15224 </span><span class="lineNoCov">          0 :                mfprintf(mlog [ WARN ] ) (&quot; --- Name qualificaiton was previously and error: we may need to set it to something different: qualifier = %s \n&quot;,qualifier.c_str());</span></a>
<a name="15225"><span class="lineNum">   15225 </span>            : #endif</a>
<a name="15226"><span class="lineNum">   15226 </span>            :              }</a>
<a name="15227"><span class="lineNum">   15227 </span>            :         }</a>
<a name="15228"><span class="lineNum">   15228 </span>            : </a>
<a name="15229"><span class="lineNum">   15229 </span>            : #if 0</a>
<a name="15230"><span class="lineNum">   15230 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;Leaving NameQualificationTraversal::setNameQualification(SgPseudoDestructorRefExp* pseudoDestructorRefExp,,,): Exiting as a test! \n&quot;);</a>
<a name="15231"><span class="lineNum">   15231 </span>            :      ROSE_ABORT();</a>
<a name="15232"><span class="lineNum">   15232 </span>            : #endif</a>
<a name="15233"><span class="lineNum">   15233 </span><span class="lineNoCov">          0 :    }</span></a>
<a name="15234"><span class="lineNum">   15234 </span>            : </a>
<a name="15235"><span class="lineNum">   15235 </span>            : </a>
<a name="15236"><span class="lineNum">   15236 </span>            : // DQ (6/4/2011): This function handles a specific case that is demonstrated by test2005_42.C.</a>
<a name="15237"><span class="lineNum">   15237 </span>            : // DQ (6/1/2011): Added support for qualification of the SgConstructorInitializer.</a>
<a name="15238"><span class="lineNum">   15238 </span>            : // void NameQualificationTraversal::setNameQualification(SgConstructorInitializer* constructorInitializer, SgMemberFunctionDeclaration* functionDeclaration, int amountOfNameQualificationRequired)</a>
<a name="15239"><span class="lineNum">   15239 </span>            : void</a>
<a name="15240"><span class="lineNum">   15240 </span><span class="lineCov">       1945 : NameQualificationTraversal::setNameQualification(SgConstructorInitializer* constructorInitializer, SgDeclarationStatement* declaration, int amountOfNameQualificationRequired)</span></a>
<a name="15241"><span class="lineNum">   15241 </span>            :    {</a>
<a name="15242"><span class="lineNum">   15242 </span>            :   // DQ (6/4/2011): This handles the case of both the declaration being a SgMemberFunctionDeclaration and a SgClassDeclaration.</a>
<a name="15243"><span class="lineNum">   15243 </span>            : </a>
<a name="15244"><span class="lineNum">   15244 </span>            :   // Setup call to refactored code.</a>
<a name="15245"><span class="lineNum">   15245 </span><span class="lineCov">       1945 :      int  outputNameQualificationLength = 0;</span></a>
<a name="15246"><span class="lineNum">   15246 </span><span class="lineCov">       1945 :      bool outputGlobalQualification     = false;</span></a>
<a name="15247"><span class="lineNum">   15247 </span><span class="lineCov">       1945 :      bool outputTypeEvaluation          = false;</span></a>
<a name="15248"><span class="lineNum">   15248 </span>            : </a>
<a name="15249"><span class="lineNum">   15249 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="15250"><span class="lineNum">   15250 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In setNameQualification(SgConstructorInitializer*) \n&quot;);</a>
<a name="15251"><span class="lineNum">   15251 </span>            : #endif</a>
<a name="15252"><span class="lineNum">   15252 </span>            : </a>
<a name="15253"><span class="lineNum">   15253 </span><span class="lineCov">       1945 :      SgScopeStatement * scope = traverseNonrealDeclForCorrectScope(declaration);</span></a>
<a name="15254"><span class="lineNum">   15254 </span><span class="lineCov">       1945 :      string qualifier = setNameQualificationSupport(scope, amountOfNameQualificationRequired, outputNameQualificationLength, outputGlobalQualification, outputTypeEvaluation);</span></a>
<a name="15255"><span class="lineNum">   15255 </span>            : </a>
<a name="15256"><span class="lineNum">   15256 </span><span class="lineCov">       1945 :      constructorInitializer-&gt;set_global_qualification_required(outputGlobalQualification);</span></a>
<a name="15257"><span class="lineNum">   15257 </span><span class="lineCov">       1945 :      constructorInitializer-&gt;set_name_qualification_length(outputNameQualificationLength);</span></a>
<a name="15258"><span class="lineNum">   15258 </span>            : </a>
<a name="15259"><span class="lineNum">   15259 </span>            :   // There should be no type evaluation required for a variable reference, as I recall.</a>
<a name="15260"><span class="lineNum">   15260 </span><span class="lineCov">       1945 :      ROSE_ASSERT(outputTypeEvaluation == false);</span></a>
<a name="15261"><span class="lineNum">   15261 </span><span class="lineCov">       1945 :      constructorInitializer-&gt;set_type_elaboration_required(outputTypeEvaluation);</span></a>
<a name="15262"><span class="lineNum">   15262 </span>            : </a>
<a name="15263"><span class="lineNum">   15263 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="15264"><span class="lineNum">   15264 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): constructorInitializer-&gt;get_name_qualification_length()     = %d \n&quot;,constructorInitializer-&gt;get_name_qualification_length());</a>
<a name="15265"><span class="lineNum">   15265 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): constructorInitializer-&gt;get_type_elaboration_required()     = %s \n&quot;,constructorInitializer-&gt;get_type_elaboration_required() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="15266"><span class="lineNum">   15266 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): constructorInitializer-&gt;get_global_qualification_required() = %s \n&quot;,constructorInitializer-&gt;get_global_qualification_required() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="15267"><span class="lineNum">   15267 </span>            : #endif</a>
<a name="15268"><span class="lineNum">   15268 </span>            : </a>
<a name="15269"><span class="lineNum">   15269 </span><span class="lineCov">       3890 :      if (qualifiedNameMapForNames.find(constructorInitializer) == qualifiedNameMapForNames.end())</span></a>
<a name="15270"><span class="lineNum">   15270 </span>            :         {</a>
<a name="15271"><span class="lineNum">   15271 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="15272"><span class="lineNum">   15272 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Inserting qualifier for name = %s into list at IR node = %p = %s \n&quot;,qualifier.c_str(),constructorInitializer,constructorInitializer-&gt;class_name().c_str());</a>
<a name="15273"><span class="lineNum">   15273 </span>            : #endif</a>
<a name="15274"><span class="lineNum">   15274 </span><span class="lineCov">       3830 :           qualifiedNameMapForNames.insert(std::pair&lt;SgNode*,std::string&gt;(constructorInitializer,qualifier));</span></a>
<a name="15275"><span class="lineNum">   15275 </span>            :         }</a>
<a name="15276"><span class="lineNum">   15276 </span>            :        else</a>
<a name="15277"><span class="lineNum">   15277 </span>            :         {</a>
<a name="15278"><span class="lineNum">   15278 </span>            :        // DQ (2/12/2012): Fixing support where the name qualification must be rewritten where it is used in a different context.</a>
<a name="15279"><span class="lineNum">   15279 </span>            :        // this appears to be a common requirement.  This case appears to not have been a problem before but is now with the</a>
<a name="15280"><span class="lineNum">   15280 </span>            :        // new EDG 4.3 support.  This has been added because of the requirements of that support.</a>
<a name="15281"><span class="lineNum">   15281 </span>            : </a>
<a name="15282"><span class="lineNum">   15282 </span>            :        // If it already existes then overwrite the existing information.</a>
<a name="15283"><span class="lineNum">   15283 </span><span class="lineCov">        529 :           std::map&lt;SgNode*,std::string&gt;::iterator i = qualifiedNameMapForNames.find(constructorInitializer);</span></a>
<a name="15284"><span class="lineNum">   15284 </span><span class="lineCov">         30 :           ROSE_ASSERT (i != qualifiedNameMapForNames.end());</span></a>
<a name="15285"><span class="lineNum">   15285 </span>            : </a>
<a name="15286"><span class="lineNum">   15286 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="15287"><span class="lineNum">   15287 </span>            :           string previousQualifier = i-&gt;second.c_str();</a>
<a name="15288"><span class="lineNum">   15288 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;WARNING: test 5: replacing previousQualifier = %s with new qualifier = %s \n&quot;,previousQualifier.c_str(),qualifier.c_str());</a>
<a name="15289"><span class="lineNum">   15289 </span>            : #endif</a>
<a name="15290"><span class="lineNum">   15290 </span>            :        // I think I can do this!</a>
<a name="15291"><span class="lineNum">   15291 </span>            :        // *i = std::pair&lt;SgNode*,std::string&gt;(templateArgument,qualifier);</a>
<a name="15292"><span class="lineNum">   15292 </span><span class="lineCov">         30 :           if (i-&gt;second != qualifier)</span></a>
<a name="15293"><span class="lineNum">   15293 </span>            :              {</a>
<a name="15294"><span class="lineNum">   15294 </span><span class="lineNoCov">          0 :                mfprintf(mlog [ WARN ] ) (&quot;Error: name in qualifiedNameMapForNames already exists and is different...\n&quot;);</span></a>
<a name="15295"><span class="lineNum">   15295 </span><span class="lineNoCov">          0 :                mfprintf(mlog [ WARN ] ) (&quot;&gt;&gt;&gt;&gt; %s\n&quot;, i-&gt;second.c_str());</span></a>
<a name="15296"><span class="lineNum">   15296 </span><span class="lineNoCov">          0 :                mfprintf(mlog [ WARN ] ) (&quot;&gt;&gt;&gt;&gt; %s\n&quot;, qualifier.c_str());</span></a>
<a name="15297"><span class="lineNum">   15297 </span><span class="lineNoCov">          0 :                i-&gt;second = qualifier;</span></a>
<a name="15298"><span class="lineNum">   15298 </span>            :              }</a>
<a name="15299"><span class="lineNum">   15299 </span>            : #if 0</a>
<a name="15300"><span class="lineNum">   15300 </span>            :        // DQ (2/12/2012): commented this code out.</a>
<a name="15301"><span class="lineNum">   15301 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Error: name in qualifiedNameMapForNames already exists... \n&quot;);</a>
<a name="15302"><span class="lineNum">   15302 </span>            :           ROSE_ABORT();</a>
<a name="15303"><span class="lineNum">   15303 </span>            : #endif</a>
<a name="15304"><span class="lineNum">   15304 </span>            :         }</a>
<a name="15305"><span class="lineNum">   15305 </span>            : </a>
<a name="15306"><span class="lineNum">   15306 </span>            :   // DQ (6/4/2011): Added test...</a>
<a name="15307"><span class="lineNum">   15307 </span><span class="lineCov">       3890 :      ROSE_ASSERT(SgNode::get_globalQualifiedNameMapForNames().find(constructorInitializer) != SgNode::get_globalQualifiedNameMapForNames().end());</span></a>
<a name="15308"><span class="lineNum">   15308 </span><span class="lineCov">       1945 :    }</span></a>
<a name="15309"><span class="lineNum">   15309 </span>            : </a>
<a name="15310"><span class="lineNum">   15310 </span>            : </a>
<a name="15311"><span class="lineNum">   15311 </span>            : void</a>
<a name="15312"><span class="lineNum">   15312 </span><span class="lineCov">       5141 : NameQualificationTraversal::setNameQualification(SgEnumVal* enumVal, SgEnumDeclaration* enumDeclaration, int amountOfNameQualificationRequired)</span></a>
<a name="15313"><span class="lineNum">   15313 </span>            :    {</a>
<a name="15314"><span class="lineNum">   15314 </span>            :   // Setup call to refactored code.</a>
<a name="15315"><span class="lineNum">   15315 </span><span class="lineCov">       5141 :      int  outputNameQualificationLength = 0;</span></a>
<a name="15316"><span class="lineNum">   15316 </span><span class="lineCov">       5141 :      bool outputGlobalQualification     = false;</span></a>
<a name="15317"><span class="lineNum">   15317 </span><span class="lineCov">       5141 :      bool outputTypeEvaluation          = false;</span></a>
<a name="15318"><span class="lineNum">   15318 </span>            : </a>
<a name="15319"><span class="lineNum">   15319 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="15320"><span class="lineNum">   15320 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In setNameQualification(SgEnumVal*) \n&quot;);</a>
<a name="15321"><span class="lineNum">   15321 </span>            : #endif</a>
<a name="15322"><span class="lineNum">   15322 </span>            : </a>
<a name="15323"><span class="lineNum">   15323 </span><span class="lineCov">       5141 :      SgScopeStatement * scope = traverseNonrealDeclForCorrectScope(enumDeclaration);</span></a>
<a name="15324"><span class="lineNum">   15324 </span><span class="lineCov">       5141 :      string qualifier = setNameQualificationSupport(scope,amountOfNameQualificationRequired, outputNameQualificationLength, outputGlobalQualification, outputTypeEvaluation);</span></a>
<a name="15325"><span class="lineNum">   15325 </span>            : </a>
<a name="15326"><span class="lineNum">   15326 </span><span class="lineCov">       5141 :      enumVal-&gt;set_global_qualification_required(outputGlobalQualification);</span></a>
<a name="15327"><span class="lineNum">   15327 </span><span class="lineCov">       5141 :      enumVal-&gt;set_name_qualification_length(outputNameQualificationLength);</span></a>
<a name="15328"><span class="lineNum">   15328 </span>            : </a>
<a name="15329"><span class="lineNum">   15329 </span>            :   // There should be no type evaluation required for a variable reference, as I recall.</a>
<a name="15330"><span class="lineNum">   15330 </span><span class="lineCov">       5141 :      ROSE_ASSERT(outputTypeEvaluation == false);</span></a>
<a name="15331"><span class="lineNum">   15331 </span><span class="lineCov">       5141 :      enumVal-&gt;set_type_elaboration_required(outputTypeEvaluation);</span></a>
<a name="15332"><span class="lineNum">   15332 </span>            : </a>
<a name="15333"><span class="lineNum">   15333 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="15334"><span class="lineNum">   15334 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): enumVal-&gt;get_name_qualification_length()     = %d \n&quot;,enumVal-&gt;get_name_qualification_length());</a>
<a name="15335"><span class="lineNum">   15335 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): enumVal-&gt;get_type_elaboration_required()     = %s \n&quot;,enumVal-&gt;get_type_elaboration_required() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="15336"><span class="lineNum">   15336 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): enumVal-&gt;get_global_qualification_required() = %s \n&quot;,enumVal-&gt;get_global_qualification_required() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="15337"><span class="lineNum">   15337 </span>            : #endif</a>
<a name="15338"><span class="lineNum">   15338 </span><span class="lineCov">      10282 :      if (qualifiedNameMapForNames.find(enumVal) == qualifiedNameMapForNames.end())</span></a>
<a name="15339"><span class="lineNum">   15339 </span>            :         {</a>
<a name="15340"><span class="lineNum">   15340 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="15341"><span class="lineNum">   15341 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Inserting qualifier for name = %s into list at IR node = %p = %s \n&quot;,qualifier.c_str(),enumVal,enumVal-&gt;class_name().c_str());</a>
<a name="15342"><span class="lineNum">   15342 </span>            : #endif</a>
<a name="15343"><span class="lineNum">   15343 </span><span class="lineCov">      10282 :           qualifiedNameMapForNames.insert(std::pair&lt;SgNode*,std::string&gt;(enumVal,qualifier));</span></a>
<a name="15344"><span class="lineNum">   15344 </span>            :         }</a>
<a name="15345"><span class="lineNum">   15345 </span>            :        else</a>
<a name="15346"><span class="lineNum">   15346 </span>            :         {</a>
<a name="15347"><span class="lineNum">   15347 </span>            :        // If it already existes then overwrite the existing information.</a>
<a name="15348"><span class="lineNum">   15348 </span><span class="lineNoCov">          0 :           std::map&lt;SgNode*,std::string&gt;::iterator i = qualifiedNameMapForNames.find(enumVal);</span></a>
<a name="15349"><span class="lineNum">   15349 </span><span class="lineNoCov">          0 :           ROSE_ASSERT (i != qualifiedNameMapForNames.end());</span></a>
<a name="15350"><span class="lineNum">   15350 </span>            : </a>
<a name="15351"><span class="lineNum">   15351 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="15352"><span class="lineNum">   15352 </span>            :           string previousQualifier = i-&gt;second.c_str();</a>
<a name="15353"><span class="lineNum">   15353 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;WARNING: test6: replacing previousQualifier = %s with new qualifier = %s \n&quot;,previousQualifier.c_str(),qualifier.c_str());</a>
<a name="15354"><span class="lineNum">   15354 </span>            : #endif</a>
<a name="15355"><span class="lineNum">   15355 </span>            :        // I think I can do this!</a>
<a name="15356"><span class="lineNum">   15356 </span>            :        // *i = std::pair&lt;SgNode*,std::string&gt;(templateArgument,qualifier);</a>
<a name="15357"><span class="lineNum">   15357 </span><span class="lineNoCov">          0 :           if (i-&gt;second != qualifier)</span></a>
<a name="15358"><span class="lineNum">   15358 </span>            :              {</a>
<a name="15359"><span class="lineNum">   15359 </span>            :             // DQ (5/3/2013): Note that this happens for test2013_144.C where the enumValue is used as the size</a>
<a name="15360"><span class="lineNum">   15360 </span>            :             // in the array type (and the SgArrayType is shared). See comments in the test code for how this</a>
<a name="15361"><span class="lineNum">   15361 </span>            :             // might be improved (forcing name qualification).</a>
<a name="15362"><span class="lineNum">   15362 </span><span class="lineCov">       5141 :                i-&gt;second = qualifier;</span></a>
<a name="15363"><span class="lineNum">   15363 </span>            : </a>
<a name="15364"><span class="lineNum">   15364 </span>            : #if 0</a>
<a name="15365"><span class="lineNum">   15365 </span>            :                enumVal-&gt;get_file_info()-&gt;display(&quot;In NameQualificationTraversal::setNameQualification(): enumVal: Where is this located&quot;);</a>
<a name="15366"><span class="lineNum">   15366 </span>            : #endif</a>
<a name="15367"><span class="lineNum">   15367 </span>            : </a>
<a name="15368"><span class="lineNum">   15368 </span>            : #if 0</a>
<a name="15369"><span class="lineNum">   15369 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Error: name in qualifiedNameMapForNames already exists and is different... \n&quot;);</a>
<a name="15370"><span class="lineNum">   15370 </span>            :                ROSE_ABORT();</a>
<a name="15371"><span class="lineNum">   15371 </span>            : #endif</a>
<a name="15372"><span class="lineNum">   15372 </span>            :              }</a>
<a name="15373"><span class="lineNum">   15373 </span>            :         }</a>
<a name="15374"><span class="lineNum">   15374 </span><span class="lineCov">       5141 :    }</span></a>
<a name="15375"><span class="lineNum">   15375 </span>            : </a>
<a name="15376"><span class="lineNum">   15376 </span>            : </a>
<a name="15377"><span class="lineNum">   15377 </span>            : void</a>
<a name="15378"><span class="lineNum">   15378 </span><span class="lineCov">       4237 : NameQualificationTraversal::setNameQualification ( SgBaseClass* baseClass, SgClassDeclaration* classDeclaration, int amountOfNameQualificationRequired )</span></a>
<a name="15379"><span class="lineNum">   15379 </span>            :    {</a>
<a name="15380"><span class="lineNum">   15380 </span>            :   // Setup call to refactored code.</a>
<a name="15381"><span class="lineNum">   15381 </span><span class="lineCov">       4237 :      int  outputNameQualificationLength = 0;</span></a>
<a name="15382"><span class="lineNum">   15382 </span><span class="lineCov">       4237 :      bool outputGlobalQualification     = false;</span></a>
<a name="15383"><span class="lineNum">   15383 </span><span class="lineCov">       4237 :      bool outputTypeEvaluation          = false;</span></a>
<a name="15384"><span class="lineNum">   15384 </span>            : </a>
<a name="15385"><span class="lineNum">   15385 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || 0</a>
<a name="15386"><span class="lineNum">   15386 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In setNameQualification(SgBaseClass*) \n&quot;);</a>
<a name="15387"><span class="lineNum">   15387 </span>            : #endif</a>
<a name="15388"><span class="lineNum">   15388 </span>            : </a>
<a name="15389"><span class="lineNum">   15389 </span><span class="lineCov">       4237 :      SgScopeStatement * scope = traverseNonrealDeclForCorrectScope(classDeclaration);</span></a>
<a name="15390"><span class="lineNum">   15390 </span><span class="lineCov">       4237 :      string qualifier = setNameQualificationSupport(scope,amountOfNameQualificationRequired, outputNameQualificationLength, outputGlobalQualification, outputTypeEvaluation);</span></a>
<a name="15391"><span class="lineNum">   15391 </span>            : </a>
<a name="15392"><span class="lineNum">   15392 </span><span class="lineCov">       4237 :      baseClass-&gt;set_global_qualification_required(outputGlobalQualification);</span></a>
<a name="15393"><span class="lineNum">   15393 </span><span class="lineCov">       4237 :      baseClass-&gt;set_name_qualification_length(outputNameQualificationLength);</span></a>
<a name="15394"><span class="lineNum">   15394 </span><span class="lineCov">       4237 :      baseClass-&gt;set_type_elaboration_required(outputTypeEvaluation);</span></a>
<a name="15395"><span class="lineNum">   15395 </span>            : </a>
<a name="15396"><span class="lineNum">   15396 </span>            :   // There should be no type evaluation required for a variable reference, as I recall.</a>
<a name="15397"><span class="lineNum">   15397 </span><span class="lineCov">       4237 :      ROSE_ASSERT(outputTypeEvaluation == false);</span></a>
<a name="15398"><span class="lineNum">   15398 </span>            : </a>
<a name="15399"><span class="lineNum">   15399 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || 0</a>
<a name="15400"><span class="lineNum">   15400 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): baseClass-&gt;get_name_qualification_length()     = %d \n&quot;,baseClass-&gt;get_name_qualification_length());</a>
<a name="15401"><span class="lineNum">   15401 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): baseClass-&gt;get_type_elaboration_required()     = %s \n&quot;,baseClass-&gt;get_type_elaboration_required() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="15402"><span class="lineNum">   15402 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): baseClass-&gt;get_global_qualification_required() = %s \n&quot;,baseClass-&gt;get_global_qualification_required() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="15403"><span class="lineNum">   15403 </span>            : #endif</a>
<a name="15404"><span class="lineNum">   15404 </span>            : </a>
<a name="15405"><span class="lineNum">   15405 </span><span class="lineCov">       8474 :      if (qualifiedNameMapForNames.find(baseClass) == qualifiedNameMapForNames.end())</span></a>
<a name="15406"><span class="lineNum">   15406 </span>            :         {</a>
<a name="15407"><span class="lineNum">   15407 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="15408"><span class="lineNum">   15408 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Inserting qualifier for name = %s into list at IR node = %p = %s \n&quot;,qualifier.c_str(),baseClass,baseClass-&gt;class_name().c_str());</a>
<a name="15409"><span class="lineNum">   15409 </span>            : #endif</a>
<a name="15410"><span class="lineNum">   15410 </span><span class="lineCov">       8474 :           qualifiedNameMapForNames.insert(std::pair&lt;SgNode*,std::string&gt;(baseClass,qualifier));</span></a>
<a name="15411"><span class="lineNum">   15411 </span>            :         }</a>
<a name="15412"><span class="lineNum">   15412 </span>            :        else</a>
<a name="15413"><span class="lineNum">   15413 </span>            :         {</a>
<a name="15414"><span class="lineNum">   15414 </span>            :        // DQ (6/17/2013): I think it is reasonable that this might have been previously set and</a>
<a name="15415"><span class="lineNum">   15415 </span>            :        // we have to overwrite the last value as we handle it again in a different context.</a>
<a name="15416"><span class="lineNum">   15416 </span>            : </a>
<a name="15417"><span class="lineNum">   15417 </span>            :        // If it already existes then overwrite the existing information.</a>
<a name="15418"><span class="lineNum">   15418 </span><span class="lineNoCov">          0 :           std::map&lt;SgNode*,std::string&gt;::iterator i = qualifiedNameMapForNames.find(baseClass);</span></a>
<a name="15419"><span class="lineNum">   15419 </span><span class="lineNoCov">          0 :           ROSE_ASSERT (i != qualifiedNameMapForNames.end());</span></a>
<a name="15420"><span class="lineNum">   15420 </span>            : </a>
<a name="15421"><span class="lineNum">   15421 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || 0</a>
<a name="15422"><span class="lineNum">   15422 </span>            :           string previousQualifier = i-&gt;second.c_str();</a>
<a name="15423"><span class="lineNum">   15423 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;WARNING: test 7: replacing previousQualifier = %s with new qualifier = %s \n&quot;,previousQualifier.c_str(),qualifier.c_str());</a>
<a name="15424"><span class="lineNum">   15424 </span>            : #endif</a>
<a name="15425"><span class="lineNum">   15425 </span>            :        // I think I can do this!</a>
<a name="15426"><span class="lineNum">   15426 </span>            :        // *i = std::pair&lt;SgNode*,std::string&gt;(templateArgument,qualifier);</a>
<a name="15427"><span class="lineNum">   15427 </span><span class="lineNoCov">          0 :           if (i-&gt;second != qualifier)</span></a>
<a name="15428"><span class="lineNum">   15428 </span>            :              {</a>
<a name="15429"><span class="lineNum">   15429 </span><span class="lineNoCov">          0 :                i-&gt;second = qualifier;</span></a>
<a name="15430"><span class="lineNum">   15430 </span>            : #if 1</a>
<a name="15431"><span class="lineNum">   15431 </span>            :             // DQ (6/17/2013): Commented out this assertion.</a>
<a name="15432"><span class="lineNum">   15432 </span><span class="lineNoCov">          0 :                mfprintf(mlog [ WARN ] ) (&quot;Error: name in qualifiedNameMapForNames already exists and is different... \n&quot;);</span></a>
<a name="15433"><span class="lineNum">   15433 </span><span class="lineNoCov">          0 :                ROSE_ABORT();</span></a>
<a name="15434"><span class="lineNum">   15434 </span>            : #else</a>
<a name="15435"><span class="lineNum">   15435 </span>            :             // DQ (6/17/2013): I think this is OK, but I'm not certain (see test2012_57.C).</a>
<a name="15436"><span class="lineNum">   15436 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;WARNING: name in qualifiedNameMapForNames already exists and is different... (reset) \n&quot;);</a>
<a name="15437"><span class="lineNum">   15437 </span>            : #endif</a>
<a name="15438"><span class="lineNum">   15438 </span>            :              }</a>
<a name="15439"><span class="lineNum">   15439 </span>            : #if 0</a>
<a name="15440"><span class="lineNum">   15440 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Error: name in qualifiedNameMapForNames already exists... \n&quot;);</a>
<a name="15441"><span class="lineNum">   15441 </span>            :           ROSE_ABORT();</a>
<a name="15442"><span class="lineNum">   15442 </span>            : #endif</a>
<a name="15443"><span class="lineNum">   15443 </span>            :         }</a>
<a name="15444"><span class="lineNum">   15444 </span><span class="lineCov">       4237 :    }</span></a>
<a name="15445"><span class="lineNum">   15445 </span>            : </a>
<a name="15446"><span class="lineNum">   15446 </span>            : </a>
<a name="15447"><span class="lineNum">   15447 </span>            : void</a>
<a name="15448"><span class="lineNum">   15448 </span><span class="lineCov">      12060 : NameQualificationTraversal::setNameQualification ( SgFunctionDeclaration* functionDeclaration, int amountOfNameQualificationRequired )</span></a>
<a name="15449"><span class="lineNum">   15449 </span>            :    {</a>
<a name="15450"><span class="lineNum">   15450 </span>            :   // This takes only a SgFunctionDeclaration since it is where we locate the name qualification information AND</a>
<a name="15451"><span class="lineNum">   15451 </span>            :   // is the correct scope from which to iterate backwards through scopes to evaluate what name qualification is required.</a>
<a name="15452"><span class="lineNum">   15452 </span>            : </a>
<a name="15453"><span class="lineNum">   15453 </span>            :   // Setup call to refactored code.</a>
<a name="15454"><span class="lineNum">   15454 </span><span class="lineCov">      12060 :      int  outputNameQualificationLength = 0;</span></a>
<a name="15455"><span class="lineNum">   15455 </span><span class="lineCov">      12060 :      bool outputGlobalQualification     = false;</span></a>
<a name="15456"><span class="lineNum">   15456 </span><span class="lineCov">      12060 :      bool outputTypeEvaluation          = false;</span></a>
<a name="15457"><span class="lineNum">   15457 </span>            : </a>
<a name="15458"><span class="lineNum">   15458 </span>            :   // mfprintf(mlog [ WARN ] ) (&quot;\n************************************************ \n&quot;);</a>
<a name="15459"><span class="lineNum">   15459 </span>            : </a>
<a name="15460"><span class="lineNum">   15460 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="15461"><span class="lineNum">   15461 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In setNameQualification(SgFunctionDeclaration*) \n&quot;);</a>
<a name="15462"><span class="lineNum">   15462 </span>            : #endif</a>
<a name="15463"><span class="lineNum">   15463 </span>            : </a>
<a name="15464"><span class="lineNum">   15464 </span><span class="lineCov">      12060 :      SgScopeStatement * scope = traverseNonrealDeclForCorrectScope(functionDeclaration);</span></a>
<a name="15465"><span class="lineNum">   15465 </span><span class="lineCov">      12060 :      string qualifier = setNameQualificationSupport(scope,amountOfNameQualificationRequired, outputNameQualificationLength, outputGlobalQualification, outputTypeEvaluation);</span></a>
<a name="15466"><span class="lineNum">   15466 </span>            : </a>
<a name="15467"><span class="lineNum">   15467 </span>            :   // DQ (9/7/2014): Added suppor for where this is a template member or non-member function declaration and we need to genrate the name with the associated template header.</a>
<a name="15468"><span class="lineNum">   15468 </span><span class="lineCov">      24120 :      string template_header;</span></a>
<a name="15469"><span class="lineNum">   15469 </span><span class="lineCov">      12060 :      SgTemplateFunctionDeclaration*       templateFunctionDeclaration       = isSgTemplateFunctionDeclaration(functionDeclaration);</span></a>
<a name="15470"><span class="lineNum">   15470 </span><span class="lineCov">      12060 :      SgTemplateMemberFunctionDeclaration* templateMemberFunctionDeclaration = isSgTemplateMemberFunctionDeclaration(functionDeclaration);</span></a>
<a name="15471"><span class="lineNum">   15471 </span><span class="lineCov">      12060 :      bool buildTemplateHeaderString = (templateFunctionDeclaration != NULL || templateMemberFunctionDeclaration != NULL);</span></a>
<a name="15472"><span class="lineNum">   15472 </span><span class="lineCov">      12060 :      if (buildTemplateHeaderString == true)</span></a>
<a name="15473"><span class="lineNum">   15473 </span>            :         {</a>
<a name="15474"><span class="lineNum">   15474 </span>            :        // DQ (9/7/2014): First idea, but not likely to work...and too complex.</a>
<a name="15475"><span class="lineNum">   15475 </span>            :        // Note that another aspect of this implementation might be that we save a set of template class</a>
<a name="15476"><span class="lineNum">   15476 </span>            :        // declarations so that we can match types in the function's parameter list against the template class declaration</a>
<a name="15477"><span class="lineNum">   15477 </span>            :        // set so that we know when to build function parameter types as template types vs. template instantiation types.</a>
<a name="15478"><span class="lineNum">   15478 </span>            :        // This would require that we save a more complex data structure than a simple string.  It is also not clear if</a>
<a name="15479"><span class="lineNum">   15479 </span>            :        // all references to a template class instantiation could be assumed to be references to it's template declaration?</a>
<a name="15480"><span class="lineNum">   15480 </span>            :        // Or maybe the problem is that there is some other function parameter lis that we need to consult.</a>
<a name="15481"><span class="lineNum">   15481 </span>            : </a>
<a name="15482"><span class="lineNum">   15482 </span>            :        // DQ (9/7/2014): Better:</a>
<a name="15483"><span class="lineNum">   15483 </span>            :        // A better solution would be to make sure that we generate type in the EDG/ROSE translation using the template</a>
<a name="15484"><span class="lineNum">   15484 </span>            :        // function's paramter list associated with the first non-defining declaration (instead of the one being generated</a>
<a name="15485"><span class="lineNum">   15485 </span>            :        // as part of building the defining declaration (which is using the same a_routine_ptr as that used to build the</a>
<a name="15486"><span class="lineNum">   15486 </span>            :        // template instantiation.  As a result we a mixing the types in the defining template declaration with that of the</a>
<a name="15487"><span class="lineNum">   15487 </span>            :        // defining template instantiation (which is always wrong).  So the simple solution is to just use the types from</a>
<a name="15488"><span class="lineNum">   15488 </span>            :        // the non-defining template member or non-member function declaration.  The same should apply to the function</a>
<a name="15489"><span class="lineNum">   15489 </span>            :        // return type.  This is the simplest solution to date.</a>
<a name="15490"><span class="lineNum">   15490 </span>            : </a>
<a name="15491"><span class="lineNum">   15491 </span>            :        // DQ (9/8/2014): The best solution was to translate the defining non-template function declarations when we saw them</a>
<a name="15492"><span class="lineNum">   15492 </span>            :        // as defining declarations, but only put the non-defining declaration into the class template (to match the normalization</a>
<a name="15493"><span class="lineNum">   15493 </span>            :        // done by EDG) and then attach the defining template declaration ahead of the first associated template instantiation.</a>
<a name="15494"><span class="lineNum">   15494 </span>            :        // This appears to work well and will soon be evaluated for further tests.</a>
<a name="15495"><span class="lineNum">   15495 </span>            : #if 0</a>
<a name="15496"><span class="lineNum">   15496 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;WARNING: technical problem with function paramter types of template functions (should maybe not be template instantiations) \n&quot;);</a>
<a name="15497"><span class="lineNum">   15497 </span>            : #endif</a>
<a name="15498"><span class="lineNum">   15498 </span><span class="lineCov">       8511 :           template_header = setTemplateHeaderNameQualificationSupport(functionDeclaration-&gt;get_scope(),amountOfNameQualificationRequired);</span></a>
<a name="15499"><span class="lineNum">   15499 </span>            : #if 0</a>
<a name="15500"><span class="lineNum">   15500 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): qualifier = %s template_header = %s \n&quot;,qualifier.c_str(),template_header.c_str());</a>
<a name="15501"><span class="lineNum">   15501 </span>            : #endif</a>
<a name="15502"><span class="lineNum">   15502 </span>            : #if 0</a>
<a name="15503"><span class="lineNum">   15503 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="15504"><span class="lineNum">   15504 </span>            :           ROSE_ABORT();</a>
<a name="15505"><span class="lineNum">   15505 </span>            : #endif</a>
<a name="15506"><span class="lineNum">   15506 </span>            :         }</a>
<a name="15507"><span class="lineNum">   15507 </span>            : </a>
<a name="15508"><span class="lineNum">   15508 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="15509"><span class="lineNum">   15509 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): functionDeclaration-&gt;get_declarationModifier().isFriend() = %s \n&quot;,functionDeclaration-&gt;get_declarationModifier().isFriend() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="15510"><span class="lineNum">   15510 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): outputNameQualificationLength                             = %d \n&quot;,outputNameQualificationLength);</a>
<a name="15511"><span class="lineNum">   15511 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): outputGlobalQualification                                 = %s \n&quot;,outputGlobalQualification ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="15512"><span class="lineNum">   15512 </span>            : #endif</a>
<a name="15513"><span class="lineNum">   15513 </span>            : </a>
<a name="15514"><span class="lineNum">   15514 </span>            :   // DQ (2/16/2013): Note that test2013_67.C is a case where name qualification of the friend function is required.</a>
<a name="15515"><span class="lineNum">   15515 </span>            :   // I think it is because it is a non defining declaration instead of a defining declaration.</a>
<a name="15516"><span class="lineNum">   15516 </span>            :   // DQ (3/31/2012): I don't think that global qualification is allowed for friend functions (so test for this).</a>
<a name="15517"><span class="lineNum">   15517 </span>            :   // test2012_57.C is an example of this issue.</a>
<a name="15518"><span class="lineNum">   15518 </span>            :   // if (outputGlobalQualification == true &amp;&amp; functionDeclaration-&gt;get_declarationModifier().isFriend() == true)</a>
<a name="15519"><span class="lineNum">   15519 </span><span class="lineCov">      12060 :      if ( (outputGlobalQualification == true) &amp;&amp; (functionDeclaration-&gt;get_declarationModifier().isFriend() == true) &amp;&amp; (functionDeclaration == functionDeclaration-&gt;get_definingDeclaration()))</span></a>
<a name="15520"><span class="lineNum">   15520 </span>            :         {</a>
<a name="15521"><span class="lineNum">   15521 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="15522"><span class="lineNum">   15522 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;WARNING: We can't specify global qualification of friend function (qualifier reset to be empty string) \n&quot;);</a>
<a name="15523"><span class="lineNum">   15523 </span>            : #endif</a>
<a name="15524"><span class="lineNum">   15524 </span>            :        // Note that I think this might only be an issue where outputNameQualificationLength == 0.</a>
<a name="15525"><span class="lineNum">   15525 </span><span class="lineNoCov">          0 :           ROSE_ASSERT (outputNameQualificationLength == 0);</span></a>
<a name="15526"><span class="lineNum">   15526 </span>            : </a>
<a name="15527"><span class="lineNum">   15527 </span>            :        // Reset the values (and the qualifier string).</a>
<a name="15528"><span class="lineNum">   15528 </span>            :        // outputNameQualificationLength = 0;</a>
<a name="15529"><span class="lineNum">   15529 </span><span class="lineNoCov">          0 :           outputGlobalQualification = false;</span></a>
<a name="15530"><span class="lineNum">   15530 </span><span class="lineNoCov">          0 :           qualifier = &quot;&quot;;</span></a>
<a name="15531"><span class="lineNum">   15531 </span>            :         }</a>
<a name="15532"><span class="lineNum">   15532 </span>            : </a>
<a name="15533"><span class="lineNum">   15533 </span><span class="lineCov">      12060 :      functionDeclaration-&gt;set_global_qualification_required(outputGlobalQualification);</span></a>
<a name="15534"><span class="lineNum">   15534 </span><span class="lineCov">      12060 :      functionDeclaration-&gt;set_name_qualification_length(outputNameQualificationLength);</span></a>
<a name="15535"><span class="lineNum">   15535 </span><span class="lineCov">      12060 :      functionDeclaration-&gt;set_type_elaboration_required(outputTypeEvaluation);</span></a>
<a name="15536"><span class="lineNum">   15536 </span>            : </a>
<a name="15537"><span class="lineNum">   15537 </span>            :   // There should be no type evaluation required for a variable reference, as I recall.</a>
<a name="15538"><span class="lineNum">   15538 </span><span class="lineCov">      12060 :      ROSE_ASSERT(outputTypeEvaluation == false);</span></a>
<a name="15539"><span class="lineNum">   15539 </span>            : </a>
<a name="15540"><span class="lineNum">   15540 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="15541"><span class="lineNum">   15541 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): functionDeclaration-&gt;get_name_qualification_length()     = %d \n&quot;,functionDeclaration-&gt;get_name_qualification_length());</a>
<a name="15542"><span class="lineNum">   15542 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): functionDeclaration-&gt;get_type_elaboration_required()     = %s \n&quot;,functionDeclaration-&gt;get_type_elaboration_required() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="15543"><span class="lineNum">   15543 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): functionDeclaration-&gt;get_global_qualification_required() = %s \n&quot;,functionDeclaration-&gt;get_global_qualification_required() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="15544"><span class="lineNum">   15544 </span>            : </a>
<a name="15545"><span class="lineNum">   15545 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): functionDeclaration = %p firstNondefiningDeclaration() = %p \n&quot;,functionDeclaration,functionDeclaration-&gt;get_firstNondefiningDeclaration());</a>
<a name="15546"><span class="lineNum">   15546 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): functionDeclaration = %p definingDeclaration()         = %p \n&quot;,functionDeclaration,functionDeclaration-&gt;get_definingDeclaration());</a>
<a name="15547"><span class="lineNum">   15547 </span>            : #endif</a>
<a name="15548"><span class="lineNum">   15548 </span>            : </a>
<a name="15549"><span class="lineNum">   15549 </span><span class="lineCov">      24120 :      if (qualifiedNameMapForNames.find(functionDeclaration) == qualifiedNameMapForNames.end())</span></a>
<a name="15550"><span class="lineNum">   15550 </span>            :         {</a>
<a name="15551"><span class="lineNum">   15551 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="15552"><span class="lineNum">   15552 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Inserting qualifier for name = %s into list at IR node = %p = %s \n&quot;,qualifier.c_str(),functionDeclaration,functionDeclaration-&gt;class_name().c_str());</a>
<a name="15553"><span class="lineNum">   15553 </span>            : #endif</a>
<a name="15554"><span class="lineNum">   15554 </span><span class="lineCov">      24044 :           qualifiedNameMapForNames.insert(std::pair&lt;SgNode*,std::string&gt;(functionDeclaration,qualifier));</span></a>
<a name="15555"><span class="lineNum">   15555 </span>            :         }</a>
<a name="15556"><span class="lineNum">   15556 </span>            :        else</a>
<a name="15557"><span class="lineNum">   15557 </span>            :         {</a>
<a name="15558"><span class="lineNum">   15558 </span>            :        // If it already exists then overwrite the existing information.</a>
<a name="15559"><span class="lineNum">   15559 </span><span class="lineCov">        712 :           std::map&lt;SgNode*,std::string&gt;::iterator i = qualifiedNameMapForNames.find(functionDeclaration);</span></a>
<a name="15560"><span class="lineNum">   15560 </span><span class="lineCov">         38 :           ROSE_ASSERT (i != qualifiedNameMapForNames.end());</span></a>
<a name="15561"><span class="lineNum">   15561 </span>            : </a>
<a name="15562"><span class="lineNum">   15562 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="15563"><span class="lineNum">   15563 </span>            :           string previousQualifier = i-&gt;second.c_str();</a>
<a name="15564"><span class="lineNum">   15564 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;WARNING: In NameQualificationTraversal::setNameQualification(): test 8: replacing previousQualifier = %s with new qualifier = %s \n&quot;,previousQualifier.c_str(),qualifier.c_str());</a>
<a name="15565"><span class="lineNum">   15565 </span>            : #endif</a>
<a name="15566"><span class="lineNum">   15566 </span>            :        // I think I can do this!</a>
<a name="15567"><span class="lineNum">   15567 </span>            :        // *i = std::pair&lt;SgNode*,std::string&gt;(templateArgument,qualifier);</a>
<a name="15568"><span class="lineNum">   15568 </span><span class="lineCov">         38 :           if (i-&gt;second != qualifier)</span></a>
<a name="15569"><span class="lineNum">   15569 </span>            :              {</a>
<a name="15570"><span class="lineNum">   15570 </span>            :             // DQ (9/25/2019): Comment this out because it hides the error we are trying ti isolate.</a>
<a name="15571"><span class="lineNum">   15571 </span>            :             // i-&gt;second = qualifier;</a>
<a name="15572"><span class="lineNum">   15572 </span>            : </a>
<a name="15573"><span class="lineNum">   15573 </span>            : #if 1</a>
<a name="15574"><span class="lineNum">   15574 </span><span class="lineNoCov">          0 :                string tmp_previousQualifier = i-&gt;second.c_str();</span></a>
<a name="15575"><span class="lineNum">   15575 </span><span class="lineNoCov">          0 :                mfprintf(mlog [ WARN ] ) (&quot;WARNING: test 8: replacing previousQualifier = %s with new qualifier = %s \n&quot;,tmp_previousQualifier.c_str(),qualifier.c_str());</span></a>
<a name="15576"><span class="lineNum">   15576 </span><span class="lineNoCov">          0 :                mfprintf(mlog [ WARN ] ) (&quot; --- functionDeclaration = %p = %s name = %s \n&quot;,functionDeclaration,functionDeclaration-&gt;class_name().c_str(),functionDeclaration-&gt;get_name().str());</span></a>
<a name="15577"><span class="lineNum">   15577 </span>            : #endif</a>
<a name="15578"><span class="lineNum">   15578 </span>            : #if 1</a>
<a name="15579"><span class="lineNum">   15579 </span>            :             // DQ (3/31/2012): Commented out this assertion.</a>
<a name="15580"><span class="lineNum">   15580 </span><span class="lineNoCov">          0 :                mfprintf(mlog [ WARN ] ) (&quot;Error: name in qualifiedNameMapForNames already exists and is different... \n&quot;);</span></a>
<a name="15581"><span class="lineNum">   15581 </span><span class="lineNoCov">          0 :                ROSE_ABORT();</span></a>
<a name="15582"><span class="lineNum">   15582 </span>            : #else</a>
<a name="15583"><span class="lineNum">   15583 </span>            :             // DQ (3/31/2012): I think this is OK, but I'm not certain (see test2012_57.C).</a>
<a name="15584"><span class="lineNum">   15584 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;WARNING: name in qualifiedNameMapForNames already exists and is different... (reset) \n&quot;);</a>
<a name="15585"><span class="lineNum">   15585 </span>            : #endif</a>
<a name="15586"><span class="lineNum">   15586 </span>            :              }</a>
<a name="15587"><span class="lineNum">   15587 </span>            :         }</a>
<a name="15588"><span class="lineNum">   15588 </span>            : </a>
<a name="15589"><span class="lineNum">   15589 </span><span class="lineCov">      12060 :      if (buildTemplateHeaderString == true)</span></a>
<a name="15590"><span class="lineNum">   15590 </span>            :         {</a>
<a name="15591"><span class="lineNum">   15591 </span>            :        // Add the template header string to a new map.</a>
<a name="15592"><span class="lineNum">   15592 </span>            : #if 0</a>
<a name="15593"><span class="lineNum">   15593 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Add the template header string to a new map: template_header = %s \n&quot;,template_header.c_str());</a>
<a name="15594"><span class="lineNum">   15594 </span>            : #endif</a>
<a name="15595"><span class="lineNum">   15595 </span>            : </a>
<a name="15596"><span class="lineNum">   15596 </span><span class="lineCov">      17022 :           if (qualifiedNameMapForTemplateHeaders.find(functionDeclaration) == qualifiedNameMapForTemplateHeaders.end())</span></a>
<a name="15597"><span class="lineNum">   15597 </span>            :              {</a>
<a name="15598"><span class="lineNum">   15598 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="15599"><span class="lineNum">   15599 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Inserting qualifier for template header = %s into list at IR node = %p = %s \n&quot;,template_header.c_str(),functionDeclaration,functionDeclaration-&gt;class_name().c_str());</a>
<a name="15600"><span class="lineNum">   15600 </span>            : #endif</a>
<a name="15601"><span class="lineNum">   15601 </span><span class="lineCov">      17022 :                qualifiedNameMapForTemplateHeaders.insert(std::pair&lt;SgNode*,std::string&gt;(functionDeclaration,template_header));</span></a>
<a name="15602"><span class="lineNum">   15602 </span>            :              }</a>
<a name="15603"><span class="lineNum">   15603 </span>            :             else</a>
<a name="15604"><span class="lineNum">   15604 </span>            :              {</a>
<a name="15605"><span class="lineNum">   15605 </span>            :             // If it already exists then overwrite the existing information.</a>
<a name="15606"><span class="lineNum">   15606 </span><span class="lineNoCov">          0 :                std::map&lt;SgNode*,std::string&gt;::iterator i = qualifiedNameMapForTemplateHeaders.find(functionDeclaration);</span></a>
<a name="15607"><span class="lineNum">   15607 </span><span class="lineNoCov">          0 :                ROSE_ASSERT (i != qualifiedNameMapForTemplateHeaders.end());</span></a>
<a name="15608"><span class="lineNum">   15608 </span>            : </a>
<a name="15609"><span class="lineNum">   15609 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="15610"><span class="lineNum">   15610 </span>            :                string previous_template_header = i-&gt;second.c_str();</a>
<a name="15611"><span class="lineNum">   15611 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;WARNING: test 9: replacing previousQualifier = %s with new qualifier = %s \n&quot;,previous_template_header.c_str(),template_header.c_str());</a>
<a name="15612"><span class="lineNum">   15612 </span>            : #endif</a>
<a name="15613"><span class="lineNum">   15613 </span><span class="lineNoCov">          0 :                if (i-&gt;second != template_header)</span></a>
<a name="15614"><span class="lineNum">   15614 </span>            :                   {</a>
<a name="15615"><span class="lineNum">   15615 </span><span class="lineNoCov">          0 :                     i-&gt;second = template_header;</span></a>
<a name="15616"><span class="lineNum">   15616 </span>            : #if 1</a>
<a name="15617"><span class="lineNum">   15617 </span>            :                  // DQ (9/7/2014): Make this an error.</a>
<a name="15618"><span class="lineNum">   15618 </span><span class="lineNoCov">          0 :                     mfprintf(mlog [ WARN ] ) (&quot;Error: name in qualifiedNameMapForTemplateHeaders already exists and is different... \n&quot;);</span></a>
<a name="15619"><span class="lineNum">   15619 </span><span class="lineNoCov">          0 :                     ROSE_ABORT();</span></a>
<a name="15620"><span class="lineNum">   15620 </span>            : #else</a>
<a name="15621"><span class="lineNum">   15621 </span>            :                  // DQ (9/7/2014): Let's not alow this.</a>
<a name="15622"><span class="lineNum">   15622 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;WARNING: name in qualifiedNameMapForTemplateHeaders already exists and is different... (reset) \n&quot;);</a>
<a name="15623"><span class="lineNum">   15623 </span>            : #endif</a>
<a name="15624"><span class="lineNum">   15624 </span>            :                   }</a>
<a name="15625"><span class="lineNum">   15625 </span>            :              }</a>
<a name="15626"><span class="lineNum">   15626 </span>            : #if 0</a>
<a name="15627"><span class="lineNum">   15627 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="15628"><span class="lineNum">   15628 </span>            :           ROSE_ABORT();</a>
<a name="15629"><span class="lineNum">   15629 </span>            : #endif</a>
<a name="15630"><span class="lineNum">   15630 </span>            :         }</a>
<a name="15631"><span class="lineNum">   15631 </span>            : </a>
<a name="15632"><span class="lineNum">   15632 </span>            : </a>
<a name="15633"><span class="lineNum">   15633 </span>            :   // mfprintf(mlog [ WARN ] ) (&quot;****************** DONE ******************** \n\n&quot;);</a>
<a name="15634"><span class="lineNum">   15634 </span><span class="lineCov">      12060 :    }</span></a>
<a name="15635"><span class="lineNum">   15635 </span>            : </a>
<a name="15636"><span class="lineNum">   15636 </span>            : // void NameQualificationTraversal::setNameQualificationReturnType ( SgFunctionDeclaration* functionDeclaration, int amountOfNameQualificationRequired )</a>
<a name="15637"><span class="lineNum">   15637 </span>            : void</a>
<a name="15638"><span class="lineNum">   15638 </span><span class="lineCov">     205919 : NameQualificationTraversal::setNameQualificationReturnType ( SgFunctionDeclaration* functionDeclaration, SgDeclarationStatement* declaration, int amountOfNameQualificationRequired )</span></a>
<a name="15639"><span class="lineNum">   15639 </span>            :    {</a>
<a name="15640"><span class="lineNum">   15640 </span>            :   // This takes only a SgFunctionDeclaration since it is where we locate the name qualification information AND</a>
<a name="15641"><span class="lineNum">   15641 </span>            :   // is the correct scope from which to iterate backwards through scopes to evaluate what name qualification is required.</a>
<a name="15642"><span class="lineNum">   15642 </span>            : </a>
<a name="15643"><span class="lineNum">   15643 </span>            :   // Setup call to refactored code.</a>
<a name="15644"><span class="lineNum">   15644 </span><span class="lineCov">     205919 :      int  outputNameQualificationLength = 0;</span></a>
<a name="15645"><span class="lineNum">   15645 </span><span class="lineCov">     205919 :      bool outputGlobalQualification     = false;</span></a>
<a name="15646"><span class="lineNum">   15646 </span><span class="lineCov">     205919 :      bool outputTypeEvaluation          = false;</span></a>
<a name="15647"><span class="lineNum">   15647 </span>            : </a>
<a name="15648"><span class="lineNum">   15648 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="15649"><span class="lineNum">   15649 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In setNameQualificationReturnType(SgFunctionDeclaration*) \n&quot;);</a>
<a name="15650"><span class="lineNum">   15650 </span>            : #endif</a>
<a name="15651"><span class="lineNum">   15651 </span>            : </a>
<a name="15652"><span class="lineNum">   15652 </span><span class="lineCov">     205919 :      SgScopeStatement * scope = traverseNonrealDeclForCorrectScope(declaration);</span></a>
<a name="15653"><span class="lineNum">   15653 </span><span class="lineCov">     205919 :      string qualifier = setNameQualificationSupport(scope,amountOfNameQualificationRequired, outputNameQualificationLength, outputGlobalQualification, outputTypeEvaluation);</span></a>
<a name="15654"><span class="lineNum">   15654 </span>            : </a>
<a name="15655"><span class="lineNum">   15655 </span><span class="lineCov">     205919 :      functionDeclaration-&gt;set_global_qualification_required_for_return_type(outputGlobalQualification);</span></a>
<a name="15656"><span class="lineNum">   15656 </span><span class="lineCov">     205919 :      functionDeclaration-&gt;set_name_qualification_length_for_return_type(outputNameQualificationLength);</span></a>
<a name="15657"><span class="lineNum">   15657 </span><span class="lineCov">     205919 :      functionDeclaration-&gt;set_type_elaboration_required_for_return_type(outputTypeEvaluation);</span></a>
<a name="15658"><span class="lineNum">   15658 </span>            : </a>
<a name="15659"><span class="lineNum">   15659 </span>            :   // There should be no type evaluation required for a variable reference, as I recall.</a>
<a name="15660"><span class="lineNum">   15660 </span><span class="lineCov">     205919 :      ROSE_ASSERT(outputTypeEvaluation == false);</span></a>
<a name="15661"><span class="lineNum">   15661 </span>            : </a>
<a name="15662"><span class="lineNum">   15662 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="15663"><span class="lineNum">   15663 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): functionDeclaration-&gt;get_name_qualification_length_for_return_type()     = %d \n&quot;,functionDeclaration-&gt;get_name_qualification_length_for_return_type());</a>
<a name="15664"><span class="lineNum">   15664 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): functionDeclaration-&gt;get_type_elaboration_required_for_return_type()     = %s \n&quot;,functionDeclaration-&gt;get_type_elaboration_required_for_return_type() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="15665"><span class="lineNum">   15665 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): functionDeclaration-&gt;get_global_qualification_required_for_return_type() = %s \n&quot;,functionDeclaration-&gt;get_global_qualification_required_for_return_type() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="15666"><span class="lineNum">   15666 </span>            : #endif</a>
<a name="15667"><span class="lineNum">   15667 </span>            : </a>
<a name="15668"><span class="lineNum">   15668 </span><span class="lineCov">     411838 :      if (qualifiedNameMapForTypes.find(functionDeclaration) == qualifiedNameMapForTypes.end())</span></a>
<a name="15669"><span class="lineNum">   15669 </span>            :         {</a>
<a name="15670"><span class="lineNum">   15670 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="15671"><span class="lineNum">   15671 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Inserting qualifier for type = %s into list at IR node = %p = %s \n&quot;,qualifier.c_str(),functionDeclaration,functionDeclaration-&gt;class_name().c_str());</a>
<a name="15672"><span class="lineNum">   15672 </span>            : #endif</a>
<a name="15673"><span class="lineNum">   15673 </span><span class="lineCov">     409798 :           qualifiedNameMapForTypes.insert(std::pair&lt;SgNode*,std::string&gt;(functionDeclaration,qualifier));</span></a>
<a name="15674"><span class="lineNum">   15674 </span>            :         }</a>
<a name="15675"><span class="lineNum">   15675 </span>            :        else</a>
<a name="15676"><span class="lineNum">   15676 </span>            :         {</a>
<a name="15677"><span class="lineNum">   15677 </span>            :        // If it already existes then overwrite the existing information.</a>
<a name="15678"><span class="lineNum">   15678 </span><span class="lineCov">      21076 :           std::map&lt;SgNode*,std::string&gt;::iterator i = qualifiedNameMapForTypes.find(functionDeclaration);</span></a>
<a name="15679"><span class="lineNum">   15679 </span><span class="lineCov">       1020 :           ROSE_ASSERT (i != qualifiedNameMapForTypes.end());</span></a>
<a name="15680"><span class="lineNum">   15680 </span>            : </a>
<a name="15681"><span class="lineNum">   15681 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="15682"><span class="lineNum">   15682 </span>            :           string previousQualifier = i-&gt;second.c_str();</a>
<a name="15683"><span class="lineNum">   15683 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;WARNING: test 10: replacing previousQualifier = %s with new qualifier = %s \n&quot;,previousQualifier.c_str(),qualifier.c_str());</a>
<a name="15684"><span class="lineNum">   15684 </span>            : #endif</a>
<a name="15685"><span class="lineNum">   15685 </span>            :        // I think I can do this!</a>
<a name="15686"><span class="lineNum">   15686 </span>            :        // *i = std::pair&lt;SgNode*,std::string&gt;(templateArgument,qualifier);</a>
<a name="15687"><span class="lineNum">   15687 </span><span class="lineCov">       1020 :           if (i-&gt;second != qualifier)</span></a>
<a name="15688"><span class="lineNum">   15688 </span>            :              {</a>
<a name="15689"><span class="lineNum">   15689 </span><span class="lineNoCov">          0 :                i-&gt;second = qualifier;</span></a>
<a name="15690"><span class="lineNum">   15690 </span>            : </a>
<a name="15691"><span class="lineNum">   15691 </span>            :             // DQ (8/3/2019): Output a message about how we are debugging this.</a>
<a name="15692"><span class="lineNum">   15692 </span><span class="lineNoCov">          0 :                mfprintf(mlog [ WARN ] ) (&quot;Commented out reset of name qualification: replacing previousQualifier = %s with new qualifier = %s \n&quot;,i-&gt;second.c_str(),qualifier.c_str());</span></a>
<a name="15693"><span class="lineNum">   15693 </span>            : #if 0</a>
<a name="15694"><span class="lineNum">   15694 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Error: name in qualifiedNameMapForNames already exists and is different... \n&quot;);</a>
<a name="15695"><span class="lineNum">   15695 </span>            :                ROSE_ABORT();</a>
<a name="15696"><span class="lineNum">   15696 </span>            : #endif</a>
<a name="15697"><span class="lineNum">   15697 </span>            :              }</a>
<a name="15698"><span class="lineNum">   15698 </span>            :         }</a>
<a name="15699"><span class="lineNum">   15699 </span><span class="lineCov">     205919 :    }</span></a>
<a name="15700"><span class="lineNum">   15700 </span>            : </a>
<a name="15701"><span class="lineNum">   15701 </span>            : </a>
<a name="15702"><span class="lineNum">   15702 </span>            : void</a>
<a name="15703"><span class="lineNum">   15703 </span><span class="lineCov">       3263 : NameQualificationTraversal::setNameQualification ( SgUsingDeclarationStatement* usingDeclaration, SgDeclarationStatement* declaration, int amountOfNameQualificationRequired )</span></a>
<a name="15704"><span class="lineNum">   15704 </span>            :    {</a>
<a name="15705"><span class="lineNum">   15705 </span>            :   // Setup call to refactored code.</a>
<a name="15706"><span class="lineNum">   15706 </span><span class="lineCov">       3263 :      int  outputNameQualificationLength = 0;</span></a>
<a name="15707"><span class="lineNum">   15707 </span><span class="lineCov">       3263 :      bool outputGlobalQualification     = false;</span></a>
<a name="15708"><span class="lineNum">   15708 </span><span class="lineCov">       3263 :      bool outputTypeEvaluation          = false;</span></a>
<a name="15709"><span class="lineNum">   15709 </span>            : </a>
<a name="15710"><span class="lineNum">   15710 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="15711"><span class="lineNum">   15711 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In setNameQualification(SgUsingDeclarationStatement*,SgDeclarationStatement*) \n&quot;);</a>
<a name="15712"><span class="lineNum">   15712 </span>            : #endif</a>
<a name="15713"><span class="lineNum">   15713 </span>            : </a>
<a name="15714"><span class="lineNum">   15714 </span><span class="lineCov">       3263 :      SgScopeStatement * scope = traverseNonrealDeclForCorrectScope(declaration);</span></a>
<a name="15715"><span class="lineNum">   15715 </span><span class="lineCov">       3263 :      string qualifier = setNameQualificationSupport(scope,amountOfNameQualificationRequired, outputNameQualificationLength, outputGlobalQualification, outputTypeEvaluation);</span></a>
<a name="15716"><span class="lineNum">   15716 </span>            : </a>
<a name="15717"><span class="lineNum">   15717 </span><span class="lineCov">       3263 :      usingDeclaration-&gt;set_global_qualification_required(outputGlobalQualification);</span></a>
<a name="15718"><span class="lineNum">   15718 </span><span class="lineCov">       3263 :      usingDeclaration-&gt;set_name_qualification_length(outputNameQualificationLength);</span></a>
<a name="15719"><span class="lineNum">   15719 </span><span class="lineCov">       3263 :      usingDeclaration-&gt;set_type_elaboration_required(outputTypeEvaluation);</span></a>
<a name="15720"><span class="lineNum">   15720 </span>            : </a>
<a name="15721"><span class="lineNum">   15721 </span>            :   // There should be no type evaluation required for a variable reference, as I recall.</a>
<a name="15722"><span class="lineNum">   15722 </span><span class="lineCov">       3263 :      ROSE_ASSERT(outputTypeEvaluation == false);</span></a>
<a name="15723"><span class="lineNum">   15723 </span>            : </a>
<a name="15724"><span class="lineNum">   15724 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="15725"><span class="lineNum">   15725 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): usingDeclaration-&gt;get_name_qualification_length()     = %d \n&quot;,usingDeclaration-&gt;get_name_qualification_length());</a>
<a name="15726"><span class="lineNum">   15726 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): usingDeclaration-&gt;get_type_elaboration_required()     = %s \n&quot;,usingDeclaration-&gt;get_type_elaboration_required() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="15727"><span class="lineNum">   15727 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): usingDeclaration-&gt;get_global_qualification_required() = %s \n&quot;,usingDeclaration-&gt;get_global_qualification_required() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="15728"><span class="lineNum">   15728 </span>            : #endif</a>
<a name="15729"><span class="lineNum">   15729 </span>            : </a>
<a name="15730"><span class="lineNum">   15730 </span><span class="lineCov">       6526 :      if (qualifiedNameMapForNames.find(usingDeclaration) == qualifiedNameMapForNames.end())</span></a>
<a name="15731"><span class="lineNum">   15731 </span>            :         {</a>
<a name="15732"><span class="lineNum">   15732 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="15733"><span class="lineNum">   15733 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Inserting qualifier for name = %s into list at IR node = %p = %s \n&quot;,qualifier.c_str(),usingDeclaration,usingDeclaration-&gt;class_name().c_str());</a>
<a name="15734"><span class="lineNum">   15734 </span>            : #endif</a>
<a name="15735"><span class="lineNum">   15735 </span><span class="lineCov">       6526 :           qualifiedNameMapForNames.insert(std::pair&lt;SgNode*,std::string&gt;(usingDeclaration,qualifier));</span></a>
<a name="15736"><span class="lineNum">   15736 </span>            :         }</a>
<a name="15737"><span class="lineNum">   15737 </span>            :        else</a>
<a name="15738"><span class="lineNum">   15738 </span>            :         {</a>
<a name="15739"><span class="lineNum">   15739 </span>            : #if 0</a>
<a name="15740"><span class="lineNum">   15740 </span>            :        // DQ (5/23/2016): Output some date to use in debugging this case.</a>
<a name="15741"><span class="lineNum">   15741 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;usingDeclaration = %p \n&quot;,usingDeclaration);</a>
<a name="15742"><span class="lineNum">   15742 </span>            :           usingDeclaration-&gt;get_file_info()-&gt;display(&quot;NameQualificationTraversal::setNameQualification(SgUsingDeclarationStatement, SgDeclarationStatement,int): debug&quot;);</a>
<a name="15743"><span class="lineNum">   15743 </span>            : #endif</a>
<a name="15744"><span class="lineNum">   15744 </span>            :        // If it already exists then overwrite the existing information.</a>
<a name="15745"><span class="lineNum">   15745 </span><span class="lineNoCov">          0 :           std::map&lt;SgNode*,std::string&gt;::iterator i = qualifiedNameMapForNames.find(usingDeclaration);</span></a>
<a name="15746"><span class="lineNum">   15746 </span><span class="lineNoCov">          0 :           ROSE_ASSERT (i != qualifiedNameMapForNames.end());</span></a>
<a name="15747"><span class="lineNum">   15747 </span>            : </a>
<a name="15748"><span class="lineNum">   15748 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="15749"><span class="lineNum">   15749 </span>            :           string previousQualifier = i-&gt;second.c_str();</a>
<a name="15750"><span class="lineNum">   15750 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;WARNING: test 11: replacing previousQualifier = %s with new qualifier = %s \n&quot;,previousQualifier.c_str(),qualifier.c_str());</a>
<a name="15751"><span class="lineNum">   15751 </span>            : #endif</a>
<a name="15752"><span class="lineNum">   15752 </span>            :        // I think I can do this!</a>
<a name="15753"><span class="lineNum">   15753 </span>            :        // *i = std::pair&lt;SgNode*,std::string&gt;(templateArgument,qualifier);</a>
<a name="15754"><span class="lineNum">   15754 </span><span class="lineNoCov">          0 :           if (i-&gt;second != qualifier)</span></a>
<a name="15755"><span class="lineNum">   15755 </span>            :              {</a>
<a name="15756"><span class="lineNum">   15756 </span><span class="lineNoCov">          0 :                i-&gt;second = qualifier;</span></a>
<a name="15757"><span class="lineNum">   15757 </span>            : #if 1</a>
<a name="15758"><span class="lineNum">   15758 </span><span class="lineNoCov">          0 :                mfprintf(mlog [ WARN ] ) (&quot;Error: name in qualifiedNameMapForNames already exists and is different... \n&quot;);</span></a>
<a name="15759"><span class="lineNum">   15759 </span><span class="lineNoCov">          0 :                ROSE_ABORT();</span></a>
<a name="15760"><span class="lineNum">   15760 </span>            : #endif</a>
<a name="15761"><span class="lineNum">   15761 </span>            :              }</a>
<a name="15762"><span class="lineNum">   15762 </span>            : #if 0</a>
<a name="15763"><span class="lineNum">   15763 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Error: name in qualifiedNameMapForNames already exists... \n&quot;);</a>
<a name="15764"><span class="lineNum">   15764 </span>            :           ROSE_ABORT();</a>
<a name="15765"><span class="lineNum">   15765 </span>            : #endif</a>
<a name="15766"><span class="lineNum">   15766 </span>            :         }</a>
<a name="15767"><span class="lineNum">   15767 </span><span class="lineCov">       3263 :    }</span></a>
<a name="15768"><span class="lineNum">   15768 </span>            : </a>
<a name="15769"><span class="lineNum">   15769 </span>            : </a>
<a name="15770"><span class="lineNum">   15770 </span>            : void</a>
<a name="15771"><span class="lineNum">   15771 </span><span class="lineCov">         50 : NameQualificationTraversal::setNameQualification ( SgUsingDeclarationStatement* usingDeclaration, SgInitializedName* associatedInitializedName, int amountOfNameQualificationRequired )</span></a>
<a name="15772"><span class="lineNum">   15772 </span>            :    {</a>
<a name="15773"><span class="lineNum">   15773 </span>            :   // Setup call to refactored code.</a>
<a name="15774"><span class="lineNum">   15774 </span><span class="lineCov">         50 :      int  outputNameQualificationLength = 0;</span></a>
<a name="15775"><span class="lineNum">   15775 </span><span class="lineCov">         50 :      bool outputGlobalQualification     = false;</span></a>
<a name="15776"><span class="lineNum">   15776 </span><span class="lineCov">         50 :      bool outputTypeEvaluation          = false;</span></a>
<a name="15777"><span class="lineNum">   15777 </span>            : </a>
<a name="15778"><span class="lineNum">   15778 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="15779"><span class="lineNum">   15779 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In setNameQualification(SgUsingDeclarationStatement*,SgInitializedName*) \n&quot;);</a>
<a name="15780"><span class="lineNum">   15780 </span>            : #endif</a>
<a name="15781"><span class="lineNum">   15781 </span>            : </a>
<a name="15782"><span class="lineNum">   15782 </span><span class="lineCov">         50 :      string qualifier = setNameQualificationSupport(associatedInitializedName-&gt;get_scope(),amountOfNameQualificationRequired, outputNameQualificationLength, outputGlobalQualification, outputTypeEvaluation);</span></a>
<a name="15783"><span class="lineNum">   15783 </span>            : </a>
<a name="15784"><span class="lineNum">   15784 </span><span class="lineCov">         50 :      usingDeclaration-&gt;set_global_qualification_required(outputGlobalQualification);</span></a>
<a name="15785"><span class="lineNum">   15785 </span><span class="lineCov">         50 :      usingDeclaration-&gt;set_name_qualification_length(outputNameQualificationLength);</span></a>
<a name="15786"><span class="lineNum">   15786 </span><span class="lineCov">         50 :      usingDeclaration-&gt;set_type_elaboration_required(outputTypeEvaluation);</span></a>
<a name="15787"><span class="lineNum">   15787 </span>            : </a>
<a name="15788"><span class="lineNum">   15788 </span>            :   // There should be no type evaluation required for a variable reference, as I recall.</a>
<a name="15789"><span class="lineNum">   15789 </span><span class="lineCov">         50 :      ROSE_ASSERT(outputTypeEvaluation == false);</span></a>
<a name="15790"><span class="lineNum">   15790 </span>            : </a>
<a name="15791"><span class="lineNum">   15791 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="15792"><span class="lineNum">   15792 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): usingDeclaration-&gt;get_name_qualification_length()     = %d \n&quot;,usingDeclaration-&gt;get_name_qualification_length());</a>
<a name="15793"><span class="lineNum">   15793 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): usingDeclaration-&gt;get_type_elaboration_required()     = %s \n&quot;,usingDeclaration-&gt;get_type_elaboration_required() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="15794"><span class="lineNum">   15794 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): usingDeclaration-&gt;get_global_qualification_required() = %s \n&quot;,usingDeclaration-&gt;get_global_qualification_required() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="15795"><span class="lineNum">   15795 </span>            : #endif</a>
<a name="15796"><span class="lineNum">   15796 </span>            : </a>
<a name="15797"><span class="lineNum">   15797 </span><span class="lineCov">        100 :      if (qualifiedNameMapForNames.find(usingDeclaration) == qualifiedNameMapForNames.end())</span></a>
<a name="15798"><span class="lineNum">   15798 </span>            :         {</a>
<a name="15799"><span class="lineNum">   15799 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="15800"><span class="lineNum">   15800 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Inserting qualifier for name = %s into list at IR node = %p = %s \n&quot;,qualifier.c_str(),usingDeclaration,usingDeclaration-&gt;class_name().c_str());</a>
<a name="15801"><span class="lineNum">   15801 </span>            : #endif</a>
<a name="15802"><span class="lineNum">   15802 </span><span class="lineCov">        100 :           qualifiedNameMapForNames.insert(std::pair&lt;SgNode*,std::string&gt;(usingDeclaration,qualifier));</span></a>
<a name="15803"><span class="lineNum">   15803 </span>            :         }</a>
<a name="15804"><span class="lineNum">   15804 </span>            :        else</a>
<a name="15805"><span class="lineNum">   15805 </span>            :         {</a>
<a name="15806"><span class="lineNum">   15806 </span><span class="lineNoCov">          0 :           mfprintf(mlog [ WARN ] ) (&quot;Error: name in qualifiedNameMapForNames already exists... \n&quot;);</span></a>
<a name="15807"><span class="lineNum">   15807 </span><span class="lineNoCov">          0 :           ROSE_ABORT();</span></a>
<a name="15808"><span class="lineNum">   15808 </span>            :         }</a>
<a name="15809"><span class="lineNum">   15809 </span><span class="lineCov">         50 :    }</span></a>
<a name="15810"><span class="lineNum">   15810 </span>            : </a>
<a name="15811"><span class="lineNum">   15811 </span>            : </a>
<a name="15812"><span class="lineNum">   15812 </span>            : void</a>
<a name="15813"><span class="lineNum">   15813 </span><span class="lineCov">         17 : NameQualificationTraversal::setNameQualification ( SgUsingDirectiveStatement* usingDirective, SgDeclarationStatement* declaration, int amountOfNameQualificationRequired )</span></a>
<a name="15814"><span class="lineNum">   15814 </span>            :    {</a>
<a name="15815"><span class="lineNum">   15815 </span>            :   // Setup call to refactored code.</a>
<a name="15816"><span class="lineNum">   15816 </span><span class="lineCov">         17 :      int  outputNameQualificationLength = 0;</span></a>
<a name="15817"><span class="lineNum">   15817 </span><span class="lineCov">         17 :      bool outputGlobalQualification     = false;</span></a>
<a name="15818"><span class="lineNum">   15818 </span><span class="lineCov">         17 :      bool outputTypeEvaluation          = false;</span></a>
<a name="15819"><span class="lineNum">   15819 </span>            : </a>
<a name="15820"><span class="lineNum">   15820 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="15821"><span class="lineNum">   15821 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In setNameQualification(SgUsingDirectiveStatement*) \n&quot;);</a>
<a name="15822"><span class="lineNum">   15822 </span>            : #endif</a>
<a name="15823"><span class="lineNum">   15823 </span>            : </a>
<a name="15824"><span class="lineNum">   15824 </span><span class="lineCov">         17 :      SgScopeStatement * scope = traverseNonrealDeclForCorrectScope(declaration);</span></a>
<a name="15825"><span class="lineNum">   15825 </span><span class="lineCov">         17 :      string qualifier = setNameQualificationSupport(scope,amountOfNameQualificationRequired, outputNameQualificationLength, outputGlobalQualification, outputTypeEvaluation);</span></a>
<a name="15826"><span class="lineNum">   15826 </span>            : </a>
<a name="15827"><span class="lineNum">   15827 </span><span class="lineCov">         17 :      usingDirective-&gt;set_global_qualification_required(outputGlobalQualification);</span></a>
<a name="15828"><span class="lineNum">   15828 </span><span class="lineCov">         17 :      usingDirective-&gt;set_name_qualification_length(outputNameQualificationLength);</span></a>
<a name="15829"><span class="lineNum">   15829 </span><span class="lineCov">         17 :      usingDirective-&gt;set_type_elaboration_required(outputTypeEvaluation);</span></a>
<a name="15830"><span class="lineNum">   15830 </span>            : </a>
<a name="15831"><span class="lineNum">   15831 </span>            :   // There should be no type evaluation required for a variable reference, as I recall.</a>
<a name="15832"><span class="lineNum">   15832 </span><span class="lineCov">         17 :      ROSE_ASSERT(outputTypeEvaluation == false);</span></a>
<a name="15833"><span class="lineNum">   15833 </span>            : </a>
<a name="15834"><span class="lineNum">   15834 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="15835"><span class="lineNum">   15835 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): usingDirective-&gt;get_name_qualification_length()     = %d \n&quot;,usingDirective-&gt;get_name_qualification_length());</a>
<a name="15836"><span class="lineNum">   15836 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): usingDirective-&gt;get_type_elaboration_required()     = %s \n&quot;,usingDirective-&gt;get_type_elaboration_required() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="15837"><span class="lineNum">   15837 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): usingDirective-&gt;get_global_qualification_required() = %s \n&quot;,usingDirective-&gt;get_global_qualification_required() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="15838"><span class="lineNum">   15838 </span>            : #endif</a>
<a name="15839"><span class="lineNum">   15839 </span>            : </a>
<a name="15840"><span class="lineNum">   15840 </span>            : </a>
<a name="15841"><span class="lineNum">   15841 </span><span class="lineCov">         34 :      if (qualifiedNameMapForNames.find(usingDirective) == qualifiedNameMapForNames.end())</span></a>
<a name="15842"><span class="lineNum">   15842 </span>            :         {</a>
<a name="15843"><span class="lineNum">   15843 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="15844"><span class="lineNum">   15844 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Inserting qualifier for name = %s into list at IR node = %p = %s \n&quot;,qualifier.c_str(),usingDirective,usingDirective-&gt;class_name().c_str());</a>
<a name="15845"><span class="lineNum">   15845 </span>            : #endif</a>
<a name="15846"><span class="lineNum">   15846 </span><span class="lineCov">         34 :           qualifiedNameMapForNames.insert(std::pair&lt;SgNode*,std::string&gt;(usingDirective,qualifier));</span></a>
<a name="15847"><span class="lineNum">   15847 </span>            :         }</a>
<a name="15848"><span class="lineNum">   15848 </span>            :        else</a>
<a name="15849"><span class="lineNum">   15849 </span>            :         {</a>
<a name="15850"><span class="lineNum">   15850 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(qualifiedNameMapForNames[usingDirective] == qualifier);</span></a>
<a name="15851"><span class="lineNum">   15851 </span>            :         }</a>
<a name="15852"><span class="lineNum">   15852 </span><span class="lineCov">         17 :    }</span></a>
<a name="15853"><span class="lineNum">   15853 </span>            : </a>
<a name="15854"><span class="lineNum">   15854 </span>            : </a>
<a name="15855"><span class="lineNum">   15855 </span>            : // DQ (7/8/2014): Adding support for name qualification of SgNamespaceDeclarations within a SgNamespaceAliasDeclarationStatement.</a>
<a name="15856"><span class="lineNum">   15856 </span>            : void</a>
<a name="15857"><span class="lineNum">   15857 </span><span class="lineNoCov">          0 : NameQualificationTraversal::setNameQualification ( SgNamespaceAliasDeclarationStatement* namespaceAliasDeclaration, SgDeclarationStatement* declaration, int amountOfNameQualificationRequired )</span></a>
<a name="15858"><span class="lineNum">   15858 </span>            :    {</a>
<a name="15859"><span class="lineNum">   15859 </span>            :   // Setup call to refactored code.</a>
<a name="15860"><span class="lineNum">   15860 </span><span class="lineNoCov">          0 :      int  outputNameQualificationLength = 0;</span></a>
<a name="15861"><span class="lineNum">   15861 </span><span class="lineNoCov">          0 :      bool outputGlobalQualification     = false;</span></a>
<a name="15862"><span class="lineNum">   15862 </span><span class="lineNoCov">          0 :      bool outputTypeEvaluation          = false;</span></a>
<a name="15863"><span class="lineNum">   15863 </span>            : </a>
<a name="15864"><span class="lineNum">   15864 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="15865"><span class="lineNum">   15865 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In setNameQualification(SgNamespaceAliasDeclarationStatement*) \n&quot;);</a>
<a name="15866"><span class="lineNum">   15866 </span>            : #endif</a>
<a name="15867"><span class="lineNum">   15867 </span>            : </a>
<a name="15868"><span class="lineNum">   15868 </span><span class="lineNoCov">          0 :      SgScopeStatement * scope = traverseNonrealDeclForCorrectScope(declaration);</span></a>
<a name="15869"><span class="lineNum">   15869 </span><span class="lineNoCov">          0 :      string qualifier = setNameQualificationSupport(scope,amountOfNameQualificationRequired, outputNameQualificationLength, outputGlobalQualification, outputTypeEvaluation);</span></a>
<a name="15870"><span class="lineNum">   15870 </span>            : </a>
<a name="15871"><span class="lineNum">   15871 </span><span class="lineNoCov">          0 :      namespaceAliasDeclaration-&gt;set_global_qualification_required(outputGlobalQualification);</span></a>
<a name="15872"><span class="lineNum">   15872 </span><span class="lineNoCov">          0 :      namespaceAliasDeclaration-&gt;set_name_qualification_length(outputNameQualificationLength);</span></a>
<a name="15873"><span class="lineNum">   15873 </span><span class="lineNoCov">          0 :      namespaceAliasDeclaration-&gt;set_type_elaboration_required(outputTypeEvaluation);</span></a>
<a name="15874"><span class="lineNum">   15874 </span>            : </a>
<a name="15875"><span class="lineNum">   15875 </span>            :   // There should be no type evaluation required for a variable reference, as I recall.</a>
<a name="15876"><span class="lineNum">   15876 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(outputTypeEvaluation == false);</span></a>
<a name="15877"><span class="lineNum">   15877 </span>            : </a>
<a name="15878"><span class="lineNum">   15878 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="15879"><span class="lineNum">   15879 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): namespaceAliasDeclaration-&gt;get_name_qualification_length()     = %d \n&quot;,namespaceAliasDeclaration-&gt;get_name_qualification_length());</a>
<a name="15880"><span class="lineNum">   15880 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): namespaceAliasDeclaration-&gt;get_type_elaboration_required()     = %s \n&quot;,namespaceAliasDeclaration-&gt;get_type_elaboration_required() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="15881"><span class="lineNum">   15881 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): namespaceAliasDeclaration-&gt;get_global_qualification_required() = %s \n&quot;,namespaceAliasDeclaration-&gt;get_global_qualification_required() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="15882"><span class="lineNum">   15882 </span>            : #endif</a>
<a name="15883"><span class="lineNum">   15883 </span>            : </a>
<a name="15884"><span class="lineNum">   15884 </span><span class="lineNoCov">          0 :      if (qualifiedNameMapForNames.find(namespaceAliasDeclaration) == qualifiedNameMapForNames.end())</span></a>
<a name="15885"><span class="lineNum">   15885 </span>            :         {</a>
<a name="15886"><span class="lineNum">   15886 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="15887"><span class="lineNum">   15887 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Inserting qualifier for name = %s into list at IR node = %p = %s \n&quot;,qualifier.c_str(),namespaceAliasDeclaration,namespaceAliasDeclaration-&gt;class_name().c_str());</a>
<a name="15888"><span class="lineNum">   15888 </span>            : #endif</a>
<a name="15889"><span class="lineNum">   15889 </span><span class="lineNoCov">          0 :           qualifiedNameMapForNames.insert(std::pair&lt;SgNode*,std::string&gt;(namespaceAliasDeclaration,qualifier));</span></a>
<a name="15890"><span class="lineNum">   15890 </span>            :         }</a>
<a name="15891"><span class="lineNum">   15891 </span>            :        else</a>
<a name="15892"><span class="lineNum">   15892 </span>            :         {</a>
<a name="15893"><span class="lineNum">   15893 </span><span class="lineNoCov">          0 :           mfprintf(mlog [ WARN ] ) (&quot;Error: name in qualifiedNameMapForNames already exists... \n&quot;);</span></a>
<a name="15894"><span class="lineNum">   15894 </span><span class="lineNoCov">          0 :           ROSE_ABORT();</span></a>
<a name="15895"><span class="lineNum">   15895 </span>            :         }</a>
<a name="15896"><span class="lineNum">   15896 </span><span class="lineNoCov">          0 :    }</span></a>
<a name="15897"><span class="lineNum">   15897 </span>            : </a>
<a name="15898"><span class="lineNum">   15898 </span>            : </a>
<a name="15899"><span class="lineNum">   15899 </span>            : // DQ (3/31/2019): Renamed this function to make it more clear now that we have two versions, one to name</a>
<a name="15900"><span class="lineNum">   15900 </span>            : // qualify the SgInitializedName and one to name qualify the type used in the SgInitializedName.</a>
<a name="15901"><span class="lineNum">   15901 </span>            : // DQ (8/4/2012): Added support to permit global qualification to be skipped explicitly (see test2012_164.C and test2012_165.C for examples where this is important).</a>
<a name="15902"><span class="lineNum">   15902 </span>            : // void NameQualificationTraversal::setNameQualification(SgInitializedName* initializedName,SgFunctionDeclaration* functionDeclaration, int amountOfNameQualificationRequired)</a>
<a name="15903"><span class="lineNum">   15903 </span>            : // void NameQualificationTraversal::setNameQualification(SgInitializedName* initializedName,SgDeclarationStatement* declaration, int amountOfNameQualificationRequired)</a>
<a name="15904"><span class="lineNum">   15904 </span>            : // void NameQualificationTraversal::setNameQualification(SgInitializedName* initializedName,SgDeclarationStatement* declaration, int amountOfNameQualificationRequired, bool skipGlobalQualification)</a>
<a name="15905"><span class="lineNum">   15905 </span>            : void</a>
<a name="15906"><span class="lineNum">   15906 </span><span class="lineCov">    1209960 : NameQualificationTraversal::setNameQualificationOnType(SgInitializedName* initializedName,SgDeclarationStatement* declaration, int amountOfNameQualificationRequired, bool skipGlobalQualification)</span></a>
<a name="15907"><span class="lineNum">   15907 </span>            :    {</a>
<a name="15908"><span class="lineNum">   15908 </span>            :   // This is used to set the name qualification on the type referenced by the SgInitializedName, and not on the SgInitializedName IR node itself.</a>
<a name="15909"><span class="lineNum">   15909 </span>            : </a>
<a name="15910"><span class="lineNum">   15910 </span>            :   // Setup call to refactored code.</a>
<a name="15911"><span class="lineNum">   15911 </span><span class="lineCov">    1209960 :      int  outputNameQualificationLength = 0;</span></a>
<a name="15912"><span class="lineNum">   15912 </span><span class="lineCov">    1209960 :      bool outputGlobalQualification     = false;</span></a>
<a name="15913"><span class="lineNum">   15913 </span><span class="lineCov">    1209960 :      bool outputTypeEvaluation          = false;</span></a>
<a name="15914"><span class="lineNum">   15914 </span>            : </a>
<a name="15915"><span class="lineNum">   15915 </span>            :   // DQ (4/28/2019): Added assertion.</a>
<a name="15916"><span class="lineNum">   15916 </span><span class="lineCov">    1209960 :      ASSERT_not_null(initializedName);</span></a>
<a name="15917"><span class="lineNum">   15917 </span>            : </a>
<a name="15918"><span class="lineNum">   15918 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="15919"><span class="lineNum">   15919 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In setNameQualificationOnType(SgInitializedName*): initializedName = %p = %s \n&quot;,initializedName,initializedName-&gt;get_name().str());</a>
<a name="15920"><span class="lineNum">   15920 </span>            : #endif</a>
<a name="15921"><span class="lineNum">   15921 </span>            : </a>
<a name="15922"><span class="lineNum">   15922 </span>            :   // DQ (4/28/2019): Added assertion.</a>
<a name="15923"><span class="lineNum">   15923 </span><span class="lineCov">    1209960 :      ASSERT_not_null(declaration);</span></a>
<a name="15924"><span class="lineNum">   15924 </span>            : </a>
<a name="15925"><span class="lineNum">   15925 </span><span class="lineCov">    1209960 :      SgScopeStatement * scope = traverseNonrealDeclForCorrectScope(declaration);</span></a>
<a name="15926"><span class="lineNum">   15926 </span><span class="lineCov">    1209960 :      string qualifier = setNameQualificationSupport(scope,amountOfNameQualificationRequired, outputNameQualificationLength, outputGlobalQualification, outputTypeEvaluation);</span></a>
<a name="15927"><span class="lineNum">   15927 </span>            : </a>
<a name="15928"><span class="lineNum">   15928 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="15929"><span class="lineNum">   15929 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In setNameQualificationOnType(SgInitializedName*): qualifier = %s \n&quot;,qualifier.c_str());</a>
<a name="15930"><span class="lineNum">   15930 </span>            : #endif</a>
<a name="15931"><span class="lineNum">   15931 </span>            : </a>
<a name="15932"><span class="lineNum">   15932 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="15933"><span class="lineNum">   15933 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;declaration = %p = %s \n&quot;,declaration,declaration-&gt;class_name().c_str());</a>
<a name="15934"><span class="lineNum">   15934 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;declaration-&gt;get_firstNondefiningDeclaration() = %p \n&quot;,declaration-&gt;get_firstNondefiningDeclaration());</a>
<a name="15935"><span class="lineNum">   15935 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;declaration-&gt;get_definingDeclaration()         = %p \n&quot;,declaration-&gt;get_definingDeclaration());</a>
<a name="15936"><span class="lineNum">   15936 </span>            : #endif</a>
<a name="15937"><span class="lineNum">   15937 </span>            : </a>
<a name="15938"><span class="lineNum">   15938 </span>            :   // unsigned int sourceSequenceForInitializedName = initializedName-&gt;get_file_info()-&gt;get_source_sequence_number();</a>
<a name="15939"><span class="lineNum">   15939 </span>            :   // unsigned int sourceSequenceForTypeDeclaration = declaration-&gt;get_file_info()-&gt;get_source_sequence_number();</a>
<a name="15940"><span class="lineNum">   15940 </span>            : </a>
<a name="15941"><span class="lineNum">   15941 </span>            :   // DQ (5/15/2018): Test code test2018_65.C demonstrates that we need to suppress the</a>
<a name="15942"><span class="lineNum">   15942 </span>            :   // name qualification of the type if the defining declaration has not been seen yet.</a>
<a name="15943"><span class="lineNum">   15943 </span><span class="lineCov">    1209960 :      unsigned int sourceSequenceForInitializedName = 0;</span></a>
<a name="15944"><span class="lineNum">   15944 </span><span class="lineCov">    1209960 :      unsigned int sourceSequenceForTypeDeclaration = 0;</span></a>
<a name="15945"><span class="lineNum">   15945 </span><span class="lineCov">    1209960 :      SgDeclarationStatement* definingDeclaration = declaration-&gt;get_definingDeclaration();</span></a>
<a name="15946"><span class="lineNum">   15946 </span><span class="lineCov">    1209960 :      if (definingDeclaration != NULL)</span></a>
<a name="15947"><span class="lineNum">   15947 </span>            :         {</a>
<a name="15948"><span class="lineNum">   15948 </span>            :        // If we have a defining declaration, then query the source sequence numbers.</a>
<a name="15949"><span class="lineNum">   15949 </span><span class="lineCov">      23281 :           ASSERT_not_null(initializedName-&gt;get_file_info());</span></a>
<a name="15950"><span class="lineNum">   15950 </span><span class="lineCov">      23281 :           ASSERT_not_null(declaration-&gt;get_file_info());</span></a>
<a name="15951"><span class="lineNum">   15951 </span><span class="lineCov">      23281 :           sourceSequenceForTypeDeclaration = definingDeclaration-&gt;get_file_info()-&gt;get_source_sequence_number();</span></a>
<a name="15952"><span class="lineNum">   15952 </span><span class="lineCov">      23281 :           sourceSequenceForInitializedName = initializedName-&gt;get_file_info()-&gt;get_source_sequence_number();</span></a>
<a name="15953"><span class="lineNum">   15953 </span>            :         }</a>
<a name="15954"><span class="lineNum">   15954 </span>            : </a>
<a name="15955"><span class="lineNum">   15955 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="15956"><span class="lineNum">   15956 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;sourceSequenceForInitializedName = %u \n&quot;,sourceSequenceForInitializedName);</a>
<a name="15957"><span class="lineNum">   15957 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;sourceSequenceForTypeDeclaration = %u \n&quot;,sourceSequenceForTypeDeclaration);</a>
<a name="15958"><span class="lineNum">   15958 </span>            : #endif</a>
<a name="15959"><span class="lineNum">   15959 </span>            : </a>
<a name="15960"><span class="lineNum">   15960 </span><span class="lineCov">    1209960 :      bool outputNameQualification = sourceSequenceForTypeDeclaration &lt; sourceSequenceForInitializedName;</span></a>
<a name="15961"><span class="lineNum">   15961 </span>            : </a>
<a name="15962"><span class="lineNum">   15962 </span>            :   // DQ (5/15/2018): If this is a SgTemplateInstantiationTypedefDeclaration then output the name qualification.</a>
<a name="15963"><span class="lineNum">   15963 </span><span class="lineCov">    1209960 :      if (isSgTemplateInstantiationTypedefDeclaration(declaration) != NULL)</span></a>
<a name="15964"><span class="lineNum">   15964 </span>            :         {</a>
<a name="15965"><span class="lineNum">   15965 </span><span class="lineCov">        566 :           outputNameQualification = true;</span></a>
<a name="15966"><span class="lineNum">   15966 </span>            :         }</a>
<a name="15967"><span class="lineNum">   15967 </span>            : </a>
<a name="15968"><span class="lineNum">   15968 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="15969"><span class="lineNum">   15969 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In setNameQualificationOnType(SgInitializedName*): outputNameQualification = %s \n&quot;,outputNameQualification ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="15970"><span class="lineNum">   15970 </span>            : #endif</a>
<a name="15971"><span class="lineNum">   15971 </span>            : </a>
<a name="15972"><span class="lineNum">   15972 </span>            :   // DQ (5/15/2018): Explicitly check for qualifier == &quot;::&quot; (see Cxxx11_tests/test2018_97.C).</a>
<a name="15973"><span class="lineNum">   15973 </span>            :   // DQ (8/4/2012): In rare cases we have to eliminate qualification only if it is going to be global qualification.</a>
<a name="15974"><span class="lineNum">   15974 </span>            :   // if (skipGlobalQualification == true &amp;&amp; qualifier == &quot;::&quot;)</a>
<a name="15975"><span class="lineNum">   15975 </span>            :   // if (skipGlobalQualification == true)</a>
<a name="15976"><span class="lineNum">   15976 </span>            :   // if (skipGlobalQualification == true &amp;&amp; qualifier == &quot;::&quot;)</a>
<a name="15977"><span class="lineNum">   15977 </span><span class="lineCov">    1209960 :      if (skipGlobalQualification == true &amp;&amp; outputNameQualification == false)</span></a>
<a name="15978"><span class="lineNum">   15978 </span>            :         {</a>
<a name="15979"><span class="lineNum">   15979 </span>            : // #ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION</a>
<a name="15980"><span class="lineNum">   15980 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="15981"><span class="lineNum">   15981 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(SgInitializedName* initializedName): skipGlobalQualification has caused global qualification to be ignored \n&quot;);</a>
<a name="15982"><span class="lineNum">   15982 </span>            : #endif</a>
<a name="15983"><span class="lineNum">   15983 </span><span class="lineCov">        759 :           qualifier = &quot;&quot;;</span></a>
<a name="15984"><span class="lineNum">   15984 </span>            : </a>
<a name="15985"><span class="lineNum">   15985 </span><span class="lineCov">        759 :           outputNameQualificationLength = 0;</span></a>
<a name="15986"><span class="lineNum">   15986 </span><span class="lineCov">        759 :           outputGlobalQualification     = false;</span></a>
<a name="15987"><span class="lineNum">   15987 </span>            : </a>
<a name="15988"><span class="lineNum">   15988 </span>            :        // Note clear if this is what we want.</a>
<a name="15989"><span class="lineNum">   15989 </span><span class="lineCov">        759 :           outputTypeEvaluation          = false;</span></a>
<a name="15990"><span class="lineNum">   15990 </span>            : #if 0</a>
<a name="15991"><span class="lineNum">   15991 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="15992"><span class="lineNum">   15992 </span>            :           ROSE_ABORT();</a>
<a name="15993"><span class="lineNum">   15993 </span>            : #endif</a>
<a name="15994"><span class="lineNum">   15994 </span>            :         }</a>
<a name="15995"><span class="lineNum">   15995 </span>            : </a>
<a name="15996"><span class="lineNum">   15996 </span><span class="lineCov">    1209960 :      initializedName-&gt;set_global_qualification_required_for_type(outputGlobalQualification);</span></a>
<a name="15997"><span class="lineNum">   15997 </span><span class="lineCov">    1209960 :      initializedName-&gt;set_name_qualification_length_for_type(outputNameQualificationLength);</span></a>
<a name="15998"><span class="lineNum">   15998 </span><span class="lineCov">    1209960 :      initializedName-&gt;set_type_elaboration_required_for_type(outputTypeEvaluation);</span></a>
<a name="15999"><span class="lineNum">   15999 </span>            : </a>
<a name="16000"><span class="lineNum">   16000 </span>            :   // There should be no type evaluation required for a variable reference, as I recall.</a>
<a name="16001"><span class="lineNum">   16001 </span><span class="lineCov">    1209960 :      ROSE_ASSERT(outputTypeEvaluation == false);</span></a>
<a name="16002"><span class="lineNum">   16002 </span>            : </a>
<a name="16003"><span class="lineNum">   16003 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="16004"><span class="lineNum">   16004 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualificationOnType(): initializedName-&gt;get_name_qualification_length_for_type()     = %d \n&quot;,initializedName-&gt;get_name_qualification_length_for_type());</a>
<a name="16005"><span class="lineNum">   16005 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualificationOnType(): initializedName-&gt;get_type_elaboration_required_for_type()     = %s \n&quot;,initializedName-&gt;get_type_elaboration_required_for_type() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="16006"><span class="lineNum">   16006 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualificationOnType(): initializedName-&gt;get_global_qualification_required_for_type() = %s \n&quot;,initializedName-&gt;get_global_qualification_required_for_type() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="16007"><span class="lineNum">   16007 </span>            : #endif</a>
<a name="16008"><span class="lineNum">   16008 </span>            : </a>
<a name="16009"><span class="lineNum">   16009 </span><span class="lineCov">    2419920 :      if (qualifiedNameMapForTypes.find(initializedName) == qualifiedNameMapForTypes.end())</span></a>
<a name="16010"><span class="lineNum">   16010 </span>            :         {</a>
<a name="16011"><span class="lineNum">   16011 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="16012"><span class="lineNum">   16012 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Inserting qualifier for type = %s into list at SgInitializedName IR node = %p = %s \n&quot;,qualifier.c_str(),initializedName,initializedName-&gt;get_name().str());</a>
<a name="16013"><span class="lineNum">   16013 </span>            : #endif</a>
<a name="16014"><span class="lineNum">   16014 </span><span class="lineCov">    2405790 :           qualifiedNameMapForTypes.insert(std::pair&lt;SgNode*,std::string&gt;(initializedName,qualifier));</span></a>
<a name="16015"><span class="lineNum">   16015 </span>            :         }</a>
<a name="16016"><span class="lineNum">   16016 </span>            :        else</a>
<a name="16017"><span class="lineNum">   16017 </span>            :         {</a>
<a name="16018"><span class="lineNum">   16018 </span>            :        // If it already existes then overwrite the existing information.</a>
<a name="16019"><span class="lineNum">   16019 </span><span class="lineCov">     141335 :           std::map&lt;SgNode*,std::string&gt;::iterator i = qualifiedNameMapForTypes.find(initializedName);</span></a>
<a name="16020"><span class="lineNum">   16020 </span><span class="lineCov">       7066 :           ROSE_ASSERT (i != qualifiedNameMapForTypes.end());</span></a>
<a name="16021"><span class="lineNum">   16021 </span>            : </a>
<a name="16022"><span class="lineNum">   16022 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="16023"><span class="lineNum">   16023 </span>            :           string previousQualifier = i-&gt;second.c_str();</a>
<a name="16024"><span class="lineNum">   16024 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;WARNING: test 12: replacing previousQualifier = %s with new qualifier = %s \n&quot;,previousQualifier.c_str(),qualifier.c_str());</a>
<a name="16025"><span class="lineNum">   16025 </span>            : #endif</a>
<a name="16026"><span class="lineNum">   16026 </span>            :        // I think I can do this!</a>
<a name="16027"><span class="lineNum">   16027 </span>            :        // *i = std::pair&lt;SgNode*,std::string&gt;(templateArgument,qualifier);</a>
<a name="16028"><span class="lineNum">   16028 </span><span class="lineCov">       7066 :           if (i-&gt;second != qualifier)</span></a>
<a name="16029"><span class="lineNum">   16029 </span>            :              {</a>
<a name="16030"><span class="lineNum">   16030 </span><span class="lineCov">    1209960 :                i-&gt;second = qualifier;</span></a>
<a name="16031"><span class="lineNum">   16031 </span>            : </a>
<a name="16032"><span class="lineNum">   16032 </span>            : #ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION</a>
<a name="16033"><span class="lineNum">   16033 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;WARNING: name in qualifiedNameMapForTypes already exists and is different... \n&quot;);</a>
<a name="16034"><span class="lineNum">   16034 </span>            : #endif</a>
<a name="16035"><span class="lineNum">   16035 </span>            :             // ROSE_ASSERT(false);</a>
<a name="16036"><span class="lineNum">   16036 </span>            :              }</a>
<a name="16037"><span class="lineNum">   16037 </span>            :         }</a>
<a name="16038"><span class="lineNum">   16038 </span><span class="lineCov">    1209960 :    }</span></a>
<a name="16039"><span class="lineNum">   16039 </span>            : </a>
<a name="16040"><span class="lineNum">   16040 </span>            : </a>
<a name="16041"><span class="lineNum">   16041 </span>            : // DQ (12/17/2013): Added support for the name qualification of the SgInitializedName object when used in the context of the preinitialization list.</a>
<a name="16042"><span class="lineNum">   16042 </span>            : void</a>
<a name="16043"><span class="lineNum">   16043 </span><span class="lineCov">        462 : NameQualificationTraversal::setNameQualificationOnName(SgInitializedName* initializedName,SgDeclarationStatement* declaration, int amountOfNameQualificationRequired, bool skipGlobalQualification)</span></a>
<a name="16044"><span class="lineNum">   16044 </span>            :    {</a>
<a name="16045"><span class="lineNum">   16045 </span>            :   // This is used to set the name qualification on the SgInitializedName directly, and not on the type referenced by the SgInitializedName IR node.</a>
<a name="16046"><span class="lineNum">   16046 </span>            : </a>
<a name="16047"><span class="lineNum">   16047 </span>            :   // Setup call to refactored code.</a>
<a name="16048"><span class="lineNum">   16048 </span><span class="lineCov">        462 :      int  outputNameQualificationLength = 0;</span></a>
<a name="16049"><span class="lineNum">   16049 </span><span class="lineCov">        462 :      bool outputGlobalQualification     = false;</span></a>
<a name="16050"><span class="lineNum">   16050 </span><span class="lineCov">        462 :      bool outputTypeEvaluation          = false;</span></a>
<a name="16051"><span class="lineNum">   16051 </span>            : </a>
<a name="16052"><span class="lineNum">   16052 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="16053"><span class="lineNum">   16053 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In setNameQualificationOnName(SgInitializedName*): amountOfNameQualificationRequired = %d \n&quot;,amountOfNameQualificationRequired);</a>
<a name="16054"><span class="lineNum">   16054 </span>            : #endif</a>
<a name="16055"><span class="lineNum">   16055 </span>            : </a>
<a name="16056"><span class="lineNum">   16056 </span><span class="lineCov">        462 :      SgScopeStatement * scope = traverseNonrealDeclForCorrectScope(declaration);</span></a>
<a name="16057"><span class="lineNum">   16057 </span><span class="lineCov">        462 :      string qualifier = setNameQualificationSupport(scope,amountOfNameQualificationRequired, outputNameQualificationLength, outputGlobalQualification, outputTypeEvaluation);</span></a>
<a name="16058"><span class="lineNum">   16058 </span>            : </a>
<a name="16059"><span class="lineNum">   16059 </span>            :   // DQ (8/4/2012): In rare cases we have to eliminate qualification only if it is going to be global qualification.</a>
<a name="16060"><span class="lineNum">   16060 </span>            :   // if (skipGlobalQualification == true &amp;&amp; qualifier == &quot;::&quot;)</a>
<a name="16061"><span class="lineNum">   16061 </span><span class="lineCov">        462 :      if (skipGlobalQualification == true)</span></a>
<a name="16062"><span class="lineNum">   16062 </span>            :         {</a>
<a name="16063"><span class="lineNum">   16063 </span>            : // #ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION</a>
<a name="16064"><span class="lineNum">   16064 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="16065"><span class="lineNum">   16065 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualificationOnName(SgInitializedName* initializedName): skipGlobalQualification has caused global qualification to be ignored \n&quot;);</a>
<a name="16066"><span class="lineNum">   16066 </span>            : #endif</a>
<a name="16067"><span class="lineNum">   16067 </span><span class="lineNoCov">          0 :           qualifier = &quot;&quot;;</span></a>
<a name="16068"><span class="lineNum">   16068 </span>            : </a>
<a name="16069"><span class="lineNum">   16069 </span><span class="lineNoCov">          0 :           outputNameQualificationLength = 0;</span></a>
<a name="16070"><span class="lineNum">   16070 </span><span class="lineNoCov">          0 :           outputGlobalQualification     = false;</span></a>
<a name="16071"><span class="lineNum">   16071 </span>            : </a>
<a name="16072"><span class="lineNum">   16072 </span>            :        // Note clear if this is what we want.</a>
<a name="16073"><span class="lineNum">   16073 </span><span class="lineNoCov">          0 :           outputTypeEvaluation          = false;</span></a>
<a name="16074"><span class="lineNum">   16074 </span>            : #if 0</a>
<a name="16075"><span class="lineNum">   16075 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="16076"><span class="lineNum">   16076 </span>            :           ROSE_ABORT();</a>
<a name="16077"><span class="lineNum">   16077 </span>            : #endif</a>
<a name="16078"><span class="lineNum">   16078 </span>            :         }</a>
<a name="16079"><span class="lineNum">   16079 </span>            : </a>
<a name="16080"><span class="lineNum">   16080 </span>            : #if 0</a>
<a name="16081"><span class="lineNum">   16081 </span>            :   // Old version of code</a>
<a name="16082"><span class="lineNum">   16082 </span>            :      initializedName-&gt;set_global_qualification_required_for_type(outputGlobalQualification);</a>
<a name="16083"><span class="lineNum">   16083 </span>            :      initializedName-&gt;set_name_qualification_length_for_type(outputNameQualificationLength);</a>
<a name="16084"><span class="lineNum">   16084 </span>            :      initializedName-&gt;set_type_elaboration_required_for_type(outputTypeEvaluation);</a>
<a name="16085"><span class="lineNum">   16085 </span>            : #else</a>
<a name="16086"><span class="lineNum">   16086 </span>            :   // DQ (3/31/2019): New version of code</a>
<a name="16087"><span class="lineNum">   16087 </span><span class="lineCov">        462 :      initializedName-&gt;set_global_qualification_required(outputGlobalQualification);</span></a>
<a name="16088"><span class="lineNum">   16088 </span><span class="lineCov">        462 :      initializedName-&gt;set_name_qualification_length(outputNameQualificationLength);</span></a>
<a name="16089"><span class="lineNum">   16089 </span><span class="lineCov">        462 :      initializedName-&gt;set_type_elaboration_required(outputTypeEvaluation);</span></a>
<a name="16090"><span class="lineNum">   16090 </span>            : #endif</a>
<a name="16091"><span class="lineNum">   16091 </span>            : </a>
<a name="16092"><span class="lineNum">   16092 </span>            :   // There should be no type evaluation required for a variable reference, as I recall.</a>
<a name="16093"><span class="lineNum">   16093 </span><span class="lineCov">        462 :      ROSE_ASSERT(outputTypeEvaluation == false);</span></a>
<a name="16094"><span class="lineNum">   16094 </span>            : </a>
<a name="16095"><span class="lineNum">   16095 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="16096"><span class="lineNum">   16096 </span>            :   // mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualificationOnName(): initializedName-&gt;get_name_qualification_length_for_type()     = %d \n&quot;,initializedName-&gt;get_name_qualification_length_for_type());</a>
<a name="16097"><span class="lineNum">   16097 </span>            :   // mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualificationOnName(): initializedName-&gt;get_type_elaboration_required_for_type()     = %s \n&quot;,initializedName-&gt;get_type_elaboration_required_for_type() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="16098"><span class="lineNum">   16098 </span>            :   // mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualificationOnName(): initializedName-&gt;get_global_qualification_required_for_type() = %s \n&quot;,initializedName-&gt;get_global_qualification_required_for_type() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="16099"><span class="lineNum">   16099 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualificationOnName(): initializedName-&gt;get_name_qualification_length()     = %d \n&quot;,initializedName-&gt;get_name_qualification_length());</a>
<a name="16100"><span class="lineNum">   16100 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualificationOnName(): initializedName-&gt;get_type_elaboration_required()     = %s \n&quot;,initializedName-&gt;get_type_elaboration_required() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="16101"><span class="lineNum">   16101 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualificationOnName(): initializedName-&gt;get_global_qualification_required() = %s \n&quot;,initializedName-&gt;get_global_qualification_required() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="16102"><span class="lineNum">   16102 </span>            : #endif</a>
<a name="16103"><span class="lineNum">   16103 </span>            : </a>
<a name="16104"><span class="lineNum">   16104 </span><span class="lineCov">        924 :      if (qualifiedNameMapForNames.find(initializedName) == qualifiedNameMapForNames.end())</span></a>
<a name="16105"><span class="lineNum">   16105 </span>            :         {</a>
<a name="16106"><span class="lineNum">   16106 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="16107"><span class="lineNum">   16107 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Inserting qualifier for SgInitializedName = %s into list at SgInitializedName IR node = %p = %s \n&quot;,qualifier.c_str(),initializedName,initializedName-&gt;get_name().str());</a>
<a name="16108"><span class="lineNum">   16108 </span>            : #endif</a>
<a name="16109"><span class="lineNum">   16109 </span><span class="lineCov">        906 :           qualifiedNameMapForNames.insert(std::pair&lt;SgNode*,std::string&gt;(initializedName,qualifier));</span></a>
<a name="16110"><span class="lineNum">   16110 </span>            :         }</a>
<a name="16111"><span class="lineNum">   16111 </span>            :        else</a>
<a name="16112"><span class="lineNum">   16112 </span>            :         {</a>
<a name="16113"><span class="lineNum">   16113 </span>            :        // If it already exists then overwrite the existing information.</a>
<a name="16114"><span class="lineNum">   16114 </span><span class="lineCov">        165 :           std::map&lt;SgNode*,std::string&gt;::iterator i = qualifiedNameMapForNames.find(initializedName);</span></a>
<a name="16115"><span class="lineNum">   16115 </span><span class="lineCov">          9 :           ROSE_ASSERT (i != qualifiedNameMapForNames.end());</span></a>
<a name="16116"><span class="lineNum">   16116 </span>            : </a>
<a name="16117"><span class="lineNum">   16117 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="16118"><span class="lineNum">   16118 </span>            :           string previousQualifier = i-&gt;second.c_str();</a>
<a name="16119"><span class="lineNum">   16119 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;WARNING: test 13: replacing previousQualifier = %s with new qualifier = %s \n&quot;,previousQualifier.c_str(),qualifier.c_str());</a>
<a name="16120"><span class="lineNum">   16120 </span>            : #endif</a>
<a name="16121"><span class="lineNum">   16121 </span>            :        // I think I can do this!</a>
<a name="16122"><span class="lineNum">   16122 </span>            :        // *i = std::pair&lt;SgNode*,std::string&gt;(templateArgument,qualifier);</a>
<a name="16123"><span class="lineNum">   16123 </span><span class="lineCov">          9 :           if (i-&gt;second != qualifier)</span></a>
<a name="16124"><span class="lineNum">   16124 </span>            :              {</a>
<a name="16125"><span class="lineNum">   16125 </span><span class="lineCov">        462 :                i-&gt;second = qualifier;</span></a>
<a name="16126"><span class="lineNum">   16126 </span>            : </a>
<a name="16127"><span class="lineNum">   16127 </span>            : #ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION</a>
<a name="16128"><span class="lineNum">   16128 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;WARNING: name in qualifiedNameMapForNames already exists and is different... \n&quot;);</a>
<a name="16129"><span class="lineNum">   16129 </span>            : #endif</a>
<a name="16130"><span class="lineNum">   16130 </span>            :             // ROSE_ASSERT(false);</a>
<a name="16131"><span class="lineNum">   16131 </span>            :              }</a>
<a name="16132"><span class="lineNum">   16132 </span>            :         }</a>
<a name="16133"><span class="lineNum">   16133 </span>            : </a>
<a name="16134"><span class="lineNum">   16134 </span>            : #if 0</a>
<a name="16135"><span class="lineNum">   16135 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test in the support for name qualifiction in the preinitialization list \n&quot;);</a>
<a name="16136"><span class="lineNum">   16136 </span>            :      ROSE_ABORT();</a>
<a name="16137"><span class="lineNum">   16137 </span>            : #endif</a>
<a name="16138"><span class="lineNum">   16138 </span><span class="lineCov">        462 :    }</span></a>
<a name="16139"><span class="lineNum">   16139 </span>            : </a>
<a name="16140"><span class="lineNum">   16140 </span>            : </a>
<a name="16141"><span class="lineNum">   16141 </span>            : void</a>
<a name="16142"><span class="lineNum">   16142 </span><span class="lineNoCov">          0 : NameQualificationTraversal::setNameQualification(SgVariableDeclaration* variableDeclaration,SgDeclarationStatement* declaration, int amountOfNameQualificationRequired)</span></a>
<a name="16143"><span class="lineNum">   16143 </span>            :    {</a>
<a name="16144"><span class="lineNum">   16144 </span>            :   // This is used to set the name qualification on the associated SgInitializedName (there is only one per SgVariableDeclaration at present, but this may be changed (fixed) in the future.</a>
<a name="16145"><span class="lineNum">   16145 </span>            : </a>
<a name="16146"><span class="lineNum">   16146 </span>            :   // Setup call to refactored code.</a>
<a name="16147"><span class="lineNum">   16147 </span><span class="lineNoCov">          0 :      int  outputNameQualificationLength = 0;</span></a>
<a name="16148"><span class="lineNum">   16148 </span><span class="lineNoCov">          0 :      bool outputGlobalQualification     = false;</span></a>
<a name="16149"><span class="lineNum">   16149 </span><span class="lineNoCov">          0 :      bool outputTypeEvaluation          = false;</span></a>
<a name="16150"><span class="lineNum">   16150 </span>            : </a>
<a name="16151"><span class="lineNum">   16151 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="16152"><span class="lineNum">   16152 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In setNameQualification(SgVariableDeclaration*) \n&quot;);</a>
<a name="16153"><span class="lineNum">   16153 </span>            : #endif</a>
<a name="16154"><span class="lineNum">   16154 </span>            : </a>
<a name="16155"><span class="lineNum">   16155 </span><span class="lineNoCov">          0 :      SgScopeStatement * scope = traverseNonrealDeclForCorrectScope(declaration);</span></a>
<a name="16156"><span class="lineNum">   16156 </span><span class="lineNoCov">          0 :      string qualifier = setNameQualificationSupport(scope,amountOfNameQualificationRequired, outputNameQualificationLength, outputGlobalQualification, outputTypeEvaluation);</span></a>
<a name="16157"><span class="lineNum">   16157 </span>            : </a>
<a name="16158"><span class="lineNum">   16158 </span><span class="lineNoCov">          0 :      variableDeclaration-&gt;set_global_qualification_required(outputGlobalQualification);</span></a>
<a name="16159"><span class="lineNum">   16159 </span><span class="lineNoCov">          0 :      variableDeclaration-&gt;set_name_qualification_length(outputNameQualificationLength);</span></a>
<a name="16160"><span class="lineNum">   16160 </span><span class="lineNoCov">          0 :      variableDeclaration-&gt;set_type_elaboration_required(outputTypeEvaluation);</span></a>
<a name="16161"><span class="lineNum">   16161 </span>            : </a>
<a name="16162"><span class="lineNum">   16162 </span>            :   // There should be no type evaluation required for a variable reference, as I recall.</a>
<a name="16163"><span class="lineNum">   16163 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(outputTypeEvaluation == false);</span></a>
<a name="16164"><span class="lineNum">   16164 </span>            : </a>
<a name="16165"><span class="lineNum">   16165 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="16166"><span class="lineNum">   16166 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): variableDeclaration-&gt;get_name_qualification_length()     = %d \n&quot;,variableDeclaration-&gt;get_name_qualification_length());</a>
<a name="16167"><span class="lineNum">   16167 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): variableDeclaration-&gt;get_type_elaboration_required()     = %s \n&quot;,variableDeclaration-&gt;get_type_elaboration_required() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="16168"><span class="lineNum">   16168 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): variableDeclaration-&gt;get_global_qualification_required() = %s \n&quot;,variableDeclaration-&gt;get_global_qualification_required() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="16169"><span class="lineNum">   16169 </span>            : #endif</a>
<a name="16170"><span class="lineNum">   16170 </span>            : </a>
<a name="16171"><span class="lineNum">   16171 </span><span class="lineNoCov">          0 :      std::map&lt;SgNode*,std::string&gt;::iterator it_qualifiedNameMapForNames = qualifiedNameMapForNames.find(variableDeclaration);</span></a>
<a name="16172"><span class="lineNum">   16172 </span><span class="lineNoCov">          0 :      if (it_qualifiedNameMapForNames == qualifiedNameMapForNames.end())</span></a>
<a name="16173"><span class="lineNum">   16173 </span>            :         {</a>
<a name="16174"><span class="lineNum">   16174 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="16175"><span class="lineNum">   16175 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Inserting qualifier for name = %s into list at SgVariableDeclaration IR node = %p = %s \n&quot;,qualifier.c_str(),variableDeclaration,variableDeclaration-&gt;class_name().c_str());</a>
<a name="16176"><span class="lineNum">   16176 </span>            : #endif</a>
<a name="16177"><span class="lineNum">   16177 </span><span class="lineNoCov">          0 :           qualifiedNameMapForNames.insert(std::pair&lt;SgNode*,std::string&gt;(variableDeclaration,qualifier));</span></a>
<a name="16178"><span class="lineNum">   16178 </span>            :         }</a>
<a name="16179"><span class="lineNum">   16179 </span>            :        else</a>
<a name="16180"><span class="lineNum">   16180 </span>            :         {</a>
<a name="16181"><span class="lineNum">   16181 </span>            :        // If it already existes then overwrite the existing information.</a>
<a name="16182"><span class="lineNum">   16182 </span><span class="lineNoCov">          0 :           std::map&lt;SgNode*,std::string&gt;::iterator i = qualifiedNameMapForNames.find(variableDeclaration);</span></a>
<a name="16183"><span class="lineNum">   16183 </span><span class="lineNoCov">          0 :           ROSE_ASSERT (i != qualifiedNameMapForNames.end());</span></a>
<a name="16184"><span class="lineNum">   16184 </span>            : </a>
<a name="16185"><span class="lineNum">   16185 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="16186"><span class="lineNum">   16186 </span>            :           string previousQualifier = i-&gt;second.c_str();</a>
<a name="16187"><span class="lineNum">   16187 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;WARNING: test 14: replacing previousQualifier = %s with new qualifier = %s \n&quot;,previousQualifier.c_str(),qualifier.c_str());</a>
<a name="16188"><span class="lineNum">   16188 </span>            : #endif</a>
<a name="16189"><span class="lineNum">   16189 </span>            :        // I think I can do this!</a>
<a name="16190"><span class="lineNum">   16190 </span>            :        // *i = std::pair&lt;SgNode*,std::string&gt;(templateArgument,qualifier);</a>
<a name="16191"><span class="lineNum">   16191 </span><span class="lineNoCov">          0 :           if (i-&gt;second != qualifier)</span></a>
<a name="16192"><span class="lineNum">   16192 </span>            :              {</a>
<a name="16193"><span class="lineNum">   16193 </span><span class="lineNoCov">          0 :                i-&gt;second = qualifier;</span></a>
<a name="16194"><span class="lineNum">   16194 </span>            : </a>
<a name="16195"><span class="lineNum">   16195 </span>            : #ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION</a>
<a name="16196"><span class="lineNum">   16196 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;WARNING: name in qualifiedNameMapForNames already exists and is different... \n&quot;);</a>
<a name="16197"><span class="lineNum">   16197 </span>            : #endif</a>
<a name="16198"><span class="lineNum">   16198 </span>            :             // ROSE_ASSERT(false);</a>
<a name="16199"><span class="lineNum">   16199 </span>            :              }</a>
<a name="16200"><span class="lineNum">   16200 </span>            : #if 0</a>
<a name="16201"><span class="lineNum">   16201 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Error: name in qualifiedNameMapForNames already exists... \n&quot;);</a>
<a name="16202"><span class="lineNum">   16202 </span>            :           ROSE_ABORT();</a>
<a name="16203"><span class="lineNum">   16203 </span>            : #endif</a>
<a name="16204"><span class="lineNum">   16204 </span>            :         }</a>
<a name="16205"><span class="lineNum">   16205 </span><span class="lineNoCov">          0 :    }</span></a>
<a name="16206"><span class="lineNum">   16206 </span>            : </a>
<a name="16207"><span class="lineNum">   16207 </span>            : void</a>
<a name="16208"><span class="lineNum">   16208 </span><span class="lineCov">      13024 : NameQualificationTraversal::setNameQualificationOnBaseType(SgTypedefDeclaration* typedefDeclaration, SgDeclarationStatement* declaration, int amountOfNameQualificationRequired)</span></a>
<a name="16209"><span class="lineNum">   16209 </span>            :    {</a>
<a name="16210"><span class="lineNum">   16210 </span>            :   // Setup call to refactored code.</a>
<a name="16211"><span class="lineNum">   16211 </span><span class="lineCov">      13024 :      int  outputNameQualificationLength = 0;</span></a>
<a name="16212"><span class="lineNum">   16212 </span><span class="lineCov">      13024 :      bool outputGlobalQualification     = false;</span></a>
<a name="16213"><span class="lineNum">   16213 </span><span class="lineCov">      13024 :      bool outputTypeEvaluation          = false;</span></a>
<a name="16214"><span class="lineNum">   16214 </span>            : </a>
<a name="16215"><span class="lineNum">   16215 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="16216"><span class="lineNum">   16216 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In setNameQualificationOnBaseType(SgTypedefDeclaration*) \n&quot;);</a>
<a name="16217"><span class="lineNum">   16217 </span>            :      mfprintf(mlog [ WARN ] ) (&quot; --- typedefDeclaration = %p (%s)\n&quot;, typedefDeclaration, typedefDeclaration-&gt;class_name().c_str());</a>
<a name="16218"><span class="lineNum">   16218 </span>            :      mfprintf(mlog [ WARN ] ) (&quot; --- declaration = %p (%s)\n&quot;, declaration, declaration-&gt;class_name().c_str());</a>
<a name="16219"><span class="lineNum">   16219 </span>            : #endif</a>
<a name="16220"><span class="lineNum">   16220 </span>            : </a>
<a name="16221"><span class="lineNum">   16221 </span><span class="lineCov">      13024 :      SgScopeStatement * scope = traverseNonrealDeclForCorrectScope(declaration);</span></a>
<a name="16222"><span class="lineNum">   16222 </span><span class="lineCov">      13024 :      string qualifier = setNameQualificationSupport(scope,amountOfNameQualificationRequired, outputNameQualificationLength, outputGlobalQualification, outputTypeEvaluation);</span></a>
<a name="16223"><span class="lineNum">   16223 </span>            : </a>
<a name="16224"><span class="lineNum">   16224 </span><span class="lineCov">      13024 :      typedefDeclaration-&gt;set_global_qualification_required_for_base_type(outputGlobalQualification);</span></a>
<a name="16225"><span class="lineNum">   16225 </span><span class="lineCov">      13024 :      typedefDeclaration-&gt;set_name_qualification_length_for_base_type(outputNameQualificationLength);</span></a>
<a name="16226"><span class="lineNum">   16226 </span><span class="lineCov">      13024 :      typedefDeclaration-&gt;set_type_elaboration_required_for_base_type(outputTypeEvaluation);</span></a>
<a name="16227"><span class="lineNum">   16227 </span>            : </a>
<a name="16228"><span class="lineNum">   16228 </span>            :   // There should be no type evaluation required for a variable reference, as I recall.</a>
<a name="16229"><span class="lineNum">   16229 </span><span class="lineCov">      13024 :      ROSE_ASSERT(outputTypeEvaluation == false);</span></a>
<a name="16230"><span class="lineNum">   16230 </span>            : </a>
<a name="16231"><span class="lineNum">   16231 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="16232"><span class="lineNum">   16232 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualificationOnBaseType(): typedefDeclaration-&gt;get_name_qualification_length_for_base_type()     = %d \n&quot;,typedefDeclaration-&gt;get_name_qualification_length_for_base_type());</a>
<a name="16233"><span class="lineNum">   16233 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualificationOnBaseType(): typedefDeclaration-&gt;get_type_elaboration_required_for_base_type()     = %s \n&quot;,typedefDeclaration-&gt;get_type_elaboration_required_for_base_type() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="16234"><span class="lineNum">   16234 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualificationOnBaseType(): typedefDeclaration-&gt;get_global_qualification_required_for_base_type() = %s \n&quot;,typedefDeclaration-&gt;get_global_qualification_required_for_base_type() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="16235"><span class="lineNum">   16235 </span>            : #endif</a>
<a name="16236"><span class="lineNum">   16236 </span>            : </a>
<a name="16237"><span class="lineNum">   16237 </span><span class="lineCov">      26048 :      if (qualifiedNameMapForTypes.find(typedefDeclaration) == qualifiedNameMapForTypes.end())</span></a>
<a name="16238"><span class="lineNum">   16238 </span>            :         {</a>
<a name="16239"><span class="lineNum">   16239 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="16240"><span class="lineNum">   16240 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Inserting qualifier for type = %s into list at IR node = %p = %s \n&quot;,qualifier.c_str(),typedefDeclaration,typedefDeclaration-&gt;class_name().c_str());</a>
<a name="16241"><span class="lineNum">   16241 </span>            : #endif</a>
<a name="16242"><span class="lineNum">   16242 </span><span class="lineCov">      26048 :           qualifiedNameMapForTypes.insert(std::pair&lt;SgNode*,std::string&gt;(typedefDeclaration,qualifier));</span></a>
<a name="16243"><span class="lineNum">   16243 </span>            :         }</a>
<a name="16244"><span class="lineNum">   16244 </span>            :        else</a>
<a name="16245"><span class="lineNum">   16245 </span>            :         {</a>
<a name="16246"><span class="lineNum">   16246 </span>            :        // If it already existes then overwrite the existing information.</a>
<a name="16247"><span class="lineNum">   16247 </span><span class="lineNoCov">          0 :           std::map&lt;SgNode*,std::string&gt;::iterator i = qualifiedNameMapForTypes.find(typedefDeclaration);</span></a>
<a name="16248"><span class="lineNum">   16248 </span><span class="lineNoCov">          0 :           ROSE_ASSERT (i != qualifiedNameMapForTypes.end());</span></a>
<a name="16249"><span class="lineNum">   16249 </span>            : </a>
<a name="16250"><span class="lineNum">   16250 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="16251"><span class="lineNum">   16251 </span>            :           string previousQualifier = i-&gt;second.c_str();</a>
<a name="16252"><span class="lineNum">   16252 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;WARNING: test 15: replacing previousQualifier = %s with new qualifier = %s \n&quot;,previousQualifier.c_str(),qualifier.c_str());</a>
<a name="16253"><span class="lineNum">   16253 </span>            : #endif</a>
<a name="16254"><span class="lineNum">   16254 </span>            :        // I think I can do this!</a>
<a name="16255"><span class="lineNum">   16255 </span>            :        // *i = std::pair&lt;SgNode*,std::string&gt;(templateArgument,qualifier);</a>
<a name="16256"><span class="lineNum">   16256 </span><span class="lineNoCov">          0 :           if (i-&gt;second != qualifier)</span></a>
<a name="16257"><span class="lineNum">   16257 </span>            :              {</a>
<a name="16258"><span class="lineNum">   16258 </span><span class="lineCov">      13024 :                i-&gt;second = qualifier;</span></a>
<a name="16259"><span class="lineNum">   16259 </span>            : </a>
<a name="16260"><span class="lineNum">   16260 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="16261"><span class="lineNum">   16261 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;WARNING: name in qualifiedNameMapForTypes already exists and is different... \n&quot;);</a>
<a name="16262"><span class="lineNum">   16262 </span>            :             // ROSE_ASSERT(false);</a>
<a name="16263"><span class="lineNum">   16263 </span>            : </a>
<a name="16264"><span class="lineNum">   16264 </span>            :                SgName testNameInMap = typedefDeclaration-&gt;get_qualified_name_prefix();</a>
<a name="16265"><span class="lineNum">   16265 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;testNameInMap = %s \n&quot;,testNameInMap.str());</a>
<a name="16266"><span class="lineNum">   16266 </span>            : #endif</a>
<a name="16267"><span class="lineNum">   16267 </span>            :              }</a>
<a name="16268"><span class="lineNum">   16268 </span>            : #if 0</a>
<a name="16269"><span class="lineNum">   16269 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Error: name in qualifiedNameMapForTypes already exists... \n&quot;);</a>
<a name="16270"><span class="lineNum">   16270 </span>            :           ROSE_ABORT();</a>
<a name="16271"><span class="lineNum">   16271 </span>            : #endif</a>
<a name="16272"><span class="lineNum">   16272 </span>            :         }</a>
<a name="16273"><span class="lineNum">   16273 </span><span class="lineCov">      13024 :    }</span></a>
<a name="16274"><span class="lineNum">   16274 </span>            : </a>
<a name="16275"><span class="lineNum">   16275 </span>            : </a>
<a name="16276"><span class="lineNum">   16276 </span>            : void</a>
<a name="16277"><span class="lineNum">   16277 </span><span class="lineNoCov">          0 : NameQualificationTraversal::setNameQualificationOnPointerMemberClass(SgTypedefDeclaration* typedefDeclaration, SgDeclarationStatement* declaration, int amountOfNameQualificationRequired)</span></a>
<a name="16278"><span class="lineNum">   16278 </span>            :    {</a>
<a name="16279"><span class="lineNum">   16279 </span>            :   // Setup call to refactored code.</a>
<a name="16280"><span class="lineNum">   16280 </span><span class="lineNoCov">          0 :      int  outputNameQualificationLength = 0;</span></a>
<a name="16281"><span class="lineNum">   16281 </span><span class="lineNoCov">          0 :      bool outputGlobalQualification     = false;</span></a>
<a name="16282"><span class="lineNum">   16282 </span><span class="lineNoCov">          0 :      bool outputTypeEvaluation          = false;</span></a>
<a name="16283"><span class="lineNum">   16283 </span>            : </a>
<a name="16284"><span class="lineNum">   16284 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="16285"><span class="lineNum">   16285 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In setNameQualificationOnPointerMemberClass(SgTypedefDeclaration*) \n&quot;);</a>
<a name="16286"><span class="lineNum">   16286 </span>            :      mfprintf(mlog [ WARN ] ) (&quot; --- typedefDeclaration = %p (%s)\n&quot;, typedefDeclaration, typedefDeclaration-&gt;class_name().c_str());</a>
<a name="16287"><span class="lineNum">   16287 </span>            :      mfprintf(mlog [ WARN ] ) (&quot; --- declaration = %p (%s)\n&quot;, declaration, declaration-&gt;class_name().c_str());</a>
<a name="16288"><span class="lineNum">   16288 </span>            : #endif</a>
<a name="16289"><span class="lineNum">   16289 </span>            : </a>
<a name="16290"><span class="lineNum">   16290 </span><span class="lineNoCov">          0 :      SgScopeStatement * scope = traverseNonrealDeclForCorrectScope(declaration);</span></a>
<a name="16291"><span class="lineNum">   16291 </span><span class="lineNoCov">          0 :      string qualifier = setNameQualificationSupport(scope,amountOfNameQualificationRequired, outputNameQualificationLength, outputGlobalQualification, outputTypeEvaluation);</span></a>
<a name="16292"><span class="lineNum">   16292 </span>            : </a>
<a name="16293"><span class="lineNum">   16293 </span><span class="lineNoCov">          0 :      typedefDeclaration-&gt;set_global_qualification_required(outputGlobalQualification);</span></a>
<a name="16294"><span class="lineNum">   16294 </span><span class="lineNoCov">          0 :      typedefDeclaration-&gt;set_name_qualification_length(outputNameQualificationLength);</span></a>
<a name="16295"><span class="lineNum">   16295 </span><span class="lineNoCov">          0 :      typedefDeclaration-&gt;set_type_elaboration_required(outputTypeEvaluation);</span></a>
<a name="16296"><span class="lineNum">   16296 </span>            : </a>
<a name="16297"><span class="lineNum">   16297 </span>            :   // There should be no type evaluation required for a variable reference, as I recall.</a>
<a name="16298"><span class="lineNum">   16298 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(outputTypeEvaluation == false);</span></a>
<a name="16299"><span class="lineNum">   16299 </span>            : </a>
<a name="16300"><span class="lineNum">   16300 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="16301"><span class="lineNum">   16301 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualificationOnPointerMemberClass(): typedefDeclaration-&gt;get_name_qualification_length()     = %d \n&quot;,typedefDeclaration-&gt;get_name_qualification_length());</a>
<a name="16302"><span class="lineNum">   16302 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualificationOnPointerMemberClass(): typedefDeclaration-&gt;get_type_elaboration_required()     = %s \n&quot;,typedefDeclaration-&gt;get_type_elaboration_required() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="16303"><span class="lineNum">   16303 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualificationOnPointerMemberClass(): typedefDeclaration-&gt;get_global_qualification_required() = %s \n&quot;,typedefDeclaration-&gt;get_global_qualification_required() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="16304"><span class="lineNum">   16304 </span>            : #endif</a>
<a name="16305"><span class="lineNum">   16305 </span>            : </a>
<a name="16306"><span class="lineNum">   16306 </span><span class="lineNoCov">          0 :      if (qualifiedNameMapForNames.find(typedefDeclaration) == qualifiedNameMapForNames.end())</span></a>
<a name="16307"><span class="lineNum">   16307 </span>            :         {</a>
<a name="16308"><span class="lineNum">   16308 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="16309"><span class="lineNum">   16309 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Inserting qualifier for type = %s into list at IR node = %p = %s \n&quot;,qualifier.c_str(),typedefDeclaration,typedefDeclaration-&gt;class_name().c_str());</a>
<a name="16310"><span class="lineNum">   16310 </span>            : #endif</a>
<a name="16311"><span class="lineNum">   16311 </span>            :        // qualifiedNameMapForTypes.insert(std::pair&lt;SgNode*,std::string&gt;(typedefDeclaration,qualifier));</a>
<a name="16312"><span class="lineNum">   16312 </span><span class="lineNoCov">          0 :           qualifiedNameMapForNames.insert(std::pair&lt;SgNode*,std::string&gt;(typedefDeclaration,qualifier));</span></a>
<a name="16313"><span class="lineNum">   16313 </span>            :         }</a>
<a name="16314"><span class="lineNum">   16314 </span>            :        else</a>
<a name="16315"><span class="lineNum">   16315 </span>            :         {</a>
<a name="16316"><span class="lineNum">   16316 </span>            :        // If it already existes then overwrite the existing information.</a>
<a name="16317"><span class="lineNum">   16317 </span>            :        // std::map&lt;SgNode*,std::string&gt;::iterator i = qualifiedNameMapForTypes.find(typedefDeclaration);</a>
<a name="16318"><span class="lineNum">   16318 </span>            :        // ROSE_ASSERT (i != qualifiedNameMapForTypes.end());</a>
<a name="16319"><span class="lineNum">   16319 </span><span class="lineNoCov">          0 :           std::map&lt;SgNode*,std::string&gt;::iterator i = qualifiedNameMapForNames.find(typedefDeclaration);</span></a>
<a name="16320"><span class="lineNum">   16320 </span><span class="lineNoCov">          0 :           ROSE_ASSERT (i != qualifiedNameMapForNames.end());</span></a>
<a name="16321"><span class="lineNum">   16321 </span>            : </a>
<a name="16322"><span class="lineNum">   16322 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="16323"><span class="lineNum">   16323 </span>            :           string previousQualifier = i-&gt;second.c_str();</a>
<a name="16324"><span class="lineNum">   16324 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;WARNING: test 16: replacing previousQualifier = %s with new qualifier = %s \n&quot;,previousQualifier.c_str(),qualifier.c_str());</a>
<a name="16325"><span class="lineNum">   16325 </span>            : #endif</a>
<a name="16326"><span class="lineNum">   16326 </span>            :        // I think I can do this!</a>
<a name="16327"><span class="lineNum">   16327 </span>            :        // *i = std::pair&lt;SgNode*,std::string&gt;(templateArgument,qualifier);</a>
<a name="16328"><span class="lineNum">   16328 </span><span class="lineNoCov">          0 :           if (i-&gt;second != qualifier)</span></a>
<a name="16329"><span class="lineNum">   16329 </span>            :              {</a>
<a name="16330"><span class="lineNum">   16330 </span><span class="lineNoCov">          0 :                i-&gt;second = qualifier;</span></a>
<a name="16331"><span class="lineNum">   16331 </span>            : </a>
<a name="16332"><span class="lineNum">   16332 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="16333"><span class="lineNum">   16333 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;WARNING: name in qualifiedNameMap already exists and is different... \n&quot;);</a>
<a name="16334"><span class="lineNum">   16334 </span>            :             // ROSE_ASSERT(false);</a>
<a name="16335"><span class="lineNum">   16335 </span>            : </a>
<a name="16336"><span class="lineNum">   16336 </span>            :                SgName testNameInMap = typedefDeclaration-&gt;get_qualified_name_prefix();</a>
<a name="16337"><span class="lineNum">   16337 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;testNameInMap = %s \n&quot;,testNameInMap.str());</a>
<a name="16338"><span class="lineNum">   16338 </span>            : #endif</a>
<a name="16339"><span class="lineNum">   16339 </span>            :              }</a>
<a name="16340"><span class="lineNum">   16340 </span>            : #if 0</a>
<a name="16341"><span class="lineNum">   16341 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Error: name in qualifiedNameMapForTypes already exists... \n&quot;);</a>
<a name="16342"><span class="lineNum">   16342 </span>            :           ROSE_ABORT();</a>
<a name="16343"><span class="lineNum">   16343 </span>            : #endif</a>
<a name="16344"><span class="lineNum">   16344 </span>            :         }</a>
<a name="16345"><span class="lineNum">   16345 </span><span class="lineNoCov">          0 :    }</span></a>
<a name="16346"><span class="lineNum">   16346 </span>            : </a>
<a name="16347"><span class="lineNum">   16347 </span>            : </a>
<a name="16348"><span class="lineNum">   16348 </span>            : void</a>
<a name="16349"><span class="lineNum">   16349 </span><span class="lineCov">      91744 : NameQualificationTraversal::setNameQualification(SgTemplateArgument* templateArgument, SgDeclarationStatement* declaration, int amountOfNameQualificationRequired)</span></a>
<a name="16350"><span class="lineNum">   16350 </span>            :    {</a>
<a name="16351"><span class="lineNum">   16351 </span>            :   // This function will generate the qualified name prefix (without the name of the declaration) and add it to</a>
<a name="16352"><span class="lineNum">   16352 </span>            :   // the map of name qualification strings referenced via the IR node that references the SgTemplateArgument.</a>
<a name="16353"><span class="lineNum">   16353 </span>            : </a>
<a name="16354"><span class="lineNum">   16354 </span>            :   // DQ (6/1/2011): Note that the name qualification could be more complex than this function presently supports.</a>
<a name="16355"><span class="lineNum">   16355 </span>            :   // The use of derivation can permit there to be multiple legal qualified names for a single construct.  There</a>
<a name="16356"><span class="lineNum">   16356 </span>            :   // could also be some qualified names using using type names that are private or protected and thus can only</a>
<a name="16357"><span class="lineNum">   16357 </span>            :   // be used in restricted contexts.  This sumbject of multiple qualified names or selecting amongst them for</a>
<a name="16358"><span class="lineNum">   16358 </span>            :   // where each may be used is not handled presently.</a>
<a name="16359"><span class="lineNum">   16359 </span>            : </a>
<a name="16360"><span class="lineNum">   16360 </span>            :   // DQ (9/23/2012): Note that the template arguments of the defining declaration don't appear to be set (only for</a>
<a name="16361"><span class="lineNum">   16361 </span>            :   // the nondefining declaration).  This was a problem for test2012_220.C.  The fix was to make sure that the</a>
<a name="16362"><span class="lineNum">   16362 </span>            :   // unparsing of the SgClassType consistantly uses the nondefining declaration, and it's template arguments.</a>
<a name="16363"><span class="lineNum">   16363 </span>            : </a>
<a name="16364"><span class="lineNum">   16364 </span>            :   // Setup call to refactored code.</a>
<a name="16365"><span class="lineNum">   16365 </span><span class="lineCov">      91744 :      int  outputNameQualificationLength = 0;</span></a>
<a name="16366"><span class="lineNum">   16366 </span><span class="lineCov">      91744 :      bool outputGlobalQualification     = false;</span></a>
<a name="16367"><span class="lineNum">   16367 </span><span class="lineCov">      91744 :      bool outputTypeEvaluation          = false;</span></a>
<a name="16368"><span class="lineNum">   16368 </span>            : </a>
<a name="16369"><span class="lineNum">   16369 </span>            : #define DEBUG_TEMPLATE_ARGUMENT_NAME_QUALIFICATION 0</a>
<a name="16370"><span class="lineNum">   16370 </span>            : </a>
<a name="16371"><span class="lineNum">   16371 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || DEBUG_TEMPLATE_ARGUMENT_NAME_QUALIFICATION</a>
<a name="16372"><span class="lineNum">   16372 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In setNameQualification(SgTemplateArgument*) \n&quot;);</a>
<a name="16373"><span class="lineNum">   16373 </span>            : #endif</a>
<a name="16374"><span class="lineNum">   16374 </span>            : </a>
<a name="16375"><span class="lineNum">   16375 </span><span class="lineCov">      91744 :      SgScopeStatement * scope = traverseNonrealDeclForCorrectScope(declaration);</span></a>
<a name="16376"><span class="lineNum">   16376 </span><span class="lineCov">      91744 :      string qualifier = setNameQualificationSupport(scope,amountOfNameQualificationRequired, outputNameQualificationLength, outputGlobalQualification, outputTypeEvaluation);</span></a>
<a name="16377"><span class="lineNum">   16377 </span>            : </a>
<a name="16378"><span class="lineNum">   16378 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || DEBUG_TEMPLATE_ARGUMENT_NAME_QUALIFICATION</a>
<a name="16379"><span class="lineNum">   16379 </span>            :      mfprintf(mlog [ WARN ] ) (&quot; - qualifier = %s\n&quot;, qualifier.c_str());</a>
<a name="16380"><span class="lineNum">   16380 </span>            : #endif</a>
<a name="16381"><span class="lineNum">   16381 </span>            : </a>
<a name="16382"><span class="lineNum">   16382 </span>            :   // These may not be important under the newest version of name qualification that uses the qualified</a>
<a name="16383"><span class="lineNum">   16383 </span>            :   // name string map to IR nodes that reference the construct using the name qualification.</a>
<a name="16384"><span class="lineNum">   16384 </span><span class="lineCov">      91744 :      templateArgument-&gt;set_global_qualification_required(outputGlobalQualification);</span></a>
<a name="16385"><span class="lineNum">   16385 </span><span class="lineCov">      91744 :      templateArgument-&gt;set_name_qualification_length(outputNameQualificationLength);</span></a>
<a name="16386"><span class="lineNum">   16386 </span><span class="lineCov">      91744 :      templateArgument-&gt;set_type_elaboration_required(outputTypeEvaluation);</span></a>
<a name="16387"><span class="lineNum">   16387 </span>            : </a>
<a name="16388"><span class="lineNum">   16388 </span>            :   // There should be no type evaluation required for a variable reference, as I recall.</a>
<a name="16389"><span class="lineNum">   16389 </span><span class="lineCov">      91744 :      ROSE_ASSERT(outputTypeEvaluation == false);</span></a>
<a name="16390"><span class="lineNum">   16390 </span>            : </a>
<a name="16391"><span class="lineNum">   16391 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || DEBUG_TEMPLATE_ARGUMENT_NAME_QUALIFICATION</a>
<a name="16392"><span class="lineNum">   16392 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): templateArgument                                      = %p \n&quot;,templateArgument);</a>
<a name="16393"><span class="lineNum">   16393 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): templateArgument-&gt;get_name_qualification_length()     = %d \n&quot;,templateArgument-&gt;get_name_qualification_length());</a>
<a name="16394"><span class="lineNum">   16394 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): templateArgument-&gt;get_type_elaboration_required()     = %s \n&quot;,templateArgument-&gt;get_type_elaboration_required() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="16395"><span class="lineNum">   16395 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): templateArgument-&gt;get_global_qualification_required() = %s \n&quot;,templateArgument-&gt;get_global_qualification_required() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="16396"><span class="lineNum">   16396 </span>            : #endif</a>
<a name="16397"><span class="lineNum">   16397 </span>            : </a>
<a name="16398"><span class="lineNum">   16398 </span>            :   // DQ (9/25/2012): The code below is more complex than I would like because it has to set the name qualification</a>
<a name="16399"><span class="lineNum">   16399 </span>            :   // on both the template arguments of the defining and nondefining declarations.</a>
<a name="16400"><span class="lineNum">   16400 </span>            : </a>
<a name="16401"><span class="lineNum">   16401 </span>            :   // DQ (9/22/2012): This is the bug to fix tomorrow morning...</a>
<a name="16402"><span class="lineNum">   16402 </span>            :   // XXX:  Either we should be setting the name_qualification_length on the SgTemplateArgument for the defining declaration (as well as the (first?) nondefining declaration)</a>
<a name="16403"><span class="lineNum">   16403 </span>            :   //       or we should be sharing the SgTemplateArgument across both the non-defining and defining declarations.</a>
<a name="16404"><span class="lineNum">   16404 </span>            :   //       I think I would like to share the SgTemplateArgument (this this problem would take care of itself).</a>
<a name="16405"><span class="lineNum">   16405 </span>            : </a>
<a name="16406"><span class="lineNum">   16406 </span>            :   // TV (04/04/2018): Look for matching defining template argument.</a>
<a name="16407"><span class="lineNum">   16407 </span>            :   // For non-real template instantiation, i.e. member of a template parameter: &quot;T0::template T1&lt;A&gt;&quot;, the template argument</a>
<a name="16408"><span class="lineNum">   16408 </span>            :   // (&quot;A&quot;) parent is the global scope (FIXME or is it the scope of the template parameter (&quot;T0&quot;)??? FIXME)</a>
<a name="16409"><span class="lineNum">   16409 </span><span class="lineCov">      91744 :      SgTemplateArgument* defining_templateArgument = NULL;</span></a>
<a name="16410"><span class="lineNum">   16410 </span><span class="lineCov">      91744 :      SgNode * tpl_arg_parent = templateArgument-&gt;get_parent();</span></a>
<a name="16411"><span class="lineNum">   16411 </span>            : </a>
<a name="16412"><span class="lineNum">   16412 </span>            : #if DEBUG_TEMPLATE_ARGUMENT_NAME_QUALIFICATION</a>
<a name="16413"><span class="lineNum">   16413 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;tpl_arg_parent = %p = %s \n&quot;, tpl_arg_parent, tpl_arg_parent ? tpl_arg_parent-&gt;class_name().c_str() : &quot;&quot;);</a>
<a name="16414"><span class="lineNum">   16414 </span>            : #endif</a>
<a name="16415"><span class="lineNum">   16415 </span>            : </a>
<a name="16416"><span class="lineNum">   16416 </span><span class="lineCov">      91744 :      ASSERT_not_null(tpl_arg_parent);</span></a>
<a name="16417"><span class="lineNum">   16417 </span>            : </a>
<a name="16418"><span class="lineNum">   16418 </span><span class="lineCov">      91744 :      SgDeclarationStatement* associatedDeclaration = isSgDeclarationStatement(tpl_arg_parent);</span></a>
<a name="16419"><span class="lineNum">   16419 </span><span class="lineCov">      91744 :      if (associatedDeclaration != NULL)</span></a>
<a name="16420"><span class="lineNum">   16420 </span>            :         {</a>
<a name="16421"><span class="lineNum">   16421 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="16422"><span class="lineNum">   16422 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;associatedDeclaration = %p = %s \n&quot;,associatedDeclaration,associatedDeclaration-&gt;class_name().c_str());</a>
<a name="16423"><span class="lineNum">   16423 </span>            : #endif</a>
<a name="16424"><span class="lineNum">   16424 </span><span class="lineCov">      87630 :           SgDeclarationStatement* firstNondefining_associatedDeclaration = associatedDeclaration-&gt;get_firstNondefiningDeclaration();</span></a>
<a name="16425"><span class="lineNum">   16425 </span><span class="lineCov">      87630 :           SgDeclarationStatement* defining_associatedDeclaration         = associatedDeclaration-&gt;get_definingDeclaration();</span></a>
<a name="16426"><span class="lineNum">   16426 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="16427"><span class="lineNum">   16427 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;firstNondefining_associatedDeclaration = %p \n&quot;,firstNondefining_associatedDeclaration);</a>
<a name="16428"><span class="lineNum">   16428 </span>            : #endif</a>
<a name="16429"><span class="lineNum">   16429 </span><span class="lineCov">      87630 :           SgTemplateInstantiationDecl* firstDefining_classTemplateInstantiationDeclaration = isSgTemplateInstantiationDecl(firstNondefining_associatedDeclaration);</span></a>
<a name="16430"><span class="lineNum">   16430 </span>            : </a>
<a name="16431"><span class="lineNum">   16431 </span>            :        // SgTemplateArgument* nondefining_templateArgument = templateArgument;</a>
<a name="16432"><span class="lineNum">   16432 </span>            : </a>
<a name="16433"><span class="lineNum">   16433 </span><span class="lineCov">      87630 :           int nondefiningDeclaration_templateArgument_position = 0;</span></a>
<a name="16434"><span class="lineNum">   16434 </span><span class="lineCov">      87630 :           int definingDeclaration_templateArgument_position    = 0;</span></a>
<a name="16435"><span class="lineNum">   16435 </span>            : </a>
<a name="16436"><span class="lineNum">   16436 </span><span class="lineCov">      87630 :           bool found = false;</span></a>
<a name="16437"><span class="lineNum">   16437 </span><span class="lineCov">      87630 :           if (firstDefining_classTemplateInstantiationDeclaration != NULL)</span></a>
<a name="16438"><span class="lineNum">   16438 </span>            :              {</a>
<a name="16439"><span class="lineNum">   16439 </span>            :             // Find the index position of the current template argument.</a>
<a name="16440"><span class="lineNum">   16440 </span><span class="lineCov">      82584 :                SgTemplateArgumentPtrList &amp; l = firstDefining_classTemplateInstantiationDeclaration-&gt;get_templateArguments();</span></a>
<a name="16441"><span class="lineNum">   16441 </span><span class="lineCov">     282029 :                for (SgTemplateArgumentPtrList::iterator i = l.begin(); i != l.end(); i++)</span></a>
<a name="16442"><span class="lineNum">   16442 </span>            :                   {</a>
<a name="16443"><span class="lineNum">   16443 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="16444"><span class="lineNum">   16444 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;--- template argument = %p = %s \n&quot;,*i,(*i)-&gt;class_name().c_str());</a>
<a name="16445"><span class="lineNum">   16445 </span>            : #endif</a>
<a name="16446"><span class="lineNum">   16446 </span><span class="lineCov">     199445 :                     if (found == false)</span></a>
<a name="16447"><span class="lineNum">   16447 </span>            :                        {</a>
<a name="16448"><span class="lineNum">   16448 </span><span class="lineCov">     173021 :                          if (*i == templateArgument)</span></a>
<a name="16449"><span class="lineNum">   16449 </span>            :                               found = true;</a>
<a name="16450"><span class="lineNum">   16450 </span>            :                            else</a>
<a name="16451"><span class="lineNum">   16451 </span><span class="lineCov">     106433 :                               nondefiningDeclaration_templateArgument_position++;</span></a>
<a name="16452"><span class="lineNum">   16452 </span>            :                        }</a>
<a name="16453"><span class="lineNum">   16453 </span>            :                   }</a>
<a name="16454"><span class="lineNum">   16454 </span>            :              }</a>
<a name="16455"><span class="lineNum">   16455 </span>            : </a>
<a name="16456"><span class="lineNum">   16456 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="16457"><span class="lineNum">   16457 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;defining_associatedDeclaration                   = %p \n&quot;,defining_associatedDeclaration);</a>
<a name="16458"><span class="lineNum">   16458 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;nondefiningDeclaration_templateArgument_position = %d \n&quot;,nondefiningDeclaration_templateArgument_position);</a>
<a name="16459"><span class="lineNum">   16459 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;definingDeclaration_templateArgument_position    = %d \n&quot;,definingDeclaration_templateArgument_position);</a>
<a name="16460"><span class="lineNum">   16460 </span>            : #endif</a>
<a name="16461"><span class="lineNum">   16461 </span>            : </a>
<a name="16462"><span class="lineNum">   16462 </span><span class="lineCov">      87630 :           SgTemplateInstantiationDecl* defining_classTemplateInstantiationDeclaration      = isSgTemplateInstantiationDecl(defining_associatedDeclaration);</span></a>
<a name="16463"><span class="lineNum">   16463 </span><span class="lineCov">      87630 :           if (defining_classTemplateInstantiationDeclaration != NULL)</span></a>
<a name="16464"><span class="lineNum">   16464 </span>            :              {</a>
<a name="16465"><span class="lineNum">   16465 </span>            :             // Find the associated template argument (matching position) in the template argument list of the defining declaration.</a>
<a name="16466"><span class="lineNum">   16466 </span>            : #if 0</a>
<a name="16467"><span class="lineNum">   16467 </span>            :             // This is simpler code (but it causes some sort of error in the stack).</a>
<a name="16468"><span class="lineNum">   16468 </span>            :                defining_templateArgument = defining_classTemplateInstantiationDeclaration-&gt;get_templateArguments()[nondefiningDeclaration_templateArgument_position];</a>
<a name="16469"><span class="lineNum">   16469 </span>            : #else</a>
<a name="16470"><span class="lineNum">   16470 </span>            :             // This code is better tested and works well.</a>
<a name="16471"><span class="lineNum">   16471 </span><span class="lineCov">      77565 :                SgTemplateArgumentPtrList &amp; l = defining_classTemplateInstantiationDeclaration-&gt;get_templateArguments();</span></a>
<a name="16472"><span class="lineNum">   16472 </span><span class="lineCov">     265736 :                for (SgTemplateArgumentPtrList::iterator i = l.begin(); i != l.end(); i++)</span></a>
<a name="16473"><span class="lineNum">   16473 </span>            :                   {</a>
<a name="16474"><span class="lineNum">   16474 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="16475"><span class="lineNum">   16475 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;--- template argument = %p = %s \n&quot;,*i,(*i)-&gt;class_name().c_str());</a>
<a name="16476"><span class="lineNum">   16476 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;In loop: nondefiningDeclaration_templateArgument_position = %d \n&quot;,nondefiningDeclaration_templateArgument_position);</a>
<a name="16477"><span class="lineNum">   16477 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;In loop: definingDeclaration_templateArgument_position    = %d \n&quot;,definingDeclaration_templateArgument_position);</a>
<a name="16478"><span class="lineNum">   16478 </span>            : #endif</a>
<a name="16479"><span class="lineNum">   16479 </span><span class="lineCov">     188171 :                     if (definingDeclaration_templateArgument_position == nondefiningDeclaration_templateArgument_position)</span></a>
<a name="16480"><span class="lineNum">   16480 </span>            :                        {</a>
<a name="16481"><span class="lineNum">   16481 </span>            :                       // This is the template argument in the coresponding defining declaration.</a>
<a name="16482"><span class="lineNum">   16482 </span><span class="lineCov">      61601 :                          defining_templateArgument = *i;</span></a>
<a name="16483"><span class="lineNum">   16483 </span>            :                        }</a>
<a name="16484"><span class="lineNum">   16484 </span>            : </a>
<a name="16485"><span class="lineNum">   16485 </span><span class="lineCov">     188171 :                     definingDeclaration_templateArgument_position++;</span></a>
<a name="16486"><span class="lineNum">   16486 </span>            :                   }</a>
<a name="16487"><span class="lineNum">   16487 </span>            : #endif</a>
<a name="16488"><span class="lineNum">   16488 </span>            : </a>
<a name="16489"><span class="lineNum">   16489 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="16490"><span class="lineNum">   16490 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;defining_templateArgument = %p \n&quot;,defining_templateArgument);</a>
<a name="16491"><span class="lineNum">   16491 </span>            : #endif</a>
<a name="16492"><span class="lineNum">   16492 </span>            : </a>
<a name="16493"><span class="lineNum">   16493 </span>            :             // This is false when the template arguments are shared (which appears to happen sometimes, see test2004_38.C).</a>
<a name="16494"><span class="lineNum">   16494 </span>            :             // ASSERT_not_null(defining_templateArgument);</a>
<a name="16495"><span class="lineNum">   16495 </span>            :             // if (defining_templateArgument != NULL)</a>
<a name="16496"><span class="lineNum">   16496 </span><span class="lineCov">      77565 :                if (defining_templateArgument != NULL &amp;&amp; defining_templateArgument != templateArgument)</span></a>
<a name="16497"><span class="lineNum">   16497 </span>            :                   {</a>
<a name="16498"><span class="lineNum">   16498 </span>            :                  // Mark the associated template argument in the defining declaration so that it can be output with qualification (see test2012_220.C).</a>
<a name="16499"><span class="lineNum">   16499 </span><span class="lineCov">      33415 :                     defining_templateArgument-&gt;set_global_qualification_required(outputGlobalQualification);</span></a>
<a name="16500"><span class="lineNum">   16500 </span><span class="lineCov">      33415 :                     defining_templateArgument-&gt;set_name_qualification_length(outputNameQualificationLength);</span></a>
<a name="16501"><span class="lineNum">   16501 </span><span class="lineCov">      33415 :                     defining_templateArgument-&gt;set_type_elaboration_required(outputTypeEvaluation);</span></a>
<a name="16502"><span class="lineNum">   16502 </span>            : </a>
<a name="16503"><span class="lineNum">   16503 </span>            :                  // DQ (9/24/2012): Make sure these are different.</a>
<a name="16504"><span class="lineNum">   16504 </span><span class="lineCov">      91744 :                     ROSE_ASSERT(defining_templateArgument != templateArgument);</span></a>
<a name="16505"><span class="lineNum">   16505 </span>            :                   }</a>
<a name="16506"><span class="lineNum">   16506 </span>            :              }</a>
<a name="16507"><span class="lineNum">   16507 </span>            :         }</a>
<a name="16508"><span class="lineNum">   16508 </span>            :        else</a>
<a name="16509"><span class="lineNum">   16509 </span>            :         {</a>
<a name="16510"><span class="lineNum">   16510 </span>            : #if 0</a>
<a name="16511"><span class="lineNum">   16511 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \n&quot;);</a>
<a name="16512"><span class="lineNum">   16512 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;NOTE: associatedDeclaration == NULL \n&quot;);</a>
<a name="16513"><span class="lineNum">   16513 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \n&quot;);</a>
<a name="16514"><span class="lineNum">   16514 </span>            : #endif</a>
<a name="16515"><span class="lineNum">   16515 </span>            : #if 0</a>
<a name="16516"><span class="lineNum">   16516 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="16517"><span class="lineNum">   16517 </span>            :           ROSE_ABORT();</a>
<a name="16518"><span class="lineNum">   16518 </span>            : #endif</a>
<a name="16519"><span class="lineNum">   16519 </span>            :         }</a>
<a name="16520"><span class="lineNum">   16520 </span>            : </a>
<a name="16521"><span class="lineNum">   16521 </span>            : #if 0</a>
<a name="16522"><span class="lineNum">   16522 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;#################### defining_templateArgument = %p templateArgument = %p qualifier = %s \n&quot;,defining_templateArgument,templateArgument,qualifier.c_str());</a>
<a name="16523"><span class="lineNum">   16523 </span>            : </a>
<a name="16524"><span class="lineNum">   16524 </span>            :   // DQ (5/29/2019): When this is violated, then we will put the name qualification string into the map using the wrong key.</a>
<a name="16525"><span class="lineNum">   16525 </span>            :      if (defining_templateArgument != NULL &amp;&amp; (defining_templateArgument != templateArgument) )</a>
<a name="16526"><span class="lineNum">   16526 </span>            :         {</a>
<a name="16527"><span class="lineNum">   16527 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;CASE OF defining_templateArgument != NULL &amp;&amp; (defining_templateArgument != templateArgument) FOUND! \n&quot;);</a>
<a name="16528"><span class="lineNum">   16528 </span>            :         }</a>
<a name="16529"><span class="lineNum">   16529 </span>            :   // ROSE_ASSERT(defining_templateArgument == NULL || (defining_templateArgument != NULL &amp;&amp; defining_templateArgument == templateArgument) );</a>
<a name="16530"><span class="lineNum">   16530 </span>            : #endif</a>
<a name="16531"><span class="lineNum">   16531 </span>            : </a>
<a name="16532"><span class="lineNum">   16532 </span>            :   // Look for the template argument in the IR node map and either reset it or add it to the map.</a>
<a name="16533"><span class="lineNum">   16533 </span>            :   // The support for the template argument from the defining declaration makes this a bit more</a>
<a name="16534"><span class="lineNum">   16534 </span>            :   // complex, but both are set to always be the same (since we will prefer to use that from the</a>
<a name="16535"><span class="lineNum">   16535 </span>            :   // defining declaration in the unparsing).  Note that the preference for the defining declaration</a>
<a name="16536"><span class="lineNum">   16536 </span>            :   // use in the unparsing comes from supporting the corner case of type declarations nested in</a>
<a name="16537"><span class="lineNum">   16537 </span>            :   // other declarations; e.g. &quot;struct X { int a; } Y;&quot; where the declaration of the type &quot;X&quot; is</a>
<a name="16538"><span class="lineNum">   16538 </span>            :   // nested in the declaration of the variable &quot;Y&quot; (there are several different forms of this).</a>
<a name="16539"><span class="lineNum">   16539 </span><span class="lineCov">     183488 :      if (qualifiedNameMapForTypes.find(templateArgument) == qualifiedNameMapForTypes.end())</span></a>
<a name="16540"><span class="lineNum">   16540 </span>            :         {</a>
<a name="16541"><span class="lineNum">   16541 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="16542"><span class="lineNum">   16542 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Inserting qualifier for name or type = %s into list at IR node = %p = %s \n&quot;,qualifier.c_str(),templateArgument,templateArgument-&gt;class_name().c_str());</a>
<a name="16543"><span class="lineNum">   16543 </span>            : #endif</a>
<a name="16544"><span class="lineNum">   16544 </span>            : #if 0</a>
<a name="16545"><span class="lineNum">   16545 </span>            :           qualifier = string(&quot;/* initialized */ &quot;) + qualifier;</a>
<a name="16546"><span class="lineNum">   16546 </span>            : #endif</a>
<a name="16547"><span class="lineNum">   16547 </span><span class="lineCov">      16352 :           qualifiedNameMapForTypes.insert(std::pair&lt;SgNode*,std::string&gt;(templateArgument,qualifier));</span></a>
<a name="16548"><span class="lineNum">   16548 </span>            : </a>
<a name="16549"><span class="lineNum">   16549 </span>            :        // Handle the defining declaration's template argument.</a>
<a name="16550"><span class="lineNum">   16550 </span>            :        // if (defining_templateArgument != NULL)</a>
<a name="16551"><span class="lineNum">   16551 </span><span class="lineCov">       8176 :           if (defining_templateArgument != NULL &amp;&amp; defining_templateArgument != templateArgument)</span></a>
<a name="16552"><span class="lineNum">   16552 </span>            :              {</a>
<a name="16553"><span class="lineNum">   16553 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="16554"><span class="lineNum">   16554 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Insert qualified name = %s for defining_templateArgument = %p \n&quot;,qualifier.c_str(),defining_templateArgument);</a>
<a name="16555"><span class="lineNum">   16555 </span>            : #endif</a>
<a name="16556"><span class="lineNum">   16556 </span><span class="lineCov">       3008 :                qualifiedNameMapForTypes.insert(std::pair&lt;SgNode*,std::string&gt;(defining_templateArgument,qualifier));</span></a>
<a name="16557"><span class="lineNum">   16557 </span>            :              }</a>
<a name="16558"><span class="lineNum">   16558 </span>            :             else</a>
<a name="16559"><span class="lineNum">   16559 </span>            :              {</a>
<a name="16560"><span class="lineNum">   16560 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="16561"><span class="lineNum">   16561 </span>            :                 mfprintf(mlog [ WARN ] ) (&quot;NOTE: defining_templateArgument != NULL &amp;&amp; defining_templateArgument != templateArgument (qualified not inserted into qualifiedNameMapForTypes using defining_templateArgument = %p \n&quot;,defining_templateArgument);</a>
<a name="16562"><span class="lineNum">   16562 </span>            : #endif</a>
<a name="16563"><span class="lineNum">   16563 </span>            :              }</a>
<a name="16564"><span class="lineNum">   16564 </span>            :         }</a>
<a name="16565"><span class="lineNum">   16565 </span>            :        else</a>
<a name="16566"><span class="lineNum">   16566 </span>            :         {</a>
<a name="16567"><span class="lineNum">   16567 </span>            :        // If it already existes then overwrite the existing information.</a>
<a name="16568"><span class="lineNum">   16568 </span><span class="lineCov">    1629380 :           std::map&lt;SgNode*,std::string&gt;::iterator i = qualifiedNameMapForTypes.find(templateArgument);</span></a>
<a name="16569"><span class="lineNum">   16569 </span><span class="lineCov">      83568 :           ROSE_ASSERT (i != qualifiedNameMapForTypes.end());</span></a>
<a name="16570"><span class="lineNum">   16570 </span>            : </a>
<a name="16571"><span class="lineNum">   16571 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="16572"><span class="lineNum">   16572 </span>            :           string previousQualifier = i-&gt;second.c_str();</a>
<a name="16573"><span class="lineNum">   16573 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;WARNING: test 17: for templateArgument = %p replacing previousQualifier = %s with new qualifier = %s \n&quot;,templateArgument,previousQualifier.c_str(),qualifier.c_str());</a>
<a name="16574"><span class="lineNum">   16574 </span>            : #endif</a>
<a name="16575"><span class="lineNum">   16575 </span>            :        // I think I can do this!</a>
<a name="16576"><span class="lineNum">   16576 </span>            :        // *i = std::pair&lt;SgNode*,std::string&gt;(templateArgument,qualifier);</a>
<a name="16577"><span class="lineNum">   16577 </span><span class="lineCov">      83568 :           if (i-&gt;second != qualifier)</span></a>
<a name="16578"><span class="lineNum">   16578 </span>            :              {</a>
<a name="16579"><span class="lineNum">   16579 </span>            : #if 0</a>
<a name="16580"><span class="lineNum">   16580 </span>            :                qualifier = string(&quot;/* replaced */ &quot;) + qualifier;</a>
<a name="16581"><span class="lineNum">   16581 </span>            : #endif</a>
<a name="16582"><span class="lineNum">   16582 </span><span class="lineCov">       5795 :                i-&gt;second = qualifier;</span></a>
<a name="16583"><span class="lineNum">   16583 </span>            : </a>
<a name="16584"><span class="lineNum">   16584 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="16585"><span class="lineNum">   16585 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;WARNING: name in qualifiedNameMapForTypes already exists and is different... \n&quot;);</a>
<a name="16586"><span class="lineNum">   16586 </span>            :             // ROSE_ASSERT(false);</a>
<a name="16587"><span class="lineNum">   16587 </span>            : #endif</a>
<a name="16588"><span class="lineNum">   16588 </span>            : </a>
<a name="16589"><span class="lineNum">   16589 </span><span class="lineCov">      11590 :                SgName testNameInMap = templateArgument-&gt;get_qualified_name_prefix();</span></a>
<a name="16590"><span class="lineNum">   16590 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="16591"><span class="lineNum">   16591 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;testNameInMap = %s \n&quot;,testNameInMap.str());</a>
<a name="16592"><span class="lineNum">   16592 </span>            : #endif</a>
<a name="16593"><span class="lineNum">   16593 </span>            : </a>
<a name="16594"><span class="lineNum">   16594 </span>            :             // DQ (9/24/2012): Check that the defining declaration's template argument is uniformally set.</a>
<a name="16595"><span class="lineNum">   16595 </span>            :             // if (defining_templateArgument != NULL)</a>
<a name="16596"><span class="lineNum">   16596 </span><span class="lineCov">       5795 :                if (defining_templateArgument != NULL &amp;&amp; defining_templateArgument != templateArgument)</span></a>
<a name="16597"><span class="lineNum">   16597 </span>            :                   {</a>
<a name="16598"><span class="lineNum">   16598 </span><span class="lineCov">       1766 :                     ROSE_ASSERT(qualifiedNameMapForTypes.find(defining_templateArgument) != qualifiedNameMapForTypes.end());</span></a>
<a name="16599"><span class="lineNum">   16599 </span><span class="lineCov">        883 :                     std::map&lt;SgNode*,std::string&gt;::iterator j = qualifiedNameMapForTypes.find(defining_templateArgument);</span></a>
<a name="16600"><span class="lineNum">   16600 </span><span class="lineCov">        883 :                     ROSE_ASSERT (j != qualifiedNameMapForTypes.end());</span></a>
<a name="16601"><span class="lineNum">   16601 </span>            : </a>
<a name="16602"><span class="lineNum">   16602 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="16603"><span class="lineNum">   16603 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;For defining_templateArgument = %p j-&gt;second = %s qualifier = %s \n&quot;,defining_templateArgument,j-&gt;second.c_str(),qualifier.c_str());</a>
<a name="16604"><span class="lineNum">   16604 </span>            : #endif</a>
<a name="16605"><span class="lineNum">   16605 </span>            :                  // ROSE_ASSERT(j-&gt;second != qualifier);</a>
<a name="16606"><span class="lineNum">   16606 </span>            : </a>
<a name="16607"><span class="lineNum">   16607 </span><span class="lineCov">        883 :                     if (j-&gt;second != qualifier)</span></a>
<a name="16608"><span class="lineNum">   16608 </span>            :                        {</a>
<a name="16609"><span class="lineNum">   16609 </span><span class="lineCov">        731 :                          j-&gt;second = qualifier;</span></a>
<a name="16610"><span class="lineNum">   16610 </span>            :                        }</a>
<a name="16611"><span class="lineNum">   16611 </span>            : </a>
<a name="16612"><span class="lineNum">   16612 </span><span class="lineCov">       1766 :                     SgName defining_testNameInMap = defining_templateArgument-&gt;get_qualified_name_prefix();</span></a>
<a name="16613"><span class="lineNum">   16613 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="16614"><span class="lineNum">   16614 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;defining_testNameInMap = %s \n&quot;,defining_testNameInMap.str());</a>
<a name="16615"><span class="lineNum">   16615 </span>            : #endif</a>
<a name="16616"><span class="lineNum">   16616 </span><span class="lineCov">        883 :                     ROSE_ASSERT(defining_testNameInMap == testNameInMap);</span></a>
<a name="16617"><span class="lineNum">   16617 </span>            :                   }</a>
<a name="16618"><span class="lineNum">   16618 </span>            :              }</a>
<a name="16619"><span class="lineNum">   16619 </span>            :             else</a>
<a name="16620"><span class="lineNum">   16620 </span>            :              {</a>
<a name="16621"><span class="lineNum">   16621 </span>            :             // DQ (5/30/2019): Need to handle the case where the name qualification stored in the qualifiedNameMapForTypes</a>
<a name="16622"><span class="lineNum">   16622 </span>            :             // are the same for templateArgument, but different for defining_templateArgument.  This is a bugfix for test2019_444.C</a>
<a name="16623"><span class="lineNum">   16623 </span>            :             // reported by Charles as part of reproducers for bugs in ROE from ASC codes.</a>
<a name="16624"><span class="lineNum">   16624 </span>            : #if 0</a>
<a name="16625"><span class="lineNum">   16625 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;The name qualifier is the same in the qualifiedNameMapForTypes for templateArgument, but need to check for defining_templateArgument \n&quot;);</a>
<a name="16626"><span class="lineNum">   16626 </span>            : #endif</a>
<a name="16627"><span class="lineNum">   16627 </span><span class="lineCov">      77773 :                if (defining_templateArgument != NULL &amp;&amp; defining_templateArgument != templateArgument)</span></a>
<a name="16628"><span class="lineNum">   16628 </span>            :                   {</a>
<a name="16629"><span class="lineNum">   16629 </span><span class="lineCov">      62056 :                     ROSE_ASSERT(qualifiedNameMapForTypes.find(defining_templateArgument) != qualifiedNameMapForTypes.end());</span></a>
<a name="16630"><span class="lineNum">   16630 </span><span class="lineCov">      31028 :                     std::map&lt;SgNode*,std::string&gt;::iterator j = qualifiedNameMapForTypes.find(defining_templateArgument);</span></a>
<a name="16631"><span class="lineNum">   16631 </span><span class="lineCov">      31028 :                     ROSE_ASSERT (j != qualifiedNameMapForTypes.end());</span></a>
<a name="16632"><span class="lineNum">   16632 </span>            :                  // ROSE_ASSERT(j-&gt;second == qualifier);</a>
<a name="16633"><span class="lineNum">   16633 </span><span class="lineCov">      31028 :                     if (j-&gt;second != qualifier)</span></a>
<a name="16634"><span class="lineNum">   16634 </span>            :                        {</a>
<a name="16635"><span class="lineNum">   16635 </span>            : #if 0</a>
<a name="16636"><span class="lineNum">   16636 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;Setting the qualified for defining_templateArgument: j-&gt;second = %s qualifier = %s \n&quot;,j-&gt;second.c_str(),qualifier.c_str());</a>
<a name="16637"><span class="lineNum">   16637 </span>            : #endif</a>
<a name="16638"><span class="lineNum">   16638 </span><span class="lineCov">        246 :                          j-&gt;second = qualifier;</span></a>
<a name="16639"><span class="lineNum">   16639 </span>            :                        }</a>
<a name="16640"><span class="lineNum">   16640 </span><span class="lineCov">      31028 :                     ROSE_ASSERT(j-&gt;second == qualifier);</span></a>
<a name="16641"><span class="lineNum">   16641 </span>            :                   }</a>
<a name="16642"><span class="lineNum">   16642 </span>            :              }</a>
<a name="16643"><span class="lineNum">   16643 </span>            :         }</a>
<a name="16644"><span class="lineNum">   16644 </span><span class="lineCov">      91744 :    }</span></a>
<a name="16645"><span class="lineNum">   16645 </span>            : </a>
<a name="16646"><span class="lineNum">   16646 </span>            : </a>
<a name="16647"><span class="lineNum">   16647 </span>            : // void NameQualificationTraversal::setNameQualification(SgCastExp* castExp, SgDeclarationStatement* typeDeclaration, int amountOfNameQualificationRequired)</a>
<a name="16648"><span class="lineNum">   16648 </span>            : void</a>
<a name="16649"><span class="lineNum">   16649 </span><span class="lineCov">       8889 : NameQualificationTraversal::setNameQualification(SgExpression* exp, SgDeclarationStatement* typeDeclaration, int amountOfNameQualificationRequired)</span></a>
<a name="16650"><span class="lineNum">   16650 </span>            :    {</a>
<a name="16651"><span class="lineNum">   16651 </span>            :   // Setup call to refactored code.</a>
<a name="16652"><span class="lineNum">   16652 </span><span class="lineCov">       8889 :      int  outputNameQualificationLength = 0;</span></a>
<a name="16653"><span class="lineNum">   16653 </span><span class="lineCov">       8889 :      bool outputGlobalQualification     = false;</span></a>
<a name="16654"><span class="lineNum">   16654 </span><span class="lineCov">       8889 :      bool outputTypeEvaluation          = false;</span></a>
<a name="16655"><span class="lineNum">   16655 </span>            : </a>
<a name="16656"><span class="lineNum">   16656 </span>            :   // DQ (6/4/2011): This should not be a SgConstructorInitializer since that uses the qualifiedNameMapForNames instead of the qualifiedNameMapForTypes.</a>
<a name="16657"><span class="lineNum">   16657 </span><span class="lineCov">       8889 :      ROSE_ASSERT(isSgConstructorInitializer(exp) == NULL);</span></a>
<a name="16658"><span class="lineNum">   16658 </span>            : </a>
<a name="16659"><span class="lineNum">   16659 </span>            :   // DQ (11/22/2016): Added assertion.</a>
<a name="16660"><span class="lineNum">   16660 </span><span class="lineCov">       8889 :      ASSERT_not_null(typeDeclaration);</span></a>
<a name="16661"><span class="lineNum">   16661 </span>            : </a>
<a name="16662"><span class="lineNum">   16662 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="16663"><span class="lineNum">   16663 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In setNameQualification(SgExpression*) \n&quot;);</a>
<a name="16664"><span class="lineNum">   16664 </span>            : #endif</a>
<a name="16665"><span class="lineNum">   16665 </span>            : </a>
<a name="16666"><span class="lineNum">   16666 </span><span class="lineCov">       8889 :      SgScopeStatement * scope = traverseNonrealDeclForCorrectScope(typeDeclaration);</span></a>
<a name="16667"><span class="lineNum">   16667 </span><span class="lineCov">       8889 :      string qualifier = setNameQualificationSupport(scope,amountOfNameQualificationRequired, outputNameQualificationLength, outputGlobalQualification, outputTypeEvaluation);</span></a>
<a name="16668"><span class="lineNum">   16668 </span>            : </a>
<a name="16669"><span class="lineNum">   16669 </span><span class="lineCov">       8889 :      exp-&gt;set_global_qualification_required(outputGlobalQualification);</span></a>
<a name="16670"><span class="lineNum">   16670 </span><span class="lineCov">       8889 :      exp-&gt;set_name_qualification_length(outputNameQualificationLength);</span></a>
<a name="16671"><span class="lineNum">   16671 </span>            : </a>
<a name="16672"><span class="lineNum">   16672 </span>            :   // DQ (6/2/2011): I think that type elaboration could be required for casts, but I am not certain.</a>
<a name="16673"><span class="lineNum">   16673 </span><span class="lineCov">       8889 :      exp-&gt;set_type_elaboration_required(outputTypeEvaluation);</span></a>
<a name="16674"><span class="lineNum">   16674 </span>            : </a>
<a name="16675"><span class="lineNum">   16675 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="16676"><span class="lineNum">   16676 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): exp-&gt;get_name_qualification_length()     = %d \n&quot;,exp-&gt;get_name_qualification_length());</a>
<a name="16677"><span class="lineNum">   16677 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): exp-&gt;get_type_elaboration_required()     = %s \n&quot;,exp-&gt;get_type_elaboration_required() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="16678"><span class="lineNum">   16678 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): exp-&gt;get_global_qualification_required() = %s \n&quot;,exp-&gt;get_global_qualification_required() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="16679"><span class="lineNum">   16679 </span>            : #endif</a>
<a name="16680"><span class="lineNum">   16680 </span><span class="lineCov">      17778 :      if (qualifiedNameMapForTypes.find(exp) == qualifiedNameMapForTypes.end())</span></a>
<a name="16681"><span class="lineNum">   16681 </span>            :         {</a>
<a name="16682"><span class="lineNum">   16682 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="16683"><span class="lineNum">   16683 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Inserting qualifier for name = %s into list at IR node = %p = %s \n&quot;,qualifier.c_str(),exp,exp-&gt;class_name().c_str());</a>
<a name="16684"><span class="lineNum">   16684 </span>            : #endif</a>
<a name="16685"><span class="lineNum">   16685 </span><span class="lineCov">      17696 :           qualifiedNameMapForTypes.insert(std::pair&lt;SgNode*,std::string&gt;(exp,qualifier));</span></a>
<a name="16686"><span class="lineNum">   16686 </span>            :         }</a>
<a name="16687"><span class="lineNum">   16687 </span>            :        else</a>
<a name="16688"><span class="lineNum">   16688 </span>            :         {</a>
<a name="16689"><span class="lineNum">   16689 </span>            :        // DQ (6/21/2011): Now we are catching this case...</a>
<a name="16690"><span class="lineNum">   16690 </span>            : </a>
<a name="16691"><span class="lineNum">   16691 </span>            :        // If it already existes then overwrite the existing information.</a>
<a name="16692"><span class="lineNum">   16692 </span><span class="lineCov">        868 :           std::map&lt;SgNode*,std::string&gt;::iterator i = qualifiedNameMapForTypes.find(exp);</span></a>
<a name="16693"><span class="lineNum">   16693 </span><span class="lineCov">         41 :           ROSE_ASSERT (i != qualifiedNameMapForTypes.end());</span></a>
<a name="16694"><span class="lineNum">   16694 </span>            : </a>
<a name="16695"><span class="lineNum">   16695 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="16696"><span class="lineNum">   16696 </span>            :           string previousQualifier = i-&gt;second.c_str();</a>
<a name="16697"><span class="lineNum">   16697 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;WARNING: test 18: replacing previousQualifier = %s with new qualifier = %s \n&quot;,previousQualifier.c_str(),qualifier.c_str());</a>
<a name="16698"><span class="lineNum">   16698 </span>            : #endif</a>
<a name="16699"><span class="lineNum">   16699 </span>            :        // I think I can do this!</a>
<a name="16700"><span class="lineNum">   16700 </span>            :        // *i = std::pair&lt;SgNode*,std::string&gt;(templateArgument,qualifier);</a>
<a name="16701"><span class="lineNum">   16701 </span><span class="lineCov">         41 :           if (i-&gt;second != qualifier)</span></a>
<a name="16702"><span class="lineNum">   16702 </span>            :              {</a>
<a name="16703"><span class="lineNum">   16703 </span><span class="lineCov">       8889 :                i-&gt;second = qualifier;</span></a>
<a name="16704"><span class="lineNum">   16704 </span>            : </a>
<a name="16705"><span class="lineNum">   16705 </span>            : </a>
<a name="16706"><span class="lineNum">   16706 </span>            : #if 0</a>
<a name="16707"><span class="lineNum">   16707 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;WARNING: name in qualifiedNameMapForTypes already exists and is different... \n&quot;);</a>
<a name="16708"><span class="lineNum">   16708 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;  - exp = %p (%s) = %s\n&quot;, exp, exp-&gt;class_name().c_str(), exp-&gt;unparseToString().c_str());</a>
<a name="16709"><span class="lineNum">   16709 </span>            :                SgNode * parent = exp-&gt;get_parent();</a>
<a name="16710"><span class="lineNum">   16710 </span>            :                while (parent) {</a>
<a name="16711"><span class="lineNum">   16711 </span>            :                  mfprintf(mlog [ WARN ] ) (&quot;  - parent = %p (%s)\n&quot;, parent, parent-&gt;class_name().c_str());</a>
<a name="16712"><span class="lineNum">   16712 </span>            :                  parent = parent-&gt;get_parent();</a>
<a name="16713"><span class="lineNum">   16713 </span>            :                }</a>
<a name="16714"><span class="lineNum">   16714 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;  - typeDeclaration = %p (%s)\n&quot;, typeDeclaration, typeDeclaration-&gt;class_name().c_str());</a>
<a name="16715"><span class="lineNum">   16715 </span>            :                SgTemplateInstantiationDecl * tpl_inst_decl = isSgTemplateInstantiationDecl(typeDeclaration);</a>
<a name="16716"><span class="lineNum">   16716 </span>            :                ASSERT_not_null(tpl_inst_decl);</a>
<a name="16717"><span class="lineNum">   16717 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;  - tpl_inst_decl = %s\n&quot;, tpl_inst_decl-&gt;get_name().str());</a>
<a name="16718"><span class="lineNum">   16718 </span>            :                ROSE_ABORT();</a>
<a name="16719"><span class="lineNum">   16719 </span>            : #endif</a>
<a name="16720"><span class="lineNum">   16720 </span>            :              }</a>
<a name="16721"><span class="lineNum">   16721 </span>            :         }</a>
<a name="16722"><span class="lineNum">   16722 </span><span class="lineCov">       8889 :    }</span></a>
<a name="16723"><span class="lineNum">   16723 </span>            : </a>
<a name="16724"><span class="lineNum">   16724 </span>            : </a>
<a name="16725"><span class="lineNum">   16725 </span>            : void</a>
<a name="16726"><span class="lineNum">   16726 </span><span class="lineNoCov">          0 : NameQualificationTraversal::setNameQualificationForPointerToMember(SgExpression* exp, SgDeclarationStatement* typeDeclaration, int amountOfNameQualificationRequired)</span></a>
<a name="16727"><span class="lineNum">   16727 </span>            :    {</a>
<a name="16728"><span class="lineNum">   16728 </span>            :   // Setup call to refactored code.</a>
<a name="16729"><span class="lineNum">   16729 </span><span class="lineNoCov">          0 :      int  outputNameQualificationLength = 0;</span></a>
<a name="16730"><span class="lineNum">   16730 </span><span class="lineNoCov">          0 :      bool outputGlobalQualification     = false;</span></a>
<a name="16731"><span class="lineNum">   16731 </span><span class="lineNoCov">          0 :      bool outputTypeEvaluation          = false;</span></a>
<a name="16732"><span class="lineNum">   16732 </span>            : </a>
<a name="16733"><span class="lineNum">   16733 </span>            :   // DQ (6/4/2011): This should not be a SgConstructorInitializer since that uses the qualifiedNameMapForNames instead of the qualifiedNameMapForTypes.</a>
<a name="16734"><span class="lineNum">   16734 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(isSgConstructorInitializer(exp) == NULL);</span></a>
<a name="16735"><span class="lineNum">   16735 </span>            : </a>
<a name="16736"><span class="lineNum">   16736 </span>            :   // DQ (11/22/2016): Added assertion.</a>
<a name="16737"><span class="lineNum">   16737 </span><span class="lineNoCov">          0 :      ASSERT_not_null(typeDeclaration);</span></a>
<a name="16738"><span class="lineNum">   16738 </span>            : </a>
<a name="16739"><span class="lineNum">   16739 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="16740"><span class="lineNum">   16740 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In setNameQualificationForPointerToMember(SgExpression*): exp = %p = %s \n&quot;,exp,exp-&gt;class_name().c_str());</a>
<a name="16741"><span class="lineNum">   16741 </span>            : #endif</a>
<a name="16742"><span class="lineNum">   16742 </span>            : </a>
<a name="16743"><span class="lineNum">   16743 </span><span class="lineNoCov">          0 :      SgScopeStatement * scope = traverseNonrealDeclForCorrectScope(typeDeclaration);</span></a>
<a name="16744"><span class="lineNum">   16744 </span><span class="lineNoCov">          0 :      string qualifier = setNameQualificationSupport(scope,amountOfNameQualificationRequired, outputNameQualificationLength, outputGlobalQualification, outputTypeEvaluation);</span></a>
<a name="16745"><span class="lineNum">   16745 </span>            : </a>
<a name="16746"><span class="lineNum">   16746 </span>            :   // DQ (4/16/2019): These are virtual functions defined for a subset of IR nodes to be valid, but defined for SgExpression to be an explicit error.</a>
<a name="16747"><span class="lineNum">   16747 </span><span class="lineNoCov">          0 :      exp-&gt;set_global_qualification_for_pointer_to_member_class_required(outputGlobalQualification);</span></a>
<a name="16748"><span class="lineNum">   16748 </span><span class="lineNoCov">          0 :      exp-&gt;set_name_qualification_for_pointer_to_member_class_length(outputNameQualificationLength);</span></a>
<a name="16749"><span class="lineNum">   16749 </span>            : </a>
<a name="16750"><span class="lineNum">   16750 </span>            :   // DQ (6/2/2011): I think that type elaboration could be required for casts, but I am not certain.</a>
<a name="16751"><span class="lineNum">   16751 </span><span class="lineNoCov">          0 :      exp-&gt;set_type_elaboration_for_pointer_to_member_class_required(outputTypeEvaluation);</span></a>
<a name="16752"><span class="lineNum">   16752 </span>            : </a>
<a name="16753"><span class="lineNum">   16753 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="16754"><span class="lineNum">   16754 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualificationForPointerToMember(): exp-&gt;get_name_qualification_length()     = %d \n&quot;,exp-&gt;get_name_qualification_length());</a>
<a name="16755"><span class="lineNum">   16755 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualificationForPointerToMember(): exp-&gt;get_type_elaboration_required()     = %s \n&quot;,exp-&gt;get_type_elaboration_required() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="16756"><span class="lineNum">   16756 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualificationForPointerToMember(): exp-&gt;get_global_qualification_required() = %s \n&quot;,exp-&gt;get_global_qualification_required() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="16757"><span class="lineNum">   16757 </span>            : #endif</a>
<a name="16758"><span class="lineNum">   16758 </span>            : </a>
<a name="16759"><span class="lineNum">   16759 </span>            :   // if (qualifiedNameMapForTypes.find(exp) == qualifiedNameMapForTypes.end())</a>
<a name="16760"><span class="lineNum">   16760 </span><span class="lineNoCov">          0 :      if (qualifiedNameMapForNames.find(exp) == qualifiedNameMapForNames.end())</span></a>
<a name="16761"><span class="lineNum">   16761 </span>            :         {</a>
<a name="16762"><span class="lineNum">   16762 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="16763"><span class="lineNum">   16763 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Inserting qualifier for name = %s into list at IR node = %p = %s \n&quot;,qualifier.c_str(),exp,exp-&gt;class_name().c_str());</a>
<a name="16764"><span class="lineNum">   16764 </span>            : #endif</a>
<a name="16765"><span class="lineNum">   16765 </span>            :        // qualifiedNameMapForTypes.insert(std::pair&lt;SgNode*,std::string&gt;(exp,qualifier));</a>
<a name="16766"><span class="lineNum">   16766 </span><span class="lineNoCov">          0 :           qualifiedNameMapForNames.insert(std::pair&lt;SgNode*,std::string&gt;(exp,qualifier));</span></a>
<a name="16767"><span class="lineNum">   16767 </span>            :         }</a>
<a name="16768"><span class="lineNum">   16768 </span>            :        else</a>
<a name="16769"><span class="lineNum">   16769 </span>            :         {</a>
<a name="16770"><span class="lineNum">   16770 </span>            :        // DQ (6/21/2011): Now we are catching this case...</a>
<a name="16771"><span class="lineNum">   16771 </span>            : </a>
<a name="16772"><span class="lineNum">   16772 </span>            :        // If it already existes then overwrite the existing information.</a>
<a name="16773"><span class="lineNum">   16773 </span>            :        // std::map&lt;SgNode*,std::string&gt;::iterator i = qualifiedNameMapForTypes.find(exp);</a>
<a name="16774"><span class="lineNum">   16774 </span><span class="lineNoCov">          0 :           std::map&lt;SgNode*,std::string&gt;::iterator i = qualifiedNameMapForNames.find(exp);</span></a>
<a name="16775"><span class="lineNum">   16775 </span>            :        // ROSE_ASSERT (i != qualifiedNameMapForTypes.end());</a>
<a name="16776"><span class="lineNum">   16776 </span><span class="lineNoCov">          0 :           ROSE_ASSERT (i != qualifiedNameMapForNames.end());</span></a>
<a name="16777"><span class="lineNum">   16777 </span>            : </a>
<a name="16778"><span class="lineNum">   16778 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="16779"><span class="lineNum">   16779 </span>            :           string previousQualifier = i-&gt;second.c_str();</a>
<a name="16780"><span class="lineNum">   16780 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;WARNING: test 18: replacing previousQualifier = %s with new qualifier = %s \n&quot;,previousQualifier.c_str(),qualifier.c_str());</a>
<a name="16781"><span class="lineNum">   16781 </span>            : #endif</a>
<a name="16782"><span class="lineNum">   16782 </span>            :        // I think I can do this!</a>
<a name="16783"><span class="lineNum">   16783 </span>            :        // *i = std::pair&lt;SgNode*,std::string&gt;(templateArgument,qualifier);</a>
<a name="16784"><span class="lineNum">   16784 </span><span class="lineNoCov">          0 :           if (i-&gt;second != qualifier)</span></a>
<a name="16785"><span class="lineNum">   16785 </span>            :              {</a>
<a name="16786"><span class="lineNum">   16786 </span><span class="lineNoCov">          0 :                i-&gt;second = qualifier;</span></a>
<a name="16787"><span class="lineNum">   16787 </span>            : </a>
<a name="16788"><span class="lineNum">   16788 </span>            :             // DQ (4/16/2019): Since expressions are not shared, we should be able to inforce this.</a>
<a name="16789"><span class="lineNum">   16789 </span><span class="lineNoCov">          0 :                mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</span></a>
<a name="16790"><span class="lineNum">   16790 </span><span class="lineNoCov">          0 :                ROSE_ABORT();</span></a>
<a name="16791"><span class="lineNum">   16791 </span>            : </a>
<a name="16792"><span class="lineNum">   16792 </span>            : #if 0</a>
<a name="16793"><span class="lineNum">   16793 </span>            :             // mfprintf(mlog [ WARN ] ) (&quot;WARNING: name in qualifiedNameMapForTypes already exists and is different... \n&quot;);</a>
<a name="16794"><span class="lineNum">   16794 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;WARNING: name in qualifiedNameMapForNames already exists and is different... \n&quot;);</a>
<a name="16795"><span class="lineNum">   16795 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;  - exp = %p (%s) = %s\n&quot;, exp, exp-&gt;class_name().c_str(), exp-&gt;unparseToString().c_str());</a>
<a name="16796"><span class="lineNum">   16796 </span>            :                SgNode * parent = exp-&gt;get_parent();</a>
<a name="16797"><span class="lineNum">   16797 </span>            :                while (parent) {</a>
<a name="16798"><span class="lineNum">   16798 </span>            :                  mfprintf(mlog [ WARN ] ) (&quot;  - parent = %p (%s)\n&quot;, parent, parent-&gt;class_name().c_str());</a>
<a name="16799"><span class="lineNum">   16799 </span>            :                  parent = parent-&gt;get_parent();</a>
<a name="16800"><span class="lineNum">   16800 </span>            :                }</a>
<a name="16801"><span class="lineNum">   16801 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;  - typeDeclaration = %p (%s)\n&quot;, typeDeclaration, typeDeclaration-&gt;class_name().c_str());</a>
<a name="16802"><span class="lineNum">   16802 </span>            :                SgTemplateInstantiationDecl * tpl_inst_decl = isSgTemplateInstantiationDecl(typeDeclaration);</a>
<a name="16803"><span class="lineNum">   16803 </span>            :                ASSERT_not_null(tpl_inst_decl);</a>
<a name="16804"><span class="lineNum">   16804 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;  - tpl_inst_decl = %s\n&quot;, tpl_inst_decl-&gt;get_name().str());</a>
<a name="16805"><span class="lineNum">   16805 </span>            :                ROSE_ABORT();</a>
<a name="16806"><span class="lineNum">   16806 </span>            : #endif</a>
<a name="16807"><span class="lineNum">   16807 </span>            :              }</a>
<a name="16808"><span class="lineNum">   16808 </span>            :         }</a>
<a name="16809"><span class="lineNum">   16809 </span><span class="lineNoCov">          0 :    }</span></a>
<a name="16810"><span class="lineNum">   16810 </span>            : </a>
<a name="16811"><span class="lineNum">   16811 </span>            : </a>
<a name="16812"><span class="lineNum">   16812 </span>            : void</a>
<a name="16813"><span class="lineNum">   16813 </span><span class="lineCov">      13148 : NameQualificationTraversal::setNameQualification(SgNonrealRefExp* exp, SgDeclarationStatement* typeDeclaration, int amountOfNameQualificationRequired)</span></a>
<a name="16814"><span class="lineNum">   16814 </span>            :    {</a>
<a name="16815"><span class="lineNum">   16815 </span>            :   // Setup call to refactored code.</a>
<a name="16816"><span class="lineNum">   16816 </span><span class="lineCov">      13148 :      int  outputNameQualificationLength = 0;</span></a>
<a name="16817"><span class="lineNum">   16817 </span><span class="lineCov">      13148 :      bool outputGlobalQualification     = false;</span></a>
<a name="16818"><span class="lineNum">   16818 </span><span class="lineCov">      13148 :      bool outputTypeEvaluation          = false;</span></a>
<a name="16819"><span class="lineNum">   16819 </span>            : </a>
<a name="16820"><span class="lineNum">   16820 </span>            :   // DQ (11/22/2016): Added assertion.</a>
<a name="16821"><span class="lineNum">   16821 </span><span class="lineCov">      13148 :      ASSERT_not_null(typeDeclaration);</span></a>
<a name="16822"><span class="lineNum">   16822 </span>            : </a>
<a name="16823"><span class="lineNum">   16823 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="16824"><span class="lineNum">   16824 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In setNameQualification(SgNonrealRefExp*) \n&quot;);</a>
<a name="16825"><span class="lineNum">   16825 </span>            : #endif</a>
<a name="16826"><span class="lineNum">   16826 </span>            : </a>
<a name="16827"><span class="lineNum">   16827 </span><span class="lineCov">      13148 :      SgScopeStatement * scope = traverseNonrealDeclForCorrectScope(typeDeclaration);</span></a>
<a name="16828"><span class="lineNum">   16828 </span><span class="lineCov">      13148 :      string qualifier = setNameQualificationSupport(scope,amountOfNameQualificationRequired, outputNameQualificationLength, outputGlobalQualification, outputTypeEvaluation);</span></a>
<a name="16829"><span class="lineNum">   16829 </span>            : </a>
<a name="16830"><span class="lineNum">   16830 </span><span class="lineCov">      13148 :      exp-&gt;set_global_qualification_required(outputGlobalQualification);</span></a>
<a name="16831"><span class="lineNum">   16831 </span><span class="lineCov">      13148 :      exp-&gt;set_name_qualification_length(outputNameQualificationLength);</span></a>
<a name="16832"><span class="lineNum">   16832 </span>            : </a>
<a name="16833"><span class="lineNum">   16833 </span>            :   // DQ (6/2/2011): I think that type elaboration could be required for casts, but I am not certain.</a>
<a name="16834"><span class="lineNum">   16834 </span><span class="lineCov">      13148 :      exp-&gt;set_type_elaboration_required(outputTypeEvaluation);</span></a>
<a name="16835"><span class="lineNum">   16835 </span>            : </a>
<a name="16836"><span class="lineNum">   16836 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="16837"><span class="lineNum">   16837 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): exp-&gt;get_name_qualification_length()     = %d \n&quot;,exp-&gt;get_name_qualification_length());</a>
<a name="16838"><span class="lineNum">   16838 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): exp-&gt;get_type_elaboration_required()     = %s \n&quot;,exp-&gt;get_type_elaboration_required() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="16839"><span class="lineNum">   16839 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): exp-&gt;get_global_qualification_required() = %s \n&quot;,exp-&gt;get_global_qualification_required() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="16840"><span class="lineNum">   16840 </span>            : #endif</a>
<a name="16841"><span class="lineNum">   16841 </span><span class="lineCov">      26296 :      if (qualifiedNameMapForNames.find(exp) == qualifiedNameMapForNames.end())</span></a>
<a name="16842"><span class="lineNum">   16842 </span>            :         {</a>
<a name="16843"><span class="lineNum">   16843 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="16844"><span class="lineNum">   16844 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Inserting qualifier for name = %s into list at IR node = %p = %s \n&quot;,qualifier.c_str(),exp,exp-&gt;class_name().c_str());</a>
<a name="16845"><span class="lineNum">   16845 </span>            : #endif</a>
<a name="16846"><span class="lineNum">   16846 </span><span class="lineCov">      25876 :           qualifiedNameMapForNames.insert(std::pair&lt;SgNode*,std::string&gt;(exp,qualifier));</span></a>
<a name="16847"><span class="lineNum">   16847 </span>            :         }</a>
<a name="16848"><span class="lineNum">   16848 </span>            :        else</a>
<a name="16849"><span class="lineNum">   16849 </span>            :         {</a>
<a name="16850"><span class="lineNum">   16850 </span>            :        // DQ (6/21/2011): Now we are catching this case...</a>
<a name="16851"><span class="lineNum">   16851 </span>            : </a>
<a name="16852"><span class="lineNum">   16852 </span>            :        // If it already existes then overwrite the existing information.</a>
<a name="16853"><span class="lineNum">   16853 </span><span class="lineCov">       3675 :           std::map&lt;SgNode*,std::string&gt;::iterator i = qualifiedNameMapForNames.find(exp);</span></a>
<a name="16854"><span class="lineNum">   16854 </span><span class="lineCov">        210 :           ROSE_ASSERT (i != qualifiedNameMapForNames.end());</span></a>
<a name="16855"><span class="lineNum">   16855 </span>            : </a>
<a name="16856"><span class="lineNum">   16856 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="16857"><span class="lineNum">   16857 </span>            :           string previousQualifier = i-&gt;second.c_str();</a>
<a name="16858"><span class="lineNum">   16858 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;WARNING: test 19: replacing previousQualifier = %s with new qualifier = %s \n&quot;,previousQualifier.c_str(),qualifier.c_str());</a>
<a name="16859"><span class="lineNum">   16859 </span>            : #endif</a>
<a name="16860"><span class="lineNum">   16860 </span>            :        // I think I can do this!</a>
<a name="16861"><span class="lineNum">   16861 </span>            :        // *i = std::pair&lt;SgNode*,std::string&gt;(templateArgument,qualifier);</a>
<a name="16862"><span class="lineNum">   16862 </span><span class="lineCov">        210 :           if (i-&gt;second != qualifier)</span></a>
<a name="16863"><span class="lineNum">   16863 </span>            :              {</a>
<a name="16864"><span class="lineNum">   16864 </span><span class="lineNoCov">          0 :                i-&gt;second = qualifier;</span></a>
<a name="16865"><span class="lineNum">   16865 </span>            : </a>
<a name="16866"><span class="lineNum">   16866 </span>            : #if 1</a>
<a name="16867"><span class="lineNum">   16867 </span><span class="lineNoCov">          0 :                mfprintf(mlog [ WARN ] ) (&quot;WARNING: name in qualifiedNameMapForNames already exists and is different... \n&quot;);</span></a>
<a name="16868"><span class="lineNum">   16868 </span><span class="lineNoCov">          0 :                ROSE_ABORT();</span></a>
<a name="16869"><span class="lineNum">   16869 </span>            : #endif</a>
<a name="16870"><span class="lineNum">   16870 </span>            : </a>
<a name="16871"><span class="lineNum">   16871 </span>            :                SgName testNameInMap = exp-&gt;get_qualified_name_prefix();</a>
<a name="16872"><span class="lineNum">   16872 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;testNameInMap = %s \n&quot;,testNameInMap.str());</a>
<a name="16873"><span class="lineNum">   16873 </span>            :              }</a>
<a name="16874"><span class="lineNum">   16874 </span>            :         }</a>
<a name="16875"><span class="lineNum">   16875 </span><span class="lineCov">      13148 :    }</span></a>
<a name="16876"><span class="lineNum">   16876 </span>            : </a>
<a name="16877"><span class="lineNum">   16877 </span>            : </a>
<a name="16878"><span class="lineNum">   16878 </span>            : void</a>
<a name="16879"><span class="lineNum">   16879 </span><span class="lineCov">         11 : NameQualificationTraversal::setNameQualification(SgAggregateInitializer* exp, SgDeclarationStatement* typeDeclaration, int amountOfNameQualificationRequired)</span></a>
<a name="16880"><span class="lineNum">   16880 </span>            :    {</a>
<a name="16881"><span class="lineNum">   16881 </span>            :   // DQ (3/22/2018): This is a special version required for the SgAggregateInitializer, becuase it uses the set_global_qualification_required_for_type()</a>
<a name="16882"><span class="lineNum">   16882 </span>            :   // named functions instead of the set_global_qualification_required() named functions.  The alternative to to reusing the version of setNameQualification()</a>
<a name="16883"><span class="lineNum">   16883 </span>            :   // that takes a SgExpression would force special unparser support for the outputType function.  And since the name qualification for the case of a class type</a>
<a name="16884"><span class="lineNum">   16884 </span>            :   // is handled as name qualification on the output of a type, fixing up the name qualification is the better solution (so it seems to be after trying the</a>
<a name="16885"><span class="lineNum">   16885 </span>            :   // alternative).</a>
<a name="16886"><span class="lineNum">   16886 </span>            : </a>
<a name="16887"><span class="lineNum">   16887 </span>            :   // Setup call to refactored code.</a>
<a name="16888"><span class="lineNum">   16888 </span><span class="lineCov">         11 :      int  outputNameQualificationLength = 0;</span></a>
<a name="16889"><span class="lineNum">   16889 </span><span class="lineCov">         11 :      bool outputGlobalQualification     = false;</span></a>
<a name="16890"><span class="lineNum">   16890 </span><span class="lineCov">         11 :      bool outputTypeEvaluation          = false;</span></a>
<a name="16891"><span class="lineNum">   16891 </span>            : </a>
<a name="16892"><span class="lineNum">   16892 </span>            :   // DQ (6/4/2011): This should not be a SgConstructorInitializer since that uses the qualifiedNameMapForNames instead of the qualifiedNameMapForTypes.</a>
<a name="16893"><span class="lineNum">   16893 </span><span class="lineCov">         11 :      ROSE_ASSERT(isSgConstructorInitializer(exp) == NULL);</span></a>
<a name="16894"><span class="lineNum">   16894 </span>            : </a>
<a name="16895"><span class="lineNum">   16895 </span>            :   // DQ (11/22/2016): Added assertion.</a>
<a name="16896"><span class="lineNum">   16896 </span><span class="lineCov">         11 :      ASSERT_not_null(typeDeclaration);</span></a>
<a name="16897"><span class="lineNum">   16897 </span>            : </a>
<a name="16898"><span class="lineNum">   16898 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="16899"><span class="lineNum">   16899 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(SgAggregateInitializer*): TOP of function: amountOfNameQualificationRequired = %d \n&quot;,amountOfNameQualificationRequired);</a>
<a name="16900"><span class="lineNum">   16900 </span>            : #endif</a>
<a name="16901"><span class="lineNum">   16901 </span>            : </a>
<a name="16902"><span class="lineNum">   16902 </span><span class="lineCov">         11 :      SgScopeStatement * scope = traverseNonrealDeclForCorrectScope(typeDeclaration);</span></a>
<a name="16903"><span class="lineNum">   16903 </span><span class="lineCov">         11 :      string qualifier = setNameQualificationSupport(scope,amountOfNameQualificationRequired, outputNameQualificationLength, outputGlobalQualification, outputTypeEvaluation);</span></a>
<a name="16904"><span class="lineNum">   16904 </span>            : </a>
<a name="16905"><span class="lineNum">   16905 </span><span class="lineCov">         11 :      exp-&gt;set_global_qualification_required_for_type(outputGlobalQualification);</span></a>
<a name="16906"><span class="lineNum">   16906 </span><span class="lineCov">         11 :      exp-&gt;set_name_qualification_length_for_type(outputNameQualificationLength);</span></a>
<a name="16907"><span class="lineNum">   16907 </span>            : </a>
<a name="16908"><span class="lineNum">   16908 </span>            :   // DQ (6/2/2011): I think that type elaboration could be required for casts, but I am not certain.</a>
<a name="16909"><span class="lineNum">   16909 </span><span class="lineCov">         11 :      exp-&gt;set_type_elaboration_required_for_type(outputTypeEvaluation);</span></a>
<a name="16910"><span class="lineNum">   16910 </span>            : </a>
<a name="16911"><span class="lineNum">   16911 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="16912"><span class="lineNum">   16912 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(SgAggregateInitializer*): exp-&gt;get_name_qualification_length()     = %d \n&quot;,exp-&gt;get_name_qualification_length_for_type());</a>
<a name="16913"><span class="lineNum">   16913 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(SgAggregateInitializer*): exp-&gt;get_type_elaboration_required()     = %s \n&quot;,exp-&gt;get_type_elaboration_required_for_type() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="16914"><span class="lineNum">   16914 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(SgAggregateInitializer*): exp-&gt;get_global_qualification_required() = %s \n&quot;,exp-&gt;get_global_qualification_required_for_type() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="16915"><span class="lineNum">   16915 </span>            : #endif</a>
<a name="16916"><span class="lineNum">   16916 </span>            : </a>
<a name="16917"><span class="lineNum">   16917 </span><span class="lineCov">         22 :      if (qualifiedNameMapForTypes.find(exp) == qualifiedNameMapForTypes.end())</span></a>
<a name="16918"><span class="lineNum">   16918 </span>            :         {</a>
<a name="16919"><span class="lineNum">   16919 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="16920"><span class="lineNum">   16920 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Inserting qualifier for name = %s into list at IR node = %p = %s \n&quot;,qualifier.c_str(),exp,exp-&gt;class_name().c_str());</a>
<a name="16921"><span class="lineNum">   16921 </span>            : #endif</a>
<a name="16922"><span class="lineNum">   16922 </span><span class="lineCov">         22 :           qualifiedNameMapForTypes.insert(std::pair&lt;SgNode*,std::string&gt;(exp,qualifier));</span></a>
<a name="16923"><span class="lineNum">   16923 </span>            :         }</a>
<a name="16924"><span class="lineNum">   16924 </span>            :        else</a>
<a name="16925"><span class="lineNum">   16925 </span>            :         {</a>
<a name="16926"><span class="lineNum">   16926 </span>            :        // DQ (6/21/2011): Now we are catching this case...</a>
<a name="16927"><span class="lineNum">   16927 </span>            : </a>
<a name="16928"><span class="lineNum">   16928 </span>            :        // If it already existes then overwrite the existing information.</a>
<a name="16929"><span class="lineNum">   16929 </span><span class="lineNoCov">          0 :           std::map&lt;SgNode*,std::string&gt;::iterator i = qualifiedNameMapForTypes.find(exp);</span></a>
<a name="16930"><span class="lineNum">   16930 </span><span class="lineNoCov">          0 :           ROSE_ASSERT (i != qualifiedNameMapForTypes.end());</span></a>
<a name="16931"><span class="lineNum">   16931 </span>            : </a>
<a name="16932"><span class="lineNum">   16932 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="16933"><span class="lineNum">   16933 </span>            :           string previousQualifier = i-&gt;second.c_str();</a>
<a name="16934"><span class="lineNum">   16934 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;WARNING: test 20: replacing previousQualifier = %s with new qualifier = %s \n&quot;,previousQualifier.c_str(),qualifier.c_str());</a>
<a name="16935"><span class="lineNum">   16935 </span>            : #endif</a>
<a name="16936"><span class="lineNum">   16936 </span>            :        // I think I can do this!</a>
<a name="16937"><span class="lineNum">   16937 </span>            :        // *i = std::pair&lt;SgNode*,std::string&gt;(templateArgument,qualifier);</a>
<a name="16938"><span class="lineNum">   16938 </span><span class="lineNoCov">          0 :           if (i-&gt;second != qualifier)</span></a>
<a name="16939"><span class="lineNum">   16939 </span>            :              {</a>
<a name="16940"><span class="lineNum">   16940 </span><span class="lineNoCov">          0 :                i-&gt;second = qualifier;</span></a>
<a name="16941"><span class="lineNum">   16941 </span>            : </a>
<a name="16942"><span class="lineNum">   16942 </span>            : #if 1</a>
<a name="16943"><span class="lineNum">   16943 </span><span class="lineNoCov">          0 :                mfprintf(mlog [ WARN ] ) (&quot;WARNING: name in qualifiedNameMapForTypes already exists and is different... \n&quot;);</span></a>
<a name="16944"><span class="lineNum">   16944 </span>            :             // ROSE_ASSERT(false);</a>
<a name="16945"><span class="lineNum">   16945 </span>            : #endif</a>
<a name="16946"><span class="lineNum">   16946 </span>            : </a>
<a name="16947"><span class="lineNum">   16947 </span><span class="lineNoCov">          0 :                SgName testNameInMap = exp-&gt;get_qualified_name_prefix();</span></a>
<a name="16948"><span class="lineNum">   16948 </span><span class="lineNoCov">          0 :                mfprintf(mlog [ WARN ] ) (&quot;testNameInMap = %s \n&quot;,testNameInMap.str());</span></a>
<a name="16949"><span class="lineNum">   16949 </span>            :              }</a>
<a name="16950"><span class="lineNum">   16950 </span>            :         }</a>
<a name="16951"><span class="lineNum">   16951 </span><span class="lineCov">         11 :    }</span></a>
<a name="16952"><span class="lineNum">   16952 </span>            : </a>
<a name="16953"><span class="lineNum">   16953 </span>            : </a>
<a name="16954"><span class="lineNum">   16954 </span>            : void</a>
<a name="16955"><span class="lineNum">   16955 </span><span class="lineCov">      17597 : NameQualificationTraversal::setNameQualification(SgClassDeclaration* classDeclaration, int amountOfNameQualificationRequired)</span></a>
<a name="16956"><span class="lineNum">   16956 </span>            :    {</a>
<a name="16957"><span class="lineNum">   16957 </span>            :   // This is used to set the name qualification on the associated SgClassDeclaration.</a>
<a name="16958"><span class="lineNum">   16958 </span>            : </a>
<a name="16959"><span class="lineNum">   16959 </span>            :   // Setup call to refactored code.</a>
<a name="16960"><span class="lineNum">   16960 </span><span class="lineCov">      17597 :      int  outputNameQualificationLength = 0;</span></a>
<a name="16961"><span class="lineNum">   16961 </span><span class="lineCov">      17597 :      bool outputGlobalQualification     = false;</span></a>
<a name="16962"><span class="lineNum">   16962 </span><span class="lineCov">      17597 :      bool outputTypeEvaluation          = false;</span></a>
<a name="16963"><span class="lineNum">   16963 </span>            : </a>
<a name="16964"><span class="lineNum">   16964 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="16965"><span class="lineNum">   16965 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In setNameQualification(SgClassDeclaration*) \n&quot;);</a>
<a name="16966"><span class="lineNum">   16966 </span>            :      mfprintf(mlog [ WARN ] ) (&quot; - classDeclaration = %p (%s)\n&quot;, classDeclaration, classDeclaration-&gt;class_name().c_str());</a>
<a name="16967"><span class="lineNum">   16967 </span>            :      mfprintf(mlog [ WARN ] ) (&quot; - amountOfNameQualificationRequired = %d\n&quot;, amountOfNameQualificationRequired);</a>
<a name="16968"><span class="lineNum">   16968 </span>            : #endif</a>
<a name="16969"><span class="lineNum">   16969 </span>            : </a>
<a name="16970"><span class="lineNum">   16970 </span><span class="lineCov">      17597 :      SgScopeStatement * scope = traverseNonrealDeclForCorrectScope(classDeclaration);</span></a>
<a name="16971"><span class="lineNum">   16971 </span><span class="lineCov">      17597 :      string qualifier = setNameQualificationSupport(scope,amountOfNameQualificationRequired, outputNameQualificationLength, outputGlobalQualification, outputTypeEvaluation);</span></a>
<a name="16972"><span class="lineNum">   16972 </span>            : </a>
<a name="16973"><span class="lineNum">   16973 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="16974"><span class="lineNum">   16974 </span>            :      mfprintf(mlog [ WARN ] ) (&quot; - qualifier = %s\n&quot;, qualifier.c_str());</a>
<a name="16975"><span class="lineNum">   16975 </span>            : #endif</a>
<a name="16976"><span class="lineNum">   16976 </span>            : </a>
<a name="16977"><span class="lineNum">   16977 </span><span class="lineCov">      17597 :      classDeclaration-&gt;set_global_qualification_required(outputGlobalQualification);</span></a>
<a name="16978"><span class="lineNum">   16978 </span><span class="lineCov">      17597 :      classDeclaration-&gt;set_name_qualification_length(outputNameQualificationLength);</span></a>
<a name="16979"><span class="lineNum">   16979 </span><span class="lineCov">      17597 :      classDeclaration-&gt;set_type_elaboration_required(outputTypeEvaluation);</span></a>
<a name="16980"><span class="lineNum">   16980 </span>            : </a>
<a name="16981"><span class="lineNum">   16981 </span>            :   // There should be no type evaluation required for a variable reference, as I recall.</a>
<a name="16982"><span class="lineNum">   16982 </span><span class="lineCov">      17597 :      ROSE_ASSERT(outputTypeEvaluation == false);</span></a>
<a name="16983"><span class="lineNum">   16983 </span>            : </a>
<a name="16984"><span class="lineNum">   16984 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="16985"><span class="lineNum">   16985 </span>            :      mfprintf(mlog [ WARN ] ) (&quot; - classDeclaration-&gt;get_name_qualification_length()     = %d \n&quot;,classDeclaration-&gt;get_name_qualification_length());</a>
<a name="16986"><span class="lineNum">   16986 </span>            :      mfprintf(mlog [ WARN ] ) (&quot; - classDeclaration-&gt;get_type_elaboration_required()     = %s \n&quot;,classDeclaration-&gt;get_type_elaboration_required() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="16987"><span class="lineNum">   16987 </span>            :      mfprintf(mlog [ WARN ] ) (&quot; - classDeclaration-&gt;get_global_qualification_required() = %s \n&quot;,classDeclaration-&gt;get_global_qualification_required() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="16988"><span class="lineNum">   16988 </span>            : #endif</a>
<a name="16989"><span class="lineNum">   16989 </span>            : </a>
<a name="16990"><span class="lineNum">   16990 </span><span class="lineCov">      35194 :      if (qualifiedNameMapForNames.find(classDeclaration) == qualifiedNameMapForNames.end())</span></a>
<a name="16991"><span class="lineNum">   16991 </span>            :         {</a>
<a name="16992"><span class="lineNum">   16992 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="16993"><span class="lineNum">   16993 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Inserting qualifier for name = %s into list at SgClassDeclaration IR node = %p = %s \n&quot;,qualifier.c_str(),classDeclaration,classDeclaration-&gt;class_name().c_str());</a>
<a name="16994"><span class="lineNum">   16994 </span>            : #endif</a>
<a name="16995"><span class="lineNum">   16995 </span><span class="lineCov">      35126 :           qualifiedNameMapForNames.insert(std::pair&lt;SgNode*,std::string&gt;(classDeclaration,qualifier));</span></a>
<a name="16996"><span class="lineNum">   16996 </span>            :         }</a>
<a name="16997"><span class="lineNum">   16997 </span>            :        else</a>
<a name="16998"><span class="lineNum">   16998 </span>            :         {</a>
<a name="16999"><span class="lineNum">   16999 </span>            :        // If it already exists then overwrite the existing information.</a>
<a name="17000"><span class="lineNum">   17000 </span><span class="lineCov">        489 :           std::map&lt;SgNode*,std::string&gt;::iterator i = qualifiedNameMapForNames.find(classDeclaration);</span></a>
<a name="17001"><span class="lineNum">   17001 </span><span class="lineCov">         34 :           ROSE_ASSERT (i != qualifiedNameMapForNames.end());</span></a>
<a name="17002"><span class="lineNum">   17002 </span>            : </a>
<a name="17003"><span class="lineNum">   17003 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="17004"><span class="lineNum">   17004 </span>            :           string previousQualifier = i-&gt;second.c_str();</a>
<a name="17005"><span class="lineNum">   17005 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;WARNING: test 21: replacing previousQualifier = %s with new qualifier = %s \n&quot;,previousQualifier.c_str(),qualifier.c_str());</a>
<a name="17006"><span class="lineNum">   17006 </span>            : #endif</a>
<a name="17007"><span class="lineNum">   17007 </span>            :        // I think I can do this!</a>
<a name="17008"><span class="lineNum">   17008 </span>            :        // *i = std::pair&lt;SgNode*,std::string&gt;(templateArgument,qualifier);</a>
<a name="17009"><span class="lineNum">   17009 </span><span class="lineCov">         34 :           if (i-&gt;second != qualifier)</span></a>
<a name="17010"><span class="lineNum">   17010 </span>            :              {</a>
<a name="17011"><span class="lineNum">   17011 </span><span class="lineNoCov">          0 :                i-&gt;second = qualifier;</span></a>
<a name="17012"><span class="lineNum">   17012 </span>            : </a>
<a name="17013"><span class="lineNum">   17013 </span>            : #if 1</a>
<a name="17014"><span class="lineNum">   17014 </span><span class="lineNoCov">          0 :                mfprintf(mlog [ WARN ] ) (&quot;Error: name in qualifiedNameMapForNames already exists and is different... \n&quot;);</span></a>
<a name="17015"><span class="lineNum">   17015 </span><span class="lineNoCov">          0 :                ROSE_ABORT();</span></a>
<a name="17016"><span class="lineNum">   17016 </span>            : #endif</a>
<a name="17017"><span class="lineNum">   17017 </span>            :              }</a>
<a name="17018"><span class="lineNum">   17018 </span>            : #if 0</a>
<a name="17019"><span class="lineNum">   17019 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Error: name in qualifiedNameMapForNames already exists... \n&quot;);</a>
<a name="17020"><span class="lineNum">   17020 </span>            :           ROSE_ABORT();</a>
<a name="17021"><span class="lineNum">   17021 </span>            : #endif</a>
<a name="17022"><span class="lineNum">   17022 </span>            :         }</a>
<a name="17023"><span class="lineNum">   17023 </span><span class="lineCov">      17597 :    }</span></a>
<a name="17024"><span class="lineNum">   17024 </span>            : </a>
<a name="17025"><span class="lineNum">   17025 </span>            : </a>
<a name="17026"><span class="lineNum">   17026 </span>            : void</a>
<a name="17027"><span class="lineNum">   17027 </span><span class="lineCov">        852 : NameQualificationTraversal::setNameQualification(SgEnumDeclaration* enumDeclaration, int amountOfNameQualificationRequired)</span></a>
<a name="17028"><span class="lineNum">   17028 </span>            :    {</a>
<a name="17029"><span class="lineNum">   17029 </span>            :   // This is used to set the name qualification on the associated SgEnumDeclaration.</a>
<a name="17030"><span class="lineNum">   17030 </span>            : </a>
<a name="17031"><span class="lineNum">   17031 </span>            :   // Setup call to refactored code.</a>
<a name="17032"><span class="lineNum">   17032 </span><span class="lineCov">        852 :      int  outputNameQualificationLength = 0;</span></a>
<a name="17033"><span class="lineNum">   17033 </span><span class="lineCov">        852 :      bool outputGlobalQualification     = false;</span></a>
<a name="17034"><span class="lineNum">   17034 </span><span class="lineCov">        852 :      bool outputTypeEvaluation          = false;</span></a>
<a name="17035"><span class="lineNum">   17035 </span>            : </a>
<a name="17036"><span class="lineNum">   17036 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="17037"><span class="lineNum">   17037 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In setNameQualification(SgEnumDeclaration*) \n&quot;);</a>
<a name="17038"><span class="lineNum">   17038 </span>            : #endif</a>
<a name="17039"><span class="lineNum">   17039 </span>            : </a>
<a name="17040"><span class="lineNum">   17040 </span>            :   // DQ (2/22/2019): Adding assertion to debug GNU 4.9.3 issue.</a>
<a name="17041"><span class="lineNum">   17041 </span><span class="lineCov">        852 :      ASSERT_not_null(enumDeclaration);</span></a>
<a name="17042"><span class="lineNum">   17042 </span>            : </a>
<a name="17043"><span class="lineNum">   17043 </span><span class="lineCov">        852 :      SgScopeStatement * scope = traverseNonrealDeclForCorrectScope(enumDeclaration);</span></a>
<a name="17044"><span class="lineNum">   17044 </span><span class="lineCov">        852 :      string qualifier = setNameQualificationSupport(scope,amountOfNameQualificationRequired, outputNameQualificationLength, outputGlobalQualification, outputTypeEvaluation);</span></a>
<a name="17045"><span class="lineNum">   17045 </span>            : </a>
<a name="17046"><span class="lineNum">   17046 </span><span class="lineCov">        852 :      enumDeclaration-&gt;set_global_qualification_required(outputGlobalQualification);</span></a>
<a name="17047"><span class="lineNum">   17047 </span><span class="lineCov">        852 :      enumDeclaration-&gt;set_name_qualification_length(outputNameQualificationLength);</span></a>
<a name="17048"><span class="lineNum">   17048 </span><span class="lineCov">        852 :      enumDeclaration-&gt;set_type_elaboration_required(outputTypeEvaluation);</span></a>
<a name="17049"><span class="lineNum">   17049 </span>            : </a>
<a name="17050"><span class="lineNum">   17050 </span>            :   // There should be no type evaluation required for a variable reference, as I recall.</a>
<a name="17051"><span class="lineNum">   17051 </span><span class="lineCov">        852 :      ROSE_ASSERT(outputTypeEvaluation == false);</span></a>
<a name="17052"><span class="lineNum">   17052 </span>            : </a>
<a name="17053"><span class="lineNum">   17053 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="17054"><span class="lineNum">   17054 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): enumDeclaration-&gt;get_name_qualification_length()     = %d \n&quot;,enumDeclaration-&gt;get_name_qualification_length());</a>
<a name="17055"><span class="lineNum">   17055 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): enumDeclaration-&gt;get_type_elaboration_required()     = %s \n&quot;,enumDeclaration-&gt;get_type_elaboration_required() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="17056"><span class="lineNum">   17056 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualification(): enumDeclaration-&gt;get_global_qualification_required() = %s \n&quot;,enumDeclaration-&gt;get_global_qualification_required() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="17057"><span class="lineNum">   17057 </span>            : #endif</a>
<a name="17058"><span class="lineNum">   17058 </span>            : </a>
<a name="17059"><span class="lineNum">   17059 </span><span class="lineCov">       1704 :      if (qualifiedNameMapForNames.find(enumDeclaration) == qualifiedNameMapForNames.end())</span></a>
<a name="17060"><span class="lineNum">   17060 </span>            :         {</a>
<a name="17061"><span class="lineNum">   17061 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="17062"><span class="lineNum">   17062 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Inserting qualifier for name = %s into list at SgEnumDeclaration IR node = %p = %s \n&quot;,qualifier.c_str(),enumDeclaration,enumDeclaration-&gt;class_name().c_str());</a>
<a name="17063"><span class="lineNum">   17063 </span>            : #endif</a>
<a name="17064"><span class="lineNum">   17064 </span><span class="lineCov">       1704 :           qualifiedNameMapForNames.insert(std::pair&lt;SgNode*,std::string&gt;(enumDeclaration,qualifier));</span></a>
<a name="17065"><span class="lineNum">   17065 </span>            :         }</a>
<a name="17066"><span class="lineNum">   17066 </span>            :        else</a>
<a name="17067"><span class="lineNum">   17067 </span>            :         {</a>
<a name="17068"><span class="lineNum">   17068 </span>            :        // If it already exists then overwrite the existing information.</a>
<a name="17069"><span class="lineNum">   17069 </span><span class="lineNoCov">          0 :           std::map&lt;SgNode*,std::string&gt;::iterator i = qualifiedNameMapForNames.find(enumDeclaration);</span></a>
<a name="17070"><span class="lineNum">   17070 </span><span class="lineNoCov">          0 :           ROSE_ASSERT (i != qualifiedNameMapForNames.end());</span></a>
<a name="17071"><span class="lineNum">   17071 </span>            : </a>
<a name="17072"><span class="lineNum">   17072 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="17073"><span class="lineNum">   17073 </span>            :           string previousQualifier = i-&gt;second.c_str();</a>
<a name="17074"><span class="lineNum">   17074 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;WARNING: test 22: replacing previousQualifier = %s with new qualifier = %s \n&quot;,previousQualifier.c_str(),qualifier.c_str());</a>
<a name="17075"><span class="lineNum">   17075 </span>            : #endif</a>
<a name="17076"><span class="lineNum">   17076 </span>            :        // I think I can do this!</a>
<a name="17077"><span class="lineNum">   17077 </span>            :        // *i = std::pair&lt;SgNode*,std::string&gt;(templateArgument,qualifier);</a>
<a name="17078"><span class="lineNum">   17078 </span><span class="lineNoCov">          0 :           if (i-&gt;second != qualifier)</span></a>
<a name="17079"><span class="lineNum">   17079 </span>            :              {</a>
<a name="17080"><span class="lineNum">   17080 </span><span class="lineNoCov">          0 :                i-&gt;second = qualifier;</span></a>
<a name="17081"><span class="lineNum">   17081 </span>            : </a>
<a name="17082"><span class="lineNum">   17082 </span>            : #if 1</a>
<a name="17083"><span class="lineNum">   17083 </span><span class="lineNoCov">          0 :                mfprintf(mlog [ WARN ] ) (&quot;Error: name in qualifiedNameMapForNames already exists and is different... \n&quot;);</span></a>
<a name="17084"><span class="lineNum">   17084 </span><span class="lineNoCov">          0 :                ROSE_ABORT();</span></a>
<a name="17085"><span class="lineNum">   17085 </span>            : #endif</a>
<a name="17086"><span class="lineNum">   17086 </span>            :              }</a>
<a name="17087"><span class="lineNum">   17087 </span>            : #if 0</a>
<a name="17088"><span class="lineNum">   17088 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Error: name in qualifiedNameMapForNames already exists... \n&quot;);</a>
<a name="17089"><span class="lineNum">   17089 </span>            :           ROSE_ABORT();</a>
<a name="17090"><span class="lineNum">   17090 </span>            : #endif</a>
<a name="17091"><span class="lineNum">   17091 </span>            :         }</a>
<a name="17092"><span class="lineNum">   17092 </span><span class="lineCov">        852 :    }</span></a>
<a name="17093"><span class="lineNum">   17093 </span>            : </a>
<a name="17094"><span class="lineNum">   17094 </span>            : </a>
<a name="17095"><span class="lineNum">   17095 </span>            : string</a>
<a name="17096"><span class="lineNum">   17096 </span><span class="lineCov">    1620630 : NameQualificationTraversal::setNameQualificationSupport(SgScopeStatement* scope, const int inputNameQualificationLength, int &amp; output_amountOfNameQualificationRequired , bool &amp; outputGlobalQualification, bool &amp; outputTypeEvaluation )</span></a>
<a name="17097"><span class="lineNum">   17097 </span>            :    {</a>
<a name="17098"><span class="lineNum">   17098 </span>            :   // This is lower level support for the different overloaded setNameQualification() functions.</a>
<a name="17099"><span class="lineNum">   17099 </span>            :   // This function builds up the qualified name as a string and then returns it to be used in</a>
<a name="17100"><span class="lineNum">   17100 </span>            :   // either the map to names or the map to types (two different hash maps).</a>
<a name="17101"><span class="lineNum">   17101 </span><span class="lineCov">    1620630 :      string qualifierString;</span></a>
<a name="17102"><span class="lineNum">   17102 </span>            : </a>
<a name="17103"><span class="lineNum">   17103 </span><span class="lineCov">    1620630 :      output_amountOfNameQualificationRequired = inputNameQualificationLength;</span></a>
<a name="17104"><span class="lineNum">   17104 </span><span class="lineCov">    1620630 :      outputGlobalQualification                = false;</span></a>
<a name="17105"><span class="lineNum">   17105 </span><span class="lineCov">    1620630 :      outputTypeEvaluation                     = false;</span></a>
<a name="17106"><span class="lineNum">   17106 </span>            : </a>
<a name="17107"><span class="lineNum">   17107 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="17108"><span class="lineNum">   17108 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualificationSupport(): scope = %p = %s = %s inputNameQualificationLength = %d \n&quot;,scope,scope-&gt;class_name().c_str(),SageInterface::get_name(scope).c_str(),inputNameQualificationLength);</a>
<a name="17109"><span class="lineNum">   17109 </span>            : #endif</a>
<a name="17110"><span class="lineNum">   17110 </span>            : </a>
<a name="17111"><span class="lineNum">   17111 </span>            : #if 0</a>
<a name="17112"><span class="lineNum">   17112 </span>            :      printf (&quot;test 6: qualifierString = %s \n&quot;,qualifierString.c_str());</a>
<a name="17113"><span class="lineNum">   17113 </span>            : #endif</a>
<a name="17114"><span class="lineNum">   17114 </span>            : </a>
<a name="17115"><span class="lineNum">   17115 </span>            :   // DQ (8/1/2020): This should always be true.</a>
<a name="17116"><span class="lineNum">   17116 </span>            :   // ROSE_ASSERT(namespaceAliasDeclarationMapFromInheritedAttribute != NULL);</a>
<a name="17117"><span class="lineNum">   17117 </span>            : </a>
<a name="17118"><span class="lineNum">   17118 </span>            : #if 0</a>
<a name="17119"><span class="lineNum">   17119 </span>            :      printf (&quot;In setNameQualificationSupport(): namespaceAliasDeclarationMap.size() = %zu \n&quot;,namespaceAliasDeclarationMap.size());</a>
<a name="17120"><span class="lineNum">   17120 </span>            : #endif</a>
<a name="17121"><span class="lineNum">   17121 </span>            : </a>
<a name="17122"><span class="lineNum">   17122 </span><span class="lineCov">    1764730 :      for (int i = 0; i &lt; inputNameQualificationLength; i++)</span></a>
<a name="17123"><span class="lineNum">   17123 </span>            :         {</a>
<a name="17124"><span class="lineNum">   17124 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="17125"><span class="lineNum">   17125 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;   --- In loop: i = %d scope = %p = %s = %s \n&quot;,i,scope,scope-&gt;class_name().c_str(),SageInterface::get_name(scope).c_str());</a>
<a name="17126"><span class="lineNum">   17126 </span>            : #endif</a>
<a name="17127"><span class="lineNum">   17127 </span><span class="lineCov">     369092 :           string scope_name;</span></a>
<a name="17128"><span class="lineNum">   17128 </span>            : </a>
<a name="17129"><span class="lineNum">   17129 </span>            :        // DQ (8/9/2020): When we process a namespace alias, we can break out of the loop over the length of</a>
<a name="17130"><span class="lineNum">   17130 </span>            :        // the required namespace name qualification depth (I think).  See Cxx_tests/test2020_24.C for an example.</a>
<a name="17131"><span class="lineNum">   17131 </span><span class="lineCov">     224997 :           bool breakOutOfLoop = false;</span></a>
<a name="17132"><span class="lineNum">   17132 </span>            : </a>
<a name="17133"><span class="lineNum">   17133 </span>            :        // DQ (8/19/2014): This is used to control the generation of qualified names for un-named namespaces</a>
<a name="17134"><span class="lineNum">   17134 </span>            :        // (and maybe also other un-named language constructs).</a>
<a name="17135"><span class="lineNum">   17135 </span><span class="lineCov">     224997 :           bool skip_over_scope = false;</span></a>
<a name="17136"><span class="lineNum">   17136 </span>            : #if 0</a>
<a name="17137"><span class="lineNum">   17137 </span>            :           printf (&quot;test 7: qualifierString = %s \n&quot;,qualifierString.c_str());</a>
<a name="17138"><span class="lineNum">   17138 </span>            : #endif</a>
<a name="17139"><span class="lineNum">   17139 </span>            :        // This requirement to visit the template arguments occurs for templaed functions and templated member functions as well.</a>
<a name="17140"><span class="lineNum">   17140 </span><span class="lineCov">     224997 :           SgTemplateInstantiationDefn* templateClassDefinition = isSgTemplateInstantiationDefn(scope);</span></a>
<a name="17141"><span class="lineNum">   17141 </span><span class="lineCov">     224997 :           if (templateClassDefinition != NULL)</span></a>
<a name="17142"><span class="lineNum">   17142 </span>            :              {</a>
<a name="17143"><span class="lineNum">   17143 </span>            :             // Need to investigate how to generate a better quality name.</a>
<a name="17144"><span class="lineNum">   17144 </span><span class="lineCov">      20251 :                SgTemplateInstantiationDecl* templateClassDeclaration = isSgTemplateInstantiationDecl(templateClassDefinition-&gt;get_declaration());</span></a>
<a name="17145"><span class="lineNum">   17145 </span><span class="lineCov">      20251 :                ASSERT_not_null(templateClassDeclaration);</span></a>
<a name="17146"><span class="lineNum">   17146 </span>            : </a>
<a name="17147"><span class="lineNum">   17147 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="17148"><span class="lineNum">   17148 </span>            :             // This is the normalized name (without name qualification for internal template arguments)</a>
<a name="17149"><span class="lineNum">   17149 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;templateClassDeclaration-&gt;get_name()          = %s \n&quot;,templateClassDeclaration-&gt;get_name().str());</a>
<a name="17150"><span class="lineNum">   17150 </span>            : </a>
<a name="17151"><span class="lineNum">   17151 </span>            :             // This is the name of the template (without and internal template arguments)</a>
<a name="17152"><span class="lineNum">   17152 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;templateClassDeclaration-&gt;get_templateName() = %s \n&quot;,templateClassDeclaration-&gt;get_templateName().str());</a>
<a name="17153"><span class="lineNum">   17153 </span>            : #endif</a>
<a name="17154"><span class="lineNum">   17154 </span>            : </a>
<a name="17155"><span class="lineNum">   17155 </span><span class="lineCov">      20251 :                SgUnparse_Info* unparseInfoPointer = new SgUnparse_Info();</span></a>
<a name="17156"><span class="lineNum">   17156 </span><span class="lineCov">      20251 :                ASSERT_not_null(unparseInfoPointer);</span></a>
<a name="17157"><span class="lineNum">   17157 </span><span class="lineCov">      20251 :                unparseInfoPointer-&gt;set_outputCompilerGeneratedStatements();</span></a>
<a name="17158"><span class="lineNum">   17158 </span>            : </a>
<a name="17159"><span class="lineNum">   17159 </span>            :             // templateClassDeclaration-&gt;get_file_info()-&gt;display(&quot;SgTemplateInstantiationDecl trying to generate the qualified name: debug&quot;);</a>
<a name="17160"><span class="lineNum">   17160 </span>            : </a>
<a name="17161"><span class="lineNum">   17161 </span><span class="lineCov">      40502 :                string template_name = templateClassDeclaration-&gt;get_templateName();</span></a>
<a name="17162"><span class="lineNum">   17162 </span>            : </a>
<a name="17163"><span class="lineNum">   17163 </span>            :             // DQ (2/22/2019): Note: the same moderately more complex handling for template arguments in the unparser,</a>
<a name="17164"><span class="lineNum">   17164 </span>            :             // might need to be used here for the support of the name qualification.</a>
<a name="17165"><span class="lineNum">   17165 </span><span class="lineCov">      20251 :                SgTemplateArgumentPtrList &amp; templateArgumentList = templateClassDeclaration-&gt;get_templateArguments();</span></a>
<a name="17166"><span class="lineNum">   17166 </span>            : #if 0</a>
<a name="17167"><span class="lineNum">   17167 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;In name qualification: templateArgumentList.size() = %zu \n&quot;,templateArgumentList.size());</a>
<a name="17168"><span class="lineNum">   17168 </span>            : #endif</a>
<a name="17169"><span class="lineNum">   17169 </span><span class="lineCov">      20251 :                bool isEmptyTemplateArgumentList = templateArgumentList.empty();</span></a>
<a name="17170"><span class="lineNum">   17170 </span>            : </a>
<a name="17171"><span class="lineNum">   17171 </span>            :             // template_name += &quot;&lt; &quot;;</a>
<a name="17172"><span class="lineNum">   17172 </span><span class="lineCov">      20251 :                if (isEmptyTemplateArgumentList == false)</span></a>
<a name="17173"><span class="lineNum">   17173 </span>            :                   {</a>
<a name="17174"><span class="lineNum">   17174 </span><span class="lineCov">      20085 :                     template_name += &quot;&lt; &quot;;</span></a>
<a name="17175"><span class="lineNum">   17175 </span>            :                   }</a>
<a name="17176"><span class="lineNum">   17176 </span>            : </a>
<a name="17177"><span class="lineNum">   17177 </span>            :             // mfprintf(mlog [ WARN ] ) (&quot;START: template_name = %s \n&quot;,template_name.c_str());</a>
<a name="17178"><span class="lineNum">   17178 </span><span class="lineCov">      20251 :                SgTemplateArgumentPtrList::iterator i = templateArgumentList.begin();</span></a>
<a name="17179"><span class="lineNum">   17179 </span>            : </a>
<a name="17180"><span class="lineNum">   17180 </span><span class="lineCov">      20251 :                bool previousTemplateArgumentOutput = false;</span></a>
<a name="17181"><span class="lineNum">   17181 </span><span class="lineCov">      61493 :                while (i != templateArgumentList.end())</span></a>
<a name="17182"><span class="lineNum">   17182 </span>            :                   {</a>
<a name="17183"><span class="lineNum">   17183 </span><span class="lineCov">      41242 :                     bool skipTemplateArgument = false;</span></a>
<a name="17184"><span class="lineNum">   17184 </span><span class="lineCov">      41242 :                     bool stopTemplateArgument = false;</span></a>
<a name="17185"><span class="lineNum">   17185 </span><span class="lineCov">      41242 :                     (*i)-&gt;outputTemplateArgument(skipTemplateArgument, stopTemplateArgument);</span></a>
<a name="17186"><span class="lineNum">   17186 </span>            : </a>
<a name="17187"><span class="lineNum">   17187 </span><span class="lineCov">      41242 :                     if (stopTemplateArgument) {</span></a>
<a name="17188"><span class="lineNum">   17188 </span>            :                       break;</a>
<a name="17189"><span class="lineNum">   17189 </span>            :                     }</a>
<a name="17190"><span class="lineNum">   17190 </span>            : </a>
<a name="17191"><span class="lineNum">   17191 </span>            : #if 0</a>
<a name="17192"><span class="lineNum">   17192 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;filterTemplateArgument = %s \n&quot;,filterTemplateArgument ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="17193"><span class="lineNum">   17193 </span>            : #endif</a>
<a name="17194"><span class="lineNum">   17194 </span>            :                  // if ((*i)-&gt;get_argumentType() != SgTemplateArgument::start_of_pack_expansion_argument)</a>
<a name="17195"><span class="lineNum">   17195 </span><span class="lineCov">      41242 :                     if (skipTemplateArgument == false)</span></a>
<a name="17196"><span class="lineNum">   17196 </span>            :                        {</a>
<a name="17197"><span class="lineNum">   17197 </span>            :                       // if (i != templateArgumentList.begin())</a>
<a name="17198"><span class="lineNum">   17198 </span><span class="lineCov">      41242 :                          if (previousTemplateArgumentOutput == true)</span></a>
<a name="17199"><span class="lineNum">   17199 </span>            :                             {</a>
<a name="17200"><span class="lineNum">   17200 </span>            :                            // DQ (2/11/2019): Adding debugging information for test2019_93.C.</a>
<a name="17201"><span class="lineNum">   17201 </span>            :                            // template_name += &quot; /* output comma: part 3 */ &quot;;</a>
<a name="17202"><span class="lineNum">   17202 </span><span class="lineCov">      21157 :                               template_name += &quot;,&quot;;</span></a>
<a name="17203"><span class="lineNum">   17203 </span>            :                             }</a>
<a name="17204"><span class="lineNum">   17204 </span><span class="lineCov">      82484 :                          string template_argument_name = globalUnparseToString(*i,unparseInfoPointer);</span></a>
<a name="17205"><span class="lineNum">   17205 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || 0</a>
<a name="17206"><span class="lineNum">   17206 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ In name qualification: templateArgument = %p template_argument_name (globalUnparseToString()) = %s \n&quot;,*i,template_argument_name.c_str());</a>
<a name="17207"><span class="lineNum">   17207 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;   --- template_argument_name.length() = %zu \n&quot;,template_argument_name.length());</a>
<a name="17208"><span class="lineNum">   17208 </span>            : #endif</a>
<a name="17209"><span class="lineNum">   17209 </span><span class="lineCov">      41242 :                          template_name += template_argument_name;</span></a>
<a name="17210"><span class="lineNum">   17210 </span><span class="lineCov">      41242 :                          previousTemplateArgumentOutput = true;</span></a>
<a name="17211"><span class="lineNum">   17211 </span>            :                        }</a>
<a name="17212"><span class="lineNum">   17212 </span><span class="lineCov">      41242 :                     i++;</span></a>
<a name="17213"><span class="lineNum">   17213 </span>            :                   }</a>
<a name="17214"><span class="lineNum">   17214 </span>            : </a>
<a name="17215"><span class="lineNum">   17215 </span>            :             // template_name += &quot;&gt; &quot;;</a>
<a name="17216"><span class="lineNum">   17216 </span><span class="lineCov">      20251 :                if (isEmptyTemplateArgumentList == false)</span></a>
<a name="17217"><span class="lineNum">   17217 </span>            :                   {</a>
<a name="17218"><span class="lineNum">   17218 </span><span class="lineCov">      20085 :                     template_name += &quot;&gt; &quot;;</span></a>
<a name="17219"><span class="lineNum">   17219 </span>            :                   }</a>
<a name="17220"><span class="lineNum">   17220 </span>            : </a>
<a name="17221"><span class="lineNum">   17221 </span><span class="lineCov">      20251 :                scope_name = template_name;</span></a>
<a name="17222"><span class="lineNum">   17222 </span>            : </a>
<a name="17223"><span class="lineNum">   17223 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="17224"><span class="lineNum">   17224 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;NAME OF SCOPE: scope name -- template_name = %s \n&quot;,template_name.c_str());</a>
<a name="17225"><span class="lineNum">   17225 </span>            : #endif</a>
<a name="17226"><span class="lineNum">   17226 </span>            : </a>
<a name="17227"><span class="lineNum">   17227 </span>            :             // DQ (2/18/2013): Fixing generation of too many SgUnparse_Info object.</a>
<a name="17228"><span class="lineNum">   17228 </span><span class="lineCov">      20251 :                delete unparseInfoPointer;</span></a>
<a name="17229"><span class="lineNum">   17229 </span>            :              }</a>
<a name="17230"><span class="lineNum">   17230 </span>            :             else</a>
<a name="17231"><span class="lineNum">   17231 </span>            :              {</a>
<a name="17232"><span class="lineNum">   17232 </span>            :             // scope_name = scope-&gt;class_name().c_str();</a>
<a name="17233"><span class="lineNum">   17233 </span><span class="lineCov">     204746 :                scope_name = SageInterface::get_name(scope).c_str();</span></a>
<a name="17234"><span class="lineNum">   17234 </span>            : #if 0</a>
<a name="17235"><span class="lineNum">   17235 </span>            :                printf (&quot;test 8: qualifierString = %s \n&quot;,qualifierString.c_str());</a>
<a name="17236"><span class="lineNum">   17236 </span>            : #endif</a>
<a name="17237"><span class="lineNum">   17237 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="17238"><span class="lineNum">   17238 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Before test for __anonymous_ un-named scopes: scope_name = %s \n&quot;,scope_name.c_str());</a>
<a name="17239"><span class="lineNum">   17239 </span>            : #endif</a>
<a name="17240"><span class="lineNum">   17240 </span>            :             // DQ (4/6/2013): Test this scope name for that of n un-named scope so that we can avoid name qualification</a>
<a name="17241"><span class="lineNum">   17241 </span>            :             // using an internally generated scope name.</a>
<a name="17242"><span class="lineNum">   17242 </span>            :             // Note that the pointer is from an EDG object (e.g. a_type_ptr), so we can't reproduce it in ROSE.</a>
<a name="17243"><span class="lineNum">   17243 </span>            :             // This might be something to fix if we want to be able to reproduce it.</a>
<a name="17244"><span class="lineNum">   17244 </span><span class="lineCov">     409492 :                if (scope_name.substr(0,14) == &quot;__anonymous_0x&quot;)</span></a>
<a name="17245"><span class="lineNum">   17245 </span>            :                   {</a>
<a name="17246"><span class="lineNum">   17246 </span>            :                  // DQ (4/6/2013): Added test (this would be better to added to the AST consistancy tests).</a>
<a name="17247"><span class="lineNum">   17247 </span><span class="lineNoCov">          0 :                     SgClassDefinition* classDefinition = isSgClassDefinition(scope);</span></a>
<a name="17248"><span class="lineNum">   17248 </span><span class="lineNoCov">          0 :                     if (classDefinition != NULL)</span></a>
<a name="17249"><span class="lineNum">   17249 </span>            :                        {</a>
<a name="17250"><span class="lineNum">   17250 </span><span class="lineNoCov">          0 :                          if (classDefinition-&gt;get_declaration()-&gt;get_isUnNamed() == false)</span></a>
<a name="17251"><span class="lineNum">   17251 </span>            :                             {</a>
<a name="17252"><span class="lineNum">   17252 </span>            :                            // DQ (4/11/2017): Klockworks reports that classDeclaration may be NULL, so make sure that adding an assertion will fix the issue.</a>
<a name="17253"><span class="lineNum">   17253 </span><span class="lineNoCov">          0 :                               SgClassDeclaration* classDeclaration = classDefinition-&gt;get_declaration();</span></a>
<a name="17254"><span class="lineNum">   17254 </span><span class="lineNoCov">          0 :                               ASSERT_not_null(classDeclaration);</span></a>
<a name="17255"><span class="lineNum">   17255 </span><span class="lineNoCov">          0 :                               mfprintf(mlog [ WARN ] ) (&quot;Error: class should be marked as unnamed: classDeclaration = %p = %s \n&quot;,classDeclaration,classDeclaration-&gt;class_name().c_str());</span></a>
<a name="17256"><span class="lineNum">   17256 </span><span class="lineNoCov">          0 :                               mfprintf(mlog [ WARN ] ) (&quot;   --- classDeclaration name = %s \n&quot;,classDeclaration-&gt;get_name().str());</span></a>
<a name="17257"><span class="lineNum">   17257 </span>            :                             }</a>
<a name="17258"><span class="lineNum">   17258 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(classDefinition-&gt;get_declaration()-&gt;get_isUnNamed() == true);</span></a>
<a name="17259"><span class="lineNum">   17259 </span>            :                        }</a>
<a name="17260"><span class="lineNum">   17260 </span>            : </a>
<a name="17261"><span class="lineNum">   17261 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="17262"><span class="lineNum">   17262 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualificationSupport(): Detected scope_name of un-named scope: scope_name = %s (reset to empty string for name qualification) \n&quot;,scope_name.c_str());</a>
<a name="17263"><span class="lineNum">   17263 </span>            : #endif</a>
<a name="17264"><span class="lineNum">   17264 </span><span class="lineNoCov">          0 :                     scope_name = &quot;&quot;;</span></a>
<a name="17265"><span class="lineNum">   17265 </span>            : </a>
<a name="17266"><span class="lineNum">   17266 </span>            :                  // DQ (5/3/2013): If this case was detected then we can't use the qualified name.</a>
<a name="17267"><span class="lineNum">   17267 </span>            :                  // The test2013_145.C demonstrates this case where one part of the name qualification</a>
<a name="17268"><span class="lineNum">   17268 </span>            :                  // is empty string (unnamed scope, specifically a union in the test code).</a>
<a name="17269"><span class="lineNum">   17269 </span><span class="lineNoCov">          0 :                     qualifierString = &quot;&quot;;</span></a>
<a name="17270"><span class="lineNum">   17270 </span>            : </a>
<a name="17271"><span class="lineNum">   17271 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="17272"><span class="lineNum">   17272 </span>            :                  // mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualificationSupport(): Exiting loop prematurely... \n&quot;);</a>
<a name="17273"><span class="lineNum">   17273 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualificationSupport(): skip over this un-named declaration in the generation of the more complete qualified name... \n&quot;);</a>
<a name="17274"><span class="lineNum">   17274 </span>            : #endif</a>
<a name="17275"><span class="lineNum">   17275 </span>            :                  // DQ (4/14/2019): If there is an un-named declaration we just want to not use that name, but</a>
<a name="17276"><span class="lineNum">   17276 </span>            :                  // we want to continue to iterate to collect the associated scopes to build the qualified name.</a>
<a name="17277"><span class="lineNum">   17277 </span>            :                  // Note that Cxx11_tests/test2019_373.C is an example where this is required.</a>
<a name="17278"><span class="lineNum">   17278 </span>            :                  // break;</a>
<a name="17279"><span class="lineNum">   17279 </span>            :                   }</a>
<a name="17280"><span class="lineNum">   17280 </span>            :                  else</a>
<a name="17281"><span class="lineNum">   17281 </span>            :                   {</a>
<a name="17282"><span class="lineNum">   17282 </span>            :                  // DQ (4/6/2013): Added test (this would be better to add to the AST consistancy tests).</a>
<a name="17283"><span class="lineNum">   17283 </span>            :                  // ROSE_ASSERT(scope-&gt;get_isUnNamed() == false);</a>
<a name="17284"><span class="lineNum">   17284 </span>            : #if 0</a>
<a name="17285"><span class="lineNum">   17285 </span>            :                     printf (&quot;test 9: qualifierString = %s \n&quot;,qualifierString.c_str());</a>
<a name="17286"><span class="lineNum">   17286 </span>            : #endif</a>
<a name="17287"><span class="lineNum">   17287 </span><span class="lineCov">     204746 :                     SgNamespaceDefinitionStatement* namespaceDefinition = isSgNamespaceDefinitionStatement(scope);</span></a>
<a name="17288"><span class="lineNum">   17288 </span><span class="lineCov">     204746 :                     if (namespaceDefinition != NULL)</span></a>
<a name="17289"><span class="lineNum">   17289 </span>            :                        {</a>
<a name="17290"><span class="lineNum">   17290 </span>            : #if 0</a>
<a name="17291"><span class="lineNum">   17291 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualificationSupport(): Detected a SgNamespaceDefinition: namespaceDefinition = %p \n&quot;,namespaceDefinition);</a>
<a name="17292"><span class="lineNum">   17292 </span>            : #endif</a>
<a name="17293"><span class="lineNum">   17293 </span>            : </a>
<a name="17294"><span class="lineNum">   17294 </span><span class="lineCov">      76891 :                          SgNamespaceDeclarationStatement* namespaceDeclaration = isSgNamespaceDeclarationStatement(namespaceDefinition-&gt;get_namespaceDeclaration());</span></a>
<a name="17295"><span class="lineNum">   17295 </span><span class="lineCov">      76891 :                          ASSERT_not_null(namespaceDeclaration);</span></a>
<a name="17296"><span class="lineNum">   17296 </span><span class="lineCov">      76891 :                          if (namespaceDeclaration-&gt;get_isUnnamedNamespace() == true)</span></a>
<a name="17297"><span class="lineNum">   17297 </span>            :                             {</a>
<a name="17298"><span class="lineNum">   17298 </span>            : #if 0</a>
<a name="17299"><span class="lineNum">   17299 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualificationSupport(): found un-named namespace: namespaceDefinition = %p \n&quot;,namespaceDefinition);</a>
<a name="17300"><span class="lineNum">   17300 </span>            : #endif</a>
<a name="17301"><span class="lineNum">   17301 </span>            :                               skip_over_scope = true;</a>
<a name="17302"><span class="lineNum">   17302 </span>            :                             }</a>
<a name="17303"><span class="lineNum">   17303 </span>            :                            else</a>
<a name="17304"><span class="lineNum">   17304 </span>            :                             {</a>
<a name="17305"><span class="lineNum">   17305 </span>            :                            // DQ (8/1/2020): Adding support for references to the NamespaceAlias (required for new failing test code).</a>
<a name="17306"><span class="lineNum">   17306 </span>            : #if 0</a>
<a name="17307"><span class="lineNum">   17307 </span>            :                               printf (&quot;Adding support for references to the NamespaceAlias \n&quot;);</a>
<a name="17308"><span class="lineNum">   17308 </span>            : #endif</a>
<a name="17309"><span class="lineNum">   17309 </span>            :                            // DQ (8/1/2020): This should always be true.</a>
<a name="17310"><span class="lineNum">   17310 </span>            :                            // ROSE_ASSERT(namespaceAliasDeclarationMapFromInheritedAttribute != NULL);</a>
<a name="17311"><span class="lineNum">   17311 </span>            : #if 0</a>
<a name="17312"><span class="lineNum">   17312 </span>            :                            // printf (&quot;namespaceAliasDeclarationMapFromInheritedAttribute-&gt;size() = %zu \n&quot;,namespaceAliasDeclarationMapFromInheritedAttribute-&gt;size());</a>
<a name="17313"><span class="lineNum">   17313 </span>            :                               printf (&quot;namespaceAliasDeclarationMap.size() = %zu \n&quot;,namespaceAliasDeclarationMap.size());</a>
<a name="17314"><span class="lineNum">   17314 </span>            : #endif</a>
<a name="17315"><span class="lineNum">   17315 </span>            :                            // if (namespaceAliasDeclarationMapFromInheritedAttribute-&gt;find(namespaceDeclaration) != namespaceAliasDeclarationMapFromInheritedAttribute-&gt;end())</a>
<a name="17316"><span class="lineNum">   17316 </span><span class="lineCov">     153782 :                               if (namespaceAliasDeclarationMap.find(namespaceDeclaration) != namespaceAliasDeclarationMap.end())</span></a>
<a name="17317"><span class="lineNum">   17317 </span>            :                                  {</a>
<a name="17318"><span class="lineNum">   17318 </span>            :                                 // SgDeclarationStatement* declaration = namespaceAliasDeclarationMapFromInheritedAttribute-&gt;operator[](namespaceDeclaration);</a>
<a name="17319"><span class="lineNum">   17319 </span>            :                                 // SgDeclarationStatement* declaration = namespaceAliasDeclarationMap[namespaceDeclaration];</a>
<a name="17320"><span class="lineNum">   17320 </span><span class="lineNoCov">          0 :                                    SgNamespaceAliasDeclarationStatement* namespaceAliasDeclaration = namespaceAliasDeclarationMap[namespaceDeclaration];</span></a>
<a name="17321"><span class="lineNum">   17321 </span><span class="lineNoCov">          0 :                                    ROSE_ASSERT(namespaceAliasDeclaration != NULL);</span></a>
<a name="17322"><span class="lineNum">   17322 </span>            : #if 0</a>
<a name="17323"><span class="lineNum">   17323 </span>            :                                    printf (&quot;test 10: qualifierString = %s \n&quot;,qualifierString.c_str());</a>
<a name="17324"><span class="lineNum">   17324 </span>            : #endif</a>
<a name="17325"><span class="lineNum">   17325 </span>            :                                 // qualifierString = &quot; /* use the namspace alias */ &quot;;</a>
<a name="17326"><span class="lineNum">   17326 </span>            : </a>
<a name="17327"><span class="lineNum">   17327 </span>            :                                 // DQ (8/2/2020): Reset the name of the scope.</a>
<a name="17328"><span class="lineNum">   17328 </span><span class="lineNoCov">          0 :                                    scope_name = namespaceAliasDeclaration-&gt;get_name();</span></a>
<a name="17329"><span class="lineNum">   17329 </span>            : </a>
<a name="17330"><span class="lineNum">   17330 </span><span class="lineNoCov">          0 :                                    breakOutOfLoop = true;</span></a>
<a name="17331"><span class="lineNum">   17331 </span>            : #if 0</a>
<a name="17332"><span class="lineNum">   17332 </span>            :                                    printf (&quot;Exiting as a test! \n&quot;);</a>
<a name="17333"><span class="lineNum">   17333 </span>            :                                    ROSE_ABORT();</a>
<a name="17334"><span class="lineNum">   17334 </span>            : #endif</a>
<a name="17335"><span class="lineNum">   17335 </span>            :                                  }</a>
<a name="17336"><span class="lineNum">   17336 </span>            : #if 0</a>
<a name="17337"><span class="lineNum">   17337 </span>            :                               printf (&quot;Exiting as a test! \n&quot;);</a>
<a name="17338"><span class="lineNum">   17338 </span>            :                               ROSE_ABORT();</a>
<a name="17339"><span class="lineNum">   17339 </span>            : #endif</a>
<a name="17340"><span class="lineNum">   17340 </span>            :                             }</a>
<a name="17341"><span class="lineNum">   17341 </span>            :                        }</a>
<a name="17342"><span class="lineNum">   17342 </span>            :                       else</a>
<a name="17343"><span class="lineNum">   17343 </span>            :                        {</a>
<a name="17344"><span class="lineNum">   17344 </span>            :                       // DQ (9/7/2014): Added case for template class definitions (which we were not using and thus</a>
<a name="17345"><span class="lineNum">   17345 </span>            :                       // it was not a problem that we didn't compute them quite right).  These were being computed</a>
<a name="17346"><span class="lineNum">   17346 </span>            :                       // as &quot;class-name::class-name&quot;, but we need then to be computed to be:</a>
<a name="17347"><span class="lineNum">   17347 </span>            :                       // &quot;class-name&lt;template-parameter&gt;::class-name&lt;template-parameter&gt;&quot; instead.</a>
<a name="17348"><span class="lineNum">   17348 </span>            :                       // Other logic will have to add the template header where these are used (not clear how to</a>
<a name="17349"><span class="lineNum">   17349 </span>            :                       // do that if we don't do it here).</a>
<a name="17350"><span class="lineNum">   17350 </span><span class="lineCov">     127855 :                          SgTemplateClassDefinition* templateClassDefinition = isSgTemplateClassDefinition(scope);</span></a>
<a name="17351"><span class="lineNum">   17351 </span><span class="lineCov">     127855 :                          if (templateClassDefinition != NULL)</span></a>
<a name="17352"><span class="lineNum">   17352 </span>            :                             {</a>
<a name="17353"><span class="lineNum">   17353 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="17354"><span class="lineNum">   17354 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualificationSupport(): Found SgTemplateClassDefinition: templateClassDefinition = %p = %s \n&quot;,templateClassDefinition,templateClassDefinition-&gt;class_name().c_str());</a>
<a name="17355"><span class="lineNum">   17355 </span>            : #endif</a>
<a name="17356"><span class="lineNum">   17356 </span><span class="lineCov">      12314 :                               SgTemplateClassDeclaration* templateClassDeclaration = templateClassDefinition-&gt;get_declaration();</span></a>
<a name="17357"><span class="lineNum">   17357 </span><span class="lineCov">      12314 :                               ASSERT_not_null(templateClassDeclaration);</span></a>
<a name="17358"><span class="lineNum">   17358 </span>            : </a>
<a name="17359"><span class="lineNum">   17359 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="17360"><span class="lineNum">   17360 </span>            :                            // This is the normalized name (without name qualification for internal template arguments)</a>
<a name="17361"><span class="lineNum">   17361 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualificationSupport(): templateClassDeclaration-&gt;get_name()          = %s \n&quot;,templateClassDeclaration-&gt;get_name().str());</a>
<a name="17362"><span class="lineNum">   17362 </span>            : </a>
<a name="17363"><span class="lineNum">   17363 </span>            :                            // This is the name of the template (without and internal template arguments)</a>
<a name="17364"><span class="lineNum">   17364 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualificationSupport(): templateClassDeclaration-&gt;get_templateName() = %s \n&quot;,templateClassDeclaration-&gt;get_templateName().str());</a>
<a name="17365"><span class="lineNum">   17365 </span>            : #endif</a>
<a name="17366"><span class="lineNum">   17366 </span>            : </a>
<a name="17367"><span class="lineNum">   17367 </span><span class="lineCov">      12314 :                               SgUnparse_Info* unparseInfoPointer = new SgUnparse_Info();</span></a>
<a name="17368"><span class="lineNum">   17368 </span><span class="lineCov">      12314 :                               ASSERT_not_null(unparseInfoPointer);</span></a>
<a name="17369"><span class="lineNum">   17369 </span><span class="lineCov">      12314 :                               unparseInfoPointer-&gt;set_outputCompilerGeneratedStatements();</span></a>
<a name="17370"><span class="lineNum">   17370 </span>            : </a>
<a name="17371"><span class="lineNum">   17371 </span>            :                            // templateClassDeclaration-&gt;get_file_info()-&gt;display(&quot;SgTemplateInstantiationDecl trying to generate the qualified name: debug&quot;);</a>
<a name="17372"><span class="lineNum">   17372 </span>            : </a>
<a name="17373"><span class="lineNum">   17373 </span><span class="lineCov">      24628 :                               string template_name = templateClassDeclaration-&gt;get_templateName();</span></a>
<a name="17374"><span class="lineNum">   17374 </span>            : </a>
<a name="17375"><span class="lineNum">   17375 </span>            :                            // DQ (9/12/2014): If we have template specialization arguments then we wnat to use these instead of the template parameters (I think).</a>
<a name="17376"><span class="lineNum">   17376 </span>            :                            // See test2014_222.C for an example.</a>
<a name="17377"><span class="lineNum">   17377 </span><span class="lineCov">      12314 :                               SgTemplateArgumentPtrList &amp; templateSpecializationArgumentList = templateClassDeclaration-&gt;get_templateSpecializationArguments();</span></a>
<a name="17378"><span class="lineNum">   17378 </span>            : #if 0</a>
<a name="17379"><span class="lineNum">   17379 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;templateSpecializationArgumentList.size() = %zu \n&quot;,templateSpecializationArgumentList.size());</a>
<a name="17380"><span class="lineNum">   17380 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;specialization = %d \n&quot;,templateClassDeclaration-&gt;get_specialization());</a>
<a name="17381"><span class="lineNum">   17381 </span>            : #endif</a>
<a name="17382"><span class="lineNum">   17382 </span><span class="lineCov">      12314 :                               if (templateSpecializationArgumentList.empty() == false)</span></a>
<a name="17383"><span class="lineNum">   17383 </span>            :                                  {</a>
<a name="17384"><span class="lineNum">   17384 </span>            :                                 // DQ (9/13/2014): I have build overloaded versions of globalUnparseToString() to handle that case of SgTemplateArgumentPtrList.</a>
<a name="17385"><span class="lineNum">   17385 </span><span class="lineCov">       1084 :                                    string template_specialization_argument_list_string = globalUnparseToString(&amp;templateSpecializationArgumentList,unparseInfoPointer);</span></a>
<a name="17386"><span class="lineNum">   17386 </span>            : #if 0</a>
<a name="17387"><span class="lineNum">   17387 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;template_specialization_argument_list_string = %s \n&quot;,template_specialization_argument_list_string.c_str());</a>
<a name="17388"><span class="lineNum">   17388 </span>            : #endif</a>
<a name="17389"><span class="lineNum">   17389 </span><span class="lineCov">        542 :                                    template_name += template_specialization_argument_list_string;</span></a>
<a name="17390"><span class="lineNum">   17390 </span>            :                                  }</a>
<a name="17391"><span class="lineNum">   17391 </span>            :                                 else</a>
<a name="17392"><span class="lineNum">   17392 </span>            :                                  {</a>
<a name="17393"><span class="lineNum">   17393 </span>            :                              // DQ (9/9/2014): Modified to support empty name template parameter lists as what appear if none are present</a>
<a name="17394"><span class="lineNum">   17394 </span>            :                              // (and this is a non-template function in a template class which we consider to be a template function</a>
<a name="17395"><span class="lineNum">   17395 </span>            :                              // because it can be instantiated).</a>
<a name="17396"><span class="lineNum">   17396 </span><span class="lineCov">      11772 :                                 SgTemplateParameterPtrList &amp; templateParameterList = templateClassDeclaration-&gt;get_templateParameters();</span></a>
<a name="17397"><span class="lineNum">   17397 </span><span class="lineCov">      11772 :                                 if (templateParameterList.empty() == false)</span></a>
<a name="17398"><span class="lineNum">   17398 </span>            :                                    {</a>
<a name="17399"><span class="lineNum">   17399 </span>            :                                   // DQ (9/13/2014): I have build overloaded versions of globalUnparseToString() to handle that case of SgTemplateParameterPtrList.</a>
<a name="17400"><span class="lineNum">   17400 </span><span class="lineCov">      23388 :                                      string template_parameter_list_string = globalUnparseToString(&amp;templateParameterList,unparseInfoPointer);</span></a>
<a name="17401"><span class="lineNum">   17401 </span><span class="lineCov">      11694 :                                      template_name += template_parameter_list_string;</span></a>
<a name="17402"><span class="lineNum">   17402 </span>            :                                    }</a>
<a name="17403"><span class="lineNum">   17403 </span>            :                                  }</a>
<a name="17404"><span class="lineNum">   17404 </span>            : </a>
<a name="17405"><span class="lineNum">   17405 </span><span class="lineCov">      12314 :                               scope_name = template_name;</span></a>
<a name="17406"><span class="lineNum">   17406 </span>            : </a>
<a name="17407"><span class="lineNum">   17407 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="17408"><span class="lineNum">   17408 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;setNameQualificationSupport(): case of SgTemplateClassDefinition: scope_name = %s \n&quot;,scope_name.c_str());</a>
<a name="17409"><span class="lineNum">   17409 </span>            : #endif</a>
<a name="17410"><span class="lineNum">   17410 </span>            : #if 0</a>
<a name="17411"><span class="lineNum">   17411 </span>            :                               mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="17412"><span class="lineNum">   17412 </span>            :                               ROSE_ABORT();</a>
<a name="17413"><span class="lineNum">   17413 </span>            : #endif</a>
<a name="17414"><span class="lineNum">   17414 </span>            :                             }</a>
<a name="17415"><span class="lineNum">   17415 </span>            :                            else</a>
<a name="17416"><span class="lineNum">   17416 </span>            :                             {</a>
<a name="17417"><span class="lineNum">   17417 </span>            :                            // DQ (4/27/2019): Need to add case for SgClassDefinition, to support test2019_102.C.</a>
<a name="17418"><span class="lineNum">   17418 </span><span class="lineCov">     115541 :                               SgClassDefinition* classDefinition = isSgClassDefinition(scope);</span></a>
<a name="17419"><span class="lineNum">   17419 </span>            :                               if (classDefinition != NULL)</a>
<a name="17420"><span class="lineNum">   17420 </span>            :                                  {</a>
<a name="17421"><span class="lineNum">   17421 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="17422"><span class="lineNum">   17422 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualificationSupport(): Found SgClassDefinition: classDefinition = %p = %s \n&quot;,classDefinition,classDefinition-&gt;class_name().c_str());</a>
<a name="17423"><span class="lineNum">   17423 </span>            : #endif</a>
<a name="17424"><span class="lineNum">   17424 </span>            : #if 0</a>
<a name="17425"><span class="lineNum">   17425 </span>            :                                 // DQ (4/27/2019): Look into this in the morning.</a>
<a name="17426"><span class="lineNum">   17426 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;\n\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ \n&quot;);</a>
<a name="17427"><span class="lineNum">   17427 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;Unclear what do do for this case! \n&quot;);</a>
<a name="17428"><span class="lineNum">   17428 </span>            :                                    mfprintf(mlog [ WARN ] ) (&quot;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ \n\n\n&quot;);</a>
<a name="17429"><span class="lineNum">   17429 </span>            : #endif</a>
<a name="17430"><span class="lineNum">   17430 </span>            :                                  }</a>
<a name="17431"><span class="lineNum">   17431 </span>            :                             }</a>
<a name="17432"><span class="lineNum">   17432 </span>            :                        }</a>
<a name="17433"><span class="lineNum">   17433 </span>            : #if 0</a>
<a name="17434"><span class="lineNum">   17434 </span>            :                     printf (&quot;test 11: qualifierString = %s \n&quot;,qualifierString.c_str());</a>
<a name="17435"><span class="lineNum">   17435 </span>            : #endif</a>
<a name="17436"><span class="lineNum">   17436 </span>            :                  // DQ (2/13/2019): Detect error in use of un-named scope (e.g. SgBasicBlock).</a>
<a name="17437"><span class="lineNum">   17437 </span>            :                  // if (scope_name.substr(0,2) == &quot;0x&quot;)</a>
<a name="17438"><span class="lineNum">   17438 </span><span class="lineCov">     409492 :                     if (scope_name.substr(0,2) == &quot;0x&quot; &amp;&amp; isSgGlobal(scope) == NULL)</span></a>
<a name="17439"><span class="lineNum">   17439 </span>            :                        {</a>
<a name="17440"><span class="lineNum">   17440 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || 0</a>
<a name="17441"><span class="lineNum">   17441 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;WARNING: Detected scope name generated from pointer: i = %d scope = %p = %s skip_over_scope = %s \n&quot;,i,scope,scope-&gt;class_name().c_str(),skip_over_scope ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="17442"><span class="lineNum">   17442 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot; --- qualifierString = %s \n&quot;,qualifierString.c_str());</a>
<a name="17443"><span class="lineNum">   17443 </span>            : #endif</a>
<a name="17444"><span class="lineNum">   17444 </span><span class="lineCov">      26620 :                          skip_over_scope = true;</span></a>
<a name="17445"><span class="lineNum">   17445 </span>            : #if 0</a>
<a name="17446"><span class="lineNum">   17446 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="17447"><span class="lineNum">   17447 </span>            :                          ROSE_ABORT();</a>
<a name="17448"><span class="lineNum">   17448 </span>            : #endif</a>
<a name="17449"><span class="lineNum">   17449 </span>            :                        }</a>
<a name="17450"><span class="lineNum">   17450 </span>            :                   }</a>
<a name="17451"><span class="lineNum">   17451 </span>            :              }</a>
<a name="17452"><span class="lineNum">   17452 </span>            : </a>
<a name="17453"><span class="lineNum">   17453 </span><span class="lineCov">     224997 :           SgDeclarationScope * decl_scope = isSgDeclarationScope(scope);</span></a>
<a name="17454"><span class="lineNum">   17454 </span><span class="lineCov">     224997 :           if (decl_scope != NULL) {</span></a>
<a name="17455"><span class="lineNum">   17455 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="17456"><span class="lineNum">   17456 </span>            :             mfprintf(mlog [ WARN ] ) (&quot;setNameQualificationSupport(): case of SgDeclarationScope:\n&quot;);</a>
<a name="17457"><span class="lineNum">   17457 </span>            :             mfprintf(mlog [ WARN ] ) (&quot; --- scope_name         = %s \n&quot;,scope_name.c_str());</a>
<a name="17458"><span class="lineNum">   17458 </span>            :             mfprintf(mlog [ WARN ] ) (&quot; --- scope-&gt;get_scope() = %p (%s) \n&quot;, scope-&gt;get_scope(), scope-&gt;get_scope() != NULL ? scope-&gt;get_scope()-&gt;class_name().c_str() : &quot;&quot;);</a>
<a name="17459"><span class="lineNum">   17459 </span>            :             mfprintf(mlog [ WARN ] ) (&quot; --- scope-&gt;get_parent() = %p (%s) \n&quot;, scope-&gt;get_parent(), scope-&gt;get_parent() != NULL ? scope-&gt;get_parent()-&gt;class_name().c_str() : &quot;&quot;);</a>
<a name="17460"><span class="lineNum">   17460 </span>            : //          ROSE_ASSERT(false);</a>
<a name="17461"><span class="lineNum">   17461 </span>            : #endif</a>
<a name="17462"><span class="lineNum">   17462 </span>            :           }</a>
<a name="17463"><span class="lineNum">   17463 </span>            : </a>
<a name="17464"><span class="lineNum">   17464 </span><span class="lineCov">     224997 :           SgGlobal* globalScope = isSgGlobal(scope);</span></a>
<a name="17465"><span class="lineNum">   17465 </span><span class="lineCov">     224997 :           if (globalScope != NULL)</span></a>
<a name="17466"><span class="lineNum">   17466 </span>            :              {</a>
<a name="17467"><span class="lineNum">   17467 </span>            :             // If we have iterated beyond the number of nested scopes, then set the global</a>
<a name="17468"><span class="lineNum">   17468 </span>            :             // qualification and reduce the name_qualification_length correspondingly by one.</a>
<a name="17469"><span class="lineNum">   17469 </span>            : </a>
<a name="17470"><span class="lineNum">   17470 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="17471"><span class="lineNum">   17471 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;!!!!! We have iterated beyond the number of nested scopes: setting outputGlobalQualification == true \n&quot;);</a>
<a name="17472"><span class="lineNum">   17472 </span>            : #endif</a>
<a name="17473"><span class="lineNum">   17473 </span><span class="lineCov">      80902 :                outputGlobalQualification = true;</span></a>
<a name="17474"><span class="lineNum">   17474 </span><span class="lineCov">      80902 :                output_amountOfNameQualificationRequired = inputNameQualificationLength-1;</span></a>
<a name="17475"><span class="lineNum">   17475 </span>            : </a>
<a name="17476"><span class="lineNum">   17476 </span><span class="lineCov">      80902 :                scope_name = &quot;::&quot;;</span></a>
<a name="17477"><span class="lineNum">   17477 </span>            :              }</a>
<a name="17478"><span class="lineNum">   17478 </span>            : </a>
<a name="17479"><span class="lineNum">   17479 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="17480"><span class="lineNum">   17480 </span>            :           mfprintf(mlog [ WARN ] ) (&quot; --- scope_name = %s skip_over_scope = %s \n&quot;,scope_name.c_str(),skip_over_scope ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="17481"><span class="lineNum">   17481 </span>            : #endif</a>
<a name="17482"><span class="lineNum">   17482 </span>            : </a>
<a name="17483"><span class="lineNum">   17483 </span><span class="lineCov">     224997 :           if (skip_over_scope == false)</span></a>
<a name="17484"><span class="lineNum">   17484 </span>            :              {</a>
<a name="17485"><span class="lineNum">   17485 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="17486"><span class="lineNum">   17486 </span>            :                mfprintf(mlog [ WARN ] ) (&quot; --- outputGlobalQualification = %s \n&quot;,outputGlobalQualification ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="17487"><span class="lineNum">   17487 </span>            : #endif</a>
<a name="17488"><span class="lineNum">   17488 </span>            : #if 0</a>
<a name="17489"><span class="lineNum">   17489 </span>            :                printf (&quot;test 12: qualifierString = %s \n&quot;,qualifierString.c_str());</a>
<a name="17490"><span class="lineNum">   17490 </span>            : #endif</a>
<a name="17491"><span class="lineNum">   17491 </span>            :             // qualifierString = scope_name + &quot;::&quot; + qualifierString;</a>
<a name="17492"><span class="lineNum">   17492 </span><span class="lineCov">     198377 :                if (outputGlobalQualification == true)</span></a>
<a name="17493"><span class="lineNum">   17493 </span>            :                   {</a>
<a name="17494"><span class="lineNum">   17494 </span>            :                  // Avoid out put of &quot;::::&quot; as substrings.</a>
<a name="17495"><span class="lineNum">   17495 </span><span class="lineCov">      80902 :                     qualifierString = &quot;::&quot; + qualifierString;</span></a>
<a name="17496"><span class="lineNum">   17496 </span>            :                   }</a>
<a name="17497"><span class="lineNum">   17497 </span>            :                  else</a>
<a name="17498"><span class="lineNum">   17498 </span>            :                   {</a>
<a name="17499"><span class="lineNum">   17499 </span>            :                  // qualifierString = scope_name + &quot;::&quot; + qualifierString;</a>
<a name="17500"><span class="lineNum">   17500 </span><span class="lineCov">     117475 :                     if (scope_name.length() == 0)</span></a>
<a name="17501"><span class="lineNum">   17501 </span>            :                        {</a>
<a name="17502"><span class="lineNum">   17502 </span>            :                       // Nothing to do for this case of an empty string for a scope name (see test2006_121.C, using an un-named namespace).</a>
<a name="17503"><span class="lineNum">   17503 </span>            :                        }</a>
<a name="17504"><span class="lineNum">   17504 </span>            :                       else</a>
<a name="17505"><span class="lineNum">   17505 </span>            :                        {</a>
<a name="17506"><span class="lineNum">   17506 </span>            : #if 0</a>
<a name="17507"><span class="lineNum">   17507 </span>            :                          printf (&quot;test 13: qualifierString = %s \n&quot;,qualifierString.c_str());</a>
<a name="17508"><span class="lineNum">   17508 </span>            : #endif</a>
<a name="17509"><span class="lineNum">   17509 </span><span class="lineCov">     140840 :                          qualifierString = scope_name + &quot;::&quot; + qualifierString;</span></a>
<a name="17510"><span class="lineNum">   17510 </span>            : #if 0</a>
<a name="17511"><span class="lineNum">   17511 </span>            :                          printf (&quot;test 14: qualifierString = %s \n&quot;,qualifierString.c_str());</a>
<a name="17512"><span class="lineNum">   17512 </span>            : #endif</a>
<a name="17513"><span class="lineNum">   17513 </span>            :                        }</a>
<a name="17514"><span class="lineNum">   17514 </span>            :                   }</a>
<a name="17515"><span class="lineNum">   17515 </span>            :              }</a>
<a name="17516"><span class="lineNum">   17516 </span>            :             else</a>
<a name="17517"><span class="lineNum">   17517 </span>            :              {</a>
<a name="17518"><span class="lineNum">   17518 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="17519"><span class="lineNum">   17519 </span>            :                mfprintf(mlog [ WARN ] ) (&quot; --- Case of skip_over_scope == true!\n&quot;);</a>
<a name="17520"><span class="lineNum">   17520 </span>            : #endif</a>
<a name="17521"><span class="lineNum">   17521 </span>            :              }</a>
<a name="17522"><span class="lineNum">   17522 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="17523"><span class="lineNum">   17523 </span>            :                mfprintf(mlog [ WARN ] ) (&quot; --- qualifierString = %s \n&quot;,qualifierString.c_str());</a>
<a name="17524"><span class="lineNum">   17524 </span>            : #endif</a>
<a name="17525"><span class="lineNum">   17525 </span><span class="lineCov">     224997 :           if (globalScope != NULL) break;</span></a>
<a name="17526"><span class="lineNum">   17526 </span>            : </a>
<a name="17527"><span class="lineNum">   17527 </span>            :        // We have to loop over scopes that are not named scopes!</a>
<a name="17528"><span class="lineNum">   17528 </span><span class="lineCov">     144095 :           scope = scope-&gt;get_scope();</span></a>
<a name="17529"><span class="lineNum">   17529 </span>            : </a>
<a name="17530"><span class="lineNum">   17530 </span><span class="lineCov">     144095 :           if (breakOutOfLoop == true)</span></a>
<a name="17531"><span class="lineNum">   17531 </span>            :              {</a>
<a name="17532"><span class="lineNum">   17532 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) &amp;&amp; 0</a>
<a name="17533"><span class="lineNum">   17533 </span>            :                printf (&quot;breakOutOfLoop == true: short curcuit this loop over the name qualification depth (becasue we used a namespace alias) \n&quot;);</a>
<a name="17534"><span class="lineNum">   17534 </span>            : #endif</a>
<a name="17535"><span class="lineNum">   17535 </span>            :                break;</a>
<a name="17536"><span class="lineNum">   17536 </span>            :              }</a>
<a name="17537"><span class="lineNum">   17537 </span>            : </a>
<a name="17538"><span class="lineNum">   17538 </span>            :         }</a>
<a name="17539"><span class="lineNum">   17539 </span>            : </a>
<a name="17540"><span class="lineNum">   17540 </span>            : #if 0</a>
<a name="17541"><span class="lineNum">   17541 </span>            :      printf (&quot;test 15: qualifierString = %s \n&quot;,qualifierString.c_str());</a>
<a name="17542"><span class="lineNum">   17542 </span>            : #endif</a>
<a name="17543"><span class="lineNum">   17543 </span>            : #if 0</a>
<a name="17544"><span class="lineNum">   17544 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setNameQualificationSupport(): After loop over name qualifiction depth: inputNameQualificationLength = %d \n&quot;,inputNameQualificationLength);</a>
<a name="17545"><span class="lineNum">   17545 </span>            : #endif</a>
<a name="17546"><span class="lineNum">   17546 </span>            : </a>
<a name="17547"><span class="lineNum">   17547 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) &amp;&amp; 0</a>
<a name="17548"><span class="lineNum">   17548 </span>            :      printf (&quot;$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ \n&quot;);</a>
<a name="17549"><span class="lineNum">   17549 </span>            :      printf (&quot;$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ \n&quot;);</a>
<a name="17550"><span class="lineNum">   17550 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;Leaving NameQualificationTraversal::setNameQualificationSupport(): outputGlobalQualification = %s output_amountOfNameQualificationRequired = %d qualifierString = %s \n&quot;,</a>
<a name="17551"><span class="lineNum">   17551 </span>            :           outputGlobalQualification ? &quot;true&quot; : &quot;false&quot;,output_amountOfNameQualificationRequired,qualifierString.c_str());</a>
<a name="17552"><span class="lineNum">   17552 </span>            :      printf (&quot;$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ \n&quot;);</a>
<a name="17553"><span class="lineNum">   17553 </span>            :      printf (&quot;$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ \n&quot;);</a>
<a name="17554"><span class="lineNum">   17554 </span>            : #endif</a>
<a name="17555"><span class="lineNum">   17555 </span>            : </a>
<a name="17556"><span class="lineNum">   17556 </span>            :   // DQ (6/12/2011): Make sure we have not generated a qualified name with &quot;::::&quot; because of an scope translated to an empty name.</a>
<a name="17557"><span class="lineNum">   17557 </span><span class="lineCov">    1620630 :      ROSE_ASSERT(qualifierString.find(&quot;::::&quot;) == string::npos);</span></a>
<a name="17558"><span class="lineNum">   17558 </span>            : </a>
<a name="17559"><span class="lineNum">   17559 </span>            :   // DQ (6/23/2011): Never generate a qualified name from a pointer value.</a>
<a name="17560"><span class="lineNum">   17560 </span>            :   // This is a bug in the inlining support where the symbol tables are not setup just right.</a>
<a name="17561"><span class="lineNum">   17561 </span><span class="lineCov">    3241270 :      if (qualifierString.substr(0,2) == &quot;0x&quot;)</span></a>
<a name="17562"><span class="lineNum">   17562 </span>            :         {</a>
<a name="17563"><span class="lineNum">   17563 </span>            : // #ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION</a>
<a name="17564"><span class="lineNum">   17564 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="17565"><span class="lineNum">   17565 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;WARNING: Detected qualified name generated from pointer value 0x..., reset to empty string (inlining does not fixup symbol tables) \n&quot;);</a>
<a name="17566"><span class="lineNum">   17566 </span>            : #endif</a>
<a name="17567"><span class="lineNum">   17567 </span><span class="lineNoCov">          0 :           qualifierString = &quot;&quot;;</span></a>
<a name="17568"><span class="lineNum">   17568 </span>            :         }</a>
<a name="17569"><span class="lineNum">   17569 </span><span class="lineCov">    3241270 :      ROSE_ASSERT(qualifierString.substr(0,2) != &quot;0x&quot;);</span></a>
<a name="17570"><span class="lineNum">   17570 </span>            : </a>
<a name="17571"><span class="lineNum">   17571 </span>            : #if 0</a>
<a name="17572"><span class="lineNum">   17572 </span>            :   // DQ (8/1/2020): Debugging namespace alias name qualification.</a>
<a name="17573"><span class="lineNum">   17573 </span>            :      if (inputNameQualificationLength &gt; 0)</a>
<a name="17574"><span class="lineNum">   17574 </span>            :         {</a>
<a name="17575"><span class="lineNum">   17575 </span>            :           printf (&quot;Exiting as a test! \n&quot;);</a>
<a name="17576"><span class="lineNum">   17576 </span>            :           ROSE_ABORT();</a>
<a name="17577"><span class="lineNum">   17577 </span>            :         }</a>
<a name="17578"><span class="lineNum">   17578 </span>            : #endif</a>
<a name="17579"><span class="lineNum">   17579 </span>            : </a>
<a name="17580"><span class="lineNum">   17580 </span>            : #if 0</a>
<a name="17581"><span class="lineNum">   17581 </span>            :      printf (&quot;test 16: qualifierString = %s \n&quot;,qualifierString.c_str());</a>
<a name="17582"><span class="lineNum">   17582 </span>            : #endif</a>
<a name="17583"><span class="lineNum">   17583 </span>            : </a>
<a name="17584"><span class="lineNum">   17584 </span><span class="lineCov">    1620630 :      return qualifierString;</span></a>
<a name="17585"><span class="lineNum">   17585 </span>            :    }</a>
<a name="17586"><span class="lineNum">   17586 </span>            : </a>
<a name="17587"><span class="lineNum">   17587 </span>            : string</a>
<a name="17588"><span class="lineNum">   17588 </span><span class="lineCov">       8511 : NameQualificationTraversal::setTemplateHeaderNameQualificationSupport(SgScopeStatement* scope, const int inputNameQualificationLength )</span></a>
<a name="17589"><span class="lineNum">   17589 </span>            :    {</a>
<a name="17590"><span class="lineNum">   17590 </span>            :   // DQ (9/7/2014): This function generates a string that is used with name qualification of template declarations.</a>
<a name="17591"><span class="lineNum">   17591 </span>            :   // For example:</a>
<a name="17592"><span class="lineNum">   17592 </span>            :   //      template &lt; typename T &gt;</a>
<a name="17593"><span class="lineNum">   17593 </span>            :   //      template &lt; typename S &gt;</a>
<a name="17594"><span class="lineNum">   17594 </span>            :   //      void X&lt;T&gt;::A&lt;S&gt;::foobar (int x) { int a_value; }</a>
<a name="17595"><span class="lineNum">   17595 </span>            :   // Requires the template header string: &quot;template &lt; typename T &gt; template &lt; typename S &gt;&quot;</a>
<a name="17596"><span class="lineNum">   17596 </span>            :   // in addition to the usual name qualification (which here is in terms of template parameters</a>
<a name="17597"><span class="lineNum">   17597 </span>            :   // instead of template arguments (as in a template instantiation), namely &quot;X&lt;T&gt;::A&lt;S&gt;::&quot;).</a>
<a name="17598"><span class="lineNum">   17598 </span>            :   // This new support for template headers also requires a new map of names to template declarations.</a>
<a name="17599"><span class="lineNum">   17599 </span>            : </a>
<a name="17600"><span class="lineNum">   17600 </span>            :   // This is lower level support for the different overloaded setNameQualification() functions.</a>
<a name="17601"><span class="lineNum">   17601 </span>            :   // This function builds up the qualified name as a string and then returns it to be used in</a>
<a name="17602"><span class="lineNum">   17602 </span>            :   // either the map to names or the map to types (two different hash maps).</a>
<a name="17603"><span class="lineNum">   17603 </span><span class="lineCov">       8511 :      string accumulated_template_header_name;</span></a>
<a name="17604"><span class="lineNum">   17604 </span>            : </a>
<a name="17605"><span class="lineNum">   17605 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="17606"><span class="lineNum">   17606 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setTemplateHeaderNameQualificationSupport(): scope = %p = %s = %s inputNameQualificationLength = %d \n&quot;,scope,scope-&gt;class_name().c_str(),SageInterface::get_name(scope).c_str(),inputNameQualificationLength);</a>
<a name="17607"><span class="lineNum">   17607 </span>            : #endif</a>
<a name="17608"><span class="lineNum">   17608 </span>            : </a>
<a name="17609"><span class="lineNum">   17609 </span><span class="lineCov">      22603 :      for (int i = 0; i &lt; inputNameQualificationLength; i++)</span></a>
<a name="17610"><span class="lineNum">   17610 </span>            :         {</a>
<a name="17611"><span class="lineNum">   17611 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="17612"><span class="lineNum">   17612 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;   --- In loop: i = %d scope = %p = %s = %s \n&quot;,i,scope,scope-&gt;class_name().c_str(),SageInterface::get_name(scope).c_str());</a>
<a name="17613"><span class="lineNum">   17613 </span>            : #endif</a>
<a name="17614"><span class="lineNum">   17614 </span><span class="lineCov">      28184 :           string template_header_name;</span></a>
<a name="17615"><span class="lineNum">   17615 </span>            : </a>
<a name="17616"><span class="lineNum">   17616 </span>            :        // DQ (9/7/2014): Added case for template class definitions (which we were not using and thus</a>
<a name="17617"><span class="lineNum">   17617 </span>            :        // it was not a problem that we didn't compute them quite right).  These were being computed</a>
<a name="17618"><span class="lineNum">   17618 </span>            :        // as &quot;class-name::class-name&quot;, but we need then to be computed to be:</a>
<a name="17619"><span class="lineNum">   17619 </span>            :        // &quot;class-name&lt;template-parameter&gt;::class-name&lt;template-parameter&gt;&quot; instead.</a>
<a name="17620"><span class="lineNum">   17620 </span>            :        // Other logic will have to add the template header where these are used (not clear how to</a>
<a name="17621"><span class="lineNum">   17621 </span>            :        // do that if we don't do it here).</a>
<a name="17622"><span class="lineNum">   17622 </span><span class="lineCov">      14092 :           SgTemplateClassDefinition* templateClassDefinition = isSgTemplateClassDefinition(scope);</span></a>
<a name="17623"><span class="lineNum">   17623 </span><span class="lineCov">      14092 :           if (templateClassDefinition != NULL)</span></a>
<a name="17624"><span class="lineNum">   17624 </span>            :              {</a>
<a name="17625"><span class="lineNum">   17625 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="17626"><span class="lineNum">   17626 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Found SgTemplateClassDefinition: templateClassDefinition = %p = %s \n&quot;,templateClassDefinition,templateClassDefinition-&gt;class_name().c_str());</a>
<a name="17627"><span class="lineNum">   17627 </span>            : #endif</a>
<a name="17628"><span class="lineNum">   17628 </span><span class="lineCov">       6056 :                SgTemplateClassDeclaration* templateClassDeclaration = templateClassDefinition-&gt;get_declaration();</span></a>
<a name="17629"><span class="lineNum">   17629 </span><span class="lineCov">       6056 :                ASSERT_not_null(templateClassDeclaration);</span></a>
<a name="17630"><span class="lineNum">   17630 </span>            : </a>
<a name="17631"><span class="lineNum">   17631 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="17632"><span class="lineNum">   17632 </span>            :             // This is the normalized name (without name qualification for internal template arguments)</a>
<a name="17633"><span class="lineNum">   17633 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;templateClassDeclaration-&gt;get_name()          = %s \n&quot;,templateClassDeclaration-&gt;get_name().str());</a>
<a name="17634"><span class="lineNum">   17634 </span>            : </a>
<a name="17635"><span class="lineNum">   17635 </span>            :             // This is the name of the template (without and internal template arguments)</a>
<a name="17636"><span class="lineNum">   17636 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;templateClassDeclaration-&gt;get_templateName() = %s \n&quot;,templateClassDeclaration-&gt;get_templateName().str());</a>
<a name="17637"><span class="lineNum">   17637 </span>            : #endif</a>
<a name="17638"><span class="lineNum">   17638 </span>            : #if 0</a>
<a name="17639"><span class="lineNum">   17639 </span>            :                SgUnparse_Info* unparseInfoPointer = new SgUnparse_Info();</a>
<a name="17640"><span class="lineNum">   17640 </span>            :                ASSERT_not_null(unparseInfoPointer);</a>
<a name="17641"><span class="lineNum">   17641 </span>            :                unparseInfoPointer-&gt;set_outputCompilerGeneratedStatements();</a>
<a name="17642"><span class="lineNum">   17642 </span>            : #endif</a>
<a name="17643"><span class="lineNum">   17643 </span>            :             // templateClassDeclaration-&gt;get_file_info()-&gt;display(&quot;SgTemplateInstantiationDecl trying to generate the qualified name: debug&quot;);</a>
<a name="17644"><span class="lineNum">   17644 </span>            : </a>
<a name="17645"><span class="lineNum">   17645 </span><span class="lineCov">       6056 :                SgTemplateParameterPtrList &amp; templateParameterList = templateClassDeclaration-&gt;get_templateParameters();</span></a>
<a name="17646"><span class="lineNum">   17646 </span><span class="lineCov">       6056 :                if (templateParameterList.empty() == false)</span></a>
<a name="17647"><span class="lineNum">   17647 </span>            :                   {</a>
<a name="17648"><span class="lineNum">   17648 </span><span class="lineCov">      11956 :                string template_name = buildTemplateHeaderString(templateParameterList);</span></a>
<a name="17649"><span class="lineNum">   17649 </span><span class="lineCov">       5978 :                template_header_name = template_name;</span></a>
<a name="17650"><span class="lineNum">   17650 </span>            :                   }</a>
<a name="17651"><span class="lineNum">   17651 </span>            : #if 0</a>
<a name="17652"><span class="lineNum">   17652 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="17653"><span class="lineNum">   17653 </span>            :                ROSE_ABORT();</a>
<a name="17654"><span class="lineNum">   17654 </span>            : #endif</a>
<a name="17655"><span class="lineNum">   17655 </span>            :              }</a>
<a name="17656"><span class="lineNum">   17656 </span>            : </a>
<a name="17657"><span class="lineNum">   17657 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3)</a>
<a name="17658"><span class="lineNum">   17658 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setTemplateHeaderNameQualificationSupport(): template_header_name = %s accumulated_template_header_name = %s \n&quot;,template_header_name.c_str(),accumulated_template_header_name.c_str());</a>
<a name="17659"><span class="lineNum">   17659 </span>            : #endif</a>
<a name="17660"><span class="lineNum">   17660 </span><span class="lineCov">      14092 :           accumulated_template_header_name = template_header_name + accumulated_template_header_name;</span></a>
<a name="17661"><span class="lineNum">   17661 </span>            : </a>
<a name="17662"><span class="lineNum">   17662 </span>            :        // We have to loop over scopes that are not named scopes!</a>
<a name="17663"><span class="lineNum">   17663 </span><span class="lineCov">      14092 :           scope = scope-&gt;get_scope();</span></a>
<a name="17664"><span class="lineNum">   17664 </span>            :         }</a>
<a name="17665"><span class="lineNum">   17665 </span>            : </a>
<a name="17666"><span class="lineNum">   17666 </span><span class="lineCov">      17022 :      ROSE_ASSERT(accumulated_template_header_name.substr(0,2) != &quot;0x&quot;);</span></a>
<a name="17667"><span class="lineNum">   17667 </span>            : </a>
<a name="17668"><span class="lineNum">   17668 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || 0</a>
<a name="17669"><span class="lineNum">   17669 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::setTemplateHeaderNameQualificationSupport(): accumulated_template_header_name = %s \n&quot;,accumulated_template_header_name.c_str());</a>
<a name="17670"><span class="lineNum">   17670 </span>            : #endif</a>
<a name="17671"><span class="lineNum">   17671 </span>            : #if 0</a>
<a name="17672"><span class="lineNum">   17672 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="17673"><span class="lineNum">   17673 </span>            :      ROSE_ABORT();</a>
<a name="17674"><span class="lineNum">   17674 </span>            : #endif</a>
<a name="17675"><span class="lineNum">   17675 </span>            : </a>
<a name="17676"><span class="lineNum">   17676 </span><span class="lineCov">       8511 :      return accumulated_template_header_name;</span></a>
<a name="17677"><span class="lineNum">   17677 </span>            :    }</a>
<a name="17678"><span class="lineNum">   17678 </span>            : </a>
<a name="17679"><span class="lineNum">   17679 </span>            : </a>
<a name="17680"><span class="lineNum">   17680 </span>            : string</a>
<a name="17681"><span class="lineNum">   17681 </span><span class="lineCov">       5978 : NameQualificationTraversal::buildTemplateHeaderString ( SgTemplateParameterPtrList &amp; templateParameterList )</span></a>
<a name="17682"><span class="lineNum">   17682 </span>            :    {</a>
<a name="17683"><span class="lineNum">   17683 </span><span class="lineCov">       5978 :      SgUnparse_Info* unparseInfoPointer = new SgUnparse_Info();</span></a>
<a name="17684"><span class="lineNum">   17684 </span><span class="lineCov">       5978 :      ASSERT_not_null(unparseInfoPointer);</span></a>
<a name="17685"><span class="lineNum">   17685 </span><span class="lineCov">       5978 :      unparseInfoPointer-&gt;set_outputCompilerGeneratedStatements();</span></a>
<a name="17686"><span class="lineNum">   17686 </span>            : </a>
<a name="17687"><span class="lineNum">   17687 </span>            : #if 0</a>
<a name="17688"><span class="lineNum">   17688 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::buildTemplateHeaderString(): templateParameterList.size() = %zu \n&quot;,templateParameterList.size());</a>
<a name="17689"><span class="lineNum">   17689 </span>            : #endif</a>
<a name="17690"><span class="lineNum">   17690 </span>            : </a>
<a name="17691"><span class="lineNum">   17691 </span><span class="lineCov">       5978 :      string template_name = &quot;template &lt; &quot;;</span></a>
<a name="17692"><span class="lineNum">   17692 </span>            :   // mfprintf(mlog [ WARN ] ) (&quot;START: template_name = %s \n&quot;,template_name.c_str());</a>
<a name="17693"><span class="lineNum">   17693 </span><span class="lineCov">       5978 :      SgTemplateParameterPtrList::iterator i = templateParameterList.begin();</span></a>
<a name="17694"><span class="lineNum">   17694 </span><span class="lineCov">      16068 :      while (i != templateParameterList.end())</span></a>
<a name="17695"><span class="lineNum">   17695 </span>            :         {</a>
<a name="17696"><span class="lineNum">   17696 </span>            : #if 0</a>
<a name="17697"><span class="lineNum">   17697 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::buildTemplateHeaderString(): Check for the type of the template parameters (could be non-type, etc.) \n&quot;);</a>
<a name="17698"><span class="lineNum">   17698 </span>            : #endif</a>
<a name="17699"><span class="lineNum">   17699 </span><span class="lineCov">      10090 :           SgTemplateParameter* templateParameter = *i;</span></a>
<a name="17700"><span class="lineNum">   17700 </span><span class="lineCov">      10090 :           ASSERT_not_null(templateParameter);</span></a>
<a name="17701"><span class="lineNum">   17701 </span>            : </a>
<a name="17702"><span class="lineNum">   17702 </span>            :        // Maybe the unparser support should optionally insert the &quot;typename&quot; or other parameter kind support.</a>
<a name="17703"><span class="lineNum">   17703 </span><span class="lineCov">      20180 :           string template_parameter_name = globalUnparseToString(templateParameter,unparseInfoPointer);</span></a>
<a name="17704"><span class="lineNum">   17704 </span>            : </a>
<a name="17705"><span class="lineNum">   17705 </span><span class="lineCov">      10090 :           bool template_parameter_name_has_been_output = false;</span></a>
<a name="17706"><span class="lineNum">   17706 </span>            : </a>
<a name="17707"><span class="lineNum">   17707 </span>            :        // DQ (9/10/2014): We only want to output the &quot;typename&quot; when it is required (and exactly when it is required is not clear).</a>
<a name="17708"><span class="lineNum">   17708 </span>            :        // Note that in C++ using &quot;class&quot; or &quot;typename&quot; is equivalent.</a>
<a name="17709"><span class="lineNum">   17709 </span>            :        // template_name += &quot;typename &quot;;</a>
<a name="17710"><span class="lineNum">   17710 </span><span class="lineCov">      10090 :           switch(templateParameter-&gt;get_parameterType())</span></a>
<a name="17711"><span class="lineNum">   17711 </span>            :              {</a>
<a name="17712"><span class="lineNum">   17712 </span>            :             // Only type parameters should require &quot;typename&quot; (but not if the type was explicit).</a>
<a name="17713"><span class="lineNum">   17713 </span><span class="lineCov">      10024 :                case SgTemplateParameter::type_parameter:</span></a>
<a name="17714"><span class="lineNum">   17714 </span><span class="lineCov">      10024 :                   {</span></a>
<a name="17715"><span class="lineNum">   17715 </span>            :                  // DQ (9/10/2014): Added support for case SgTemplateParameter::type_parameter.</a>
<a name="17716"><span class="lineNum">   17716 </span><span class="lineCov">      10024 :                     SgType* type = templateParameter-&gt;get_type();</span></a>
<a name="17717"><span class="lineNum">   17717 </span><span class="lineCov">      10024 :                     ASSERT_not_null(type);</span></a>
<a name="17718"><span class="lineNum">   17718 </span>            : #if 0</a>
<a name="17719"><span class="lineNum">   17719 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::buildTemplateHeaderString(): case SgTemplateParameter::type_parameter: type = %p = %s \n&quot;,type,type-&gt;class_name().c_str());</a>
<a name="17720"><span class="lineNum">   17720 </span>            : #endif</a>
<a name="17721"><span class="lineNum">   17721 </span>            :                  // If the type was explicit then don't output a redundant &quot;typename&quot;.</a>
<a name="17722"><span class="lineNum">   17722 </span><span class="lineCov">      10024 :                     SgTemplateType* templateType = isSgTemplateType(type);</span></a>
<a name="17723"><span class="lineNum">   17723 </span><span class="lineCov">      10024 :                     if (templateType == NULL)</span></a>
<a name="17724"><span class="lineNum">   17724 </span>            :                        {</a>
<a name="17725"><span class="lineNum">   17725 </span>            :                       // This might tell us when to use &quot;class: instead of &quot;typename&quot; but since they are equivalent we can prefer to output &quot;typename&quot;.</a>
<a name="17726"><span class="lineNum">   17726 </span><span class="lineCov">      10024 :                          SgClassType* classType = isSgClassType(type);</span></a>
<a name="17727"><span class="lineNum">   17727 </span><span class="lineCov">      10024 :                          if (classType != NULL)</span></a>
<a name="17728"><span class="lineNum">   17728 </span>            :                             {</a>
<a name="17729"><span class="lineNum">   17729 </span>            :                            // DQ (9/13/2014): See test2014_224.C for where this is required.</a>
<a name="17730"><span class="lineNum">   17730 </span><span class="lineNoCov">          0 :                               template_name += &quot;typename &quot;;</span></a>
<a name="17731"><span class="lineNum">   17731 </span>            :                            // string name = classType-&gt;get_name();</a>
<a name="17732"><span class="lineNum">   17732 </span>            :                            // curprint(name);</a>
<a name="17733"><span class="lineNum">   17733 </span>            :                             }</a>
<a name="17734"><span class="lineNum">   17734 </span>            :                            else</a>
<a name="17735"><span class="lineNum">   17735 </span>            :                             {</a>
<a name="17736"><span class="lineNum">   17736 </span>            :                            // SgUnparse_Info ninfo(info);</a>
<a name="17737"><span class="lineNum">   17737 </span>            :                            // unp-&gt;u_type-&gt;unparseType(type,ninfo);</a>
<a name="17738"><span class="lineNum">   17738 </span>            :                             }</a>
<a name="17739"><span class="lineNum">   17739 </span>            :                        }</a>
<a name="17740"><span class="lineNum">   17740 </span>            :                       else</a>
<a name="17741"><span class="lineNum">   17741 </span>            :                        {</a>
<a name="17742"><span class="lineNum">   17742 </span><span class="lineNoCov">          0 :                          template_name += &quot;typename &quot;;</span></a>
<a name="17743"><span class="lineNum">   17743 </span>            : #if 0</a>
<a name="17744"><span class="lineNum">   17744 </span>            :                          string name = templateType-&gt;get_name();</a>
<a name="17745"><span class="lineNum">   17745 </span>            : #if 0</a>
<a name="17746"><span class="lineNum">   17746 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::buildTemplateHeaderString(): case SgTemplateParameter::type_parameter: type-&gt;get_name() = %s \n&quot;,name.c_str());</a>
<a name="17747"><span class="lineNum">   17747 </span>            : #endif</a>
<a name="17748"><span class="lineNum">   17748 </span>            :                       // unp-&gt;u_exprStmt-&gt;curprint(&quot; typename &quot;);</a>
<a name="17749"><span class="lineNum">   17749 </span>            :                          curprint(name);</a>
<a name="17750"><span class="lineNum">   17750 </span>            : #endif</a>
<a name="17751"><span class="lineNum">   17751 </span>            :                        }</a>
<a name="17752"><span class="lineNum">   17752 </span>            : </a>
<a name="17753"><span class="lineNum">   17753 </span>            :                     break;</a>
<a name="17754"><span class="lineNum">   17754 </span>            :                   }</a>
<a name="17755"><span class="lineNum">   17755 </span>            : </a>
<a name="17756"><span class="lineNum">   17756 </span>            :             // Non-type parameters should not require &quot;typename&quot;.</a>
<a name="17757"><span class="lineNum">   17757 </span><span class="lineCov">         66 :                case SgTemplateParameter::nontype_parameter:</span></a>
<a name="17758"><span class="lineNum">   17758 </span><span class="lineCov">         66 :                   {</span></a>
<a name="17759"><span class="lineNum">   17759 </span><span class="lineCov">         66 :                     if (templateParameter-&gt;get_expression() != NULL)</span></a>
<a name="17760"><span class="lineNum">   17760 </span>            :                        {</a>
<a name="17761"><span class="lineNum">   17761 </span>            :                       // unp-&gt;u_exprStmt-&gt;unparseExpression(templateParameter-&gt;get_expression(),info);</a>
<a name="17762"><span class="lineNum">   17762 </span>            :                        }</a>
<a name="17763"><span class="lineNum">   17763 </span>            :                       else</a>
<a name="17764"><span class="lineNum">   17764 </span>            :                        {</a>
<a name="17765"><span class="lineNum">   17765 </span><span class="lineCov">         66 :                          if (templateParameter-&gt;get_initializedName() == NULL)</span></a>
<a name="17766"><span class="lineNum">   17766 </span>            :                             {</a>
<a name="17767"><span class="lineNum">   17767 </span>            :                            // Not clear what this is?</a>
<a name="17768"><span class="lineNum">   17768 </span>            :                             }</a>
<a name="17769"><span class="lineNum">   17769 </span><span class="lineCov">         66 :                          ASSERT_not_null(templateParameter-&gt;get_initializedName());</span></a>
<a name="17770"><span class="lineNum">   17770 </span>            : </a>
<a name="17771"><span class="lineNum">   17771 </span><span class="lineCov">         66 :                          SgType* type = templateParameter-&gt;get_initializedName()-&gt;get_type();</span></a>
<a name="17772"><span class="lineNum">   17772 </span><span class="lineCov">         66 :                          ASSERT_not_null(type);</span></a>
<a name="17773"><span class="lineNum">   17773 </span>            : #if 0</a>
<a name="17774"><span class="lineNum">   17774 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;In NameQualificationTraversal::buildTemplateHeaderString(): case SgTemplateParameter::nontype_parameter: type = %p = %s \n&quot;,type,type-&gt;class_name().c_str());</a>
<a name="17775"><span class="lineNum">   17775 </span>            : #endif</a>
<a name="17776"><span class="lineNum">   17776 </span>            :                       // unp-&gt;u_type-&gt;outputType&lt;SgInitializedName&gt;(templateParameter-&gt;get_initializedName(),type,info);</a>
<a name="17777"><span class="lineNum">   17777 </span><span class="lineCov">         66 :                          SgUnparse_Info* unparseInfoPointer = new SgUnparse_Info();</span></a>
<a name="17778"><span class="lineNum">   17778 </span><span class="lineCov">         66 :                          ASSERT_not_null(unparseInfoPointer);</span></a>
<a name="17779"><span class="lineNum">   17779 </span><span class="lineCov">         66 :                          unparseInfoPointer-&gt;set_outputCompilerGeneratedStatements();</span></a>
<a name="17780"><span class="lineNum">   17780 </span>            : </a>
<a name="17781"><span class="lineNum">   17781 </span><span class="lineCov">         66 :                          unparseInfoPointer-&gt;set_isTypeFirstPart();</span></a>
<a name="17782"><span class="lineNum">   17782 </span>            : </a>
<a name="17783"><span class="lineNum">   17783 </span><span class="lineCov">         66 :                          string template_parameter_name_1stpart = globalUnparseToString(type,unparseInfoPointer);</span></a>
<a name="17784"><span class="lineNum">   17784 </span>            : </a>
<a name="17785"><span class="lineNum">   17785 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || 0</a>
<a name="17786"><span class="lineNum">   17786 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;case SgTemplateParameter::nontype_parameter: templateParameter = %p template_parameter_name_1stpart (globalUnparseToString()) = %s \n&quot;,templateParameter,template_parameter_name_1stpart.c_str());</a>
<a name="17787"><span class="lineNum">   17787 </span>            : #endif</a>
<a name="17788"><span class="lineNum">   17788 </span><span class="lineCov">         66 :                          unparseInfoPointer-&gt;unset_isTypeFirstPart();</span></a>
<a name="17789"><span class="lineNum">   17789 </span>            : </a>
<a name="17790"><span class="lineNum">   17790 </span>            :                       // DQ (9/11/2014): Need to add a space.</a>
<a name="17791"><span class="lineNum">   17791 </span><span class="lineCov">         66 :                          template_parameter_name_1stpart += &quot; &quot;;</span></a>
<a name="17792"><span class="lineNum">   17792 </span>            : </a>
<a name="17793"><span class="lineNum">   17793 </span><span class="lineCov">         66 :                          template_name += template_parameter_name_1stpart;</span></a>
<a name="17794"><span class="lineNum">   17794 </span>            : </a>
<a name="17795"><span class="lineNum">   17795 </span>            :                       // Put out the template parameter name.</a>
<a name="17796"><span class="lineNum">   17796 </span><span class="lineCov">         66 :                          template_name += template_parameter_name;</span></a>
<a name="17797"><span class="lineNum">   17797 </span>            : </a>
<a name="17798"><span class="lineNum">   17798 </span><span class="lineCov">         66 :                          template_parameter_name_has_been_output = true;</span></a>
<a name="17799"><span class="lineNum">   17799 </span>            : </a>
<a name="17800"><span class="lineNum">   17800 </span><span class="lineCov">         66 :                          unparseInfoPointer-&gt;set_isTypeSecondPart();</span></a>
<a name="17801"><span class="lineNum">   17801 </span>            : </a>
<a name="17802"><span class="lineNum">   17802 </span>            :                       // Output the second part of the type.</a>
<a name="17803"><span class="lineNum">   17803 </span><span class="lineCov">        132 :                          string template_parameter_name_2ndpart = globalUnparseToString(type,unparseInfoPointer);</span></a>
<a name="17804"><span class="lineNum">   17804 </span>            : </a>
<a name="17805"><span class="lineNum">   17805 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || 0</a>
<a name="17806"><span class="lineNum">   17806 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;case SgTemplateParameter::nontype_parameter: templateParameter = %p template_parameter_name_2ndpart (globalUnparseToString()) = %s \n&quot;,templateParameter,template_parameter_name_2ndpart.c_str());</a>
<a name="17807"><span class="lineNum">   17807 </span>            : #endif</a>
<a name="17808"><span class="lineNum">   17808 </span><span class="lineCov">         66 :                          template_name += template_parameter_name_2ndpart;</span></a>
<a name="17809"><span class="lineNum">   17809 </span>            : </a>
<a name="17810"><span class="lineNum">   17810 </span>            :                       // This is not really required since the SgUnparse_Info object will not be used further.</a>
<a name="17811"><span class="lineNum">   17811 </span><span class="lineCov">         66 :                          unparseInfoPointer-&gt;unset_isTypeSecondPart();</span></a>
<a name="17812"><span class="lineNum">   17812 </span>            :                        }</a>
<a name="17813"><span class="lineNum">   17813 </span>            :                     break;</a>
<a name="17814"><span class="lineNum">   17814 </span>            :                   }</a>
<a name="17815"><span class="lineNum">   17815 </span>            : </a>
<a name="17816"><span class="lineNum">   17816 </span><span class="lineNoCov">          0 :                case SgTemplateParameter::template_parameter:</span></a>
<a name="17817"><span class="lineNum">   17817 </span><span class="lineNoCov">          0 :                   {</span></a>
<a name="17818"><span class="lineNum">   17818 </span><span class="lineNoCov">          0 :                     ASSERT_not_null(templateParameter-&gt;get_templateDeclaration());</span></a>
<a name="17819"><span class="lineNum">   17819 </span><span class="lineNoCov">          0 :                     SgNonrealDecl* nrdecl = isSgNonrealDecl(templateParameter-&gt;get_templateDeclaration());</span></a>
<a name="17820"><span class="lineNum">   17820 </span><span class="lineNoCov">          0 :                     ASSERT_not_null(nrdecl);</span></a>
<a name="17821"><span class="lineNum">   17821 </span>            : </a>
<a name="17822"><span class="lineNum">   17822 </span><span class="lineNoCov">          0 :                     SgTemplateParameterPtrList &amp; templateParameterList = nrdecl-&gt;get_tpl_params();</span></a>
<a name="17823"><span class="lineNum">   17823 </span>            : </a>
<a name="17824"><span class="lineNum">   17824 </span><span class="lineNoCov">          0 :                     template_name += buildTemplateHeaderString(templateParameterList);</span></a>
<a name="17825"><span class="lineNum">   17825 </span>            : </a>
<a name="17826"><span class="lineNum">   17826 </span>            :                  // Not clear if this should always be marked as &quot;class&quot;.</a>
<a name="17827"><span class="lineNum">   17827 </span>            :                  // TV (04/06/2018): not always (rarely?) necessary...</a>
<a name="17828"><span class="lineNum">   17828 </span><span class="lineNoCov">          0 :                     template_name += &quot;class &quot;;</span></a>
<a name="17829"><span class="lineNum">   17829 </span>            : #if 0</a>
<a name="17830"><span class="lineNum">   17830 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;buildTemplateHeaderString(): case SgTemplateParameter::template_parameter: Sorry, not implemented (ignored) \n&quot;);</a>
<a name="17831"><span class="lineNum">   17831 </span>            :                     ROSE_ABORT();</a>
<a name="17832"><span class="lineNum">   17832 </span>            : #endif</a>
<a name="17833"><span class="lineNum">   17833 </span>            :                     break;</a>
<a name="17834"><span class="lineNum">   17834 </span>            :                   }</a>
<a name="17835"><span class="lineNum">   17835 </span>            : </a>
<a name="17836"><span class="lineNum">   17836 </span><span class="lineNoCov">          0 :                default:</span></a>
<a name="17837"><span class="lineNum">   17837 </span><span class="lineNoCov">          0 :                   {</span></a>
<a name="17838"><span class="lineNum">   17838 </span><span class="lineNoCov">          0 :                     mfprintf(mlog [ WARN ] ) (&quot;Error: buildTemplateHeaderString(): default reached \n&quot;);</span></a>
<a name="17839"><span class="lineNum">   17839 </span><span class="lineNoCov">          0 :                     ROSE_ABORT();</span></a>
<a name="17840"><span class="lineNum">   17840 </span>            :                   }</a>
<a name="17841"><span class="lineNum">   17841 </span>            :              }</a>
<a name="17842"><span class="lineNum">   17842 </span>            : </a>
<a name="17843"><span class="lineNum">   17843 </span>            : #if (DEBUG_NAME_QUALIFICATION_LEVEL &gt; 3) || 0</a>
<a name="17844"><span class="lineNum">   17844 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;templateParameter = %p template_parameter_name (globalUnparseToString()) = %s \n&quot;,templateParameter,template_parameter_name.c_str());</a>
<a name="17845"><span class="lineNum">   17845 </span>            : #endif</a>
<a name="17846"><span class="lineNum">   17846 </span>            :        // template_name += template_parameter_name;</a>
<a name="17847"><span class="lineNum">   17847 </span><span class="lineCov">         66 :           if (template_parameter_name_has_been_output == false)</span></a>
<a name="17848"><span class="lineNum">   17848 </span>            :              {</a>
<a name="17849"><span class="lineNum">   17849 </span><span class="lineCov">      10024 :                template_name += template_parameter_name;</span></a>
<a name="17850"><span class="lineNum">   17850 </span>            :              }</a>
<a name="17851"><span class="lineNum">   17851 </span><span class="lineCov">      10090 :           i++;</span></a>
<a name="17852"><span class="lineNum">   17852 </span>            : </a>
<a name="17853"><span class="lineNum">   17853 </span><span class="lineCov">      10090 :           if (i != templateParameterList.end())</span></a>
<a name="17854"><span class="lineNum">   17854 </span><span class="lineCov">      10090 :                template_name += &quot;,&quot;;</span></a>
<a name="17855"><span class="lineNum">   17855 </span>            :         }</a>
<a name="17856"><span class="lineNum">   17856 </span>            : </a>
<a name="17857"><span class="lineNum">   17857 </span><span class="lineCov">       5978 :      template_name += &quot; &gt; &quot;;</span></a>
<a name="17858"><span class="lineNum">   17858 </span>            : </a>
<a name="17859"><span class="lineNum">   17859 </span>            : #if 0</a>
<a name="17860"><span class="lineNum">   17860 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;Leaving buildTemplateHeaderString(): template_name = %s \n&quot;,template_name.c_str());</a>
<a name="17861"><span class="lineNum">   17861 </span>            : #endif</a>
<a name="17862"><span class="lineNum">   17862 </span>            : </a>
<a name="17863"><span class="lineNum">   17863 </span><span class="lineCov">       5978 :      return template_name;</span></a>
<a name="17864"><span class="lineNum">   17864 </span>            :    }</a>
<a name="17865"><span class="lineNum">   17865 </span>            : </a>
<a name="17866"><span class="lineNum">   17866 </span>            : </a>
<a name="17867"><span class="lineNum">   17867 </span>            : </a>
<a name="17868"><span class="lineNum">   17868 </span>            : // DQ (3/31/2014): Adding support for global qualifiction.</a>
<a name="17869"><span class="lineNum">   17869 </span>            : size_t</a>
<a name="17870"><span class="lineNum">   17870 </span><span class="lineCov">       3263 : NameQualificationTraversal::depthOfGlobalNameQualification(SgDeclarationStatement* declaration)</span></a>
<a name="17871"><span class="lineNum">   17871 </span>            :    {</a>
<a name="17872"><span class="lineNum">   17872 </span><span class="lineCov">       3263 :      ASSERT_not_null(declaration);</span></a>
<a name="17873"><span class="lineNum">   17873 </span>            : #if 0</a>
<a name="17874"><span class="lineNum">   17874 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In depthOfGlobalNameQualification(): declaration = %p = %s \n&quot;,declaration,declaration-&gt;class_name().c_str());</a>
<a name="17875"><span class="lineNum">   17875 </span>            : #endif</a>
<a name="17876"><span class="lineNum">   17876 </span><span class="lineCov">       3263 :      size_t depthOfNameQualification = 0;</span></a>
<a name="17877"><span class="lineNum">   17877 </span>            : </a>
<a name="17878"><span class="lineNum">   17878 </span><span class="lineCov">       3263 :      SgScopeStatement* scope = declaration-&gt;get_scope();</span></a>
<a name="17879"><span class="lineNum">   17879 </span><span class="lineCov">       4152 :      while (isSgGlobal(scope) == NULL)</span></a>
<a name="17880"><span class="lineNum">   17880 </span>            :         {</a>
<a name="17881"><span class="lineNum">   17881 </span>            : #if 0</a>
<a name="17882"><span class="lineNum">   17882 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;   --- scope = %p = %s \n&quot;,scope,scope-&gt;class_name().c_str());</a>
<a name="17883"><span class="lineNum">   17883 </span>            : #endif</a>
<a name="17884"><span class="lineNum">   17884 </span><span class="lineCov">        889 :           if (scope-&gt;isNamedScope() == true)</span></a>
<a name="17885"><span class="lineNum">   17885 </span>            :              {</a>
<a name="17886"><span class="lineNum">   17886 </span><span class="lineCov">        889 :                depthOfNameQualification++;</span></a>
<a name="17887"><span class="lineNum">   17887 </span>            : #if 0</a>
<a name="17888"><span class="lineNum">   17888 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Incrementing depthOfNameQualification = %&quot; PRIuPTR &quot; \n&quot;,depthOfNameQualification);</a>
<a name="17889"><span class="lineNum">   17889 </span>            : #endif</a>
<a name="17890"><span class="lineNum">   17890 </span>            :              }</a>
<a name="17891"><span class="lineNum">   17891 </span>            : </a>
<a name="17892"><span class="lineNum">   17892 </span><span class="lineCov">        889 :           scope = scope-&gt;get_scope();</span></a>
<a name="17893"><span class="lineNum">   17893 </span>            : #if 0</a>
<a name="17894"><span class="lineNum">   17894 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;   --- (after scope-&gt;get_scope()): scope = %p = %s \n&quot;,scope,scope-&gt;class_name().c_str());</a>
<a name="17895"><span class="lineNum">   17895 </span>            : #endif</a>
<a name="17896"><span class="lineNum">   17896 </span>            :         }</a>
<a name="17897"><span class="lineNum">   17897 </span>            : </a>
<a name="17898"><span class="lineNum">   17898 </span>            : #if 0</a>
<a name="17899"><span class="lineNum">   17899 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;In depthOfGlobalNameQualification(): depthOfNameQualification = %&quot; PRIuPTR &quot; \n&quot;,depthOfNameQualification);</a>
<a name="17900"><span class="lineNum">   17900 </span>            : #endif</a>
<a name="17901"><span class="lineNum">   17901 </span>            : </a>
<a name="17902"><span class="lineNum">   17902 </span><span class="lineCov">       3263 :      return depthOfNameQualification;</span></a>
<a name="17903"><span class="lineNum">   17903 </span>            :    }</a>
<a name="17904"><span class="lineNum">   17904 </span>            : </a>
<a name="17905"><span class="lineNum">   17905 </span>            : </a>
<a name="17906"><span class="lineNum">   17906 </span>            : // DQ (1/24/2019): display accumulated private base class map.</a>
<a name="17907"><span class="lineNum">   17907 </span>            : void</a>
<a name="17908"><span class="lineNum">   17908 </span><span class="lineNoCov">          0 : NameQualificationTraversal::displayBaseClassMap ( const string &amp; label, BaseClassSetMap &amp; x )</span></a>
<a name="17909"><span class="lineNum">   17909 </span>            :    {</a>
<a name="17910"><span class="lineNum">   17910 </span>            :   // std::map&lt;SgClassDeclaration*,std::set&lt;SgClassDeclaration*&gt; &gt; privateBaseClassSets );</a>
<a name="17911"><span class="lineNum">   17911 </span>            : </a>
<a name="17912"><span class="lineNum">   17912 </span><span class="lineNoCov">          0 :      mfprintf(mlog [ WARN ] ) (&quot;In displayBaseClassMap(): label = %s \n&quot;,label.c_str());</span></a>
<a name="17913"><span class="lineNum">   17913 </span>            : </a>
<a name="17914"><span class="lineNum">   17914 </span>            :   // std::map&lt;SgClassDeclaration*,std::set&lt;SgClassDeclaration*&gt; &gt;::iterator i = x.begin();</a>
<a name="17915"><span class="lineNum">   17915 </span><span class="lineNoCov">          0 :      BaseClassSetMap::iterator i = x.begin();</span></a>
<a name="17916"><span class="lineNum">   17916 </span><span class="lineNoCov">          0 :      while (i != x.end())</span></a>
<a name="17917"><span class="lineNum">   17917 </span>            :         {</a>
<a name="17918"><span class="lineNum">   17918 </span><span class="lineNoCov">          0 :           SgClassDeclaration*             derivedClassDeclaration = i-&gt;first;</span></a>
<a name="17919"><span class="lineNum">   17919 </span><span class="lineNoCov">          0 :           std::set&lt;SgClassDeclaration*&gt; &amp; privateBaseClasses      = i-&gt;second;</span></a>
<a name="17920"><span class="lineNum">   17920 </span>            : </a>
<a name="17921"><span class="lineNum">   17921 </span><span class="lineNoCov">          0 :           mfprintf(mlog [ WARN ] ) (&quot;  --- derivedClassDeclaration = %p = %s name = %s \n&quot;,derivedClassDeclaration,derivedClassDeclaration-&gt;class_name().c_str(),derivedClassDeclaration-&gt;get_name().str());</span></a>
<a name="17922"><span class="lineNum">   17922 </span><span class="lineNoCov">          0 :           mfprintf(mlog [ WARN ] ) (&quot;  --- privateBaseClasses.size() = %zu \n&quot;,privateBaseClasses.size());</span></a>
<a name="17923"><span class="lineNum">   17923 </span>            : </a>
<a name="17924"><span class="lineNum">   17924 </span><span class="lineNoCov">          0 :           std::set&lt;SgClassDeclaration*&gt;::const_iterator j = privateBaseClasses.begin();</span></a>
<a name="17925"><span class="lineNum">   17925 </span><span class="lineNoCov">          0 :           while (j != privateBaseClasses.end())</span></a>
<a name="17926"><span class="lineNum">   17926 </span>            :              {</a>
<a name="17927"><span class="lineNum">   17927 </span><span class="lineNoCov">          0 :                SgClassDeclaration* privateBaseClassDeclaration = *j;</span></a>
<a name="17928"><span class="lineNum">   17928 </span><span class="lineNoCov">          0 :                ASSERT_not_null(privateBaseClassDeclaration);</span></a>
<a name="17929"><span class="lineNum">   17929 </span>            : </a>
<a name="17930"><span class="lineNum">   17930 </span><span class="lineNoCov">          0 :                mfprintf(mlog [ WARN ] ) (&quot;  --- --- privateBaseClassDeclaration = %p = %s name = %s \n&quot;,privateBaseClassDeclaration,privateBaseClassDeclaration-&gt;class_name().c_str(),privateBaseClassDeclaration-&gt;get_name().str());</span></a>
<a name="17931"><span class="lineNum">   17931 </span>            : </a>
<a name="17932"><span class="lineNum">   17932 </span><span class="lineNoCov">          0 :                j++;</span></a>
<a name="17933"><span class="lineNum">   17933 </span>            :              }</a>
<a name="17934"><span class="lineNum">   17934 </span><span class="lineNoCov">          0 :           i++;</span></a>
<a name="17935"><span class="lineNum">   17935 </span>            :         }</a>
<a name="17936"><span class="lineNum">   17936 </span>            : </a>
<a name="17937"><span class="lineNum">   17937 </span><span class="lineNoCov">          0 :      mfprintf(mlog [ WARN ] ) (&quot;Leaving displayBaseClassMap(): label = %s \n&quot;,label.c_str());</span></a>
<a name="17938"><span class="lineNum">   17938 </span><span class="lineNoCov">          0 :    }</span></a>
<a name="17939"><span class="lineNum">   17939 </span>            : </a>
<a name="17940"><span class="lineNum">   17940 </span>            : </a>
<a name="17941"><span class="lineNum">   17941 </span>            : // DQ (2/17/2019): Moved this to the name qualification file so we can work on it more easily.</a>
<a name="17942"><span class="lineNum">   17942 </span>            : bool</a>
<a name="17943"><span class="lineNum">   17943 </span><span class="lineCov">       9152 : SgScopeStatement::hasAmbiguity(SgName &amp; name, SgSymbol* symbol)</span></a>
<a name="17944"><span class="lineNum">   17944 </span>            :    {</a>
<a name="17945"><span class="lineNum">   17945 </span>            :   // DQ (2/16/2019): Added to support detection of ambiguity that drives the generation of name qualification.</a>
<a name="17946"><span class="lineNum">   17946 </span>            : </a>
<a name="17947"><span class="lineNum">   17947 </span>            :   // NOTE: in the case where the declaration associated with the symbol is declared in the current scope, we can't have any ambiguity.</a>
<a name="17948"><span class="lineNum">   17948 </span>            : </a>
<a name="17949"><span class="lineNum">   17949 </span>            : #define DEBUG_HAS_AMBIGUITY 0</a>
<a name="17950"><span class="lineNum">   17950 </span>            : </a>
<a name="17951"><span class="lineNum">   17951 </span>            : #if DEBUG_HAS_AMBIGUITY</a>
<a name="17952"><span class="lineNum">   17952 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;\nIn SgScopeStatement::hasAmbiguity(): name = %s symbol = %p = %s \n&quot;,name.str(),symbol,symbol-&gt;class_name().c_str());</a>
<a name="17953"><span class="lineNum">   17953 </span>            : #endif</a>
<a name="17954"><span class="lineNum">   17954 </span>            : </a>
<a name="17955"><span class="lineNum">   17955 </span>            : #if DEBUG_HAS_AMBIGUITY</a>
<a name="17956"><span class="lineNum">   17956 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;Print the symbol table for the current scope = %p = %s \n&quot;,this,this-&gt;class_name().c_str());</a>
<a name="17957"><span class="lineNum">   17957 </span>            :      this-&gt;get_symbol_table()-&gt;print();</a>
<a name="17958"><span class="lineNum">   17958 </span>            : #endif</a>
<a name="17959"><span class="lineNum">   17959 </span>            : </a>
<a name="17960"><span class="lineNum">   17960 </span>            :   // DQ (2/23/2019): This might be a possible alternative way (maybe a better way) to detect possible ambiguity.</a>
<a name="17961"><span class="lineNum">   17961 </span><span class="lineCov">       9152 :      size_t numberOfSymbols = this-&gt;count_symbol (name);</span></a>
<a name="17962"><span class="lineNum">   17962 </span>            : </a>
<a name="17963"><span class="lineNum">   17963 </span>            : #if DEBUG_HAS_AMBIGUITY</a>
<a name="17964"><span class="lineNum">   17964 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;numberOfSymbols = %zu \n&quot;,numberOfSymbols);</a>
<a name="17965"><span class="lineNum">   17965 </span>            : #endif</a>
<a name="17966"><span class="lineNum">   17966 </span>            : </a>
<a name="17967"><span class="lineNum">   17967 </span><span class="lineCov">       9152 :      size_t numberOfAliasSymbols = this-&gt;count_alias_symbol(name);</span></a>
<a name="17968"><span class="lineNum">   17968 </span>            : </a>
<a name="17969"><span class="lineNum">   17969 </span>            : #if DEBUG_HAS_AMBIGUITY</a>
<a name="17970"><span class="lineNum">   17970 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;numberOfAliasSymbols = %zu \n&quot;,numberOfAliasSymbols);</a>
<a name="17971"><span class="lineNum">   17971 </span>            : #endif</a>
<a name="17972"><span class="lineNum">   17972 </span>            : </a>
<a name="17973"><span class="lineNum">   17973 </span><span class="lineCov">       9152 :      bool ambiguityDetected = false;</span></a>
<a name="17974"><span class="lineNum">   17974 </span><span class="lineCov">       9152 :      if (numberOfAliasSymbols &gt; 1)</span></a>
<a name="17975"><span class="lineNum">   17975 </span>            :         {</a>
<a name="17976"><span class="lineNum">   17976 </span>            :        // Detected ambiguity that will require some name qualification.</a>
<a name="17977"><span class="lineNum">   17977 </span>            : </a>
<a name="17978"><span class="lineNum">   17978 </span>            :        // If there are multiple SgAliasSymbols then we need to know if they are associated with the same</a>
<a name="17979"><span class="lineNum">   17979 </span>            :        // base class or different base classes. If all from the same base class then there is no ambiguity.</a>
<a name="17980"><span class="lineNum">   17980 </span>            :        // else if they are from multiple base classes then it is the derivation that is providing the</a>
<a name="17981"><span class="lineNum">   17981 </span>            :        // possible ambiguity, which should be resolved via additional name qualification.</a>
<a name="17982"><span class="lineNum">   17982 </span>            : </a>
<a name="17983"><span class="lineNum">   17983 </span><span class="lineCov">        110 :           std::vector&lt;SgNode*&gt; causalNodeList;</span></a>
<a name="17984"><span class="lineNum">   17984 </span>            : </a>
<a name="17985"><span class="lineNum">   17985 </span><span class="lineCov">         55 :           rose_hash_multimap * internal_table = this-&gt;get_symbol_table()-&gt;get_table();</span></a>
<a name="17986"><span class="lineNum">   17986 </span><span class="lineCov">         55 :           ASSERT_not_null(internal_table);</span></a>
<a name="17987"><span class="lineNum">   17987 </span>            : </a>
<a name="17988"><span class="lineNum">   17988 </span>            : #if DEBUG_HAS_AMBIGUITY</a>
<a name="17989"><span class="lineNum">   17989 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Before loop over symbols \n&quot;);</a>
<a name="17990"><span class="lineNum">   17990 </span>            : #endif</a>
<a name="17991"><span class="lineNum">   17991 </span><span class="lineCov">         55 :           std::pair&lt;rose_hash_multimap::iterator, rose_hash_multimap::iterator&gt; range = internal_table-&gt;equal_range (name);</span></a>
<a name="17992"><span class="lineNum">   17992 </span><span class="lineCov">        165 :           for (rose_hash_multimap::iterator i = range.first; i != range.second; ++i)</span></a>
<a name="17993"><span class="lineNum">   17993 </span>            :              {</a>
<a name="17994"><span class="lineNum">   17994 </span><span class="lineCov">        110 :                SgSymbol * orig_current_symbol = i-&gt;second;</span></a>
<a name="17995"><span class="lineNum">   17995 </span><span class="lineCov">        110 :                ASSERT_not_null(orig_current_symbol);</span></a>
<a name="17996"><span class="lineNum">   17996 </span>            : </a>
<a name="17997"><span class="lineNum">   17997 </span>            : #if DEBUG_HAS_AMBIGUITY</a>
<a name="17998"><span class="lineNum">   17998 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Top of loop over symbols \n&quot;);</a>
<a name="17999"><span class="lineNum">   17999 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;@@@@@@ orig_current_symbol = %p = %s \n&quot;,orig_current_symbol,orig_current_symbol-&gt;class_name().c_str());</a>
<a name="18000"><span class="lineNum">   18000 </span>            : #endif</a>
<a name="18001"><span class="lineNum">   18001 </span><span class="lineCov">        110 :                SgAliasSymbol* aliasSymbol = isSgAliasSymbol(orig_current_symbol);</span></a>
<a name="18002"><span class="lineNum">   18002 </span><span class="lineCov">        110 :                if (aliasSymbol != NULL)</span></a>
<a name="18003"><span class="lineNum">   18003 </span>            :                   {</a>
<a name="18004"><span class="lineNum">   18004 </span><span class="lineCov">        110 :                     size_t causalNodeCount = aliasSymbol-&gt;get_causal_nodes().size();</span></a>
<a name="18005"><span class="lineNum">   18005 </span>            : #if DEBUG_HAS_AMBIGUITY</a>
<a name="18006"><span class="lineNum">   18006 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot; --- causalNodeCount = %zu \n&quot;,causalNodeCount);</a>
<a name="18007"><span class="lineNum">   18007 </span>            : #endif</a>
<a name="18008"><span class="lineNum">   18008 </span><span class="lineCov">        110 :                     if (causalNodeCount == 1)</span></a>
<a name="18009"><span class="lineNum">   18009 </span>            :                        {</a>
<a name="18010"><span class="lineNum">   18010 </span>            :                       // We need to know if each of the alias symbols has a different causal node.</a>
<a name="18011"><span class="lineNum">   18011 </span><span class="lineCov">        110 :                          SgNode* causalNode = aliasSymbol-&gt;get_causal_nodes()[0];</span></a>
<a name="18012"><span class="lineNum">   18012 </span>            : #if DEBUG_HAS_AMBIGUITY</a>
<a name="18013"><span class="lineNum">   18013 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot; --- causalNode = %p \n&quot;,causalNode);</a>
<a name="18014"><span class="lineNum">   18014 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot; --- find(causalNodeList.begin(),causalNodeList.end(),causalNode) == causalNodeList.end() = %s \n&quot;,</a>
<a name="18015"><span class="lineNum">   18015 </span>            :                               find(causalNodeList.begin(),causalNodeList.end(),causalNode) == causalNodeList.end() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="18016"><span class="lineNum">   18016 </span>            : #endif</a>
<a name="18017"><span class="lineNum">   18017 </span><span class="lineCov">        110 :                          if (find(causalNodeList.begin(),causalNodeList.end(),causalNode) == causalNodeList.end())</span></a>
<a name="18018"><span class="lineNum">   18018 </span>            :                             {</a>
<a name="18019"><span class="lineNum">   18019 </span><span class="lineCov">         55 :                               causalNodeList.push_back(causalNode);</span></a>
<a name="18020"><span class="lineNum">   18020 </span>            :                             }</a>
<a name="18021"><span class="lineNum">   18021 </span>            :                        }</a>
<a name="18022"><span class="lineNum">   18022 </span>            :                       else</a>
<a name="18023"><span class="lineNum">   18023 </span>            :                        {</a>
<a name="18024"><span class="lineNum">   18024 </span>            :                       // We have identified an ambiguity.</a>
<a name="18025"><span class="lineNum">   18025 </span>            : </a>
<a name="18026"><span class="lineNum">   18026 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT (causalNodeCount &gt; 1);</span></a>
<a name="18027"><span class="lineNum">   18027 </span>            : #if DEBUG_HAS_AMBIGUITY</a>
<a name="18028"><span class="lineNum">   18028 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot; --- We have identified an ambiguity (causalNodeCount &gt; 1): causalNodeCount = %zu \n&quot;,causalNodeCount);</a>
<a name="18029"><span class="lineNum">   18029 </span>            : #endif</a>
<a name="18030"><span class="lineNum">   18030 </span><span class="lineNoCov">          0 :                          ambiguityDetected = true;</span></a>
<a name="18031"><span class="lineNum">   18031 </span>            :                        }</a>
<a name="18032"><span class="lineNum">   18032 </span>            :                   }</a>
<a name="18033"><span class="lineNum">   18033 </span>            :                  else</a>
<a name="18034"><span class="lineNum">   18034 </span>            :                   {</a>
<a name="18035"><span class="lineNum">   18035 </span>            :                  // DQ (2/17/2019): This case should be addressed.</a>
<a name="18036"><span class="lineNum">   18036 </span>            :                  // I think this means that there is no ambiguity, since it would be through a single class</a>
<a name="18037"><span class="lineNum">   18037 </span>            :                  // (else the base class is mixing alias symbols with the non-alias symbols and it is less</a>
<a name="18038"><span class="lineNum">   18038 </span>            :                  // clear if there is an ambiguity (but there still could be and we would not detect it).</a>
<a name="18039"><span class="lineNum">   18039 </span>            :                  // I need a test code to demonstrate this before it can be properly addressed.</a>
<a name="18040"><span class="lineNum">   18040 </span>            : #if DEBUG_HAS_AMBIGUITY</a>
<a name="18041"><span class="lineNum">   18041 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Note: In SgScopeStatement::hasAmbiguity(): Found a non SgAliasSymbol: orig_current_symbol = %p = %s \n&quot;,</a>
<a name="18042"><span class="lineNum">   18042 </span>            :                          orig_current_symbol,orig_current_symbol-&gt;class_name().c_str());</a>
<a name="18043"><span class="lineNum">   18043 </span>            : #endif</a>
<a name="18044"><span class="lineNum">   18044 </span>            :                   }</a>
<a name="18045"><span class="lineNum">   18045 </span>            : #if DEBUG_HAS_AMBIGUITY</a>
<a name="18046"><span class="lineNum">   18046 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;Bottom of loop over symbols: causalNodeList.size() = %zu \n&quot;,causalNodeList.size());</a>
<a name="18047"><span class="lineNum">   18047 </span>            : #endif</a>
<a name="18048"><span class="lineNum">   18048 </span>            :              }</a>
<a name="18049"><span class="lineNum">   18049 </span>            : </a>
<a name="18050"><span class="lineNum">   18050 </span>            : #if DEBUG_HAS_AMBIGUITY</a>
<a name="18051"><span class="lineNum">   18051 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;After loop over symbols: causalNodeList.size() = %zu \n&quot;,causalNodeList.size());</a>
<a name="18052"><span class="lineNum">   18052 </span>            : #endif</a>
<a name="18053"><span class="lineNum">   18053 </span>            : </a>
<a name="18054"><span class="lineNum">   18054 </span><span class="lineCov">         55 :           if (causalNodeList.size() &gt; 1)</span></a>
<a name="18055"><span class="lineNum">   18055 </span>            :              {</a>
<a name="18056"><span class="lineNum">   18056 </span><span class="lineNoCov">          0 :                ambiguityDetected = true;</span></a>
<a name="18057"><span class="lineNum">   18057 </span>            :              }</a>
<a name="18058"><span class="lineNum">   18058 </span>            : </a>
<a name="18059"><span class="lineNum">   18059 </span>            : #if DEBUG_HAS_AMBIGUITY</a>
<a name="18060"><span class="lineNum">   18060 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Using count_alias_symbol(): Detected ambiguity that will require some name qualification \n&quot;);</a>
<a name="18061"><span class="lineNum">   18061 </span>            : #endif</a>
<a name="18062"><span class="lineNum">   18062 </span>            :        // ambiguityDetected = true;</a>
<a name="18063"><span class="lineNum">   18063 </span>            :         }</a>
<a name="18064"><span class="lineNum">   18064 </span>            :        else</a>
<a name="18065"><span class="lineNum">   18065 </span>            :         {</a>
<a name="18066"><span class="lineNum">   18066 </span>            :        // No ambiguity that will require any name qualification.</a>
<a name="18067"><span class="lineNum">   18067 </span>            : </a>
<a name="18068"><span class="lineNum">   18068 </span>            : #if DEBUG_HAS_AMBIGUITY</a>
<a name="18069"><span class="lineNum">   18069 </span>            :           mfprintf(mlog [ WARN ] ) (&quot;Using count_alias_symbol(): No ambiguity that will require any name qualification \n&quot;);</a>
<a name="18070"><span class="lineNum">   18070 </span>            : #endif</a>
<a name="18071"><span class="lineNum">   18071 </span>            :        // Lookup the SgAliasSymbol in the class scope.</a>
<a name="18072"><span class="lineNum">   18072 </span><span class="lineCov">       9097 :           SgAliasSymbol* aliasSymbol = this-&gt;lookup_alias_symbol(name,symbol);</span></a>
<a name="18073"><span class="lineNum">   18073 </span>            :        // ASSERT_not_null(aliasSymbol);</a>
<a name="18074"><span class="lineNum">   18074 </span><span class="lineCov">       9097 :           if (aliasSymbol != NULL)</span></a>
<a name="18075"><span class="lineNum">   18075 </span>            :              {</a>
<a name="18076"><span class="lineNum">   18076 </span><span class="lineCov">        460 :                ROSE_ASSERT(aliasSymbol-&gt;get_causal_nodes().empty() == false);</span></a>
<a name="18077"><span class="lineNum">   18077 </span><span class="lineCov">        460 :                if (aliasSymbol-&gt;get_causal_nodes().size() &gt; 1)</span></a>
<a name="18078"><span class="lineNum">   18078 </span>            :                   {</a>
<a name="18079"><span class="lineNum">   18079 </span>            :                  // Detected ambiguity that will require some name qualification.</a>
<a name="18080"><span class="lineNum">   18080 </span>            : </a>
<a name="18081"><span class="lineNum">   18081 </span>            : #if DEBUG_HAS_AMBIGUITY</a>
<a name="18082"><span class="lineNum">   18082 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Detected ambiguity that will require some name qualification \n&quot;);</a>
<a name="18083"><span class="lineNum">   18083 </span>            : #endif</a>
<a name="18084"><span class="lineNum">   18084 </span>            :                     ambiguityDetected = true;</a>
<a name="18085"><span class="lineNum">   18085 </span>            :                   }</a>
<a name="18086"><span class="lineNum">   18086 </span>            :                  else</a>
<a name="18087"><span class="lineNum">   18087 </span>            :                   {</a>
<a name="18088"><span class="lineNum">   18088 </span><span class="lineCov">        460 :                     if (numberOfSymbols &gt; 1)</span></a>
<a name="18089"><span class="lineNum">   18089 </span>            :                        {</a>
<a name="18090"><span class="lineNum">   18090 </span>            : #if DEBUG_HAS_AMBIGUITY</a>
<a name="18091"><span class="lineNum">   18091 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;Detected multible SgSymbol are available: consider this an ambiguity: numberOfSymbols = %zu \n&quot;,numberOfSymbols);</a>
<a name="18092"><span class="lineNum">   18092 </span>            : #endif</a>
<a name="18093"><span class="lineNum">   18093 </span><span class="lineCov">          9 :                          ambiguityDetected = true;</span></a>
<a name="18094"><span class="lineNum">   18094 </span>            : #if 0</a>
<a name="18095"><span class="lineNum">   18095 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="18096"><span class="lineNum">   18096 </span>            :                          ROSE_ABORT();</a>
<a name="18097"><span class="lineNum">   18097 </span>            : #endif</a>
<a name="18098"><span class="lineNum">   18098 </span>            :                        }</a>
<a name="18099"><span class="lineNum">   18099 </span>            :                       else</a>
<a name="18100"><span class="lineNum">   18100 </span>            :                        {</a>
<a name="18101"><span class="lineNum">   18101 </span>            :                       // No ambiguity that will require any name qualification.</a>
<a name="18102"><span class="lineNum">   18102 </span>            : </a>
<a name="18103"><span class="lineNum">   18103 </span>            : #if DEBUG_HAS_AMBIGUITY</a>
<a name="18104"><span class="lineNum">   18104 </span>            :                          mfprintf(mlog [ WARN ] ) (&quot;No ambiguity that will require any name qualification \n&quot;);</a>
<a name="18105"><span class="lineNum">   18105 </span>            : #endif</a>
<a name="18106"><span class="lineNum">   18106 </span>            :                        }</a>
<a name="18107"><span class="lineNum">   18107 </span>            :                   }</a>
<a name="18108"><span class="lineNum">   18108 </span>            :              }</a>
<a name="18109"><span class="lineNum">   18109 </span>            :             else</a>
<a name="18110"><span class="lineNum">   18110 </span>            :              {</a>
<a name="18111"><span class="lineNum">   18111 </span>            : #if DEBUG_HAS_AMBIGUITY</a>
<a name="18112"><span class="lineNum">   18112 </span>            :                mfprintf(mlog [ WARN ] ) (&quot;No SgAliasSymbol is available \n&quot;);</a>
<a name="18113"><span class="lineNum">   18113 </span>            : #endif</a>
<a name="18114"><span class="lineNum">   18114 </span><span class="lineCov">       8637 :                if (numberOfSymbols &gt; 1)</span></a>
<a name="18115"><span class="lineNum">   18115 </span>            :                   {</a>
<a name="18116"><span class="lineNum">   18116 </span>            : #if DEBUG_HAS_AMBIGUITY</a>
<a name="18117"><span class="lineNum">   18117 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Detected multible SgSymbol are available: consider this an ambiguity: numberOfSymbols = %zu \n&quot;,numberOfSymbols);</a>
<a name="18118"><span class="lineNum">   18118 </span>            : #endif</a>
<a name="18119"><span class="lineNum">   18119 </span><span class="lineCov">       1535 :                     ambiguityDetected = true;</span></a>
<a name="18120"><span class="lineNum">   18120 </span>            : #if 0</a>
<a name="18121"><span class="lineNum">   18121 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;Exiting as a test! \n&quot;);</a>
<a name="18122"><span class="lineNum">   18122 </span>            :                     ROSE_ABORT();</a>
<a name="18123"><span class="lineNum">   18123 </span>            : #endif</a>
<a name="18124"><span class="lineNum">   18124 </span>            :                   }</a>
<a name="18125"><span class="lineNum">   18125 </span>            :                  else</a>
<a name="18126"><span class="lineNum">   18126 </span>            :                   {</a>
<a name="18127"><span class="lineNum">   18127 </span>            : #if DEBUG_HAS_AMBIGUITY</a>
<a name="18128"><span class="lineNum">   18128 </span>            :                     mfprintf(mlog [ WARN ] ) (&quot;No SgSymbol or only one SgSymbol is available \n&quot;);</a>
<a name="18129"><span class="lineNum">   18129 </span>            : #endif</a>
<a name="18130"><span class="lineNum">   18130 </span>            :                   }</a>
<a name="18131"><span class="lineNum">   18131 </span>            :              }</a>
<a name="18132"><span class="lineNum">   18132 </span>            :         }</a>
<a name="18133"><span class="lineNum">   18133 </span>            : </a>
<a name="18134"><span class="lineNum">   18134 </span>            : #if DEBUG_HAS_AMBIGUITY</a>
<a name="18135"><span class="lineNum">   18135 </span>            :      mfprintf(mlog [ WARN ] ) (&quot;ambiguityDetected = %s \n&quot;,ambiguityDetected ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="18136"><span class="lineNum">   18136 </span>            : #endif</a>
<a name="18137"><span class="lineNum">   18137 </span>            : </a>
<a name="18138"><span class="lineNum">   18138 </span><span class="lineCov">       9152 :      return ambiguityDetected;</span></a>
<a name="18139"><span class="lineNum">   18139 </span>            :    }</a>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.14</a></td></tr>
  </table>
  <br>

</body>
</html>
